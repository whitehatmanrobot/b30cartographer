       SizeInfo[Index].Free
            ||
            SizeInfo[Index].FrontHeapAllocs
            ||
            SizeInfo[Index].FrontHeapFrees) {

            dprintf("%6ld - %6ld   %6ld %6ld %6ld %6ld\n",
                    Index * BucketSize,
                    (Index + 1) * BucketSize,
                    SizeInfo[Index].Busy,
                    SizeInfo[Index].Free,
                    SizeInfo[Index].FrontHeapAllocs,
                    SizeInfo[Index].FrontHeapFrees
                    );

            FEBusy += SizeInfo[Index].FrontHeapAllocs;
            FEFree += SizeInfo[Index].FrontHeapFrees;
            Busy += SizeInfo[Index].Busy;
            Free += SizeInfo[Index].Free;
        }
    }

    dprintf("----------------------------------------------- \n");
    dprintf("  Total           %6I64d %6I64d %6I64d %6I64d \n",
            Busy,
            Free,
            FEBusy,
            FEFree
            );
}

VOID
DumpBlock (
    IN ULONG64 BlockAddress,
    IN UCHAR   Flag
    )
{
    UCHAR Buffer[33];
    PULONG pLongArray = (PULONG)Buffer;
    ULONG i;

    memchr(Buffer, '?', sizeof( Buffer ));

    if (!ReadMemory( BlockAddress, &Buffer[0], sizeof( Buffer ), NULL )) {

        dprintf("%p  ?\n", BlockAddress);

        return;
    }

    dprintf("%p %c %08lx %08lx %08lx %08lx ",
            BlockAddress,
            Flag,
            pLongArray[0],
            pLongArray[1],
            pLongArray[2],
            pLongArray[3]
            );

    for (i = 0; i < 32; i++) {

        if (!isprint(Buffer[i])) {

            Buffer[i] = '.';
        }
    }

    Buffer[32] = 0;

    dprintf("%s\n", Buffer);
}

VOID
CollectHeapInfo(
    ULONG64 HeapAddress
    )
{
    ULONG64 TempValue;
    ULONG64 FrontEndHeapType;

    memset(&CrtHeapStat, 0, sizeof(CrtHeapStat));

    CrtHeapStat.HeapAddress = HeapAddress;

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "TotalFreeSize", CrtHeapStat.FreeSpace);
    CrtHeapStat.FreeSpace *= HeapEntrySize;

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "NonDedicatedListLength", CrtHeapStat.FreeListLength);

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "Flags", TempValue);
    CrtHeapStat.Flags = (ULONG)TempValue;

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "Signature", TempValue);

    if (TempValue != 0xeeffeeff) {
        dprintf("Error: Heap %p has an invalid signature %08lx\n", HeapAddress, 0xeeffeeff);
    }

    if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "LockVariable", TempValue) == 0) {

        if (TempValue != 0) {

            GetFieldValue(TempValue, "ntdll!_RTL_CRITICAL_SECTION", "DebugInfo", TempValue);
            GetFieldValue(TempValue, "ntdll!_RTL_CRITICAL_SECTION_DEBUG", "ContentionCount", CrtHeapStat.LockContention);

        } else {

            CrtHeapStat.LockContention = 0xbad;
        }
    }

    CrtHeapStat.FrontEndHeapType = 0;

    if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "Lookaside", TempValue)) {


        if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeapType", FrontEndHeapType)) {

            dprintf("Front-end heap type info is not available\n");

        } else {

            CrtHeapStat.FrontEndHeapType = (ULONG)FrontEndHeapType;

            GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeap", CrtHeapStat.FrontEndHeap);
        }

    } else {

        if (TempValue) {

            CrtHeapStat.FrontEndHeapType = 1;
        }

        CrtHeapStat.FrontEndHeap = TempValue;
    }
}

typedef struct _BUCKET_INFO {

    ULONG  TotalBlocks;
    ULONG  SubSegmentCounts;
    ULONG BlockUnits;
    ULONG UseAffinity;
    LONG Conversions;

} BUCKET_INFO, *PBUCKET_INFO;

VOID
DumpLowfHeap(
    ULONG64 HeapAddress
    )
{
    ULONG64 TempValue, CrtAddress;
    ULONG64 Head;
    ULONG TempOffset, i;
    ULONG64 Next;
    ULONG Counter, TempSize;
    ULONG Values[20];
    PBUCKET_INFO BucketInfo;
    ULONG CacheSize = GetFieldSize("ntdll!_USER_MEMORY_CACHE", "AvailableBlocks") / sizeof(ULONG);

    if (CacheSize > 20) {

        CacheSize = 20;
    }

    InitTypeRead(HeapAddress, nt!_LFH_HEAP);

    if (GetFieldValue(HeapAddress, "ntdll!_LFH_HEAP", "Lock.DebugInfo", TempValue) == 0) {

        if (TempValue != 0) {

            ULONG64 Contention;

            GetFieldValue(TempValue, "ntdll!_RTL_CRITICAL_SECTION_DEBUG", "ContentionCount", Contention);

            dprintf("       Lock contention  %7ld\n", (ULONG) Contention);
        }
    }

    GetFieldValue(HeapAddress, "ntdll!_LFH_HEAP", "SubSegmentZones.Flink", Head);

    Counter = 0;

    ReadPointer(Head, &Next);

    while (Next != Head) {

        Counter += 1;

        if (!ReadPointer(Next, &Next)) {

            dprintf("ERROR Cannot read SubSegmentZones list at %p\n", Next);

            break;
        }
    }

    dprintf("       Metadata usage   %7ld\n", Counter * 1024);

    dprintf("       Statistics:\n");
    dprintf("           Segments created    %7ld\n", ReadField(SegmentCreate));
    dprintf("           Segments deleted    %7ld\n", ReadField(SegmentDelete));
    dprintf("           Segments reused     %7ld\n", ReadField(SegmentInsertInFree));
    dprintf("           Conversions         %7ld\n", ReadField(Conversions));
    dprintf("           ConvertedSpace      %7ld\n\n", ReadField(ConvertedSpace));

    GetFieldOffset("ntdll!_LFH_HEAP", "UserBlockCache", &TempOffset);

    CrtAddress = TempValue = HeapAddress + TempOffset;

    InitTypeRead(TempValue, nt!_USER_MEMORY_CACHE);
    dprintf("       Block cache:\n");
    dprintf("            Free blocks        %7ld\n", ReadField(FreeBlocks));
    dprintf("            Sequence           %7ld\n", ReadField(Sequence));
    dprintf("            Cache blocks");

    for (i = 0; i < CacheSize; i++) {

        ULONG64 Depth;

        GetFieldValue(TempValue, "ntdll!_SLIST_HEADER", "Depth", Depth);

        dprintf(" %6ld", (ULONG)Depth);
        TempValue += GetTypeSize("_SLIST_HEADER");
    }

    GetFieldOffset("ntdll!_USER_MEMORY_CACHE", "AvailableBlocks", &TempOffset);
    dprintf("\n            Available   ");


    TempValue = CrtAddress + TempOffset;

    if (ReadMemory( TempValue, Values, CacheSize * sizeof(ULONG), NULL )) {

        for (i = 0; i < CacheSize; i++) {

            dprintf(" %6ld", Values[i]);
        }
    }

    dprintf("\n");

    GetFieldOffset("ntdll!_LFH_HEAP", "Buckets", &TempOffset);

    CrtAddress = HeapAddress + TempOffset;
    TempSize = GetTypeSize("nt!_HEAP_BUCKET");

    BucketInfo = (PBUCKET_INFO)malloc(128 * sizeof(BUCKET_INFO));

    if (BucketInfo) {

        dprintf("       Buckets info:\n");
        dprintf("  Size   Blocks  Seg Aff Conv\n");
        dprintf("-----------------------------\n");

        for (i = 0; i < 128; i++) {

            InitTypeRead(CrtAddress + (i * TempSize), nt!_HEAP_BUCKET);

            BucketInfo[i].TotalBlocks = (ULONG)ReadField(Counters.TotalBlocks);
            BucketInfo[i].BlockUnits = (ULONG)ReadField(BlockUnits);
            BucketInfo[i].Conversions = (ULONG)ReadField(Conversions);
            BucketInfo[i].SubSegmentCounts = (ULONG)ReadField(Counters.SubSegmentCounts);
            BucketInfo[i].UseAffinity = (ULONG)ReadField(UseAffinity);

            if (BucketInfo[i].TotalBlocks) {

                dprintf("%6ld %7ld %5ld  %ld %4ld\n",
                       BucketInfo[i].BlockUnits*HeapEntrySize,
                       BucketInfo[i].TotalBlocks,
                       BucketInfo[i].SubSegmentCounts,
                       BucketInfo[i].UseAffinity,
                       BucketInfo[i].Conversions
                       );
            }
        }
        dprintf("-----------------------------\n");

        free(BucketInfo);
    }
}

VOID
DumpHeapInfo(
    ULONG64 HeapAddress
    )
{
    ULONG64 TempValue;

    dprintf("\n%2ld: Heap %p\n",
            CrtHeapStat.HeapIndex,
            CrtHeapStat.HeapAddress);

    dprintf("   Flags          %08lx - ", CrtHeapStat.Flags);
    DumpFlagDescription(CrtHeapStat.Flags);
    dprintf("\n");

    dprintf("   Reserved       %I64d (k)\n", CrtHeapStat.ReservedMemory/1024);
    dprintf("   Commited       %I64d (k)\n", CrtHeapStat.CommitedMemory/1024);
    dprintf("   Virtual bytes  %I64d (k)\n", CrtHeapStat.VirtualBytes/1024);
    dprintf("   Free space     %I64d (k)\n", CrtHeapStat.FreeSpace/1024);


    if (CrtHeapStat.CommitedMemory) {
        dprintf("   External fragmentation          %ld%% (%ld free blocks)\n",
                (ULONG)(CrtHeapStat.FreeSpace *100 / CrtHeapStat.CommitedMemory),
                CrtHeapStat.FreeListLength
                );

    }

    if (CrtHeapStat.VirtualBytes) {
        dprintf("   Virtual address fragmentation   %ld%% (%ld uncommited ranges)\n",
                (ULONG)((CrtHeapStat.VirtualBytes - CrtHeapStat.CommitedMemory) *100 / CrtHeapStat.VirtualBytes),
                CrtHeapStat.UncommitedRanges
                );
    }


    dprintf("   Virtual blocks  %ld\n", CrtHeapStat.VirtualBlocks);
    dprintf("   Lock contention %ld\n", CrtHeapStat.LockContention);

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "LastSegmentIndex", TempValue);
    dprintf("   Segments        %ld\n", (ULONG)TempValue + 1);

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "LargeBlocksIndex", TempValue);

    if (TempValue) {

        ULONG PerfOffset;

        InitTypeRead(TempValue, nt!_HEAP_INDEX);

        dprintf("   %ld hash table for the free list\n", (ULONG) ReadField(ArraySize));
        dprintf("       Commits %ld\n", (ULONG) ReadField(Committs));
        dprintf("       Decommitts %ld\n", (ULONG) ReadField(Decommitts));
    }

    switch (CrtHeapStat.FrontEndHeapType) {
    case 1:

        dprintf("\n   Lookaside heap   %p\n", CrtHeapStat.FrontEndHeap);
        break;
    case 2:

        dprintf("\n   Low fragmentation heap   %p\n", CrtHeapStat.FrontEndHeap);

        DumpLowfHeap(CrtHeapStat.FrontEndHeap);
        break;
    }
}

BOOLEAN
HeapStatRoutine(
    IN ULONG Context,
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    IN ULONG64 EntryAddress,
    IN ULONG64 Data
    )
{
    ULONG SizeIndex;

    switch (Context) {

    case CONTEXT_START_HEAP:
        {
            if (DumpBlocksSize == 0) {
                dprintf("Walking the heap %p ", HeapAddress);
            }

            CollectHeapInfo(HeapAddress);

            //
            //  Allow scanning the heap
            //

            return TRUE;
        }
        break;

    case CONTEXT_END_HEAP:

        if (DumpBlocksSize == 0) {
            dprintf("\r");
        }
        if (SizeInfo == NULL) {

            dprintf("%p %08lx %7I64d %6I64d %6I64d %6I64d %5ld %5ld %4ld %6lx   ",
                    CrtHeapStat.HeapAddress,
                    CrtHeapStat.Flags,
                    (CrtHeapStat.ReservedMemory / 1024),
                    (CrtHeapStat.CommitedMemory / 1024),
                    (CrtHeapStat.VirtualBytes / 1024),
                    (CrtHeapStat.FreeSpace / 1024),
                    CrtHeapStat.FreeListLength,
                    CrtHeapStat.UncommitedRanges,
                    CrtHeapStat.VirtualBlocks,
                    CrtHeapStat.LockContention
                    );

            switch (CrtHeapStat.FrontEndHeapType) {
            case 1:
                dprintf("L  ");
                break;
            case 2:
                dprintf("LFH");
                break;
            default:
                dprintf("   ");
            }

            dprintf("\n");

            //
            //  Report external fragmentation is the heap uses more than 1M
            //  The threshold to report is 10%
            //

            if ((CrtHeapStat.CommitedMemory > 1024*1024)
                    &&
                CrtHeapStat.FreeSpace *100 / CrtHeapStat.CommitedMemory > 10) {

                dprintf("    External fragmentation  %ld %% (%ld free blocks)\n",
                        (ULONG)(CrtHeapStat.FreeSpace *100 / CrtHeapStat.CommitedMemory),
                        CrtHeapStat.FreeListLength
                        );
            }

            //
            //  Report virtual address fragmentation is the heap has more than 100 UCR
            //  The threshold to report is 10%
            //

            if (CrtHeapStat.UncommitedRanges > 100
                    &&
                (CrtHeapStat.VirtualBytes - CrtHeapStat.CommitedMemory) *100 / CrtHeapStat.VirtualBytes > 10) {

                dprintf("    Virtual address fragmentation  %ld %% (%ld uncommited ranges)\n",
                        (ULONG)((CrtHeapStat.VirtualBytes - CrtHeapStat.CommitedMemory) *100 / CrtHeapStat.VirtualBytes),
                        CrtHeapStat.UncommitedRanges
                        );
            }

            //
            //  Make noise about lock contention. The value is 1M, and it's arbitrary.
            //  Over a long run this value can be legitimate
            //

            if (CrtHeapStat.LockContention > 1024*1024) {

                dprintf("    Lock contention  %ld \n",
                        CrtHeapStat.LockContention);
            }
        } else {

            DumpHeapInfo(StatHeapAddress);
            HeapStatDumpBlocks();
        }
        break;

    case CONTEXT_START_SEGMENT:

        {
            ULONG64 NumberOfPages, NumberOfUnCommittedPages, LargestUnCommittedRange, NumberOfUnCommittedRanges;

            GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "NumberOfPages", NumberOfPages);
            GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "NumberOfUnCommittedPages", NumberOfUnCommittedPages);
            GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "LargestUnCommittedRange", LargestUnCommittedRange);
            GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "NumberOfUnCommittedRanges", NumberOfUnCommittedRanges);

            CrtHeapStat.ReservedMemory += NumberOfPages * PageSize;
            CrtHeapStat.CommitedMemory += (NumberOfPages - NumberOfUnCommittedPages) * PageSize;
            CrtHeapStat.UncommitedRanges += (ULONG)NumberOfUnCommittedRanges;
            CrtHeapStat.VirtualBytes += NumberOfPages * PageSize - LargestUnCommittedRange;

        }

        if ((SizeInfo != NULL)
                &&
            (DumpBlocksSize == 0)
            ) {

            dprintf(".");
        }

        if (VerifyBlocks) {

            dprintf(".");
            return TRUE;
        }

        //
        //  Do not walk the blocks. We need to return FALSE
        //

        return (SizeInfo != NULL);

    case CONTEXT_START_SUBSEGMENT:

        CrtHeapStat.ScanningSubSegment = TRUE;
        break;

    case CONTEXT_END_SUBSEGMENT:
        CrtHeapStat.ScanningSubSegment = FALSE;
        break;

    case CONTEXT_FREE_BLOCK:
        if (SizeInfo) {

            if (CrtHeapStat.ScanningSubSegment) {

                SizeInfo[HeapStatSizeToSizeIndex(Data)].FrontHeapFrees += 1;

            } else {

                SizeInfo[HeapStatSizeToSizeIndex(Data)].Free += 1;
            }
        }

        if (Data == DumpBlocksSize) {

            DumpBlock(EntryAddress + HeapEntrySize, 'F');
        }
        break;
    case CONTEXT_BUSY_BLOCK:

        if (SizeInfo) {

            if (CrtHeapStat.ScanningSubSegment) {

                SizeInfo[HeapStatSizeToSizeIndex(Data)].FrontHeapAllocs += 1;

            } else {

                SizeInfo[HeapStatSizeToSizeIndex(Data)].Busy += 1;
            }
        }
        if (Data == DumpBlocksSize) {
            DumpBlock(EntryAddress + HeapEntrySize, 'B');
        }
        break;

    case CONTEXT_LOOKASIDE_BLOCK:

        if (SizeInfo) {

            SizeInfo[HeapStatSizeToSizeIndex(Data)].FrontHeapFrees += 1;
            SizeInfo[HeapStatSizeToSizeIndex(Data)].Busy -= 1;
        }
        if (Data == DumpBlocksSize) {

            DumpBlock(EntryAddress + HeapEntrySize, 'f');
        }
        break;
    case CONTEXT_VIRTUAL_BLOCK:

        if (SizeInfo) {

            SizeInfo[HeapStatSizeToSizeIndex(Data)].Busy += 1;
        }
        CrtHeapStat.VirtualBlocks += 1;
        break;

    case CONTEXT_ERROR:

        dprintf("HEAP %p (Seg %p) At %p Error: %s\n",
               HeapAddress,
               SegmentAddress,
               EntryAddress,
               (LPSTR) (ULONG_PTR) Data
               );

        break;
    }
    return TRUE;
}


VOID
HeapStat(LPCTSTR szArguments)
{
    ULONG64 Process;
    ULONG64 ThePeb;
    HANDLE hProcess;

    int LastCommand = ' ';


    if (!InitializeHeapExtension()) {

        return;
    }

    HeapEntryFind = 0;
    HeapEntryFindSize = 0;
    HeapAddressFind = 0;
    SegmentAddressFind = 0;
    Lookaside = FALSE;
    StatHeapAddress = 0;
    BucketSize = 1024;
    DumpBlocksSize = 0;
    VerifyBlocks = FALSE;

    GetPebAddress( 0, &ThePeb);
    GetCurrentProcessHandle( &hProcess );

    ScanVM = FALSE;

    {
        LPSTR p = (LPSTR)szArguments;

        while (p && *p) {

            if (*p == '-') {

                p++;

                LastCommand = toupper(*p);

                if (LastCommand == 'V') {

                    VerifyBlocks = TRUE;
                }

            } else if (isxdigit(*p)) {

                ULONG64 HexInput = 0;

                GetExpressionEx(p, &HexInput, &p);

                switch (LastCommand) {
                case 'B':

                    BucketSize = (ULONG)HexInput;

                    break;
                case 'D':

                    DumpBlocksSize = (ULONG)HexInput;

                    break;
                default:

                    if (StatHeapAddress != 0) {

                        dprintf("Parameter error: unexpected second heap address %I64d\n", HexInput);

                    } else {
                        StatHeapAddress = HexInput;
                    }
                }
                LastCommand = '\0';
                continue;
            }

            p++;
        }
    }

    if (StatHeapAddress == 0) {

        DumpGlobals();

        if (PointerSize == 8) {
            dprintf("        ");
        }
        dprintf("  Heap     Flags   Reserv  Commit  Virt   Free  List   UCR  Virt  Lock  Fast \n");

        if (PointerSize == 8) {
            dprintf("        ");
        }

        dprintf("                    (k)     (k)    (k)     (k) length      blocks cont. heap \n");

        if (PointerSize == 8) {
            dprintf("--------");
        }
        dprintf("-----------------------------------------------------------------------------\n");

        ScanProcessHeaps( 0,
                          ThePeb,
                          HeapStatRoutine
                          );


        if (PointerSize == 8) {
            dprintf("--------");
        }
        dprintf("-----------------------------------------------------------------------------\n");

    } else {

        //
        //  Do not handle blocks over 512k, which is close to virtual alloc limit
        //

        LargestBucketIndex = (512*1024)/BucketSize;

        SizeInfo = malloc(LargestBucketIndex * sizeof(SIZE_INFO));

        if (SizeInfo == NULL) {

            dprintf("cannot allocate thye statistics buffer\n");
            return;
        }

        memset(SizeInfo, 0, LargestBucketIndex * sizeof(SIZE_INFO));

        ScanProcessHeaps( StatHeapAddress,
                          ThePeb,
                          HeapStatRoutine
                          );

        free(SizeInfo);
        SizeInfo = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\heapleak.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    heapleak.c

Abstract:

    WinDbg Extension Api

Author:

    Adrian Marinescu (adrmarin) 04/17/2000

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "heap.h"
#pragma hdrstop

ULONG PageSize;
ULONG HeapEntrySize;
ULONG PointerSize;
ULONG64 HeapLargestAddress;
BOOLEAN Is64BitArchitecture;
ULONG FrontEndHeapType;
ULONG CrtSegmentIndex;

ULONG ScanLevel;

ULONG LoopLimit = 100000;


BOOLEAN
ReadHeapSubSegment(
    ULONG64 HeapAddress,
    ULONG64 SegmentAddress,
    ULONG64 SubSegmentAddress,
    HEAP_ITERATOR_CALLBACK HeapCallback
    )
{
    ULONG64 SubSegmentDescriptor;
    ULONG64 BlockCount = 0, BlockSize;
    ULONG i;
    ULONG64 CrtAddress;
    ULONG64 EntryAddress;

    GetFieldValue(SubSegmentAddress, "ntdll!_HEAP_USERDATA_HEADER", "SubSegment", SubSegmentDescriptor);

    if (!(*HeapCallback)( CONTEXT_START_SUBSEGMENT,
                          HeapAddress,
                          SubSegmentAddress,
                          SubSegmentDescriptor,
                          0
                     )) {

        return FALSE;
    }

    GetFieldValue(SubSegmentDescriptor, "ntdll!_HEAP_SUBSEGMENT", "BlockCount", BlockCount);

    if (GetFieldValue(SubSegmentDescriptor, "ntdll!_HEAP_SUBSEGMENT", "BlockSize", BlockSize)) {

        (*HeapCallback)( CONTEXT_ERROR,
                         HeapAddress,
                         SegmentAddress,
                         SubSegmentAddress,
                         (ULONG64)(&"subsegment cannot access the block size\n")
                         );

        return FALSE;
    }

    if (BlockSize <= 1) {

        (*HeapCallback)( CONTEXT_ERROR,
                 HeapAddress,
                 SegmentAddress,
                 SubSegmentAddress,
                 (ULONG64)(&"invalid block size\n")
                 );

        return FALSE;
    }

    CrtAddress = SubSegmentAddress + GetTypeSize("ntdll!_HEAP_USERDATA_HEADER");

    for (i = 0; i < BlockCount; i++) {

        ULONG64 SmallTagIndex, BlockSegIndex;

        EntryAddress = CrtAddress + i * BlockSize * HeapEntrySize;

        GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "SegmentIndex", BlockSegIndex);

        if (BlockSegIndex != 0xFF) {

            (*HeapCallback)( CONTEXT_ERROR,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             (ULONG64)(&"SegmentIndex field corrupted\n")
                             );
        }

        GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "SmallTagIndex", SmallTagIndex);

        if (SmallTagIndex) {

            (*HeapCallback)( CONTEXT_BUSY_BLOCK,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             BlockSize * HeapEntrySize
                             );
        } else {

            (*HeapCallback)( CONTEXT_FREE_BLOCK,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             BlockSize * HeapEntrySize
                             );
        }
    }

    if (!(*HeapCallback)( CONTEXT_END_SUBSEGMENT,
                          HeapAddress,
                          SubSegmentAddress,
                          SubSegmentDescriptor,
                          0
                     )) {

        return FALSE;
    }

    return TRUE;
}

//
//  Walking heap routines
//

BOOLEAN
ReadHeapSegment(
    ULONG64 HeapAddress,
    ULONG SegmentIndex,
    ULONG64 SegmentAddress,
    HEAP_ITERATOR_CALLBACK HeapCallback
    )
{
    ULONG64 SegmentBaseAddress;
    ULONG64 PrevEntryAddress, EntryAddress, NextEntryAddress;
    ULONG64 EntrySize, EntryFlags, BlockSegIndex;
    ULONG64 SegmentLastValidEntry;
    ULONG64 UnCommittedRange, UnCommittedRangeAddress = 0, UnCommittedRangeSize = 0;
    ULONG LoopCount;
    BOOLEAN IsSubsegment;

    ScanLevel = SCANSEGMENT;

    if (!(*HeapCallback)( CONTEXT_START_SEGMENT,
                          HeapAddress,
                          SegmentAddress,
                          0,
                          0
                     )) {

        return FALSE;
    }

    CrtSegmentIndex = SegmentIndex;

    GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "BaseAddress", SegmentBaseAddress);
    GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "LastValidEntry", SegmentLastValidEntry);
    GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "UnCommittedRanges", UnCommittedRange);

    if (UnCommittedRange) {

        GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Address", UnCommittedRangeAddress);
        GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Size", UnCommittedRangeSize);
    }

//    dprintf("Uncommitted: %p  %p  %p\n", UnCommittedRange, UnCommittedRangeAddress, UnCommittedRangeSize);

    if (SegmentBaseAddress == HeapAddress) {

        EntryAddress = HeapAddress;

    } else {

        EntryAddress = SegmentAddress;
    }

    PrevEntryAddress = 0;
    LoopCount = 0;

    while (EntryAddress < SegmentLastValidEntry) {

        if (++LoopCount >= LoopLimit) {

             dprintf("Walking the segment exceeded the %ld limit\n", LoopLimit);

             break;
        }

        if (ScanLevel < SCANSEGMENT) {

            break;
        }

        if (GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "Size", EntrySize)) {

            (*HeapCallback)( CONTEXT_ERROR,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             (ULONG64)(&"unable to read uncommited range structure at\n")
                             );
            break;
        }

        if (EntrySize <= 1) {

            (*HeapCallback)( CONTEXT_ERROR,
                     HeapAddress,
                     SegmentAddress,
                     EntryAddress,
                     (ULONG64)(&"invalid block size\n")
                     );

            break;
        }

        EntrySize *= HeapEntrySize;

        NextEntryAddress = EntryAddress + EntrySize;

        GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "Flags", EntryFlags);

        GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "SegmentIndex", BlockSegIndex);

        if (BlockSegIndex != CrtSegmentIndex) {

            (*HeapCallback)( CONTEXT_ERROR,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             (ULONG64)(&"SegmentIndex field corrupted\n")
                             );
        }

        IsSubsegment = FALSE;

        if (FrontEndHeapType == 2) {

            ULONG64 Signature;
            GetFieldValue(EntryAddress + HeapEntrySize, "ntdll!_HEAP_USERDATA_HEADER", "Signature", Signature);

            if ((ULONG)Signature == 0xF0E0D0C0) {

                ReadHeapSubSegment( HeapAddress,
                                    SegmentAddress,
                                    EntryAddress + HeapEntrySize,
                                    HeapCallback );

                IsSubsegment = TRUE;

                if (CheckControlC()) {

                    ScanLevel = 0;
                    return FALSE;
                }
            }
        }

        if (!IsSubsegment) {
            if (EntryFlags & HEAP_ENTRY_BUSY) {

                (*HeapCallback)( CONTEXT_BUSY_BLOCK,
                                 HeapAddress,
                                 SegmentAddress,
                                 EntryAddress,
                                 EntrySize
                                 );
            } else {

                (*HeapCallback)( CONTEXT_FREE_BLOCK,
                                 HeapAddress,
                                 SegmentAddress,
                                 EntryAddress,
                                 EntrySize
                                 );
            }
        }

        PrevEntryAddress = EntryAddress;
        EntryAddress = NextEntryAddress;

        if (EntryFlags & HEAP_ENTRY_LAST_ENTRY) {

            if (CheckControlC()) {

                ScanLevel = 0;
                return FALSE;
            }

            if (EntryAddress == UnCommittedRangeAddress) {

                PrevEntryAddress = 0;
                EntryAddress = UnCommittedRangeAddress + UnCommittedRangeSize;

                GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Next", UnCommittedRange);

                if (UnCommittedRange) {

                    GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Address", UnCommittedRangeAddress);
                    GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Size", UnCommittedRangeSize);
                }

            } else {

                break;
            }
        }
    }

    if (!(*HeapCallback)( CONTEXT_END_SEGMENT,
                          HeapAddress,
                          SegmentAddress,
                          0,
                          0
                     )) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
ReadHeapData(ULONG64 HeapAddress, HEAP_ITERATOR_CALLBACK HeapCallback)
{
    ULONG SegmentCount = 0;
    ULONG64 Head;
    ULONG64 Next;
    ULONG i;
    ULONG PtrSize;
    ULONG SegmentsOffset;
    ULONG VirtualBlockOffset;
    ULONG64 Segment;
    ULONG64 LookasideAddress;
    ULONG64 LFHAddress;
    ULONG LoopCount;

    ScanLevel = SCANHEAP;

    if (!(*HeapCallback)( CONTEXT_START_HEAP,
                          HeapAddress,
                          0,
                          0,
                          0
                     )) {

        return FALSE;
    }

    PtrSize = IsPtr64() ? 8 : 4;

    LookasideAddress = 0;
    LFHAddress = 0;
    FrontEndHeapType = 0;

    if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "Lookaside", LookasideAddress)) {


        if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeapType", FrontEndHeapType)) {

            dprintf("Front-end heap type info is not available\n");
        }

        switch (FrontEndHeapType){
        case 1:
            GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeap", LookasideAddress);
        break;
        case 2:
            GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeap", LFHAddress);
        break;
        }

    } else {

        if (LookasideAddress) {

            FrontEndHeapType = 1;
        }
    }

    GetFieldOffset("ntdll!_HEAP", "Segments", &SegmentsOffset);

    do {

        if (ScanLevel < SCANHEAP) {

            return FALSE;
        }

        if (!ReadPointer( HeapAddress + SegmentsOffset + SegmentCount*PtrSize,
                     &Segment ) ) {

            break;
        }

        if (Segment) {

            ReadHeapSegment( HeapAddress,
                             SegmentCount,
                             Segment,
                             HeapCallback
                            );

            SegmentCount += 1;

            if (CheckControlC()) {

                ScanLevel = 0;
                return FALSE;
            }
        }

    } while ( Segment );

    GetFieldOffset("_HEAP", "VirtualAllocdBlocks", &VirtualBlockOffset);

    Head = HeapAddress + VirtualBlockOffset;
    GetFieldValue(HeapAddress, "ntdll!_HEAP", "VirtualAllocdBlocks.Flink", Next);

    LoopCount = 0;

    while (Next != Head) {

        ULONG64 VBlockSize;

        if (++LoopCount >= LoopLimit) {

             dprintf("Walking the virtual block list exceeded the %ld limit\n", LoopLimit);

             break;
        }

        if (ScanLevel < SCANHEAP) {

            return FALSE;
        }

        GetFieldValue(Next, "ntdll!_HEAP_VIRTUAL_ALLOC_ENTRY", "CommitSize", VBlockSize);

        (*HeapCallback)( CONTEXT_VIRTUAL_BLOCK,
                         HeapAddress,
                         0,
                         Next,
                         VBlockSize
                         );

        if (!ReadPointer(Next, &Next)) {

            (*HeapCallback)( CONTEXT_ERROR,
                             HeapAddress,
                             0,
                             Next,
                             (ULONG64)(&"Unable to read virtual block\n")
                             );
            break;
        }
    }

    if (!(*HeapCallback)( CONTEXT_END_BLOCKS,
                          HeapAddress,
                          0,
                          0,
                          0
                     )) {

        return FALSE;
    }

//    dprintf("Scanning lookasides\n");


    if (LookasideAddress) {
        ULONG LookasideSize;
        PVOID Lookaside;

        HeapEntrySize = GetTypeSize("ntdll!_HEAP_ENTRY");
        LookasideSize = GetTypeSize("ntdll!_HEAP_LOOKASIDE");

        for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i++) {

            if (ScanLevel < SCANHEAP) {

                return FALSE;
            }

            GetFieldValue(LookasideAddress, "ntdll!_HEAP_LOOKASIDE", "ListHead.Next", Next);

            if (Is64BitArchitecture) {

                Next <<= 3;
            }

            LoopCount = 0;

            while (Next) {

                if (++LoopCount >= LoopLimit) {

                     dprintf("Walking the lookaside block list index %ld exceeded the %ld limit\n", i, LoopLimit);

                     break;
                }

                (*HeapCallback)( CONTEXT_LOOKASIDE_BLOCK,
                                 HeapAddress,
                                 0,
                                 Next - HeapEntrySize,
                                 i*HeapEntrySize
                                 );

                if (!ReadPointer(Next, &Next)) {

                    (*HeapCallback)( CONTEXT_ERROR,
                                     HeapAddress,
                                     0,
                                     Next,
                                     (ULONG64)(&"Unable to read lookaside block\n")
                                     );
                    break;
                }
            }

            LookasideAddress += LookasideSize;
        }
    }

    if (LFHAddress) {
        (*HeapCallback)( CONTEXT_LFH_HEAP,
                         HeapAddress,
                         LFHAddress,
                         0,
                         0
                         );
    }

    (*HeapCallback)( CONTEXT_END_HEAP,
                     HeapAddress,
                     0,
                     0,
                     0
                   );

    return TRUE;
}


void
ScanProcessHeaps(
    IN ULONG64 AddressToDump,
    IN ULONG64 ProcessPeb,
    HEAP_ITERATOR_CALLBACK HeapCallback
    )
{
    ULONG NumberOfHeaps;
    ULONG64 pHeapsList;
    ULONG64 * Heaps;
    ULONG PtrSize;
    ULONG HeapNumber;

    if (AddressToDump) {

        ReadHeapData ( AddressToDump, HeapCallback);
        return;
    }

    if (!(*HeapCallback)( CONTEXT_START_GLOBALS,
                          0,
                          0,
                          0,
                          ProcessPeb
                     )) {

        return;
    }

    ScanLevel = SCANPROCESS;

    GetFieldValue(ProcessPeb, "ntdll!_PEB", "NumberOfHeaps", NumberOfHeaps);
    GetFieldValue(ProcessPeb, "ntdll!_PEB", "ProcessHeaps", pHeapsList);

    if (NumberOfHeaps == 0) {

        dprintf( "No heaps to display.\n" );

        return;
    }

    if (!pHeapsList) {

        dprintf( "Unable to get address of ProcessHeaps array\n" );
        return;

    }

    Heaps = malloc( NumberOfHeaps * sizeof(ULONG64) );

    if (!Heaps) {

        dprintf( "Unable to allocate memory to hold ProcessHeaps array\n" );

        return;
    }

    PtrSize = IsPtr64() ? 8 : 4;

    for (HeapNumber=0; HeapNumber<NumberOfHeaps ; HeapNumber++) {

        if (!ReadPointer( pHeapsList + HeapNumber*PtrSize,
                     &Heaps[HeapNumber] ) ) {

            dprintf( "%08p: Unable to read ProcessHeaps array\n", pHeapsList );

            free(Heaps);
            return;
        }
    }

    for ( HeapNumber = 0; HeapNumber < NumberOfHeaps; HeapNumber++ ) {

        if (ScanLevel < SCANPROCESS) {

            free(Heaps);
            return;
        }

        if ((AddressToDump == 0)
                ||
            (AddressToDump == Heaps[HeapNumber])) {

            ReadHeapData ( Heaps[HeapNumber], HeapCallback);
        }
    }

    free(Heaps);
}

//
//  Allocation routines
//

HANDLE TempHeap;

#define AllocateBlock(Size) HeapAlloc(TempHeap, 0, Size)
#define FreeBlock(P) HeapFree(TempHeap, 0, P)

//
//  Leak detector code
//

typedef enum _USAGE_TYPE {

    UsageUnknown,
    UsageModule,
    UsageHeap,
    UsageOther

} USAGE_TYPE;

typedef struct _HEAP_BLOCK {

    LIST_ENTRY   Entry;
    ULONG64 BlockAddress;
    ULONG64 Size;
    LONG    Count;
} HEAP_BLOCK, *PHEAP_BLOCK;

typedef struct _BLOCK_DESCR {
    USAGE_TYPE Type;
    ULONG64 Heap;
    LONG Count;
    HEAP_BLOCK Blocks[1];
}BLOCK_DESCR, *PBLOCK_DESCR;

typedef struct _MEMORY_MAP {

    ULONG64 Granularity;
    ULONG64 Offset;
    ULONG64 MaxAddress;

    CHAR FlagsBitmap[256 / 8];

    union{

        struct _MEMORY_MAP * Details[ 256 ];
        PBLOCK_DESCR Usage[ 256 ];
    };

    struct _MEMORY_MAP * Parent;

} MEMORY_MAP, *PMEMORY_MAP;

MEMORY_MAP ProcessMemory;
ULONG LeaksCount = 0;
ULONG64 PreviousPage = 0;
ULONG64 CrtPage = 0;
LONG NumBlocks = 0;
PHEAP_BLOCK TempBlocks;
ULONG64 LastHeapAddress = 0;
ULONG64 RtlpPreviousStartAddress = 0;

LIST_ENTRY HeapBusyList;
LIST_ENTRY HeapLeakList;


void InitializeMap(PMEMORY_MAP MemMap, PMEMORY_MAP Parent)
{
    memset(MemMap, 0, sizeof(*MemMap));
    MemMap->Parent = Parent;
    if (Parent) {
        MemMap->Granularity = Parent->Granularity / 256;
    }
}


void
SetBlockInfo(PMEMORY_MAP MemMap, ULONG64 Base, ULONG64 Size, PBLOCK_DESCR BlockDescr)
{
    ULONG64 Start, End;
    ULONG64 i;

    if (((Base + Size - 1) < MemMap->Offset) ||
        (Base > MemMap->MaxAddress)
        ) {

        return;
    }

    if (Base > MemMap->Offset) {
        Start = (Base - MemMap->Offset) / MemMap->Granularity;
    } else {
        Start = 0;
    }

    End = (Base - MemMap->Offset + Size - 1) / MemMap->Granularity;

    if (End > 255) {

        End = 255;
    }

    for (i = Start; i <= End; i++) {

        if (MemMap->Granularity == PageSize) {

            if (BlockDescr) {
                if (MemMap->Usage[i] != NULL) {
                    if (MemMap->Usage[i] != BlockDescr) {

                        dprintf("Error\n");
                    }
                }

                MemMap->Usage[i] = BlockDescr;
            } else {

                MemMap->FlagsBitmap[i / 8] |= 1 << (i % 8);
            }

        } else {

            if (!MemMap->Details[i]) {

                MemMap->Details[i] = AllocateBlock(sizeof(*MemMap));

                if (!MemMap->Details[i]) {
                    dprintf("Error allocate\n");
                    return;
                }

                InitializeMap(MemMap->Details[i], MemMap);
                MemMap->Details[i]->Offset = MemMap->Offset + MemMap->Granularity * i;
                MemMap->Details[i]->MaxAddress = MemMap->Offset + MemMap->Granularity * (i+1) - 1;
            }

            SetBlockInfo(MemMap->Details[i], Base, Size, BlockDescr);
        }
    }
}

PBLOCK_DESCR
GetBlockInfo(PMEMORY_MAP MemMap, ULONG64 Base)
{
    ULONG64 Start;
    PBLOCK_DESCR BlockDescr = NULL;

    if ((Base < MemMap->Offset) ||
        (Base > MemMap->MaxAddress)
        ) {

        return NULL;
    }

    if (Base > MemMap->Offset) {
        Start = (Base - MemMap->Offset) / MemMap->Granularity;
    } else {
        Start = 0;
    }

    if (MemMap->Granularity == PageSize) {

        return MemMap->Usage[Start];

    } else {

        if (MemMap->Details[Start]) {

            return GetBlockInfo(MemMap->Details[Start], Base);
        }
    }

    return NULL;
}

BOOLEAN
GetFlag(PMEMORY_MAP MemMap, ULONG64 Base)
{
    ULONG64 Start;
    PBLOCK_DESCR BlockDescr = NULL;
/*
    dprintf("GetFlag %p %p %p\n",
            MemMap->Offset,
            MemMap->MaxAddress,
            MemMap->Granularity
            );
*/
    if ((Base < MemMap->Offset) ||
        (Base > MemMap->MaxAddress)
        ) {

        return FALSE;
    }

    if (Base > MemMap->Offset) {
        Start = (Base - MemMap->Offset) / MemMap->Granularity;
    } else {
        Start = 0;
    }

    if (MemMap->Granularity == PageSize) {

        ULONG Flag = (MemMap->FlagsBitmap[Start / 8] & (1 << (Start % 8))) != 0;

        return (MemMap->FlagsBitmap[Start / 8] & (1 << (Start % 8))) != 0;

    } else {

        if (MemMap->Details[Start]) {

            return GetFlag(MemMap->Details[Start], Base);
        }
    }

    return FALSE;
}

void InitializeSystem()
{
    ULONG64 AddressRange = PageSize;
    ULONG64 PreviousAddressRange = PageSize;

    InitializeMap(&ProcessMemory, NULL);

    InitializeListHead( &HeapBusyList );
    InitializeListHead( &HeapLeakList );


    while (TRUE) {

        AddressRange = AddressRange * 256;

        if ((AddressRange < PreviousAddressRange)
                ||
            (AddressRange > HeapLargestAddress)
            ) {

            ProcessMemory.MaxAddress = HeapLargestAddress;

            ProcessMemory.Granularity = PreviousAddressRange;

            break;
        }

        PreviousAddressRange = AddressRange;
    }

    TempBlocks = AllocateBlock(PageSize);

    if (TempBlocks == NULL) {

        dprintf("Cannot allocate temp buffer\n");
    }
}

BOOLEAN
PushPageDescriptor(ULONG64 Page, ULONG64 NumPages)
{
    PBLOCK_DESCR PBlockDescr;
    PBLOCK_DESCR PreviousDescr;
    LONG i;

    PreviousDescr = GetBlockInfo(&ProcessMemory, Page * PageSize);

    if (PreviousDescr) {

        dprintf("Conflicting descriptors %08lx\n", PreviousDescr);

        return FALSE;
    }

    PBlockDescr = (PBLOCK_DESCR)AllocateBlock(sizeof(BLOCK_DESCR) + (NumBlocks - 1) * sizeof(HEAP_BLOCK));

    if (!PBlockDescr) {

        dprintf("Unable to allocate page descriptor\n");

        return FALSE;
    }
    PBlockDescr->Type = UsageHeap;
    PBlockDescr->Count = NumBlocks;
    PBlockDescr->Heap = LastHeapAddress;

    memcpy(PBlockDescr->Blocks, TempBlocks, NumBlocks * sizeof(HEAP_BLOCK));

    for (i = 0; i < NumBlocks; i++) {

        InitializeListHead( &PBlockDescr->Blocks[i].Entry );

        if (PBlockDescr->Blocks[i].BlockAddress != RtlpPreviousStartAddress) {

            InsertTailList(&HeapLeakList, &PBlockDescr->Blocks[i].Entry);

            PBlockDescr->Blocks[i].Count = 0;

            RtlpPreviousStartAddress = PBlockDescr->Blocks[i].BlockAddress;
        }
    }

    SetBlockInfo(&ProcessMemory, Page * PageSize, NumPages * PageSize, PBlockDescr);

    return TRUE;
}

BOOLEAN RegisterHeapBlocks(
    IN ULONG Context,
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    IN ULONG64 EntryAddress,
    IN ULONG64 Data
    )
{
    if (Context == CONTEXT_START_HEAP) {

        dprintf("Heap %p\n", HeapAddress);

        LastHeapAddress = HeapAddress;

        return TRUE;
    }

    if (Context == CONTEXT_START_SEGMENT) {

        ULONG64 NumberOfPages;
        ULONG64 SegmentBaseAddress;

        GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "NumberOfPages", NumberOfPages);
        GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "BaseAddress", SegmentBaseAddress);

        SetBlockInfo(&ProcessMemory, SegmentBaseAddress, NumberOfPages * PageSize, NULL);

        return TRUE;
    }

    if (Context == CONTEXT_ERROR) {

        dprintf("HEAP %p (Seg %p) At %p Error: %s\n",
               HeapAddress,
               SegmentAddress,
               EntryAddress,
               (LPSTR) (ULONG_PTR) Data
                );

        return TRUE;
    }

    if (Context == CONTEXT_END_BLOCKS) {
        if (PreviousPage) {

            PushPageDescriptor(PreviousPage, 1);
        }

        PreviousPage = 0;
        NumBlocks = 0;

    } else if (Context == CONTEXT_BUSY_BLOCK) {

        ULONG EntrySize;
        ULONG64 EndPage;

        EntrySize = (ULONG)Data;

        EndPage = (EntryAddress + (EntrySize - 1)) / PageSize;

        if (!GetFlag(&ProcessMemory, EntryAddress)) {

            dprintf("CONTEXT_BUSY_BLOCK %p address isn't from the heap\n", EntryAddress);
        }

        CrtPage = (EntryAddress) / PageSize;

        if (CrtPage != PreviousPage) {

            if (PreviousPage) {

                PushPageDescriptor(PreviousPage, 1);
            }

            PreviousPage = CrtPage;
            NumBlocks = 0;
        }

        TempBlocks[NumBlocks].BlockAddress = EntryAddress;
        TempBlocks[NumBlocks].Count = 0;
        TempBlocks[NumBlocks].Size = EntrySize;

        NumBlocks++;

        if (EndPage != CrtPage) {

            PushPageDescriptor(CrtPage, 1);

            NumBlocks = 0;

            TempBlocks[NumBlocks].BlockAddress = (ULONG_PTR)EntryAddress;
            TempBlocks[NumBlocks].Count = 0;
            TempBlocks[NumBlocks].Size = EntrySize;

            NumBlocks = 1;

            if (EndPage - CrtPage > 1) {

                PushPageDescriptor(CrtPage + 1, EndPage - CrtPage - 1);
            }

            PreviousPage = EndPage;
        }
    } else if (Context == CONTEXT_VIRTUAL_BLOCK) {

        ULONG64 EndPage;

        EndPage = (EntryAddress + Data - 1) / PageSize;

        CrtPage = (EntryAddress) / PageSize;

        if (CrtPage != PreviousPage) {

            if (PreviousPage) {

                PushPageDescriptor(PreviousPage, 1);
            }

            PreviousPage = CrtPage;
            NumBlocks = 0;
        } else {
            dprintf("Error in large block address\n");
        }

        TempBlocks[NumBlocks].BlockAddress = EntryAddress;
        TempBlocks[NumBlocks].Count = 0;
        TempBlocks[NumBlocks].Size = Data * HeapEntrySize;

        NumBlocks++;

        PushPageDescriptor(CrtPage, EndPage - CrtPage + 1);

        PreviousPage = 0;

    } else if ( Context == CONTEXT_LOOKASIDE_BLOCK ) {

        PBLOCK_DESCR PBlockDescr;
        LONG i;


        if (!GetFlag(&ProcessMemory, EntryAddress)) {

            dprintf("CONTEXT_LOOKASIDE_BLOCK %p address isn't from the heap\n", EntryAddress);
        }

        PBlockDescr = GetBlockInfo(&ProcessMemory, EntryAddress);

        if (!PBlockDescr) {

            dprintf("Error finding block from lookaside %p\n", EntryAddress);

            return FALSE;
        }

        for (i = 0; i < PBlockDescr->Count; i++) {

            if ((PBlockDescr->Blocks[i].BlockAddress <= (ULONG_PTR)EntryAddress) &&
                (PBlockDescr->Blocks[i].BlockAddress + PBlockDescr->Blocks[i].Size > (ULONG_PTR)EntryAddress)) {

                PBlockDescr->Blocks[i].Count = -10000;
                RemoveEntryList(&PBlockDescr->Blocks[i].Entry);

                return TRUE;
            }
        }

        dprintf("Error, block %p from lookaside not found in allocated block list\n", EntryAddress);
    }

    return TRUE;
}

PHEAP_BLOCK
GetHeapBlock(ULONG64 Address)
{
    PBLOCK_DESCR PBlockDescr;
    LONG i;

    PBlockDescr = GetBlockInfo(&ProcessMemory, Address);

    if (PBlockDescr) {
        for (i = 0; i < PBlockDescr->Count; i++) {

            if ((PBlockDescr->Blocks[i].BlockAddress <= Address) &&
                (PBlockDescr->Blocks[i].BlockAddress + PBlockDescr->Blocks[i].Size > Address)) {

                if (PBlockDescr->Blocks[i].BlockAddress != Address) {

                    return GetHeapBlock(PBlockDescr->Blocks[i].BlockAddress);
                }

                return &(PBlockDescr->Blocks[i]);
            }
        }
    }

    return NULL;
}

BOOLEAN
ScanHeapAllocBlocks()
{

    PLIST_ENTRY Next;

    Next = HeapBusyList.Flink;

    while (Next != &HeapBusyList) {

        PHEAP_BLOCK Block = CONTAINING_RECORD(Next, HEAP_BLOCK, Entry);

        PULONG_PTR CrtAddress = (PULONG_PTR)(Block->BlockAddress + HeapEntrySize);

        Next = Next->Flink;

        while ((ULONG_PTR)CrtAddress < Block->BlockAddress + Block->Size) {

            ULONG_PTR Pointer;

            if (ReadMemory( (ULONG64)(CrtAddress),
                             &Pointer,
                             sizeof(Pointer),
                             NULL
                           )) {

                PHEAP_BLOCK pBlock = GetHeapBlock( Pointer );

                if (pBlock) {

                    //
                    //  We found a block. we increment then the reference count
                    //

                    if (pBlock->Count == 0) {

                        RemoveEntryList(&pBlock->Entry);
                        InsertTailList(&HeapBusyList, &pBlock->Entry);
                    }

                    pBlock->Count += 1;
                }
            }

            //
            //  Go to the next possible pointer
            //

            CrtAddress++;
        }
    }

    Next = HeapLeakList.Flink;

    while (Next != &HeapLeakList) {

        PHEAP_BLOCK Block = CONTAINING_RECORD(Next, HEAP_BLOCK, Entry);
        PBLOCK_DESCR PBlockDescr = GetBlockInfo( &ProcessMemory, Block->BlockAddress );
        PULONG_PTR CrtAddress = (PULONG_PTR)(Block->BlockAddress + HeapEntrySize);

        //
        //  First time we need to display the header
        //

        if (LeaksCount == 0) {

            dprintf("\n");
            DumpEntryHeader();
        }

        //
        //  Display the information for this block
        //

        if (PBlockDescr)
        {
            DumpEntryInfo(PBlockDescr->Heap, 0, Block->BlockAddress);
        }

        LeaksCount += 1;

        //
        //  Go to the next item from the leak list
        //

        Next = Next->Flink;
    }

    return TRUE;
}

BOOLEAN
ScanProcessVM (
    HANDLE hProcess
    )
{
    NTSTATUS Status;
    SIZE_T BufferLen;
    ULONG_PTR lpAddress = 0;
    MEMORY_BASIC_INFORMATION Buffer;
    PVOID MemoryBuffer;

    if ( hProcess ) {

        PROCESS_BASIC_INFORMATION BasicInfo;

        dprintf("Scanning VM ...");

        Status = NtQueryInformationProcess(
                    hProcess,
                    ProcessBasicInformation,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    NULL
                    );

//        dprintf("PEB %p\n", BasicInfo.PebBaseAddress);

        MemoryBuffer = AllocateBlock(PageSize);

        if (!MemoryBuffer) {

            return FALSE;
        }

        BufferLen = sizeof(Buffer);

        while (BufferLen) {

            BufferLen = VirtualQueryEx( hProcess,
                                        (LPVOID)lpAddress,
                                        &Buffer,
                                        sizeof(Buffer)
                                      );

            if (BufferLen) {

                if (( Buffer.AllocationProtect &
                      (PAGE_READWRITE | PAGE_EXECUTE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY))
                    ) {

                    ULONG64 NumPages;
                    ULONG i, j;

                    NumPages = Buffer.RegionSize / PageSize;

                    for (i = 0; i < NumPages; i++) {

                        if (ReadMemory( (ULONG64)(lpAddress + i * PageSize),
                                        MemoryBuffer,
                                        PageSize,
                                        NULL )
                                &&
                            !GetFlag(&ProcessMemory, lpAddress)
                            ) {

                            ULONG_PTR * Pointers = (ULONG_PTR *)MemoryBuffer;

                            for (j = 0; j < PageSize/sizeof(ULONG_PTR); j++) {

                                ULONG_PTR Address = lpAddress + i * PageSize + j * sizeof(ULONG_PTR);

                                PHEAP_BLOCK pBlock = GetHeapBlock(*Pointers);

                                if (pBlock) {

                                    if (pBlock->Count == 0) {

                                        RemoveEntryList(&pBlock->Entry);
                                        InsertTailList(&HeapBusyList, &pBlock->Entry);
                                    }

                                    pBlock->Count += 1;
                                }

                                Pointers += 1;
                            }
                        }

                        if (CheckControlC()) {
                            FreeBlock(MemoryBuffer);
                            ScanLevel = 0;

                            return FALSE;
                        }
                    }
                }

                lpAddress += Buffer.RegionSize;
            }
        }

        //
        //  First scan will mark all used blocks
        //

        ScanHeapAllocBlocks();

        FreeBlock(MemoryBuffer);
    }

    return TRUE;
}


void InspectLeaks(
    IN ULONG64 AddressToDump,
    IN ULONG64 ProcessPeb
    )
{
    HANDLE hProcess;

    LeaksCount = 0;

    InitializeSystem();

    if (TempBlocks) {
        ScanProcessHeaps( 0,
                          ProcessPeb,
                          RegisterHeapBlocks
                          );

        GetCurrentProcessHandle( &hProcess );

        if (hProcess){

            ScanProcessVM(hProcess);

            if (LeaksCount) {

                dprintf("%ld leaks detected.\n", LeaksCount);

            } else {

                dprintf( "No leaks detected.\n");
            }

        } else {

            dprintf("Unable to get the process handle\n");
        }
    }
}

VOID
HeapDetectLeaks()
{
    ULONG64 Process;
    ULONG64 ThePeb;
    ULONG64 PageHeapAddress;
    BOOLEAN PageHeapEnabled = FALSE;
    ULONG PageHeapFlags = 0;

    if (!InitializeHeapExtension()) {

        return;
    }

    //
    // Return immediately if full page heap is enabled
    //

    PageHeapAddress = GetExpression ("ntdll!RtlpDebugPageHeap");

    ReadMemory (PageHeapAddress,
                &PageHeapEnabled,
                sizeof (BOOLEAN),
                NULL);

    PageHeapAddress = GetExpression ("ntdll!RtlpDphGlobalFlags");

    ReadMemory (PageHeapAddress,
                &PageHeapFlags,
                sizeof (ULONG),
                NULL);

    if (PageHeapEnabled == TRUE && (PageHeapFlags & 0x01)) {
        dprintf ("!heap -l does not work if full page heap is enabled for the process \n");
        return;
    }


    GetPebAddress( 0, &ThePeb);

    TempHeap = HeapCreate(HEAP_NO_SERIALIZE | HEAP_GROWABLE, 0, 0);
    if (!TempHeap) {

        dprintf("Unable to create temporary heap\n");
        return;
    }

    InspectLeaks( 0, ThePeb);
    HeapDestroy(TempHeap);

    TempHeap = NULL;
}

BOOLEAN
InitializeHeapExtension()
{
    PointerSize = IsPtr64() ? 8 : 4;
    HeapEntrySize = GetTypeSize("ntdll!_HEAP_ENTRY");

    if ((HeapEntrySize == 0)
            ||
        (PointerSize == 0)) {

        dprintf("Invalid type information\n");

        return FALSE;
    }

    //
    //  Issue adrmarin 04/28/00: The page size should be available in the new interface
    //  IDebugControl::GetPageSize
    //

    if (PointerSize == 4) {

        PageSize = 0x1000;
        HeapLargestAddress = (ULONG)-1;
        Is64BitArchitecture = FALSE;

    } else {

        PageSize = 0x2000;
        HeapLargestAddress = (ULONGLONG)-1;
        Is64BitArchitecture = TRUE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\heappagx.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    heappagx.c

Abstract:

    This module contains the page heap manager debug extensions.

Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

--*/


#define DEBUG_PAGE_HEAP 1

#include "precomp.h"
#include "heap.h"



__inline
BOOLEAN
CheckInterrupted(
    VOID
    )
{
    if (CheckControlC()) {
        dprintf ("\n...interrupted...\n" );
        return TRUE;
    }
    return FALSE;
}


#define CHECK_FOR_CTRL_C()                    \
    if (CheckControlC()) {                    \
        dprintf ("\n...interrupted...\n" );   \
        return;                               \
    }


__inline
ULONG64
Read_PVOID (
    ULONG64 Address
    )
{
    ULONG64 RemoteValue = 0;
    ReadPointer( Address, &RemoteValue);
    return RemoteValue;
}

__inline
ULONG
Read_ULONG(
    ULONG64 Address
    )
{
    ULONG RemoteValue = 0;
    ReadMemory( Address, &RemoteValue, sizeof( ULONG ), NULL );
    return RemoteValue;
}

ULONG
ReturnFieldOffset(
    PCHAR TypeName,
    PCHAR FieldName)
{
    ULONG off=0;
    ULONG Result;

    Result = GetFieldOffset(TypeName, FieldName, &off);

    if (Result != 0) {

        dprintf ("Error: Failed to get the offset for `%s!%s'.\n",
                 TypeName,
                 FieldName);
    }

    return off;
}

VOID
PageHeapLocateFaultAllocation(
    ULONG64 RemoteHeap,
    ULONG64 AddressOfFault
    );

VOID
PageHeapReportAllocation(
    ULONG64 RemoteHeap,
    ULONG64 RemoteHeapNode,
    PCHAR NodeType,
    ULONG64 AddressOfFault
    );

BOOLEAN
PageHeapExtensionShowHeapList(
    VOID
    );

VOID            
PageHeapPrintFlagsMeaning (
    ULONG64 HeapFlags
    );

VOID
TraceDatabaseDump (
    PCSTR Args,
    BOOLEAN SortByCountField
    );

VOID
TraceDatabaseBlockDump (
    ULONG64 Address
    );

VOID
FaultInjectionTracesDump (
    PCSTR Args
    );

#define PAGE_HEAP_HELP_TEXT "                                      \n"

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID 
PageHeapHelp (
    VOID
    )
{

    dprintf ("!heap -p          Dump all page heaps.                        \n"
             "!heap -p -h ADDR  Detailed dump of page heap at ADDR.         \n"
             "!heap -p -a ADDR  Figure out what heap block is at ADDR.      \n"
             "!heap -p -fi [N]  Dump last N fault injection traces.\n"
             "                                                              \n"
             " +-----+---------------+--+                                   \n"
             " |     |               |  | Light page heap allocated block       \n"
             " +-----+---------------+--+                                   \n"
             "     ^         ^        ^                                     \n"
             "     |         |        8 suffix bytes filled with 0xA0       \n"
             "     |         user allocation (filled with E0 if zeroing not requested) \n"
             "     block header (starts with 0xABCDAAAA and ends with 0xDCBAAAAA).\n"
             "     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n"
             "     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n"
             "                                                              \n"
             " +-----+---------------+--+                                   \n"
             " |     |               |  | Light page heap freed block           \n"
             " +-----+---------------+--+                                   \n"
             "     ^         ^        ^                                     \n"
             "     |         |        8 suffix bytes filled with 0xA0       \n"
             "     |         user allocation (filled with F0 bytes)         \n"
             "     block header (starts with 0xABCDAAA9 and ends with 0xDCBAAA9). \n"
             "     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n"
             "     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n"
             "                                                              \n"
             " +-----+---------+--+------                                   \n"
             " |     |         |  | ... N/A page     Full page heap         \n"
             " +-----+---------+--+------            allocated block        \n"
             "     ^         ^   ^                                          \n"
             "     |         |   0-7 suffix bytes filled with 0xD0          \n"
             "     |         user allocation (filled with C0 if zeroing not requested) \n"
             "     block header (starts with 0xABCDBBBB and ends with 0xDCBABBBB).\n"
             "     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n"
             "     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n"
             "                                                              \n"
             " +-----+---------+--+------                                   \n"
             " |     |         |  | ... N/A page     Full page heap         \n"
             " +-----+---------+--+------            freed block            \n"
             "     ^         ^   ^                                          \n"
             "     |         |   0-7 suffix bytes filled with 0xD0          \n"
             "     |         user allocation (filled with F0 bytes)         \n"
             "     block header (starts with 0xABCDBBA and ends with 0xDCBABBBA).\n"
             "     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n"
             "     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n"
             "                                                              \n"
             "Note. The `-t', `-tc', `-ts' options are no longer supported. \n"
             "Please use the UMDH tool provided with the debugger package   \n"
             "for equivalent functionality.                                 \n"
             "                                                              \n");
}


VOID
PageHeapUseUmdh (
    VOID
    )
{
    dprintf ("                                                              \n"
             "This page heap debug extension option is no longer supported. \n"
             "Please use the UMDH tool provided with the debugger package   \n"
             "for equivalent functionality.                                 \n"
             "                                                              \n");
}


VOID
PageHeapExtensionFind(
    PCSTR ArgumentString
    )
{
    ULONG64 RemoteHeapList;
    ULONG64 RemoteHeap;
    ULONG64 RemoteVirtualNode;
    ULONG64 RemoteVirtualBase;
    ULONG64 RemoteVirtualSize;
    ULONG64 AddressOfFault;
    BOOL GetResult;
    ULONG Result;
    ULONG Offset;
    ULONG64 NextNode;

    GetResult = GetExpressionEx (ArgumentString, 
                                 &AddressOfFault,
                                 &ArgumentString);

    if (GetResult == FALSE) {
        dprintf ("\nFailed to convert `%s' to an address.\n",
                 ArgumentString);
        return;
    }

    RemoteHeapList = (ULONG64) GetExpression ("NTDLL!RtlpDphPageHeapList");
    RemoteHeap = Read_PVOID (RemoteHeapList);

    if (RemoteHeap == 0) {

        dprintf ("\nNo page heaps active in process (or bad symbols)\n\n");
        AddressOfFault = 0;
    }

    if (( AddressOfFault == 0 ) || ( strchr( ArgumentString, '?' ))) {

        PageHeapHelp();
        return;
    }

    Result = GetFieldOffset ("NTDLL!_DPH_HEAP_ROOT",
                             "NextHeap",
                             &Offset);

    if (Result != 0) {
        dprintf ("\nFailed to get offset of `NextHeap' field.\n");
        return;
    }

    //
    //  Find the heap that contains the range of virtual addresses that
    //  contain the AddressOfFault.
    //

    while (RemoteHeap != RemoteHeapList) {

        //
        //  The heap header contains a linked list of virtual memory
        //  allocations.
        //

        InitTypeRead (RemoteHeap - Offset, ntdll!_DPH_HEAP_ROOT);

        RemoteVirtualNode = ReadField (pVirtualStorageListHead);

        while (RemoteVirtualNode != 0) {

            InitTypeRead (RemoteVirtualNode, ntdll!_DPH_HEAP_BLOCK);

            RemoteVirtualBase = ReadField (pVirtualBlock);
            RemoteVirtualSize = ReadField (nVirtualBlockSize);

            NextNode = ReadField (pNextAlloc);
            
            if (RemoteVirtualBase == 0 || RemoteVirtualSize == 0) {

                dprintf ("\nError: Heap 0x%p appears to have an invalid\n"
                         "          virtual allocation list\n\n",
                         RemoteHeap);
            }

            if ((AddressOfFault >= RemoteVirtualBase) &&
                (AddressOfFault <= RemoteVirtualBase + RemoteVirtualSize )) {

                //
                //  The fault appears to have occurred in the range of this
                //  heap, so we'll search the busy and free lists for the
                //  closest match and report it.  Then exit.
                //

                PageHeapLocateFaultAllocation (RemoteHeap - Offset, 
                                               AddressOfFault);
                return;
            }

            CHECK_FOR_CTRL_C();
            
            RemoteVirtualNode = NextNode;
        }

        CHECK_FOR_CTRL_C();

        //
        //  Not found in this heap. Continue to search in the next heap.
        //

        RemoteHeap = Read_PVOID (RemoteHeap);

    }
    
    //
    // If we are here we did not find a virtual range.
    //

    dprintf ("\nCould not find a page heap containing virtual address %p\n",
             AddressOfFault);
}


VOID
PageHeapLocateFaultAllocation(
    ULONG64 RemoteHeap,
    ULONG64 AddressOfFault
    )
{
    ULONG64 ClosestHeapNode;
    ULONG64 ClosestDifference;
    ULONG64 RemoteHeapNode;
    ULONG64 RemoteAllocBase;
    ULONG64 RemoteAllocSize;
    ULONG RemoteFreeListSize;
    ULONG64 NextNode;

    ClosestHeapNode = 0;

    //
    //  First search the busy list for the containing allocation, if any.
    //

    InitTypeRead (RemoteHeap, NTDLL!_DPH_HEAP_ROOT);

    RemoteHeapNode = ReadField (pBusyAllocationListHead);

    while (RemoteHeapNode != 0) {

        InitTypeRead (RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK);

        RemoteAllocBase = ReadField (pVirtualBlock);
        RemoteAllocSize = ReadField (nVirtualBlockSize);

        NextNode = ReadField (pNextAlloc);

        if ((AddressOfFault >= RemoteAllocBase) &&
            (AddressOfFault < RemoteAllocBase + RemoteAllocSize)) {

            //
            //  The fault appears to have occurred in this allocation's
            //  memory (which includes the NO_ACCESS page beyond the user
            //  portion of the allocation).
            //

            PageHeapReportAllocation (RemoteHeap, 
                                      RemoteHeapNode, 
                                      "allocated", 
                                      AddressOfFault );

            return;
        }

        CHECK_FOR_CTRL_C();

        RemoteHeapNode = NextNode;
    }

    //
    //  Failed to find containing allocation on busy list, so search free.
    //

    InitTypeRead (RemoteHeap, NTDLL!_DPH_HEAP_ROOT);

    RemoteHeapNode = ReadField (pFreeAllocationListHead);

    while (RemoteHeapNode != 0) {

        InitTypeRead (RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK);

        RemoteAllocBase = ReadField (pVirtualBlock);
        RemoteAllocSize = ReadField (nVirtualBlockSize);

        if ((AddressOfFault >= RemoteAllocBase) &&
            (AddressOfFault < RemoteAllocBase + RemoteAllocSize)) {

            //
            //  The fault appears to have occurred in this freed alloc's
            //  memory.
            //

            PageHeapReportAllocation (RemoteHeap, 
                                      RemoteHeapNode, 
                                      "freed", 
                                      AddressOfFault );

            return;
        }

        CHECK_FOR_CTRL_C();

        RemoteHeapNode = ReadField (pNextAlloc);
    }

    //
    //  Failed to find containing allocation in free list, but we wouldn't
    //  have gotten this far if the debug heap did not contain the virtual
    //  address range of the fault.  So, report it as a wild pointer that
    //  could have been freed memory.
    //

    InitTypeRead (RemoteHeap, NTDLL!_DPH_HEAP_ROOT);

    RemoteFreeListSize = (ULONG) ReadField (nFreeAllocations);

    dprintf( "\nPAGEHEAP: %p references memory contained in the heap %p,\n"
             "          but does not reference an existing allocated or\n"
             "          recently freed heap block.  It is possible that\n"
             "          the memory at %p could previously have been\n"
             "          allocated and freed, but it must have been freed\n"
             "          prior to the most recent %d frees.\n\n",
             AddressOfFault,
             RemoteHeap,
             AddressOfFault,
             RemoteFreeListSize);
}


VOID
PageHeapReportAllocation(
    ULONG64 RemoteHeap,
    ULONG64 RemoteHeapNode,
    PCHAR NodeType,
    ULONG64 AddressOfFault
    )
{
    ULONG64 RemoteUserBase;
    ULONG64 RemoteUserSize;
    ULONG64 EndOfBlock;
    ULONG64 PastTheBlock;
    ULONG64 BeforeTheBlock;

    InitTypeRead (RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK);
    RemoteUserBase = ReadField (pUserAllocation);
    RemoteUserSize = ReadField (nUserRequestedSize);

    EndOfBlock = RemoteUserBase + RemoteUserSize - 1;

    if (AddressOfFault > EndOfBlock) {

        PastTheBlock = AddressOfFault - EndOfBlock;

        dprintf( "\nPAGEHEAP: %p is %p bytes beyond the end of %s heap block at\n"
            "          %p of 0x%x bytes",
            AddressOfFault,
            PastTheBlock,
            NodeType,
            RemoteUserBase,
            RemoteUserSize
            );

    }
    else if (AddressOfFault >= RemoteUserBase) {

        dprintf( "\nPAGEHEAP: %p references %s heap block at\n"
            "          %p of 0x%x bytes",
            AddressOfFault,
            NodeType,
            RemoteUserBase,
            RemoteUserSize
            );

    }

    else {

        BeforeTheBlock = (PCHAR) RemoteUserBase - (PCHAR) AddressOfFault;

        dprintf( "\nPAGEHEAP: %p is %p bytes before the %s heap block at\n"
            "          %p of 0x%x bytes",
            AddressOfFault,
            BeforeTheBlock,
            NodeType,
            RemoteUserBase,
            RemoteUserSize
            );

    }

    {
        ULONG64 Trace;

        Trace = ReadField (StackTrace);
        dprintf ("\n\n");
        TraceDatabaseBlockDump (Trace);
    }
}


#define FORMAT_TYPE_BUSY_LIST 0
#define FORMAT_TYPE_FREE_LIST 1
#define FORMAT_TYPE_VIRT_LIST 2


BOOLEAN
PageHeapDumpThisList(
    ULONG64 RemoteList,
    PCH   ListName,
    ULONG FormatType
    )
{
    ULONG64 RemoteNode;
    ULONG64 RemoteBase;
    ULONG64 RemoteSize;
    ULONG64 RemoteUser;
    ULONG64 RemoteUsiz;
    ULONG64 RemoteFlag;
    ULONG64 RemoteValu;

    ULONG64 NextNode;

    RemoteNode = RemoteList;
    dprintf( "\n%s: \n", ListName);

    switch (FormatType) {
        
        case FORMAT_TYPE_BUSY_LIST:
                      
            dprintf( "Descriptor  UserAddr  UserSize  VirtAddr  VirtSize  UserFlag  UserValu\n" );
            break;

        case FORMAT_TYPE_FREE_LIST:
            
            dprintf( "Descriptor  UserAddr  UserSize  VirtAddr  VirtSize\n" );
            break;
    }

    while (RemoteNode) {

        InitTypeRead (RemoteNode, NTDLL!_DPH_HEAP_BLOCK);

        dprintf ("%p :  ", RemoteNode);

        RemoteBase = ReadField (pVirtualBlock );
        RemoteSize = ReadField (nVirtualBlockSize );
        RemoteUser = ReadField (pUserAllocation );
        RemoteUsiz = ReadField (nUserRequestedSize );
        RemoteFlag = ReadField (UserFlags );
        RemoteValu = ReadField (UserValue );

        NextNode = ReadField (pNextAlloc);
        
        switch (FormatType) {
            
            case FORMAT_TYPE_BUSY_LIST:

                if (RemoteFlag || RemoteValu) {

                    dprintf ("%p  %p  %p  %p  %p  %p\n",
                            RemoteUser,
                            RemoteUsiz,
                            RemoteBase,
                            RemoteSize,
                            RemoteFlag,
                            RemoteValu);
                }
                else {
                    
                    dprintf ("%p  %p  %p  %p\n",
                            RemoteUser,
                            RemoteUsiz,
                            RemoteBase,
                            RemoteSize);
                }

                break;

            case FORMAT_TYPE_FREE_LIST:

                dprintf ("%p  %p  %p  %p\n",
                         RemoteUser,
                         RemoteUsiz,
                         RemoteBase,
                         RemoteSize);

                break;

            case FORMAT_TYPE_VIRT_LIST:

                dprintf( "%p - %p (%p)\n",
                         RemoteBase,
                         (PCH)RemoteBase + RemoteSize,
                         RemoteSize);
                
                break;
        }

        if (CheckInterrupted()) {
            return FALSE;
        }
        
        //
        // Move on to the next node in the list.
        //

        RemoteNode = NextNode;
    }

    return TRUE;
}


BOOLEAN
PageHeapDumpThisHeap(
    ULONG64 RemoteHeap
    )
{
    ULONG64 RemoteNode;
    ULONG64 VirtualList;
    ULONG64 PoolList;
    ULONG64 AvailableList;
    ULONG64 FreeList;
    ULONG64 BusyList;

    InitTypeRead(RemoteHeap, NTDLL!_DPH_HEAP_ROOT);

    dprintf ("\nPage heap @ %I64X with associated light heap @ %I64X :\n\n",
             RemoteHeap,
             ReadField (NormalHeap));

    dprintf ("Signature:       %I64X\n", ReadField(Signature));
    dprintf ("HeapFlags:       %I64X\n", ReadField(HeapFlags));
    dprintf ("ExtraFlags:      %I64X\n", ReadField(ExtraFlags));
    dprintf ("NormalHeap:      %I64X\n", ReadField(NormalHeap));
    dprintf ("VirtualRanges:   %I64X\n", ReadField(nVirtualStorageRanges));
    dprintf ("VirtualCommit:   %I64X\n", ReadField(nVirtualStorageBytes));
    dprintf ("BusyAllocs:      %I64X\n", ReadField(nBusyAllocations));
    dprintf ("BusyVirtual:     %I64X\n", ReadField(nBusyAllocationBytesCommitted));
    dprintf ("BusyReadWrite:   %I64X\n", ReadField(nBusyAllocationBytesAccessible));
    dprintf ("FreeAllocs:      %I64X\n", ReadField(nFreeAllocations));
    dprintf ("FreeVirtual:     %I64X\n", ReadField(nFreeAllocationBytesCommitted));
    dprintf ("AvailAllocs:     %I64X\n", ReadField(nAvailableAllocations));
    dprintf ("AvailVirtual:    %I64X\n", ReadField(nAvailableAllocationBytesCommitted));
    dprintf ("NodePools:       %I64X\n", ReadField(nNodePools));
    dprintf ("NodeVirtual:     %I64X\n", ReadField(nNodePoolBytes));
    dprintf ("AvailNodes:      %I64X\n", ReadField(nUnusedNodes));
    dprintf ("Seed:            %I64X\n", ReadField(Seed));

    VirtualList = ReadField (pVirtualStorageListHead);
    PoolList = ReadField (pNodePoolListHead);
    AvailableList = ReadField (pAvailableAllocationListHead);
    FreeList = ReadField (pFreeAllocationListHead);
    BusyList = ReadField (pBusyAllocationListHead);

    {
        ULONG64 Trace;

        dprintf ("\n");
        Trace = ReadField (CreateStackTrace);
        TraceDatabaseBlockDump (Trace);
    }

    if (! PageHeapDumpThisList(VirtualList,
                               "VirtualList",
                               FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
    }

    if (! PageHeapDumpThisList(PoolList,
                               "NodePoolList",
                               FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
    }

    if (! PageHeapDumpThisList(AvailableList,
                               "AvailableList",
                               FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
    }

    if (! PageHeapDumpThisList(FreeList,
                               "FreeList",
                               FORMAT_TYPE_FREE_LIST )) {
        return FALSE;
    }

    if (! PageHeapDumpThisList(BusyList,
                               "BusyList",
                               FORMAT_TYPE_BUSY_LIST )) {
        return FALSE;
    }

    dprintf( "\n" );
    
    return TRUE;
}


VOID
PageHeapExtensionDump(
    PCSTR ArgumentString
    )
{
    ULONG64 RemoteHeapList;
    ULONG64 RemoteHeap;
    ULONG64 RemoteHeapToDump;
    BOOLEAN AnyDumps = FALSE;
    BOOL GetResult;
    ULONG Result;
    ULONG Offset;

    GetResult = GetExpressionEx (ArgumentString, 
                                 &RemoteHeapToDump,
                                 &ArgumentString);

    if (GetResult == FALSE) {
        dprintf ("\nFailed to convert `%s' to an address.\n",
                 ArgumentString);
        return;
    }

    RemoteHeapList = (ULONG64) GetExpression( "NTDLL!RtlpDphPageHeapList" );
    RemoteHeap = Read_PVOID( RemoteHeapList );

    if (( RemoteHeap       == 0 ) ||
        ( RemoteHeapToDump == 0 ) ||
        ( strchr( ArgumentString, '?' ))) {

        PageHeapHelp();
        PageHeapExtensionShowHeapList();
        return;
    }

    Result = GetFieldOffset ("NTDLL!_DPH_HEAP_ROOT",
                             "NextHeap",
                             &Offset);

    if (Result != 0) {
        dprintf ("\nFailed to get offset of `NextHeap' field.\n");
        return;
    }

    while (RemoteHeap != RemoteHeapList) {

        ULONG64 HeapAddress;

        HeapAddress = RemoteHeap - Offset;

        if ((((LONG_PTR)RemoteHeapToDump & 0xFFFF0000 ) == ((LONG_PTR)HeapAddress & 0xFFFF0000 )) ||
            ((LONG_PTR)RemoteHeapToDump == -1 )) {

            AnyDumps = TRUE;

            if (! PageHeapDumpThisHeap(HeapAddress))
                return;

        }

        if (CheckInterrupted()) {
            return;
        }

        //
        // Move forward in the list of Flink fields that chains
        // all heaps.
        //

        RemoteHeap = Read_PVOID (RemoteHeap);
    }

    if (! AnyDumps) {
        dprintf( "\nPage heap \"0x%p\" not found in process\n\n", RemoteHeapToDump );
        PageHeapExtensionShowHeapList();
    }
}


VOID
PageHeapDumpFaultInjectionSettings (
    VOID
    )
{
    ULONG64 Address;
    ULONG Probability;

    Probability = Read_ULONG (GetExpression ("NTDLL!RtlpDphFaultProbability"));

    if (Probability) {
        dprintf ("---------------------------------------------------------------\n");
        dprintf ("Page heap fault injection is enabled!                          \n");
        dprintf ("Heap allocations will fail randomly with probability %u/10000. \n", Probability); 
        dprintf ("---------------------------------------------------------------\n\n");
    }
}


BOOLEAN
PageHeapExtensionShowHeapList(
    VOID
    )
{
    ULONG64 RemoteHeapList;
    ULONG64 RemoteHeap;
    ULONG64 NormalHeap;
    ULONG64 HeapFlags;
    ULONG Result;
    ULONG Offset;

    PageHeapDumpFaultInjectionSettings ();

    RemoteHeapList = (ULONG64)GetExpression( "NTDLL!RtlpDphPageHeapList" );
    RemoteHeap = Read_PVOID( RemoteHeapList );

    if (RemoteHeap == 0) {

        dprintf( "\nNo page heaps active in process (or bad symbols)\n" );
        return FALSE;
    }
    else {

        Result = GetFieldOffset ("NTDLL!_DPH_HEAP_ROOT",
                                 "NextHeap",
                                 &Offset);

        if (Result != 0) {
            dprintf ("\nFailed to get offset of `NextHeap' field.\n");
            return FALSE;
        }

        dprintf ("Page heaps active in the process "
                 "(format: pageheap, lightheap, flags): \n\n");

        while (RemoteHeap && (RemoteHeap != RemoteHeapList)) {

            InitTypeRead (RemoteHeap - Offset, NTDLL!_DPH_HEAP_ROOT);

            NormalHeap = ReadField (NormalHeap);
            HeapFlags = ReadField (ExtraFlags);

            dprintf ("    %p , %p , %I64X (",
                     RemoteHeap - Offset, 
                     NormalHeap, 
                     HeapFlags);

            PageHeapPrintFlagsMeaning (HeapFlags);

            dprintf (")\n");

            //
            // Move forward in the list of Flink fields that chains
            // all heaps.
            //

            RemoteHeap = Read_PVOID (RemoteHeap);
            if (CheckInterrupted()) {
                break;
            }
        }

        dprintf( "\n" );
        return TRUE;
    }
}


BOOLEAN
PageHeapIsActive(
    VOID
    )
{
    ULONG64 RemoteHeapList = (ULONG64)GetExpression ("NTDLL!RtlpDphPageHeapList" );
    ULONG64 RemoteHeap = Read_PVOID( RemoteHeapList );

    if (RemoteHeap == 0) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


VOID            
PageHeapPrintFlagsMeaning (
    ULONG64 HeapFlags
    )
{
    if ((HeapFlags & PAGE_HEAP_ENABLE_PAGE_HEAP)) {
        dprintf ("pageheap ");
    }
    else {
        dprintf ("lightheap ");
    }

    if ((HeapFlags & PAGE_HEAP_COLLECT_STACK_TRACES)) {
        dprintf ("traces ");
    }

    if ((HeapFlags & PAGE_HEAP_NO_UMDH_SUPPORT)) {
        dprintf ("no_umdh ");
    }

    if ((HeapFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
        dprintf ("backwards ");
    }

    if ((HeapFlags & PAGE_HEAP_UNALIGNED_ALLOCATIONS)) {
        dprintf ("unaligned ");
    }

    if ((HeapFlags & PAGE_HEAP_USE_SIZE_RANGE)) {
        dprintf ("size_range ");
    }

    if ((HeapFlags & PAGE_HEAP_USE_DLL_RANGE)) {
        dprintf ("dll_range ");
    }

    if ((HeapFlags & PAGE_HEAP_USE_RANDOM_DECISION)) {
        dprintf ("random ");
    }

    if ((HeapFlags & PAGE_HEAP_USE_DLL_NAMES)) {
        dprintf ("dlls ");
    }

    if ((HeapFlags & PAGE_HEAP_USE_FAULT_INJECTION)) {
        dprintf ("faults ");
    }

    if ((HeapFlags & PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS)) {
        dprintf ("no_serialize ");
    }

    if ((HeapFlags & PAGE_HEAP_NO_LOCK_CHECKS)) {
        dprintf ("no_lock_checks ");
    }

    if ((HeapFlags & PAGE_HEAP_USE_READONLY)) {
        dprintf ("readonly ");
    }
}



VOID
PageHeapExtension(
    PCSTR ArgumentString
    )
{
    PCSTR Current;
    
    //
    // Is help requested?
    //

    if (strstr (ArgumentString, "?") != NULL) {

        PageHeapHelp ();
    }

    //
    // If page heap not active then return immediately.
    //

    if (! PageHeapIsActive()) {
        dprintf ("Page heap is not active for this process. \n");
        return;
    }

    //
    // Parse command line
    //

    if ((Current = strstr (ArgumentString, "-h")) != NULL) {

        PageHeapExtensionDump (Current + strlen("-h"));
    }
    else if ((Current = strstr (ArgumentString, "-a")) != NULL) {

        PageHeapExtensionFind (Current + strlen("-a"));
    }
    else if ((Current = strstr (ArgumentString, "-tc")) != NULL) {

        PageHeapUseUmdh ();
    }
    else if ((Current = strstr (ArgumentString, "-ts")) != NULL) {

        PageHeapUseUmdh ();
    }
    else if ((Current = strstr (ArgumentString, "-t")) != NULL) {

        PageHeapUseUmdh ();
    }
    else if ((Current = strstr (ArgumentString, "-fi")) != NULL) {

        FaultInjectionTracesDump (Current + strlen("-fi"));
    }
    else {
        PageHeapExtensionShowHeapList ();
    }

    return;
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// Trace database
/////////////////////////////////////////////////////////////////////


VOID
TraceDatabaseBlockDump (
    ULONG64 Address
    )
{
    ULONG64 TraceAddress;
    ULONG64 ReturnAddress;
    CHAR  SymbolName[ 1024 ];
    ULONG64 Displacement;
    ULONG I;
    ULONG64 BlockSize;
    ULONG PvoidSize;
     
    if (Address == 0) {
        dprintf ("    No trace\n");
        return;
    }

    PvoidSize = IsPtr64() ? 8 : 4;
    
    InitTypeRead (Address, NTDLL!_RTL_STACK_TRACE_ENTRY);

    BlockSize = ReadField (Depth);

    dprintf ("    Trace @ %I64X \n", 
             Address);

    for (I = 0; I < BlockSize; I += 1) {

        TraceAddress = ReadField (BackTrace);

        ReturnAddress = Read_PVOID (TraceAddress + I * PvoidSize);

        GetSymbol (ReturnAddress, SymbolName, &Displacement);

        dprintf ("    %p %s+0x%p\n", 
                 ReturnAddress, 
                 SymbolName, 
                 Displacement);
    }
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// Fault injection traces
/////////////////////////////////////////////////////////////////////


VOID
FaultInjectionTracesDump (
    PCSTR Args
    )
{
    ULONG64 TracesToDisplay = 0;
    ULONG64 TraceAddress;
    ULONG64 IndexAddress;
    ULONG Index;
    ULONG I;
    const ULONG NO_OF_FAULT_INJECTION_TRACES = 128;
    ULONG PvoidSize;
    ULONG64 TraceBlock;
    ULONG TracesFound = 0;
    BOOLEAN Interrupted = FALSE;
    ULONG64 FlagsAddress;
    ULONG Flags;
     
    if (Args) {
        TracesToDisplay = GetExpression(Args);

        if (TracesToDisplay == 0) {
            TracesToDisplay = 4;
        }
    }

    PvoidSize = IsPtr64() ? 8 : 4;
    
    TraceAddress = (ULONG64) GetExpression ("NTDLL!RtlpDphFaultStacks");
    IndexAddress = (ULONG64) GetExpression ("NTDLL!RtlpDphFaultStacksIndex");
    FlagsAddress = (ULONG64) GetExpression ("NTDLL!RtlpDphGlobalFlags");

    Flags = Read_ULONG (FlagsAddress);

    if (! (Flags & PAGE_HEAP_USE_FAULT_INJECTION)) {

        dprintf ("Fault injection is not enabled for this process. \n");
        dprintf ("Use `pageheap /enable PROGRAM /fault RATE' to enable it. \n");
        return;
    }

    Index = Read_ULONG (IndexAddress);

    for (I = 0; I < NO_OF_FAULT_INJECTION_TRACES; I += 1) {

        Index -= 1;
        Index &= (NO_OF_FAULT_INJECTION_TRACES - 1);
        
        TraceBlock = Read_PVOID (TraceAddress + Index * PvoidSize);

        if (TraceBlock != 0) {
            TracesFound += 1;
            
            dprintf ("\n");
            TraceDatabaseBlockDump (TraceBlock);

            if (TracesFound >= TracesToDisplay) {
                break;
            }
        }
        
        if (CheckControlC()) {
            Interrupted = TRUE;
            dprintf ("Interrupted \n");
            break;
        }
    }

    if (Interrupted == FALSE && TracesFound == 0) {

        dprintf ("No fault injection traces found. \n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\help.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    WinDbg Extension Api

Author:

    Kshitiz K. Sharma (kksharma) 10-Jan-2001

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


DECLARE_API( help )
{
    dprintf("acl <address> [flags]        - Displays the ACL\n" );
    dprintf("atom <address>               - Displays the atom or table(s) for the process\n");
    dprintf("avrf [-? | parameters]       - Displays or modifies App Verifier settings\n");
    dprintf("cs [-? | parameters]         - Displays critical sections for the process\n");
    dprintf("cxr                          - Obsolete, .cxr is new command\n");
    dprintf("dlls [-h | parameters]       - Displays loaded DLLS\n");
    dprintf("exr                          - Obsolete, .exr is new command\n");
    dprintf("gflag [-?|<value>]           - Displays the global flag\n");
    dprintf("heap [-? | parameters]       - Displays heap info\n");
    dprintf("help                         - Displays this list\n");
    dprintf("kuser                        - Displays KUSER_SHARED_DATA\n");
    dprintf("list [-? | parameters]       - Displays lists\n");
    dprintf("peb [address]                - Displays the PEB structure\n");
    dprintf("psr <value>|@ipsr [flags]    - Displays an IA64 Processor Status Word\n");
    dprintf("sd <address> [flags]         - Displays the SECURITY_DESCRIPTOR\n" );
    dprintf("sid <address> [flags]        - Displays the SID\n" );
    dprintf("slist [-? | parameters]      - Displays singly-linked list\n");
    dprintf("teb [address]                - Displays the TEB structure\n"); 
    dprintf("tls <slot | -1> [teb | 0]    - Dumps TLS slots. !tls /? for usage\n");
    dprintf("token [-n|-?] <handle|addr>  - Displays TOKEN\n");
/*
    This is not working yet.  Contact SilviuC for more info.
    dprintf("udeadlock [-? | parameters]  - Displays App Verifier deadlock detection info\n");
*/

    dprintf("\nType \".hh [command]\" for more detailed help\n");

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\heappagxxp.c ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappagx.c

Abstract:

    This module contains the page heap manager debug extensions.

Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/


#define DEBUG_PAGE_HEAP 1

#include "precomp.h"
#include "heap.h"


__inline
BOOLEAN
CheckInterrupted(
    VOID
    )
{
    if (CheckControlC()) {
        dprintf( "\nInterrupted\n\n" );
        return TRUE;
    }
    return FALSE;
}

__inline
ULONG64
FetchRemotePVOID (
    ULONG64 Address
    )
{
    ULONG64 RemoteValue = 0;
    ReadPointer( Address, &RemoteValue);
    return RemoteValue;
}

__inline
ULONG
FetchRemoteULONG(
    ULONG64 Address
    )
{
    ULONG RemoteValue = 0;
    ReadMemory( Address, &RemoteValue, sizeof( ULONG ), NULL );
    return RemoteValue;
}

ULONG
ReturnFieldOffset(
    PCHAR TypeName,
    PCHAR FieldName);


#define FETCH_REMOTE_FIELD_PTR( StructBase, StructType, FieldName ) \
            FetchRemotePVOID((StructBase) + ReturnFieldOffset( #StructType, #FieldName ))

#define FETCH_REMOTE_FIELD_INT( StructBase, StructType, FieldName ) \
            FetchRemoteULONG((StructBase) + ReturnFieldOffset( #StructType, #FieldName ))

#define FETCH_REMOTE_FIELD_SIZE_T( StructBase, StructType, FieldName ) \
            FetchRemotePVOID((StructBase) + ReturnFieldOffset( #StructType, #FieldName ))

#define DUMP_REMOTE_FIELD_INT( DumpName, StructBase, StructType, FieldName ) \
            dprintf( "%s%08X\n", (DumpName), FETCH_REMOTE_FIELD_INT( StructBase, StructType, FieldName ))

#define DUMP_REMOTE_FIELD_PTR( DumpName, StructBase, StructType, FieldName ) \
            dprintf( "%s%p\n", (DumpName), FETCH_REMOTE_FIELD_PTR( StructBase, StructType, FieldName ))

VOID
DebugPageHeapLocateFaultAllocationXP(
    ULONG64 RemoteHeap,
    ULONG64 AddressOfFault
    );

VOID
DebugPageHeapReportAllocationXP(
    ULONG64 RemoteHeap,
    ULONG64 RemoteHeapNode,
    PCHAR NodeType,
    ULONG64 AddressOfFault
    );

BOOLEAN
DebugPageHeapExtensionShowHeapListXP(
    VOID
    );

VOID
TraceDatabaseDumpXP (
    PCSTR Args,
    BOOLEAN SortByCountField
    );

VOID
TraceDatabaseBlockDumpXP (
    ULONG64 Address
    );

VOID
FaultInjectionTracesDumpXP (
    PCSTR Args
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID DebugPageHeapHelpXP (
    )
{

    dprintf ("!heap -p          Dump all page heaps.                        \n");
    dprintf ("!heap -p -h ADDR  Detailed dump of page heap at ADDR.         \n");
    dprintf ("!heap -p -a ADDR  Figure out what heap block is at ADDR.      \n");
    dprintf ("!heap -p -t [N]   Dump N collected traces with heavy heap users.\n");
    dprintf ("!heap -p -tc [N]  Dump N traces sorted by count usage (eqv. with -t).\n");
    dprintf ("!heap -p -ts [N]  Dump N traces sorted by size.\n");
    dprintf ("!heap -p -fi [N]  Dump last N fault injection traces.\n");
    dprintf ("                                                              \n");
    dprintf (" +-----+---------------+--+                                   \n");
    dprintf (" |     |               |  | Normal heap allocated block       \n");
    dprintf (" +-----+---------------+--+                                   \n");
    dprintf ("     ^         ^        ^                                     \n");
    dprintf ("     |         |        8 suffix bytes filled with 0xA0       \n");
    dprintf ("     |         user allocation (filled with E0 if zeroing not requested) \n");
    dprintf ("     block header (starts with 0xABCDAAAA and ends with 0xDCBAAAAA).\n");
    dprintf ("     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n");
    dprintf ("     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n");
    dprintf ("                                                              \n");
    dprintf (" +-----+---------------+--+                                   \n");
    dprintf (" |     |               |  | Normal heap freed block           \n");
    dprintf (" +-----+---------------+--+                                   \n");
    dprintf ("     ^         ^        ^                                     \n");
    dprintf ("     |         |        8 suffix bytes filled with 0xA0       \n");
    dprintf ("     |         user allocation (filled with F0 bytes)         \n");
    dprintf ("     block header (starts with 0xABCDAAA9 and ends with 0xDCBAAA9). \n");
    dprintf ("     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n");
    dprintf ("     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n");
    dprintf ("                                                              \n");
    dprintf (" +-----+---------+--+------                                   \n");
    dprintf (" |     |         |  | ... N/A page     Page heap              \n");
    dprintf (" +-----+---------+--+------            allocated block        \n");
    dprintf ("     ^         ^   ^                                          \n");
    dprintf ("     |         |   0-7 suffix bytes filled with 0xD0          \n");
    dprintf ("     |         user allocation (filled with C0 if zeroing not requested) \n");
    dprintf ("     block header (starts with 0xABCDBBBB and ends with 0xDCBABBBB).\n");
    dprintf ("     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n");
    dprintf ("     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n");
    dprintf ("                                                              \n");
    dprintf (" +-----+---------+--+------                                   \n");
    dprintf (" |     |         |  | ... N/A page     Page heap              \n");
    dprintf (" +-----+---------+--+------            freed block            \n");
    dprintf ("     ^         ^   ^                                          \n");
    dprintf ("     |         |   0-7 suffix bytes filled with 0xD0          \n");
    dprintf ("     |         user allocation (filled with F0 bytes)         \n");
    dprintf ("     block header (starts with 0xABCDBBA and ends with 0xDCBABBBA).\n");
    dprintf ("     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n");
    dprintf ("     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n");
    dprintf ("                                                              \n");
}


VOID
DebugPageHeapExtensionFindXP(
    PCSTR ArgumentString
    )
{
    ULONG64 RemoteHeapList;
    ULONG64 RemoteHeap;
    ULONG64 RemoteVirtualNode;
    ULONG64 RemoteVirtualBase;
    ULONG64 RemoteVirtualSize;
    ULONG64 AddressOfFault;
    BOOL Result;

    Result = GetExpressionEx (ArgumentString, 
                              &AddressOfFault,
                              &ArgumentString);

    if (Result == FALSE) {
        dprintf ("\nFailed to convert `%s' to an address.\n",
                 ArgumentString);
        return;
    }

    RemoteHeapList = (ULONG64) GetExpression( "NTDLL!RtlpDphHeapListHead" );
    RemoteHeap     = FetchRemotePVOID( RemoteHeapList );

    if (RemoteHeap == 0) {
        dprintf( "\nNo page heaps active in process (or bad symbols)\n\n" );
        AddressOfFault = 0;
    }

    if (( AddressOfFault == 0 ) || ( strchr( ArgumentString, '?' ))) {

        DebugPageHeapHelpXP();
        return;
    }

    //
    //  Find the heap that contains the range of virtual addresses that
    //  contain the AddressOfFault.
    //

    for (;;) {

        //
        //  The heap header contains a linked list of virtual memory
        //  allocations.
        //

        RemoteVirtualNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pVirtualStorageListHead );

        while (RemoteVirtualNode != 0) {

            RemoteVirtualBase = FETCH_REMOTE_FIELD_PTR( RemoteVirtualNode, NTDLL!_DPH_HEAP_BLOCK, pVirtualBlock );
            RemoteVirtualSize = FETCH_REMOTE_FIELD_SIZE_T( RemoteVirtualNode, NTDLL!_DPH_HEAP_BLOCK, nVirtualBlockSize );

            if (( RemoteVirtualBase == 0 ) || ( RemoteVirtualSize == 0 )) {
                dprintf( "\nPAGEHEAP: Heap 0x%p appears to have an invalid\n"
                    "          virtual allocation list\n\n",
                    RemoteHeap
                    );
            }

            if ((AddressOfFault >= RemoteVirtualBase) &&
                (AddressOfFault <= RemoteVirtualBase + RemoteVirtualSize )) {

                //
                //  The fault appears to have occurred in the range of this
                //  heap, so we'll search the busy and free lists for the
                //  closest match and report it.  Then exit.
                //

                DebugPageHeapLocateFaultAllocationXP( RemoteHeap, AddressOfFault );
                return;
            }

            if (CheckInterrupted()) {
                return;
            }

            RemoteVirtualNode = FETCH_REMOTE_FIELD_PTR( RemoteVirtualNode, NTDLL!_DPH_HEAP_BLOCK, pNextAlloc );

        }


        //
        //  Not found in this heap.  Continue with next heap or end
        //  of heap list.
        //

        if (CheckInterrupted()) {
            return;
        }

        RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pNextHeapRoot );

        if (RemoteHeap == 0) {
            dprintf( "\nPAGEHEAP: Could not find a page heap containing\n"
                "          the virtual address 0x%p\n\n",
                AddressOfFault
                );
            return;
        }
    }
}


VOID
DebugPageHeapLocateFaultAllocationXP(
    ULONG64 RemoteHeap,
    ULONG64 AddressOfFault
    )
{
    ULONG64 ClosestHeapNode;
    ULONG64 ClosestDifference;
    ULONG64 RemoteHeapNode;
    ULONG64 RemoteAllocBase;
    ULONG64 RemoteAllocSize;
    ULONG RemoteFreeListSize;

    ClosestHeapNode = 0;

    //
    //  First search the busy list for the containing allocation, if any.
    //

    RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pBusyAllocationListHead );

    while (RemoteHeapNode != 0) {

        RemoteAllocBase = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pVirtualBlock );
        RemoteAllocSize = FETCH_REMOTE_FIELD_SIZE_T( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, nVirtualBlockSize );

        if ((AddressOfFault >= RemoteAllocBase) &&
            (AddressOfFault < RemoteAllocBase + RemoteAllocSize)) {

            //
            //  The fault appears to have occurred in this allocation's
            //  memory (which includes the NO_ACCESS page beyond the user
            //  portion of the allocation).
            //

            DebugPageHeapReportAllocationXP( RemoteHeap, RemoteHeapNode, "allocated", AddressOfFault );
            return;
        }

        if (CheckInterrupted()) {
            return;
        }

        RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pNextAlloc );
    }

    //
    //  Failed to find containing allocation on busy list, so search free.
    //

    RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pFreeAllocationListHead );

    while (RemoteHeapNode != 0) {

        RemoteAllocBase = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pVirtualBlock );
        RemoteAllocSize = FETCH_REMOTE_FIELD_INT( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, nVirtualBlockSize );

        if ((AddressOfFault >= RemoteAllocBase) &&
            (AddressOfFault < RemoteAllocBase + RemoteAllocSize)) {

            //
            //  The fault appears to have occurred in this freed alloc's
            //  memory.
            //

            DebugPageHeapReportAllocationXP( RemoteHeap, RemoteHeapNode, "freed", AddressOfFault );
            return;
        }

        if (CheckInterrupted()) {
            return;
        }

        RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pNextAlloc );
    }

    //
    //  Failed to find containing allocation in free list, but we wouldn't
    //  have gotten this far if the debug heap did not contain the virtual
    //  address range of the fault.  So, report it as a wild pointer that
    //  could have been freed memory.
    //

    RemoteFreeListSize = FETCH_REMOTE_FIELD_INT( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nFreeAllocations );

    dprintf( "\nPAGEHEAP: %p references memory contained in the heap %p,\n"
        "          but does not reference an existing allocated or\n"
        "          recently freed heap block.  It is possible that\n"
        "          the memory at %p could previously have been\n"
        "          allocated and freed, but it must have been freed\n"
        "          prior to the most recent %d frees.\n\n",
        AddressOfFault,
        RemoteHeap,
        AddressOfFault,
        RemoteFreeListSize
        );

}


VOID
DebugPageHeapReportAllocationXP(
    ULONG64 RemoteHeap,
    ULONG64 RemoteHeapNode,
    PCHAR NodeType,
    ULONG64 AddressOfFault
    )
{
    ULONG64 RemoteUserBase;
    ULONG64 RemoteUserSize;
    ULONG64 EndOfBlock;
    ULONG64 PastTheBlock;
    ULONG64 BeforeTheBlock;

    RemoteUserBase = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pUserAllocation );
    RemoteUserSize = FETCH_REMOTE_FIELD_SIZE_T( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, nUserRequestedSize );

    EndOfBlock = RemoteUserBase + RemoteUserSize - 1;

    if (AddressOfFault > EndOfBlock) {

        PastTheBlock = AddressOfFault - EndOfBlock;

        dprintf( "\nPAGEHEAP: %p is %p bytes beyond the end of %s heap block at\n"
            "          %p of 0x%x bytes",
            AddressOfFault,
            PastTheBlock,
            NodeType,
            RemoteUserBase,
            RemoteUserSize
            );

    }

    else if (AddressOfFault >= RemoteUserBase) {

        dprintf( "\nPAGEHEAP: %p references %s heap block at\n"
            "          %p of 0x%x bytes",
            AddressOfFault,
            NodeType,
            RemoteUserBase,
            RemoteUserSize
            );

    }

    else {

        BeforeTheBlock = (PCHAR) RemoteUserBase - (PCHAR) AddressOfFault;

        dprintf( "\nPAGEHEAP: %p is %p bytes before the %s heap block at\n"
            "          %p of 0x%x bytes",
            AddressOfFault,
            BeforeTheBlock,
            NodeType,
            RemoteUserBase,
            RemoteUserSize
            );

    }

    {
        ULONG64 Trace;

        Trace = FETCH_REMOTE_FIELD_PTR (RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, StackTrace);
        dprintf ("\n\n");
        TraceDatabaseBlockDumpXP (Trace);
    }
}


#define FORMAT_TYPE_BUSY_LIST 0
#define FORMAT_TYPE_FREE_LIST 1
#define FORMAT_TYPE_VIRT_LIST 2


BOOLEAN
DebugPageHeapDumpThisListXP(
    ULONG64 RemoteList,
    PCH   ListName,
    ULONG FormatType
    )
{
    ULONG64 RemoteNode;
    ULONG64 RemoteBase;
    ULONG64 RemoteSize;
    ULONG64 RemoteUser;
    ULONG64 RemoteUsiz;
    ULONG RemoteFlag;
    ULONG64 RemoteValu;

    RemoteNode = RemoteList;
    dprintf( "\n%s:\n", ListName );

    switch (FormatType) {
    
    case FORMAT_TYPE_BUSY_LIST:
        dprintf( "UserAddr  UserSize  VirtAddr  VirtSize  UserFlag  UserValu\n" );
        break;
    case FORMAT_TYPE_FREE_LIST:
        dprintf( "UserAddr  UserSize  VirtAddr  VirtSize\n" );
        break;
    }

    while (RemoteNode) {

        RemoteBase = FETCH_REMOTE_FIELD_PTR( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, pVirtualBlock );
        RemoteSize = FETCH_REMOTE_FIELD_SIZE_T( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, nVirtualBlockSize );
        RemoteUser = FETCH_REMOTE_FIELD_PTR( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, pUserAllocation );
        RemoteUsiz = FETCH_REMOTE_FIELD_SIZE_T( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, nUserRequestedSize );
        RemoteFlag = FETCH_REMOTE_FIELD_INT( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, UserFlags );
        RemoteValu = FETCH_REMOTE_FIELD_PTR( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, UserValue );
        RemoteNode = FETCH_REMOTE_FIELD_PTR( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, pNextAlloc );

        switch (FormatType) {
        
        case FORMAT_TYPE_BUSY_LIST:

            dprintf(( RemoteFlag || RemoteValu ) ?
                "%p  %08X  %p  %08X  %08X  %p\n" :
            "%p  %08X  %p  %08X\n",
                RemoteUser,
                RemoteUsiz,
                RemoteBase,
                RemoteSize,
                RemoteFlag,
                RemoteValu
                );
            break;

        case FORMAT_TYPE_FREE_LIST:

            dprintf( "%p  %08X  %p  %08X\n",
                RemoteUser,
                RemoteUsiz,
                RemoteBase,
                RemoteSize
                );
            break;

        case FORMAT_TYPE_VIRT_LIST:

            dprintf( "%p - %p (%08X)\n",
                RemoteBase,
                (PCH)RemoteBase + RemoteSize,
                RemoteSize
                );
            break;

        }

        if (CheckInterrupted()) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
DebugPageHeapDumpThisHeapXP(
    ULONG64 RemoteHeap
    )
{
    ULONG64 RemoteNode;

    dprintf( "\nDPH Heap at %p:\n\n", RemoteHeap );

    DUMP_REMOTE_FIELD_INT( "Signature:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Signature );
    DUMP_REMOTE_FIELD_INT( "HeapFlags:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, HeapFlags );
    DUMP_REMOTE_FIELD_INT( "ExtraFlags:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, ExtraFlags );
    DUMP_REMOTE_FIELD_INT( "NormalHeap:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, NormalHeap );
    DUMP_REMOTE_FIELD_INT( "VirtualRanges:   ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nVirtualStorageRanges );
    DUMP_REMOTE_FIELD_PTR( "VirtualCommit:   ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nVirtualStorageBytes );
    DUMP_REMOTE_FIELD_INT( "BusyAllocs:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nBusyAllocations );
    DUMP_REMOTE_FIELD_PTR( "BusyVirtual:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nBusyAllocationBytesCommitted );
    DUMP_REMOTE_FIELD_PTR( "BusyReadWrite:   ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nBusyAllocationBytesAccessible );
    DUMP_REMOTE_FIELD_INT( "FreeAllocs:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nFreeAllocations );
    DUMP_REMOTE_FIELD_PTR( "FreeVirtual:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nFreeAllocationBytesCommitted );
    DUMP_REMOTE_FIELD_INT( "AvailAllocs:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nAvailableAllocations );
    DUMP_REMOTE_FIELD_PTR( "AvailVirtual:    ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nAvailableAllocationBytesCommitted );
    DUMP_REMOTE_FIELD_INT( "NodePools:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nNodePools );
    DUMP_REMOTE_FIELD_PTR( "NodeVirtual:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nNodePoolBytes );
    DUMP_REMOTE_FIELD_INT( "AvailNodes:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nUnusedNodes );
    DUMP_REMOTE_FIELD_INT( "Seed:            ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Seed );

    dprintf (" --- Counters --- \n");
    DUMP_REMOTE_FIELD_INT( "Size < 1K:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[0] );
    DUMP_REMOTE_FIELD_INT( "Size < 4K:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[1] );
    DUMP_REMOTE_FIELD_INT( "Size >= 4K:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[2] );
    DUMP_REMOTE_FIELD_INT( "W/o alloc info:  ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[3] );
    DUMP_REMOTE_FIELD_INT( "Total allocs:    ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[4] );
    DUMP_REMOTE_FIELD_INT( "Total reallocs:  ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[5] );
    DUMP_REMOTE_FIELD_INT( "Total frees:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[6] );
    DUMP_REMOTE_FIELD_INT( "Normal allocs:   ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[7] );
    DUMP_REMOTE_FIELD_INT( "Normal reallocs: ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[8] );
    DUMP_REMOTE_FIELD_INT( "Normal frees:    ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[9] );

    {
        ULONG64 Trace;

        dprintf ("\n");
        Trace = FETCH_REMOTE_FIELD_PTR (RemoteHeap, NTDLL!_DPH_HEAP_ROOT, CreateStackTrace);
        TraceDatabaseBlockDumpXP (Trace);
    }

    if (! DebugPageHeapDumpThisListXP(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pVirtualStorageListHead ),
        "VirtualList",
        FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
    }

    if (! DebugPageHeapDumpThisListXP(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pNodePoolListHead ),
        "NodePoolList",
        FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
    }

    if (! DebugPageHeapDumpThisListXP(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pAvailableAllocationListHead ),
        "AvailableList",
        FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
    }

    if (! DebugPageHeapDumpThisListXP(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pFreeAllocationListHead ),
        "FreeList",
        FORMAT_TYPE_FREE_LIST )) {
        return FALSE;
    }

    if (! DebugPageHeapDumpThisListXP(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pBusyAllocationListHead ),
        "BusyList",
        FORMAT_TYPE_BUSY_LIST )) {
        return FALSE;
    }

    dprintf( "\n" );
    return TRUE;
}


VOID
DebugPageHeapExtensionDumpXP(
    PCSTR ArgumentString
    )
{
    ULONG64 RemoteHeapList;
    ULONG64 RemoteHeap;
    ULONG64 RemoteHeapToDump;
    BOOLEAN AnyDumps = FALSE;
    BOOL Result;

    Result = GetExpressionEx (ArgumentString, 
                              &RemoteHeapToDump,
                              &ArgumentString);

    if (Result == FALSE) {
        dprintf ("\nFailed to convert `%s' to an address.\n",
                 ArgumentString);
        return;
    }

    RemoteHeapList = (ULONG64) GetExpression( "NTDLL!RtlpDphHeapListHead" );
    RemoteHeap = FetchRemotePVOID( RemoteHeapList );

    if (( RemoteHeap       == 0 ) ||
        ( RemoteHeapToDump == 0 ) ||
        ( strchr( ArgumentString, '?' ))) {

        DebugPageHeapHelpXP();
        DebugPageHeapExtensionShowHeapListXP();
        return;
    }

    while (RemoteHeap != 0) {

        if ((((LONG_PTR)RemoteHeapToDump & 0xFFFF0000 ) == ((LONG_PTR)RemoteHeap & 0xFFFF0000 )) ||
            ((LONG_PTR)RemoteHeapToDump == -1 )) {

            AnyDumps = TRUE;

            if (! DebugPageHeapDumpThisHeapXP( RemoteHeap ))
                return;

        }

        if (CheckInterrupted()) {
            return;
        }

        RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pNextHeapRoot );
    }

    if (! AnyDumps) {
        dprintf( "\nPage heap \"0x%p\" not found in process\n\n", RemoteHeapToDump );
        DebugPageHeapExtensionShowHeapListXP();
    }
}


BOOLEAN
DebugPageHeapExtensionShowHeapListXP(
    VOID
    )
{
    ULONG64 RemoteHeapList = (ULONG64)GetExpression( "NTDLL!RtlpDphHeapListHead" );
    ULONG64 RemoteHeap     = FetchRemotePVOID( RemoteHeapList );
    ULONG64 NormalHeap;
    ULONG HeapFlags;

    if (RemoteHeap == 0) {

        dprintf( "\nNo page heaps active in process (or bad symbols)\n" );
        return FALSE;
    }
    else {

        dprintf( "\nPage heaps active in process:\n\n" );

        do {

            NormalHeap = FETCH_REMOTE_FIELD_PTR (RemoteHeap, NTDLL!_DPH_HEAP_ROOT, NormalHeap);
            HeapFlags = (ULONG) FETCH_REMOTE_FIELD_INT (RemoteHeap, NTDLL!_DPH_HEAP_ROOT, ExtraFlags);

            dprintf ("    %p (%p, flags %X)\n", RemoteHeap, NormalHeap, HeapFlags);

            RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pNextHeapRoot );

        } while (RemoteHeap);

        dprintf( "\n" );
        return TRUE;
    }
}


BOOLEAN
DebugPageHeapIsActiveXP(
    VOID
    )
{
    ULONG64 RemoteHeapList = (ULONG64)GetExpression( "NTDLL!RtlpDphHeapListHead" );
    ULONG64 RemoteHeap     = FetchRemotePVOID( RemoteHeapList );

    if (RemoteHeap == 0) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


VOID
DebugPageHeapExtensionXP(
    PCSTR ArgumentString
    )
{
    PCSTR Current;
    
    //
    // Is help requested?
    //

    if (strstr (ArgumentString, "?") != NULL) {

        DebugPageHeapHelpXP ();
    }

    //
    // If page heap not active then return immediately.
    //

    if (! DebugPageHeapIsActiveXP()) {
        dprintf ("Page heap is not active for this process. \n");
        return;
    }

    //
    // Parse command line
    //

    if ((Current = strstr (ArgumentString, "-h")) != NULL) {

        DebugPageHeapExtensionDumpXP (Current + strlen("-h"));
    }
    else if ((Current = strstr (ArgumentString, "-a")) != NULL) {

        DebugPageHeapExtensionFindXP (Current + strlen("-a"));
    }
    else if ((Current = strstr (ArgumentString, "-tc")) != NULL) {

        TraceDatabaseDumpXP (Current + strlen("-tc"), TRUE);
    }
    else if ((Current = strstr (ArgumentString, "-ts")) != NULL) {

        TraceDatabaseDumpXP (Current + strlen("-ts"), FALSE);
    }
    else if ((Current = strstr (ArgumentString, "-t")) != NULL) {

        TraceDatabaseDumpXP (Current + strlen("-t"), TRUE);
    }
    else if ((Current = strstr (ArgumentString, "-fi")) != NULL) {

        FaultInjectionTracesDumpXP (Current + strlen("-fi"));
    }
    else {
        DebugPageHeapExtensionShowHeapListXP ();
    }

    return;
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// Trace database
/////////////////////////////////////////////////////////////////////

typedef struct {
    
    ULONG64 Address;
    ULONG64 Count;
    ULONG64 Size;

} TRACE, *PTRACE;

VOID
TraceDatabaseDumpXP (
    PCSTR Args,
    BOOLEAN SortByCountField
    )
{
    ULONG64 Database;
    ULONG I, J, Min, TraceIndex;
    PTRACE Trace;
    ULONG64 TracesToDisplay = 0;
    ULONG64 MaximumSize;
    ULONG64 CurrentSize;
    ULONG64 NoOfTraces;
    ULONG64 NoOfHits;
    ULONG NoOfBuckets;
    ULONG PvoidSize;
     
    if (Args) {
        TracesToDisplay = GetExpression(Args);

        if (TracesToDisplay == 0) {
            TracesToDisplay = 4;
        }
    }

    Database = (ULONG64) GetExpression ("NTDLL!RtlpDphTraceDatabaseXP" );
    Database = FetchRemotePVOID (Database);

    MaximumSize = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, MaximumSize);
    CurrentSize = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, CurrentSize);

    NoOfBuckets = FETCH_REMOTE_FIELD_INT(Database, NTDLL!_RTL_TRACE_DATABASE, NoOfBuckets);
    NoOfTraces = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, NoOfTraces);
    NoOfHits = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, NoOfHits);

    PvoidSize = IsPtr64() ? 8 : 4;

    dprintf ("MaximumSize: %p \n", MaximumSize);
    dprintf ("CurentSize: %p \n", CurrentSize);
    dprintf ("NoOfBuckets: %u \n", NoOfBuckets);
    dprintf ("NoOfTraces: %p \n", NoOfTraces); 
    dprintf ("NoOfHits: %p \n", NoOfHits);

    //
    // Dump hash counters.
    //

    dprintf ("HashCounters:");

    for (I = 0; I < 16; I += 1) {

        CHAR FieldName[16];

        sprintf (FieldName, "HashCounter[%u]", I);

        dprintf (" %u", FetchRemoteULONG (
            Database + ReturnFieldOffset("NTDLL!_RTL_TRACE_DATABASE", FieldName)));
    }
    
    dprintf ("\n");


    if (NoOfTraces < TracesToDisplay) {
        TracesToDisplay = NoOfTraces;
    }

    Trace = (PTRACE) malloc (sizeof(TRACE) * (ULONG)NoOfTraces);

    if (Trace == NULL) {
        dprintf ("Error: cannot allocate trace database debug structure.\n");
        return;
    }

    //
    // Read all the traces from the hash table.
    //

    for (I = 0, TraceIndex = 0; I < NoOfBuckets; I += 1) {

        ULONG64 Current;

        Current = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, Buckets);
        Current += I * PvoidSize;

        Current = FetchRemotePVOID (Current);

        while (Current != 0) {

            if (TraceIndex >= NoOfTraces) {
                dprintf ("Internal error: TraceIndex >= NoOfTraces \n");
                return;
            }

            Trace[TraceIndex].Address = Current;
            Trace[TraceIndex].Count = FETCH_REMOTE_FIELD_PTR (Current, NTDLL!_RTL_TRACE_BLOCK, UserCount);
            Trace[TraceIndex].Size = FETCH_REMOTE_FIELD_PTR (Current, NTDLL!_RTL_TRACE_BLOCK, UserSize);
            TraceIndex += 1;

            Current = FETCH_REMOTE_FIELD_PTR (Current, NTDLL!_RTL_TRACE_BLOCK, Next);
        }
    }

    //
    // Sort the traces just read based on Count field.
    //

    for (I = 0; I < NoOfTraces; I += 1) {

        for (J = I, Min = I; J < NoOfTraces; J += 1) {

            if (SortByCountField) {

                if (Trace[J].Count > Trace[Min].Count) {
                    Min = J;
                }
            }
            else {

                if (Trace[J].Size > Trace[Min].Size) {
                    Min = J;
                }
            }
        }

        if (Min != I) {

            ULONG64 Address;
            ULONG64 Count;
            ULONG64 Size;

            Address = Trace[I].Address;
            Count = Trace[I].Count;
            Size = Trace[I].Size;

            Trace[I].Address = Trace[Min].Address;
            Trace[I].Count = Trace[Min].Count;
            Trace[I].Size = Trace[Min].Size;

            Trace[Min].Address = Address;
            Trace[Min].Count = Count;
            Trace[Min].Size = Size;
        }
    }

#if 0

    for (I = 1; I < NoOfTraces; I += 1) {

        if (Trace[I].Size > Trace[I-1].Size) {
            dprintf (".");
        }
    }

#endif

    dprintf ("\n");

    //
    // Print first N
    //

    for (I = 0; I < TracesToDisplay; I += 1) {
        dprintf ("\n");
        TraceDatabaseBlockDumpXP (Trace[I].Address);

        if (CheckControlC()) {
            dprintf ("Interrupted \n");
            break;
        }
    }

    dprintf ("\n");
    free (Trace);
}


VOID
TraceDatabaseBlockDumpXP (
    ULONG64 Address
    )
{
    ULONG64 TraceAddress;
    ULONG64 ReturnAddress;
    CHAR  SymbolName[ 1024 ];
    ULONG64 Displacement;
    ULONG I;
    ULONG BlockSize;
    ULONG PvoidSize;
     
    if (Address == 0) {
        dprintf ("    No trace\n");
        return;
    }

    PvoidSize = IsPtr64() ? 8 : 4;
    
    BlockSize = FETCH_REMOTE_FIELD_INT(Address, NTDLL!_RTL_TRACE_BLOCK, Size);

    dprintf ("    Trace @ %p: %p bytes, %u blocks (heap @ %p) \n", 
             Address,
             FETCH_REMOTE_FIELD_PTR(Address, NTDLL!_RTL_TRACE_BLOCK, UserSize),
             FETCH_REMOTE_FIELD_PTR(Address, NTDLL!_RTL_TRACE_BLOCK, UserCount),
             FETCH_REMOTE_FIELD_PTR(Address, NTDLL!_RTL_TRACE_BLOCK, UserContext));

    dprintf ("    [%x, %u, %u] \n",
             FETCH_REMOTE_FIELD_INT(Address, NTDLL!_RTL_TRACE_BLOCK, Magic),
             FETCH_REMOTE_FIELD_INT(Address, NTDLL!_RTL_TRACE_BLOCK, Count),
             FETCH_REMOTE_FIELD_INT(Address, NTDLL!_RTL_TRACE_BLOCK, Size));


    for (I = 0; I < BlockSize; I += 1) {

        TraceAddress = FETCH_REMOTE_FIELD_PTR (Address, NTDLL!_RTL_TRACE_BLOCK, Trace);

        ReturnAddress = FetchRemotePVOID (TraceAddress + I * PvoidSize);

        GetSymbol (ReturnAddress, SymbolName, &Displacement);

        dprintf ("    %p %s+0x%p\n", 
                 ReturnAddress, 
                 SymbolName, 
                 Displacement);
    }
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// Fault injection traces
/////////////////////////////////////////////////////////////////////

VOID
FaultInjectionTracesDumpXP (
    PCSTR Args
    )
{
    ULONG64 TracesToDisplay = 0;
    ULONG64 TraceAddress;
    ULONG64 IndexAddress;
    ULONG Index;
    ULONG I;
    const ULONG NO_OF_FAULT_INJECTION_TRACES = 128;
    ULONG PvoidSize;
    ULONG64 TraceBlock;
    ULONG TracesFound = 0;
    BOOLEAN Interrupted = FALSE;
    ULONG64 FlagsAddress;
    ULONG Flags;
     
    if (Args) {
        TracesToDisplay = GetExpression(Args);

        if (TracesToDisplay == 0) {
            TracesToDisplay = 4;
        }
    }

    PvoidSize = IsPtr64() ? 8 : 4;
    
    TraceAddress = (ULONG64) GetExpression ("NTDLL!RtlpDphFaultStacks");
    IndexAddress = (ULONG64) GetExpression ("NTDLL!RtlpDphFaultStacksIndex");
    FlagsAddress = (ULONG64) GetExpression ("NTDLL!RtlpDphGlobalFlags");

    Flags = FetchRemoteULONG (FlagsAddress);

    if (! (Flags & PAGE_HEAP_USE_FAULT_INJECTION)) {

        dprintf ("Fault injection is not enabled for this process. \n");
        dprintf ("Use `pageheap /enable PROGRAM /fault RATE' to enable it. \n");
        return;
    }

    Index = FetchRemoteULONG (IndexAddress);

    for (I = 0; I < NO_OF_FAULT_INJECTION_TRACES; I += 1) {

        Index -= 1;
        Index &= (NO_OF_FAULT_INJECTION_TRACES - 1);
        
        TraceBlock = FetchRemotePVOID (TraceAddress + Index * PvoidSize);

        if (TraceBlock != 0) {
            TracesFound += 1;
            
            dprintf ("\n");
            TraceDatabaseBlockDumpXP (TraceBlock);

            if (TracesFound >= TracesToDisplay) {
                break;
            }
        }
        
        if (CheckControlC()) {
            Interrupted = TRUE;
            dprintf ("Interrupted \n");
            break;
        }
    }

    if (Interrupted == FALSE && TracesFound == 0) {

        dprintf ("No fault injection traces found. \n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\image.cpp ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    peext.c

Abstract:

    This module contains the PE dump extensions

Author:

    Kent Forschmiedt (kentf) 10-May-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <time.h>


// STYP_ flags values for MIPS ROM images

#define STYP_REG      0x00000000
#define STYP_TEXT     0x00000020
#define STYP_INIT     0x80000000
#define STYP_RDATA    0x00000100
#define STYP_DATA     0x00000040
#define STYP_LIT8     0x08000000
#define STYP_LIT4     0x10000000
#define STYP_SDATA    0x00000200
#define STYP_SBSS     0x00000080
#define STYP_BSS      0x00000400
#define STYP_LIB      0x40000000
#define STYP_UCODE    0x00000800
#define S_NRELOC_OVFL 0x20000000

#define IMAGE_SCN_MEM_SYSHEAP       0x00010000  // Obsolete
#define IMAGE_SCN_MEM_PROTECTED     0x00004000  // Obsolete


const static char * const MachineName[] = {
    "Unknown",
    "i386",
    "Alpha AXP",
    "Alpha AXP64",
    "Intel IA64",
    "AMD 64",
};

const static char * const SubsystemName[] = {
    "Unknown",
    "Native",
    "Windows GUI",
    "Windows CUI",
    "Posix CUI",
};

const static char * const DirectoryEntryName[] = {
    "Export",
    "Import",
    "Resource",
    "Exception",
    "Security",
    "Base Relocation",
    "Debug",
    "Description",
    "Special",
    "Thread Storage",
    "Load Configuration",
    "Bound Import",
    "Import Address Table",
    "Reserved",
    "Reserved",
    "Reserved",
    0
};

typedef enum DFT
{
   dftUnknown,
   dftObject,
   dftPE,
   dftROM,
   dftDBG,
   dftPEF,
} DFT;

typedef struct NB10I                   // NB10 debug info
{
    DWORD   nb10;                      // NB10
    DWORD   off;                       // offset, always 0
    DWORD   sig;
    DWORD   age;
} NB10I;

IMAGE_NT_HEADERS ImageNtHeaders;
PIMAGE_FILE_HEADER ImageFileHdr;
PIMAGE_OPTIONAL_HEADER ImageOptionalHdr;
PIMAGE_SECTION_HEADER SectionHdrs;
ULONG64 Base;
ULONG64 ImageNtHeadersAddr, ImageFileHdrAddr, ImageOptionalHdrAddr, SectionHdrsAddr;
DFT dft;
CHAR g_szOptionalHeaderType[MAX_PATH] = {0};

VOID
DumpHeaders (
    VOID
    );

VOID
DumpSections(
    VOID
    );

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG64 FilePointer,
    OUT PULONG64 VirtualAddress
    );

VOID
DumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    );

VOID
ImageExtension(
    IN PSTR lpArgs
    );

PCHAR
GetOptHdrType(
    void
    )
{
    if (!g_szOptionalHeaderType[0])
    {
        strcpy(g_szOptionalHeaderType, "nt!IMAGE_OPTIONAL_HEADER");
    } 
    return g_szOptionalHeaderType;
}

VOID
SetOptHdrType(
    ULONG64 ImageBase,
    ULONG64 ImageFileHeader
    )
{
    CHAR Buffer[MAX_PATH*2] = {0};
    ULONG MachineType;
    BOOL b64bitImage;

    if (GetFieldValue(ImageFileHeader, "IMAGE_FILE_HEADER", "Machine", MachineType))
    {
        // default to default for pointer size
        MachineType = IsPtr64() ? IMAGE_FILE_MACHINE_IA64 : IMAGE_FILE_MACHINE_I386;
    }
    if (MachineType == IMAGE_FILE_MACHINE_IA64 ||
        MachineType == IMAGE_FILE_MACHINE_AMD64 ||
        MachineType == IMAGE_FILE_MACHINE_ALPHA64)
    {
        b64bitImage = TRUE;
    } else
    {
        b64bitImage = FALSE;
    }

    if ((g_ExtSymbols->GetModuleNames(DEBUG_ANY_ID, ImageBase, NULL, 0, NULL,
                                      Buffer, MAX_PATH, NULL, 
                                      NULL, 0, NULL) == S_OK) && 
        IsPtr64())  // Wee need to do this for WOW64 images only
    {
        StringCchCat(Buffer, sizeof(Buffer), "!IMAGE_OPTIONAL_HEADER");
        if (GetTypeSize(Buffer))
        {
            // Module has IMAGE_OPTIONAL_HEADER type
            StringCchCopy(g_szOptionalHeaderType, sizeof(g_szOptionalHeaderType),  Buffer);
            return;
        } else if (b64bitImage)
        {
            // 64 bit images might just have IMAGE_OPTIONAL_HEADER64 defined
            StringCchCat(Buffer, sizeof(Buffer), "64");
            if (GetTypeSize(Buffer))
            {
                // Module has IMAGE_OPTIONAL_HEADER type
                StringCchCopy(g_szOptionalHeaderType, sizeof(g_szOptionalHeaderType),  Buffer);
                return;
            }
        }

    }

    if (b64bitImage)
    {
        StringCchCopy(g_szOptionalHeaderType, sizeof(g_szOptionalHeaderType), "IMAGE_OPTIONAL_HEADER64");
    } else
    {
        StringCchCopy(g_szOptionalHeaderType, sizeof(g_szOptionalHeaderType), "IMAGE_OPTIONAL_HEADER");
    }
}

DECLARE_API( dh )
{
    INIT_API();
    ImageExtension( (PSTR)args );
    EXIT_API();
    return S_OK;

}

VOID
ImageExtension(
    IN PSTR lpArgs
    )
{
    BOOL DoAll;
    BOOL DoSections;
    BOOL DoHeaders;
    CHAR c;
    PCHAR p;
    ULONG64 xBase;

    //
    // Evaluate the argument string to get the address of the
    // image to dump.
    //

    DoAll = TRUE;
    DoHeaders = FALSE;
    DoSections = FALSE;

    xBase = 0;

    while (*lpArgs) {

        while (isspace(*lpArgs)) {
            lpArgs++;
        }

        if (*lpArgs == '/' || *lpArgs == '-') {

            // process switch

            switch (*++lpArgs) {

                case 'a':   // dump everything we can
                case 'A':
                    ++lpArgs;
                    DoAll = TRUE;
                    break;

                default: // invalid switch

                case 'h':   // help
                case 'H':
                case '?':

                    dprintf("Usage: dh [options] address\n");
                    dprintf("\n");
                    dprintf("Dumps headers from an image based at address.\n");
                    dprintf("\n");
                    dprintf("Options:\n");
                    dprintf("\n");
                    dprintf("   -a      Dump everything\n");
                    dprintf("   -f      Dump file headers\n");
                    dprintf("   -s      Dump section headers\n");
                    dprintf("\n");

                    return;

                case 'f':
                case 'F':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoHeaders = TRUE;
                    break;

                case 's':
                case 'S':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoSections = TRUE;
                    break;

            }

        } else if (*lpArgs) {

            if (xBase != 0) {
                dprintf("Invalid extra argument\n");
                return;
            }

            p = lpArgs;
            while (*p && !isspace(*p)) {
                p++;
            }
            c = *p;
            *p = 0;

            xBase = GetExpression(lpArgs);

            *p = c;
            lpArgs=p;

        }

    }

    if ( !xBase ) {
        return;
    }

    DumpImage(xBase, DoAll || DoHeaders, DoAll || DoSections);
}

VOID
DumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    )
{
    IMAGE_DOS_HEADER DosHeader;
    ULONG cb;
    ULONG64 Offset;
    BOOL Ok;
    ULONG OptionalHeaderTypeSize;
    ULONG MachineType;

    Base = xBase;

    Ok = ReadMemory(Base, &DosHeader, sizeof(DosHeader), &cb);

    if (!Ok) {
        dprintf("Can't read file header\n");
        return;
    }

    if (cb != sizeof(DosHeader) || DosHeader.e_magic != IMAGE_DOS_SIGNATURE) {
        dprintf("No file header.\n");
        return;
    }

    Offset = Base + DosHeader.e_lfanew;

    Ok = ReadMemory(Offset, &ImageNtHeaders, sizeof(ImageNtHeaders), &cb);
    ImageNtHeadersAddr = Offset;

    if (!Ok) {
        dprintf("Can't read optional header\n");
        return;
    }

    if (InitTypeRead(ImageNtHeadersAddr, IMAGE_NT_HEADERS)) {
        dprintf("Bad file header.\n");
        return;
    }

    ImageFileHdr = &ImageNtHeaders.FileHeader;
    ImageFileHdrAddr = ReadField(FileHeader);
    ImageOptionalHdr = &ImageNtHeaders.OptionalHeader;
    ImageOptionalHdrAddr = ReadField(OptionalHeader);

    SetOptHdrType(xBase, ImageFileHdrAddr);

    if ((ULONG) ReadField(FileHeader.SizeOfOptionalHeader) == GetTypeSize("IMAGE_ROM_OPTIONAL_HEADER")) {
        dft = dftROM;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_DLL) {
        dft = dftPE;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {
        dft = dftPE;
    } else if (ImageFileHdr->SizeOfOptionalHeader == 0) {
        dft = dftObject;
    } else {
        dft = dftUnknown;
    }

    if (DoHeaders) {
        DumpHeaders();
    }

    OptionalHeaderTypeSize = GetTypeSize(GetOptHdrType());

    if (DoSections) {
        ULONG SectSize, NumSections;
        ULONG OptHdrOffset = 0;

        SectSize = GetTypeSize("IMAGE_SECTION_HEADER");

        // OptionalHeader offset is the same in both 32 and 64 bit binaries, so we not need to
        // set IMAGE_NT_HEADERS type the way we do for IMAGE_OPTIONAL_HEADER
        if (GetFieldOffset("IMAGE_NT_HEADERS", "OptionalHeader", &OptHdrOffset))
        {
            dprintf("Cannot get IMAGE_NT_HEADERS.OptionalHeader type info\n");
            return;
        }

        InitTypeRead(ImageFileHdrAddr, IMAGE_FILE_HEADER);
        SectionHdrs = (PIMAGE_SECTION_HEADER) malloc((NumSections =(ULONG) ReadField(NumberOfSections) )* 
                                                     SectSize);
        __try {

            SectionHdrsAddr = Offset + OptHdrOffset + OptionalHeaderTypeSize;
            Ok = ReadMemory(
                            SectionHdrsAddr,
                            SectionHdrs,
                            (NumSections) * SectSize,
                            &cb);

            if (!Ok) {
                dprintf("Can't read section headers.\n");
            } else {

                if (cb != NumSections * SectSize) {
                    dprintf("\n***\n*** Some section headers may be missing ***\n***\n\n");
                    NumSections = (USHORT)(cb / SectSize);
                }

                DumpSections( );

            }

        }
        __finally {

            if (SectionHdrs) {
                free(SectionHdrs);
                SectionHdrs = 0;
            }

        }

    }

}

VOID
DumpHeaders (
    VOID
    )

/*++

Routine Description:

    Formats the file header and optional header.

Arguments:

    None.

Return Value:

    None

--*/

{
    int i, j;
    const char *time;
    const char *name;
    DWORD dw;
    ULONG Ptr64;
    ULONG SizeOfOptionalHeader, DirOff, DirSize, OptionalHeaderTypeSize=0;
    time_t TimeDateStamp;


    InitTypeRead(ImageFileHdrAddr, IMAGE_FILE_HEADER);
    // Print out file type

    switch (dft) {
        case dftObject :
            dprintf("\nFile Type: COFF OBJECT\n");
            break;

        case dftPE :
            if (ReadField(Characteristics) & IMAGE_FILE_DLL) {
                dprintf("\nFile Type: DLL\n");
            } else {
                dprintf("\nFile Type: EXECUTABLE IMAGE\n");
            }
            break;

        case dftROM :
            dprintf("\nFile Type: ROM IMAGE\n");
            break;

        default :
            dprintf("\nFile Type: UNKNOWN\n");
            break;

    }

    switch (ReadField(Machine)) {
        case IMAGE_FILE_MACHINE_I386     : i = 1; Ptr64 = FALSE; break;
        case IMAGE_FILE_MACHINE_ALPHA    : i = 2; Ptr64 = FALSE; break;
        case IMAGE_FILE_MACHINE_ALPHA64  : i = 3; Ptr64 = TRUE; break;
        case IMAGE_FILE_MACHINE_IA64     : i = 4; Ptr64 = TRUE; break;
        case IMAGE_FILE_MACHINE_AMD64    : i = 5; Ptr64 = TRUE; break;
        default : i = 0;
    }

    dprintf(
           "FILE HEADER VALUES\n"
           "%8hX machine (%s)\n"
           "%8hX number of sections\n"
           "%8lX time date stamp",
           (ULONG) ReadField(Machine),
           MachineName[i],
           (ULONG) ReadField(NumberOfSections),
           TimeDateStamp = (ULONG) ReadField(TimeDateStamp));

    if ((time = ctime((time_t *) &TimeDateStamp)) != NULL) {
        dprintf( " %s", time);
    }
    dprintf("\n");

    dprintf(
           "%8lX file pointer to symbol table\n"
           "%8lX number of symbols\n"
           "%8hX size of optional header\n"
           "%8hX characteristics\n",
           (ULONG) ReadField(PointerToSymbolTable),
           (ULONG) ReadField(NumberOfSymbols),
           SizeOfOptionalHeader = (ULONG) ReadField(SizeOfOptionalHeader),
           (ULONG) ReadField(Characteristics));

    for (dw = (ULONG) ReadField(Characteristics), j = 0; dw; dw >>= 1, j++) {
        if (dw & 1) {
            switch (1 << j) {
                case IMAGE_FILE_RELOCS_STRIPPED     : name = "Relocations stripped"; break;
                case IMAGE_FILE_EXECUTABLE_IMAGE    : name = "Executable"; break;
                case IMAGE_FILE_LINE_NUMS_STRIPPED  : name = "Line numbers stripped"; break;
                case IMAGE_FILE_LOCAL_SYMS_STRIPPED : name = "Symbols stripped"; break;
                case IMAGE_FILE_BYTES_REVERSED_LO   : name = "Bytes reversed"; break;
                case IMAGE_FILE_32BIT_MACHINE       : name = "32 bit word machine"; break;
                case IMAGE_FILE_DEBUG_STRIPPED      : name = "Debug information stripped"; break;
                case IMAGE_FILE_SYSTEM              : name = "System"; break;
                case IMAGE_FILE_DLL                 : name = "DLL"; break;
                case IMAGE_FILE_BYTES_REVERSED_HI   : name = ""; break;
                default : name = "RESERVED - UNKNOWN";
            }

            if (*name) {
                dprintf( "            %s\n", name);
            }
        }
    }

    if (SizeOfOptionalHeader != 0) {
        char szLinkerVersion[30];

        
        OptionalHeaderTypeSize = GetTypeSize(GetOptHdrType());
        GetShortField(ImageOptionalHdrAddr, GetOptHdrType(), 1); // InitTypeRead(ImageOptionalHdrAddr, IMAGE_OPTIONAL_HEADER64);

        sprintf(szLinkerVersion,
                "%u.%02u",
                (ULONG) ReadField(MajorLinkerVersion),
                (ULONG) ReadField(MinorLinkerVersion));

        dprintf(
                "\n"
                "OPTIONAL HEADER VALUES\n"
                "%8hX magic #\n"
                "%8s linker version\n"
                "%8lX size of code\n"
                "%8lX size of initialized data\n"
                "%8lX size of uninitialized data\n"
                "%8P address of entry point\n"
                "%8P base of code\n"
                
                ,
                (ULONG) ReadField(Magic),
                szLinkerVersion,
                (ULONG) ReadField(SizeOfCode),
                (ULONG) ReadField(SizeOfInitializedData),
                (ULONG) ReadField(SizeOfUninitializedData),
                ReadField(AddressOfEntryPoint),
                ReadField(BaseOfCode)
                );
        if (!Ptr64) {
            dprintf("%8P base of data\n",
                    ReadField(BaseOfData));

        }
    }

    if (dft == dftROM) {
        PIMAGE_ROM_OPTIONAL_HEADER romOptionalHdr;

        InitTypeRead(ImageOptionalHdrAddr, IMAGE_ROM_OPTIONAL_HEADER);
//        romOptionalHdr = (PIMAGE_ROM_OPTIONAL_HEADER) &ImageOptionalHdr;
        dprintf(
               "         ----- rom -----\n"
               "%8lX base of bss\n"
               "%8lX gpr mask\n"
               "         cpr mask\n"
               "         %08lX %08lX %08lX %08lX\n"
               "%8hX gp value\n",
               (ULONG) ReadField(BaseOfBss),
               (ULONG) ReadField(GprMask),
               (ULONG) ReadField(CprMask[0]),
               (ULONG) ReadField(CprMask[1]),
               (ULONG) ReadField(CprMask[2]),
               (ULONG) ReadField(CprMask[3]),
               (ULONG) ReadField(GpValue));
    }

    if (SizeOfOptionalHeader == OptionalHeaderTypeSize) {
        char szOSVersion[30];
        char szImageVersion[30];
        char szSubsystemVersion[30];
        
        GetShortField(ImageOptionalHdrAddr, GetOptHdrType(), 1); // InitTypeRead(ImageOptionalHdrAddr, IMAGE_OPTIONAL_HEADER64);
        GetFieldOffset(GetOptHdrType(), "DataDirectory", &DirOff);

        
        switch ((ULONG) ReadField(Subsystem)) {
            case IMAGE_SUBSYSTEM_POSIX_CUI   : i = 4; break;
            case IMAGE_SUBSYSTEM_WINDOWS_CUI : i = 3; break;
            case IMAGE_SUBSYSTEM_WINDOWS_GUI : i = 2; break;
            case IMAGE_SUBSYSTEM_NATIVE      : i = 1; break;
            default : i = 0;
        }

        sprintf(szOSVersion,
                "%hu.%02hu",
                (USHORT) ReadField(MajorOperatingSystemVersion),
                (USHORT) ReadField(MinorOperatingSystemVersion));

        sprintf(szImageVersion,
                "%hu.%02hu",
                (USHORT) ReadField(MajorImageVersion),
                (USHORT) ReadField(MinorImageVersion));

        sprintf(szSubsystemVersion,
                "%hu.%02hu",
                (USHORT) ReadField(MajorSubsystemVersion),
                (USHORT) ReadField(MinorSubsystemVersion));

        dprintf(
                "         ----- new -----\n"
                "%p image base\n"
                "%8lX section alignment\n"
                "%8lX file alignment\n"
                "%8hX subsystem (%s)\n"
                "%8s operating system version\n"
                "%8s image version\n"
                "%8s subsystem version\n",
                ReadField(ImageBase),
                (ULONG) ReadField(SectionAlignment),
                (ULONG) ReadField(FileAlignment),
                (USHORT) ReadField(Subsystem),
                SubsystemName[i],
                szOSVersion,
                szImageVersion,
                szSubsystemVersion);
        dprintf(
                "%8lX size of image\n"
                "%8lX size of headers\n"
                "%8lX checksum\n"
                "%p size of stack reserve\n"
                "%p size of stack commit\n"
                "%p size of heap reserve\n"
                "%p size of heap commit\n",
                (ULONG) ReadField(SizeOfImage),
                (ULONG) ReadField(SizeOfHeaders),
                (ULONG) ReadField(CheckSum),
                ReadField(SizeOfStackReserve),
                ReadField(SizeOfStackCommit),
                ReadField(SizeOfHeapReserve),
                ReadField(SizeOfHeapCommit));

        dprintf("%p Opt Hdr\n", ImageOptionalHdrAddr);
        DirSize = GetTypeSize("IMAGE_DATA_DIRECTORY");
        
        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++) {
            if (!DirectoryEntryName[i]) {
                break;
            }

            InitTypeRead(ImageOptionalHdrAddr + DirOff + i*DirSize, IMAGE_DATA_DIRECTORY);
            dprintf( "%8P [%8lX] address [size] of %s Directory\n",
                    ReadField(VirtualAddress),
                    (ULONG) ReadField(Size),
                    DirectoryEntryName[i]
                   );
        }

        dprintf( "\n" );
    }

}


VOID
DumpSectionHeader (
    IN DWORD i,
    IN ULONG64 Sh
    )
{
    const char *name;
    char *szUnDName;
    DWORD li, lj;
    WORD memFlags;
    CHAR Name[40];

    InitTypeRead(Sh, IMAGE_SECTION_HEADER);
    GetFieldValue(Sh, "IMAGE_SECTION_HEADER", "Name", Name);

    dprintf("\nSECTION HEADER #%hX\n%8.8s name", i, Name);

#if 0
    if (Sh->Name[0] == '/') {
        name = SzObjSectionName((char *) Sh->Name, (char *) DumpStringTable);

        dprintf(" (%s)", name);
    }
#endif
    dprintf( "\n");

    dprintf( "%8P %s\n"
             "%8lX virtual address\n"
             "%8lX size of raw data\n"
             "%8lX file pointer to raw data\n"
             "%8lX file pointer to relocation table\n",
           ReadField(Misc.PhysicalAddress),
           (dft == dftObject) ? "physical address" : "virtual size",
           (ULONG) ReadField(VirtualAddress),
           (ULONG) ReadField(SizeOfRawData),
           (ULONG) ReadField(PointerToRawData),
           (ULONG) ReadField(PointerToRelocations));

    dprintf( "%8lX file pointer to line numbers\n"
                        "%8hX number of relocations\n"
                        "%8hX number of line numbers\n"
                        "%8lX flags\n",
           (ULONG) ReadField(PointerToLinenumbers),
           (ULONG) ReadField(NumberOfRelocations),
           (ULONG) ReadField(NumberOfLinenumbers),
           (ULONG) ReadField(Characteristics));

    memFlags = 0;

    li = (ULONG) ReadField(Characteristics);

    if (dft == dftROM) {
       for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case STYP_REG   : name = "Regular"; break;
                    case STYP_TEXT  : name = "Text"; memFlags = 1; break;
                    case STYP_INIT  : name = "Init Code"; memFlags = 1; break;
                    case STYP_RDATA : name = "Data"; memFlags = 2; break;
                    case STYP_DATA  : name = "Data"; memFlags = 6; break;
                    case STYP_LIT8  : name = "Literal 8"; break;
                    case STYP_LIT4  : name = "Literal 4"; break;
                    case STYP_SDATA : name = "GP Init Data"; memFlags = 6; break;
                    case STYP_SBSS  : name = "GP Uninit Data"; memFlags = 6; break;
                    case STYP_BSS   : name = "Uninit Data"; memFlags = 6; break;
                    case STYP_LIB   : name = "Library"; break;
                    case STYP_UCODE : name = "UCode"; break;
                    case S_NRELOC_OVFL : name = "Non-Relocatable overlay"; memFlags = 1; break;
                    default : name = "RESERVED - UNKNOWN";
                }

                dprintf( "         %s\n", name);
            }
        }
    } else {
        // Clear the padding bits

        li &= ~0x00700000;

        for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case IMAGE_SCN_TYPE_NO_PAD  : name = "No Pad"; break;

                    case IMAGE_SCN_CNT_CODE     : name = "Code"; break;
                    case IMAGE_SCN_CNT_INITIALIZED_DATA : name = "Initialized Data"; break;
                    case IMAGE_SCN_CNT_UNINITIALIZED_DATA : name = "Uninitialized Data"; break;

                    case IMAGE_SCN_LNK_OTHER    : name = "Other"; break;
                    case IMAGE_SCN_LNK_INFO     : name = "Info"; break;
                    case IMAGE_SCN_LNK_REMOVE   : name = "Remove"; break;
                    case IMAGE_SCN_LNK_COMDAT   : name = "Communal"; break;

                    case IMAGE_SCN_MEM_DISCARDABLE: name = "Discardable"; break;
                    case IMAGE_SCN_MEM_NOT_CACHED: name = "Not Cached"; break;
                    case IMAGE_SCN_MEM_NOT_PAGED: name = "Not Paged"; break;
                    case IMAGE_SCN_MEM_SHARED   : name = "Shared"; break;
                    case IMAGE_SCN_MEM_EXECUTE  : name = ""; memFlags |= 1; break;
                    case IMAGE_SCN_MEM_READ     : name = ""; memFlags |= 2; break;
                    case IMAGE_SCN_MEM_WRITE    : name = ""; memFlags |= 4; break;

                    case IMAGE_SCN_MEM_FARDATA  : name = "Far Data"; break;
                    case IMAGE_SCN_MEM_SYSHEAP  : name = "Sys Heap"; break;
                    case IMAGE_SCN_MEM_PURGEABLE: name = "Purgeable or 16-Bit"; break;
                    case IMAGE_SCN_MEM_LOCKED   : name = "Locked"; break;
                    case IMAGE_SCN_MEM_PRELOAD  : name = "Preload"; break;
                    case IMAGE_SCN_MEM_PROTECTED: name = "Protected"; break;

                    default : name = "RESERVED - UNKNOWN";
                }

                if (*name) {
                    dprintf( "         %s\n", name);
                }
            }
        }

        // print alignment

        switch ((ULONG) ReadField(Characteristics) & 0x00700000) {
            default:                      name = "(no align specified)"; break;
            case IMAGE_SCN_ALIGN_1BYTES:  name = "1 byte align";  break;
            case IMAGE_SCN_ALIGN_2BYTES:  name = "2 byte align";  break;
            case IMAGE_SCN_ALIGN_4BYTES:  name = "4 byte align";  break;
            case IMAGE_SCN_ALIGN_8BYTES:  name = "8 byte align";  break;
            case IMAGE_SCN_ALIGN_16BYTES: name = "16 byte align"; break;
            case IMAGE_SCN_ALIGN_32BYTES: name = "32 byte align"; break;
            case IMAGE_SCN_ALIGN_64BYTES: name = "64 byte align"; break;
        }

        dprintf( "         %s\n", name);
    }

    if (memFlags) {
        switch(memFlags) {
            case 1 : name = "Execute Only"; break;
            case 2 : name = "Read Only"; break;
            case 3 : name = "Execute Read"; break;
            case 4 : name = "Write Only"; break;
            case 5 : name = "Execute Write"; break;
            case 6 : name = "Read Write"; break;
            case 7 : name = "Execute Read Write"; break;
            default : name = "Unknown Memory Flags"; break;
        }
        dprintf( "         %s\n", name);
    }
}

VOID
DumpDebugDirectory (
    IN ULONG64 DebugDir
    )
{
    BOOL Ok;
    DWORD cb;
    NB10I nb10i;
    PIMAGE_DEBUG_MISC miscData;
    PIMAGE_DEBUG_MISC miscDataCur;
    ULONG64 VirtualAddress;
    DWORD len;

    InitTypeRead(DebugDir, IMAGE_DEBUG_DIRECTORY );
    switch ((ULONG) ReadField(Type)){
        case IMAGE_DEBUG_TYPE_COFF:
            dprintf( "\tcoff   ");
            break;
        case IMAGE_DEBUG_TYPE_CODEVIEW:
            dprintf( "\tcv     ");
            break;
        case IMAGE_DEBUG_TYPE_FPO:
            dprintf( "\tfpo    ");
            break;
        case IMAGE_DEBUG_TYPE_MISC:
            dprintf( "\tmisc   ");
            break;
        case IMAGE_DEBUG_TYPE_FIXUP:
            dprintf( "\tfixup  ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
            dprintf( "\t-> src ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
            dprintf( "\tsrc -> ");
            break;
        case IMAGE_DEBUG_TYPE_EXCEPTION:
            dprintf( "\tpdata  ");
            break;
        default:
            dprintf( "\t(%6lu)", (ULONG) ReadField(Type));
            break;
    }
    dprintf( "%8x    %8x %8x",
                (ULONG) ReadField(SizeOfData),
                (ULONG) ReadField(AddressOfRawData),
                (ULONG) ReadField(PointerToRawData));

    if ((ULONG) ReadField(PointerToRawData) &&
        (ULONG) ReadField(Type) == IMAGE_DEBUG_TYPE_MISC)
    {

        if (!TranslateFilePointerToVirtualAddress(ReadField(PointerToRawData), &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = (ULONG) ReadField(SizeOfData);
            miscData = (PIMAGE_DEBUG_MISC) malloc(len);
            if (miscData) {
                Ok = ReadMemory(Base + VirtualAddress, miscData, len, &cb);

                if (!Ok || cb != len) {
                    dprintf("Can't read debug data\n");
                } else {

                    miscDataCur = miscData;
                    do {
                        if (miscDataCur->DataType == IMAGE_DEBUG_MISC_EXENAME) {
                            if (ImageOptionalHdr->MajorLinkerVersion == 2 &&
                                ImageOptionalHdr->MinorLinkerVersion < 37) {
                                dprintf( "\tImage Name: %s", miscDataCur->Reserved);
                            } else {
                                dprintf( "\tImage Name: %s", miscDataCur->Data);
                            }
                            break;
                        }
                        len -= miscDataCur->Length;
                        miscDataCur = (PIMAGE_DEBUG_MISC) ((PCHAR) miscDataCur + miscData->Length);
                    } while (len > 0);

                }

                free(miscData);
            } else {
                dprintf("Cannot allocate memory for reading debug data\n");
            }
        }
    }

    if ((ULONG) ReadField(PointerToRawData) &&
        (ULONG) ReadField(Type) == IMAGE_DEBUG_TYPE_CODEVIEW)
    {
        if (!TranslateFilePointerToVirtualAddress((ULONG) ReadField(PointerToRawData), &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = (ULONG) ReadField(SizeOfData);

            Ok = ReadMemory(Base + VirtualAddress, &nb10i, sizeof(nb10i), &cb);

            if (!Ok || cb != sizeof(nb10i)) {
                dprintf("Can't read debug data\n");
            } else {
                dprintf( "\tFormat: %4.4s", &nb10i.nb10);

                if (nb10i.nb10 == '01BN') {
                    CHAR PdbName[MAX_PATH];
                    
                    if ((len - sizeof(nb10i) > MAX_PATH))
                        len = MAX_PATH;

                    Ok = ReadMemory(Base + VirtualAddress + sizeof(nb10i), PdbName, len-sizeof(nb10i), &cb);
                    if (!Ok || cb != len-sizeof(nb10i)) {
                        strcpy(PdbName, "<pdb name unavailable>");
                    }
                    dprintf( ", %x, %x, %s", nb10i.sig, nb10i.age, PdbName);
                }
            }
        }

    }

    dprintf( "\n");
}



VOID
DumpDebugDirectories (
    ULONG64 sh
    )

/*++

Routine Description:

    Print out the contents of all debug directories

Arguments:

    sh - Section header for section that contains debug dirs

Return Value:

    None.

--*/
{
    int                numDebugDirs;
    IMAGE_DEBUG_DIRECTORY      debugDir;
    ULONG64            DebugDirAddr;
    ULONG64            pc;
    ULONG64 VA;
    DWORD              cb, Sz, DebugDirSize;
    BOOL               Ok;

    Sz = GetTypeSize("IMAGE_DATA_DIRECTORY");
    DebugDirSize = GetTypeSize("IMAGE_DEBUG_DIRECTORY");
    if (dft == dftROM) {

        GetFieldValue(sh, "IMAGE_SECTION_HEADER", "VirtualAddress", VA);
        DebugDirAddr = Base + VA;
        pc = DebugDirAddr;
        if (InitTypeRead(pc, IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir @%p\n", pc);
            return;
        }

        numDebugDirs = 0;
        while (ReadField(Type) != 0) {
            numDebugDirs++;
            pc += DebugDirSize;
            if (InitTypeRead(pc, IMAGE_DEBUG_DIRECTORY)) {
                break;
            }
        }
    } else {
        ULONG Off, DirSize;

        GetFieldOffset(GetOptHdrType(), "DataDirectory", &Off);

        GetFieldValue(ImageOptionalHdrAddr + Off + Sz*IMAGE_DIRECTORY_ENTRY_DEBUG, 
                      "IMAGE_DATA_DIRECTORY", "VirtualAddress", VA);
        GetFieldValue(ImageOptionalHdrAddr + Off + Sz*IMAGE_DIRECTORY_ENTRY_DEBUG, 
                      "IMAGE_DATA_DIRECTORY", "Size", DirSize);
        
        DebugDirAddr = Base + VA; // ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
        numDebugDirs = DirSize / DebugDirSize; 
//        dprintf(" DD @%p, DD addr %p\n", ImageOptionalHdrAddr + Off + Sz*IMAGE_DIRECTORY_ENTRY_DEBUG,
  //              DebugDirAddr);
        // ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
    }

    dprintf("\n\nDebug Directories(%d)\n",numDebugDirs);
    dprintf("\tType       Size     Address  Pointer\n\n");
    pc = DebugDirAddr;
    while (numDebugDirs) {
        if (InitTypeRead(pc, IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir @%p\n", pc);
            break;
        }
        DumpDebugDirectory(pc);
        pc += Sz;
        numDebugDirs--;
    }
}



VOID
DumpSections(
    VOID
    )
{
    ULONG64 sh;
    const char *p;
    DWORD64 li;
    DWORD cb;
    BOOL Ok;
    ULONG i, j;
    CHAR szName[IMAGE_SIZEOF_SHORT_NAME + 1];
    ULONG NumberOfSections, SectSize, Characteristics;


    GetFieldValue(ImageFileHdrAddr, "IMAGE_FILE_HEADER", "NumberOfSections", NumberOfSections);
    GetFieldValue(ImageFileHdrAddr, "IMAGE_FILE_HEADER", "Characteristics", Characteristics);
    SectSize = GetTypeSize("IMAGE_SECTION_HEADER");

    for (i = 1; i <= NumberOfSections; i++) {

        sh = SectionHdrsAddr + (i-1)*SectSize;

        //szName = SzObjSectionName((char *) sh.Name, (char *) DumpStringTable);
        GetFieldValue(sh, "IMAGE_SECTION_HEADER", "Name", szName);
        // strncpy(szName, (char *) sh.Name, IMAGE_SIZEOF_SHORT_NAME);
        szName[IMAGE_SIZEOF_SHORT_NAME] = 0;

        DumpSectionHeader(i, sh);

        if (dft == dftROM) {

            if (!(Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {

                // If we're looking at the .rdata section and the symbols
                // aren't stripped, the debug directory must be here.

                if (!strcmp(szName, ".rdata")) {

                    DumpDebugDirectories(sh);

                    //DumpDebugData(&sh);
                }
            }

        } else if (dft == dftPE) {
            CHAR tmp[40];
            ULONG64 VA;

            sprintf(tmp, "DataDirectory[%d].VirtualAddress", IMAGE_DIRECTORY_ENTRY_DEBUG);
            GetFieldValue(ImageOptionalHdrAddr, GetOptHdrType(), tmp, li);
//            dprintf("Opt Hdr %p, %s = %p", ImageOptionalHdrAddr, tmp, li);

            if (li != 0) {
                InitTypeRead(sh, IMAGE_SECTION_HEADER);
                VA = ReadField(VirtualAddress);
                if (li >= VA && li < (VA + ReadField(SizeOfRawData))) {
                    DumpDebugDirectories(sh);

                    //DumpDebugData(&sh);
                }
            }


#if 0
            if (Switch.Dump.PData) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpFunctionTable(pimage, rgsym, (char *) DumpStringTable, &sh);
                }
            }

            if (Switch.Dump.Imports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpImports(&sh);
                }
            }

            if (Switch.Dump.Exports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    // UNDONE: Is this check really necessary?

                    if (ImageFileHdr->Machine != IMAGE_FILE_MACHINE_MPPC_601) {
                        DumpExports(&sh);
                    }
                }
            }

#endif

        }

    }
}

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG64 FilePointer,
    OUT PULONG64 VirtualAddress
    )
{
    ULONG i;
    ULONG64 sh;
    ULONG NumberOfSections, SectSize, Characteristics;


    GetFieldValue(ImageFileHdrAddr, "IMAGE_FILE_HEADER", "NumberOfSections", NumberOfSections);
    GetFieldValue(ImageFileHdrAddr, "IMAGE_FILE_HEADER", "Characteristics", Characteristics);
    SectSize = GetTypeSize("IMAGE_SECTION_HEADER");


    for (i = 1; i <= NumberOfSections; i++) {
        sh = SectionHdrsAddr + (i-1)*SectSize;

        InitTypeRead(sh, IMAGE_SECTION_HEADER);
        if (ReadField(PointerToRawData) <= FilePointer &&
            FilePointer < ReadField(PointerToRawData) + ReadField(SizeOfRawData)) {

            *VirtualAddress = FilePointer - ReadField(PointerToRawData) + ReadField(VirtualAddress);
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbgeng.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS2       g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS3 g_ExtSystem;



HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);


#define PAGE_ALIGN64(Va) ((ULONG64)((Va) & ~((ULONG64) ((LONG64) (LONG) PageSize - 1))))

extern ULONG PageSize;

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;
extern ULONG g_TargetBuild;
extern ULONG g_Qualifier;
extern ULONG64 g_SharedUserData;

//-----------------------------------------------------------------------------------------
//
//  prototypes for internal non-exported support functions
//
//-----------------------------------------------------------------------------------------

HRESULT
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    );

HRESULT 
GetCurrentProcessName( 
    PSTR ProcessBuffer, 
    ULONG BufferSIze
    );



/////////////////////////////////////////////
//
//  sddump.c
//
/////////////////////////////////////////////

ULONG64
GetSidAddr(ULONG64 BaseAddress);

ULONG 
GetSidAttributes(ULONG64 BaseAddress);

PCSTR ConvertSidToFriendlyName(IN SID* pSid, IN PCSTR pszFmt);

void ShowSid(IN PCSTR pszPad, IN ULONG64 addrSid, IN ULONG fOptions);

/////////////////////////////////////////////
//
//  Util.c
//
/////////////////////////////////////////////

typedef VOID
(*PDUMP_SPLAY_NODE_FN)(
    ULONG64 RemoteAddress,
    ULONG   Level
    );

ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    );

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

ULONG
GetBitFieldOffset (
   IN LPSTR     Type, 
   IN LPSTR     Field, 
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   );

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    );

VOID
DumpUnicode(
    UNICODE_STRING u
    );

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    );


ULONG64
GetPointerValue (
    PCHAR String
    );

BOOLEAN
IsHexNumber(
   const char *szExpression
   );

BOOLEAN
IsDecNumber(
   const char *szExpression
   );

VOID DumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\peb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    peb.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <time.h>

BOOL
GetTeb32FromWowTeb(ULONG64 Teb, PULONG64 pTeb32)
{
    if (pTeb32) {
        return ReadPointer(Teb, pTeb32);
    }
    return FALSE;
}

BOOL
GetPeb32FromWowTeb(ULONG64 Teb, PULONG64 pPeb32)
{
    ULONG Peb32;
    ULONG64 Teb32=0;
    ULONG err;

    if (GetTeb32FromWowTeb(Teb, &Teb32) && Teb32) {
        if (!(err =GetFieldValue(Teb32, "nt!TEB32", "ProcessEnvironmentBlock", Peb32))) {
            *pPeb32 = Peb32;
            return TRUE;
        } else if (err == SYMBOL_TYPE_INFO_NOT_FOUND) {
            if (!(err =GetFieldValue(Teb32, "wow64!TEB32", "ProcessEnvironmentBlock", Peb32))) {
                *pPeb32 = Peb32;
                return TRUE;
            }
        }
    }
    return FALSE;
}

HRESULT
DumpPeb(ULONG64 peb, BOOL IsWow64Peb)
{
    ULONG64 ldr;
    ULONG64 err;
    ULONG64 ldr_Initialized;
    ULONG64 ldr_InInitializationOrderModuleList_Flink;
    ULONG64 ldr_InInitializationOrderModuleList_Blink;
    ULONG64 ldr_InLoadOrderModuleList_Flink;
    ULONG64 ldr_InLoadOrderModuleList_Blink;
    ULONG   ldr_InMemoryOrderModuleList_Offset;
    ULONG64 ldr_InMemoryOrderModuleList_Flink;
    ULONG64 ldr_InMemoryOrderModuleList_Blink;
    ULONG   ldr_DataTableEntry_InMemoryOrderLinks_Offset;
    ULONG64 peb_SubSystemData;
    ULONG64 peb_ProcessHeap;
    ULONG64 peb_ProcessParameters;
    PCHAR   ldrdata = "nt!_PEB_LDR_DATA";
    PCHAR   ldrEntry = "nt!_LDR_DATA_TABLE_ENTRY";
    PCHAR   processparam = "nt!_RTL_USER_PROCESS_PARAMETERS";
    HRESULT hr = S_OK;

    if (IsWow64Peb) {
        // try and load types from nt
        if ( err = InitTypeRead( peb, nt!PEB32 ) )   {
            if (err == SYMBOL_TYPE_INFO_NOT_FOUND) {
                // try load types from wow64
                if ( !( err = InitTypeRead( peb, wow64!PEB32 )) )   {
                    ldrdata = "wow64!_PEB_LDR_DATA32";
                    ldrEntry = "wow64!_LDR_DATA_TABLE_ENTRY32";
                    processparam = "wow64!_RTL_USER_PROCESS_PARAMETERS32";
                } else {
                    dprintf( "error %d InitTypeRead( wow64!PEB32 at %p)...\n", (ULONG) err, peb);
                    return E_INVALIDARG;
                }
            } else {
                dprintf( "error %d InitTypeRead( nt!PEB32 at %p)...\n", (ULONG) err, peb);
                return E_INVALIDARG;
            }
        } else {
            ldrdata = "nt!_PEB_LDR_DATA32";
            ldrEntry = "nt!_LDR_DATA_TABLE_ENTRY32";
            processparam = "nt!_RTL_USER_PROCESS_PARAMETERS32";
        }
    } else {
        if ( err = InitTypeRead( peb, nt!_PEB ) )   {
           dprintf( "error %d InitTypeRead( nt!_PEB at %p)...\n", (ULONG) err, peb);
           return E_INVALIDARG;
        }
    }

    dprintf(
        "    InheritedAddressSpace:    %s\n"
        "    ReadImageFileExecOptions: %s\n"
        "    BeingDebugged:            %s\n"
        "    ImageBaseAddress:         %p\n"
        "    Ldr                       %p\n",
        ReadField( InheritedAddressSpace )    ? "Yes" : "No",
        ReadField( ReadImageFileExecOptions ) ? "Yes" : "No",
        ReadField( BeingDebugged )            ? "Yes" : "No",
        ReadField( ImageBaseAddress ),
        (ldr = ReadField( Ldr ))
        );

    peb_SubSystemData     = ReadField( SubSystemData );
    peb_ProcessHeap       = ReadField( ProcessHeap );
    peb_ProcessParameters = ReadField( ProcessParameters );

    err = GetFieldOffset( ldrdata,
                          "InMemoryOrderModuleList",
                          &ldr_InMemoryOrderModuleList_Offset
                        );
    if ( err )   {
        dprintf( "    ***  _PEB_LDR_DATA%s was not found...\n",
                 ( err == FIELDS_DID_NOT_MATCH ) ? ".InMemoryModuleList field" :
                 " type"
               );
    }
    else   {
       err = GetFieldOffset( ldrEntry,
                             "InMemoryOrderLinks",
                             &ldr_DataTableEntry_InMemoryOrderLinks_Offset
                           );
       if (err )  {
           dprintf( "    ***  _LDR_DATA_TABLE_ENTRY%s was not found...\n",
                    ( err == FIELDS_DID_NOT_MATCH ) ? ".InMemoryOrderLinks field" :
                   " type"
                  );
       }
    }

    if ( err || GetFieldValue( ldr, ldrdata, "Initialized", ldr_Initialized ) )   {
        dprintf( "    *** unable to read Ldr table at %p\n", ldr );
    }
    else  {
        ULONG64 next, head;
        BOOL First = TRUE;

        GetFieldValue( ldr, ldrdata, "InInitializationOrderModuleList.Flink", ldr_InInitializationOrderModuleList_Flink );
        GetFieldValue( ldr, ldrdata, "InInitializationOrderModuleList.Blink", ldr_InInitializationOrderModuleList_Blink );
        GetFieldValue( ldr, ldrdata, "InLoadOrderModuleList.Flink", ldr_InLoadOrderModuleList_Flink );
        GetFieldValue( ldr, ldrdata, "InLoadOrderModuleList.Blink", ldr_InLoadOrderModuleList_Blink );
        GetFieldValue( ldr, ldrdata, "InMemoryOrderModuleList.Flink", ldr_InMemoryOrderModuleList_Flink );
        GetFieldValue( ldr, ldrdata, "InMemoryOrderModuleList.Blink", ldr_InMemoryOrderModuleList_Blink );

        dprintf(
            "    Ldr.Initialized:          %s\n"
            "    Ldr.InInitializationOrderModuleList: %p . %p\n"
            "    Ldr.InLoadOrderModuleList:           %p . %p\n"
            "    Ldr.InMemoryOrderModuleList:         %p . %p\n",
                  ldr_Initialized ? "Yes" : "No",
                  ldr_InInitializationOrderModuleList_Flink,
                  ldr_InInitializationOrderModuleList_Blink,
                  ldr_InLoadOrderModuleList_Flink,
                  ldr_InLoadOrderModuleList_Blink,
                  ldr_InMemoryOrderModuleList_Flink,
                  ldr_InMemoryOrderModuleList_Blink
               );
        head = ldr + (ULONG64)ldr_InMemoryOrderModuleList_Offset;
        next = ldr_InMemoryOrderModuleList_Flink;
        while( next != head )    {
            ULONG64 entry, dllBase;
            UNICODE_STRING64 u;
            time_t Timestamp=0;
            const char *time;

            entry = next - ldr_DataTableEntry_InMemoryOrderLinks_Offset;
            if (GetFieldValue( entry, ldrEntry, "DllBase", dllBase )) {
                dprintf("Cannot read %s at %p\n",ldrEntry, entry);
                break;
            }
            GetFieldValue( entry, ldrEntry, "TimeDateStamp", Timestamp );
            GetFieldValue( entry, ldrEntry, "FullDllName.Buffer", u.Buffer );
            GetFieldValue( entry, ldrEntry, "FullDllName.Length", u.Length );
            GetFieldValue( entry, ldrEntry, "FullDllName.MaximumLength", u.MaximumLength );
            if (First) {
                if (IsPtr64()) {
                    dprintf("                    Base TimeStamp / Module\n");
                } else {
                    dprintf("            Base TimeStamp                     Module\n");
                }
                First = FALSE;
            }
            if (IsPtr64()) {
                dprintf("        ");
            }
            dprintf( "%16p ", dllBase );
            if ((time = ctime((time_t *) &Timestamp)) != NULL) {
                dprintf( "%08x %-20.20s ", Timestamp, time+4);
            }
            if ( u.Buffer )  {
                if (IsPtr64()) {
                    dprintf("\n                         ");
                }
                DumpUnicode64( u );
            }
            dprintf( "\n");
            GetFieldValue( entry, ldrEntry, "InMemoryOrderLinks.Flink", next );

            if (CheckControlC()) {
                break;
            }
        }
    }

    dprintf(
        "    SubSystemData:     %p\n"
        "    ProcessHeap:       %p\n"
        "    ProcessParameters: %p\n",
                  peb_SubSystemData,
                  peb_ProcessHeap,
                  peb_ProcessParameters
            );
    if ( peb_ProcessParameters )   {
        ULONG64 peb_ProcessParameters_Environment;
        ULONG64 peb_ProcessParameters_Flags;
        UNICODE_STRING64 windowTitle;
        UNICODE_STRING64 imagePathName;
        UNICODE_STRING64 commandLine;
        UNICODE_STRING64 dllPath;

        GetFieldValue( peb_ProcessParameters, processparam, "Environment", peb_ProcessParameters_Environment );
        GetFieldValue( peb_ProcessParameters, processparam, "Flags", peb_ProcessParameters_Flags );
        GetFieldValue( peb_ProcessParameters, processparam, "WindowTitle.Buffer", windowTitle.Buffer );
        GetFieldValue( peb_ProcessParameters, processparam, "WindowTitle.Length", windowTitle.Length );
        GetFieldValue( peb_ProcessParameters, processparam, "WindowTitle.MaximumLength", windowTitle.MaximumLength );
        GetFieldValue( peb_ProcessParameters, processparam, "ImagePathName.Buffer", imagePathName.Buffer );
        GetFieldValue( peb_ProcessParameters, processparam, "ImagePathName.Length", imagePathName.Length );
        GetFieldValue( peb_ProcessParameters, processparam, "ImagePathName.MaximumLength", imagePathName.MaximumLength );
        GetFieldValue( peb_ProcessParameters, processparam, "CommandLine.Buffer", commandLine.Buffer );
        GetFieldValue( peb_ProcessParameters, processparam, "CommandLine.Length", commandLine.Length );
        GetFieldValue( peb_ProcessParameters, processparam, "CommandLine.MaximumLength", commandLine.MaximumLength );
        GetFieldValue( peb_ProcessParameters, processparam, "DllPath.Buffer", dllPath.Buffer );
        GetFieldValue( peb_ProcessParameters, processparam, "DllPath.Length", dllPath.Length );
        GetFieldValue( peb_ProcessParameters, processparam, "DllPath.MaximumLength", dllPath.MaximumLength );
        if ( !(peb_ProcessParameters_Flags & RTL_USER_PROC_PARAMS_NORMALIZED) )   {
             windowTitle.Buffer   += peb_ProcessParameters;
             imagePathName.Buffer += peb_ProcessParameters;
             commandLine.Buffer   += peb_ProcessParameters;
             dllPath.Buffer       += peb_ProcessParameters;
        }
        dprintf(
            "    WindowTitle:  '" );
        DumpUnicode64( windowTitle );
        dprintf("'\n");
        dprintf(
            "    ImageFile:    '" );
        DumpUnicode64( imagePathName );
        dprintf("'\n");
        dprintf(
            "    CommandLine:  '" );
        DumpUnicode64( commandLine );
        dprintf("'\n");
        dprintf(
            "    DllPath:      '" );
        DumpUnicode64( dllPath );
        dprintf("'\n"
                "    Environment:  %p\n", peb_ProcessParameters_Environment );

        {
            WCHAR EnvBuf[0x4000];
            WCHAR *Env = EnvBuf;
            ULONG cb;

            if (ReadMemory(peb_ProcessParameters_Environment, Env,
                           sizeof(EnvBuf)-4, &cb))
            {
                EnvBuf[cb /2] = 0;
                EnvBuf[(cb /2)+ 1] = 0;

                //
                // Go until we reach a double NULL unicode
                //

                while(*(Env+1) != 0)
                {
                    dprintf("        %ws\n", Env);
                    while(*Env++ != 0);
                }

                if ((PUCHAR) Env >= (PUCHAR)EnvBuf + (sizeof(EnvBuf)-4))
                {
                    dprintf("\n        use 'db %p' to see remaining "
                            "environment variables\n",
                            peb_ProcessParameters_Environment + sizeof(EnvBuf));
                }
            }
        }
    }
    else   {
        dprintf( "    *** unable to read process parameters\n" );

    }
    return S_OK;
}

DECLARE_API( peb )

/*++

Routine Description:

    This function is called to dump the PEB

    Called as:

        !peb

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG64 pebAddress;
    ULONG64 peb;
    HRESULT hr = S_OK;

    INIT_API();
    if ( *args ) {
       pebAddress = GetExpression( args );
    } else {
        ULONG64 tebAddress;
        tebAddress = GetExpression("@$teb");
        if (TargetMachine == IMAGE_FILE_MACHINE_IA64 && tebAddress) {
            ULONG64 Peb32=0;
            if (GetPeb32FromWowTeb(tebAddress, &Peb32) && Peb32) {
                dprintf("Wow64 PEB32 at %lx\n", Peb32);
                DumpPeb(Peb32, TRUE);
                dprintf("\n\nWow64 ");
            }
        }

        pebAddress = GetExpression("@$peb");
        //GetPebAddress( 0, &pebAddress );
    }

    if ( pebAddress ) {
       dprintf( "PEB at %p\n", pebAddress );
    }
    else  {
       dprintf( "PEB NULL...\n" );
       return E_INVALIDARG;
    }

    peb = IsPtr64() ? pebAddress : (ULONG64)(LONG64)(LONG)pebAddress;

    hr = DumpPeb(peb, FALSE);
    EXIT_API();
    return hr;


} // PebExtension()


HRESULT
DumpTeb(ULONG64 tebAddress, BOOL IsWow64Teb)
{

    ULONG64 teb;
    ULONG64 tib_ExceptionList;
    ULONG64 tib_StackBase;
    ULONG64 tib_StackLimit;
    ULONG64 tib_StackSusSystemTib;
    ULONG64 tib_FiberData;
    ULONG64 tib_ArbitraryUserPointer;
    ULONG64 tib_Self;
    ULONG64 tib_EnvironmentPointer;
    ULONG64 teb_ClientId_UniqueProcess;
    ULONG64 teb_ClientId_UniqueThread;
    ULONG64 teb_RealClientId_UniqueProcess;
    ULONG64 teb_RealClientId_UniqueThread;
    ULONG64 DeallocationBStore;
    HRESULT hr = S_OK;
    ULONG64 err;
    ULONG64 UseHardErrorsAreDisabled;
    ULONG   HardErrorModeOffset;
    PCHAR   TebType;

    teb = tebAddress;
    if (!IsWow64Teb) {
        TebType = "nt!_TEB";
        if ( InitTypeRead( teb, nt!_TEB ) )   {
           dprintf( "error InitTypeRead( TEB )...\n");
           return E_INVALIDARG;
        }
    } else {
        TebType = "nt!TEB32";
        if ( err = InitTypeRead( teb, nt!TEB32 ) )   {
            if (err == SYMBOL_TYPE_INFO_NOT_FOUND) {
                TebType = "wow64!TEB32";
                if ( InitTypeRead( teb, wow64!TEB32 ) )   {
                    dprintf( "error InitTypeRead( wow64!TEB32 )...\n");
                    return E_INVALIDARG;
                }
            } else {
                dprintf( "error InitTypeRead( TEB32 )...\n");
                return E_INVALIDARG;
            }
        }
    }

    dprintf(
        "    ExceptionList:        %p\n"
        "    StackBase:            %p\n"
        "    StackLimit:           %p\n"
        "    SubSystemTib:         %p\n"
        "    FiberData:            %p\n"
        "    ArbitraryUserPointer: %p\n"
        "    Self:                 %p\n"
        "    EnvironmentPointer:   %p\n",
                    GetShortField(0, "NtTib.ExceptionList", 0),
                    ReadField( NtTib.StackBase ),
                    GetShortField(0, "NtTib.StackLimit", 0),
                    GetShortField(0, "NtTib.SubsystemTib", 0),
                    GetShortField(0, "NtTib.FiberData", 0),
                    GetShortField(0, "NtTib.ArbitraryUsetPointer", 0),
                    GetShortField(0, "NtTib.Self", 0),
                    GetShortField(0, "NtTib.EnvironmentPointer", 0)
            );

     teb_ClientId_UniqueProcess     = GetShortField( 0, "ClientId.UniqueProcess", 0 );
     teb_ClientId_UniqueThread      = GetShortField( 0, "ClientId.UniqueThread",  0 );
     teb_RealClientId_UniqueProcess = GetShortField( 0, "RealClientId.UniqueProcess", 0 );
     teb_RealClientId_UniqueThread  = GetShortField( 0, "RealClientId.UniqueThread",  0 );
     dprintf(
         "    ClientId:             %p . %p\n", teb_ClientId_UniqueProcess, teb_ClientId_UniqueThread );
     if ( teb_ClientId_UniqueProcess != teb_RealClientId_UniqueProcess ||
          teb_ClientId_UniqueThread  != teb_RealClientId_UniqueThread )
     {
        dprintf(
            "    Real ClientId:        %p . %p\n", teb_RealClientId_UniqueProcess, teb_RealClientId_UniqueThread );
     }

     UseHardErrorsAreDisabled = GetFieldOffset(TebType,
                                               "HardErrorMode",
                                               &HardErrorModeOffset);

    dprintf(
        "    RpcHandle:            %p\n"
        "    Tls Storage:          %p\n"
        "    PEB Address:          %p\n"
        "    LastErrorValue:       %u\n"
        "    LastStatusValue:      %x\n"
        "    Count Owned Locks:    %u\n"
        "    HardErrorMode:        %x\n",
            ReadField( ActiveRpcHandle ),
            ReadField( ThreadLocalStoragePointer ),
            ReadField( ProcessEnvironmentBlock ),
            (ULONG)ReadField( LastErrorValue ),
            (ULONG)ReadField( LastStatusValue ),
            (ULONG)ReadField( CountOfOwnedCriticalSections ),
            (ULONG) (UseHardErrorsAreDisabled
                     ? ReadField( HardErrorsAreDisabled )
                     : ReadField( HardErrorMode ))
            );
    if  (TargetMachine == IMAGE_FILE_MACHINE_IA64 && !IsWow64Teb)   {
        dprintf(
            "    DeallocationBStore:   %p\n"
            "    BStoreLimit:          %p\n",
            ReadField(DeallocationBStore),
            ReadField( BStoreLimit )
           );
    }
    return hr;
} // DumpTeb()



DECLARE_API( teb )

/*++

Routine Description:

    This function is called to dump the TEB

    Called as:

        !teb

--*/

{

    ULONG64 tebAddress;
    HRESULT hr = S_OK;

    INIT_API();
    if ( *args )   {
       tebAddress = GetExpression( args );
    } else {
        tebAddress = GetExpression("@$teb");
    }

    if ( tebAddress )   {
        if (TargetMachine == IMAGE_FILE_MACHINE_IA64 && tebAddress) {
            ULONG64 Teb32=0;
            if (GetTeb32FromWowTeb(tebAddress, &Teb32) && Teb32) {
                dprintf("Wow64 TEB32 at %p\n", Teb32);
                DumpTeb(Teb32, TRUE);
                dprintf("\n\nWow64 ");
            }
        }
       dprintf( "TEB at %p\n", tebAddress );
    } else  {
       dprintf( "TEB NULL...\n" );
       hr = E_INVALIDARG;
       goto ExitTeb;
    }
    // tebAddress = IsPtr64() ? tebAddress : (ULONG64)(LONG64)(LONG)tebAddress;

    hr = DumpTeb(tebAddress, FALSE);
ExitTeb:
    EXIT_API();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\kuser.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kuser.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
KUserExtension(
    PCSTR lpArgumentString,
    ULONG64 SharedData
    );


DECLARE_API( kuser )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the shared user mode
    page (KUSER_SHARED_DATA)

    Called as:

        !kuser

Arguments:

    None

Return Value:

    None

--*/

{

    INIT_API();
    KUserExtension( args, g_SharedUserData );
    EXIT_API();
    return S_OK;

}

char *DriveTypes[] = {
    "DOSDEVICE_DRIVE_UNKNOWN",
    "DOSDEVICE_DRIVE_CALCULATE",
    "DOSDEVICE_DRIVE_REMOVABLE",
    "DOSDEVICE_DRIVE_FIXED",
    "DOSDEVICE_DRIVE_REMOTE",
    "DOSDEVICE_DRIVE_CDROM",
    "DOSDEVICE_DRIVE_RAMDISK"
};


VOID
KUserExtension(
    PCSTR lpArgumentString,
    ULONG64 SharedData
    )
{
    BOOLEAN fFirst;
    ULONG i;
    WCHAR NtSystemRoot[MAX_PATH];
    ULONG TickCount;
    ULARGE_INTEGER TickCount64;

    try {
        if (InitTypeRead(SharedData, nt!_KUSER_SHARED_DATA))
	{
	    dprintf("Cannot read _KUSER_SHARED_DATA @ %p\n", SharedData);
	    __leave;
	}
        dprintf( "_KUSER_SHARED_DATA at %p\n", SharedData ),
        TickCount = (ULONG) ReadField(TickCountLow);
        if (TickCount) {
            dprintf( "TickCount:    %x * %08x\n",
                     (ULONG)ReadField(TickCountMultiplier),
                     TickCount
                   );
        } else {
            TickCount64.LowPart = (ULONG)ReadField(TickCount.LowPart);
            TickCount64.HighPart = (ULONG)ReadField(TickCount.High1Part);
            dprintf( "TickCount:    %x * %016I64x\n",
                     (ULONG)ReadField(TickCountMultiplier),
                     TickCount64.QuadPart
                   );
        }

#if 0
        dprintf( "Interrupt Time: %x:%08x:%08x\n",
                 (ULONG)ReadField(InterruptTime.High2Time),
                 (ULONG)ReadField(InterruptTime.High1Time),
                 (ULONG)ReadField(InterruptTime.LowPart)
               );
        dprintf( "System Time: %x:%08x:%08x\n",
                 (ULONG)ReadField(SystemTime.High2Time),
                 (ULONG)ReadField(SystemTime.High1Time),
                 (ULONG)ReadField(SystemTime.LowPart)
               );
        dprintf( "TimeZone Bias: %x:%08x:%08x\n",
                 (ULONG)ReadField(TimeZoneBias.High2Time),
                 (ULONG)ReadField(TimeZoneBias.High1Time),
                 (ULONG)ReadField(TimeZoneBias.LowPart)
               );
#endif
        dprintf( "TimeZone Id: %x\n", (ULONG)ReadField(TimeZoneId) );

        dprintf( "ImageNumber Range: [%x .. %x]\n",
                 (ULONG)ReadField(ImageNumberLow),
                 (ULONG)ReadField(ImageNumberHigh)
               );
        dprintf( "Crypto Exponent: %x\n", (ULONG)ReadField(CryptoExponent) );

        GetFieldValue(SharedData, "nt!_KUSER_SHARED_DATA", "NtSystemRoot", NtSystemRoot);

        dprintf( "SystemRoot: '%ws'\n",
                 NtSystemRoot
               );


#if 0
        dprintf( "DosDeviceMap: %08x", (ULONG)ReadField(DosDeviceMap) );
        fFirst = TRUE;
        for (i=0; i<32; i++) {
            if ((ULONG)ReadField(DosDeviceMap) & (1 << i)) {
                if (fFirst) {
                    dprintf( " (" );
                    fFirst = FALSE;
                    }
                else {
                    dprintf( " " );
                    }
                dprintf( "%c:", 'A'+i );
                }
            }
        if (!fFirst) {
            dprintf( ")" );
            }
        dprintf( "\n" );

        for (i=0; i<32; i++) {
            CHAR Field[40];
            ULONG DosDeviceDriveType;

            sprintf(Field, "DosDeviceDriveType[%d]", i);

            DosDeviceDriveType  = (ULONG) GetShortField(0, Field, 0);
            if (DosDeviceDriveType > DOSDEVICE_DRIVE_UNKNOWN &&
                DosDeviceDriveType <= DOSDEVICE_DRIVE_RAMDISK
               ) {
                dprintf( "DriveType[ %02i ] (%c:) == %s\n",
                         i, 'A'+i,
                         DriveTypes[ DosDeviceDriveType ]
                       );
                }
            }
#endif

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\psr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ia64 psr

Abstract:

    KD Extension Api

Author:

    Thierry Fevrier (v-thief)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "psr.h"

//
// EmPsrFields: EM register fields for the Processor Status Register.
//

EM_REG_FIELD EmPsrFields[] = {
        { "rv",  "reserved0"   , 0x1, 0 },   // 0
        { "be",  "Big-Endian"  , 0x1, 1 },   // 1
        { "up",  "User Performance monitor enable", 0x1, 2 }, // 2
        { "ac",  "Alignment Check", 0x1, 3 }, // 3
        { "mfl", "Lower floating-point registers written", 0x1, 4 }, // 4
        { "mfh", "Upper floating-point registers written", 0x1, 5 }, // 5
        { "rv",  "reserved1",    0x7, 6 }, // 6-12
        { "ic",  "Interruption Collection", 0x1, 13 }, // 13
        { "i",   "Interrupt enable", 0x1, 14 }, // 14
        { "pk",  "Protection Key enable", 0x1, 15 }, // 15
        { "rv",  "reserved2", 0x1, 16 }, // 16
        { "dt",  "Data Address Translation enable", 0x1, 17 }, // 17
        { "dfl", "Disabled Floating-point Low  register set", 0x1, 18 }, // 18
        { "dfh", "Disabled Floating-point High register set", 0x1, 19 }, // 19
        { "sp",  "Secure Performance monitors", 0x1, 20 }, // 20
        { "pp",  "Privileged Performance monitor enable", 0x1, 21 }, // 21
        { "di",  "Disable Instruction set transition", 0x1, 22 }, // 22
        { "si",  "Secure Interval timer", 0x1, 23 }, // 23
        { "db",  "Debug Breakpoint fault enable", 0x1, 24 }, // 24
        { "lp",  "Lower Privilege transfer trap enable", 0x1, 25 }, // 25
        { "tb",  "Taken Branch trap enable", 0x1, 26 }, // 26
        { "rt",  "Register stack translation enable", 0x1, 27 }, // 27
        { "rv",  "reserved3", 0x4, 28 }, // 28-31
        { "cpl", "Current Privilege Level", 0x2, 32 }, // 32-33
        { "is",  "Instruction Set", 0x1, 34 }, // 34
        { "mc",  "Machine Abort Mask delivery disable", 0x1, 35 }, // 35
        { "it",  "Instruction address Translation enable", 0x1, 36 }, // 36
        { "id",  "Instruction Debug fault disable", 0x1, 37 }, // 37
        { "da",  "Disable Data Access and Dirty-bit faults", 0x1, 38 }, // 38
        { "dd",  "Data Debug fault disable", 0x1, 39 }, // 39
        { "ss",  "Single Step enable", 0x1, 40 }, // 40
        { "ri",  "Restart Instruction", 0x2, 41 }, // 41-42
        { "ed",  "Exception Deferral", 0x1, 43 }, // 43
        { "bn",  "register Bank", 0x1, 44 }, // 44
        { "ia",  "Disable Instruction Access-bit faults", 0x1, 45 }, // 45
        { "rv",  "reserved4", 0x12, 46 } // 46-63
};

VOID
DisplayFullEmRegField(
    ULONG64      EmRegValue,
    EM_REG_FIELD EmRegFields[],
    ULONG        Field
    )
{
   dprintf( "\n %3.3s : %I64x : %-s",
            EmRegFields[Field].SubName,
            (EmRegValue >> EmRegFields[Field].Shift) & ((1 << EmRegFields[Field].Length) - 1),
            EmRegFields[Field].Name
          );
   return;
} // DisplayFullEmRegField()


VOID
DisplayFullEmReg(
    IN ULONG64      Val,
    IN EM_REG_FIELD EmRegFields[],
    IN DISPLAY_MODE DisplayMode
    )
{
    ULONG i, j;

    i = j = 0;
    if ( DisplayMode >= DISPLAY_MAX )   {
       while( j < EM_REG_BITS )   {
          DisplayFullEmRegField( Val, EmRegFields, i );
          j += EmRegFields[i].Length;
          i++;
       }
    }
    else  {
       while( j < EM_REG_BITS )   {
          if ( !strstr(EmRegFields[i].Name, "reserved" ) &&
               !strstr(EmRegFields[i].Name, "ignored"  ) ) {
             DisplayFullEmRegField( Val, EmRegFields, i );
          }
          j += EmRegFields[i].Length;
          i++;
       }
    }
    dprintf("\n");

    return;

} // DisplayFullEmReg()

VOID
DisplayPsrIA64(
    IN const PCHAR         Header,
    IN       EM_PSR        EmPsr,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( EM_PSRToULong64(EmPsr), EmPsrFields, DisplayMode );
    }
    else   {
       dprintf(
            "ia bn ed ri ss dd da id it mc is cpl rt tb lp db\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x   %1I64x  %1I64x  %1I64x  %1I64x\n\t\t"
            "si di pp sp dfh dfl dt pk i ic | mfh mfl ac up be\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x   %1I64x   %1I64x  %1I64x %1I64x  %1I64x |  %1I64x   %1I64x   %1I64x  %1I64x  %1I64x\n",
            EmPsr.ia,
            EmPsr.bn,
            EmPsr.ed,
            EmPsr.ri,
            EmPsr.ss,
            EmPsr.dd,
            EmPsr.da,
            EmPsr.id,
            EmPsr.it,
            EmPsr.mc,
            EmPsr.is,
            EmPsr.cpl,
            EmPsr.rt,
            EmPsr.tb,
            EmPsr.lp,
            EmPsr.db,
            EmPsr.si,
            EmPsr.di,
            EmPsr.pp,
            EmPsr.sp,
            EmPsr.dfh,
            EmPsr.dfl,
            EmPsr.dt,
            EmPsr.pk,
            EmPsr.i,
            EmPsr.ic,
            EmPsr.mfh,
            EmPsr.mfl,
            EmPsr.ac,
            EmPsr.up,
            EmPsr.be
            );
    }
    return;
} // DisplayPsrIA64()

DECLARE_API( psr )

/*++

Routine Description:

    Dumps an IA64 Processor Status Word

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     psrValue;
    ULONG       result;
    ULONG       flags = 0;

    char       *header;

    result = sscanf(args,"%X %lx", &psrValue, &flags);
    psrValue = GetExpression(args);

        if ((result != 1) && (result != 2)) {
        //
        // If user specified "@ipsr"...
        //
        char ipsrStr[16];

        result = sscanf(args, "%15s %lx", ipsrStr, &flags);
        if ( ((result != 1) && (result != 2)) || strcmp(ipsrStr,"@ipsr") )   {
            dprintf("USAGE: !psr 0xValue [display_mode:0,1,2]\n");
            dprintf("USAGE: !psr @ipsr   [display_mode:0,1,2]\n");
            return E_INVALIDARG;
        }
        psrValue = GetExpression("@ipsr");
    }
    header = (flags > DISPLAY_MIN) ? NULL : "\tpsr:\t";

    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!psr not implemented for this architecture.\n");
    }
    else
    {
        DisplayPsrIA64( header, ULong64ToEM_PSR(psrValue), flags );
    }

    return S_OK;

} // !psr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\psr.h ===
#ifndef _EXTS_PSR_H_
#define _EXTS_PSR_H_

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ia64.h

Abstract:

    This file contains definitions which are specifice to ia64 platforms


Author:

    Kshitiz K. Sharma (kksharma)

Environment:

    User Mode.

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif


/////////////////////////////////////////////
//
//  Generic EM Registers definitions
//
/////////////////////////////////////////////

typedef unsigned __int64  EM_REG;
typedef EM_REG           *PEM_REG;
#define EM_REG_BITS       (sizeof(EM_REG) * 8)

__inline EM_REG
ULong64ToEMREG(
    IN ULONG64 Val
    )
{
    return (*((PEM_REG)&Val));
} // ULong64ToEMREG()

__inline ULONG64
EMREGToULong64(
    IN EM_REG EmReg
    )
{
    return (*((PULONG64)&EmReg));
} // EMRegToULong64()

#define DEFINE_ULONG64_TO_EMREG(_EM_REG_TYPE) \
__inline _EM_REG_TYPE                         \
ULong64To##_EM_REG_TYPE(                      \
    IN ULONG64 Val                            \
    )                                         \
{                                             \
    return (*((P##_EM_REG_TYPE)&Val));        \
} // ULong64To##_EM_REG_TYPE()

#define DEFINE_EMREG_TO_ULONG64(_EM_REG_TYPE) \
__inline ULONG64                              \
_EM_REG_TYPE##ToULong64(                      \
    IN _EM_REG_TYPE EmReg                     \
    )                                         \
    {                                         \
    return (*((PULONG64)&EmReg));             \
} // _EM_REG_TYPE##ToULong64()

typedef struct _EM_PSR {
   unsigned __int64 reserved0:1;  //     0 : reserved
   unsigned __int64 be:1;         //     1 : Big-Endian
   unsigned __int64 up:1;         //     2 : User Performance monitor enable
   unsigned __int64 ac:1;         //     3 : Alignment Check
   unsigned __int64 mfl:1;        //     4 : Lower (f2  ..  f31) floating-point registers written
   unsigned __int64 mfh:1;        //     5 : Upper (f32 .. f127) floating-point registers written
   unsigned __int64 reserved1:7;  //  6-12 : reserved
   unsigned __int64 ic:1;         //    13 : Interruption Collection
   unsigned __int64 i:1;          //    14 : Interrupt Bit
   unsigned __int64 pk:1;         //    15 : Protection Key enable
   unsigned __int64 reserved2:1;  //    16 : reserved
   unsigned __int64 dt:1;         //    17 : Data Address Translation
   unsigned __int64 dfl:1;        //    18 : Disabled Floating-point Low  register set
   unsigned __int64 dfh:1;        //    19 : Disabled Floating-point High register set
   unsigned __int64 sp:1;         //    20 : Secure Performance monitors
   unsigned __int64 pp:1;         //    21 : Privileged Performance monitor enable
   unsigned __int64 di:1;         //    22 : Disable Instruction set transition
   unsigned __int64 si:1;         //    23 : Secure Interval timer
   unsigned __int64 db:1;         //    24 : Debug Breakpoint fault
   unsigned __int64 lp:1;         //    25 : Lower Privilege transfer trap
   unsigned __int64 tb:1;         //    26 : Taken Branch trap
   unsigned __int64 rt:1;         //    27 : Register stack translation
   unsigned __int64 reserved3:4;  // 28-31 : reserved
   unsigned __int64 cpl:2;        // 32;33 : Current Privilege Level
   unsigned __int64 is:1;         //    34 : Instruction Set
   unsigned __int64 mc:1;         //    35 : Machine Abort Mask
   unsigned __int64 it:1;         //    36 : Instruction address Translation
   unsigned __int64 id:1;         //    37 : Instruction Debug fault disable
   unsigned __int64 da:1;         //    38 : Disable Data Access and Dirty-bit faults
   unsigned __int64 dd:1;         //    39 : Data Debug fault disable
   unsigned __int64 ss:1;         //    40 : Single Step enable
   unsigned __int64 ri:2;         // 41;42 : Restart Instruction
   unsigned __int64 ed:1;         //    43 : Exception Deferral
   unsigned __int64 bn:1;         //    44 : register Bank
   unsigned __int64 ia:1;         //    45 : Disable Instruction Access-bit faults
   unsigned __int64 reserved4:18; // 46-63 : reserved
} EM_PSR, *PEM_PSR;

typedef EM_PSR   EM_IPSR;
typedef EM_IPSR *PEM_IPSR;

DEFINE_ULONG64_TO_EMREG(EM_PSR)

DEFINE_EMREG_TO_ULONG64(EM_PSR)

typedef enum _DISPLAY_MODE {
    DISPLAY_MIN     = 0,
    DISPLAY_DEFAULT = DISPLAY_MIN,
    DISPLAY_MED     = 1,
    DISPLAY_MAX     = 2,
    DISPLAY_FULL    = DISPLAY_MAX
} DISPLAY_MODE;


typedef struct _EM_REG_FIELD  {
   const    char   *SubName;
   const    char   *Name;
   unsigned long    Length;
   unsigned long    Shift;
} EM_REG_FIELD, *PEM_REG_FIELD;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\slist.c ===
//+----------------------------------------------------------------------------
//
// File:     slist.c
//
// Module:   Debugger extension DLL
//
// Synopsis: !slist debugger extension for ntsd and kd.  Dumps the SLIST
//           header and then walks the SLIST displaying the address of
//           each node on the list.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Created:  14 Nov 2001  Scott Gasch (sgasch)
//
//+----------------------------------------------------------------------------

#include "precomp.h"
#include "ntrtl.h"
#include <string.h>
#pragma hdrstop

#define ARRAY_COUNT(x) (sizeof(x) / sizeof((x)[0]))

CHAR *g_szNodeType = NULL;
ULONG64 g_uOffset = 0;
ULONG64 g_uSlistHead = 0;
ULONG g_uPtrSize = 0;

//+----------------------------------------------------------------------------
//
// Function:  DisplaySlistHelp
//
// Synopsis:  Display a simple usage message
//
// Arguments: void
//
// Returns:   void
//
//+----------------------------------------------------------------------------
void
DisplaySlistHelp(void)
{
    dprintf("!slist <address> [symbol [offset]]\n\n"
            "Dump the slist with header at address. If symbol and offset are\n"
            "present, assume each node on the SLIST is of type symbol and that\n"
            "the SLIST pointer is at offset in the struct.\n\n"
            "Examples:\n"
            "  !slist 80543ea8\n"
            "  !slist myprog!SlistHeader myprog!NODE 0\n");
}


//+----------------------------------------------------------------------------
//
// Function:  DumpSlistHeader
//
// Synopsis:  Given the address of the SLIST header, dump it.
//
// Arguments: ULONG64 u64AddrSlistHeader -- addr of SLIST_HEADER in debugee mem
//
// Returns:   void
//
//+----------------------------------------------------------------------------
void
DumpSlistHeader(void)
{
    ULONG uOffset;                            // field offset within the struct

    dprintf("SLIST HEADER:\n");

    if (InitTypeRead(g_uSlistHead,
                     nt!_SLIST_HEADER))
    {
        dprintf("Unable to read type nt!_SLIST_HEADER at %p\n",
                g_uSlistHead);
        dprintf("Please check your symbols and sympath.\n");
        return;
    }

    //
    // Depending on the type of machine we are debugging, dump the proper
    // SLIST_HEADER structure.  Note this must change is the definition of
    // SLIST_HEADER changes in ntrtl.h.
    //
    if ((TargetMachine == IMAGE_FILE_MACHINE_IA64) ||
        (TargetMachine == IMAGE_FILE_MACHINE_AMD64))
    {
        GetFieldOffset ("nt!_SLIST_HEADER", "Alignment", &uOffset);
        dprintf("   +0x%03x Alignment          : %I64x\n",
                uOffset, ReadField(Alignment));
        dprintf("   +0x%03x (Depth)            : %x\n",
                uOffset, ReadField(Alignment) & 0xFFFF);
        GetFieldOffset ("nt!_SLIST_HEADER", "Region", &uOffset);
        dprintf("   +0x%03x Region             : %I64x\n",
                uOffset, ReadField(Region));
    }
    else
    {
        GetFieldOffset ("nt!_SLIST_HEADER", "Alignment", &uOffset);
        dprintf("   +0x%03x Alignment          : %I64x\n",
                uOffset, ReadField(Alignment));
        GetFieldOffset ("nt!_SLIST_HEADER", "Next", &uOffset);
        dprintf("   +0x%03x Next               : %I64x\n",
                uOffset, ReadField(Next));
        GetFieldOffset ("nt!_SLIST_HEADER", "Depth", &uOffset);
        dprintf("   +0x%03x Depth              : %I64x\n",
                uOffset, ReadField(Depth));
        GetFieldOffset ("nt!_SLIST_HEADER", "Sequence", &uOffset);
        dprintf("   +0x%03x Sequence           : %I64x\n",
                uOffset, ReadField(Sequence));
    }
}


//+----------------------------------------------------------------------------
//
// Function:  DumpSlist
//
// Synopsis:  Walk and display the SLIST.
//
// Arguments: ULONG64 pHeader -- addr of SLIST_HEADER in debugee mem
//
// Returns:   void
//
//+----------------------------------------------------------------------------
void
DumpSlist(void)
{
    ULONG uError;                             // result of ReadPointer operations
    ULONG64 pCurrent;                         // ptr to current item
    ULONG64 pNext;                            // ptr to next item
    ULONG64 u64Head;                          // first item scratch var
    ULONG64 u64Region;                        // region info for ia64 headers
    SYM_DUMP_PARAM SymDump;
    ULONG x;

    //
    // Determine the address of the first node on the list.
    //
    if ((TargetMachine == IMAGE_FILE_MACHINE_IA64) ||
        (TargetMachine == IMAGE_FILE_MACHINE_AMD64))
    {
        //
        // For ia64, getting the first node involves some work.  It's
        // made up of some bits from the Alignment part of the header
        // and a few bits from the Region part of the header.
        //
        // First read the Alignment part in.
        //
        uError = ReadPointer(g_uSlistHead, &u64Head);
        if (!uError)
        {
            dprintf("Can't read memory at %p, error %x\n",
                    g_uSlistHead, uError);
            return;
        }

        //
        // Now read the Region part in, 8 bytes later.
        //
        uError = ReadPointer(g_uSlistHead + 8, &u64Region);
        if (!uError)
        {
            dprintf("Can't read memory at %p, error %x\n",
                    (g_uSlistHead + 8), uError);
            return;
        }

        //
        // Note to self:
        //
        // 25 == SLIST_ADR_BITS_START
        //  4 == SLIST_ADR_ALIGMENT
        //
        // See base\ntos\rtl\ia64\slist.s
        //
        pCurrent = ((u64Head >> 25) << 4);
        pCurrent += u64Region;
    }
    else
    {
        //
        // For x86 this is easy, the pointer is sitting in the first 4
        // bytes of the Header.
        //
        uError = ReadPointer(g_uSlistHead, &u64Head);
        if (!uError)
        {
            dprintf("Can't read memory at %p, error %x\n",
                    g_uSlistHead, uError);
            return;
        }
        pCurrent = u64Head;
    }
    dprintf("\nSLIST CONTENTS:\n");

    //
    // Walk until NULL termination
    //
    while((ULONG64)0 != pCurrent)
    {
        //
        // Be responsive to ^C, allow dump of SLIST to be aborted
        //
        if (TRUE == CheckControlC())
        {
            return;
        }

        //
        // Dump this one
        //
        if (NULL == g_szNodeType)
        {
            dprintf("%p  ", pCurrent);

            for (x = 0;
                 x < 4;
                 x++)
            {
                uError = ReadPointer(pCurrent + (x * g_uPtrSize), &pNext);
                if (!uError)
                {
                    dprintf("Can't read memory at address %p, error %x\n",
                            pCurrent + (x * g_uPtrSize), uError);
                    pNext = 0;
                } else
                {
                    if (g_uPtrSize == 4)
                    {
                        dprintf("%08x ", pNext);
                    }
                    else
                    {
                        dprintf("%08x%08x ",
                                (pNext & 0xFFFFFFFF00000000) >> 32,
                                pNext & 0x00000000FFFFFFFF);
                        if (x == 1) dprintf("\n                  ");
                    }
                }

            }
            dprintf("\n");
        }
        else
        {
            dprintf("%p\n",
                    (pCurrent - g_uOffset));

            SymDump.size = sizeof(SYM_DUMP_PARAM);
            SymDump.sName = (PUCHAR)g_szNodeType;
            SymDump.Options = 0;
            SymDump.addr = pCurrent - g_uOffset;
            SymDump.listLink = NULL;
            SymDump.Context = NULL;
            SymDump.CallbackRoutine = NULL;
            SymDump.nFields = 0;
            SymDump.Fields = NULL;

            Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);
        }

        //
        // Get the next one
        //
        uError = ReadPointer(pCurrent, &pNext);
        if (!uError)
        {
            dprintf("Can't read memory at %p, error %x\n",
                    pCurrent, uError);
            return;
        }
        pCurrent = pNext;
    }
}


//+----------------------------------------------------------------------------
//
// Function:  slist
//
// Synopsis:  Entry point for !slist
//
// Arguments: Arguments to command in char *args
//
// Returns:   S_OK
//
//+----------------------------------------------------------------------------

DECLARE_API(slist)
{
    SLIST_HEADER sSlistHeader;
    ULONG64 u64AddrSlistHeader = 0;
    BOOL fSuccess;
    CHAR *pArgs = NULL;
    CHAR *pDelims = " \t";
    CHAR *pToken;
    DWORD dwNumTokens = 0;

    INIT_API();

    //
    // Reset params from last time we ran.
    //
    g_uSlistHead = 0;
    if (NULL != g_szNodeType)
    {
        free(g_szNodeType);
        g_szNodeType = NULL;
    }
    g_uOffset = 0;

    if ((TargetMachine == IMAGE_FILE_MACHINE_IA64) ||
        (TargetMachine == IMAGE_FILE_MACHINE_AMD64))
    {
        g_uPtrSize = 8;
    }
    else
    {
        g_uPtrSize = 4;
    }

    //
    // Parse our arguments
    //
    pArgs = _strdup(args);
    if (NULL == pArgs)
    {
        dprintf("Debugger machine out of memory!\n");
        goto Done;
    }

    pToken = strtok(pArgs, pDelims);
    while (NULL != pToken)
    {
        dwNumTokens++;

        if ((!strncmp(pToken, "-help", 5)) ||
            (!strncmp(pToken, "-?", 2)) ||
            (!strncmp(pToken, "/help", 5)) ||
            (!strncmp(pToken, "/?", 2)))
        {
            DisplaySlistHelp();
            goto Done;
        }
        else
        {
            if (0 == g_uSlistHead)
            {
                g_uSlistHead = GetExpression(pToken);
            }
            else if (NULL == g_szNodeType)
            {
                g_szNodeType = _strdup(pToken);
                if (NULL == g_szNodeType)
                {
                    dprintf("Debugger machine out of memory!\n");
                    goto Done;
                }
            }
            else
            {
                g_uOffset = GetExpression(pToken);
            }
        }
        pToken = strtok(NULL, pDelims);
    }

    //
    // If they called with no commandline, give them the help.
    //
    if (0 == dwNumTokens)
    {
        DisplaySlistHelp();
        goto Done;
    }

    //
    // Dump the slist header
    //
    DumpSlistHeader();

    //
    // Walk the slist
    //
    DumpSlist();

 Done:
    g_uSlistHead = 0;
    if (NULL != g_szNodeType)
    {
        free(g_szNodeType);
        g_szNodeType = NULL;
    }
    g_uOffset = 0;
    g_uPtrSize = 0;

    if (NULL != pArgs)
    {
        free(pArgs);
    }

    EXIT_API();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\sddump.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    sddump.c

Abstract:

    Debugger Extension Api

Author:

    Baskar Kothandaraman (baskark) 26-Jan-1998

Environment:

    Kernel Mode

Revision History:

    Kshitiz K. Sharma (kksharma)

    Using debugger type info : SID and ACL have exactly same type definitions on
    all platforms - No change.

--*/


#include "precomp.h"
#pragma hdrstop

/*
+-------------------------------------------------------------------+

    NAME:       sid_successfully_read

    FUNCTION:   Tries to read in a SID from the specified address.
                It first reads in the minimal structure, then
                allocates a buffer big enough to hold the whole sid
                & reads in the whole SID....

    ARGS:       Address     --  Address from which to read it from
                sid_buffer  --  variable to receive the ptr to the
                                allocated buffer with the SID.

    RETURN:     TRUE on success, FALSE otherwise.

    NOTE***:    The caller has to call free(*sid_buffer) to free
                up the memory upon a successful call to this
                function.

+-------------------------------------------------------------------+
*/

BOOLEAN sid_successfully_read(
    ULONG64            Address,
    PSID               *sid_buffer
    )
{
    ULONG           result;
    SID             minimum; /* minimum we need to read to get the details */


    *sid_buffer = NULL;

    if ( !ReadMemory( Address,
                      &minimum,
                      sizeof(minimum),
                      &result) )
    {
        dprintf("%08p: Unable to get MIN SID header\n", Address);
        return FALSE;
    }

    /* Now of read-in any extra sub-authorities necessary */

    if (minimum.SubAuthorityCount > SID_MAX_SUB_AUTHORITIES)
    {
        dprintf("SID has an invalid sub-authority_count, 0x%x\n", minimum.SubAuthorityCount);
        return FALSE;
    }
    else
    {
        ULONG   size_to_read = RtlLengthRequiredSid(minimum.SubAuthorityCount);

        *sid_buffer = malloc(size_to_read);

        if (! *sid_buffer)
        {
            dprintf("SID: can't allocate memory to read\n");
            return FALSE;
        }

        if ( !ReadMemory( Address,
                          *sid_buffer,
                          size_to_read,
                          &result) )
        {
            dprintf("%08p: Unable to get The Whole SID\n", Address);
            free(*sid_buffer);
            *sid_buffer = NULL;
            return FALSE;
        }

        if (! RtlValidSid(*sid_buffer))
        {
            dprintf("%08p: SID pointed to by this address is invalid\n", Address);
            free(*sid_buffer);
            *sid_buffer = NULL;
            return FALSE;
        }

    }

    return TRUE;
}

/*
+-------------------------------------------------------------------+

    NAME:       acl_successfully_read

    FUNCTION:   Tries to read in a ACL from the specified address.
                It first reads in the minimal structure, then
                allocates a buffer big enough to hold the whole acl
                & reads in the whole ACL....

    ARGS:       Address     --  Address from which to read it from
                acl_buffer  --  variable to receive the ptr to the
                                allocated buffer with the ACL.

    RETURN:     TRUE on success, FALSE otherwise.

    NOTE***:    The caller has to call free(*acl_buffer) to free
                up the memory upon a successful call to this
                function.

+-------------------------------------------------------------------+
*/

BOOLEAN acl_successfully_read(
    ULONG64            Address,
    PACL               *acl_buffer
    )
{
    ULONG           result;
    ACL             minimum; /* minimum we need to read to get the details */


    *acl_buffer = NULL;

    if ( !ReadMemory( Address,
                      &minimum,
                      sizeof(minimum),
                      &result) )
    {
        dprintf("%08p: Unable to get MIN ACL header\n", Address);
        return FALSE;
    }

    *acl_buffer = malloc(minimum.AclSize);

    if (! *acl_buffer)
    {
        dprintf("ACL: can't allocate memory to read\n");
        return FALSE;
    }

    if ( !ReadMemory( Address,
                      *acl_buffer,
                      minimum.AclSize,
                      &result) )
    {
        dprintf("%08p: Unable to get The Whole ACL\n", Address);
        free(*acl_buffer);
        *acl_buffer = NULL;
        return FALSE;
    }

    if (! RtlValidAcl(*acl_buffer))
    {
        dprintf("%08p: ACL pointed to by this address is invalid\n", Address);
        free(*acl_buffer);
        *acl_buffer = NULL;
        return FALSE;
    }

    return TRUE;
}

/*
+-------------------------------------------------------------------+

    NAME:       DumpSID

    FUNCTION:   Prints out a SID, with the padding provided.

    ARGS:       pad         --  Padding to print before the SID.
                sid_to_dump --  Pointer to the SID to print.
                Flag        --  To control options.

    RETURN:     N/A

    NOTE***:    It right now, doesn't lookup the sid.
                In future, you might want ot use the Flag
                parameter to make that optional.

+-------------------------------------------------------------------+
*/


VOID    DumpSID(
    CHAR        *pad,
    PSID        sid_to_dump,
    ULONG       Flag
    )
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      us;

    if (sid_to_dump)
    {
        ntstatus = RtlConvertSidToUnicodeString(&us, sid_to_dump, TRUE);

        if (NT_SUCCESS(ntstatus))
        {
            dprintf("%s%wZ", pad, &us);
            RtlFreeUnicodeString(&us);
        }
        else
        {
            dprintf("0x%08lx: Can't Convert SID to UnicodeString", ntstatus);
        }
    }
    else
    {
        dprintf("%s is NULL", pad);
    }
    if (Flag & 1) {
        PCSTR pszStr;

        dprintf(" ");

        pszStr = ConvertSidToFriendlyName(sid_to_dump, "(%s: %s\\%s)");

        if (pszStr && *pszStr) {

            dprintf(pszStr);
        }
    }
    dprintf("\n");

}

/*
+-------------------------------------------------------------------+

    NAME:       DumpACL

    FUNCTION:   Prints out a ACL, with the padding provided.

    ARGS:       pad         --  Padding to print before the ACL.
                acl_to_dump --  Pointer to the ACL to print.
                Flag        --  To control options.
                Start       --  Actual start address of the Acl

    RETURN:     N/A

+-------------------------------------------------------------------+
*/

BOOL
DumpACL (
    IN  char     *pad,
    IN  ACL      *pacl,
    IN  ULONG    Flags,
    IN  ULONG64  Start
    )
{
    USHORT       x;

    if (pacl == NULL)
    {
        dprintf("%s is NULL\n", pad);
        return FALSE;
    }

    dprintf("%s\n", pad);
    dprintf("%s->AclRevision: 0x%x\n", pad, pacl->AclRevision);
    dprintf("%s->Sbz1       : 0x%x\n", pad, pacl->Sbz1);
    dprintf("%s->AclSize    : 0x%x\n", pad, pacl->AclSize);
    dprintf("%s->AceCount   : 0x%x\n", pad, pacl->AceCount);
    dprintf("%s->Sbz2       : 0x%x\n", pad, pacl->Sbz2);

    for (x = 0; x < pacl->AceCount; x ++)
    {
        PACE_HEADER     ace;
        CHAR        temp_pad[MAX_PATH];
        NTSTATUS    result;

        _snprintf(temp_pad, sizeof(temp_pad), "%s->Ace[%u]: ", pad, x);

        result = RtlGetAce(pacl, x, &ace);
        if (! NT_SUCCESS(result))
        {
            dprintf("%sCan't GetAce, 0x%08lx\n", temp_pad, result);
            return FALSE;
        }

        dprintf("%s->AceType: ", temp_pad);

#define BRANCH_AND_PRINT(x) case x: dprintf(#x "\n"); break

        switch (ace->AceType)
        {
            BRANCH_AND_PRINT(ACCESS_ALLOWED_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_COMPOUND_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_OBJECT_ACE_TYPE);

            BRANCH_AND_PRINT(ACCESS_ALLOWED_CALLBACK_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_CALLBACK_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_CALLBACK_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_CALLBACK_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE);

            default:
                dprintf("0x%08lx <-- *** Unknown AceType\n", ace->AceType);
                continue; // With the next ace
        }

#undef BRANCH_AND_PRINT

        dprintf("%s->AceFlags: 0x%x\n", temp_pad, ace->AceFlags);

#define BRANCH_AND_PRINT(x) if (ace->AceFlags & x){ dprintf("%s            %s\n", temp_pad, #x); }

        BRANCH_AND_PRINT(OBJECT_INHERIT_ACE)
        BRANCH_AND_PRINT(CONTAINER_INHERIT_ACE)
        BRANCH_AND_PRINT(NO_PROPAGATE_INHERIT_ACE)
        BRANCH_AND_PRINT(INHERIT_ONLY_ACE)
        BRANCH_AND_PRINT(INHERITED_ACE)
        BRANCH_AND_PRINT(SUCCESSFUL_ACCESS_ACE_FLAG)
        BRANCH_AND_PRINT(FAILED_ACCESS_ACE_FLAG)

#undef BRANCH_AND_PRINT

        dprintf("%s->AceSize: 0x%x\n", temp_pad, ace->AceSize);

        /*
            From now on it is ace specific stuff.
            Fortunately ACEs can be split into 3 groups,
            with the ACE structure being the same within the group

            Added 8 more ace types for callback support.
        */

        switch (ace->AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_ALARM_ACE_TYPE:
                {
                    CHAR        more_pad[MAX_PATH];
                    SYSTEM_AUDIT_ACE    *tace = (SYSTEM_AUDIT_ACE *) ace;

                    dprintf("%s->Mask : 0x%08lx\n", temp_pad, tace->Mask);

                    _snprintf(more_pad, sizeof(more_pad), "%s->SID: ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);
                }
                break;

            case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:
            case ACCESS_DENIED_CALLBACK_ACE_TYPE:
            case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:
            case SYSTEM_ALARM_CALLBACK_ACE_TYPE:

                {
                    CHAR        more_pad[MAX_PATH];
                    SYSTEM_AUDIT_ACE    *tace = (SYSTEM_AUDIT_ACE *) ace;

                    dprintf("%s->Mask : 0x%08lx\n", temp_pad, tace->Mask);

                    _snprintf(more_pad, sizeof(more_pad), "%s->SID: ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);
                    dprintf("%s->Address : %08p\n", temp_pad, Start + (ULONG) (((PUCHAR) ace) - ((PUCHAR) pacl)));
                }
                break;

            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                {
                    CHAR                            more_pad[MAX_PATH];
                    COMPOUND_ACCESS_ALLOWED_ACE     *tace = (COMPOUND_ACCESS_ALLOWED_ACE *) ace;
                    PBYTE                           ptr;

                    dprintf("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                    dprintf("%s->CompoundAceType : 0x%08lx\n", temp_pad, tace->CompoundAceType);
                    dprintf("%s->Reserved        : 0x%08lx\n", temp_pad, tace->Reserved);

                    _snprintf(more_pad, sizeof(more_pad), "%s->SID(1)          : ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);

                    ptr = (PBYTE)&(tace->SidStart);
                    ptr += RtlLengthSid((PSID)ptr); /* Skip this & get to next sid */

                    _snprintf(more_pad, sizeof(more_pad), "%s->SID(2)          : ", temp_pad);
                    DumpSID(more_pad, ptr, Flags);
                }
                break;

            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                {
                    CHAR                            more_pad[MAX_PATH];
                    ACCESS_ALLOWED_OBJECT_ACE       *tace = (ACCESS_ALLOWED_OBJECT_ACE *) ace;
                    PBYTE                           ptr;
                    GUID                            *obj_guid = NULL, *inh_obj_guid = NULL;

                    dprintf("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                    dprintf("%s->Flags           : 0x%08lx\n", temp_pad, tace->Flags);

                    ptr = (PBYTE)&(tace->ObjectType);

                    if (tace->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        dprintf("%s                  : ACE_OBJECT_TYPE_PRESENT\n", temp_pad);
                        obj_guid = &(tace->ObjectType);
                        ptr = (PBYTE)&(tace->InheritedObjectType);
                    }

                    if (tace->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        dprintf("%s                  : ACE_INHERITED_OBJECT_TYPE_PRESENT\n", temp_pad);
                        inh_obj_guid = &(tace->InheritedObjectType);
                        ptr = (PBYTE)&(tace->SidStart);
                    }

                    if (obj_guid)
                    {
                        dprintf("%s->ObjectType      : (in HEX)", temp_pad);
                        dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                            obj_guid->Data1,
                            obj_guid->Data2,
                            obj_guid->Data3,
                            obj_guid->Data4[0],
                            obj_guid->Data4[1],
                            obj_guid->Data4[2],
                            obj_guid->Data4[3],
                            obj_guid->Data4[4],
                            obj_guid->Data4[5],
                            obj_guid->Data4[6],
                            obj_guid->Data4[7]
                            );
                    }

                    if (inh_obj_guid)
                    {
                        dprintf("%s->InhObjTYpe      : (in HEX)", temp_pad);
                        dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                            inh_obj_guid->Data1,
                            inh_obj_guid->Data2,
                            inh_obj_guid->Data3,
                            inh_obj_guid->Data4[0],
                            inh_obj_guid->Data4[1],
                            inh_obj_guid->Data4[2],
                            inh_obj_guid->Data4[3],
                            inh_obj_guid->Data4[4],
                            inh_obj_guid->Data4[5],
                            inh_obj_guid->Data4[6],
                            inh_obj_guid->Data4[7]
                            );
                    }

                    _snprintf(more_pad, sizeof(more_pad), "%s->SID             : ", temp_pad);
                    DumpSID(more_pad, ptr, Flags);
                }
                break;

            case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE:
            case SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE:
            {
                CHAR                            more_pad[MAX_PATH];
                ACCESS_ALLOWED_OBJECT_ACE       *tace = (ACCESS_ALLOWED_OBJECT_ACE *) ace;
                PBYTE                           ptr;
                GUID                            *obj_guid = NULL, *inh_obj_guid = NULL;

                dprintf("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                dprintf("%s->Flags           : 0x%08lx\n", temp_pad, tace->Flags);

                ptr = (PBYTE)&(tace->ObjectType);

                if (tace->Flags & ACE_OBJECT_TYPE_PRESENT)
                {
                    dprintf("%s                  : ACE_OBJECT_TYPE_PRESENT\n", temp_pad);
                    obj_guid = &(tace->ObjectType);
                    ptr = (PBYTE)&(tace->InheritedObjectType);
                }

                if (tace->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    dprintf("%s                  : ACE_INHERITED_OBJECT_TYPE_PRESENT\n", temp_pad);
                    inh_obj_guid = &(tace->InheritedObjectType);
                    ptr = (PBYTE)&(tace->SidStart);
                }

                if (obj_guid)
                {
                    dprintf("%s->ObjectType      : (in HEX)", temp_pad);
                    dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                        obj_guid->Data1,
                        obj_guid->Data2,
                        obj_guid->Data3,
                        obj_guid->Data4[0],
                        obj_guid->Data4[1],
                        obj_guid->Data4[2],
                        obj_guid->Data4[3],
                        obj_guid->Data4[4],
                        obj_guid->Data4[5],
                        obj_guid->Data4[6],
                        obj_guid->Data4[7]
                        );
                }

                if (inh_obj_guid)
                {
                    dprintf("%s->InhObjTYpe      : (in HEX)", temp_pad);
                    dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                        inh_obj_guid->Data1,
                        inh_obj_guid->Data2,
                        inh_obj_guid->Data3,
                        inh_obj_guid->Data4[0],
                        inh_obj_guid->Data4[1],
                        inh_obj_guid->Data4[2],
                        inh_obj_guid->Data4[3],
                        inh_obj_guid->Data4[4],
                        inh_obj_guid->Data4[5],
                        inh_obj_guid->Data4[6],
                        inh_obj_guid->Data4[7]
                        );
                }

                _snprintf(more_pad, sizeof(more_pad), "%s->SID             : ", temp_pad);
                DumpSID(more_pad, ptr, Flags);
                dprintf("%s->Address : %08p\n", temp_pad, Start + (ULONG) (((PUCHAR) ace) - ((PUCHAR) pacl)));
            }
            break;
        }
        dprintf("\n");
    }

    return TRUE;
}

/*
+-------------------------------------------------------------------+

    NAME:       DumpSD

    FUNCTION:   Prints out a Security Descriptor,
                with the padding provided.

    ARGS:       pad          --  Padding to print before the ACL.
                sd_to_dump   --  Pointer to the ACL to print.
                owner        --  Ptr to Owner SID
                group        --  Ptr to Group SID
                dacl         --  Ptr to DACL
                sacl         --  Ptr to SACL
                Flag         --  To control options.
                dacl_address --  Actual start address of the dacl
                sacl_address --  Actual start address of the sacl

    RETURN:     N/A

+-------------------------------------------------------------------+
*/

BOOL
DumpSD (
    IN  char     *pad,
    IN  ULONG64                 sd_to_dump,
    IN  PSID                    owner,
    IN  PSID                    group,
    IN  PACL                    dacl,
    IN  PACL                    sacl,
    IN  ULONG                   Flags,
    IN  ULONG64                 dacl_address,
    IN  ULONG64                 sacl_address
    )
{
    ULONG Control;

    InitTypeRead(sd_to_dump, SECURITY_DESCRIPTOR);
    Control = (ULONG) ReadField(Control);

#define CHECK_SD_CONTROL_FOR(x)\
    if (Control & x)\
    {\
        dprintf("%s            %s\n", pad, #x);\
    }\

    dprintf("%s->Revision: 0x%x\n", pad, (ULONG) ReadField(Revision));
    dprintf("%s->Sbz1    : 0x%x\n", pad, (ULONG) ReadField(Sbz1));
    dprintf("%s->Control : 0x%x\n", pad, (ULONG) ReadField(Control));

    CHECK_SD_CONTROL_FOR(SE_OWNER_DEFAULTED)
    CHECK_SD_CONTROL_FOR(SE_GROUP_DEFAULTED)
    CHECK_SD_CONTROL_FOR(SE_DACL_PRESENT)
    CHECK_SD_CONTROL_FOR(SE_DACL_DEFAULTED)
    CHECK_SD_CONTROL_FOR(SE_SACL_PRESENT)
    CHECK_SD_CONTROL_FOR(SE_SACL_DEFAULTED)
    CHECK_SD_CONTROL_FOR(SE_DACL_UNTRUSTED)
    CHECK_SD_CONTROL_FOR(SE_SERVER_SECURITY)
    CHECK_SD_CONTROL_FOR(SE_DACL_AUTO_INHERIT_REQ)
    CHECK_SD_CONTROL_FOR(SE_SACL_AUTO_INHERIT_REQ)
    CHECK_SD_CONTROL_FOR(SE_DACL_AUTO_INHERITED)
    CHECK_SD_CONTROL_FOR(SE_SACL_AUTO_INHERITED)
    CHECK_SD_CONTROL_FOR(SE_DACL_PROTECTED)
    CHECK_SD_CONTROL_FOR(SE_SACL_PROTECTED)
    CHECK_SD_CONTROL_FOR(SE_SELF_RELATIVE)

    {
        CHAR        temp_pad[MAX_PATH];

        _snprintf(temp_pad, sizeof(temp_pad), "%s->Owner   : ", pad);

        DumpSID(temp_pad, owner, Flags);

        _snprintf(temp_pad, sizeof(temp_pad), "%s->Group   : ", pad);

        DumpSID(temp_pad, group, Flags);

        _snprintf(temp_pad, sizeof(temp_pad), "%s->Dacl    : ", pad);

        DumpACL(temp_pad, dacl, Flags, dacl_address);

        _snprintf(temp_pad, sizeof(temp_pad), "%s->Sacl    : ", pad);

        DumpACL(temp_pad, sacl, Flags, sacl_address);
    }

#undef CHECK_SD_CONTROL_FOR

    return TRUE;
}

/*
+-------------------------------------------------------------------+

    NAME:       sd

    FUNCTION:   Reads in & prints the security descriptor, from
                the address specified. !sd command's workhorse.

    ARGS:       Standard Debugger extensions, refer to DECLARE_API
                macro in the header files.

+-------------------------------------------------------------------+
*/



DECLARE_API( sd )
{
    ULONG64 Address;
    ULONG   Flags;
    ULONG   result;
    PACL                dacl = NULL, sacl = NULL;
    ULONG64     dacl_address;
    ULONG64     sacl_address;
//    SECURITY_DESCRIPTOR sd_to_dump;
    PSID                owner_sid = NULL, group_sid = NULL;
    ULONG   Control;

    Address = 0;
    Flags = 6;
    GetExpressionEx(args, &Address, &args);
    if (args && *args) Flags = (ULONG) GetExpression(args);

    if (Address == 0) {
        dprintf("usage: !sd <SecurityDescriptor-address>\n");
        goto CLEANUP;
    }

    if ( GetFieldValue( Address,
                        "SECURITY_DESCRIPTOR",
                        "Control",
                        Control) ) {
        dprintf("%08p: Unable to get SD contents\n", Address);
        goto CLEANUP;
    }

    if (Control & SE_SELF_RELATIVE)
    {
        ULONG dacl_offset, sacl_offset;

        InitTypeRead(Address, SECURITY_DESCRIPTOR_RELATIVE);

        dacl_offset = (ULONG) ReadField(Dacl);
        sacl_offset = (ULONG) ReadField(Sacl);

        if (!(Control & SE_OWNER_DEFAULTED)) /* read in the owner */
        {
            ULONG   owner_offset = (ULONG) ReadField(Owner);

            if (owner_offset != 0)
            {
                ULONG64 owner_address = Address + owner_offset;
                
                if (! sid_successfully_read(owner_address, & owner_sid))
                {
                    dprintf("%08p: Unable to read in Owner in SD\n", owner_address);
                    goto CLEANUP;
                }
            }
        }

        if (!(Control & SE_GROUP_DEFAULTED)) /* read in the group */
        {
            ULONG group_offset = (ULONG) ReadField(Group);

            if (group_offset != 0)
            {
                ULONG64 group_address = Address + group_offset;

                if (! sid_successfully_read(group_address, & group_sid))
                {
                    dprintf("%08p: Unable to read in Group in SD\n", group_address);
                    goto CLEANUP;
                }
            }
        }

        if ((Control & SE_DACL_PRESENT) &&
            (dacl_offset != 0))
        {
            dacl_address = Address + dacl_offset;

            if (! acl_successfully_read(dacl_address, & dacl))
            {
                dprintf("%08p: Unable to read in Dacl in SD\n", dacl_address);
                goto CLEANUP;
            }
        }


        if ((Control & SE_SACL_PRESENT) &&
            (sacl_offset != 0))
        {
            sacl_address = Address + sacl_offset;

            if (! acl_successfully_read(sacl_address, & sacl))
            {
                dprintf("%08p: Unable to read in Sacl in SD\n", sacl_address);
                goto CLEANUP;
            }
        }
    }
    else
    {
        ULONG64 Dacl, Sacl;
        InitTypeRead(Address, SECURITY_DESCRIPTOR);

        Dacl = ReadField(Dacl);
        Sacl = ReadField(Sacl);

        if (!(Control & SE_OWNER_DEFAULTED)) /* read in the owner */
        {
            ULONG64      owner_address = ReadField(Owner);

            if (owner_address != 0 &&
                ! sid_successfully_read(owner_address, & owner_sid))
            {
                dprintf("%08p: Unable to read in Owner in SD\n", owner_address);
                goto CLEANUP;
            }
        }

        if (!(Control & SE_GROUP_DEFAULTED)) /* read in the group */
        {
            ULONG64     group_address = ReadField(Group);

            if (group_address != 0 &&
                ! sid_successfully_read(group_address, & group_sid))
            {
                dprintf("%08p: Unable to read in Group in SD\n", group_address);
                goto CLEANUP;
            }
        }

        if ((Control & SE_DACL_PRESENT) &&
            (Dacl != 0))
        {
            dacl_address = Dacl;

            if (! acl_successfully_read(dacl_address, & dacl))
            {
                dprintf("%08p: Unable to read in Dacl in SD\n", dacl_address);
                goto CLEANUP;
            }
        }

        if ((Control & SE_SACL_PRESENT) &&
            (Sacl != 0))
        {
            sacl_address = (Sacl);

            if (! acl_successfully_read(sacl_address, & sacl))
            {
                dprintf("%08p: Unable to read in Sacl in SD\n", sacl_address);
                goto CLEANUP;
            }
        }
    }

    DumpSD("", Address, owner_sid, group_sid, dacl, sacl, Flags, dacl_address, sacl_address);


CLEANUP:

    if (owner_sid)
    {
        free(owner_sid);
    }

    if (group_sid)
    {
        free(group_sid);
    }

    if (dacl)
    {
        free(dacl);
    }

    if (sacl)
    {
        free(sacl);
    }
    return S_OK;
}

PSTR g_SidAttrType = "nt!_SID_AND_ATTRIBUTES";

ULONG64
GetSidAddr(ULONG64 BaseAddress)
{
    ULONG64 Addr;
    if (GetFieldValue(BaseAddress, g_SidAttrType, "Sid", Addr))
    {
        dprintf("Cannot read %s.Sid @ %p\n", g_SidAttrType, BaseAddress);
        return 0;
    }
    return Addr;
}

ULONG
GetSidAttributes(ULONG64 BaseAddress)
{
    ULONG Attributes;

    if (GetFieldValue(BaseAddress, g_SidAttrType, "Attributes", Attributes))
    {
        dprintf("Cannot read %s.Attributes @%p\n", g_SidAttrType, BaseAddress);
        return 0;
    }
    return Attributes;
}

typedef
BOOL
(* PFuncLookupAccountSidA)(
    IN LPCSTR lpSystemName,
    IN PSID Sid,
    OUT LPSTR Name,
    IN OUT LPDWORD cbName,
    OUT LPSTR ReferencedDomainName,
    IN OUT LPDWORD cbReferencedDomainName,
    OUT PSID_NAME_USE peUse
    );

BOOL
WINAPI
LsaLookupAccountSidA(
    IN LPCSTR lpSystemName,
    IN PSID Sid,
    OUT LPSTR Name,
    IN OUT LPDWORD cbName,
    OUT LPSTR ReferencedDomainName,
    IN OUT LPDWORD cbReferencedDomainName,
    OUT PSID_NAME_USE peUse
    )
{
    PFuncLookupAccountSidA pFuncLookupAccountSidA = NULL;
    BOOL bRetval = FALSE;

    HMODULE hLib = LoadLibrary("advapi32.dll");
    if (hLib)
    {
        pFuncLookupAccountSidA = (PFuncLookupAccountSidA) GetProcAddress(hLib, "LookupAccountSidA");

        if (pFuncLookupAccountSidA)
        {
            bRetval = pFuncLookupAccountSidA(lpSystemName, Sid, Name, cbName,
                                             ReferencedDomainName, cbReferencedDomainName, peUse);
        }

        FreeLibrary(hLib);
    }

    return bRetval;

}

PCSTR GetSidTypeStr(IN SID_NAME_USE eUse)
{
    static PCSTR acszSidTypeStr[] = {
        "Invalid", "User", "Group", "Domain", "Alias", "Well Known Group",
        "Deleted Account", "Invalid", "Unknown", "Computer",
    };

    if (eUse < SidTypeUser || eUse > SidTypeComputer) {
        dprintf( "Unrecognized SID");
        return NULL;
    }

    return acszSidTypeStr[eUse];
}

PCSTR ConvertSidToFriendlyName(IN SID* pSid, IN PCSTR pszFmt)
{
    HRESULT hRetval = E_FAIL;

    static CHAR szSid[MAX_PATH] = {0};

    CHAR szName[MAX_PATH] = {0};
    CHAR szDomainName[MAX_PATH] ={0};
    SID_NAME_USE eUse = SidTypeInvalid;
    DWORD cbName = sizeof(szName) - 1;
    DWORD cbDomainName = sizeof(szDomainName) - 1;
    PCSTR pszSidTypeStr;

    if (CheckControlC())
    {
        return NULL;
    }

    //
    // null terminates szSid
    //
    szSid[0] = 0;

    hRetval = LsaLookupAccountSidA(NULL, pSid,
                    szName, &cbName,
                    szDomainName, &cbDomainName,
                    &eUse) ? S_OK : GetLastError() + 0x80000000;

    if (SUCCEEDED(hRetval))
    {

        pszSidTypeStr = GetSidTypeStr(eUse);
        if (!pszSidTypeStr)
        {
            return NULL;
        }
        hRetval = _snprintf(szSid, sizeof(szSid) -1, pszFmt, pszSidTypeStr, *szDomainName ? szDomainName : "localhost", szName) >= 0 ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    }

    if (FAILED(hRetval) && (ERROR_NONE_MAPPED != HRESULT_CODE(hRetval))) {

        dprintf("ConvertSidToFriendlyName on failed with error code %#x\n", hRetval);

        return NULL;
    }

    //
    // Indicate none mapped if so
    //
    if (!*szSid)
    {

        _snprintf(szSid, sizeof(szSid) - 1, "(no name mapped)");
    }

    return szSid;
}

void ShowSid(IN PCSTR pszPad, IN ULONG64 addrSid, IN ULONG fOptions)
{
    PSID    sid_to_dump = NULL;
    if (!addrSid) {

        dprintf("%s(null)\n", pszPad);
        return;
    }

    if (! sid_successfully_read(addrSid, & sid_to_dump))
    {
        dprintf("%s%08p: Unable to read in SID\n", pszPad,addrSid);
        return ;
    }

    DumpSID((PCHAR) pszPad, sid_to_dump, fOptions);

    if (sid_to_dump)
    {
        free (sid_to_dump);
    }
}


/*
+-------------------------------------------------------------------+

    NAME:       sid

    FUNCTION:   Reads in & prints the SID, from
                the address specified. !sid command's workhorse.

    ARGS:       Standard Debugger extensions, refer to DECLARE_API
                macro in the header files.

+-------------------------------------------------------------------+
*/

DECLARE_API( sid )
{
    ULONG64 Address;
    ULONG   Flags;
    ULONG   result;
    PSID    sid_to_dump = NULL;
    NTSTATUS        ntstatus;
    UNICODE_STRING  us;


    Address = 0;
    Flags = 6;
    GetExpressionEx(args, &Address, &args);
    if (args && *args) Flags = (ULONG) GetExpression(args);

    if (Address == 0) {
        dprintf("usage: !sid <SID-address>\n");
        return E_INVALIDARG;
    }

    if (! sid_successfully_read(Address, & sid_to_dump))
    {
        dprintf("%08p: Unable to read in SID\n", Address);
        return E_INVALIDARG;
    }

    DumpSID("SID is: ", sid_to_dump, Flags);

    if (sid_to_dump)
    {
        free (sid_to_dump);
    }
    return S_OK;
}

/*
+-------------------------------------------------------------------+

    NAME:       acl

    FUNCTION:   Reads in & prints the ACL, from
                the address specified. !acl command's workhorse.

    ARGS:       Standard Debugger extensions, refer to DECLARE_API
                macro in the header files.

+-------------------------------------------------------------------+
*/

DECLARE_API( acl )
{
    ULONG64 Address;
    ULONG   Flags;
    ULONG   result;
    PACL    acl_to_dump;
    NTSTATUS        ntstatus;
    UNICODE_STRING  us;


    Address = 0;
    Flags = 6;
    GetExpressionEx(args, &Address, &args);
    if (args && *args) Flags = (ULONG) GetExpression(args);
    if (Address == 0) {
        dprintf("usage: !acl <ACL-address>\n");
        return E_INVALIDARG;
    }

    if (! acl_successfully_read(Address, & acl_to_dump))
    {
        dprintf("%08p: Unable to read in ACL\n", Address);
        return E_INVALIDARG;
    }

    DumpACL("ACL is: ", acl_to_dump, Flags, Address);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\token.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    token.hxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode / Kernel Mode

Revision History:

--*/

#ifndef TOKEN_HXX
#define TOKEN_HXX

#define DUMP_HEX        0x1
#define DUMP_SD         0x80

#define SATYPE_USER     1
#define SATYPE_GROUP    2
#define SATYPE_PRIV     3

HRESULT LocalDumpSid(IN PCSTR pszPad, PSID pxSid, IN ULONG fOptions);

DECLARE_API(token);

__inline PCSTR EasyStr(IN PCSTR pszName)
{
    return pszName ? pszName : "(null)";
}

#if defined(DBG)
#define DBG_LOG(uLevel, Msg) { dprintf("Level %lx : ", uLevel); dprintf Msg ;}
#else
#define DBG_LOG(uLevel, Msg)  // do nothing
#endif

#endif // #ifndef TOKEN_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\tls.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    tls.cpp

Abstract:

    WinDbg Extension Api

Author:

    Deon Brewis (deonb) 2-Jun-2002

Environment:

    User Mode.
    Kernel Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <time.h>

#define TLS_ALL     -2
#define TLS_CURRENT -1

// #define TLS_DBG

#ifdef TLS_DBG
#define trace dprintf
#else
#define trace __noop
#endif

EXTERN_C BOOL GetTeb32FromWowTeb(ULONG64 Teb, PULONG64 pTeb32); // implemented in peb.c
EXTERN_C BOOL GetPeb32FromWowTeb(ULONG64 Teb, PULONG64 pPeb32); // implemented in peb.c

BOOLEAN TestBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )
{

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    return (BOOLEAN)((*ByteAddress >> ShiftCount) & 1);
}

ULONG64 GetPebForTarget()
{
    ULONG64 pebAddress;
    ULONG64 peb;
    
    pebAddress = GetExpression("@$peb");

    ULONG64 tebAddress;
    tebAddress = GetExpression("@$teb");
    if (tebAddress)
    {
        if (TargetMachine == IMAGE_FILE_MACHINE_IA64 && tebAddress)
        {
            ULONG64 Peb32=0;
            if (GetPeb32FromWowTeb(tebAddress, &Peb32) && Peb32) 
            {
                trace("Wow64 PEB32 at %lx\n", Peb32);
                pebAddress = Peb32;
            }
        }
    }

    if (pebAddress) 
    {
        trace( "PEB at %p\n", pebAddress );
        peb = IsPtr64() ? pebAddress : (ULONG64)(LONG64)(LONG)pebAddress;
    }
    else  
    {
       trace( "PEB NULL...\n" );
       peb = 0;
    }

    return peb;
}

ULONG64 GetTebForTarget(ULONG64 ulThread)
{
    trace("GetTebForTarget %p\n", ulThread);
    
    ULONG64 tebAddress;
    ULONG64 teb;

    if (TLS_ALL == ulThread)
    {
        return 0;
    }

    if (TLS_CURRENT == ulThread)
    {
        tebAddress = GetExpression("@$teb");
    } 
    else 
    {
        tebAddress = ulThread; // GetTebForThread!!
    }

    if ( tebAddress )   
    {
        if (TargetMachine == IMAGE_FILE_MACHINE_IA64 && tebAddress) 
        {
            ULONG64 Teb32=0;
            if (GetTeb32FromWowTeb(tebAddress, &Teb32) && Teb32) 
            {
                trace("Wow64 TEB32 at %p\n", Teb32);
                tebAddress = Teb32;
                trace("\n\nWow64 ");
            }
        }
        trace( "TEB at %p\n", tebAddress);
    } 
    else  
    {
       trace( "TEB NULL...\n" );
       teb = 0;
    }

    if (tebAddress)
    {
        teb = IsPtr64() ? tebAddress : (ULONG64)(LONG64)(LONG)tebAddress;
    }
    else
    {
        teb = 0;
    }

    return teb;
}

// Function:  HrReadPRtlBitmap
//
// Arguments: Address    [in]  Location of RTL BITMAP
//            pRtlBitmap [out] RTL Bitmap. Free with LocalFree / not
HRESULT HrReadPRtlBitmap(IN ULONG64 pAddress, OUT PRTL_BITMAP *ppRtlBitmap)
{
    HRESULT hr = S_OK;

    if (!pAddress || !ppRtlBitmap)
    {
        return E_INVALIDARG;
    }

    ULONG64 Address;
    if (!ReadPointer(pAddress, &Address))
    {
        *ppRtlBitmap = NULL;
        return E_FAIL;
    }

    DWORD dwPtrSize;
    if (IsPtr64()) 
    {
        dwPtrSize = sizeof(DWORD64);
    }
    else 
    {
        dwPtrSize = sizeof(DWORD);
    }

    ULONG SizeOfBitMap;
    if (ReadMemory(Address, &SizeOfBitMap, sizeof(SizeOfBitMap), NULL))
    {
        *ppRtlBitmap = reinterpret_cast<PRTL_BITMAP>(LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(RTL_BITMAP) + (SizeOfBitMap / 8) ));
        if (*ppRtlBitmap)
        {
            // Create an internal pointer into itself
            (*ppRtlBitmap)->Buffer = reinterpret_cast<PULONG>(reinterpret_cast<LPBYTE>(*ppRtlBitmap) + sizeof(RTL_BITMAP));
            (*ppRtlBitmap)->SizeOfBitMap = SizeOfBitMap;
            
            ULONG64 pBuffer = NULL;
            if (ReadPointer(Address + dwPtrSize, &pBuffer))
            {
                if (!ReadMemory(pBuffer, (*ppRtlBitmap)->Buffer, SizeOfBitMap / 8, NULL))
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_FAIL;
            }

            if (FAILED(hr))
            {
                LocalFree(*ppRtlBitmap);
                *ppRtlBitmap = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

#define return_msg(hr, msg) dprintf(msg); return hr; 

//
// Function:  DumpTls
//
// Arguments: 
//            ulSlot     [in]  Slot id    || TLS_ALL for all.
//            ulThread   [in]  Thread id  || TLS_CURRENT for current || TLS_ALL for all
//
// Returns: S_OK is succeeded
//
HRESULT
DumpTls (
    IN ULONG ulSlot,
    IN ULONG64 ulThread,
    IN LPCWSTR szThreadDescription
    )
{
    HRESULT hr;

    trace("DUMPTLS: %p %p\n", ulSlot, ulThread);

    if ( (TLS_ALL != ulSlot) && (ulSlot > 1088) )
    {
        return_msg (E_INVALIDARG, "Slot must be 0 to 1088 (or -1 to dump slot 0)\n");
    }

    ULONG64 Peb = GetPebForTarget();
    if (!Peb)
    {
        return_msg (E_INVALIDARG, "Could not get Peb for target - check your symbols for nt!\n");
    }
    trace("Peb = %p\n", Peb);

    ULONG64 Teb = GetTebForTarget(ulThread);
    if (!Teb)
    {
        return_msg (E_INVALIDARG, "Could not get Teb for target - check your symbols for nt!\n");
    }
    trace("Teb = %p\n", Teb);

    WCHAR szOwnDescription[MAX_PATH];
    if ( (TLS_CURRENT == ulThread) && !szThreadDescription)
    {
        ULONG64 ethread = GetExpression("@$thread");

        if (ethread)
        {
            if (ERROR_SUCCESS == InitTypeRead(ethread, nt!_ETHREAD))
            {
                ULONG64 Cid_UniqueProcess = GetExpression("@$tpid");
                ULONG64 Cid_UniqueThread = GetExpression("@$tid");

                if (Cid_UniqueProcess &&  Cid_UniqueThread)
                {
                    trace("%04x %1p.%1p\n", ulSlot, Cid_UniqueProcess, Cid_UniqueThread);
                    swprintf(szOwnDescription, L"%I64x.%I64x", Cid_UniqueProcess, Cid_UniqueThread);
                    szThreadDescription = szOwnDescription;
                }

            }
        }
    }

    if (TLS_ALL == ulSlot)
    {
        if (szThreadDescription)
        {
            dprintf("TLS slots on thread: %S\n", szThreadDescription);
        }
        else
        {
            dprintf("TLS slots on thread: %p\n", Teb);
        }
    }

    DWORD dwPtrSize;
    if (IsPtr64()) 
	{
        dwPtrSize = sizeof(DWORD64);
    }
    else 
	{
        dwPtrSize = sizeof(DWORD);
    }

    hr = E_FAIL;
    PRTL_BITMAP pTlsBitmap = NULL;
    PRTL_BITMAP pTlsExpansionBitmap = NULL;

    ULONG TlsBitmap_Offset; 
    GetFieldOffset("PEB", "TlsBitmap", &TlsBitmap_Offset);
    if (TlsBitmap_Offset)
    {
        ULONG TlsExpansionBitmap_Offset;
        GetFieldOffset("PEB", "TlsExpansionBitmap", &TlsExpansionBitmap_Offset);
        if (TlsExpansionBitmap_Offset)
        {
            hr = HrReadPRtlBitmap(Peb + TlsBitmap_Offset, &pTlsBitmap);
            if (SUCCEEDED(hr))
            {
                hr = HrReadPRtlBitmap(Peb + TlsExpansionBitmap_Offset, &pTlsExpansionBitmap);
                if (SUCCEEDED(hr))
                {
                    trace("pTlsBitmap: %p\n", pTlsBitmap);
                    trace("pTlsExpansionBitmap: %p\n", pTlsExpansionBitmap);
                }
            }
        }
    }
    if (FAILED(hr))
    {
        LocalFree(pTlsBitmap);
        LocalFree(pTlsExpansionBitmap);
        return_msg (E_FAIL, "Could not get read TlsBitmap or TlsExpansionBitmap in peb - check your symbols for nt!\n");
    }

    hr = E_FAIL;
    ULONG TlsSlots_Offset;
    ULONG TlsExpansionSlots_Offset;
    GetFieldOffset("TEB", "TlsSlots", &TlsSlots_Offset);
    if (TlsSlots_Offset)
    {
        GetFieldOffset("TEB", "TlsExpansionSlots", &TlsExpansionSlots_Offset);
        if (TlsExpansionSlots_Offset)
        {
            hr = S_OK;
        }
    }
    if (FAILED(hr))
    {
        LocalFree(pTlsBitmap);
        LocalFree(pTlsExpansionBitmap);
        return_msg (E_FAIL, "Could not get read TlsSlots or TlsExpansionSlots in teb - check your symbols for nt!\n");
    }

    if (TLS_ALL == ulSlot)
	{
        trace("All slots\n");

        LPBYTE arrTlsSlots = new BYTE[dwPtrSize * 1088];
        if (arrTlsSlots)
        {
            hr = E_FAIL;
            
            if (ReadMemory(Teb + TlsSlots_Offset, arrTlsSlots, 64 * dwPtrSize, NULL))
            {
                ULONG64 pTlsExpansionSlots;
                if (ReadPointer(Teb + TlsExpansionSlots_Offset, &pTlsExpansionSlots))
                {
                    hr = S_OK;
                    if (pTlsExpansionSlots)
                    {
                        if (!ReadMemory(pTlsExpansionSlots, arrTlsSlots + (64 * dwPtrSize), 1024, NULL))
                        {
                            hr = E_FAIL;
                        }
                    }
                }
            }

            if (FAILED(hr))
            {
                delete[] arrTlsSlots;
                LocalFree(pTlsBitmap);
                LocalFree(pTlsExpansionBitmap);
                return_msg (E_FAIL, "Could not read content of Tls Slots from teb - check your symbols for nt!\n");
            }

            BOOL bFound = FALSE;

            for (int x = 0; x < 1088; x++) 
		    {
			    if (CheckControlC()) 
			    {
                    delete[] arrTlsSlots;
                    LocalFree(pTlsBitmap);
                    LocalFree(pTlsExpansionBitmap);
				    return FALSE;
			    }

                BOOL bSet = FALSE;

                if (x < TLS_MINIMUM_AVAILABLE)
                {
                    if (!TestBit(pTlsBitmap, x))
                    {
                        continue;
                    }
                    else
                    {
                        bFound = TRUE;;
                    }
                }
                else
                {
                    if (!TestBit(pTlsExpansionBitmap, x - TLS_MINIMUM_AVAILABLE))
                    {
                        continue;
                    }
                    else
                    {
                        bFound = TRUE;;
                    }
                }

                if ( sizeof(DWORD64) == dwPtrSize )
                {
                    dprintf("0x%04x : %p\n", x, reinterpret_cast<DWORD64*>(arrTlsSlots)[x]);
                }
                else
                {
                    dprintf("0x%04x : %p\n", x, reinterpret_cast<DWORD*>(arrTlsSlots)[x]);
                }
            }

            if (!bFound)
            {
                dprintf("  No TLS slots have been allocated for this process.\n");
            }

            delete[] arrTlsSlots;
        }
    }
    else
    {
        ULONG64 Tls_Location = 0;
        if (ulSlot < TLS_MINIMUM_AVAILABLE)
        {
            Tls_Location = Teb + TlsSlots_Offset + ulSlot * dwPtrSize;
        }
        else
        {
            if (ReadPointer(Teb + TlsExpansionSlots_Offset, &Tls_Location))
            {
                Tls_Location += (ulSlot * dwPtrSize);
            }
        }
        if (!Tls_Location)
        {
            LocalFree(pTlsBitmap);
            LocalFree(pTlsExpansionBitmap);
            return_msg (E_FAIL, "Could not read content TlsLocation from teb - check your symbols for nt!\n");
        }

        ULONG64 Tls_SlotX; 
        if (ReadPointer(Tls_Location, &Tls_SlotX))
        {
            if (szThreadDescription)
            {
                dprintf("%S: %p\n", szThreadDescription,  Tls_SlotX);
            }
            else
            {
                dprintf("%I64x: %p\n", Teb, szThreadDescription,  Tls_SlotX);
            }
        }
        else
        {
            dprintf("Could not read TLS value from %p - check your symbols for nt!\n", Tls_Location);
        }
    }

    LocalFree(pTlsBitmap);
    LocalFree(pTlsExpansionBitmap);
    return TRUE;
}


HRESULT DumpThreadsUserMode(ULONG ulSlot)
{
    ULONG ulOldThread;
    HRESULT hr = g_ExtSystem->GetCurrentThreadId(&ulOldThread);
    if (SUCCEEDED(hr))
    {
        ULONG ulNumThreads;
        hr = g_ExtSystem->GetNumberThreads(&ulNumThreads);
        if (SUCCEEDED(hr))
        {
            trace("Threads (current %d): %d\n", ulOldThread, ulNumThreads);

            PULONG pIds = new ULONG[ulNumThreads];
            if (pIds)
            {
                PULONG pSysIds = new ULONG[ulNumThreads];
                if (pSysIds)
                {
                    hr = g_ExtSystem->GetThreadIdsByIndex(0, ulNumThreads, pIds, pSysIds);
                    if (SUCCEEDED(hr))
                    {
                        if (TLS_ALL != ulSlot)
                        {
                            dprintf("Per-thread values for slot 0x%03x:\n", static_cast<DWORD>(ulSlot));
                        }

                        for (ULONG x = 0; x < ulNumThreads; x++)
                        {
                            hr = g_ExtSystem->SetCurrentThreadId(pIds[x]);
                            if (SUCCEEDED(hr))
                            {
                                ULONG64 Cid_UniqueProcess = GetExpression("@$tpid");

                                ULONG64 teb;
                                g_ExtSystem->GetCurrentThreadTeb(&teb);

                                WCHAR szThreadDescription[MAX_PATH];
                                swprintf(szThreadDescription, L"%I64x.%1x", Cid_UniqueProcess, pSysIds[x]);
                            
                                trace("Thread: %d %d %x %x\n", x, pIds[x], pSysIds[x], teb);

                                DumpTls (ulSlot, teb, szThreadDescription);
                            }
                        }
                    }
                    delete[] pSysIds;
                }
                delete[] pIds;
            }
        }
    
        g_ExtSystem->SetCurrentThreadId(ulOldThread);
    }
    return S_OK;
}

ULONG
ThreadListCallback (
    PFIELD_INFO   NextThrd,
    PVOID         Context
    )
{
    ULONG   ulSlot = static_cast<ULONG>(reinterpret_cast<ULONG_PTR>(Context));
    ULONG64 RealThreadBase = NextThrd->address;
    if (!IsPtr64())
    {
        RealThreadBase = (ULONG64) (LONG64) (LONG) RealThreadBase;
    }

    trace("Reading %p\n", RealThreadBase);

    if (InitTypeRead(RealThreadBase, nt!_ETHREAD))
    {
        dprintf("*** Error in in reading nt!_ETHREAD @ %p\n", RealThreadBase);
        return TRUE;
    }

    ULONG64 Cid_UniqueProcess = ReadField(Cid.UniqueProcess);
    ULONG64 Cid_UniqueThread = ReadField(Cid.UniqueThread);
    ULONG64 Teb = ReadField(Tcb.Teb);

    trace("%04x %1p.%1p %1p\n", ulSlot, Cid_UniqueProcess, Cid_UniqueThread, Teb);
    
    WCHAR szThreadDescription[MAX_PATH];
    swprintf(szThreadDescription, L"%I64x.%I64x", Cid_UniqueProcess, Cid_UniqueThread);

    DumpTls (ulSlot, Teb, szThreadDescription);

    return FALSE;
}

HRESULT DumpThreadsKernelMode(ULONG ulSlot)
{
    trace("DumpThreadsKernelMode %p %p\n", ulSlot);

    ULONG64 ThreadListHead_Flink = 0;
    ULONG64 process = GetExpression("@$proc");

    trace("Process is %p\n", process);

    GetFieldValue(process, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink", ThreadListHead_Flink);
    trace("GetFieldValue returned %p\n", ThreadListHead_Flink);

    ULONG64 Next;
    if (!ReadPointer(ThreadListHead_Flink, &Next) ||
        (Next == ThreadListHead_Flink))
    {
        trace("Empty\n");
        return S_OK;
    }

    if (TLS_ALL != ulSlot)
    {
        dprintf("Per-thread values for slot 0x%03x:\n", static_cast<DWORD>(ulSlot));
    }
    
    ULONG ulList = ListType("nt!_ETHREAD", ThreadListHead_Flink, 1, 
                            "Tcb.ThreadListEntry.Flink", reinterpret_cast<LPVOID>(static_cast<ULONG_PTR>(ulSlot)), &ThreadListCallback);
    trace("ListType returned %x\n",ListType);

    return S_OK;
}


DECLARE_API( tls )
{
    ULONG64 ulProcess = NULL;
    ULONG64 ulThread = NULL;
    ULONG64 ul64Slot = NULL;
    ULONG   ulSlot = NULL;

    INIT_API();
     
    BOOL bKernelMode = FALSE;
    
    KDDEBUGGER_DATA64 kdd;
    if (GetDebuggerData('GBDK', &kdd, sizeof(kdd)))
    {
        bKernelMode = TRUE;
    }

    // Skip past leading spaces
    while (*args == ' ')
    {
        args++;
    }
    
    if (!GetExpressionEx(args, &ul64Slot, &args))
    {
        dprintf("Usage:\n"
                "tls <slot> [teb]\n"
                "  slot:  -1 to dump all allocated slots\n"
                "         {0-1088} to dump specific slot\n"
                "  teb:   <empty> for current thread\n"
                "         0 for all threads in this process\n"
                "         <teb address> (not threadid) to dump for specific thread.\n"
                );
        return S_OK;
    }

    ulSlot = static_cast<ULONG>(ul64Slot);
    
    if (ulSlot == -1)
    {
        ulSlot = TLS_ALL;
    }
    
    if (!GetExpressionEx(args, &ulThread, &args))
    {
        ulThread = TLS_CURRENT;
    }

    if (0 == ulThread)
    {
        if (bKernelMode)
        {
            DumpThreadsKernelMode(ulSlot);
        }
        else
        {
            DumpThreadsUserMode(ulSlot);
        }
    }
    else
    {        
        DumpTls (ulSlot, ulThread, NULL);
    }

    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\token.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    token.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "token.h"
//#include "util.h"
//#include "sid.h"
//
// Flags used to control level of info
//

#define SHOW_FRIENDLY_NAME           0x001
#define SHOW_VERBOSE_INFO            0x002
#define SHOW_SINGLE_ENTRY            0x004
#define SHOW_SUMMARY_ONLLY           0x008
#define DECODE_SEC_BUF_DEC           0x010
#define SHOW_NTLM                    0x020
#define SHOW_KERB                    0x040
#define SHOW_SPNEGO                  0x080
#define SHOW_LSAP                    0x100


#define TOKEN_LOG                    1


static PCSTR ImpLevels[] = {"Anonymous", "Identification", "Impersonation", "Delegation"};
#define ImpLevel(x) ((x < (sizeof(ImpLevels) / sizeof(CHAR *))) ? ImpLevels[x] : "Illegal!")

static void DisplayTokenUsage(void)
{
    dprintf("Usage:\n");
    dprintf("   !token [-n] <address>  Dump token by TOKEN address  (Kernel mode)\n");
    dprintf("   !token [-n] <handle>   Dump token by handle  (User mode)\n");
    dprintf("   !token [-n]            Dump token of active thread\n");
    dprintf("Options:\n");
    dprintf("   -?   Display this message\n");
    dprintf("   -n   Lookup Sid friendly name on host\n\n");
}

TCHAR*  GetPrivName(IN LUID* pPriv)
{
    switch (pPriv->LowPart)
    {
    case SE_CREATE_TOKEN_PRIVILEGE:
        return(SE_CREATE_TOKEN_NAME);
    case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
        return(SE_ASSIGNPRIMARYTOKEN_NAME);
    case SE_LOCK_MEMORY_PRIVILEGE:
        return(SE_LOCK_MEMORY_NAME);
    case SE_INCREASE_QUOTA_PRIVILEGE:
        return(SE_INCREASE_QUOTA_NAME);
    case SE_UNSOLICITED_INPUT_PRIVILEGE:
        return(SE_UNSOLICITED_INPUT_NAME);
    case SE_TCB_PRIVILEGE:
        return(SE_TCB_NAME);
    case SE_SECURITY_PRIVILEGE:
        return(SE_SECURITY_NAME);
    case SE_TAKE_OWNERSHIP_PRIVILEGE:
        return(SE_TAKE_OWNERSHIP_NAME);
    case SE_LOAD_DRIVER_PRIVILEGE:
        return(SE_LOAD_DRIVER_NAME);
    case SE_SYSTEM_PROFILE_PRIVILEGE:
        return(SE_SYSTEM_PROFILE_NAME);
    case SE_SYSTEMTIME_PRIVILEGE:
        return(SE_SYSTEMTIME_NAME);
    case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
        return(SE_PROF_SINGLE_PROCESS_NAME);
    case SE_INC_BASE_PRIORITY_PRIVILEGE:
        return(SE_INC_BASE_PRIORITY_NAME);
    case SE_CREATE_PAGEFILE_PRIVILEGE:
        return(SE_CREATE_PAGEFILE_NAME);
    case SE_CREATE_PERMANENT_PRIVILEGE:
        return(SE_CREATE_PERMANENT_NAME);
    case SE_BACKUP_PRIVILEGE:
        return(SE_BACKUP_NAME);
    case SE_RESTORE_PRIVILEGE:
        return(SE_RESTORE_NAME);
    case SE_SHUTDOWN_PRIVILEGE:
        return(SE_SHUTDOWN_NAME);
    case SE_DEBUG_PRIVILEGE:
        return(SE_DEBUG_NAME);
    case SE_AUDIT_PRIVILEGE:
        return(SE_AUDIT_NAME);
    case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
        return(SE_SYSTEM_ENVIRONMENT_NAME);
    case SE_CHANGE_NOTIFY_PRIVILEGE:
        return(SE_CHANGE_NOTIFY_NAME);
    case SE_REMOTE_SHUTDOWN_PRIVILEGE:
        return(SE_REMOTE_SHUTDOWN_NAME);
    case SE_UNDOCK_PRIVILEGE:
        return(SE_UNDOCK_NAME);
    case SE_SYNC_AGENT_PRIVILEGE:
        return(SE_SYNC_AGENT_NAME);
    case SE_ENABLE_DELEGATION_PRIVILEGE:
        return(SE_ENABLE_DELEGATION_NAME);
    case SE_MANAGE_VOLUME_PRIVILEGE:
        return(SE_MANAGE_VOLUME_NAME);
    default:
        return("Unknown Privilege");
    }
}

HRESULT LocalDumpSid(IN PCSTR pszPad, PSID pxSid, IN ULONG fOptions)
{
    UNICODE_STRING ucsSid = {0};
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PCSTR FriendlyName;

    NtStatus = RtlConvertSidToUnicodeString(&ucsSid, pxSid, TRUE);

    if (NT_SUCCESS(NtStatus))
    {

        dprintf("%s", pszPad);
        dprintf("%wZ", &ucsSid);

    }
    else
    {
        dprintf("LocadDumpSid failed to dump Sid at addr %p\n", pxSid);
    }

    RtlFreeUnicodeString(&ucsSid);

    if (fOptions & SHOW_FRIENDLY_NAME)
    {

        dprintf(" ");

        FriendlyName = ConvertSidToFriendlyName(pxSid, "(%s: %s\\%s)");

        if (!FriendlyName)
        {
            return E_FAIL;
        }
        dprintf(FriendlyName);
    }

    dprintf("\n");
    return S_OK;
}

void DumpAttr(IN PCSTR pszPad, IN ULONG attributes, IN ULONG SAType)
{
    if (SAType == SATYPE_GROUP)
    {
        dprintf("%sAttributes - ", pszPad);

        if (attributes & SE_GROUP_MANDATORY)
        {
            attributes &= ~SE_GROUP_MANDATORY;
            dprintf("Mandatory ");
        }

        if (attributes & SE_GROUP_ENABLED_BY_DEFAULT)
        {
            attributes &= ~SE_GROUP_ENABLED_BY_DEFAULT;
            dprintf("Default ");
        }

        if (attributes & SE_GROUP_ENABLED)
        {
            attributes &= ~SE_GROUP_ENABLED;
            dprintf("Enabled ");
        }

        if (attributes & SE_GROUP_OWNER)
        {
            attributes &= ~SE_GROUP_OWNER;
            dprintf("Owner ");
        }

        if (attributes & SE_GROUP_LOGON_ID)
        {
            attributes &= ~SE_GROUP_LOGON_ID;
            dprintf("LogonId ");
        }

        if (attributes & SE_GROUP_USE_FOR_DENY_ONLY)
        {
            attributes &= ~SE_GROUP_USE_FOR_DENY_ONLY;
            dprintf("DenyOnly ");
        }

        if (attributes & SE_GROUP_RESOURCE)
        {
            attributes &= ~SE_GROUP_RESOURCE;
            dprintf("GroupResource ");
        }


        if (attributes)
        {
            dprintf("%#x ", attributes);
        }
    }
}

void DumpLocalSidAttr(IN PSID_AND_ATTRIBUTES pSA, IN ULONG SAType, IN ULONG fOptions)
{
    LocalDumpSid("", pSA->Sid, fOptions);
    DumpAttr("    ", pSA->Attributes, SAType);
}

void DumpSidAttr(IN ULONG64 addrSid, IN ULONG attributes, IN ULONG SAType, IN ULONG fOptions)
{
    ShowSid("", addrSid, fOptions);
    DumpAttr("    ", attributes, SAType);
}

void DumpLuidAttr(PLUID_AND_ATTRIBUTES pLA, ULONG LAType)
{
    dprintf("0x%x%08x", pLA->Luid.HighPart, pLA->Luid.LowPart);
    dprintf(" %-32s", GetPrivName(&pLA->Luid));

    if (LAType == SATYPE_PRIV)
    {

        dprintf("  Attributes - ");
        if (pLA->Attributes & SE_PRIVILEGE_ENABLED)
        {

            dprintf("Enabled ");
        }

        if (pLA->Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
        {

            dprintf("Default ");
        }
    }
}

void PrintToken(IN HANDLE hToken, IN ULONG fOptions)
{
    TOKEN_USER* pTUser = NULL;
    TOKEN_GROUPS* pTGroups = NULL;
    TOKEN_PRIVILEGES* pTPrivs = NULL;
    TOKEN_PRIMARY_GROUP* pTPrimaryGroup = NULL;
    TOKEN_STATISTICS TStats = {0};
    ULONG cbRetInfo = 0;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    DWORD i = 0;
    DWORD dwSessionId = 0;

    CHAR bufferUser[256];
    CHAR bufferGroups[4096];
    CHAR bufferPriv[1024];
    CHAR bufferPriGrp[128];

    pTUser = (TOKEN_USER*) &bufferUser[0];
    pTGroups = (TOKEN_GROUPS*) &bufferGroups[0];
    pTPrivs = (TOKEN_PRIVILEGES*) &bufferPriv[0];
    pTPrimaryGroup = (TOKEN_PRIMARY_GROUP*) &bufferPriGrp[0];

    status = NtQueryInformationToken(hToken, TokenSessionId, &dwSessionId, sizeof(dwSessionId), &cbRetInfo);

    if (!NT_SUCCESS(status))
    {

        dprintf("Failed to query token:  %#x\n", status);
        return;
    }
    dprintf("TS Session ID: %#x\n", dwSessionId);

    status = NtQueryInformationToken(hToken, TokenUser, pTUser, 256, &cbRetInfo);

    if (!NT_SUCCESS(status))
    {

        dprintf("Failed to query token:  %#x\n", status);
        return;
    }

    dprintf("User: ");
    DumpLocalSidAttr(&pTUser->User, SATYPE_USER, fOptions);

    dprintf("Groups: ");
    status = NtQueryInformationToken(hToken, TokenGroups, pTGroups, 4096, &cbRetInfo);

    for (i = 0; i < pTGroups->GroupCount; i++)
    {

        dprintf("\n %02d ", i);
        DumpLocalSidAttr(&pTGroups->Groups[i], SATYPE_GROUP, fOptions);

        if (CheckControlC())
        {
            return;
        }
    }

    status = NtQueryInformationToken(hToken, TokenPrimaryGroup, pTPrimaryGroup, 128, &cbRetInfo);

    dprintf("\n");
    dprintf("Primary Group: ");
    LocalDumpSid("", pTPrimaryGroup->PrimaryGroup, fOptions);

    dprintf("Privs: ");
    status = NtQueryInformationToken(hToken, TokenPrivileges, pTPrivs, 1024, &cbRetInfo);

    if (!NT_SUCCESS(status))
    {

        printf("NtQueryInformationToken returned %#x\n", status);
        return;
    }
    for (i = 0; i < pTPrivs->PrivilegeCount; i++)
    {

        dprintf("\n %02d ", i);
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);

        if (CheckControlC())
        {
            return;
        }
    }

    status = NtQueryInformationToken(hToken, TokenStatistics, &TStats, sizeof(TStats), &cbRetInfo);

    dprintf("\nAuth ID: %x:%x\n", TStats.AuthenticationId.HighPart, TStats.AuthenticationId.LowPart);
    dprintf("Impersonation Level: %s\n", ImpLevel(TStats.ImpersonationLevel));
    dprintf("TokenType: %s\n", TStats.TokenType == TokenPrimary ? "Primary" : "Impersonation");
}

HRESULT LiveSessionToken(IN HANDLE hThread, IN HANDLE hRemoteToken, IN ULONG fOptions)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    HANDLE hProcess = NULL;
    HANDLE hToken = NULL;

    GetCurrentProcessHandle(&hProcess);

    Status = hProcess ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

    if (NT_SUCCESS(Status))
    {

        if (hRemoteToken == NULL)
        {

            Status = NtOpenThreadToken(hThread, TOKEN_QUERY, FALSE, &hToken);

            if ((Status == STATUS_NO_TOKEN) || (hToken == NULL))
            {

                dprintf("Thread is not impersonating. Using process token...\n");

                Status = NtOpenProcessToken(hProcess, TOKEN_QUERY, &hToken);
            }
        }
        else
        {

            Status = DuplicateHandle(hProcess, hRemoteToken,
                                     GetCurrentProcess(), &hToken, 0, FALSE,
                                     DUPLICATE_SAME_ACCESS) ? STATUS_SUCCESS : GetLastError() + 0x80000000;
        }
    }

    if (NT_SUCCESS(Status))
    {

        DBG_LOG(TOKEN_LOG, ("token %p, remote token %p\n", hToken, hRemoteToken));

        PrintToken(hToken, fOptions);

        CloseHandle(hToken);

    }
    else
    {

        dprintf("Error %#x getting thread token\n", Status);
    }

    return NT_SUCCESS(Status) ? S_OK : E_FAIL;
}

void DisplayPrivilegs(IN ULONG64 privAddr, IN ULONG cPriv)
{
    UCHAR buffer[1024] = {0};
    LUID_AND_ATTRIBUTES* pPrivileges = (LUID_AND_ATTRIBUTES*) buffer;
    ULONG ret;
    ULONG i;

    if ((cPriv * sizeof(LUID_AND_ATTRIBUTES)) > sizeof(buffer))
    {
        dprintf("Invalid privilege count %#lx - too large.\n", cPriv);
        return;
    }
    if (!ReadMemory(privAddr, pPrivileges, cPriv * sizeof(LUID_AND_ATTRIBUTES), &ret) ||
        (ret != cPriv * sizeof(LUID_AND_ATTRIBUTES)))
    {
        dprintf("Unable to read DisplayPrivilegs @ %p\n", privAddr);
        return;
    }

    for (i = 0; i < cPriv ; i++)
    {

        dprintf("\n %02d ", i);
        DumpLuidAttr(pPrivileges + i, SATYPE_PRIV);
        
        if (CheckControlC())
        {
            break;
        }

    }
}

void DisplayGroups(IN ULONG64 addrGroups, IN ULONG cGroup, IN ULONG cbSA, IN ULONG fOptions)
{
    ULONG i;
    ULONG64 sa;
    for (i = 0; i < cGroup; i++)
    {

        dprintf("\n %02d ", i);
        sa = addrGroups + i * cbSA;
        DumpSidAttr(GetSidAddr(sa), GetSidAttributes(sa), SATYPE_GROUP, fOptions);

        if (CheckControlC())
        {
            break;
        }
    }
}

//
// kd dump token
//
BOOL
DumpKdToken (
    IN char     *Pad,
    IN ULONG64  RealTokenBase,
    IN ULONG    Flags
    )
{
    ULONG TokenType, TokenFlags, TokenInUse, UserAndGroupCount;
    ULONG RestrictedSidCount, PrivilegeCount;
    ULONG64 AuthenticationId, TokenId, ParentTokenId, ModifiedId, UserAndGroups;
    ULONG64 RestrictedSids, Privileges, ImpersonationLevel;
    CHAR  SourceName[16];

#define TokFld(F) GetFieldValue(RealTokenBase, "TOKEN", #F, F)
#define TokSubFld(F,N) GetFieldValue(RealTokenBase, "TOKEN", #F, N)

    if (TokFld(TokenType)) {
        dprintf("%sUnable to read TOKEN at %p.\n", Pad, RealTokenBase);
        return FALSE;
    }

    if (TokenType != TokenPrimary  &&
        TokenType != TokenImpersonation) {
        dprintf("%sUNKNOWN token type - probably is not a token\n", Pad);
        return FALSE;
    }

    TokSubFld(TokenSource.SourceName, SourceName);
    TokFld(TokenFlags); TokFld(AuthenticationId);
    TokFld(TokenInUse);
    TokFld(ImpersonationLevel); TokFld(TokenId), TokFld(ParentTokenId);
    TokFld(ModifiedId); TokFld(RestrictedSids); TokFld(RestrictedSidCount);
    TokFld(PrivilegeCount); TokFld(Privileges); TokFld(UserAndGroupCount);
    TokFld(UserAndGroups);

    dprintf("%sSource: %-18s TokenFlags: 0x%x ",
            Pad, &(SourceName[0]), TokenFlags);

    //
    // Token type
    //
    if (TokenType == TokenPrimary) {
        if (TokenInUse) {
            dprintf("( Token in use )\n");
        } else {
            dprintf("( Token NOT in use ) \n");
        }
    } else
    {
        dprintf("\n");
    }

    //
    // Token ID and modified ID
    //
    dprintf("%sToken ID: %-16I64lx ParentToken ID: %I64lx\n", Pad, TokenId, ParentTokenId );

    dprintf("%sModified ID:               (%lx, %lx)\n",
            Pad, (ULONG) (ModifiedId >> 32) & 0xffffffff,  (ULONG) (ModifiedId & 0xffffffff));

    dprintf("%sRestrictedSidCount: %-6d RestrictedSids: %p\n", Pad, RestrictedSidCount, RestrictedSids );

#undef TokFld
#undef TokSubFld
    return TRUE;

    //
    // Intentionally left out as detailed info has already been displayed before and
    // dt _TOKEN displays these
    //
    dprintf("%sSidCount: %-16d Sids: %p\n", Pad, UserAndGroupCount, UserAndGroups );

    dprintf("%sPrivilegeCount: %-10d Privileges: %p\n", Pad, PrivilegeCount, Privileges );

}


void DisplayToken(ULONG64 addrToken, IN ULONG fOptions)
{
    ULONG cGroup = 0;
    ULONG cbSA = 0;
    ULONG64 addrGroups = 0;
    ULONG ret;
    ULONG64 tsa;

    if (ret = (ULONG) InitTypeRead(addrToken, nt!_TOKEN))
    {
        dprintf("InitTypeRead(%p, nt!_TOKEN) failed - %lx\n", addrToken, ret);
        return;
    }

    dprintf("TS Session ID: %#x\n", (ULONG) ReadField(SessionId));

    dprintf("User: "); // nt!_TOKEN

    tsa = ReadField(UserAndGroups); //    TSID_AND_ATTRIBUTES tsa(LsaReadPtrField(UserAndGroups));
    DumpSidAttr(GetSidAddr(tsa), GetSidAttributes(tsa), SATYPE_USER, fOptions);

    dprintf("Groups: ");

    cGroup = (ULONG) ReadField(UserAndGroupCount);

    addrGroups = ReadField(UserAndGroups);
     // ReadTypeSize("nt!_SID_AND_ATTRIBUTES[1]") - ReadTypeSize("nt!_SID_AND_ATTRIBUTES[2]");
    cbSA = GetTypeSize("nt!_SID_AND_ATTRIBUTES");
    //
    // stolen from NtQueryInformationToken because the first sid is the user itself
    //
    addrGroups += cbSA;
    cGroup -= 1;

    DisplayGroups(addrGroups, cGroup, cbSA, fOptions);

    dprintf("\n");
    dprintf("Primary Group: ");
    ShowSid("", ReadField(PrimaryGroup), fOptions);

    dprintf("Privs: ");
    DisplayPrivilegs(ReadField(Privileges), (ULONG) ReadField(PrivilegeCount));

    dprintf("\nAuthentication ID:         (%x,%x)\n", (ULONG) ReadField(AuthenticationId.HighPart), (ULONG) ReadField(AuthenticationId.LowPart));
    dprintf("Impersonation Level:       %s\n", ImpLevel((ULONG) ReadField(ImpersonationLevel)));
    dprintf("TokenType:                 %s\n", ((ULONG) ReadField(TokenType)) == TokenPrimary ? "Primary" : "Impersonation");

    DumpKdToken("", addrToken, 0);
}

#if 0

//
// This is the logic to determine impersonation info in !thread
//
if (ActiveImpersonationInfo)
{
    InitTypeRead(ImpersonationInfo, nt!_PS_IMPERSONATION_INFORMATION);
    ImpersonationInfo_Token = ReadField(Token);
    ImpersonationInfo_ImpersonationLevel = ReadField(ImpersonationLevel);

    if (ImpersonationInfo_Token)
    {
        dprintf("%sImpersonation token:  %p (Level %s)\n",
                pszPad, ImpersonationInfo_Token,
                SecImpLevels( ImpersonationInfo_ImpersonationLevel ) );
    }
    else
    {
        dprintf("%sUnable to read Impersonation Information at %x\n",
                pszPad, ImpersonationInfo );
    }
}
else
{

    dprintf("%sNot impersonating\n", pszPad);
}

#endif


HRESULT DumpSessionToken(IN ULONG dwProcessor, IN ULONG64 addrToken, IN ULONG fOptions)
{
    HRESULT hRetval = S_OK;

    ULONG64 addrThread = 0;
    ULONG64 addrProcess = 0;
    ULONG ActiveImpersonationInfo = 0;
    ULONG64 addrImpersonationInfo = 0;
    ULONG64 ret;

    //
    // If no token addr is input as argument, addrToken is zero
    //
    if  ( ((LONG64)addrToken) > 0 ) // sanity check
    {

        //
        // This can not be a kernel mode access token address
        //
        dprintf("%#I64x is not a valid KM token address, if this is an access token handle,\n", addrToken);
        dprintf("try \"!handle %#I64x\" to get the token address first\n\n", addrToken);
        hRetval = E_FAIL;
    }

        if (SUCCEEDED(hRetval) && !addrToken)
        {

            addrThread = 0;
            GetCurrentThreadAddr(dwProcessor, &addrThread);
            hRetval = addrThread ? S_OK : E_FAIL;

            if (FAILED(hRetval))
            {

                dprintf("Unable to read current thread address\n");

            }
            else
            {

                //
                // ActiveImpersonationInfo is of type C Bit Fields and has a width of 1 (Bitfield Pos 3, 1 Bit)
                //
                if (ret = InitTypeRead(addrThread, nt!_ETHREAD))
                {
                    dprintf("InitTypeRead(%I64x, nt!_ETHREAD) failed - %lx", addrThread, ret);
                    return E_FAIL;
                }

                ActiveImpersonationInfo = (ULONG) ReadField(ActiveImpersonationInfo);

                if (ActiveImpersonationInfo)
                {

                    addrImpersonationInfo = ReadField(ImpersonationInfo);

                    if (!addrImpersonationInfo ||
                        GetFieldValue(addrImpersonationInfo, "nt!_PS_IMPERSONATION_INFORMATION", "Token", addrToken))
                    {
                        dprintf("Cannot read nt!_PS_IMPERSONATION_INFORMATION.Token @ %p\n", addrImpersonationInfo);
                    }
                }
            }

            //
            //  If addrToken is NULL, then this is not an impersonation case
            //
            if (SUCCEEDED(hRetval) && !addrToken)
            {

                dprintf("Thread is not impersonating. Using process token...\n");

                GetCurrentProcessAddr(dwProcessor, addrThread, &addrProcess);
                hRetval = addrProcess ? S_OK : E_FAIL;

                if (FAILED(hRetval))
                {

                    dprintf("Unable to read current process address\n");

                }
                else
                {

                    if (GetFieldValue(addrProcess, "nt!_EPROCESS", "Token", addrToken))
                    {
                        dprintf("Cannot read nt!_EPROCESS.Token @ %p\n", addrProcess);
                    }

                    if (IsPtr64())
                    {
                        addrToken = addrToken & ~(ULONG64)15;
                    } else {
                        addrToken = addrToken & ~(ULONG64)7;
                    }

                    hRetval = addrToken ? S_OK : E_FAIL;
                }
            }

            if (FAILED(hRetval))
            {

                dprintf("Unable to read token address\n");
            }
        }

        if (SUCCEEDED(hRetval))
        {

            if (addrProcess)
            {

                dprintf("_EPROCESS %p, ", addrProcess);
            }

            if (addrThread)
            {

                dprintf("_ETHREAD %p, ", addrThread);
            }

            dprintf("%s %p\n", "_TOKEN", addrToken);


            (void)DisplayToken(addrToken, fOptions);
        }

    return hRetval;
}

HRESULT ProcessTokenOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++)
    {

        if (*pszArgs == '-' || *pszArgs == '/')
        {

            switch (*++pszArgs)
            {
            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    if (*pfOptions & SHOW_FRIENDLY_NAME)
    {
        // "!token -n" will hang the machine if it is running under usermode and
        // the process being debugged is lsass.exe
        CHAR ProcessDebugged[MAX_PATH];

        if (GetCurrentProcessName(ProcessDebugged, sizeof(ProcessDebugged)) == S_OK)
        {
            if (!_stricmp(ProcessDebugged, "lsass.exe"))
            {
                dprintf("\n\nWARNING: !token -n while debugging lsass.exe hangs the machine\n\n");
                hRetval = E_FAIL;
            }
        }
    }
    return hRetval;
}

DECLARE_API( token )
{
    HRESULT hRetval = S_OK;

    ULONG64 addrToken = 0;
    ULONG dwProcessor = 0;
    HANDLE hCurrentThread = 0;
    ULONG SessionType = DEBUG_CLASS_UNINITIALIZED;
    ULONG SessionQual = 0;

    CHAR szArgs[64] = {0};
    ULONG fOptions = 0;

    INIT_API();


    if (args && (strlen(args) < sizeof(szArgs)))
    {
        strcpy(szArgs, args);
    }

    if (SUCCEEDED(hRetval))
    {

        hRetval = ProcessTokenOptions(szArgs, &fOptions);
    }

    if (SUCCEEDED(hRetval) && szArgs[0])
    {

        hRetval = GetExpressionEx(szArgs, &addrToken, &args)  ? S_OK : E_INVALIDARG;
        if (!addrToken)
        {
            hRetval = S_OK;
        }
    }

    if (SUCCEEDED(hRetval))
    {

        hRetval = GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread);
    }

    if (SUCCEEDED(hRetval))
    {

        if (g_TargetClass == DEBUG_CLASS_USER_WINDOWS &&
            g_Qualifier == DEBUG_USER_WINDOWS_PROCESS)
        {

            hRetval = LiveSessionToken(hCurrentThread,
                                       (HANDLE)  (ULONG_PTR) addrToken,
                                       fOptions);

        }
        else if (DEBUG_CLASS_KERNEL == g_TargetClass)
        {

            hRetval = DumpSessionToken(dwProcessor, addrToken, fOptions);

        }
        else
        {

            dprintf("!token only works for kernel targets or live usermode debugging\n");
            hRetval = E_FAIL;
        }
    }

    if (E_INVALIDARG == hRetval)
    {

        (void)DisplayTokenUsage();
    }

    EXIT_API();
    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\kext.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass, g_TargetQual;
ULONG   g_TargetBuild;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS2       g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG MajorVer, Platform, MinorVer, SrvPack;
                if ((Hr = DebugControl->GetSystemVersion(&Platform, &MajorVer,
                                         &MinorVer, NULL,
                                         0, NULL,
                                         &SrvPack, NULL,
                                         0, NULL)) == S_OK) {
                    g_TargetBuild = MinorVer;
                }

                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &g_TargetQual)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


DECLARE_API ( time )
{
    dprintf("*** !time is obsolete: Use '.time'\n");
    return S_OK;
}

HRESULT
PrintString(
    BOOL Unicode,
    PDEBUG_CLIENT Client,
    LPCSTR args
    )
{
    ULONG64 AddrString;
    ULONG64 Displacement;
    STRING32 String;
    UNICODE_STRING UnicodeString;
    ULONG64 AddrBuffer;
    CHAR Symbol[1024];
    LPSTR StringData;
    HRESULT hResult;
    BOOL b;


    AddrString = GetExpression(args);
    if (!AddrString)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the string
    //

    GetSymbol(AddrString, Symbol, &Displacement);

    //
    // Read the string from the debuggees address space into our
    // own.

    b = ReadMemory(AddrString, &String, sizeof(String), NULL);

    if ( !b )
    {
        return E_FAIL;
    }

    INIT_API();

    if (IsPtr64())
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING64, Buffer),
                             &AddrBuffer);
    }
    else
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING32, Buffer),
                             &AddrBuffer);
    }

    EXIT_API();

    if (hResult != S_OK)
    {
        return E_FAIL;
    }

    StringData = (LPSTR) LocalAlloc(LMEM_ZEROINIT,
                                    String.Length + sizeof(UNICODE_NULL));

    if (!StringData)
    {
        return E_FAIL;
    }

    dprintf("String(%d,%d)", String.Length, String.MaximumLength);
    if (Symbol[0])
    {
        dprintf(" %s+%p", Symbol, Displacement);
    }

    b = ReadMemory(AddrBuffer, StringData, String.Length, NULL);

    if ( b )
    {
        if (Unicode)
        {
            ANSI_STRING AnsiString;

            UnicodeString.Buffer = (PWSTR)StringData;
            UnicodeString.Length = String.Length;
            UnicodeString.MaximumLength = String.Length+sizeof(UNICODE_NULL);

            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString,TRUE);

            dprintf(" at %p: %s\n", AddrString, AnsiString.Buffer);

            RtlFreeAnsiString(&AnsiString);
        }
        else
        {
            dprintf(" at %p: %s\n", AddrString, StringData);
        }

        LocalFree(StringData);
        return S_OK;
    }
    else
    {
        LocalFree(StringData);
        return E_FAIL;
    }
}

DECLARE_API( str )

/*++

Routine Description:

    This function is called to format and dump counted (ansi) string.

Arguments:

    args - Address

Return Value:

    None.

--*/
{
    return PrintString(FALSE, Client, args);
}

DECLARE_API( ustr )

/*++

Routine Description:

    This function is called to format and dump counted (unicode) string.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    return PrintString(TRUE, Client, args);
}

DECLARE_API( obja )

/*++

Routine Description:

    This function is called to format and dump an object attributes structure.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    ULONG64 AddrObja;
    ULONG64 Displacement;
    ULONG64 AddrString;
    STRING32 String;
    ULONG64 StrAddr = NULL;
    CHAR Symbol[1024];
    LPSTR StringData;
    BOOL b;
    ULONG Attr;
    HRESULT hResult;
    ULONG ObjectNameOffset;
    ULONG AttrOffset;
    ULONG StringOffset;

    if (IsPtr64())
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, Attributes);
        StringOffset = FIELD_OFFSET(STRING64, Buffer);
    }
    else
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, Attributes);
        StringOffset = FIELD_OFFSET(STRING32, Buffer);
    }


    AddrObja = GetExpression(args);
    if (!AddrObja)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the Obja
    //

    GetSymbol(AddrObja, Symbol, &Displacement);

    dprintf("Obja %s+%p at %p:\n", Symbol, Displacement, AddrObja);


    INIT_API();

    hResult = g_ExtData->ReadPointersVirtual(1,
                         AddrObja + ObjectNameOffset,
                         &AddrString);

    if (hResult != S_OK)
    {
        return E_FAIL;
    }

    if (AddrString)
    {
        b = ReadMemory(AddrString, &String, sizeof(String), NULL);

        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + StringOffset,
                             &StrAddr);
    }

    EXIT_API();


    if (StrAddr)
    {
        StringData = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                       String.Length+sizeof(UNICODE_NULL));

        if (StringData)
        {

            b = ReadMemory(StrAddr, StringData, String.Length, NULL);

            if (b)
            {
                dprintf("\tName is %s\n", StringData);
            }

            LocalFree(StringData);
        }

    }

    b = ReadMemory(AddrObja + AttrOffset, &Attr, sizeof(Attr), NULL);

    if (!b)
    {
        return E_FAIL;
    }

    if (Attr & OBJ_INHERIT )
    {
        dprintf("\tOBJ_INHERIT\n");
    }
    if (Attr & OBJ_PERMANENT )
    {
        dprintf("\tOBJ_PERMANENT\n");
    }
    if (Attr & OBJ_EXCLUSIVE )
    {
        dprintf("\tOBJ_EXCLUSIVE\n");
    }
    if (Attr & OBJ_CASE_INSENSITIVE )
    {
        dprintf("\tOBJ_CASE_INSENSITIVE\n");
    }
    if (Attr & OBJ_OPENIF )
    {
        dprintf("\tOBJ_OPENIF\n");
    }


    return S_OK;
}


DECLARE_API( help )
{

    dprintf("cbreg [%%%%]<RegBaseAddress>    - Displays CardBus and ExCA registers\n");
    dprintf("db [Flag] [Address [L <Range>]] - Displays memory in bytes and ANSI chars\n");
    dprintf("dc [Flag] [Address [L <Range>]] - Displays memory in ULONGs and ANSI chars\n");
    dprintf("dd [Flag] [Address [L <Range>]] - Displays memory in ULONGs\n");
    dprintf("diskspace <DriveLetter>[:]      - Displays free disk space for volume\n");
    dprintf("dp [Flag] [Address [L <Range>]] - Displays memory in ULONG_PTR\n");
    dprintf("du [Flag] [Address [L <Range>]] - Displays memory in wide chars\n");
    dprintf("dw [Flag] [Address [L <Range>]] - Displays memory in USHORTs\n");
    dprintf("eb [Flag] <Address> [[Value1] [[Value2]...]]] - Write bytes into memory\n");
    dprintf("ed [Flag] <Address> [[Value1] [[Value2]...]]] - Write ULONGs into memory\n");

    dprintf("ecb <Bus>.<Dev>.<Func> <Offset> <Data> - Edit PCI ConfigSpace byte\n");
    dprintf("ecd <Bus>.<Dev>.<Func> <Offset> <Data> - Edit PCI ConfigSpace ULONG\n");
    dprintf("ecs                                    - Edit PCI ConfigSpace help\n");
    dprintf("ecw <Bus>.<Dev>.<Func> <Offset> <Data> - Edit PCI ConfigSpace WORD\n");
    dprintf("exca <BasePort>.<SocketNum>    - Displays CardBus ExCA registers only\n");
    dprintf("help                           - Show this help\n");
    dprintf("pci [Flag] [Bus] [Device] [Function] [MinAddr] [MaxAddr]\n");
    dprintf("                               - Displays PCI type1 config\n");

    dprintf("\nType \".hh [command]\" for more detailed help\n");

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\util.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    util.c

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


ULONG
GetBitFieldOffset (
   IN LPSTR     Type,
   IN LPSTR     Field,
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   )
{
   FIELD_INFO flds = {
       Field, "", 0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_SIZE_IN_BITS,
       0, NULL};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), Type, DBG_DUMP_NO_PRINT, 0,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG Err, i=0;
   LPSTR dot, last=Field;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   *pSize   = flds.size;
   return Err;
}

ULONG
GetUlongFromAddress (
    ULONG64 Location
    )
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory(Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG))) {
        dprintf("unable to read from %08x\n",Location);
        return 0;
    }

    return Value;
}

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    )
{
    ULONG64 Value;
    ULONG result;

    if (!ReadPointer(Location,&Value)) {
        dprintf("unable to read from %08p\n",Location);
        return 0;
    }

    return Value;
}

ULONG
GetUlongValue (
    PCHAR String
    )
{
    ULONG64 Location;
    ULONG Value;
    ULONG result;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return GetUlongFromAddress( Location );
}


ULONG64
GetPointerValue (
    PCHAR String
    )
{
    ULONG64 Location, Val=0;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    ReadPointer(Location, &Val);

    return Val;
}
#if 0
VOID
DumpImageName(
    IN ULONG64 Process
    )
{
    ULONG64 ImageFileName;
    STRING String;
    ULONG Result;
    IN WCHAR Buf[512];


    if ( !GetFieldValue(Process, "EPROCESS", "ImageFileName.Buffer", ImageFileName ) ){

        wcscpy(Buf,L"*** image name unavailable ***");
        if ( ReadMemory( ImageFileName,
                         &String,
                         sizeof(STRING),
                         &Result) ) {
            if ( ReadMemory( (DWORD)String.Buffer,
                             &Buf[0],
                             String.Length,
                             &Result) ) {
                Buf[String.Length/sizeof(WCHAR)] = UNICODE_NULL;
            }
        }
    } else {
        wcscpy(Buf,L"System Process");
    }
    dprintf("%ws",Buf);
}
#endif

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    )
{
    ULONG64 RightChild;
    if (Parent == pLinks) {

        return FALSE;
    }

    if (GetFieldValue(Parent, "RTL_SPLAY_LINKS", "RightChild", RightChild)) {

        return FALSE;
    }

    if (RightChild == pLinks) {

        return TRUE;
    }

    return FALSE;
}

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    )
{
    ULONG64 LeftChild;
    if (Parent == pLinks) {

        return FALSE;
    }

    if (GetFieldValue(Parent, "RTL_SPLAY_LINKS", "LeftChild", LeftChild)) {

        return FALSE;
    }

    if (LeftChild == pLinks) {

        return TRUE;
    }

    return FALSE;
}


ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    )
/*++
    Purpose:

        Perform an in-order iteration across a splay tree, calling a
        user supplied function with a pointer to each RTL_SPLAY_LINKS
        structure encountered in the tree, and the level in the tree
        at which it was encountered (zero based).

    Arguments:

        pSplayLinks     - pointer to root of a splay tree

        DumpNodeFn      - user supplied dumping function

   Returns:

        Count of nodes encountered in the tree.

   Notes:

        Errors reading memory do not terminate the iteration if more
        work is possible.

        Consumes the Control-C flag to terminate possible loops in
        corrupt structures.

--*/
{
    ULONG Level = 0;
    ULONG NodeCount = 0;

    if (pSplayLinks) {
        ULONG64 LeftChild, RightChild, Parent, Current;

        //
        //  Retrieve the root links, find the leftmost node in the tree
        //

        if (GetFieldValue(Current = pSplayLinks,
                          "RTL_SPLAY_LINKS",
                          "LeftChild",
                          LeftChild)) {

            return NodeCount;
        }

        while (LeftChild != 0) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            if (GetFieldValue(Current = LeftChild,
                              "RTL_SPLAY_LINKS",
                              "LeftChild",
                              LeftChild)) {

                //
                //  We can try to continue from this
                //

                break;
            }

            Level++;
        }

        while (TRUE) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            NodeCount++;
            pSplayLinks = Current;
            (*DumpNodeFn)(pSplayLinks, Level);

            /*
                first check to see if there is a right subtree to the input link
                if there is then the real successor is the left most node in
                the right subtree.  That is find and return P in the following diagram

                      Links
                         \
                          .
                         .
                        .
                       /
                      P
                       \
            */

            GetFieldValue(Current, "RTL_SPLAY_LINKS", "RightChild", RightChild);
            if (RightChild != 0) {

                if (GetFieldValue(Current = RightChild,
                                  "RTL_SPLAY_LINKS",
                                  "RightChild",
                                  RightChild)) {

                    //
                    //  We've failed to step through to a successor, so
                    //  there is no more to do
                    //

                    return NodeCount;
                }

                Level++;

                GetFieldValue(Current,"RTL_SPLAY_LINKS","LeftChild",LeftChild);
                while (LeftChild != 0) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    if (GetFieldValue(Current = LeftChild,
                                     "RTL_SPLAY_LINKS",
                                     "LeftChild",
                                     LeftChild)) {

                        //
                        //  We can continue from this
                        //

                        break;
                    }

                    Level++;
                }

            } else {

                /*
                    we do not have a right child so check to see if have a parent and if
                    so find the first ancestor that we are a left decendent of. That
                    is find and return P in the following diagram

                               P
                              /
                             .
                              .
                               .
                              Links
                */

                //
                //  If the IsLeft or IsRight functions fail to read through a parent
                //  pointer, then we will quickly exit through the break below
                //

                GetFieldValue(Current, "RTL_SPLAY_LINKS", "Parent", Parent);
                while (DbgRtlIsRightChild(Current, Parent)) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    Level--;
                    pSplayLinks = (Current = Parent);
                }

                GetFieldValue(Current, "RTL_SPLAY_LINKS", "Parent", Parent);
                if (!DbgRtlIsLeftChild(Current, Parent)) {

                    //
                    //  we do not have a real successor so we break out
                    //

                    break;

                } else {

                    Level--;
                    pSplayLinks = (Current = Parent);
                }
            }
        }
    }

    return NodeCount;
}

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    )
{
    UNICODE_STRING v;
    DWORD BytesRead;

 //   dprintf("L %x, M %x, B %p ", u.Length, u.MaximumLength, u.Buffer);
    if ((u.Length <= u.MaximumLength) &&
        (u.Buffer) &&
        (u.Length > 0)) {

        v.Buffer = LocalAlloc(LPTR, u.MaximumLength+2);
        if (v.Buffer != NULL) {
            v.MaximumLength = u.MaximumLength;
            v.Length = u.Length;
            if (ReadMemory(u.Buffer,
                           v.Buffer,
                           u.Length,
                           (PULONG) &u.Buffer) &&
                (v.Buffer[0] != 0)) {
                v.Buffer[v.Length/sizeof(WCHAR)] = 0;
                dprintf("%ws", v.Buffer);
            } else {
                dprintf("< Name not readable >");
            }
            LocalFree(v.Buffer);

            return;
        }
    }
    dprintf("< Name not readable >");
}

BOOLEAN
IsHexNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   for(;*szExpression; szExpression++) {

      if      ((*szExpression)< '0') { return FALSE ; }
      else if ((*szExpression)> 'f') { return FALSE ; }
      else if ((*szExpression)>='a') { continue ;     }
      else if ((*szExpression)> 'F') { return FALSE ; }
      else if ((*szExpression)<='9') { continue ;     }
      else if ((*szExpression)>='A') { continue ;     }
      else                           { return FALSE ; }
   }
   return TRUE ;
}


BOOLEAN
IsDecNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   while(*szExpression) {

      if      ((*szExpression)<'0') { return FALSE ; }
      else if ((*szExpression)>'9') { return FALSE ; }
      szExpression ++ ;
   }
   return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\diskspace.cpp ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    diskspace.cpp

Abstract:

    WinDbg Extension Api

Environment:

    Kernel Mode.

Revision History:
 
    Mike McCracken (mmccr) 09/17/2001
    
    Prints out free space for a specifed volume

--*/

#include "precomp.h"
#pragma hdrstop

                      
ULONG GetUNICODE_STRING(ULONG64 ul64Address, CHAR *pszBuffer, ULONG ulSize)
{
    ULONG64 ul64Buffer = 0;
    ULONG ulLength = 0;
    ULONG ulBytesRead = 0;
    WCHAR wszLocalBuffer[MAX_PATH + 1] = {0};

    if ((!pszBuffer) || (!ulSize))
    {
        return E_FAIL;
    }

    if (GetFieldValue(ul64Address, "nt!_UNICODE_STRING", 
                      "Length", ulLength))
    {
        dprintf("Cannot get UNICODE_STRING length!\n");
        return E_FAIL;
    }

    if (GetFieldValue(ul64Address, "nt!_UNICODE_STRING", 
                      "Buffer", ul64Buffer))
    {
        dprintf("Cannot get UNICODE_STRING buffer!\n");
        return E_FAIL;
    }
    
    if (!ReadMemory(ul64Buffer, 
               wszLocalBuffer, 
               (ulLength < (MAX_PATH * 2)) ? ulLength : (MAX_PATH * 2),
               &ulBytesRead))
    {
        dprintf("Failed ReadMemory at 0x%I64x!\n", ul64Buffer);
        return E_FAIL;
    }

    wcstombs(pszBuffer, wszLocalBuffer, ulSize);
    
    return S_OK;
}
                      
                      
ULONG64 GetObpRootDirectoryObjectAddress()
{
    ULONG64 ul64Temp = 0;
    ULONG64 ul64ObjRoot = 0;

    //Get the address of the pointer
    GetExpressionEx("nt!ObpRootDirectoryObject", &ul64Temp, NULL);

    //Get the value in the pointer
    ReadPtr(ul64Temp, &ul64ObjRoot);

    return ul64ObjRoot;
}

ULONG GetNumberOfHashBuckets()
{    
    FIELD_INFO Field = {(PUCHAR)"HashBuckets", NULL, 0, DBG_DUMP_FIELD_NO_CALLBACK_REQ , 0, NULL};
    SYM_DUMP_PARAM Sym = {sizeof(SYM_DUMP_PARAM), (PUCHAR)"nt!_OBJECT_DIRECTORY", DBG_DUMP_NO_PRINT, 0,
                            NULL, NULL, NULL, sizeof (Field) / sizeof(FIELD_INFO), &Field};
    
    // Get the size of the HashBuckets member
    if (Ioctl(IG_DUMP_SYMBOL_INFO,
              &Sym,
              sizeof(Sym)))
    {
        dprintf("Failed to get size of HashBuckets!\n");
        return 0;
    }

    return (Field.size / (IsPtr64() ? 8 : 4));
}

ULONG GetObjectTypeName(ULONG64 ul64Object, CHAR *pszTypeName, ULONG ulSize)
{

    ULONG ulTypeNameOffset = 0;
    ULONG ulObjectBodyOffset = 0;
    ULONG64 ul64Type = 0;

    // Get the offset of the object body
    if (GetFieldOffset("nt!_OBJECT_HEADER", "Body", &ulObjectBodyOffset))
    {
        dprintf("Cannot get ObjectBody offset!\n");
        return E_FAIL;
    }
    
    if (GetFieldValue(ul64Object - ulObjectBodyOffset, "nt!_OBJECT_HEADER", "Type", ul64Type))
    {
        dprintf("Failed to get Type value at 0x%I64x!\n", ul64Object);
        return E_FAIL;
    }
    
    if (GetFieldOffset("nt!_OBJECT_TYPE", "Name", &ulTypeNameOffset))
    {
        dprintf("Cannot get TypeName offset!\n");
        return E_FAIL;
    }

    return GetUNICODE_STRING(ul64Type + ulTypeNameOffset, pszTypeName, ulSize);
}

ULONG64 GetObjectChildDirectory(ULONG64 ul64Object)
{
    CHAR szTypeName[MAX_PATH + 1] = {0};
    
    if (GetObjectTypeName(ul64Object, szTypeName, sizeof(szTypeName)))
    {
        return 0;
    }

    if (!_stricmp(szTypeName, "Directory"))
    {        
        return ul64Object;
    }
    return 0;
}

ULONG GetRealDeviceForSymbolicLink(ULONG64 ul64Object, CHAR *pszDevicePath, ULONG ulSize)
{
    CHAR szTypeName[MAX_PATH + 1] = {0};
    ULONG ulLinkTargetOffset = 0;

    if (GetObjectTypeName(ul64Object, szTypeName, sizeof(szTypeName)))
    {
        dprintf("Could not get TypeName for object in GetRealDeviceForSymbolicLink!\n");
        return E_FAIL;
    }

    if (_stricmp(szTypeName, "SymbolicLink"))
    {        
        dprintf("Object in GetRealDeviceForSymbolicLink is a %s\n", szTypeName);
        return E_FAIL;
    }
    
    // Get the offset of the object body
    if (GetFieldOffset("nt!_OBJECT_SYMBOLIC_LINK", "LinkTarget", &ulLinkTargetOffset))
    {
        dprintf("Cannot get LinkTarget offset!\n");
        return E_FAIL;
    }

    return GetUNICODE_STRING(ul64Object + ulLinkTargetOffset, pszDevicePath, ulSize);
}

ULONG64 FindObjectByName(CHAR *ObjectPath, ULONG64 ul64StartPoint)
{
    ULONG64 ul64ObjRoot = ul64StartPoint;  
    ULONG64 ul64DirEntry = 0;

    ULONG ulNumberOfBuckets = 0;
    ULONG ulPointerSize = 4;
    ULONG ulHashOffset = 0;
    ULONG ulObjectBodyOffset = 0;
    ULONG ulNameInfoNameOffset = 0;

    ULONG i = 0;
    CHAR PathCopy[MAX_PATH + 1] = {0};
    CHAR *PathPtr = ObjectPath;

    if (!PathPtr)
    {
        return NULL;
    }
    
    while (PathPtr[0] == '\\')
    {
        PathPtr++;
    }

    //Copy the Path String
    strncpy(PathCopy, PathPtr, min(sizeof(PathCopy)-1, strlen(PathPtr)));

    if (ul64ObjRoot == 0)
    {
        // Get the address of the Root Directory Object
        ul64ObjRoot = GetObpRootDirectoryObjectAddress();
        if (!ul64ObjRoot)
        {
            dprintf("Could not get the address of the ObpRootDirectoryObject!\n");
            return NULL;
        }
    }

    if (ObjectPath[0] == '\0')
    {
        return ul64ObjRoot;
    }

    PathPtr = PathCopy;
    while ((PathPtr[0] != '\\') && (PathPtr[0] != '\0'))
    {
        PathPtr++;
    }
    
    if (PathPtr[0] == '\\')
    {
        PathPtr[0] = '\0';
        PathPtr++;
    }

    //Get the offset of the hashbuckets field in the _OBJECT_DIRECTORY structure
    if (GetFieldOffset("nt!_OBJECT_DIRECTORY", "HashBuckets", &ulHashOffset)) 
    {
        dprintf("Cannot get HashBuckets offset!\n");
        return NULL;
    }

    // Get the pointer size for our architecture
    ulPointerSize = (IsPtr64() ? 8 : 4);

    // Try to dynamically determine the number of HashBuckets in the _OBJECT_DIRECTORY structure
    ulNumberOfBuckets = GetNumberOfHashBuckets();
    if (!ulNumberOfBuckets)
    {
        ulNumberOfBuckets = 37; // From ob.h #define NUMBER_HASH_BUCKETS 37
    }

    // Get the offset of the object body
    if (GetFieldOffset("nt!_OBJECT_HEADER", "Body", &ulObjectBodyOffset))
    {
        dprintf("Cannot get ObjectBody offset!\n");
        return NULL;
    }
    

    // Get the offset of the object body
    if (GetFieldOffset("nt!_OBJECT_HEADER_NAME_INFO", "Name", &ulNameInfoNameOffset))
    {
        dprintf("Cannot get NameInfo Name Offset!\n");
        return NULL;
    }
        
    // Iterate through each bucket
    for (i=0; i < ulNumberOfBuckets; i++)
    {
        // Get the address of each _OBJECT_DIRECTORY_ENTRY in the HashBucket array
        if (ReadPointer(ul64ObjRoot + ulHashOffset + (i * ulPointerSize), &ul64DirEntry))
        {
            while (ul64DirEntry)
            {
                ULONG64 ul64Object = 0;
                ULONG64 ul64Header = 0;
                ULONG64 ul64NameInfo = 0;
                ULONG ulNameInfoOffset = 0;
                CHAR szObjName[MAX_PATH + 1] = {0};
                                
                // Setup to point at our current object \
                // - this is actually a pointer to the body field of the _OBJECT_HEADER Structure 
                if (GetFieldValue(ul64DirEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "Object", ul64Object))
                {
                    dprintf("Failed to get object value at 0x%I64x!\n", ul64DirEntry);
                    break;
                }

                // Find the header for this object by subtracting the body (current) offset
                ul64Header = ul64Object - ulObjectBodyOffset;

                // Get the offset from the top of the header of the NameInfoObject
                if (GetFieldValue(ul64Header, "nt!_OBJECT_HEADER", "NameInfoOffset", ulNameInfoOffset))
                {
                    dprintf("Failed to get NameInfoOffset pointer from objectheader at 0x%I64x!\n", ul64Header);
                    break;
                }

                // If zero the object does not have one
                if (ulNameInfoOffset == 0)
                {
                    break;
                }

                // Set our pointer to point to the _OBJECT_HEADER_NAME_INFO structure
                ul64NameInfo = ul64Header - ulNameInfoOffset;

                // Get the objects name
                if (GetUNICODE_STRING(ul64NameInfo + ulNameInfoNameOffset, szObjName, sizeof(szObjName)))
                {
                    dprintf("Could Not Get Name\n");
                    break;
                }

                if (!_stricmp(PathCopy, szObjName))
                {
                    ULONG64 ul64NextDirectory = 0;
                    
                    if (PathPtr[0] == '\0')
                    {
                        return ul64Object;
                    }

                    ul64NextDirectory = GetObjectChildDirectory(ul64Object);
                    return FindObjectByName(PathPtr, ul64NextDirectory);
                }

                //Get the next _OBJECT_DIRECTORY_ENTRY
                if (GetFieldValue(ul64DirEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "ChainLink", ul64DirEntry))
                {
                    dprintf("Failed to get next object value at 0x%I64x!\n", ul64Object);
                    break;
                }

            }  // while loop
        }   // if statement
    }   // for loop

    return NULL;
}

ULONG64 GetVPBPtrFromDeviceObject(ULONG64 ul64DeviceObject)
{
    ULONG64 ul64VpbPtr = 0;

    // Get the offset from the top of the header of the NameInfoObject
    if (GetFieldValue(ul64DeviceObject, "nt!_DEVICE_OBJECT", "Vpb", ul64VpbPtr))
    {
        dprintf("Failed to get Vbp pointer from DeviceObject at 0x%I64x!\n", ul64DeviceObject);
        return NULL;
    }

    return ul64VpbPtr;
}


ULONG GetDeviceDriverString(ULONG64 ul64Device, CHAR *pszString, ULONG ulSize)
{
    ULONG ulNameOffset = 0;
    ULONG64 ul64Driver = 0;

    if (GetFieldValue(ul64Device, "nt!_DEVICE_OBJECT", "DriverObject", ul64Driver))
    {
        dprintf("Failed to get DriverObject from Device pointer at 0x%I64x!\n", ul64Device);
        return E_FAIL;
    }

    // Get the offset of the DriverName in the _DRIVER_OBJECT
    if (GetFieldOffset("nt!_DRIVER_OBJECT", "DriverName", &ulNameOffset))
    {
        dprintf("Cannot get DriverName offset!\n");
        return E_FAIL;
    }

    return GetUNICODE_STRING(ul64Driver + ulNameOffset, pszString, ulSize);
}


VOID OutputData(ULONG ulBytesPerCluster,
                ULONG64 ul64TotalClusters,
                ULONG64 ul64FreeClusters)
{
    ULONG64 ul64TotalBytes = ul64TotalClusters * ulBytesPerCluster;
    ULONG64 ul64FreeBytes = ul64FreeClusters * ulBytesPerCluster;
    
    dprintf("   Cluster Size %u KB\n", ulBytesPerCluster / 1024);
    dprintf(" Total Clusters %I64u KB\n", ul64TotalClusters);
    dprintf("  Free Clusters %I64u KB\n", ul64FreeClusters);
    dprintf("    Total Space %I64u GB (%I64u KB)\n", 
                    (ul64TotalBytes) / (0x40000000),
                    (ul64TotalBytes) / (0x400));
    
    if (ul64FreeBytes > 0x40000000)
    {
        dprintf("     Free Space %I64f GB (%.2I64u MB)\n", 
                        (float)(ul64FreeBytes) / (0x40000000),
                        (ul64FreeBytes) / (0x100000));
    }
    else if (ul64FreeBytes > 0x100000)
    {
        dprintf("     Free Space %I64f MB (%.2I64u KB)\n", 
                        (float)(ul64FreeBytes) / (0x100000),
                        (ul64FreeBytes) / (0x400));
    }
    else
    {
        dprintf("     Free Space %I64u Bytes\n", ul64FreeBytes);
    }
}

ULONG GetAndOutputNTFSData(CHAR cDriveletter, ULONG64 ul64DevObj)
{
    ULONG ulVCBOffset = 0;
    ULONG ulBytesPerCluster = 0;
    ULONG64 ul64TotalClusters = 0;
    ULONG64 ul64FreeClusters = 0;

    if (GetFieldOffset("ntfs!_VOLUME_DEVICE_OBJECT", "Vcb", &ulVCBOffset))
    {
        dprintf("Cannot get Vcb offset for NTFS Device!\n");
        return E_FAIL;
    }

    if (GetFieldValue(ul64DevObj + ulVCBOffset, "ntfs!_VCB", "BytesPerCluster", ulBytesPerCluster))
    {
        dprintf("Failed to get BytesPerCluster from VCB at 0x%I64x!\n", ul64DevObj + ulVCBOffset);
        return E_FAIL;
    }
    
    if (GetFieldValue(ul64DevObj + ulVCBOffset, "ntfs!_VCB", "TotalClusters", ul64TotalClusters))
    {
        dprintf("Failed to get TotalClusters from VCB at 0x%I64x!\n", ul64DevObj + ulVCBOffset);
        return E_FAIL;
    }
    
    if (GetFieldValue(ul64DevObj + ulVCBOffset, "ntfs!_VCB", "FreeClusters", ul64FreeClusters))
    {
        dprintf("Failed to get FreeClusters from VCB at 0x%I64x!\n", ul64DevObj + ulVCBOffset);
        return E_FAIL;
    }
    
    OutputData(ulBytesPerCluster, ul64TotalClusters, ul64FreeClusters);

    return S_OK;
} 


ULONG GetAndOutputFatData(CHAR cDriveletter, ULONG64 ul64DevObj)
{
    ULONG ulVCBOffset = 0;
    ULONG ulBytesPerSector = 0;
    ULONG ulSectorsPerCluster = 0;
    ULONG64 ul64TotalClusters = 0;
    ULONG64 ul64FreeClusters = 0;

    if (GetFieldOffset("fastfat!_VOLUME_DEVICE_OBJECT", "Vcb", &ulVCBOffset))
    {
        dprintf("Cannot get Vcb offset for FastFat Device!\n");
        return E_FAIL;
    }

    if (GetFieldValue(ul64DevObj + ulVCBOffset, "fastfat!_VCB", "Bpb.BytesPerSector", ulBytesPerSector))
    {
        dprintf("Failed to get BytesPerSector from VCB at 0x%I64x!\n", ul64DevObj + ulVCBOffset);
        return E_FAIL;
    }
    
    if (GetFieldValue(ul64DevObj + ulVCBOffset, "fastfat!_VCB", "Bpb.SectorsPerCluster", ulSectorsPerCluster))
    {
        dprintf("Failed to get SectorsPerCluster from VCB at 0x%I64x!\n", ul64DevObj + ulVCBOffset);
        return E_FAIL;
    }
    
    if (GetFieldValue(ul64DevObj + ulVCBOffset, "fastfat!_VCB", "AllocationSupport.NumberOfClusters", ul64TotalClusters))
    {
        dprintf("Failed to get TotalClusters from VCB at 0x%I64x!\n", ul64DevObj + ulVCBOffset);
        return E_FAIL;
    }
    
    if (GetFieldValue(ul64DevObj + ulVCBOffset, "fastfat!_VCB", "AllocationSupport.NumberOfFreeClusters", ul64FreeClusters))
    {
        dprintf("Failed to get FreeClusters from VCB at 0x%I64x!\n", ul64DevObj + ulVCBOffset);
        return E_FAIL;
    }
    
    OutputData(ulBytesPerSector * ulSectorsPerCluster, ul64TotalClusters, ul64FreeClusters);

    return S_OK;
}

DECLARE_API( diskspace )

/*++

Routine Description:

    Dumps free disk space for the specified volume

Arguments:

    args - The volume letter of the drive on which you want the info

Return Value:

    None

--*/
{    
    ULONG ulReturn = S_OK;
    CHAR cVolume = args[0];
    CHAR szRootPath[MAX_PATH + 1] = {0};
    ULONG64 ul64Drive = 0;
    ULONG64 ul64Vpb = 0;
        
    INIT_API();

    // Make sure we have a valid drive letter as the first character.
    if (((cVolume < 'A') || (cVolume > 'z')) || 
        ((cVolume > 'Z') && (cVolume < 'a'))) 
    {
        dprintf("'%s' is not a valid drive specification!\n", args);
        ulReturn = E_FAIL;
        goto exit;
    }

    // Make sure this is likely to be a valid param in that it is 
    // followed by a space of a colon.
    if ((args[1] != ' ') && (args[1] != ':') && (args[1] != '\0'))
    {
        dprintf("'%s' is not a valid drive specification!\n", args);
        ulReturn = E_FAIL;
        goto exit;
    }

    sprintf(szRootPath, "\\GLOBAL??\\%c:", cVolume);

    dprintf("Checking Free Space for %c: ", cVolume);

    ul64Drive = FindObjectByName(szRootPath, 0);
    if (!ul64Drive)
    {
        dprintf("\nFailed to find volume %c:!\n", cVolume);
        ulReturn = E_FAIL;
        goto exit;
    }

    GetRealDeviceForSymbolicLink(ul64Drive, szRootPath, sizeof(szRootPath));
    if (strstr(_strlwr(szRootPath), "cdrom"))
    {
        dprintf("\n%c: is a CDROM drive.  This function is not supported!\n", cVolume);
        ulReturn = E_FAIL;
        goto exit;
    }
    dprintf(".."); 

    ul64Drive = FindObjectByName(szRootPath, 0);
    dprintf(".."); 
    
    if (GetFieldValue(ul64Drive, "nt!_DEVICE_OBJECT", "Vpb", ul64Vpb))
    {
        dprintf("Failed to get Vbp pointer from DeviceObject at 0x%I64x!\n", ul64Drive);
        ulReturn = E_FAIL;
        goto exit;
    }
    dprintf(".."); 

    if (GetFieldValue(ul64Vpb, "nt!_VPB", "DeviceObject", ul64Drive))
    {
        dprintf("Failed to get DeviceObject from VBP pointer at 0x%I64x!\n", ul64Vpb);
        ulReturn = E_FAIL;
        goto exit;
    }
    dprintf(".."); 


    if (GetDeviceDriverString(ul64Drive, szRootPath, sizeof(szRootPath)))
    {
        dprintf("Failed to Get Driver String From Device at 0x%I64x!\n", ul64Drive);
        ulReturn = E_FAIL;
        goto exit;
    }    
    dprintf("..\n"); 

    if (strstr(_strlwr(szRootPath), "ntfs"))
    {
        GetAndOutputNTFSData(cVolume, ul64Drive);
    }
    else if (strstr(_strlwr(szRootPath), "fastfat"))
    {
        GetAndOutputFatData(cVolume, ul64Drive);
    }
    else if (strstr(_strlwr(szRootPath), "cdfs"))
    {
        dprintf("This extension does not support the cdfs filesystem!\n"); 
    }
    else
    {
        dprintf("Unable to determine Volume Type for %s!\n", szRootPath); 
    }    
    
exit:

    EXIT_API();

    return ulReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\kextfn.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    kextfn.h

Abstract:


Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 3/5/2001

--*/

#ifndef _KEXTFN_H
#define _KEXTFN_H
#endif // _KEXTFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\verifier.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    verifier.c

Abstract:

    Application verifier debugger extension for both ntsd and kd.

Author:

    Silviu Calinoiu (SilviuC) 4-Mar-2001

Environment:

    User Mode.

--*/

#include "precomp.h"
#pragma hdrstop

//
// Page heap extension functions (defined in heappagx.c and heappagxXP.c). 
// We need one for WinXP client and one for latest .NET server because the internal 
// structures changed significantly and there are not separate debugger packages 
// for each OS. We have this problem only for stuff implemented inside ntdll.dll
// since the dll is different between OSes. We do nto have this problem for
// verifier.dll because this one is refreshed whenever the application verifier
// package is installed.
//

VOID
PageHeapExtension(
    IN PCSTR lpArgumentString
    );

VOID
DebugPageHeapExtensionXP(
    IN PCSTR lpArgumentString
    );

//
// Local functions
//

ULONG
VrfGetArguments (
    PCHAR ArgsString,
    PCHAR Args[],
    ULONG NoOfArgs
    );

VOID
VrfHelp (
    VOID
    );

BOOLEAN
VrfTraceInitialize (
    );

ULONG64
VrfTraceAddress ( 
    ULONG TraceIndex
    );

VOID
VrfTraceDump (
    ULONG TraceIndex
    );

LOGICAL
VrfVerifierGlobalFlagSet (
    VOID
    );

VOID
VrfDumpSettings (
    );

VOID
VrfDumpStopInformation (
    VOID
    );

VOID
VrfFigureOutAddress (
    ULONG64 Address
    );

VOID
VrfDumpGlobalCounters (
    VOID
    );

VOID
VrfDumpBreakTriggers (
    VOID
    );

VOID
VrfToggleBreakTrigger (
    ULONG Index
    );

VOID
VrfDumpFaultInjectionSettings (
    VOID
    );

VOID
VrfSetFaultInjectionParameters (
    ULONG Index,
    ULONG Probability
    );

VOID
VrfSetFaultInjectionCallParameters (
    ULONG Index,
    ULONG Call
    );

VOID
VrfDumpFaultInjectionTargetRanges (
    VOID
    );

VOID
VrfAddFaultInjectionTargetRange (
    ULONG64 Start,
    ULONG64 End
    );

VOID
VrfResetFaultInjectionTargetRanges (
    VOID
    );

VOID
VrfDumpFaultInjectionExclusionRanges (
    VOID
    );

VOID
VrfAddFaultInjectionExclusionRange (
    ULONG64 Start,
    ULONG64 End
    );

VOID
VrfResetFaultInjectionExclusionRanges (
    VOID
    );

VOID
VrfSetFaultInjectionExclusionPeriod (
    ULONG64 TimeInMsecs
    );

VOID
VrfDumpFaultInjectionTraces (
    ULONG Count
    );

VOID
VrfToggleFaultInjectionBreak (
    ULONG Index
    );

VOID
VrfSetFaultInjectionDllTarget (
    PCHAR DllName,
    LOGICAL Exclude
    );

VOID
VrfDumpExceptionLog (
    ULONG MaxEntries
    );

VOID
VrfDumpThreadsInformation (
    ULONG64 UserThreadId
    );

LOGICAL
VrfCheckSymbols (
    PCHAR * DllName
    );

//
// Globals.
//

LOGICAL WinXpClient;

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// Call tracker querying
/////////////////////////////////////////////////////////////////////

extern ULONG64 VrfThreadTrackerAddress;
extern ULONG64 VrfHeapTrackerAddress;
extern ULONG64 VrfVspaceTrackerAddress;

LOGICAL
VrfDetectTrackerAddresses (
    VOID
    );

LOGICAL
VrfQueryCallTracker (
    ULONG64 TrackerAddress,
    ULONG64 SearchAddress,
    ULONG64 LastEntries
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// !avrf entry point
/////////////////////////////////////////////////////////////////////

DECLARE_API( avrf )
/*++

Routine Description:

    Application verifier debugger extension. 

Arguments:

    args - 

Return Value:

    None

--*/
{
    PCHAR Args[16];
    ULONG NoOfArgs, I;
    PCHAR DllName;

    INIT_API();

    if (g_TargetBuild <= 2600) {
        WinXpClient = TRUE;
    }

    //
    // Check out the symbols.
    //

    if (VrfCheckSymbols(&DllName) == FALSE) {

        if (DllName) {
            dprintf ("Please fix the symbols for `%s'.\n", DllName);
        }
        
        return S_OK;
    }

    //
    // Parse arguments.
    //

    NoOfArgs = VrfGetArguments ((PCHAR)args,
                                Args,
                                16);

    //
    // Check if help needed
    //

    if (NoOfArgs > 0 && strstr (Args[0], "?") != NULL) {
        VrfHelp ();
        goto Exit;
    }

    if (NoOfArgs > 0 && _stricmp (Args[0], "-cnt") == 0) {
        
        VrfDumpGlobalCounters ();

        goto Exit;
    }
    
    if (NoOfArgs > 0 && _stricmp (Args[0], "-brk") == 0) {
        
        if (NoOfArgs > 1) {
            
            ULONG64 Index;
            BOOL Result;
            PCSTR Remainder;

            Result = GetExpressionEx (Args[1], &Index, &Remainder);

            if (Result == FALSE) {
                dprintf ("\nFailed to convert `%s' to an index.\n", Args[1]);
                goto Exit;
            }

            VrfToggleBreakTrigger ((ULONG)Index);
        }
        else {

            VrfDumpBreakTriggers ();
        }

        goto Exit;
    }
    
    if (NoOfArgs > 0 && _stricmp (Args[0], "-flt") == 0) {
        
        if (NoOfArgs == 1) {
            
            VrfDumpFaultInjectionSettings ();
        }
        else if (NoOfArgs == 3){

            if (_stricmp(Args[1], "stacks") == 0) {

                ULONG64 Count;
                BOOL Result;
                PCSTR Remainder;

                Result = GetExpressionEx (Args[2], &Count, &Remainder);

                if (Result == FALSE) {
                    dprintf ("\nFailed to convert `%s' to a number.\n", Args[2]);
                    goto Exit;
                }

                VrfDumpFaultInjectionTraces ((ULONG)Count);
            }
            else if (_stricmp(Args[1], "break") == 0) {

                ULONG64 Count;
                BOOL Result;
                PCSTR Remainder;

                Result = GetExpressionEx (Args[2], &Count, &Remainder);

                if (Result == FALSE) {
                    dprintf ("\nFailed to convert `%s' to an index.\n", Args[2]);
                    goto Exit;
                }

                VrfToggleFaultInjectionBreak ((ULONG)Count);
            }
            else {

                ULONG64 Index;
                ULONG64 Probability;
                BOOL Result;
                PCSTR Remainder;

                Result = GetExpressionEx (Args[1], &Index, &Remainder);

                if (Result == FALSE) {
                    dprintf ("\nFailed to convert `%s' to an index.\n", Args[1]);
                    goto Exit;
                }

                Result = GetExpressionEx (Args[2], &Probability, &Remainder);

                if (Result == FALSE) {
                    dprintf ("\nFailed to convert `%s' to a probability.\n", Args[2]);
                    goto Exit;
                }

                VrfSetFaultInjectionParameters ((ULONG)Index,
                                                (ULONG)Probability);
            }
        }

        goto Exit;
    }
    
    if (NoOfArgs > 0 && _stricmp (Args[0], "-trg") == 0) {
        
        if (NoOfArgs > 1) {
            
            if (_stricmp(Args[1], "all") == 0) {
                
                VrfResetFaultInjectionTargetRanges ();
            }
            else if (NoOfArgs == 3 && _stricmp(Args[1], "dll") == 0) {
                
                VrfSetFaultInjectionDllTarget (Args[2], FALSE);
            }
            else if (NoOfArgs > 2){

                ULONG64 Start;
                ULONG64 End;
                BOOL Result;
                PCSTR Remainder;

                Result = GetExpressionEx (Args[1], &Start, &Remainder);

                if (Result == FALSE) {
                    dprintf ("\nFailed to convert `%s' to a start address.\n", Args[1]);
                    goto Exit;
                }

                Result = GetExpressionEx (Args[2], &End, &Remainder);

                if (Result == FALSE) {
                    dprintf ("\nFailed to convert `%s' to an end address.\n", Args[2]);
                    goto Exit;
                }

                VrfAddFaultInjectionTargetRange (Start, End);
            }
        }
        else {

            VrfDumpFaultInjectionTargetRanges ();
        }

        goto Exit;
    }
    
    if (NoOfArgs > 0 && _stricmp (Args[0], "-skp") == 0) {
        
        if (NoOfArgs > 1) {
            
            if (_stricmp(Args[1], "all") == 0) {
                
                VrfResetFaultInjectionExclusionRanges ();
            }
            else if (NoOfArgs == 3 && _stricmp(Args[1], "dll") == 0) {
                
                VrfSetFaultInjectionDllTarget (Args[2], TRUE);
            }
            else if (NoOfArgs == 2) {
                
                ULONG64 Period;
                BOOL Result;
                PCSTR Remainder;

                Result = GetExpressionEx (Args[1], &Period, &Remainder);

                if (Result == FALSE) {
                    dprintf ("\nFailed to convert `%s' to a number.\n", Args[1]);
                    goto Exit;
                }

                VrfSetFaultInjectionExclusionPeriod (Period);
            }
            else if (NoOfArgs > 2){

                ULONG64 Start;
                ULONG64 End;
                BOOL Result;
                PCSTR Remainder;

                Result = GetExpressionEx (Args[1], &Start, &Remainder);

                if (Result == FALSE) {
                    dprintf ("\nFailed to convert `%s' to a start address.\n", Args[1]);
                    goto Exit;
                }

                Result = GetExpressionEx (Args[2], &End, &Remainder);

                if (Result == FALSE) {
                    dprintf ("\nFailed to convert `%s' to an end address.\n", Args[2]);
                    goto Exit;
                }

                VrfAddFaultInjectionExclusionRange (Start, End);
            }
        }
        else {

            VrfDumpFaultInjectionExclusionRanges ();
        }

        goto Exit;
    }
    
    if (NoOfArgs > 0 && _stricmp (Args[0], "-ex") == 0) {

        ULONG MaxEntries;

        if (NoOfArgs > 1) {

            MaxEntries = atoi (Args[1]);
        }
        else {

            MaxEntries = (ULONG)-1;
        }

        VrfDumpExceptionLog (MaxEntries);
        goto Exit;
    }
    
    if (NoOfArgs > 0 && _stricmp (Args[0], "-threads") == 0) {

        ULONG64 ThreadId;

        if (NoOfArgs > 1) {

            BOOL Result;
            PCSTR Remainder;

            Result = GetExpressionEx (Args[1], &ThreadId, &Remainder);
        }
        else {

            ThreadId = 0;
        }

        VrfDumpThreadsInformation (ThreadId);
        goto Exit;
    }

    //
    // The rest of the options need traces support.
    //

    if (VrfTraceInitialize() == FALSE) {
        goto DumpAndExit;
    }

    if (NoOfArgs > 1 && _stricmp (Args[0], "-trace") == 0) {
        
        ULONG Index;

        Index = (ULONG) GetExpression (Args[1]);

        if (Index != 0) {
            VrfTraceDump (Index);
        }
        else {
            dprintf ("Invalid trace index: `%s' . \n", Args[1]);
        }
        
        goto Exit;
    }
    
    if (NoOfArgs > 1 && _stricmp (Args[0], "-a") == 0) {

        ULONG64 Address;
        BOOL Result;
        PCSTR Remainder;

        Result = GetExpressionEx (Args[1], &Address, &Remainder);

        if (Result == FALSE) {
            dprintf ("\nFailed to convert `%s' to an address.\n", Args[1]);
            goto Exit;
        }

        dprintf ("Address %I64X ...\n\n", Address);
        
        VrfFigureOutAddress (Address);

        goto Exit;
    }
    
    if (NoOfArgs > 1 && _stricmp (Args[0], "-vs") == 0) {

        if (NoOfArgs > 2 && _stricmp (Args[1], "-a") == 0) {

            ULONG64 Address;
            BOOL Result;
            PCSTR Remainder;

            Result = GetExpressionEx (Args[2], &Address, &Remainder);

            if (Result == FALSE) {
                dprintf ("\nFailed to convert `%s' to an address.\n", Args[2]);
                goto Exit;
            }

            VrfQueryCallTracker (VrfVspaceTrackerAddress, Address, 0);
            goto Exit;
        }
        else {

            VrfQueryCallTracker (VrfVspaceTrackerAddress, 0, atoi(Args[1]));
            goto Exit;
        }
    }
    
    if (NoOfArgs > 1 && _stricmp (Args[0], "-hp") == 0) {

        if (NoOfArgs > 2 && _stricmp (Args[1], "-a") == 0) {

            ULONG64 Address;
            BOOL Result;
            PCSTR Remainder;

            Result = GetExpressionEx (Args[2], &Address, &Remainder);

            if (Result == FALSE) {
                dprintf ("\nFailed to convert `%s' to an address.\n", Args[2]);
                goto Exit;
            }

            VrfQueryCallTracker (VrfHeapTrackerAddress, Address, 0);
            goto Exit;
        }
        else {

            VrfQueryCallTracker (VrfHeapTrackerAddress, 0, atoi(Args[1]));
            goto Exit;
        }
    }

    if (NoOfArgs > 0 && _stricmp (Args[0], "-trm") == 0) {
        
        VrfQueryCallTracker (VrfThreadTrackerAddress, 0, 32);
        goto Exit;
    }
    
    //
    // If no option specified then we just print current settings.
    //

DumpAndExit:

    VrfDumpSettings ();

Exit:

    EXIT_API();
    return S_OK;
}


VOID
VrfHelp (
    VOID
    )
{
    dprintf ("Application verifier debugger extension                        \n"
             "                                                               \n"
             "!avrf                 displays current settings and stop       \n"
             "                      data if a verifier stop happened.        \n"
             // "!avrf -a ADDR        figure out the nature of address ADDR. \n"
             "!avrf -vs N           dump last N entries from vspace log.     \n"
             "!avrf -vs -a ADDR     searches ADDR in the vspace log.         \n"
             "!avrf -hp N           dump last N entries from heap log.       \n"
             "!avrf -hp -a ADDR     searches ADDR in the heap log.           \n"
             "!avrf -trm            dump thread terminate/suspend log.       \n"
             "!avrf -ex [N]         dump exception log entries.              \n"
             "!avrf -threads [TID]  dump threads information.                \n"
             "!avrf -trace INDEX    dump stack trace with index INDEX.       \n"
             "!avrf -cnt            dump global counters.                    \n"
             "!avrf -brk [INDEX]    dump or set/reset break triggers.        \n"
             "!avrf -flt            dump fault injection settings.           \n"
             "!avrf -flt INDX PROB  set fault probability for an event.      \n"
             "!avrf -flt break INDX toggle break for a fault injection event.\n"
             "!avrf -flt stacks N   dump the last N fault injection stacks.  \n"
             "!avrf -trg            dump fault injection target addresses.   \n"
             "!avrf -trg START END  add a new fault target range.            \n"
             "!avrf -trg dll XXX    add code in dll XXX as target range.     \n"
             "!avrf -trg all        deletes all fault target ranges.         \n"
             "!avrf -skp            dump fault injection exclusion addresses.\n"
             "!avrf -skp START END  add a new fault exclusion range.         \n"
             "!avrf -skp dll XXX    add code in dll XXX as exclusion range.  \n"
             "!avrf -skp all        deletes all fault exclusion ranges.      \n"
             "!avrf -skp TIME       disable faults for TIME msecs.           \n"
             "                                                               \n");
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// Argument parsing routines
/////////////////////////////////////////////////////////////////////

PCHAR 
VrfGetArgument (
    PCHAR Args,
    PCHAR * Next
    )
{
    PCHAR Start;

    if (Args == NULL) {
        return NULL;
    }

    while (*Args == ' ' || *Args == '\t') {
        Args += 1;
    }

    if (*Args == '\0') {
        return NULL;
    }

    Start = Args;

    while (*Args != ' ' && *Args != '\t' && *Args != '\0') {
        Args += 1;
    }

    if (*Args == '\0') {
        *Next = NULL;
    }
    else {
        *Args = '\0';
        *Next = Args + 1;
    }

    return Start;
}

ULONG
VrfGetArguments (
    PCHAR ArgsString,
    PCHAR Args[],
    ULONG NoOfArgs
    )
{
    PCHAR Arg = ArgsString;
    PCHAR Next;
    ULONG Index;
    
    for (Index = 0; Index < NoOfArgs; Index += 1) {

        Arg = VrfGetArgument (Arg, &Next);

        if (Arg) {
            Args[Index] = Arg;
        }
        else {
            break;
        }

        Arg = Next;
    }

    return Index;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Dump stack traces
/////////////////////////////////////////////////////////////////////

ULONG64 TraceDbArrayEnd;
ULONG PvoidSize;

BOOLEAN
VrfTraceInitialize (
    )
{
    ULONG64 TraceDatabaseAddress;
    ULONG64 TraceDatabase;

    //
    // Stack trace database address
    //

    TraceDatabaseAddress = GetExpression("ntdll!RtlpStackTraceDataBase");
    
    if ( TraceDatabaseAddress == 0 ) {
        dprintf( "Unable to resolve ntdll!RtlpStackTraceDataBase symbolic name.\n");
        return FALSE;
    }

    if (!ReadPointer (TraceDatabaseAddress, &TraceDatabase ) != S_OK) {
        dprintf( "Cannot read pointer at ntdll!RtlpStackTraceDataBase\n" );
        return FALSE;
    }

    if (TraceDatabase == 0) {
        dprintf( "Stack traces not enabled (ntdll!RtlpStackTraceDataBase is null).\n" );
        return FALSE;
    }

    //
    // Find the array of stack traces
    //

    if (InitTypeRead(TraceDatabase, ntdll!_STACK_TRACE_DATABASE)) {
        dprintf("Unable to read type ntdll!_STACK_TRACE_DATABASE @ %p\n", TraceDatabase);
        return FALSE;
    }

    TraceDbArrayEnd = ReadField (EntryIndexArray);

    PvoidSize = IsPtr64() ? 8 : 4;

    return TRUE;
}


ULONG64
VrfTraceAddress ( 
    ULONG TraceIndex
    )
{
    ULONG64 TracePointerAddress;
    ULONG64 TracePointer;

    TracePointerAddress = TraceDbArrayEnd - TraceIndex * PvoidSize;

    if (!ReadPointer (TracePointerAddress, &TracePointer) != S_OK) {
        dprintf ("Cannot read stack trace address @ %p\n", TracePointerAddress);
        return 0;
    }

    return TracePointer;
}

VOID
VrfTraceDump (
    ULONG TraceIndex
    )
{
    ULONG64 TraceAddress;
    ULONG64 TraceArray;
    ULONG TraceDepth;
    ULONG Offset;
    ULONG Index;
    ULONG64 ReturnAddress;
    CHAR Symbol[ 1024 ];
    ULONG64 Displacement;

    //
    // Get real address of the trace.
    //

    TraceAddress = VrfTraceAddress (TraceIndex);

    if (TraceAddress == 0) {
        return;
    }

    //
    // Read the stack trace depth
    //

    if (InitTypeRead(TraceAddress, ntdll!_RTL_STACK_TRACE_ENTRY)) {
        dprintf("Unable to read type ntdll!_RTL_STACK_TRACE_ENTRY @ %p\n", TraceAddress);
        return;
    }

    TraceDepth = (ULONG)ReadField (Depth);

    //
    // Limit the depth to 20 to protect ourselves from corrupted data
    //

    TraceDepth = __min (TraceDepth, 16);

    //
    // Get a pointer to the BackTrace array
    //

    GetFieldOffset ("ntdll!_RTL_STACK_TRACE_ENTRY", "BackTrace", &Offset);
    TraceArray = TraceAddress + Offset;

    //
    // Dump this stack trace. Skip first two entries.
    //

    TraceArray += 2 * PvoidSize;

    for (Index = 2; Index < TraceDepth; Index += 1) {

        if (!ReadPointer (TraceArray, &ReturnAddress) != S_OK) {
            dprintf ("Cannot read address @ %p\n", TraceArray);
            return;
        }

        GetSymbol (ReturnAddress, Symbol, &Displacement);

        dprintf ("\t%p: %s+0x%I64X\n",
                 ReturnAddress,
                 Symbol,
                 Displacement );

        TraceArray += PvoidSize;
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Dump settings
/////////////////////////////////////////////////////////////////////

ULONG64 
VrfPebAddress (
    VOID
    )
{
    ULONG64 PebAddress;
    
    GetPebAddress (0, &PebAddress);
    // dprintf ("PEB @ %I64X \n", PebAddress);

    return PebAddress;
}


LOGICAL
VrfVerifierGlobalFlagSet (
    VOID
    )
{
    ULONG64 FlagsAddress;
    ULONG Flags;
    ULONG BytesRead;
    ULONG I;
    ULONG64 GlobalFlags;

    InitTypeRead (VrfPebAddress(), ntdll!_PEB);
    GlobalFlags = ReadField (NtGlobalFlag);

    if ((GlobalFlags & FLG_APPLICATION_VERIFIER)) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


VOID
VrfDumpSettings (
    )
{
    ULONG64 FlagsAddress;
    ULONG Flags;
    ULONG BytesRead;
    ULONG I;
    ULONG64 GlobalFlags;

    InitTypeRead (VrfPebAddress(), ntdll!_PEB);
    GlobalFlags = ReadField (NtGlobalFlag);

    dprintf ("\nGlobal flags: %08I64X \n", GlobalFlags);

    if ((GlobalFlags & FLG_APPLICATION_VERIFIER)) {
        dprintf ("Application verifier global flag is set. \n");
    }
    
    if ((GlobalFlags & FLG_HEAP_PAGE_ALLOCS)) {
        dprintf ("Page heap global flag is set. \n");
    }
    
    dprintf ("\n");

    if ((GlobalFlags & FLG_APPLICATION_VERIFIER) == 0) {
        
        dprintf ("Application verifier is not enabled for this process. \n");
        
        if ((GlobalFlags & FLG_HEAP_PAGE_ALLOCS)) {

            dprintf ("Page heap has been enabled separately. \n");
        }
        
        return;
    }

    FlagsAddress = GetExpression("ntdll!AVrfpVerifierFlags");

    if (FlagsAddress == 0) {
        dprintf( "Unable to resolve ntdll!AVrfpVerifierFlags symbolic name.\n");
        return;
    }

    if (ReadMemory (FlagsAddress, &Flags, sizeof Flags, &BytesRead) == FALSE) {
        dprintf ("Cannot read value @ %p (ntdll!AVrfpVerifierFlags) \n", FlagsAddress);
        return;
    }

    dprintf ("Application verifier settings (%08X): \n\n", Flags);

    if (WinXpClient) {
        
        //
        // On XP client no heap checks actually means light page heap.
        //

        if (Flags & RTL_VRF_FLG_FULL_PAGE_HEAP) {
            dprintf ("   - full page heap\n");
        }
        else {
            dprintf ("   - light page heap\n");
        }
    }
    else {

        //
        // On .NET server no heap checks really means no heap checks.
        //

        if (Flags & RTL_VRF_FLG_FULL_PAGE_HEAP) {
            dprintf ("   - full page heap\n");
        }
        else if (Flags & RTL_VRF_FLG_FAST_FILL_HEAP) {
            dprintf ("   - fast fill heap (a.k.a light page heap)\n");
        }
        else {
            dprintf ("   - no heap checking enabled!\n");
        }
    }
           
    if (Flags & RTL_VRF_FLG_LOCK_CHECKS) {
        dprintf ("   - lock checks (critical section verifier)\n");
    }
    if (Flags & RTL_VRF_FLG_HANDLE_CHECKS) {
        dprintf ("   - handle checks\n");
    }
    if (Flags & RTL_VRF_FLG_STACK_CHECKS) {
        dprintf ("   - stack checks (disable automatic stack extensions)\n");
    }
    if (Flags & RTL_VRF_FLG_TLS_CHECKS) {
        dprintf ("   - TLS checks (thread local storage APIs)\n");
    }
    if (Flags & RTL_VRF_FLG_RPC_CHECKS) {
        dprintf ("   - RPC checks (RPC verifier)\n");
    }
    if (Flags & RTL_VRF_FLG_COM_CHECKS) {
        dprintf ("   - COM checks (COM verifier)\n");
    }
    if (Flags & RTL_VRF_FLG_DANGEROUS_APIS) {
        dprintf ("   - bad APIs (e.g. TerminateThread)\n");
    }
    if (Flags & RTL_VRF_FLG_RACE_CHECKS) {
        dprintf ("   - random delays for wait operations\n");
    }
    if (Flags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS) {
        dprintf ("   - virtual memory operations checks\n");
    }
    if (Flags & RTL_VRF_FLG_DEADLOCK_CHECKS) {
        dprintf ("   - deadlock verifier\n");
    }

    dprintf ("\n");

    //
    // Call the appropriate page heap extension.
    //

    if (WinXpClient) {
        DebugPageHeapExtensionXP ("-p");
    }
    else {
        PageHeapExtension ("-p");
    }

    dprintf ("\n");
    
    //
    // Dump verifier stop information if there is any.
    //
      
    VrfDumpStopInformation ();
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////// Stop data
/////////////////////////////////////////////////////////////////////

VOID
VrfDumpBriefStopDescription (
    ULONG64 Code
    );

VOID
VrfDumpStopInformation (
    VOID
    )
{
    ULONG64 CurrentStopAddress;
    ULONG64 CurrentStopData[5];
    ULONG64 PreviousStopAddress;
    ULONG64 PreviousStopData[5];
    ULONG I;
    ULONG UlongPtrSize;

    UlongPtrSize = GetTypeSize ("ntdll!ULONG_PTR");
    
    //
    // Check if a verifier stop has been encountered.
    //

    CurrentStopAddress = GetExpression("verifier!AVrfpStopData");
    
    if (CurrentStopAddress == 0) {
        dprintf( "Unable to resolve verifier!AVrfpStopData symbolic name.\n");
        return;
    }

    for (I = 0; I < 5; I += 1) {

        if (!ReadPointer (CurrentStopAddress + I * UlongPtrSize, &(CurrentStopData[I])) != S_OK) {
            dprintf ("Cannot read value @ %p \n", CurrentStopAddress + I * UlongPtrSize);
        }
    }

    //
    // Read also previous stop data.
    //

    PreviousStopAddress = GetExpression("verifier!AVrfpPreviousStopData");
    
    if (PreviousStopAddress == 0) {
        dprintf( "Unable to resolve verifier!AVrfpPreviousStopData symbolic name.\n");
        return;
    }

    for (I = 0; I < 5; I += 1) {

        if (!ReadPointer (PreviousStopAddress + I * UlongPtrSize, &(PreviousStopData[I])) != S_OK) {
            dprintf ("Cannot read value @ %p \n", PreviousStopAddress + I * UlongPtrSize);
        }
    }

    //
    // Parse the values just read.
    //

    if (PreviousStopData[0] != 0) {

        dprintf ("Previous stop %p : %p %p %p %p was continued! \n", 
                 PreviousStopData[0],
                 PreviousStopData[1],
                 PreviousStopData[2],
                 PreviousStopData[3],
                 PreviousStopData[4]);

        dprintf ("\n    ");
        VrfDumpBriefStopDescription (PreviousStopData[0]);
        dprintf ("\n");
    }

    if (CurrentStopData[0] == 0) {

        dprintf ("No verifier stop active. \n\n");

        dprintf ("Note. Sometimes bugs found by verifier manifest themselves \n"
                 "as raised exceptions (access violations, stack overflows, invalid handles \n"
                 "and it is not always necessary to have a verifier stop. \n");
    }
    else {

        dprintf ("Current stop %p : %p %p %p %p . \n", 
                 CurrentStopData[0],
                 CurrentStopData[1],
                 CurrentStopData[2],
                 CurrentStopData[3],
                 CurrentStopData[4]);
        
        dprintf ("\n    ");
        VrfDumpBriefStopDescription (CurrentStopData[0]);
        dprintf ("\n");
    }
}


VOID
VrfDumpBriefStopDescription (
    ULONG64 Code
    )
{
    switch (Code) {
        case APPLICATION_VERIFIER_UNKNOWN_ERROR:
            dprintf ("Unknown error. \n");
            break;
        case APPLICATION_VERIFIER_ACCESS_VIOLATION:
            dprintf ("Access violation. \n");
            break;
        case APPLICATION_VERIFIER_UNSYNCHRONIZED_ACCESS:
            dprintf ("Unsynchronized access. \n");
            break;
        case APPLICATION_VERIFIER_EXTREME_SIZE_REQUEST:
            dprintf ("Extreme size request. \n");
            break;
        case APPLICATION_VERIFIER_BAD_HEAP_HANDLE:
            dprintf ("Bad heap handle (not even handle of another heap). \n");
            break;
        case APPLICATION_VERIFIER_SWITCHED_HEAP_HANDLE:
            dprintf ("Switched heap handle. \n");
            break;
        case APPLICATION_VERIFIER_DOUBLE_FREE:
            dprintf ("Double free. \n");
            break;
        case APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK:
            dprintf ("Corrupted heap block. \n");
            break;
        case APPLICATION_VERIFIER_DESTROY_PROCESS_HEAP:
            dprintf ("Attempt to destroy process heap. \n");
            break;
        case APPLICATION_VERIFIER_UNEXPECTED_EXCEPTION:
            dprintf ("Unexpected exception inside page heap code. \n");
            break;
        case APPLICATION_VERIFIER_STACK_OVERFLOW:
            dprintf ("Stack overflow. \n");
            break;
        
        case APPLICATION_VERIFIER_INVALID_FREEMEM:
            dprintf ("Invalid free memory. \n");
            break;
        case APPLICATION_VERIFIER_INVALID_ALLOCMEM:
            dprintf ("Invalid memory allocation. \n");
            break;
        case APPLICATION_VERIFIER_INVALID_MAPVIEW:
            dprintf ("Invalid memory mapping. \n");
            break;
        
        case APPLICATION_VERIFIER_TERMINATE_THREAD_CALL:
            dprintf ("TerminateThread() call. \n");
            break;
        case APPLICATION_VERIFIER_INVALID_EXIT_PROCESS_CALL:
            dprintf ("ExitProcess() call while multiple threads still running. \n");
            break;

        case APPLICATION_VERIFIER_EXIT_THREAD_OWNS_LOCK:
            dprintf ("Threads owns lock in a context it should not. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_IN_UNLOADED_DLL:
            dprintf ("DLL unloaded contains a critical section that was not deleted. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_IN_FREED_HEAP:
            dprintf ("Block freed contains a critical section that was not deleted. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_IN_FREED_MEMORY:
            dprintf ("Virtual region freed contains a critical section that was not deleted. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_DOUBLE_INITIALIZE:
            dprintf ("Critical section initialized twice. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_CORRUPTED:
            dprintf ("Corrupted critical section. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_INVALID_OWNER:
            dprintf ("Critical section has invalid owner. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_INVALID_RECURSION_COUNT:
            dprintf ("Critical section has invalid recursion count. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_INVALID_LOCK_COUNT:
            dprintf ("Critical section has invalid lock count. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_OVER_RELEASED:
            dprintf ("Releasing a critical section that is not acquired. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_NOT_INITIALIZED:
            dprintf ("Using an uninitialized critical section. \n");
            break;
        case APPLICATION_VERIFIER_LOCK_ALREADY_INITIALIZED:
            dprintf ("Initializing a critical section already initialized. \n");
            break;
        case APPLICATION_VERIFIER_INVALID_HANDLE:
            dprintf ("Using an invalid handle (either closed or simply bad). \n");
            break;
        case APPLICATION_VERIFIER_INVALID_TLS_VALUE:
            dprintf ("Using an invalid TLS value (not obtained from TlsAlloc()). \n");
            break;

        case APPLICATION_VERIFIER_INCORRECT_WAIT_CALL:
            dprintf ("Wait call with invalid parameters. \n");
            break;
        case APPLICATION_VERIFIER_NULL_HANDLE:
            dprintf ("Using a null handle. \n");
            break;
        case APPLICATION_VERIFIER_WAIT_IN_DLLMAIN:
            dprintf ("Wait operation in DllMain function. \n");
            break;
        
        case APPLICATION_VERIFIER_COM_ERROR:
            dprintf ("COM related error. \n");
            break;
        case APPLICATION_VERIFIER_COM_API_IN_DLLMAIN:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_API_IN_DLLMAIN \n");
            break;
        case APPLICATION_VERIFIER_COM_UNHANDLED_EXCEPTION:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_UNHANDLED_EXCEPTION \n");
            break;
        case APPLICATION_VERIFIER_COM_UNBALANCED_COINIT:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_UNBALANCED_COINIT \n");
            break;
        case APPLICATION_VERIFIER_COM_UNBALANCED_OLEINIT:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_UNBALANCED_OLEINIT \n");
            break;
        case APPLICATION_VERIFIER_COM_UNBALANCED_SWC:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_UNBALANCED_SWC \n");
            break;
        case APPLICATION_VERIFIER_COM_NULL_DACL:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_NULL_DACL \n");
            break;
        case APPLICATION_VERIFIER_COM_UNSAFE_IMPERSONATION:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_UNSAFE_IMPERSONATION\n");
            break;
        case APPLICATION_VERIFIER_COM_SMUGGLED_WRAPPER:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_SMUGGLED_WRAPPER \n");
            break;
        case APPLICATION_VERIFIER_COM_SMUGGLED_PROXY:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_SMUGGLED_PROXY \n");
            break;
        case APPLICATION_VERIFIER_COM_CF_SUCCESS_WITH_NULL:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_CF_SUCCESS_WITH_NULL \n");
            break;
        case APPLICATION_VERIFIER_COM_GCO_SUCCESS_WITH_NULL:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_GCO_SUCCESS_WITH_NULL \n");
            break;
        case APPLICATION_VERIFIER_COM_OBJECT_IN_FREED_MEMORY:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_OBJECT_IN_FREED_MEMORY \n");
            break;
        case APPLICATION_VERIFIER_COM_OBJECT_IN_UNLOADED_DLL:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_OBJECT_IN_UNLOADED_DLL \n");
            break;
        case APPLICATION_VERIFIER_COM_VTBL_IN_FREED_MEMORY:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_VTBL_IN_FREED_MEMORY \n");
            break;
        case APPLICATION_VERIFIER_COM_VTBL_IN_UNLOADED_DLL:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_VTBL_IN_UNLOADED_DLL \n");
            break;
        case APPLICATION_VERIFIER_COM_HOLDING_LOCKS_ON_CALL:
            dprintf ("COM error: APPLICATION_VERIFIER_COM_HOLDING_LOCKS_ON_CALL \n");
            break;
        
        case APPLICATION_VERIFIER_RPC_ERROR:
            dprintf ("RPC related error. \n");
            break;
        
        default:
            dprintf ("UNRECOGNIZED STOP CODE! \n");
            break;
    }
}





/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Nature of address
/////////////////////////////////////////////////////////////////////

//
// Definitions from \nt\base\ntos\rtl\heappagi.h
//

#define DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED   0xABCDAAAA
#define DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED     0xDCBAAAAA

#define DPH_PAGE_BLOCK_START_STAMP_ALLOCATED     0xABCDBBBB
#define DPH_PAGE_BLOCK_END_STAMP_ALLOCATED       0xDCBABBBB

#define DPH_NORMAL_BLOCK_SUFFIX         0xA0
#define DPH_PAGE_BLOCK_PREFIX       0xB0
#define DPH_PAGE_BLOCK_INFIX        0xC0
#define DPH_PAGE_BLOCK_SUFFIX       0xD0
#define DPH_NORMAL_BLOCK_INFIX      0xE0
#define DPH_FREE_BLOCK_INFIX        0xF0


VOID
VrfFigureOutAddress (
    ULONG64 Address
    )
{
    ULONG64 Prefix;
    ULONG PrefixSize;
    ULONG64 StartStamp, EndStamp;
    ULONG64 Heap;
    CHAR Buffer[128];

    PrefixSize = GetTypeSize ("NTDLL!_DPH_BLOCK_INFORMATION");

    Prefix = Address - PrefixSize;

    if (InitTypeRead (Prefix, NTDLL!_DPH_BLOCK_INFORMATION) == 0) {

        StartStamp = ReadField (StartStamp);
        EndStamp = ReadField (EndStamp);
        Heap = ReadField (Heap);

        if (EndStamp == DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED) {

            dprintf ("Address %I64X is the start of a block allocated in light heap %I64X .\n",
                     Address, Heap);
        }
        else if (EndStamp == DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED - 1) {

            dprintf ("Address %I64X is the start of a block freed in light heap %I64X .\n"
                     "The block is still in the delayed free cache.\n",
                     Address, Heap);
        }
        else if (EndStamp == DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED - 2) {

            dprintf ("Address %I64X is the start of a block freed in light heap %I64X .\n"
                     "The block was recycled, it is not in the delayed free cache anymore.\n",
                     Address, Heap);
        }
        else {

            sprintf (Buffer, "-p -a %I64X", Address);

            dprintf ("Searching inside page heap structures ... \n");

            //
            // Call the appropriate page heap extension.
            //

            if (WinXpClient) {
                DebugPageHeapExtensionXP (Buffer);
            }
            else {
                PageHeapExtension (Buffer);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

ULONG
ReadULONG (
    ULONG64 Address
    )
{
    ULONG Value;
    ULONG BytesRead;

    if (ReadMemory (Address, &Value, sizeof Value, &BytesRead) == FALSE) {
        dprintf ("Cannot read value @ %p. \n", Address);
        return 0;
    }
    else {

        return Value;
    }
}

VOID
WriteULONG (
    ULONG64 Address,
    ULONG Value
    )
{
    ULONG BytesWritten;

    if (WriteMemory (Address, &Value, sizeof Value, &BytesWritten) == FALSE) {
        dprintf ("Cannot write value @ %p. \n", Address);
    }
}


VOID
WritePVOID (
    ULONG64 Address,
    ULONG64 Value
    )
{
    ULONG BytesWritten;

    if (IsPtr64()) {
        
        if (WriteMemory (Address, &Value, 8, &BytesWritten) == FALSE) {
            dprintf ("Cannot write pointer @ %p. \n", Address);
        }
    }
    else {

        if (WriteMemory (Address, &Value, 4, &BytesWritten) == FALSE) {
            dprintf ("Cannot write pointer @ %p. \n", Address);
        }
    }
}


ULONG64
ReadPVOID (
    ULONG64 Address
    )
{
    ULONG BytesRead;

    if (IsPtr64()) {
        
        ULONG64 Value;

        if (ReadMemory (Address, &Value, sizeof Value, &BytesRead) == FALSE) {
            dprintf ("Cannot read pointer @ %p. \n", Address);
            return 0;
        }
        else {

            return (ULONG64)Value;
        }
    }
    else {

        ULONG Value;

        if (ReadMemory (Address, &Value, sizeof Value, &BytesRead) == FALSE) {
            dprintf ("Cannot read pointer @ %p. \n", Address);
            return 0;
        }
        else {

            return (ULONG64)Value;
        }
    }
}


//
// Definitions from \nt\base\win32\verifier\support.h
//

#define CNT_WAIT_SINGLE_CALLS                 0
#define CNT_WAIT_SINGLEEX_CALLS               1
#define CNT_WAIT_MULTIPLE_CALLS               2
#define CNT_WAIT_MULTIPLEEX_CALLS             3
#define CNT_WAIT_WITH_TIMEOUT_CALLS           4
#define CNT_WAIT_WITH_TIMEOUT_FAILS           5
#define CNT_CREATE_EVENT_CALLS                6
#define CNT_CREATE_EVENT_FAILS                7
#define CNT_HEAP_ALLOC_CALLS                  8
#define CNT_HEAP_ALLOC_FAILS                  9
#define CNT_CLOSE_NULL_HANDLE_CALLS           10
#define CNT_CLOSE_PSEUDO_HANDLE_CALLS         11
#define CNT_HEAPS_CREATED                     12
#define CNT_HEAPS_DESTROYED                   13
#define CNT_VIRTUAL_ALLOC_CALLS               14
#define CNT_VIRTUAL_ALLOC_FAILS               15
#define CNT_MAP_VIEW_CALLS                    16
#define CNT_MAP_VIEW_FAILS                    17
#define CNT_OLE_ALLOC_CALLS                   18
#define CNT_OLE_ALLOC_FAILS                   19

VOID
VrfDumpGlobalCounters (
    VOID
    )
{
    ULONG64 Address;
    ULONG TypeSize;
    ULONG Value;

    Address = GetExpression("verifier!AVrfpCounter");
    TypeSize = sizeof (ULONG);

    Value = ReadULONG (Address + TypeSize * CNT_WAIT_SINGLE_CALLS);
    dprintf ("WaitForSingleObject calls:                %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_WAIT_SINGLEEX_CALLS);
    dprintf ("WaitForSingleObjectEx calls:              %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_WAIT_MULTIPLE_CALLS);
    dprintf ("WaitForMultipleObjects calls              %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_WAIT_MULTIPLEEX_CALLS);
    dprintf ("WaitForMultipleObjectsEx calls:           %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_WAIT_WITH_TIMEOUT_CALLS);
    dprintf ("Waits with timeout calls:                 %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_WAIT_WITH_TIMEOUT_FAILS);
    dprintf ("Waits with timeout failed:                %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_CREATE_EVENT_CALLS);
    dprintf ("CreateEvent calls:                        %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_CREATE_EVENT_FAILS);
    dprintf ("CreateEvent calls failed:                 %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_HEAP_ALLOC_CALLS);
    dprintf ("Heap allocation calls:                    %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_HEAP_ALLOC_FAILS);
    dprintf ("Heap allocations failed:                  %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_CLOSE_NULL_HANDLE_CALLS);
    dprintf ("CloseHandle called with null handle:      %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_CLOSE_PSEUDO_HANDLE_CALLS);
    dprintf ("CloseHandle called with pseudo handle:    %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_HEAPS_CREATED);
    dprintf ("Heaps created:                            %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_HEAPS_DESTROYED);
    dprintf ("Heaps destroyed:                          %X \n", Value);
    
    Value = ReadULONG (Address + TypeSize * CNT_VIRTUAL_ALLOC_CALLS);
    dprintf ("Virtual allocation calls:                 %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_VIRTUAL_ALLOC_FAILS);
    dprintf ("Virtual allocations failed:               %X \n", Value);
    
    Value = ReadULONG (Address + TypeSize * CNT_MAP_VIEW_CALLS);
    dprintf ("Map view calls:                           %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_MAP_VIEW_FAILS);
    dprintf ("Map views failed:                         %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_OLE_ALLOC_CALLS);
    dprintf ("OLE string allocation calls:              %X \n", Value);

    Value = ReadULONG (Address + TypeSize * CNT_OLE_ALLOC_FAILS);
    dprintf ("OLE string allocations failed:            %X \n", Value);
}

//
// Definitions from \nt\base\win32\verifier\support.h
//

#define BRK_CLOSE_NULL_HANDLE                  0
#define BRK_CLOSE_PSEUDO_HANDLE                1
#define BRK_CREATE_EVENT_FAIL                  2
#define BRK_HEAP_ALLOC_FAIL                    3
#define BRK_WAIT_WITH_TIMEOUT_FAIL             4
#define BRK_VIRTUAL_ALLOC_FAIL                 5
#define BRK_MAP_VIEW_FAIL                      6
#define BRK_CREATE_FILE_FAIL                   7
#define BRK_CREATE_KEY_FAIL                    8
#define BRK_OLE_ALLOC_FAIL                     9

#define BRK_MAXIMUM_INDEX                      64

VOID
VrfDumpBreakTriggers (
    VOID
    )
{
    ULONG64 Address;
    ULONG TypeSize;
    ULONG Value;

    Address = GetExpression("verifier!AVrfpBreak");
    TypeSize = sizeof (ULONG);

    Value = ReadULONG (Address + TypeSize * BRK_CLOSE_NULL_HANDLE);
    dprintf ("%03X : Break for closing null handle:                         %X \n", 
             BRK_CLOSE_NULL_HANDLE,
             Value);

    Value = ReadULONG (Address + TypeSize * BRK_CLOSE_PSEUDO_HANDLE);
    dprintf ("%03X : Break for closing pseudo handle:                       %X \n", 
             BRK_CLOSE_PSEUDO_HANDLE,
             Value);

    Value = ReadULONG (Address + TypeSize * BRK_CREATE_EVENT_FAIL);
    dprintf ("%03X : Break for failing CreateEvent:                         %X \n", 
             BRK_CREATE_EVENT_FAIL,
             Value);

    Value = ReadULONG (Address + TypeSize * BRK_HEAP_ALLOC_FAIL);
    dprintf ("%03X : Break for failing heap allocation:                     %X \n", 
             BRK_HEAP_ALLOC_FAIL,
             Value);

    Value = ReadULONG (Address + TypeSize * BRK_WAIT_WITH_TIMEOUT_FAIL);
    dprintf ("%03X : Break for failing a wait with timeout:                 %X \n", 
             BRK_WAIT_WITH_TIMEOUT_FAIL,
             Value);
    
    Value = ReadULONG (Address + TypeSize * BRK_VIRTUAL_ALLOC_FAIL);
    dprintf ("%03X : Break for failing virtual allocation:                  %X \n", 
             BRK_VIRTUAL_ALLOC_FAIL,
             Value);
    
    Value = ReadULONG (Address + TypeSize * BRK_MAP_VIEW_FAIL);
    dprintf ("%03X : Break for failing map view operations:                 %X \n", 
             BRK_MAP_VIEW_FAIL,
             Value);
    
    Value = ReadULONG (Address + TypeSize * BRK_CREATE_FILE_FAIL);
    dprintf ("%03X : Break for failing create/open file operations:         %X \n", 
             BRK_CREATE_FILE_FAIL,
             Value);
    
    Value = ReadULONG (Address + TypeSize * BRK_CREATE_KEY_FAIL);
    dprintf ("%03X : Break for failing registry create/open key operations: %X \n", 
             BRK_CREATE_KEY_FAIL,
             Value);
    
    Value = ReadULONG (Address + TypeSize * BRK_OLE_ALLOC_FAIL);
    dprintf ("%03X : Break for failing OLE string allocations:              %X \n", 
             BRK_OLE_ALLOC_FAIL,
             Value);
}

VOID
VrfToggleBreakTrigger (
    ULONG Index
    )
{
    ULONG64 Address;
    ULONG TypeSize;
    ULONG Value;

    if (Index > BRK_MAXIMUM_INDEX) {
        dprintf ("Index %X is out of range (0..%X) \n",
                 Index,
                 BRK_MAXIMUM_INDEX);
        return;
    }

    Address = GetExpression("verifier!AVrfpBreak");
    TypeSize = sizeof (ULONG);

    Value = ReadULONG (Address + TypeSize * Index);

    if (Value == 0) {
        
        WriteULONG (Address + TypeSize * Index, 1);
        dprintf ("Break trigger %X is now enabled.\n", Index);
    }
    else {

        WriteULONG (Address + TypeSize * Index, 0);
        dprintf ("Break trigger %X is now disabled.\n", Index);
    }
}


//
// Definitions from \nt\base\win32\verifier\faults.h
//

#define CLS_WAIT_APIS                0
#define CLS_HEAP_ALLOC_APIS          1
#define CLS_VIRTUAL_ALLOC_APIS       2
#define CLS_REGISTRY_APIS            3
#define CLS_FILE_APIS                4
#define CLS_EVENT_APIS               5
#define CLS_MAP_VIEW_APIS            6
#define CLS_OLE_ALLOC_APIS           7
                                         
#define CLS_MAXIMUM_INDEX 16

VOID
VrfDumpFaultInjectionSettings (
    VOID
    )
{
    ULONG64 Address;
    ULONG64 BreakAddress;
    ULONG64 TrueAddress;
    ULONG64 FalseAddress;
    ULONG TypeSize;
    ULONG Value;
    ULONG BreakValue;
    ULONG SuccessValue;
    ULONG FailValue;

    dprintf ("Fault injection settings:   Probability (break, success/failed)   \n"
             "==============================================\n");

    Address = GetExpression("verifier!AVrfpFaultProbability");
    BreakAddress = GetExpression("verifier!AVrfpFaultBreak");
    TrueAddress = GetExpression("verifier!AVrfpFaultTrue");
    FalseAddress = GetExpression("verifier!AVrfpFaultFalse");
    TypeSize = sizeof (ULONG);

    Value = ReadULONG (Address + TypeSize * CLS_WAIT_APIS);
    BreakValue = ReadULONG (BreakAddress + TypeSize * CLS_WAIT_APIS);
    SuccessValue = ReadULONG (FalseAddress + TypeSize * CLS_WAIT_APIS);
    FailValue = ReadULONG (TrueAddress + TypeSize * CLS_WAIT_APIS);
    dprintf ("%03X : Wait APIs:                 %02X (%X, %X / %X)\n", 
             CLS_WAIT_APIS,
             Value, 
             BreakValue,
             SuccessValue, 
             FailValue);

    Value = ReadULONG (Address + TypeSize * CLS_HEAP_ALLOC_APIS);
    BreakValue = ReadULONG (BreakAddress + TypeSize * CLS_HEAP_ALLOC_APIS);
    SuccessValue = ReadULONG (FalseAddress + TypeSize * CLS_HEAP_ALLOC_APIS);
    FailValue = ReadULONG (TrueAddress + TypeSize * CLS_HEAP_ALLOC_APIS);
    dprintf ("%03X : Heap allocations:          %02X (%X, %X / %X)\n", 
             CLS_HEAP_ALLOC_APIS,
             Value, 
             BreakValue,
             SuccessValue, 
             FailValue);

    Value = ReadULONG (Address + TypeSize * CLS_VIRTUAL_ALLOC_APIS);
    BreakValue = ReadULONG (BreakAddress + TypeSize * CLS_VIRTUAL_ALLOC_APIS);
    SuccessValue = ReadULONG (FalseAddress + TypeSize * CLS_VIRTUAL_ALLOC_APIS);
    FailValue = ReadULONG (TrueAddress + TypeSize * CLS_VIRTUAL_ALLOC_APIS);
    dprintf ("%03X : Virtual space allocations: %02X (%X, %X / %X)\n", 
             CLS_VIRTUAL_ALLOC_APIS,
             Value, 
             BreakValue,
             SuccessValue, 
             FailValue);

    Value = ReadULONG (Address + TypeSize * CLS_REGISTRY_APIS);
    BreakValue = ReadULONG (BreakAddress + TypeSize * CLS_REGISTRY_APIS);
    SuccessValue = ReadULONG (FalseAddress + TypeSize * CLS_REGISTRY_APIS);
    FailValue = ReadULONG (TrueAddress + TypeSize * CLS_REGISTRY_APIS);
    dprintf ("%03X : Registry APIs:             %02X (%X, %X / %X)\n", 
             CLS_REGISTRY_APIS,
             Value, 
             BreakValue,
             SuccessValue, 
             FailValue);

    Value = ReadULONG (Address + TypeSize * CLS_FILE_APIS);
    BreakValue = ReadULONG (BreakAddress + TypeSize * CLS_FILE_APIS);
    SuccessValue = ReadULONG (FalseAddress + TypeSize * CLS_FILE_APIS);
    FailValue = ReadULONG (TrueAddress + TypeSize * CLS_FILE_APIS);
    dprintf ("%03X : File APIs:                 %02X (%X, %X / %X)\n", 
             CLS_FILE_APIS,
             Value, 
             BreakValue,
             SuccessValue, 
             FailValue);

    Value = ReadULONG (Address + TypeSize * CLS_EVENT_APIS);
    BreakValue = ReadULONG (BreakAddress + TypeSize * CLS_EVENT_APIS);
    SuccessValue = ReadULONG (FalseAddress + TypeSize * CLS_EVENT_APIS);
    FailValue = ReadULONG (TrueAddress + TypeSize * CLS_EVENT_APIS);
    dprintf ("%03X : Event APIs:                %02X (%X, %X / %X)\n", 
             CLS_EVENT_APIS,
             Value, 
             BreakValue,
             SuccessValue, 
             FailValue);

    Value = ReadULONG (Address + TypeSize * CLS_MAP_VIEW_APIS);
    BreakValue = ReadULONG (BreakAddress + TypeSize * CLS_MAP_VIEW_APIS);
    SuccessValue = ReadULONG (FalseAddress + TypeSize * CLS_MAP_VIEW_APIS);
    FailValue = ReadULONG (TrueAddress + TypeSize * CLS_MAP_VIEW_APIS);
    dprintf ("%03X : Map view operations:       %02X (%X, %X / %X)\n", 
             CLS_MAP_VIEW_APIS,
             Value, 
             BreakValue,
             SuccessValue, 
             FailValue);

    Value = ReadULONG (Address + TypeSize * CLS_OLE_ALLOC_APIS);
    BreakValue = ReadULONG (BreakAddress + TypeSize * CLS_OLE_ALLOC_APIS);
    SuccessValue = ReadULONG (FalseAddress + TypeSize * CLS_OLE_ALLOC_APIS);
    FailValue = ReadULONG (TrueAddress + TypeSize * CLS_OLE_ALLOC_APIS);
    dprintf ("%03X : OLE string allocations:    %02X (%X, %X / %X)\n", 
             CLS_OLE_ALLOC_APIS,
             Value, 
             BreakValue,
             SuccessValue, 
             FailValue);
}


VOID
VrfSetFaultInjectionParameters (
    ULONG Index,
    ULONG Probability
    )
{
    ULONG64 Address;
    ULONG TypeSize;
    ULONG Value;

    if (Index > CLS_MAXIMUM_INDEX) {
        dprintf ("Index %X is out of range (0..%X) \n",
                 Index,
                 CLS_MAXIMUM_INDEX);
        return;
    }

    if (Probability > 100) {
        dprintf ("Probability %X is out of range (0..%X) \n",
                 Probability,
                 100);
        return;
    }

    Address = GetExpression("verifier!AVrfpFaultProbability");
    TypeSize = sizeof (ULONG);

    WriteULONG (Address + TypeSize * Index, Probability);

    dprintf ("Probability for event %X is now set to %X.\n", 
             Index,
             Probability);
}



VOID
VrfToggleFaultInjectionBreak (
    ULONG Index
    )
{
    ULONG64 Address;
    ULONG TypeSize;
    ULONG Value;

    if (Index > CLS_MAXIMUM_INDEX) {
        dprintf ("Index %X is out of range (0..%X) \n",
                 Index,
                 CLS_MAXIMUM_INDEX);
        return;
    }


    Address = GetExpression("verifier!AVrfpFaultBreak");
    TypeSize = sizeof (ULONG);

    Value = ReadULONG (Address + TypeSize * Index);

    if (Value == 0) {
        
        WriteULONG (Address + TypeSize * Index, 1);
        dprintf ("Will break for fault injection event %X.\n", Index);
    }
    else {

        WriteULONG (Address + TypeSize * Index, 0);
        dprintf ("Will not break for fault injection event %X.\n", Index);
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID
VrfDumpFaultInjectionTargetRanges (
    VOID
    )
{
    ULONG64 StartAddress, EndAddress;
    ULONG64 HitsAddress;
    ULONG64 IndexAddress;
    ULONG TypeSize;
    ULONG64 Start, End;
    ULONG MaximumIndex;
    ULONG Index;
    ULONG RangeCount = 0;
    ULONG Hits;

    dprintf ("Fault injection target ranges (START END HITS): \n"
             "============================================================\n");

    IndexAddress = GetExpression("verifier!AVrfpFaultTargetMaximumIndex");
    StartAddress = GetExpression("verifier!AVrfpFaultTargetStart");
    EndAddress = GetExpression("verifier!AVrfpFaultTargetEnd");
    HitsAddress = GetExpression("verifier!AVrfpFaultTargetHits");
    TypeSize = IsPtr64() ? 8 : 4;

    MaximumIndex = ReadULONG (IndexAddress);

    for (Index = 0; Index < MaximumIndex; Index += 1) {
        
        ReadPointer (StartAddress + TypeSize * Index, &Start);
        ReadPointer (EndAddress + TypeSize * Index, &End);

        Hits = ReadULONG (HitsAddress + sizeof(ULONG) * Index);

        if (Start == 0 && End == 0) {
            continue;
        }
        
        dprintf ("%016I64X    %016I64X    %X\n", Start, End, Hits);
        RangeCount += 1;
    }

    if (RangeCount == 0) {
        dprintf ("No fault injection target ranges are active. \n");
    }
}


VOID
VrfAddFaultInjectionTargetRange (
    ULONG64 TargetStart,
    ULONG64 TargetEnd
    )
{
    ULONG64 StartAddress, EndAddress;
    ULONG64 HitsAddress;
    ULONG64 IndexAddress;
    ULONG TypeSize;
    ULONG64 Start, End;
    ULONG MaximumIndex;
    ULONG Index;
    ULONG Hits;

    IndexAddress = GetExpression("verifier!AVrfpFaultTargetMaximumIndex");
    StartAddress = GetExpression("verifier!AVrfpFaultTargetStart");
    EndAddress = GetExpression("verifier!AVrfpFaultTargetEnd");
    HitsAddress = GetExpression("verifier!AVrfpFaultTargetHits");
    TypeSize = IsPtr64() ? 8 : 4;

    MaximumIndex = ReadULONG (IndexAddress);

    for (Index = 0; Index < MaximumIndex; Index += 1) {
        
        ReadPointer (StartAddress + TypeSize * Index, &Start);
        ReadPointer (EndAddress + TypeSize * Index, &End);

        if (Start == 0) {
            break;
        }
    }

    if (Index < MaximumIndex) {
        
        WritePVOID (StartAddress + TypeSize * Index, TargetStart);
        WritePVOID (EndAddress + TypeSize * Index, TargetEnd);
        WriteULONG (HitsAddress + sizeof(ULONG) * Index, 0);

        dprintf ("Target range %I64X - %I64X activated. \n",
                 TargetStart, 
                 TargetEnd);
    }
    else {

        dprintf ("No more space for additional fault target range. \n");
    }
}


VOID
VrfResetFaultInjectionTargetRanges (
    VOID
    )
{
    ULONG64 StartAddress, EndAddress;
    ULONG64 HitsAddress;
    ULONG64 IndexAddress;
    ULONG TypeSize;
    ULONG64 Start, End;
    ULONG MaximumIndex;
    ULONG Index;
    ULONG Hits;

    IndexAddress = GetExpression("verifier!AVrfpFaultTargetMaximumIndex");
    StartAddress = GetExpression("verifier!AVrfpFaultTargetStart");
    EndAddress = GetExpression("verifier!AVrfpFaultTargetEnd");
    HitsAddress = GetExpression("verifier!AVrfpFaultTargetHits");
    TypeSize = IsPtr64() ? 8 : 4;

    MaximumIndex = ReadULONG (IndexAddress);

    for (Index = 0; Index < MaximumIndex; Index += 1) {
        
        WritePVOID (StartAddress + TypeSize * Index, 0);
        WriteULONG (HitsAddress + sizeof(ULONG) * Index, 0);
        
        if (Index == 0) {
            
            WritePVOID (EndAddress + TypeSize * Index, ~((ULONG64)0));
        }
        else {

            WritePVOID (EndAddress + TypeSize * Index, 0);
        }
    }
    
    dprintf ("Target ranges have been reset. \n");
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID
VrfDumpFaultInjectionExclusionRanges (
    VOID
    )
{
    ULONG64 StartAddress, EndAddress;
    ULONG64 HitsAddress;
    ULONG64 TimeAddress;
    ULONG64 IndexAddress;
    ULONG TypeSize;
    ULONG64 Start, End;
    ULONG MaximumIndex;
    ULONG Index;
    ULONG RangeCount = 0;
    ULONG Hits;
    ULONG TimeInMsecs;

    dprintf ("Fault injection exclusion ranges (START END HITS): \n"
             "============================================================\n");

    IndexAddress = GetExpression("verifier!AVrfpFaultExclusionMaximumIndex");
    StartAddress = GetExpression("verifier!AVrfpFaultExclusionStart");
    EndAddress = GetExpression("verifier!AVrfpFaultExclusionEnd");
    HitsAddress = GetExpression("verifier!AVrfpFaultExclusionHits");
    TimeAddress = GetExpression("verifier!AVrfpFaultPeriodTimeInMsecs");
    TypeSize = IsPtr64() ? 8 : 4;

    MaximumIndex = ReadULONG (IndexAddress);
    TimeInMsecs = ReadULONG (TimeAddress);

    for (Index = 0; Index < MaximumIndex; Index += 1) {
        
        ReadPointer (StartAddress + TypeSize * Index, &Start);
        ReadPointer (EndAddress + TypeSize * Index, &End);

        Hits = ReadULONG (HitsAddress + sizeof(ULONG) * Index);

        if (Start == 0 && End == 0) {
            continue;
        }
        
        dprintf ("%016I64X    %016I64X    %X\n", Start, End, Hits);
        RangeCount += 1;
    }

    if (RangeCount == 0) {
        dprintf ("No fault injection exclusion ranges are active. \n");
    }

    if (TimeInMsecs) {
        dprintf ("\nFault injection disabled for the next 0x%X msecs. \n", TimeInMsecs);
    }
}


VOID
VrfAddFaultInjectionExclusionRange (
    ULONG64 TargetStart,
    ULONG64 TargetEnd
    )
{
    ULONG64 StartAddress, EndAddress;
    ULONG64 HitsAddress;
    ULONG64 IndexAddress;
    ULONG TypeSize;
    ULONG64 Start, End;
    ULONG MaximumIndex;
    ULONG Index;
    ULONG Hits;

    IndexAddress = GetExpression("verifier!AVrfpFaultExclusionMaximumIndex");
    StartAddress = GetExpression("verifier!AVrfpFaultExclusionStart");
    EndAddress = GetExpression("verifier!AVrfpFaultExclusionEnd");
    HitsAddress = GetExpression("verifier!AVrfpFaultExclusionHits");
    TypeSize = IsPtr64() ? 8 : 4;

    MaximumIndex = ReadULONG (IndexAddress);

    for (Index = 0; Index < MaximumIndex; Index += 1) {
        
        ReadPointer (StartAddress + TypeSize * Index, &Start);
        ReadPointer (EndAddress + TypeSize * Index, &End);

        if (Start == 0) {
            break;
        }
    }

    if (Index < MaximumIndex) {
        
        WritePVOID (StartAddress + TypeSize * Index, TargetStart);
        WritePVOID (EndAddress + TypeSize * Index, TargetEnd);
        WriteULONG (HitsAddress + sizeof(ULONG) * Index, 0);

        dprintf ("Exclusion range %I64X - %I64X activated. \n",
                 TargetStart, 
                 TargetEnd);
    }
    else {

        dprintf ("No more space for additional fault exclusion range. \n");
    }
}


VOID
VrfResetFaultInjectionExclusionRanges (
    VOID
    )
{
    ULONG64 StartAddress, EndAddress;
    ULONG64 TimeAddress;
    ULONG64 HitsAddress;
    ULONG64 IndexAddress;
    ULONG TypeSize;
    ULONG64 Start, End;
    ULONG MaximumIndex;
    ULONG Index;
    ULONG Hits;

    IndexAddress = GetExpression("verifier!AVrfpFaultExclusionMaximumIndex");
    StartAddress = GetExpression("verifier!AVrfpFaultExclusionStart");
    EndAddress = GetExpression("verifier!AVrfpFaultExclusionEnd");
    HitsAddress = GetExpression("verifier!AVrfpFaultExclusionHits");
    TimeAddress = GetExpression("verifier!AVrfpFaultPeriodTimeInMsecs");
    TypeSize = IsPtr64() ? 8 : 4;

    MaximumIndex = ReadULONG (IndexAddress);

    for (Index = 0; Index < MaximumIndex; Index += 1) {
        
        WritePVOID (StartAddress + TypeSize * Index, 0);
        WritePVOID (EndAddress + TypeSize * Index, 0);
        WriteULONG (HitsAddress + sizeof(ULONG) * Index, 0);
    }
    
    WriteULONG (TimeAddress, 0);

    dprintf ("Exclusion ranges have been reset. \n");
}


VOID
VrfSetFaultInjectionExclusionPeriod (
    ULONG64 TimeInMsecs
    )
{
    
    ULONG64 TimeAddress;
    ULONG64 HitsAddress;
    ULONG64 IndexAddress;
    ULONG TypeSize;
    ULONG64 Start, End;
    ULONG MaximumIndex;
    ULONG Index;
    ULONG Hits;

    TimeAddress = GetExpression("verifier!AVrfpFaultPeriodTimeInMsecs");
    TypeSize = IsPtr64() ? 8 : 4;

    WriteULONG (TimeAddress, (ULONG)TimeInMsecs);

    dprintf ("Fault injection disabled for the next 0x%I64X msecs. \n", TimeInMsecs);
}


VOID
VrfDumpFaultInjectionTraces (
    ULONG Count
    )
{
    ULONG64 TraceAddress;
    ULONG64 IndexAddress;
    ULONG64 Address;
    ULONG Index;
    ULONG MaxIndex;
    ULONG TraceSize;
    ULONG TypeSize;
    ULONG I;

    TraceAddress = GetExpression ("verifier!AVrfpFaultTrace");

    Address = GetExpression ("verifier!AVrfpFaultTraceIndex");
    Index = ReadULONG(Address);

    Address = GetExpression ("verifier!AVrfpFaultNumberOfTraces");
    MaxIndex = ReadULONG(Address);

    Address = GetExpression ("verifier!AVrfpFaultTraceSize");
    TraceSize = ReadULONG(Address);

    TypeSize = IsPtr64() ? 8 : 4;

    if (Count > MaxIndex) {
        Count = MaxIndex;
    }

    //
    // Bring Index within stack trace database limits.
    //

    Index = Index % MaxIndex;

    while (Count > 0) {

        dprintf ("- - - - - - - - - - - - - - - - - - - - - - - - - \n");

        for (I = 0; I < TraceSize; I += 1) {
            
            CHAR  SymbolName[ 1024 ];
            ULONG64 Displacement;
            ULONG64 ReturnAddress;

            ReadPointer (TraceAddress + TypeSize * TraceSize * Index + TypeSize * I, 
                     &ReturnAddress);

            if (ReturnAddress == 0) {
                break;
            }
            
            GetSymbol (ReturnAddress, SymbolName, &Displacement);

            dprintf ("    %p %s+0x%p\n", 
                     ReturnAddress, 
                     SymbolName, 
                     Displacement);
        }
    
        Index = (Index - 1) % MaxIndex;

        Count -= 1;
    }
}


PWSTR
ReadUnicodeString (
    ULONG64 Address,
    PWSTR Buffer,
    ULONG BufferSizeInBytes
    )
{
    ULONG BytesRead;
    ULONG Offset;
    LOGICAL Result;

    InitTypeRead (Address, ntdll!_UNICODE_STRING);
    
    Result = ReadMemory (ReadField(Buffer), 
                         Buffer, 
                         BufferSizeInBytes, 
                         &BytesRead);

    if (Result == FALSE) {
        dprintf ("Cannot read UNICODE string @ %p. \n", Address);
        return NULL;
    }
    else {

        Buffer[BufferSizeInBytes - 1] = 0;

        return Buffer;
    }
}


CHAR DllNameInChars [256];
WCHAR DllNameInWChars [256];

VOID
VrfSetFaultInjectionDllTarget (
    PCHAR DllName,
    LOGICAL Exclude
    )
{
    ULONG64 PebAddress;
    ULONG64 LdrAddress;
    ULONG Offset;
    ULONG64 ListStart;
    ULONG64 ListEntry;
    ULONG NameOffset;

    PebAddress = VrfPebAddress ();

    InitTypeRead (PebAddress, ntdll!_PEB);
    LdrAddress = ReadField (Ldr);

    InitTypeRead (LdrAddress, ntdll!_PEB_LDR_DATA);
    
    GetFieldOffset ("ntdll!_PEB_LDR_DATA", 
                    "InLoadOrderModuleList",
                    &Offset);

    ListStart = LdrAddress + Offset;

    ReadPointer(ListStart, &ListEntry);

    while (ListEntry != ListStart) {
        
        GetFieldOffset ("ntdll!_LDR_DATA_TABLE_ENTRY", 
                        "InLoadOrderLinks",
                        &Offset);

        LdrAddress = ListEntry - Offset;

        GetFieldOffset ("ntdll!_LDR_DATA_TABLE_ENTRY", 
                        "BaseDllName",
                        &NameOffset);

        ReadUnicodeString (LdrAddress + NameOffset, 
                           DllNameInWChars, 
                           sizeof DllNameInWChars);
        
        //
        // Convert from WCHAR* to CHAR* the dll name.
        //

        {
            PCHAR Src;
            ULONG Ti;

            Src = (PCHAR)DllNameInWChars;
            Ti = 0;

            while (*Src) {

                if (Ti > 254) {
                    break;
                }

                DllNameInChars[Ti] = *Src;

                Src += sizeof(WCHAR);
                Ti += 1;
            }

            DllNameInChars[Ti] = 0;
        }
        
        if (_stricmp (DllName, DllNameInChars) == 0) {
            
            InitTypeRead (LdrAddress, ntdll!_LDR_DATA_TABLE_ENTRY);
            
            if (Exclude) {
                
                VrfAddFaultInjectionExclusionRange (ReadField (DllBase),
                                                    ReadField (DllBase) + ReadField (SizeOfImage));
            }
            else {

                VrfAddFaultInjectionTargetRange (ReadField (DllBase),
                                                 ReadField (DllBase) + ReadField (SizeOfImage));
            }

            break;
        }

        ReadPointer(ListEntry, &ListEntry);
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID
VrfDumpExceptionLog (
    ULONG MaxEntries
    )
{
    ULONG64 TempAddress;
    ULONG64 ExceptionLogAddress;
    ULONG64 CurrentLogEntryAddress;
    ULONG64 Value;
    ULONG ExceptionLogEntriesNo;
    ULONG CurrentLogIndex;
    ULONG BytesRead;
    ULONG LogEntrySize;
    ULONG LogEntry;
    ULONG EntriedDumped = 0;
    
    //
    // Read the start of the exception log database.
    //

    ExceptionLogAddress = GetExpression ("&verifier!AVrfpExceptionLog");
    
    if (ExceptionLogAddress == 0 ) {

        dprintf ("No exception information available (unable to resolve verifier!AVrfpExceptionLog)\n");
        return;
    }

    if (!ReadPointer (ExceptionLogAddress, &ExceptionLogAddress) != S_OK) {

        dprintf ("No exception information available (cannot read pointer from address %p)\n",
                 ExceptionLogAddress);
        return;
    }

    //
    // Read the number of entries in the exception log database.
    //

    TempAddress = GetExpression ("&verifier!AVrfpExceptionLogEntriesNo");

    if (TempAddress == 0 ) {

        dprintf ("No exception information available (unable to resolve verifier!AVrfpExceptionLogEntriesNo)\n");
        return;
    }

    ExceptionLogEntriesNo = ReadULONG(TempAddress);

    if (ExceptionLogEntriesNo <= 1) {
        return;
    }

    //
    // Read the current index in the exception log database.
    //

    TempAddress = GetExpression ("&verifier!AVrfpExceptionLogCurrentIndex");

    if (TempAddress == 0 ) {

        dprintf ("No exception information available (unable to resolve verifier!AVrfpExceptionLogCurrentIndex)\n");
        return;
    }

    if (ReadMemory (TempAddress, &CurrentLogIndex, sizeof (CurrentLogIndex), &BytesRead) == FALSE) {

        dprintf ("Error: cannot read value at %p\n",
                 TempAddress);
        return;
    }

    CurrentLogIndex = CurrentLogIndex % ExceptionLogEntriesNo;

    //
    // Read the AVRF_EXCEPTION_LOG_ENTRY type size.
    //

    LogEntrySize = GetTypeSize ("verifier!_AVRF_EXCEPTION_LOG_ENTRY");

    if (LogEntrySize == 0) {

        dprintf ("Error: cannot get verifier!_AVRF_EXCEPTION_LOG_ENTRY type size.\n");
        return;
    }

    //
    // Parse all the log entries.
    //

    for (LogEntry = 0; LogEntry < ExceptionLogEntriesNo && LogEntry < MaxEntries; LogEntry += 1) {

        if (CheckControlC()) {

            break;
        }

        CurrentLogEntryAddress = ExceptionLogAddress + CurrentLogIndex * LogEntrySize;

        if (InitTypeRead(CurrentLogEntryAddress, verifier!_AVRF_EXCEPTION_LOG_ENTRY)) {

            dprintf ("Error: cannot read log entry at %p\n",
                     CurrentLogEntryAddress);
        }
        else {

            Value = ReadField (ThreadId);

            if (Value == 0) {

                //
                // This is the last entry in our log.
                //
             
                break;
            }

            EntriedDumped += 1;

            dprintf ("=================================\n");

            dprintf ("Thread ID: %p\n",
                      Value);

            Value = ReadField (ExceptionCode);
            dprintf ("Exception code: %I64x\n",
                      Value);

            Value = ReadField (ExceptionAddress);
            dprintf ("Exception address: %p\n",
                      Value);

            Value = ReadField (ExceptionRecord);
            dprintf ("Exception record: %p\n",
                      Value);

            Value = ReadField (ContextRecord);
            dprintf ("Context record: %p\n",
                      Value);
        }

        if (CurrentLogIndex > 0) {

            CurrentLogIndex -= 1;
        }
        else {

            CurrentLogIndex = ExceptionLogEntriesNo - 1;
        }
    }

    if (EntriedDumped == 0) {

        dprintf ("No exception log entries available.\n");
    }
    else {

        dprintf ("\nDisplayed %u exception log entries.\n",
                  EntriedDumped);
    }
}

#define THREAD_TABLE_SIZE 61

VOID
VrfDumpThreadsInformation (
    ULONG64 UserThreadId
    )
{
    ULONG64 CrtListHeadAddress;
    ULONG64 Flink;
    ULONG64 Displacement;
    ULONG64 ThreadId;
    ULONG64 ThreadParentId;
    ULONG64 ThreadParameter;
    ULONG64 ThreadStackSize;
    ULONG64 ThreadStartAddress;
    ULONG64 ThreadCreationFlags;
    ULONG64 TempAddress;
    ULONG CrtListIndex;
    ULONG PtrSize;
    ULONG DumpedThreads;
    ULONG ThreadTableLength;
    BOOL Continue;
    CHAR SeparatorString[] = "===================================================\n";
    CHAR Symbol[ 1024 ];

    PtrSize = IsPtr64() ? 8 : 4;

    DumpedThreads = 0;

    //
    // Get the length of the thread list array.
    //

    TempAddress = GetExpression ("&verifier!AVrfpThreadTableEntriesNo");

    if (TempAddress == 0 ) {

        ThreadTableLength = THREAD_TABLE_SIZE;
    }
    else {

        ThreadTableLength = ReadULONG(TempAddress);

        if (ThreadTableLength <= 1) {
            return;
        }
    }

    //
    // Get the address of the thread list array.
    //

    CrtListHeadAddress = GetExpression ("&verifier!AVrfpThreadTable");

    if (CrtListHeadAddress == 0 ) {

        dprintf ("Unable read thread table (verifier!AVrfpThreadTable))\n");
        return;
    }

    for (CrtListIndex = 0; CrtListIndex < ThreadTableLength; CrtListIndex += 1, CrtListHeadAddress += 2 * PtrSize) {

        if (CheckControlC()) {

            break;
        }

        //
        // Read the first Flink from the list.
        //

        if (ReadPtr (CrtListHeadAddress, &Flink) != S_OK) {

            dprintf ("Cannot read list head from %p\n",
                     CrtListHeadAddress);
            continue;
        }

        //
        // Parse all the elements of this list.
        //

        Continue = TRUE;

        while (Flink != CrtListHeadAddress) {

            if (CheckControlC()) {

                Continue = FALSE;
                break;
            }

            if (InitTypeRead(Flink, verifier!_AVRF_THREAD_ENTRY)) {

                dprintf ("Error: cannot read verifier thread structure from %p\n",
                        Flink);
                break;
            }

            ThreadId = ReadField (Id);
    
            if (UserThreadId == 0 || UserThreadId == ThreadId) {

                ThreadStartAddress = ReadField (Function);

                if (ThreadStartAddress != 0) {

                    GetSymbol (ThreadStartAddress, Symbol, &Displacement);
                    ThreadParameter = ReadField (Parameter);
                    ThreadParentId = ReadField (ParentThreadId);
                    ThreadStackSize = ReadField (StackSize);
                    ThreadCreationFlags = ReadField (CreationFlags);
                }

                DumpedThreads += 1;

                dprintf (SeparatorString);
                dprintf ("Thread ID = 0x%X\n", (ULONG)ThreadId);
                
                if (ThreadStartAddress == 0) {

                    dprintf ("Initial thread\n");
                }
                else {

                    dprintf ("Parent thread ID = 0x%X\n", (ULONG)ThreadParentId);
                    
                    if (Displacement != 0) {

                        dprintf ("Start address = 0x%p: %s+0x%I64X\n", 
                                ThreadStartAddress,
                                Symbol,
                                Displacement);
                    }
                    else {

                        dprintf ("Start address = 0x%p: %s\n", 
                                ThreadStartAddress,
                                Symbol);
                    }

                    if (ThreadParameter != 0) {

                        dprintf ("Parameter = 0x%p\n", ThreadParameter);
                    }

                    if (ThreadStackSize != 0) {

                        dprintf ("Stack size specified by parent = 0x%p\n", ThreadStackSize);
                    }

                    if (ThreadCreationFlags != 0) {

                        dprintf ("CreateThread flags specified by parent = 0x%X\n", (ULONG)ThreadCreationFlags);
                    }
                }
            }

            //
            // Go to the next thread.
            //

            if (ReadPtr (Flink, &Flink) != S_OK) {

                dprintf ("Cannot read next list element address from %p\n",
                         Flink);
                break;
            }
        }

        if (Continue == FALSE) {

            break;
        }
    }

    dprintf (SeparatorString);
    dprintf ("Number of threads displayed: 0x%X\n", DumpedThreads);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// Call tracker querying
/////////////////////////////////////////////////////////////////////

//
// This codes are defined in \nt\base\win32\verifier\tracker.h
//
                                         
#define TRACK_HEAP_ALLOCATE             1
#define TRACK_HEAP_REALLOCATE           2
#define TRACK_HEAP_FREE                 3
#define TRACK_VIRTUAL_ALLOCATE          4
#define TRACK_VIRTUAL_FREE              5
#define TRACK_VIRTUAL_PROTECT           6
#define TRACK_MAP_VIEW_OF_SECTION       7
#define TRACK_UNMAP_VIEW_OF_SECTION     8
#define TRACK_EXIT_PROCESS              9
#define TRACK_TERMINATE_THREAD          10
#define TRACK_SUSPEND_THREAD            11

ULONG64 VrfThreadTrackerAddress;
ULONG64 VrfHeapTrackerAddress;
ULONG64 VrfVspaceTrackerAddress;

LOGICAL
VrfDetectTrackerAddresses (
    VOID
    )
{
    ULONG64 SymbolAddress;

    SymbolAddress = GetExpression ("verifier!AVrfThreadTracker");

    if (!ReadPointer (SymbolAddress, &VrfThreadTrackerAddress) != S_OK) {
        dprintf( "Error: cannot read pointer at verifier!AVrfThreadTracker \n" );
        return FALSE;
    }

    SymbolAddress = GetExpression ("verifier!AVrfHeapTracker");

    if (!ReadPointer (SymbolAddress, &VrfHeapTrackerAddress) != S_OK) {
        dprintf( "Error: cannot read pointer at verifier!AVrfHeapTracker \n" );
        return FALSE;
    }

    SymbolAddress = GetExpression ("verifier!AVrfVspaceTracker");

    if (!ReadPointer (SymbolAddress, &VrfVspaceTrackerAddress) != S_OK) {
        dprintf( "Error: cannot read pointer at verifier!AVrfVspaceTracker \n" );
        return FALSE;
    }

    return TRUE;
}


LOGICAL
VrfCallTrackerHeapSearchFilter (
    ULONG64 SearchAddress,
    PULONG64 Info
    )
{
    if (Info[4] == TRACK_HEAP_ALLOCATE) {
        if (Info[0] <= SearchAddress && SearchAddress < Info[0] + Info[1]) {
            return TRUE;
        }
    }
    else if (Info[4] == TRACK_HEAP_FREE) {
        if (Info[0] == SearchAddress) {
            return TRUE;
        }
    }
    else if (Info[4] == TRACK_HEAP_REALLOCATE) {
        if (Info[1] <= SearchAddress && SearchAddress < Info[1] + Info[2]) {
            return TRUE;
        }

        if (Info[0] == SearchAddress) {
            return TRUE;
        }
    }
    
    return FALSE;
}


LOGICAL
VrfCallTrackerVspaceSearchFilter (
    ULONG64 SearchAddress,
    PULONG64 Info
    )
{
    if (Info[4] == TRACK_VIRTUAL_ALLOCATE || Info[4] == TRACK_MAP_VIEW_OF_SECTION ) {
        if (Info[0] <= SearchAddress && SearchAddress < Info[0] + Info[1]) {
            return TRUE;
        }
    }
    else {
        if (Info[0] == SearchAddress) {
            return TRUE;
        }
    }
    
    return FALSE;
}


LOGICAL
VrfCallTrackerSearchFilter (
    ULONG64 TrackerAddress,
    ULONG64 SearchAddress,
    PULONG64 Info
    )
{
    if (TrackerAddress == VrfThreadTrackerAddress) {

        return FALSE;
    }
    else if (TrackerAddress == VrfHeapTrackerAddress) {

        return VrfCallTrackerHeapSearchFilter (SearchAddress, Info);
    }
    else if (TrackerAddress == VrfVspaceTrackerAddress) {

        return VrfCallTrackerVspaceSearchFilter (SearchAddress, Info);
    }
    else {

        dprintf ("Error: unrecognized call tracker address %p \n", TrackerAddress);
        return FALSE;
    }
    
    return FALSE;
}


PCHAR 
VrfCallTrackerEntryName (
    ULONG64 Type
    )
{
    switch (Type) {
        case TRACK_HEAP_ALLOCATE: return "HeapAlloc";
        case TRACK_HEAP_REALLOCATE: return "HeapReAlloc";
        case TRACK_HEAP_FREE: return "HeapFree";
        case TRACK_VIRTUAL_ALLOCATE: return "VirtualAlloc";
        case TRACK_VIRTUAL_FREE: return "VirtualFree";
        case TRACK_VIRTUAL_PROTECT: return "VirtualProtect";
        case TRACK_MAP_VIEW_OF_SECTION: return "MapView";
        case TRACK_UNMAP_VIEW_OF_SECTION: return "UnmapView";
        case TRACK_EXIT_PROCESS: return "ExitProcess";
        case TRACK_TERMINATE_THREAD: return "TerminateThread";
        case TRACK_SUSPEND_THREAD: return "SuspendThread";
        default: return "unknown!";
    }
}


LOGICAL
VrfQueryCallTracker (
    ULONG64 TrackerAddress,
    ULONG64 SearchAddress,
    ULONG64 LastEntries
    )
{
    ULONG64 TrackerSize;
    ULONG64 TrackerIndex;
    ULONG EntriesOffset;
    ULONG Result;
    ULONG EntrySize;
    ULONG64 EntryAddress;
    ULONG64 Index;
    ULONG64 EntryInfo[5];
    ULONG64 EntryTraceDepth;
    ULONG TraceOffset;
    LOGICAL FullTracker = FALSE;
    LOGICAL FoundEntry = FALSE;
    LOGICAL AtLeastOneEntry = FALSE;
    ULONG PvoidSize;
    ULONG64 ReturnAddress;
    ULONG I;
    CHAR Symbol [1024];
    ULONG64 Displacement;

    //
    // Read all type sizes and field offsets required to traverse the call tracker.
    //

    if (InitTypeRead (TrackerAddress, verifier!_AVRF_TRACKER)) {
        dprintf("Error: failed to read type verifier!_AVRF_TRACKER @ %p\n", TrackerAddress);
        return FALSE;
    }

    TrackerSize = ReadField (Size);
    TrackerIndex = ReadField (Index);

    if (GetFieldOffset ("verifier!_AVRF_TRACKER", "Entry", &EntriesOffset) != S_OK) {
        dprintf("Error: failed to get offset of `Entry' in type verifier!_AVRF_TRACKER\n");
        return FALSE;
    }

    if (GetFieldOffset ("verifier!_AVRF_TRACKER_ENTRY", "Trace", &TraceOffset) != S_OK) {
        dprintf("Error: failed to get offset of `Trace' in type verifier!_AVRF_TRACKER_ENTRY\n");
        return FALSE;
    }

    EntrySize = GetTypeSize ("verifier!_AVRF_TRACKER_ENTRY");

    if (EntrySize == 0) {
        dprintf("Error: failed to get size of type verifier!_AVRF_TRACKER_ENTRY\n");
        return FALSE;
    }

    PvoidSize = IsPtr64() ? 8 : 4;
    
    //
    // Figure out how many valid entries are in the tracker.
    //

    if (TrackerIndex == 0) {
            
        dprintf ("The tracker has zero entries. \n");
            return TRUE;
    }

    if (SearchAddress != 0) {
        
        if (TrackerIndex < TrackerSize) {
            dprintf ("Searching call tracker @ %p with %I64u valid entries ... \n", 
                     TrackerAddress, TrackerIndex);
        }
        else {
            dprintf ("Searching call tracker @ %p with %I64u valid entries ... \n", 
                     TrackerAddress, TrackerSize);

            FullTracker = TRUE;
        }
    }
    else {

        if (TrackerIndex < TrackerSize) {

            dprintf ("Dumping last %I64u entries from tracker @ %p with %I64u valid entries ... \n", 
                     LastEntries, TrackerAddress, TrackerIndex);
        }
        else {
            dprintf ("Dumping last %I64u entries from tracker @ %p with %I64u valid entries ... \n", 
                     LastEntries, TrackerAddress, TrackerSize);

            FullTracker = TRUE;
        }
    }

    //
    // Compute last entry in the call tracker.
    //

    EntryAddress = TrackerAddress + EntriesOffset + EntrySize * TrackerIndex;

    //
    // Start a loop iterating in reverse all tracker entries from the 
    // most recent to the oldest one logged 
    //

    for (Index = 0; Index < TrackerSize; Index += 1) {
        
        //
        // Check for user interruption.
        //

        if (CheckControlC ()) {
            dprintf ("Search interrupted. \n");
            break;
        }

        //
        // If we have already printed the last N entries stop.
        //

        if (SearchAddress == 0) {
            if (Index >= LastEntries) {
                break;
            }
        }
        
        //
        // Read the current tracker entry.
        //

        if (InitTypeRead (EntryAddress, verifier!_AVRF_TRACKER_ENTRY)) {
            dprintf("Error: failed to read type verifier!_AVRF_TRACKER_ENTRY @ %p\n", EntryAddress);
            return FALSE;
        }

        EntryInfo[0] = ReadField (Info[0]);
        EntryInfo[1] = ReadField (Info[1]);
        EntryInfo[2] = ReadField (Info[2]);
        EntryInfo[3] = ReadField (Info[3]);
        EntryInfo[4] = ReadField (Type);
        
        EntryTraceDepth = ReadField (TraceDepth);

        FoundEntry = TRUE;

        //
        // If we are searching for an address and the current entry
        // does not satisfy the search condition then move on.
        //

        if (SearchAddress != 0) {
            if (VrfCallTrackerSearchFilter(TrackerAddress, SearchAddress, EntryInfo) == FALSE) {
                FoundEntry = FALSE;
            }
        }

        //
        // Dump the tracker entry.
        //

        if (FoundEntry) {
            
            dprintf ("-------------------------------------------------------------- \n"
                     "%s: %I64X %I64X %I64X %I64X \n\n",
                     VrfCallTrackerEntryName (EntryInfo[4]),
                     EntryInfo[0],
                     EntryInfo[1],
                     EntryInfo[2],
                     EntryInfo[3]);

            for (I = 0; I < EntryTraceDepth; I += 1) {
                
                ReturnAddress = 0;
                ReadPointer (EntryAddress + TraceOffset + I * PvoidSize, &ReturnAddress);
                GetSymbol (ReturnAddress, Symbol, &Displacement);
                dprintf ("\t%p: %s+0x%I64X\n", ReturnAddress, Symbol, Displacement );
            }

            AtLeastOneEntry = TRUE;
        }

        //
        // Move to the previous tracker entry.
        //

        if (FullTracker) {
            
            if (TrackerIndex > 0) {
                TrackerIndex -= 1;
            }
            else {
                TrackerIndex = TrackerSize - 1;
            }
        }
        else {

            if (TrackerIndex == 1) {
                break;
            }
            else {
                TrackerIndex -= 1;
            }
        }

        EntryAddress = TrackerAddress + EntriesOffset + EntrySize * TrackerIndex;
    }

    //
    // If we searched for an address and did not find any print a sorry message.
    //

    if (SearchAddress != 0 && AtLeastOneEntry == FALSE) {
        dprintf ("No entries found. \n");
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Symbol checking
/////////////////////////////////////////////////////////////////////

#define CHECK_NAME(Name, Dll) {                                             \
        if (GetExpression(Name) == 0) {                                     \
            dprintf ("Failed to resolve `%s' to an address. \n", Name);     \
            Result = FALSE;                                                 \
            *DllName = Dll;                                                 \
            goto Exit;                                                      \
        }                                                                   \
    }

#define CHECK_TYPE(Name, Dll) {                                             \
        if (GetTypeSize(Name) == 0) {                                       \
            dprintf ("No type information found for `%s'. \n", Name);       \
            Result = FALSE;                                                 \
            *DllName = Dll;                                                 \
            goto Exit;                                                      \
        }                                                                   \
    }

LOGICAL
VrfCheckSymbols (
    PCHAR * DllName
    )
{
    LOGICAL Result = TRUE;

    CHECK_TYPE ("ntdll!_PEB", "ntdll.dll");

    if (VrfPebAddress() == 0) {

        dprintf ("Failed to get the address of the PEB structure.\n");
        *DllName = "ntdll.dll";
        return FALSE;
    }

    if (VrfVerifierGlobalFlagSet() == FALSE) {

        dprintf ("Application verifier is not enabled for this process.\n"
                 "Use appverif.exe tool to enable it. \n");
        *DllName = NULL;
        return FALSE;
    }

    //
    // ntdll.dll variables
    //

    CHECK_NAME ("ntdll!RtlpStackTraceDataBase", "ntdll.dll");
    CHECK_NAME ("ntdll!AVrfpVerifierFlags", "ntdll.dll");

    //
    // ntdll.dll types
    //

    CHECK_TYPE ("ntdll!_RTL_CRITICAL_SECTION", "ntdll.dll");
    CHECK_TYPE ("ntdll!_RTL_CRITICAL_SECTION_DEBUG", "ntdll.dll");
    CHECK_TYPE ("ntdll!_RTL_STACK_TRACE_ENTRY", "ntdll.dll");
    CHECK_TYPE ("ntdll!_STACK_TRACE_DATABASE", "ntdll.dll");
    CHECK_TYPE ("ntdll!_DPH_HEAP_ROOT", "ntdll.dll");
    CHECK_TYPE ("ntdll!_DPH_HEAP_BLOCK", "ntdll.dll");
    CHECK_TYPE ("ntdll!_DPH_BLOCK_INFORMATION", "ntdll.dll");
    CHECK_TYPE ("ntdll!ULONG_PTR", "ntdll.dll");
    CHECK_TYPE ("ntdll!_UNICODE_STRING", "ntdll.dll");
    CHECK_TYPE ("ntdll!_PEB", "ntdll.dll");
    CHECK_TYPE ("ntdll!_PEB_LDR_DATA", "ntdll.dll");
    CHECK_TYPE ("ntdll!_LDR_DATA_TABLE_ENTRY", "ntdll.dll");

    //
    // verifier.dll types
    //

    CHECK_TYPE ("verifier!_AVRF_EXCEPTION_LOG_ENTRY", "verifier.dll");
    CHECK_TYPE ("verifier!_AVRF_DEADLOCK_GLOBALS", "verifier.dll");
    CHECK_TYPE ("verifier!_AVRF_DEADLOCK_RESOURCE", "verifier.dll");
    CHECK_TYPE ("verifier!_AVRF_DEADLOCK_NODE", "verifier.dll");
    CHECK_TYPE ("verifier!_AVRF_DEADLOCK_THREAD", "verifier.dll");
    CHECK_TYPE ("verifier!_AVRF_THREAD_ENTRY", "verifier.dll");
    CHECK_TYPE ("verifier!_AVRF_TRACKER", "verifier.dll");
    CHECK_TYPE ("verifier!_AVRF_TRACKER_ENTRY", "verifier.dll");

    //
    // Cache some addresses we may need.
    //

    VrfDetectTrackerAddresses ();

    Exit:

    //
    // On WinXP !avrf does not work with retail symbols because they do
    // not have the type information required. This has been fixed in .NET using
    // the ntdllsym/verifiersym solution. 
    //

    if (Result == FALSE && WinXpClient == TRUE) {
        dprintf ("\nThis extension requires symbols with type information \n"
                 "for ntdll.dll and verifier.dll. \n\n");
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\pci.h ===
/*++

Module Name:

    pci.h

Abstract:

    This is the PCI bus specific header file used by device drivers.

Author:

Revision History:

--*/

#ifndef _PCI_
#define _PCI_


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

// end_wdm end_ntminiport end_ntndis

        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;

// begin_wdm begin_ntminiport begin_ntndis

    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_VPD               0x03
#define PCI_CAPABILITY_ID_SLOT_ID           0x04
#define PCI_CAPABILITY_ID_MSI               0x05
#define PCI_CAPABILITY_ID_CPCI_HOTSWAP      0x06
#define PCI_CAPABILITY_ID_PCIX              0x07
#define PCI_CAPABILITY_ID_HYPERTRANSPORT    0x08
#define PCI_CAPABILITY_ID_VENDOR_SPECIFIC   0x09
#define PCI_CAPABILITY_ID_DEBUG_PORT        0x0A
#define PCI_CAPABILITY_ID_CPCI_RES_CTRL     0x0B
#define PCI_CAPABILITY_ID_SHPC              0x0C
#define PCI_CAPABILITY_ID_AGP_TARGET        0x0E

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capabilities
//
typedef struct _PCI_AGP_CAPABILITY {
    
    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Agp3Mode:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   HostTransDisable:1;
        ULONG   Gart64:1;
        ULONG   ITA_Coherent:1;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   CalibrationCycle:3;
        ULONG   AsyncRequestSize:3;
        ULONG   Rsvd1:1;
        ULONG   Isoch:1;
        ULONG   Rsvd2:6;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:1;
        ULONG   Gart64:1;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   CalibrationCycle:3;
        ULONG   AsyncReqSize:3;
        ULONG   Rsvd3:8;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

//
// An AGPv3 Target must have an extended capability,
// but it's only present for a Master when the Isoch
// bit is set in its status register
//
typedef enum _EXTENDED_AGP_REGISTER {
    IsochStatus,
    AgpControl,
    ApertureSize,
    AperturePageSize,
    GartLow,
    GartHigh,
    IsochCommand
} EXTENDED_AGP_REGISTER, *PEXTENDED_AGP_REGISTER;

typedef struct _PCI_AGP_ISOCH_STATUS {
    ULONG ErrorCode: 2;
    ULONG Rsvd1: 1;
    ULONG Isoch_L: 3;
    ULONG Isoch_Y: 2;
    ULONG Isoch_N: 8;
    ULONG Rsvd2: 16;
} PCI_AGP_ISOCH_STATUS, *PPCI_AGP_ISOCH_STATUS;

typedef struct _PCI_AGP_CONTROL {
    ULONG Rsvd1: 7;
    ULONG GTLB_Enable: 1;
    ULONG AP_Enable: 1;
    ULONG CAL_Disable: 1;
    ULONG Rsvd2: 22;
} PCI_AGP_CONTROL, *PPCI_AGP_CONTROL;

typedef struct _PCI_AGP_APERTURE_PAGE_SIZE {
    USHORT PageSizeMask: 11;
    USHORT Rsvd1: 1;
    USHORT PageSizeSelect: 4;
} PCI_AGP_APERTURE_PAGE_SIZE, *PPCI_AGP_APERTURE_PAGE_SIZE;

typedef struct _PCI_AGP_ISOCH_COMMAND {
    USHORT Rsvd1: 6;
    USHORT Isoch_Y: 2;
    USHORT Isoch_N: 8;
} PCI_AGP_ISOCH_COMMAND, *PPCI_AGP_ISOCH_COMMAND;

typedef struct PCI_AGP_EXTENDED_CAPABILITY {

    PCI_AGP_ISOCH_STATUS IsochStatus;

//
// Target only ----------------<<-begin->>
//
    PCI_AGP_CONTROL AgpControl;
    USHORT ApertureSize;
    PCI_AGP_APERTURE_PAGE_SIZE AperturePageSize;
    ULONG GartLow;
    ULONG GartHigh;
//
// ------------------------------<<-end->>
//

    PCI_AGP_ISOCH_COMMAND IsochCommand;

} PCI_AGP_EXTENDED_CAPABILITY, *PPCI_AGP_EXTENDED_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  PerVectorMaskCapable:1;
         USHORT  Reserved:7;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG Reserved:2;              // always zero, DWORD aligned address
               ULONG Address:30;
            } Register;
            ULONG Raw;
      } MessageAddressLower;

      //
      // This is only valid if CapableOf64Bits is 1.
      //

      union {
          struct {
              USHORT    MessageData;
          } Option32Bit;
          struct {
              ULONG     MessageAddressUpper;
              USHORT    MessageData;
              USHORT    Reserved;
              ULONG     MaskBits;
              ULONG     PendingBits;
          } Option64Bit;
      };

} PCI_MSI_CAPABILITY, *PPCI_MSI_CAPABILITY;

//
// MSI-X (Message Signalled Interrupts eXtended) Capability
//

typedef struct {

      PCI_CAPABILITIES_HEADER Header;

      struct {
          USHORT TableSize:11;
          USHORT Reserved:4;
          USHORT MSIXEnable:1;
      } MessageControl;

      ULONG     MessageAddressUpper;
      
      struct {
          ULONG BaseIndexRegister:3;
          ULONG TableOffset:29;
      } BIR_Offset;

} PCI_MSIX_CAPABILITY, *PPCI_MSIX_CAPABILITY;

typedef struct {

    ULONG   Pending:1;
    ULONG   Mask:1;
    ULONG   MessageAddressLower:30;

} PCI_MSIX_TABLE_ENTRY, *PPCI_MSIX_TABLE_ENTRY;

typedef struct {

    PCI_CAPABILITIES_HEADER Header;

    union {
        struct {
            USHORT  DataParityErrorRecoveryEnable:1;
            USHORT  EnableRelaxedOrdering:1;
            USHORT  MaxMemoryReadByteCount:2;
            USHORT  MaxOutstandingSplitTransactions:3;
            USHORT  Reserved:9;
        } bits;
        USHORT  AsUSHORT;
    } Command;

    union {
        struct {
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Device64Bit:1;
            ULONG   Capable133MHz:1;
            ULONG   SplitCompletionDiscarded:1;
            ULONG   UnexpectedSplitCompletion:1;
            ULONG   DeviceComplexity:1;
            ULONG   DesignedMaxMemoryReadByteCount:2;
            ULONG   DesignedMaxOutstandingSplitTransactions:3;
            ULONG   DesignedMaxCumulativeReadSize:3;
            ULONG   ReceivedSplitCompletionErrorMessage:1;
            ULONG   Reserved:2;
        } bits;
        ULONG   AsULONG;
    } Status;
} PCI_X_CAPABILITY, *PPCI_X_CAPABILITY;

//
// AMD HyperTransport (TM) Capabilities structure
//

typedef enum {
    HTSlavePrimary = 0,
    HTHostSecondary,
    HTReserved1,
    HTReserved2,
    HTInterruptDiscoveryConfig,
    HTAddressMapping,
    HTReserved3,
    HTReserved4
} PCI_HT_CapabilitiesType, *PPCI_HT_CapabilitiesType;

typedef struct {
    USHORT  Reserved1:1;
    USHORT  CFlE:1;
    USHORT  CST:1;
    USHORT  CFE:1;
    USHORT  LkFail:1;
    USHORT  Init:1;
    USHORT  EOC:1;
    USHORT  TXO:1;
    USHORT  CRCError:4;
    USHORT  IsocEn:1;
    USHORT  LSEn:1;
    USHORT  ExtCTL:1;
    USHORT  Reserved2:1;
} PCI_HT_LinkControl, *PPCI_HT_LinkControl;

typedef struct {
    USHORT  MaxLinkWidthIn:3;
    USHORT  DwFlowControlIn:1;
    USHORT  MaxLinkWidthOut:3;
    USHORT  DwFlowControlOut:1;
    USHORT  LinkWidthIn:3;
    USHORT  DwFlowControlInEn:1;
    USHORT  LinkWidthOut:3;
    USHORT  DwFlowControlOutEn:1;
} PCI_HT_LinkConfig, *PPCI_HT_LinkConfig;

typedef enum {
    HTMaxLinkWidth8bits = 0,
    HTMaxLinkWidth16bits,
    HTMaxLinkWidthResevered1,
    HTMaxLinkWidth32bits,
    HTMaxLinkWidth2bits,
    HTMaxLinkWidth4bits,
    HTMaxLinkWidthResevered2,
    HTMaxLinkWidthNotConnected
} PCI_HT_MaxLinkWidth, *PPCI_HT_MaxLinkWidth;

typedef struct {
    UCHAR   MinorRev:4;
    UCHAR   MajorRev:4;
} PCI_HT_RevisionID, *PPCI_HT_RevisionID;

typedef enum {
    HTFreq200MHz = 0,
    HTFreq300MHz,
    HTFreq400MHz,
    HTFreq500MHz,
    HTFreq600MHz,
    HTFreq800MHz,
    HTFreq1000MHz,
    HTFreqReserved,
    HTFreqVendorDefined
} PCI_HT_Frequency, *PPCI_HT_Frequency;

typedef struct {
    UCHAR   LinkFrequency:4;    // use PCI_HT_Frequency
    UCHAR   ProtocolError:1;
    UCHAR   OverflowError:1;
    UCHAR   EndOfChainError:1;
    UCHAR   CTLTimeout:1;
} PCI_HT_Frequency_Error, *PPCI_HT_Frequency_Error;

typedef struct {
    UCHAR  IsocMode:1;
    UCHAR  LDTSTOP:1;
    UCHAR  CRCTestMode:1;
    UCHAR  ExtendedCTLTimeReq:1;
    UCHAR  Reserved:4;
} PCI_HT_FeatureCap, *PPCI_HT_FeatureCap;


typedef struct {
  UCHAR  ExtendedRegisterSet:1;
  UCHAR  Reserved:7; 
} PCI_HT_FeatureCap_Ex, *PPCI_HT_FeatureCap_Ex;

typedef struct {
    USHORT  ProtFloodEn:1;
    USHORT  OverflowFloodEn:1;
    USHORT  ProtFatalEn:1;
    USHORT  OverflowFatalEn:1;
    USHORT  EOCFatalEn:1;
    USHORT  RespFatalEn:1;
    USHORT  CRCFatalEn:1;
    USHORT  SERRFataEn:1;
    USHORT  ChainFail:1;
    USHORT  ResponseError:1;
    USHORT  ProtNonFatalEn:1;
    USHORT  OverflowNonFatalEn:1;
    USHORT  EOCNonFatalEn:1;
    USHORT  RespNonFatalEn:1;
    USHORT  CRCNonFatalEn:1;
    USHORT  SERRNonFatalEn:1;
} PCI_HT_ErrorHandling, *PPCI_HT_ErrorHandling;

typedef struct {
    USHORT  Reserved1;
    UCHAR   LastInterrupt;
    UCHAR   Reserved2;
} PCI_HT_INTERRUPT_INDEX_1, *PPCI_HT_INTERRUPT_INDEX_1;

typedef struct {
    
    struct {
        ULONG   Mask:1;
        ULONG   Polarity:1;
        ULONG   MessageType:3;
        ULONG   RequestEOI:1;
        ULONG   Reserved:26;
    } LowPart;

    struct {
        ULONG   Reserved:30;
        ULONG   PassPW:1;
        ULONG   WaitingForEOI:1;
    } HighPart;

} PCI_HT_INTERRUPT_INDEX_N, *PPCI_HT_INTERRUPT_INDEX_N;

typedef struct {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Offset 2
    //
    
    union {
        struct {
            USHORT  Reserved:12;
            USHORT  DropOnUnitinit:1;
            USHORT  CapabilityType:3; // use PCI_HT_CapabilitiesType
        } Generic;

        struct {
            USHORT  BaseUnitID:5;
            USHORT  UnitCount:5;
            USHORT  MasterHost:1;
            USHORT  DefaultDirection:1;
            USHORT  DropOnUnitinit:1;
            USHORT  CapabilityType:3; // use PCI_HT_CapabilitiesType
        } SlavePrimary;

        struct {
            USHORT  WarmReset:1;
            USHORT  DoubleEnded:1;
            USHORT  DeviceNumber:5;
            USHORT  ChainSide:1;
            USHORT  HostHide:1;
            USHORT  Rsv:1;
            USHORT  ActAsSlave:1;
            USHORT  InboundEOCError:1;
            USHORT  DropOnUnitinit:1;
            USHORT  CapabilityType:3; // use PCI_HT_CapabilitiesType
        } HostSecondary;

        struct {
            USHORT  Index:8;
            USHORT  Reserved:5;
            USHORT  CapabilityType:3; // use PCI_HT_CapabilitiesType
        } Interrupt;

    } Command;

    //
    // Offset 4
    //
    
    union {
        
        struct {

            PCI_HT_LinkControl  LinkControl_0;
            PCI_HT_LinkConfig   LinkConfig_0;
        };

        ULONG DataPort;     // Interrupt DataPort
    };
    
    //
    // Offset 8
    //

    union {

        struct {
            
            // Offset 0x8
            PCI_HT_LinkControl      LinkControl_1;
            PCI_HT_LinkConfig       LinkConfig_1;
            // Offset 0xc
            PCI_HT_RevisionID       RevisionID;
            // Offset 0xd
            PCI_HT_Frequency_Error  FreqErr_0;
            // Offset 0xe
            USHORT                  LinkFreqCap_0;
            // Offset 0x10
            PCI_HT_FeatureCap       FeatureCap;
            // Offset 0x11
            PCI_HT_Frequency_Error  FreqErr_1;
            // Offset 0x12
            USHORT                  LinkFreqCap_1;
            // Offset 0x14
            USHORT                  EnumerationScratchpad;
            // Offset 0x16
            PCI_HT_ErrorHandling    ErrorHandling;
            // Offset 0x18
            UCHAR                   MemoryBaseUpper8Bits;
            // Offset 0x19          
            UCHAR                   MemoryLimitUpper8Bits;
            // Offset 0x20
            USHORT                  Reserved;

        } SlavePrimary;

        struct {
            
            // Offset 0x8
            PCI_HT_RevisionID       RevisionID;
            // Offset 0x9
            PCI_HT_Frequency_Error  FreqErr_0;
            // Offset 0xa
            USHORT                  LinkFreqCap_0;
            // Offset 0xc
            PCI_HT_FeatureCap       FeatureCap;
            PCI_HT_FeatureCap_Ex    FeatureCapEx;
            // Offset 0xe
            USHORT                  Reserved1;
            // Offset 0x10
            USHORT                  EnumerationScratchpad;
            // Offset 0x12
            PCI_HT_ErrorHandling    ErrorHandling;
            // Offset 0x14
            UCHAR                   MemoryBaseUpper8Bits;
            // Offset 0x15
            UCHAR                   MemoryLimitUpper8Bits;
            // Offset 0x16
            USHORT                  Reserved2;

        } HostSecondary;
    };
} PCI_HT_CAPABILITY, *PPCI_HT_CAPABILITY;


// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBLCASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05

// Class 0d - PCI_CLASS_WIRELESS_CTLR

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

// Class 0e - PCI_CLASS_INTELLIGENT_IO_CTLR

#define PCI_SUBCLASS_INTIO_I2O              0x00

// Class 0f - PCI_CLASS_SATELLITE_CTLR

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

// Class 10 - PCI_CLASS_ENCRYPTION_DECRYPTION

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

// Class 11 - PCI_CLASS_DATA_ACQ_SIGNAL_PROC

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80



// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_wdm end_ntminiport

// end_ntddk end_ntosp

//
// PCI_REGISTRY_INFO - this structure is passed into the HAL from
// the firmware.  It signifies how many PCI bus(es) are present and
// what style of access the PCI bus(es) support.
//

typedef struct _PCI_REGISTRY_INFO {
    UCHAR       MajorRevision;
    UCHAR       MinorRevision;
    UCHAR       NoBuses;
    UCHAR       HardwareMechanism;
} PCI_REGISTRY_INFO, *PPCI_REGISTRY_INFO;

//
// PCI definitions for IOBase & IOLimit
// PCIBridgeIO2Base(a,b)  - convert IOBase  & IOBaseUpper16 to ULONG IOBase
// PCIBridgeIO2Limit(a,b) - convert IOLimit & IOLimitUpper6 to ULONG IOLimit
//

#define PciBridgeIO2Base(a,b)   \
        ( ((a >> 4) << 12) + (((a & 0xf) == 1) ? (b << 16) : 0) )

#define PciBridgeIO2Limit(a,b)  (PciBridgeIO2Base(a,b) | 0xfff)

#define PciBridgeMemory2Base(a)  (ULONG) ((a & 0xfff0) << 16)
#define PciBridgeMemory2Limit(a) (PciBridgeMemory2Base(a) | 0xfffff)

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1/2.BridgeControl
//

#define PCI_ENABLE_BRIDGE_PARITY_ERROR        0x0001
#define PCI_ENABLE_BRIDGE_SERR                0x0002
#define PCI_ENABLE_BRIDGE_ISA                 0x0004
#define PCI_ENABLE_BRIDGE_VGA                 0x0008
#define PCI_ENABLE_BRIDGE_MASTER_ABORT_SERR   0x0020
#define PCI_ASSERT_BRIDGE_RESET               0x0040

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1.BridgeControl
//

#define PCI_ENABLE_BRIDGE_FAST_BACK_TO_BACK   0x0080

//
// Bit encodes for PCI_COMMON_CONFIG.u.type2.BridgeControl
//

#define PCI_ENABLE_CARDBUS_IRQ_ROUTING        0x0080
#define PCI_ENABLE_CARDBUS_MEM0_PREFETCH      0x0100
#define PCI_ENABLE_CARDBUS_MEM1_PREFETCH      0x0200
#define PCI_ENABLE_CARDBUS_WRITE_POSTING      0x0400

//
//  Definitions needed for Access to Hardware Type 1
//

#define PCI_TYPE1_ADDR_PORT     (0xCF8)
#define PCI_TYPE1_DATA_PORT     0xCFC

typedef struct _PCI_TYPE1_CFG_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:7;
            ULONG   Enable:1;
        } bits;

        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_BITS, *PPCI_TYPE1_CFG_BITS;


//
//  Definitions needed for Access to Hardware Type 2
//

#define PCI_TYPE2_CSE_PORT              ((PUCHAR) 0xCF8)
#define PCI_TYPE2_FORWARD_PORT          ((PUCHAR) 0xCFA)
#define PCI_TYPE2_ADDRESS_BASE          0xC


typedef struct _PCI_TYPE2_CSE_BITS {
    union {
        struct {
            UCHAR   Enable:1;
            UCHAR   FunctionNumber:3;
            UCHAR   Key:4;
        } bits;
        UCHAR   AsUCHAR;
    } u;
} PCI_TYPE2_CSE_BITS, PPCI_TYPE2_CSE_BITS;


typedef struct _PCI_TYPE2_ADDRESS_BITS {
    union {
        struct {
            USHORT  RegisterNumber:8;
            USHORT  Agent:4;
            USHORT  AddressBase:4;
        } bits;
        USHORT  AsUSHORT;
    } u;
} PCI_TYPE2_ADDRESS_BITS, *PPCI_TYPE2_ADDRESS_BITS;


//
// Definitions for the config cycle format on the PCI bus.
//

typedef struct _PCI_TYPE0_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   Reserved2:21;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE0_CFG_CYCLE_BITS, *PPCI_TYPE0_CFG_CYCLE_BITS;

typedef struct _PCI_TYPE1_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:8;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_CYCLE_BITS, *PPCI_TYPE1_CFG_CYCLE_BITS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\mts.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mts.c

Abstract:

    MikeTs's little KD extension.

Author:

    Michael Tsang (mikets) 18-November-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "pcskthw.h"
#include "pci.h"
#include "pcip.h"
#pragma hdrstop

VOID PrintClassInfo(PBYTE  pb, DWORD dwReg);

VOID
PrintPciStatusReg(
    USHORT Status
    )
{
    if (Status & PCI_STATUS_CAPABILITIES_LIST) {
        dprintf("CapList ");
    }
    if (Status & PCI_STATUS_66MHZ_CAPABLE) {
        dprintf("66MHzCapable ");
    }
    if (Status & PCI_STATUS_UDF_SUPPORTED) {
        dprintf("UDFSupported ");
    }
    if (Status & PCI_STATUS_FAST_BACK_TO_BACK) {
        dprintf("FB2BCapable ");
    }
    if (Status & PCI_STATUS_DATA_PARITY_DETECTED) {
        dprintf("DataPERR ");
    }
    if (Status & PCI_STATUS_SIGNALED_TARGET_ABORT) {
        dprintf("TargetDevAbort ");
    }
    if (Status & PCI_STATUS_RECEIVED_TARGET_ABORT) {
        dprintf("TargetAbort ");
    }
    if (Status & PCI_STATUS_RECEIVED_MASTER_ABORT) {
        dprintf("InitiatorAbort ");
    }
    if (Status & PCI_STATUS_SIGNALED_SYSTEM_ERROR) {
        dprintf("SERR ");
    }
    if (Status & PCI_STATUS_DETECTED_PARITY_ERROR) {
        dprintf("PERR ");
    }
    if (Status & PCI_STATUS_DEVSEL) {
        dprintf("DEVSELTiming:%lx",(Status & PCI_STATUS_DEVSEL) >> 9);
    }
    dprintf("\n");
}

VOID
PrintPciBridgeCtrlReg(
    USHORT Bridge
    )
{
    PCI_BRIDBG_CTRL_REG bReg = *((PCI_BRIDBG_CTRL_REG *) &Bridge);

    if (bReg.PERRREnable) {
        dprintf("PERRREnable ");
    }
    if (bReg.SERREnable) {
        dprintf("SERREnable ");
    }
    if (bReg.ISAEnable) {
        dprintf("ISAEnable ");
    }
    if (bReg.MasterAbort) {
        dprintf("MasterAbort ");
    }
    if (bReg.CBRst) {
        dprintf("CBRst ");
    }
    if (bReg.IRQRoutingEnable) {
        dprintf("IRQRoutingEnable ");
    }
    if (bReg.Mem0Prefetch) {
        dprintf("Mem0Prefetch ");
    }
    if (bReg.Mem1Prefetch) {
        dprintf("Mem1Prefetch ");
    }
    if (bReg.WritePostEnable) {
        dprintf("WritePostEnable ");
    }
    dprintf("\n");
}

BOOL
PrintCommonConfigSpace(
    PCI_COMMON_CONFIG *pCmnCfg,
    PCHAR Pad
    )
{
    PCHAR pch = NULL;

    if (!Pad) {
        Pad = "";
    }

    dprintf("%s%02x: VendorID       %04lx ", Pad, CONFIG_OFFSET(VendorID), pCmnCfg->VendorID);
    dprintf("%s\n", ((pch = GetVendorDesc(pCmnCfg->VendorID, TRUE)) ? pch : ""));
    dprintf("%s%02x: DeviceID       %04lx\n", Pad, CONFIG_OFFSET(DeviceID), pCmnCfg->DeviceID);
    dprintf("%s%02x: Command        %04lx ", Pad, CONFIG_OFFSET(Command), pCmnCfg->Command);

    if (pCmnCfg->Command & PCI_ENABLE_IO_SPACE) {
        dprintf("IOSpaceEnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_MEMORY_SPACE) {
        dprintf("MemSpaceEnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_BUS_MASTER) {
        dprintf("BusInitiate ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_SPECIAL_CYCLES) {
        dprintf("SpecialCycle ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_WRITE_AND_INVALIDATE) {
        dprintf("MemWriteEnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_VGA_COMPATIBLE_PALETTE) {
        dprintf("VGASnoop ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_PARITY) {
        dprintf("PERREnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_WAIT_CYCLE) {
        dprintf("WaitCycle ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_SERR) {
        dprintf("SERREnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_FAST_BACK_TO_BACK) {
        dprintf("FB2BEnable ");
    }
    dprintf("\n");


    dprintf("%s%02x: Status         %04lx ", Pad, CONFIG_OFFSET(Status), pCmnCfg->Status);
    PrintPciStatusReg(pCmnCfg->Status);

    dprintf("%s%02x: RevisionID     %02lx\n%s%02x: ProgIF         %02lx",
            Pad,
            CONFIG_OFFSET(RevisionID),
            pCmnCfg->RevisionID,
            Pad,
            CONFIG_OFFSET(ProgIf),
            pCmnCfg->ProgIf);
    PrintClassInfo((PBYTE) pCmnCfg, CONFIG_OFFSET(ProgIf));

    dprintf("%s%02x: SubClass       %02lx", Pad, CONFIG_OFFSET(SubClass), pCmnCfg->SubClass);
    PrintClassInfo((PBYTE) pCmnCfg, CONFIG_OFFSET(SubClass));

    dprintf("%s%02x: BaseClass      %02lx", Pad, CONFIG_OFFSET(BaseClass), pCmnCfg->BaseClass);
    PrintClassInfo((PBYTE) pCmnCfg, CONFIG_OFFSET(BaseClass));

    dprintf("%s%02x: CacheLineSize  %04lx", Pad, CONFIG_OFFSET(CacheLineSize), pCmnCfg->CacheLineSize);

    if (pCmnCfg->CacheLineSize & 0xf0) {
        dprintf("BurstDisabled ");
    }
    if (pCmnCfg->CacheLineSize & 0xf) {
        dprintf("Burst4DW");
    }
    dprintf("\n");

    dprintf("%s%02x: LatencyTimer   %02lx\n",
            Pad,
            CONFIG_OFFSET(LatencyTimer),
            pCmnCfg->LatencyTimer);
    dprintf("%s%02x: HeaderType     %02lx\n",
            Pad,
            CONFIG_OFFSET(HeaderType),
            pCmnCfg->HeaderType);
    dprintf("%s%02x: BIST           %02lx\n",
            Pad,
            CONFIG_OFFSET(BIST),
            pCmnCfg->BIST);

    return TRUE;
}

BOOL
PrintCfgSpaceType0(
    PCI_COMMON_CONFIG *pCmnCfg,
    PCHAR Pad
    )
{
    int i;

    if (!Pad) {
        Pad = "";
    }

    for (i=0; i<PCI_TYPE0_ADDRESSES; ++i) {
        dprintf("%s%02x: BAR%x           %08lx\n", Pad,  TYPE0_OFFSET(BaseAddresses[i]), i, pCmnCfg->u.type0.BaseAddresses[i]);
    }

    dprintf("%s%02x: CBCISPtr       %08lx\n", Pad, TYPE0_OFFSET(CIS), pCmnCfg->u.type0.CIS);
    dprintf("%s%02x: SubSysVenID    %04lx\n", Pad, TYPE0_OFFSET(SubVendorID), pCmnCfg->u.type0.SubVendorID);
    dprintf("%s%02x: SubSysID       %04lx\n", Pad, TYPE0_OFFSET(SubSystemID), pCmnCfg->u.type0.SubSystemID);
    dprintf("%s%02x: ROMBAR         %08lx\n", Pad, TYPE0_OFFSET(ROMBaseAddress), pCmnCfg->u.type0.ROMBaseAddress);
    dprintf("%s%02x: CapPtr         %02lx\n", Pad, TYPE0_OFFSET(CapabilitiesPtr), pCmnCfg->u.type0.CapabilitiesPtr);
    dprintf("%s%02x: IntLine        %02lx\n", Pad, TYPE0_OFFSET(InterruptLine), pCmnCfg->u.type0.InterruptLine);
    dprintf("%s%02x: IntPin         %02lx\n", Pad, TYPE0_OFFSET(InterruptPin), pCmnCfg->u.type0.InterruptPin);
    dprintf("%s%02x: MinGnt         %02lx\n", Pad, TYPE0_OFFSET(MinimumGrant), pCmnCfg->u.type0.MinimumGrant);
    dprintf("%s%02x: MaxLat         %02lx\n", Pad, TYPE0_OFFSET(MaximumLatency), pCmnCfg->u.type0.MaximumLatency);

    return TRUE;
}

BOOL
PrintCfgSpaceType1(
    PCI_COMMON_CONFIG *pCmnCfg,
    PCHAR Pad
    )
{
    int i;

    if (!Pad) {
        Pad = "";
    }

    for (i=0; i<PCI_TYPE1_ADDRESSES; ++i) {
        dprintf("%s%02x: BAR%x           %08lx\n",
                Pad, CONFIG_OFFSET(u.type1.BaseAddresses[i]), i, pCmnCfg->u.type1.BaseAddresses[i]);
    }

    dprintf("%s%02x: PriBusNum      %02lx\n", Pad, TYPE1_OFFSET(PrimaryBus), pCmnCfg->u.type1.PrimaryBus);
    dprintf("%s%02x: SecBusNum      %02lx\n", Pad, TYPE1_OFFSET(SecondaryBus), pCmnCfg->u.type1.SecondaryBus);
    dprintf("%s%02x: SubBusNum      %02lx\n", Pad, TYPE1_OFFSET(SubordinateBus), pCmnCfg->u.type1.SubordinateBus);
    dprintf("%s%02x: SecLatencyTmr  %02lx\n", Pad, TYPE1_OFFSET(SecondaryLatency), pCmnCfg->u.type1.SecondaryLatency);
    dprintf("%s%02x: IOBase         %02lx\n", Pad, TYPE1_OFFSET(IOBase), pCmnCfg->u.type1.IOBase);
    dprintf("%s%02x: IOLimit        %02lx\n", Pad, TYPE1_OFFSET(IOLimit), pCmnCfg->u.type1.IOLimit);
    dprintf("%s%02x: SecStatus      %04lx ",Pad, TYPE1_OFFSET(SecondaryStatus), pCmnCfg->u.type1.SecondaryStatus);
    PrintPciStatusReg(pCmnCfg->u.type1.SecondaryStatus);

    dprintf("%s%02x: MemBase        %04lx\n", Pad, TYPE1_OFFSET(MemoryBase), pCmnCfg->u.type1.MemoryBase);
    dprintf("%s%02x: MemLimit       %04lx\n", Pad, TYPE1_OFFSET(MemoryLimit), pCmnCfg->u.type1.MemoryLimit);
    dprintf("%s%02x: PrefMemBase    %04lx\n", Pad, TYPE1_OFFSET(PrefetchBase), pCmnCfg->u.type1.PrefetchBase);
    dprintf("%s%02x: PrefMemLimit   %04lx\n", Pad, TYPE1_OFFSET(PrefetchLimit), pCmnCfg->u.type1.PrefetchLimit);
    dprintf("%s%02x: PrefBaseHi     %08lx\n", Pad, TYPE1_OFFSET(PrefetchBaseUpper32), pCmnCfg->u.type1.PrefetchBaseUpper32);
    dprintf("%s%02x: PrefLimitHi    %08lx\n", Pad, TYPE1_OFFSET(PrefetchLimitUpper32), pCmnCfg->u.type1.PrefetchLimitUpper32);
    dprintf("%s%02x: IOBaseHi       %04lx\n", Pad, TYPE1_OFFSET(IOBaseUpper16), pCmnCfg->u.type1.IOBaseUpper16);
    dprintf("%s%02x: IOLimitHi      %04lx\n", Pad, TYPE1_OFFSET(IOLimitUpper16), pCmnCfg->u.type1.IOLimitUpper16);
    dprintf("%s%02x: CapPtr         %02lx\n", Pad, TYPE1_OFFSET(CapabilitiesPtr), pCmnCfg->u.type1.CapabilitiesPtr);
    dprintf("%s%02x: ROMBAR         %08lx\n", Pad, TYPE1_OFFSET(ROMBaseAddress), pCmnCfg->u.type1.ROMBaseAddress);
    dprintf("%s%02x: IntLine        %02lx\n", Pad, TYPE1_OFFSET(InterruptLine), pCmnCfg->u.type1.InterruptLine);
    dprintf("%s%02x: IntPin         %02lx\n", Pad, TYPE1_OFFSET(InterruptPin), pCmnCfg->u.type1.InterruptPin);
    dprintf("%s%02x: BridgeCtrl     %04lx ", Pad, TYPE1_OFFSET(BridgeControl), pCmnCfg->u.type1.BridgeControl);
    PrintPciBridgeCtrlReg(pCmnCfg->u.type2.BridgeControl);

    return TRUE;
}

BOOL
PrintCfgSpaceType2(
    PCI_COMMON_CONFIG *pCmnCfg,
    PCHAR Pad
    )
{
    PPCI_TYPE2_HEADER_EXTRAS extras;
    ULONG extraOffset;

    if (!Pad) {
        Pad = "";
    }

    dprintf("%s%02x: RegBaseAddr    %08lx\n", Pad, TYPE2_OFFSET(SocketRegistersBaseAddress), pCmnCfg->u.type2.SocketRegistersBaseAddress);
    dprintf("%s%02x: CapPtr         %02lx\n", Pad, TYPE2_OFFSET(SocketRegistersBaseAddress), pCmnCfg->u.type2.CapabilitiesPtr);
    dprintf("%s%02x: SecStatus      %04lx ", Pad, TYPE2_OFFSET(SecondaryStatus), pCmnCfg->u.type2.SecondaryStatus);
    PrintPciStatusReg(pCmnCfg->u.type2.SecondaryStatus);

    dprintf("%s%02x: PCIBusNum      %02lx\n", Pad, TYPE2_OFFSET(PrimaryBus), pCmnCfg->u.type2.PrimaryBus);
    dprintf("%s%02x: CBBusNum       %02lx\n", Pad, TYPE2_OFFSET(SecondaryBus), pCmnCfg->u.type2.SecondaryBus);
    dprintf("%s%02x: SubBusNum      %02lx\n", Pad, TYPE2_OFFSET(SubordinateBus), pCmnCfg->u.type2.SubordinateBus);
    dprintf("%s%02x: CBLatencyTimer %02lx\n", Pad, TYPE2_OFFSET(SecondaryLatency), pCmnCfg->u.type2.SecondaryLatency);
    dprintf("%s%02x: MemBase0       %08lx\n", Pad, TYPE2_OFFSET(Range[0].Base), pCmnCfg->u.type2.Range[0].Base);
    dprintf("%s%02x: MemLimit1      %08lx\n", Pad, TYPE2_OFFSET(Range[1].Limit), pCmnCfg->u.type2.Range[1].Limit);
    dprintf("%s%02x: IOBase0        %08lx\n", Pad, TYPE2_OFFSET(Range[2].Base), pCmnCfg->u.type2.Range[2].Base);
    dprintf("%s%02x: IOLimit1       %08lx\n", Pad, TYPE2_OFFSET(Range[3].Limit), pCmnCfg->u.type2.Range[3].Limit);
    dprintf("%s%02x: IntLine        %02lx\n", Pad, TYPE2_OFFSET(InterruptLine), pCmnCfg->u.type2.InterruptLine);
    dprintf("%s%02x: IntPin         %02lx\n", Pad, TYPE2_OFFSET(InterruptPin), pCmnCfg->u.type2.InterruptPin);
    dprintf("%s%02x: BridgeCtrl     %04lx ", Pad, TYPE2_OFFSET(BridgeControl), pCmnCfg->u.type2.BridgeControl);
    PrintPciBridgeCtrlReg(pCmnCfg->u.type2.BridgeControl);

    extras =   (PPCI_TYPE2_HEADER_EXTRAS) ((PUCHAR) pCmnCfg + CONFIG_OFFSET(DeviceSpecific));

    extraOffset = CONFIG_OFFSET(DeviceSpecific);
    dprintf("%s%02x: SubSysVenID    %04lx\n", Pad, extraOffset, extras->SubVendorID);

    dprintf("%s%02x: SubSystemID    %04lx\n",
            Pad, extraOffset + FIELD_OFFSET(PCI_TYPE2_HEADER_EXTRAS, SubSystemID), extras->SubSystemID);

    dprintf("%s%02x: LegacyBaseAddr %04lx\n",
            Pad, extraOffset + FIELD_OFFSET(PCI_TYPE2_HEADER_EXTRAS, LegacyModeBaseAddress), extras->LegacyModeBaseAddress);

    return TRUE;
}

VOID
PrintDataRange(
    PCHAR pData,
    ULONG nDwords,
    ULONG base,
    PCHAR Pad
    )
{
    unsigned int i;
    unsigned int j;
    PULONG pRange;

    pRange = (PULONG) pData;
    if (!Pad) {
        Pad = "";
    }
    for (i=0; i<((nDwords+3)/4); i++) {
        dprintf("%s%02lx:", Pad,  base + i*16);
        for (j=0; (j < 4) && (i*4+j < nDwords); j++) {
            dprintf(" %08lx", pRange[i*4+j]);
        }
        dprintf("\n");
    }
}

BOOL
PrintPciCapHeader(
    PCI_CAPABILITIES_HEADER *pCapHdr,
    ULONG CapOffset,
    PCHAR Pad
    )
{

    if (!Pad) Pad = "";

    dprintf("%s%02x: CapID          %02x ", Pad, CapOffset, pCapHdr->CapabilityID);

    switch (pCapHdr->CapabilityID) {
        case PCI_CAPABILITY_ID_POWER_MANAGEMENT:
            dprintf("PwrMgmt ");
        break;

        case PCI_CAPABILITY_ID_AGP:
            dprintf("AGP ");
        break;

        case PCI_CAPABILITY_ID_AGP_TARGET:
            dprintf("AGPT ");
        break;

        case PCI_CAPABILITY_ID_VPD:
            dprintf("VPD ");
            break;

        case PCI_CAPABILITY_ID_SLOT_ID:
            dprintf("SLOT ID ");
            break;

        case PCI_CAPABILITY_ID_MSI:
            dprintf("MSI ");
            break;

        case PCI_CAPABILITY_ID_CPCI_HOTSWAP:
            dprintf("CPCI HotSwap ");
            break;

        case PCI_CAPABILITY_ID_PCIX:
            dprintf("PCI-X ");
            break;

        case PCI_CAPABILITY_ID_HYPERTRANSPORT:
            dprintf("HyperTransport ");
            break;

        case PCI_CAPABILITY_ID_VENDOR_SPECIFIC:
            dprintf("Vendor Specific ");
            break;

        case PCI_CAPABILITY_ID_DEBUG_PORT:
            dprintf("Debug Port ");
            break;

        case PCI_CAPABILITY_ID_CPCI_RES_CTRL:
            dprintf("CPCI Resource Control ");
            break;

        case PCI_CAPABILITY_ID_SHPC:
            dprintf("SHPC ");
            break;

        default:
            dprintf("Unknown ");
            break;
    }

    dprintf("\n");

    dprintf("%s%02x: NextPtr        %02lx\n",
            Pad,
            (CapOffset + FIELD_OFFSET(PCI_CAPABILITIES_HEADER, Next)), pCapHdr->Next);

    return TRUE;
}

VOID
PrintPciPwrMgmtCaps(
    USHORT Capabilities
    )
{
    PCI_PMC pmc;

    pmc = *((PCI_PMC *) &Capabilities);

    if (pmc.PMEClock) {
        dprintf("PMECLK ");
    }
    if (pmc.Rsvd1) {
        dprintf("AUXPWR ");
    }
    if (pmc.DeviceSpecificInitialization) {
        dprintf("DSI ");
    }
    if (pmc.Support.D1) {
        dprintf("D1Support ");
    }
    if (pmc.Support.D2) {
        dprintf("D2Support ");
    }
    if (pmc.Support.PMED0) {
        dprintf("PMED0 ");
    }
    if (pmc.Support.PMED1) {
        dprintf("PMED1 ");
    }
    if (pmc.Support.PMED2) {
        dprintf("PMED2 ");
    }
    if (pmc.Support.PMED3Hot) {
        dprintf("PMED3Hot ");
    }
    if (pmc.Support.PMED3Cold) {
        dprintf("PMED3Cold ");
    }
    dprintf("Version=%lx\n", pmc.Version);
}
BOOL
PrintPciPowerManagement(
    PCHAR pData,
    ULONG CapOffset,
    PCHAR Pad
    )
{
    PPCI_PM_CAPABILITY pPmC;
    int i;

    pPmC = (PPCI_PM_CAPABILITY) pData;
    if (!Pad) {
        Pad = "";
    }
    dprintf("%s%02x: PwrMgmtCap     %04x ",
            Pad,
            CapOffset + FIELD_OFFSET(PCI_PM_CAPABILITY, PMC),
            pPmC->PMC.AsUSHORT);
    PrintPciPwrMgmtCaps(pPmC->PMC.AsUSHORT);

    dprintf("%s%02x: PwrMgmtCtrl    %04x ",
            Pad,
            CapOffset+FIELD_OFFSET(PCI_PM_CAPABILITY, PMCSR),
            pPmC->PMCSR.AsUSHORT);
    PCI_PMCSR CtrlStatus = pPmC->PMCSR.ControlStatus;
    if (CtrlStatus.PMEEnable) {
        dprintf("PMEEnable ");
    }
    if (CtrlStatus.PMEStatus) {
        dprintf("PMESTAT ");
    }
    dprintf("DataScale:%lx ", CtrlStatus.DataScale);
    dprintf("DataSel:%lx ", CtrlStatus.DataSelect);
    dprintf("D%lx%s", CtrlStatus.PowerState, (CtrlStatus.PowerState == 3) ? "Hot " : " ");


    if (pPmC->PMCSR_BSE.AsUCHAR){

        dprintf("\n%sPwrMgmtBridge  ", Pad);
        if (pPmC->PMCSR_BSE.BridgeSupport.D3HotSupportsStopClock) {
            dprintf("D3HotStopClock ");
        }
        if (pPmC->PMCSR_BSE.BridgeSupport.BusPowerClockControlEnabled) {
            dprintf("BPCCEnable ");
        }
    }

    dprintf("\n");
    return TRUE;
}

BOOL
PrintPciAGP(
    PCHAR pData,
    ULONG CapOffset,
    PCHAR Pad
    )
{
    PPCI_AGP_CAPABILITY pAGP;
    int i;

    pAGP = (PPCI_AGP_CAPABILITY) pData;
    if (!Pad) {
        Pad = "";
    }
    dprintf("%s%02x: Version        Major %lx, Minor %lx\n",
            Pad,
            CapOffset + sizeof(PCI_CAPABILITIES_HEADER),
            pAGP->Major,
            pAGP->Minor);

    dprintf("%s%02x: Status         MaxRQDepth:%lx",
            Pad,
            CapOffset + FIELD_OFFSET(PCI_AGP_CAPABILITY, AGPStatus),
            pAGP->AGPStatus.RequestQueueDepthMaximum);

    dprintf(" ARSize:%lx", pAGP->AGPStatus.AsyncRequestSize);

    dprintf(" CCycle:%lx", pAGP->AGPStatus.CalibrationCycle);

    if (pAGP->AGPStatus.SideBandAddressing) {
        dprintf(" SBA");
    }

    if (pAGP->AGPStatus.ITA_Coherent) {
        dprintf(" COH");
    }

    if (pAGP->AGPStatus.Gart64) {
        dprintf(" Gart64");
    }

    if (pAGP->AGPStatus.HostTransDisable) {
        dprintf(" HTXDisable");
    }

    if (pAGP->AGPStatus.FourGB) {
        dprintf(" 4GB");
    }

    if (pAGP->AGPStatus.FastWrite) {
        dprintf(" FW");
    }

    if (pAGP->AGPStatus.Agp3Mode) {
        dprintf(" AGP3Mode");
    }

    dprintf(" Rate:%lx\n", pAGP->AGPStatus.Rate);

    dprintf("%s%02x: Command        ",
            Pad,
            CapOffset + FIELD_OFFSET(PCI_AGP_CAPABILITY, AGPCommand));

    dprintf("RQDepth:%lx ", pAGP->AGPCommand.RequestQueueDepth);

    dprintf("ARSize:%lx ", pAGP->AGPCommand.AsyncReqSize);

    dprintf("CCycle:%lx ", pAGP->AGPCommand.CalibrationCycle);

    if (pAGP->AGPCommand.SBAEnable) {
        dprintf("SBA ");
    }

    if (pAGP->AGPCommand.AGPEnable) {
        dprintf("AGPEnable ");
    }

    if (pAGP->AGPCommand.Gart64) {
        dprintf("Gart64 ");
    }

    if (pAGP->AGPCommand.FourGBEnable) {
        dprintf("4GB ");
    }

    if (pAGP->AGPCommand.FastWriteEnable) {
        dprintf("FW ");
    }

    dprintf("Rate:%lx ", pAGP->AGPCommand.Rate);
    dprintf("\n");

    if (pAGP->Header.CapabilityID == PCI_CAPABILITY_ID_AGP_TARGET) {
        DWORD dwOff = sizeof(PCI_AGP_CAPABILITY);
        PPCI_AGP_EXTENDED_CAPABILITY pAGPExt =
            (PPCI_AGP_EXTENDED_CAPABILITY)(pAGP + 1);

        dprintf("%s%02x: Control        ", Pad,
                CapOffset + dwOff + FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, AgpControl));

        if (!pAGPExt->AgpControl.CAL_Disable) {
            dprintf("CALEnable ");
        }

        if (pAGPExt->AgpControl.AP_Enable) {
            dprintf("APEnable ");
        }

        if (pAGPExt->AgpControl.GTLB_Enable) {
            dprintf("GTLBEnable ");
        }
        dprintf("\n");

        dprintf("%s%02x: Aperture       Size:%lx PageSize:%lx\n",
                Pad,
                CapOffset + dwOff + FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, ApertureSize),
                pAGPExt->ApertureSize, pAGPExt->AperturePageSize);

        dprintf("%s%02x: Gart           %08lx:%08lx\n", Pad,
                CapOffset + dwOff + FIELD_OFFSET(PCI_AGP_EXTENDED_CAPABILITY, GartLow),
                pAGPExt->GartHigh, pAGPExt->GartLow);
    }

    return TRUE;
}

VOID
PrintPciHtCommandReg(
    IN PPCI_HT_CAPABILITY PciHtCap
    )
{

    dprintf("Type: ");
    switch (PciHtCap->Command.Generic.CapabilityType) {
        case HTHostSecondary:
            dprintf("Secondary/Host ");

            if (PciHtCap->Command.HostSecondary.DeviceNumber) {
                dprintf("DeviceNumber:%02x ", PciHtCap->Command.HostSecondary.DeviceNumber);
            }

            if (PciHtCap->Command.HostSecondary.WarmReset) {
                dprintf("WarmReset ");
            }

            if (PciHtCap->Command.HostSecondary.DoubleEnded) {
                dprintf("DoubleEnded ");
            }

            if (PciHtCap->Command.HostSecondary.ChainSide) {
                dprintf("ChainSide ");
            }

            if (PciHtCap->Command.HostSecondary.HostHide) {
                dprintf("HostHide ");
            }

            if (PciHtCap->Command.HostSecondary.ActAsSlave) {
                dprintf("ActAsSlave ");
            }

            if (PciHtCap->Command.HostSecondary.InboundEOCError) {
                dprintf("InboundEOCError ");
            }

            if (PciHtCap->Command.HostSecondary.DropOnUnitinit) {
                dprintf("DropOnUnitinit ");
            }
            dprintf("\n");
            break;

        case HTSlavePrimary:

            dprintf("Primary/Slave ");

            dprintf("BaseUnitID:%lx ", PciHtCap->Command.SlavePrimary.BaseUnitID);
            dprintf("UnitCount:%lx ", PciHtCap->Command.SlavePrimary.UnitCount);


            if (PciHtCap->Command.SlavePrimary.MasterHost) {
                dprintf("MasterHost ");
            }

            if (PciHtCap->Command.SlavePrimary.DefaultDirection) {
                dprintf("DefaultDirection ");
            }

            if (PciHtCap->Command.SlavePrimary.DropOnUnitinit) {
                dprintf("DropOnUnitinit ");
            }

            dprintf("\n");
            break;


        case HTInterruptDiscoveryConfig:
            dprintf("InterruptDiscovery ");
            break;

        case HTAddressMapping:
            dprintf("AddressMapping - ");
        default:
            dprintf("(not implemented)\n");
            break;
    }
}

VOID
PrintPciHtLinkControl(
    IN PPCI_HT_LinkControl LinkControl
    )
{

    if (LinkControl->CFlE) {
        dprintf("CFlE ");
    }

    if (LinkControl->CST) {
        dprintf("CST ");
    }

    if (LinkControl->CFE) {
        dprintf("CFE ");
    }

    if (LinkControl->LkFail) {
        dprintf("LkFail ");
    }

    if (LinkControl->Init) {
        dprintf("Init ");
    }

    if (LinkControl->EOC) {
        dprintf("EOC ");
    }

    if (LinkControl->TXO) {
        dprintf("TXO ");
    }

    if (LinkControl->CRCError) {
        dprintf("CRCError: %lx ", LinkControl->CRCError);
    }

    if (LinkControl->IsocEn) {
        dprintf("IsocEn ");
    }

    if (LinkControl->LSEn) {
        dprintf("LSEn ");
    }

    if (LinkControl->ExtCTL) {
        dprintf("ExtCTL ");
    }
    dprintf("\n");
}


VOID
PrintPciHtLinkConfig(
    IN PPCI_HT_LinkConfig LinkConfig
    )
{

    dprintf("MxLnkWdthIn:");

    switch (LinkConfig->MaxLinkWidthIn) {

        case HTMaxLinkWidth8bits:
            dprintf("8 ");
            break;

        case HTMaxLinkWidth16bits:
            dprintf("16 ");
            break;

        case HTMaxLinkWidth32bits:
            dprintf("32 ");
            break;

        case HTMaxLinkWidth2bits:
            dprintf("2 ");
            break;

        case HTMaxLinkWidth4bits:
            dprintf("4 ");
            break;

        case HTMaxLinkWidthNotConnected:
            dprintf("!Connected ");
            break;
    }

    if (LinkConfig->DwFlowControlIn) {
        dprintf("DwFcIn ");
    }

    dprintf("MxLnkWdthOut:");
    switch (LinkConfig->MaxLinkWidthOut) {

        case HTMaxLinkWidth8bits:
            dprintf("8 ");
            break;

        case HTMaxLinkWidth16bits:
            dprintf("16 ");
            break;

        case HTMaxLinkWidth32bits:
            dprintf("32 ");
            break;

        case HTMaxLinkWidth2bits:
            dprintf("2 ");
            break;

        case HTMaxLinkWidth4bits:
            dprintf("4 ");
            break;

        case HTMaxLinkWidthNotConnected:
            dprintf("!Connected ");
            break;
    }

    if (LinkConfig->DwFlowControlOut) {
        dprintf("DwFcOut ");
    }

    dprintf("LnkWdthIn:");
    switch (LinkConfig->LinkWidthIn) {

        case HTMaxLinkWidth8bits:
            dprintf("8 ");
            break;

        case HTMaxLinkWidth16bits:
            dprintf("16 ");
            break;

        case HTMaxLinkWidth32bits:
            dprintf("32 ");
            break;

        case HTMaxLinkWidth2bits:
            dprintf("2 ");
            break;

        case HTMaxLinkWidth4bits:
            dprintf("4 ");
            break;

        case HTMaxLinkWidthNotConnected:
            dprintf("!Connected ");
            break;
    }

    if (LinkConfig->DwFlowControlInEn) {
        dprintf("DwFcInEn ");
    }

    dprintf("LnkWdthOut:");
    switch (LinkConfig->LinkWidthOut) {

        case HTMaxLinkWidth8bits:
            dprintf("8 ");
            break;

        case HTMaxLinkWidth16bits:
            dprintf("16 ");
            break;

        case HTMaxLinkWidth32bits:
            dprintf("32 ");
            break;

        case HTMaxLinkWidth2bits:
            dprintf("2 ");
            break;

        case HTMaxLinkWidth4bits:
            dprintf("4 ");
            break;

        case HTMaxLinkWidthNotConnected:
            dprintf("!Connected ");
            break;
    }

    if (LinkConfig->DwFlowControlOutEn) {
        dprintf("DwFcOutEn ");
    }

    dprintf("\n");

}

VOID
PrintPciHtInterruptBlock(
    IN PPCI_TYPE1_CFG_BITS PciCfg1,
    IN ULONG CapOffset
    )
{

    UCHAR index;
    ULONG writeOffset, readOffset;
    ULONG currentInterrupt;
    PULONG dataPort;
    PCI_HT_INTERRUPT_INDEX_1 index1;
    PCI_HT_INTERRUPT_INDEX_N interruptIndex;

    writeOffset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, Command.Interrupt);
    readOffset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, DataPort);

    //
    //  Start with the first index to determine the max interrupt count
    //
    index = 1;

    if (!(WritePci(PciCfg1, (PUCHAR)&index, writeOffset, sizeof(UCHAR)))){
        dprintf("write operation failed!\n");
        return;
    }

    RtlZeroMemory(&index1, sizeof(PCI_HT_INTERRUPT_INDEX_1));
    ReadPci(PciCfg1, (PUCHAR)&index1, readOffset, sizeof(ULONG));

    dprintf("- Last Interrupt: 0x%lx\n", index1.LastInterrupt);

    //
    //  According to the HyperTransport spec the interrupt index list
    //  starts at index 0x10
    //
    index = 0x10;
    currentInterrupt = 0;

    dprintf(" InterruptBlock:\n");
    while (currentInterrupt <= (ULONG)index1.LastInterrupt) {

        ULONG i = 0;

        dataPort = (PULONG)&interruptIndex.LowPart;
        RtlZeroMemory(&interruptIndex, sizeof(PCI_HT_INTERRUPT_INDEX_N));

        //
        //  Each interruptIndex is 64bits long so we have to read from the
        //  dataport twice to get the full value
        //
        while (i <= 1) {

            if (!(WritePci(PciCfg1, (PUCHAR)&index, writeOffset, sizeof(UCHAR)))){
                dprintf("write operation failed!\n");
                return;
            }

            ReadPci(PciCfg1, (PUCHAR)dataPort, readOffset, sizeof(ULONG));

            index++;
            dataPort++;
            i++;
        }

        dprintf("     INT%02x: %08x%08x  ( ",
                currentInterrupt,
                interruptIndex.HighPart,
                interruptIndex.LowPart);

        dprintf("MessageType: %lx ", interruptIndex.LowPart.MessageType);

        if (interruptIndex.LowPart.Mask) {
            dprintf("Masked ");
        }
        if (interruptIndex.LowPart.Polarity) {
            dprintf("active-low ");
        }else{
            dprintf("active-high ");
        }

        if (interruptIndex.LowPart.RequestEOI) {
            dprintf("RequestEOI ");
        }

        if (interruptIndex.HighPart.PassPW) {
            dprintf("PassPW ");
        }

        if (interruptIndex.HighPart.WaitingForEOI) {
            dprintf("WaitingForEOI ");
        }
        dprintf(")\n");

        currentInterrupt++;
    }
}

VOID
PrintPciHtFreqError(
    IN PPCI_HT_Frequency_Error FreqError
    )
{
    UCHAR asUCHAR;

    asUCHAR = (*(PUCHAR)FreqError);

    dprintf("Freq: ");
    switch (FreqError->LinkFrequency) {
            case HTFreq200MHz:
                dprintf("200MHz ");
                break;
            case HTFreq300MHz:
                dprintf("300MHz ");
                break;
            case HTFreq400MHz:
                dprintf("400MHz ");
                break;
            case HTFreq500MHz:
                dprintf("500MHz ");
                break;
            case HTFreq600MHz:
                dprintf("600MHz ");
                break;
            case HTFreq800MHz:
                dprintf("800MHz ");
                break;
            case HTFreq1000MHz:
                dprintf("1000MHz ");
                break;
            case HTFreqReserved:
            case HTFreqVendorDefined:
            default:
                dprintf("?? ");
                break;
        }

    //
    //  only print an error if we have one
    //
    if (asUCHAR & 0xf0) {

        dprintf("Error: ");

        if (FreqError->ProtocolError) {
            dprintf("ProtocolError ");
        }

        if (FreqError->OverflowError) {
            dprintf("OverflowError ");
        }
        if (FreqError->EndOfChainError) {
            dprintf("EndOfChainError ");
        }
        if (FreqError->CTLTimeout) {
            dprintf("CTLTimeout ");
        }
    }

    dprintf("\n");
}

VOID
PrintPciHtFeatureCap(
    IN PPCI_HT_FeatureCap FeatureCap,
    IN PPCI_HT_FeatureCap_Ex FeatureCapEx
    )
{

    if (FeatureCap->IsocMode) {
        dprintf("IsocMode ");
    }

    if (FeatureCap->LDTSTOP) {
        dprintf("LDTSTOP ");
    }

    if (FeatureCap->CRCTestMode) {
        dprintf("CRCTestMode ");
    }

    if (FeatureCapEx){
        if (FeatureCapEx->ExtendedRegisterSet) {
            dprintf("ExtendedRegisterSet ");
        }
    }

    dprintf("\n");
}
VOID
PrintPciHtErrorHandling(
    IN PPCI_HT_ErrorHandling ErrorHandling
    )
{

    USHORT asUSHORT = (*(PUSHORT)ErrorHandling);

    if (asUSHORT & 0xffff) {

        if (ErrorHandling->ProtFloodEn){
            dprintf("ProtFloodEn ");
        }

        if (ErrorHandling->OverflowFloodEn){
            dprintf("OverflowFloodEn ");
        }

        if (ErrorHandling->ProtFatalEn){
            dprintf("ProtFatalEn ");
        }

        if (ErrorHandling->OverflowFatalEn){
            dprintf("OverflowFatalEn ");
        }

        if (ErrorHandling->EOCFatalEn){
            dprintf("EOCFatalEn ");
        }

        if (ErrorHandling->RespFatalEn){
            dprintf("RespFatalEn ");
        }

        if (ErrorHandling->CRCFatalEn){
            dprintf("CRCFatalEn ");
        }

        if (ErrorHandling->SERRFataEn){
            dprintf("SERRFataEn ");
        }

        if (ErrorHandling->ChainFail){
            dprintf("ChainFail ");
        }

        if (ErrorHandling->ResponseError){
            dprintf("ResponseError ");
        }

        if (ErrorHandling->ProtNonFatalEn){
            dprintf("ProtNonFatalEn ");
        }

        if (ErrorHandling->OverflowNonFatalEn){
            dprintf("OverflowNonFatalEn ");
        }

        if (ErrorHandling->EOCNonFatalEn){
            dprintf("EOCNonFatalEn ");
        }

        if (ErrorHandling->RespNonFatalEn){
            dprintf("RespNonFatalEn ");
        }

        if (ErrorHandling->CRCNonFatalEn){
            dprintf("CRCNonFatalEn ");
        }

        if (ErrorHandling->SERRNonFatalEn){
            dprintf("SERRNonFatalEn ");
        }
    }
    dprintf("\n");
}

BOOL
PrintPciHtCaps(
    IN PPCI_TYPE1_CFG_BITS PciCfg1,
    IN PCHAR CapData,
    IN ULONG CapOffset,
    IN PCHAR Pad
    )
{
    PPCI_HT_CAPABILITY pciHtCap;
    ULONG offset;

    pciHtCap = (PPCI_HT_CAPABILITY)CapData;
    if (!Pad) {
        Pad = "";
    }

    offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, Command);
    dprintf("%s%02x: Command        %04x ", Pad, offset, pciHtCap->Command);

    PrintPciHtCommandReg(pciHtCap);

    if (pciHtCap->Command.Generic.CapabilityType == HTInterruptDiscoveryConfig){
        //
        //  Handle the interrupt stuff and return
        //
        PrintPciHtInterruptBlock(PciCfg1, CapOffset);

        return TRUE;
    }

    //
    //  Print the common link control/config
    //
    offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, LinkControl_0);
    dprintf("%s%02x: LinkControl_0  %04x ", Pad, offset, pciHtCap->LinkControl_0);
    PrintPciHtLinkControl(&pciHtCap->LinkControl_0);

    offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, LinkConfig_0);
    dprintf("%s%02x: LinkConfig_0   %04x ", Pad, offset, pciHtCap->LinkConfig_0);
    PrintPciHtLinkConfig(&pciHtCap->LinkConfig_0);

    //
    //  Now deal with the host/slave specifics
    //
    switch (pciHtCap->Command.Generic.CapabilityType) {

        case HTSlavePrimary:

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, LinkControl_0);
        dprintf("%s%02x: LinkControl_1  %04x ", Pad, offset, pciHtCap->LinkControl_0);
        PrintPciHtLinkControl(&pciHtCap->SlavePrimary.LinkControl_1);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.LinkConfig_1);
        dprintf("%s%02x: LinkConfig_1   %04x ", Pad, offset, pciHtCap->SlavePrimary.LinkConfig_1);
        PrintPciHtLinkConfig(&pciHtCap->SlavePrimary.LinkConfig_1);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.RevisionID);
        dprintf("%s%02x: RevisionID     %02x:%02x (Major:Minor)\n", Pad, offset,
                    pciHtCap->SlavePrimary.RevisionID.MajorRev,
                    pciHtCap->SlavePrimary.RevisionID.MinorRev);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.FreqErr_0);
        dprintf("%s%02x: FreqErr_0      %02x ", Pad, offset, pciHtCap->SlavePrimary.FreqErr_0);
        PrintPciHtFreqError(&pciHtCap->SlavePrimary.FreqErr_0);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.LinkFreqCap_0);
        dprintf("%s%02x: LinkFreqCap_0  %04x\n", Pad, offset, pciHtCap->SlavePrimary.LinkFreqCap_0);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.FeatureCap);
        dprintf("%s%02x: FeatureCap     %02x ", Pad, offset, pciHtCap->SlavePrimary.FeatureCap);
        PrintPciHtFeatureCap(&pciHtCap->SlavePrimary.FeatureCap, NULL);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.FreqErr_1);
        dprintf("%s%02x: FreqErr_1      %02x ", Pad, offset, pciHtCap->SlavePrimary.FreqErr_1);
        PrintPciHtFreqError(&pciHtCap->SlavePrimary.FreqErr_1);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.LinkFreqCap_1);
        dprintf("%s%02x: LinkFreqCap_1  %04x\n", Pad, offset, pciHtCap->SlavePrimary.LinkFreqCap_1);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.EnumerationScratchpad);
        dprintf("%s%02x: EnumScratchpad %04x\n", Pad, offset, pciHtCap->SlavePrimary.EnumerationScratchpad);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.ErrorHandling);
        dprintf("%s%02x: ErrorHandling  %04x ", Pad, offset, pciHtCap->SlavePrimary.ErrorHandling);
        PrintPciHtErrorHandling(&pciHtCap->SlavePrimary.ErrorHandling);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.MemoryBaseUpper8Bits);
        dprintf("%s%02x: MemBaseUpper   %02x\n", Pad, offset, pciHtCap->SlavePrimary.MemoryBaseUpper8Bits);

        offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, SlavePrimary.MemoryLimitUpper8Bits);
        dprintf("%s%02x: MemLimitUpper  %02x\n", Pad, offset, pciHtCap->SlavePrimary.MemoryLimitUpper8Bits);
        break;

        case HTHostSecondary:

            offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, HostSecondary.RevisionID);
            dprintf("%s%02x: RevisionID     %02x:%02x (Major:Minor)\n", Pad, offset,
                    pciHtCap->HostSecondary.RevisionID.MajorRev,
                    pciHtCap->HostSecondary.RevisionID.MinorRev);

            offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, HostSecondary.FreqErr_0);
            dprintf("%s%02x: FreqErr_0      %02x ", Pad, offset, pciHtCap->HostSecondary.FreqErr_0);
            PrintPciHtFreqError(&pciHtCap->HostSecondary.FreqErr_0);

            offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, HostSecondary.LinkFreqCap_0);
            dprintf("%s%02x: LinkFreqCap_0  %04x\n", Pad, offset, pciHtCap->HostSecondary.LinkFreqCap_0);

            offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, HostSecondary.FeatureCap);
            dprintf("%s%02x: FeatureCap     %04x ", Pad, offset, pciHtCap->HostSecondary.FeatureCap);
            PrintPciHtFeatureCap(&pciHtCap->HostSecondary.FeatureCap, &pciHtCap->HostSecondary.FeatureCapEx);

            offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, HostSecondary.EnumerationScratchpad);
            dprintf("%s%02x: EnumScratchpad %04x\n", Pad, offset, pciHtCap->HostSecondary.EnumerationScratchpad);

            offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, HostSecondary.ErrorHandling);
            dprintf("%s%02x: ErrorHandling  %04x ", Pad, offset, pciHtCap->HostSecondary.ErrorHandling);
            PrintPciHtErrorHandling(&pciHtCap->HostSecondary.ErrorHandling);

            offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, HostSecondary.MemoryBaseUpper8Bits);
            dprintf("%s%02x: MemBaseUpper   %02x\n", Pad, offset, pciHtCap->HostSecondary.MemoryBaseUpper8Bits);

            offset = CapOffset + FIELD_OFFSET(PCI_HT_CAPABILITY, HostSecondary.MemoryLimitUpper8Bits);
            dprintf("%s%02x: MemLimitUpper  %02x\n", Pad, offset, pciHtCap->HostSecondary.MemoryLimitUpper8Bits);
            break;

        default:
            break;

    }

    return TRUE;
}


BOOL
PrintPciMSICaps(
    PCHAR pData,
    ULONG CapOffset,
    PCHAR Pad
    )
{
    PPCI_MSI_CAPABILITY pMsiCap;
    pMsiCap = (PPCI_MSI_CAPABILITY) pData;
    if (!Pad) {
        Pad = "";
    }

    dprintf("%s%02x: MsgCtrl       ",
            Pad,
            CapOffset + FIELD_OFFSET(PCI_MSI_CAPABILITY, MessageControl));
    if (pMsiCap->MessageControl.CapableOf64Bits) {
        dprintf("64BitCapable ");
    }
    if (pMsiCap->MessageControl.MSIEnable) {
        dprintf("MSIEnable ");
    }

    dprintf("MultipleMsgEnable:%lx ", pMsiCap->MessageControl.MultipleMessageEnable);
    dprintf("MultipleMsgCapable:%lx ", pMsiCap->MessageControl.MultipleMessageCapable);
    dprintf("%s%02x: MsgAddr      %lx\n",
            Pad,
            CapOffset + FIELD_OFFSET(PCI_MSI_CAPABILITY, MessageAddressLower),
            pMsiCap->MessageAddressLower.Raw);

    if (pMsiCap->MessageControl.CapableOf64Bits) {
        dprintf("%s%02x: MsgAddrHi      %lx\n",
                Pad,
                CapOffset + FIELD_OFFSET(PCI_MSI_CAPABILITY, Option64Bit.MessageAddressUpper),
                pMsiCap->Option64Bit.MessageAddressUpper);
        dprintf("%s%02x: MsData         %lx\n",
                Pad,
                CapOffset + FIELD_OFFSET(PCI_MSI_CAPABILITY, Option64Bit.MessageData),
                pMsiCap->Option64Bit.MessageData);
    } else {
        dprintf("%s%02x: MsData         %lx\n",
                Pad,
                CapOffset + FIELD_OFFSET(PCI_MSI_CAPABILITY, Option32Bit.MessageData),
                pMsiCap->Option32Bit.MessageData);
    }
    return TRUE;
}

/*** CardBus Registers
 */

VOID
PrintCBSktEventReg(
    UCHAR Register
    )
{
    dprintf("%lx ", Register);
    if (Register & SKTEVENT_CSTSCHG) {
        dprintf("CSTSCHG ");
    }
    if (Register & SKTEVENT_CCD1) {
        dprintf("/CCD1 ");
    }
    if (Register & SKTEVENT_CCD2) {
        dprintf("/CCD2 ");
    }
    if (Register & SKTEVENT_POWERCYCLE) {
        dprintf("PowerCycle ");
    }
}

//Socket Mask Register

VOID
PrintCBSktMaskReg(
    UCHAR Register
    )
{
    dprintf("%lx ", Register);

    if (Register & SKTMSK_POWERCYCLE) {
        dprintf("PowerCycle ");
    }
    if (Register & SKTMSK_CSTSCHG) {
        dprintf("CSTSCHG ");
    }
    if ((Register & SKTMSK_CCD) == 0) {
        dprintf("CSCDisabled ");
    } else if ((Register & SKTMSK_CCD) == SKTMSK_CCD) {
        dprintf("CSCEnabled ");
    } else {
        dprintf("Undefined ");
    }

}


//Socket Present State Register
VOID
PrintCBSktStateReg(
    ULONG Register
    )
{
    dprintf("%08lx ", Register);

    if (Register & SKTSTATE_CSTSCHG) {
        dprintf("CSTSCHG ");
    }
    if (Register & SKTSTATE_POWERCYCLE) {
        dprintf("PowerCycle ");
    }
    if (Register & SKTSTATE_CARDTYPE_MASK) {
        dprintf("");
    }
    if (Register & SKTSTATE_R2CARD) {
        dprintf("R2Card ");
    }
    if (Register & SKTSTATE_CBCARD) {
        dprintf("CBCard ");
    }
    if (Register & SKTSTATE_OPTI_DOCK) {
        dprintf("OptiDock ");
    }
    if (Register & SKTSTATE_CARDINT) {
        dprintf("CardInt ");
    }
    if (Register & SKTSTATE_NOTACARD) {
        dprintf("NotACard ");
    }
    if (Register & SKTSTATE_DATALOST) {
        dprintf("DataLoss ");
    }
    if (Register & SKTSTATE_BADVCCREQ) {
        dprintf("BadVccReq ");
    }
    if (Register & SKTSTATE_5VCARD) {
        dprintf("5VCard ");
    }
    if (Register & SKTSTATE_3VCARD) {
        dprintf("3VCard ");
    }
    if (Register & SKTSTATE_XVCARD) {
        dprintf("XVCard ");
    }
    if (Register & SKTSTATE_YVCARD) {
        dprintf("YVCard ");
    }
    if (Register & SKTSTATE_5VSOCKET) {
        dprintf("5VSkt ");
    }
    if (Register & SKTSTATE_3VSOCKET) {
        dprintf("3VSkt ");
    }
    if (Register & SKTSTATE_XVSOCKET) {
        dprintf("XVSkt ");
    }
    if (Register & SKTSTATE_YVSOCKET) {
        dprintf("YVSkt ");
    }
    if ((Register & SKTSTATE_CCD_MASK) == 0) {
        dprintf("CardPresent ");
    } else if ((Register & SKTSTATE_CCD_MASK) == SKTSTATE_CCD_MASK) {
        dprintf("NoCard ");
    } else {
        dprintf("CardMayPresent ");
    }
}

//Socket Control Register
VOID
PrintCBSktCtrlReg(
    ULONG Register
    )
{
    ULONG Ctrl;
    dprintf("%08lx ", Register);

    Ctrl = Register & SKTPOWER_VPP_CONTROL;
    dprintf("Vpp:");
    switch (Ctrl) {
    case SKTPOWER_VPP_OFF:
        dprintf("Off");
        break;
    case SKTPOWER_VPP_120V:
        dprintf("12V");
        break;
    case SKTPOWER_VPP_050V:
        dprintf("5V");
        break;
    case SKTPOWER_VPP_033V:
        dprintf("3.3V");
        break;
    case SKTPOWER_VPP_0XXV:
        dprintf("X.XV");
        break;
    case SKTPOWER_VPP_0YYV:
        dprintf("Y.YV");
        break;
    }

    dprintf(" Vcc:");
    switch (Register & SKTPOWER_VCC_CONTROL) {
    case SKTPOWER_VCC_OFF:
        dprintf("Off");
        break;
    case SKTPOWER_VCC_050V:
        dprintf("5V");
        break;
    case SKTPOWER_VCC_033V:
        dprintf("3.3V");
        break;
    case SKTPOWER_VCC_0XXV:
        dprintf("X.XV");
        break;
    case SKTPOWER_VCC_0YYV:
        dprintf("Y.YV");
        break;
    }
    if (Register & SKTPOWER_STOPCLOCK) {
        dprintf(" ClockStopEnabled ");
    }
}

BOOL
PrintCBRegs(
    PCHAR pData,
    PCHAR Pad
    )
{
    ULONG Off=0;
    dprintf("%s%02lx: SktEvent      ", Pad, Off);
    PrintCBSktEventReg(*pData);
    dprintf("\n");
    pData+=4; Off+=4;
    dprintf("%s%02lx: SktMask       ", Pad, Off);
    PrintCBSktMaskReg(*pData);
    dprintf("\n");
    pData+=4; Off+=4;
    dprintf("%s%02lx: SktState      ", Pad, Off);
    PrintCBSktStateReg(*((PULONG)pData));
    dprintf("\n");
    pData+=4; Off+=4;
    dprintf("%s%02lx: SktForce      %08lx\n", Pad, Off, *((PULONG)pData));
    pData+=4; Off+=4;
    dprintf("%s%02lx: SktCtrl       ", Pad, Off);
    PrintCBSktEventReg(*(pData));
    dprintf("\n");

    return FALSE;
}

/*** ExCA Registers
 */

VOID
PrintExCARegs(
    PEXCAREGS pExCARegs
    )
{
    struct _MEMWIN_EXCA {
        USHORT Start;
        USHORT Stop;
        USHORT Offset;
        USHORT Reserved;
    } MemWin, *pMemWin;

    dprintf("%02lx: IDRev           %02lx", FIELD_OFFSET(EXCAREGS, bIDRev),pExCARegs->bIDRev);
    if ((pExCARegs->bIDRev & IDREV_IFID_MASK) == IDREV_IFID_IO) {
        dprintf(" IOOnly");
    }
    else if ((pExCARegs->bIDRev & IDREV_IFID_MASK) == IDREV_IFID_MEM) {
        dprintf(" MemOnly");
    } else if ((pExCARegs->bIDRev & IDREV_IFID_MASK) == IDREV_IFID_IOMEM) {
        dprintf(" IO&Mem");
    }
    dprintf(" Rev: %02lx\n", pExCARegs->bIDRev & IDREV_REV_MASK);

    dprintf("%02lx: IFStatus        %02lx",
            FIELD_OFFSET(EXCAREGS, bInterfaceStatus),
            pExCARegs->bInterfaceStatus);

    if (pExCARegs->bInterfaceStatus & IFS_BVD1) {
        dprintf(" BVD1");
    }
    if (pExCARegs->bInterfaceStatus & IFS_BVD2) {
        dprintf(" BVD2");
    }
    if (pExCARegs->bInterfaceStatus & IFS_CD1) {
        dprintf(" CD1");
    }
    if (pExCARegs->bInterfaceStatus & IFS_CD2) {
        dprintf(" CD2");
    }
    if (pExCARegs->bInterfaceStatus & IFS_WP) {
        dprintf(" WP");
    }
    if (pExCARegs->bInterfaceStatus & IFS_RDYBSY) {
        dprintf(" Ready");
    }
    if (pExCARegs->bInterfaceStatus & IFS_CARDPWR_ACTIVE) {
        dprintf(" PowerActive");
    }
    if (pExCARegs->bInterfaceStatus & IFS_VPP_VALID) {
        dprintf(" VppValid");
    }
    dprintf("\n");

    dprintf("%02lx: PwrCtrl         %02lx", FIELD_OFFSET(EXCAREGS, bPowerControl), pExCARegs->bPowerControl);

    dprintf(" Vpp1=");
    switch (pExCARegs->bPowerControl & PC_VPP1_MASK) {
    case PC_VPP_NO_CONNECT:
        dprintf("Off");
        break;
    case PC_VPP_SETTO_VCC:
        dprintf("Vcc");
        break;
    case PC_VPP_SETTO_VPP:
        dprintf("Vpp");
        break;
    }
    dprintf(" Vpp2=");
    switch ((pExCARegs->bPowerControl & PC_VPP2_MASK) >> 2) {
    case PC_VPP_NO_CONNECT:
        dprintf("Off");
        break;
    case PC_VPP_SETTO_VCC:
        dprintf("Vcc");
        break;
    case PC_VPP_SETTO_VPP:
        dprintf("Vpp");
        break;
    }
    if (pExCARegs->bPowerControl & PC_CARDPWR_ENABLE) {
        dprintf(" PwrEnable");
    }
    if (pExCARegs->bPowerControl & PC_AUTOPWR_ENABLE) {
        dprintf(" AutoPwrEnabled");
    }
    if (pExCARegs->bPowerControl & PC_RESETDRV_DISABLE) {
        dprintf(" RESETDRVDisabled");
    }
    if (pExCARegs->bPowerControl & PC_OUTPUT_ENABLE) {
        dprintf(" OutputEnable");
    }
    dprintf("\n");

    dprintf("%02lx: IntGenCtrl      %02lx",
            FIELD_OFFSET(EXCAREGS, bIntGenControl),
            pExCARegs->bIntGenControl);
    if (pExCARegs->bIntGenControl & IGC_INTR_ENABLE) {
        dprintf(" INTREnable");
    }
    if (pExCARegs->bIntGenControl & IGC_PCCARD_IO) {
        dprintf(" IOCard");
    }
    if (pExCARegs->bIntGenControl & IGC_PCCARD_RESETLO) {
        dprintf(" ResetOff");
    }
    if (pExCARegs->bIntGenControl & IGC_RINGIND_ENABLE) {
        dprintf(" RingIndEnable");
    }
    dprintf(" CardIRQ:%lx\n", pExCARegs->bIntGenControl & IGC_IRQ_MASK);

    dprintf("%02lx: CardStatChange  %02lx", FIELD_OFFSET(EXCAREGS, bCardStatusChange), pExCARegs->bCardStatusChange);
    if (pExCARegs->bCardStatusChange & CSC_BATT_DEAD) {
        dprintf(" BATTDEAD");
    }
    if (pExCARegs->bCardStatusChange & CSC_BATT_WARNING) {
        dprintf(" BATTWARN");
    }
    if (pExCARegs->bCardStatusChange & CSC_READY_CHANGE) {
        dprintf(" RDYC");
    }
    if (pExCARegs->bCardStatusChange & CSC_CD_CHANGE) {
        dprintf(" CDC");
    }
    dprintf("\n");

    dprintf("%02lx: IntConfig       %02lx",
            FIELD_OFFSET(EXCAREGS,  bCardStatusIntConfig),
            pExCARegs->bCardStatusIntConfig);
    if (pExCARegs->bCardStatusIntConfig & CSCFG_BATT_DEAD) {
        dprintf(" BattDeadEnable");
    }
    if (pExCARegs->bCardStatusIntConfig & CSCFG_BATT_WARNING) {
        dprintf(" BattWarnEnable");
    }
    if (pExCARegs->bCardStatusIntConfig & CSCFG_READY_ENABLE) {
        dprintf(" RDYEnable");
    }
    if (pExCARegs->bCardStatusIntConfig & CSCFG_CD_ENABLE) {
        dprintf(" CDEnable");
    }
    dprintf(" CSCIRQ:%lx\n",(pExCARegs->bCardStatusIntConfig & CSCFG_IRQ_MASK));

    dprintf("%02lx: WinEnable       %02lx",
            FIELD_OFFSET(EXCAREGS, bWindowEnable),
            pExCARegs->bWindowEnable);
    if (pExCARegs->bWindowEnable & WE_MEM0_ENABLE) {
        dprintf(" Mem0Enable");
    }
    if (pExCARegs->bWindowEnable & WE_MEM1_ENABLE) {
        dprintf(" Mem1Enable");
    }
    if (pExCARegs->bWindowEnable & WE_MEM2_ENABLE) {
        dprintf(" Mem2Enable");
    }
    if (pExCARegs->bWindowEnable & WE_MEM3_ENABLE) {
        dprintf(" Mem3Enable");
    }
    if (pExCARegs->bWindowEnable & WE_MEM4_ENABLE) {
        dprintf(" Mem4Enable");
    }

    if (pExCARegs->bWindowEnable & WE_MEMCS16_DECODE) {
        dprintf(" DecodeA23-A12");
    }
    if (pExCARegs->bWindowEnable & WE_IO0_ENABLE) {
        dprintf(" IO0Enable");
    }
    if (pExCARegs->bWindowEnable & WE_IO1_ENABLE) {
        dprintf(" IO1Enable");
    }
    dprintf("\n");

    dprintf("%02lx: IOWinCtrl       %02lx",
            FIELD_OFFSET(EXCAREGS, bIOControl),
            pExCARegs->bIOControl);
    if (pExCARegs->bIOControl & IOC_IO0_DATASIZE) {
        dprintf(" IO0CardIOCS");
    }
    if (pExCARegs->bIOControl & IOC_IO0_IOCS16) {
        dprintf(" IO016Bit");
    }
    if (pExCARegs->bIOControl & IOC_IO0_ZEROWS) {
        dprintf(" IO0ZeroWS");
    }
    if (pExCARegs->bIOControl & IOC_IO0_WAITSTATE) {
        dprintf(" IO0WS");
    }
    if (pExCARegs->bIOControl & IOC_IO1_DATASIZE) {
        dprintf(" IO1CardIOCS");
    }
    if (pExCARegs->bIOControl & IOC_IO1_IOCS16) {
        dprintf(" IO116Bit");
    }
    if (pExCARegs->bIOControl & IOC_IO1_ZEROWS) {
        dprintf(" IO1ZeroWS");
    }
    if (pExCARegs->bIOControl & IOC_IO1_WAITSTATE) {
        dprintf(" IO1WS");
    }
    dprintf("\n");

    dprintf("%02lx: IOWin0Start     %02lx %02lx\n",
            FIELD_OFFSET(EXCAREGS, bIO0StartLo),
            pExCARegs->bIO0StartHi, pExCARegs->bIO0StartLo);
    dprintf("%02lx: IOWin0Stop      %02lx %02lx\n",
            FIELD_OFFSET(EXCAREGS, bIO0StopLo),
            pExCARegs->bIO0StopHi, pExCARegs->bIO0StopLo);
    dprintf("%02lx: IOWin1Start     %02lx %02lx\n",
            FIELD_OFFSET(EXCAREGS, bIO1StartLo),
            pExCARegs->bIO1StartHi, pExCARegs->bIO1StartLo);
    dprintf("%02lx: IOWin1Stop      %02lx %02lx\n",
            FIELD_OFFSET(EXCAREGS, bIO1StopLo),
            pExCARegs->bIO1StopHi, pExCARegs->bIO1StopLo);

    pMemWin = (struct _MEMWIN_EXCA*) &pExCARegs->bMem0StartLo;
    for (int i=0;
         i<5;
         i++, pMemWin++) {

        dprintf("%02lx: MemWin%lxStart    %04lx",
                FIELD_OFFSET(EXCAREGS, bMem0StartLo) + i*sizeof(_MEMWIN_EXCA),
                i, pMemWin->Start & MEMBASE_ADDR_MASK);
        if (pMemWin->Start & MEMBASE_ZEROWS) {
            dprintf(" ZeroWs");
        } else if (pMemWin->Start & MEMBASE_16BIT) {
            dprintf(" 16Bit");
        }
        dprintf("\n");

        dprintf("%02lx: MemWin%lxStop     %04lx, WaitState:%lx\n",
                FIELD_OFFSET(EXCAREGS, bMem0StopLo) + i*sizeof(_MEMWIN_EXCA),
                i,
                (pMemWin->Stop & MEMEND_ADDR_MASK),
                (pMemWin->Stop & MEMEND_WS_MASK));
        dprintf("%02lx: MemWin%lxOffset   %04lx %s%s\n",
                FIELD_OFFSET(EXCAREGS, bMem0OffsetLo) + i*sizeof(_MEMWIN_EXCA),
                i,
                (pMemWin->Offset & MEMOFF_ADDR_MASK),
                ((pMemWin->Offset & MEMOFF_REG_ACTIVE) ? " RegActive" : ""),
                ((pMemWin->Offset & MEMOFF_WP) ? " WP" : "")
                );

    }
}

VOID
PrintExCAHiRegs(
    PUCHAR pExCaReg,
    PCHAR Pad
    )
{
    ULONG Off = sizeof(EXCAREGS);
    dprintf("%s%02lx: MemWin0High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: MemWin1High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: MemWin2High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: MemWin3High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: MemWin4High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: CLIOWin0High    %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: CLIOWin1High    %02lx\n", Pad, Off++, *(pExCaReg++));

}

/***LP  ReadExCAByte - Read ExCA byte register
 *
 *  ENTRY
 *      dwBaseAddr - Base port address
 *      dwReg - register offset
 *
 *  EXIT
 *      returns data read
 */

BYTE
ReadExCAByte(ULONG64 dwBaseAddr, DWORD dwReg)
{
    BYTE bData=0;
    ULONG ulSize;

    ulSize = sizeof(BYTE);
    WriteIoSpace64(dwBaseAddr, dwReg, &ulSize);
    ulSize = sizeof(BYTE);
    ReadIoSpace64(dwBaseAddr + 1, (PULONG)&bData, &ulSize);

    return bData;
}       //ReadExCAByte

/***LP  GetClassDesc - Get class description string
 *
 *  ENTRY
 *      BaseClass - Base Class code
 *      SubClass - Sub Class code
 *      ProgIF - Program Interface code
 *      ClassDesc - Which string call wants
 *
 *  EXIT-SUCCESS
 *      returns pointer to description string
 *  EXIT-FAILURE
 *      returns NULL
 */

PCHAR
GetClassDesc(
    IN UCHAR BaseClass,
    IN UCHAR SubClass,
    IN UCHAR ProgIf,
    IN PCI_CLASSCODEDESC ClassDesc
    )
{
    ULONG i;

    if ((BaseClass == 1) && (SubClass == 1)){
        //
        //  IDE progIf is special. Ignore it here.
        //
        ProgIf = 0;;
    }

    i = 0;
    while (PciClassCodeTable[i].BaseDesc){

        if ((PciClassCodeTable[i].BaseClass == BaseClass) &&
            (PciClassCodeTable[i].SubClass == SubClass) &&
            (PciClassCodeTable[i].ProgIf == ProgIf)) {

            switch (ClassDesc) {
                case BaseClassDescription:
                    return PciClassCodeTable[i].BaseDesc;
                    break;
                case SubClassDescription:
                    return PciClassCodeTable[i].SubDesc;
                    break;
                case ProgIfDescription:
                    return PciClassCodeTable[i].ProgDesc;
                    break;
                default:
                    break;
            }
        }
        i++;
    }
    return NULL;

}       //GetClassDesc


/*** GetVendorDesc - Get Vendor ID Description string.
 *
 *  ENTRY
 *      VendorID -> Device's Vendor ID
 *      FullVenDesc - Flag to determine which string to return
 *
 *  EXIT
 *      None
 */
PCHAR
GetVendorDesc(
    IN USHORT VendorID,
    IN BOOL FullVenDesc
    )
{

    ULONG i;

    i = 0;
    while (PciVenTable[i].VenId != 0xFFFF) {

        if (PciVenTable[i].VenId == VendorID) {

            if (FullVenDesc) {
                return PciVenTable[i].VenFull;
            }

            if (PciVenTable[i].VenShort) {
                return PciVenTable[i].VenShort;
            }else{
                break;
            }
        }

        i++;
    }
    return NULL;
}


/***LP  PrintClassInfo - Print device class info.
 *
 *  ENTRY
 *      Config -> ConfigSpace
 *      Reg - ConfigSpace register
 *
 *  EXIT
 *      None
 */

VOID
PrintClassInfo(
    IN PUCHAR Config,
    IN ULONG Reg
    )
{
    PPCI_COMMON_CONFIG pcc = (PPCI_COMMON_CONFIG) Config;
    PCI_CLASSCODEDESC classDesc;
    UCHAR baseClass, subClass, progIF;
    PCHAR pch;

    baseClass = pcc->BaseClass;
    subClass = pcc->SubClass;
    progIF = pcc->ProgIf;

    if (Reg == CONFIG_OFFSET(BaseClass)){
        classDesc = BaseClassDescription;
    }else if (Reg == CONFIG_OFFSET(SubClass)){
        classDesc = SubClassDescription;
    }else{

        classDesc = ProgIfDescription;

        //
        //  ProgIf for IDE gets extra attention
        //
        if ((pcc->BaseClass == 0x01) &&
            (pcc->SubClass == 0x01) &&
            (pcc->ProgIf != 0)){

            dprintf(" ");
            if (pcc->ProgIf & 0x80)
                dprintf("MasterIDE ");
            if (pcc->ProgIf & 0x02)
                dprintf("PriNativeCapable ");
            if (pcc->ProgIf & 0x01)
                dprintf("PriNativeMode ");
            if (pcc->ProgIf & 0x08)
                dprintf("SecNativeCapable ");
            if (pcc->ProgIf & 0x04)
                dprintf("SecNativeMode");

            dprintf("\n");
            return;
        }
    }

    if ((pch = GetClassDesc(baseClass, subClass, progIF, classDesc)) != NULL){
        dprintf(" %s", pch);
    }

    dprintf("\n");
}       //PrintClassInfo

VOID
DumpCfgSpace (
    IN PPCI_TYPE1_CFG_BITS PciCfg1
    )
{
    PCI_COMMON_CONFIG commonConfig;
    PPCI_COMMON_CONFIG pcs;
    BYTE bHeaderType;
    DWORD dwOffset, devicePrivateStart;

    dwOffset = 0;

    ReadPci(PciCfg1, (PUCHAR)&commonConfig, 0, sizeof(commonConfig));
    pcs = &commonConfig;
    bHeaderType = pcs->HeaderType & ~PCI_MULTIFUNCTION;

    if (PrintCommonConfigSpace(pcs, "  ")) {
        switch (bHeaderType)
        {
        case PCI_DEVICE_TYPE:
            PrintCfgSpaceType0(pcs, "  ");
            break;

        case PCI_BRIDGE_TYPE:
            PrintCfgSpaceType1(pcs, "  ");
            break;

        case PCI_CARDBUS_BRIDGE_TYPE:
            PrintCfgSpaceType2(pcs, "  ");
            break;

        default:
            dprintf("    TypeUnknown:\n");
            PrintDataRange((PCHAR) &pcs->u, 12, CONFIG_OFFSET(u),  "    ");
        }

        if (bHeaderType == PCI_DEVICE_TYPE) {
            dwOffset = pcs->u.type0.CapabilitiesPtr;
        }
        else if (bHeaderType == PCI_BRIDGE_TYPE) {
            dwOffset = pcs->u.type1.CapabilitiesPtr;
        }
        else if (bHeaderType == PCI_CARDBUS_BRIDGE_TYPE) {
            dwOffset = pcs->u.type2.CapabilitiesPtr;
        }
        else {
            dwOffset = 0;
        }

//        dprintf("Status : %lx     Offset %lx\n", pcs->Status, dwOffset);
        if ((pcs->Status & PCI_STATUS_CAPABILITIES_LIST) &&
            (dwOffset >= PCI_COMMON_HDR_LENGTH)) {

            dprintf(" Capabilities:\n");
            while ((dwOffset != 0)) {
                PPCI_CAPABILITIES_HEADER pCap;

                pCap = (PPCI_CAPABILITIES_HEADER)&((PBYTE)pcs)[dwOffset];

                if (PrintPciCapHeader(pCap, dwOffset, "  ")) {
                    switch (pCap->CapabilityID) {
                        case PCI_CAPABILITY_ID_POWER_MANAGEMENT:
                            PrintPciPowerManagement(((PCHAR)pCap), dwOffset, "  ");
                            break;

                        case PCI_CAPABILITY_ID_AGP_TARGET:
                        case PCI_CAPABILITY_ID_AGP:
                            PrintPciAGP(((PCHAR)pCap), dwOffset, "  ");
                            break;

                        case PCI_CAPABILITY_ID_MSI:
                            PrintPciMSICaps(((PCHAR)pCap), dwOffset, "  ");
                            break;

                        case PCI_CAPABILITY_ID_HYPERTRANSPORT:
                            PrintPciHtCaps(PciCfg1, ((PCHAR)pCap), dwOffset, "  ");
                            break;
                    }
                    dwOffset = pCap->Next;
                } else {
                    break;
                }
            }
        }

    }

    dprintf(" Device Private:\n");

    devicePrivateStart = CONFIG_OFFSET(DeviceSpecific);
    devicePrivateStart += (bHeaderType == PCI_CARDBUS_BRIDGE_TYPE ? sizeof(PCI_TYPE2_HEADER_EXTRAS) : 0);

    PrintDataRange((PCHAR) pcs+devicePrivateStart,
                   (sizeof(PCI_COMMON_CONFIG) - devicePrivateStart)/4, devicePrivateStart, "  ");
}

/***LP  DumpCBRegs - Dump CardBus registers
 *
 *  ENTRY
 *      pbBuff -> register base
 *
 *  EXIT
 *      None
 */

VOID DumpCBRegs(PBYTE pbBuff)
{
    PrintCBRegs((PCHAR) pbBuff, "");
}       //DumpCBRegs

/***LP  DumpExCARegs - Dump ExCA registers
 *
 *  ENTRY
 *      pbBuff -> buffer
 *      dwSize - size of buffer
 *
 *  EXIT
 *      None
 */

VOID DumpExCARegs(PBYTE pbBuff, DWORD dwSize)
{
    PrintExCARegs((PEXCAREGS) pbBuff);
    PrintExCAHiRegs(pbBuff + sizeof(EXCAREGS), "");
}       //DumpExCARegs

DECLARE_API( dcs )
/*++

Routine Description:

    Dumps PCI ConfigSpace

Arguments:

    args - Supplies the Bus.Dev.Fn numbers

Return Value:

    None

--*/
{
    LONG lcArgs;
    DWORD dwBus = 0;
    DWORD dwDev = 0;
    DWORD dwFn = 0;


    lcArgs = sscanf(args, "%lx.%lx.%lx", &dwBus, &dwDev, &dwFn);

    dprintf("!dcs now integrated into !pci 1xx (flag 100).\n"
            "Use !pci 100 %lx %lx %lx to dump PCI config space.\n",
            dwBus, dwDev, dwFn);
    return E_INVALIDARG;


    if (lcArgs != 3)
    {
        dprintf("invalid command syntax\n"
                "Usage: dcs <Bus>.<Dev>.<Func>\n");
    }
    else
    {
        PCI_TYPE1_CFG_BITS PciCfg1;

        PciCfg1.u.AsULONG = 0;
        PciCfg1.u.bits.BusNumber = dwBus;
        PciCfg1.u.bits.DeviceNumber = dwDev;
        PciCfg1.u.bits.FunctionNumber = dwFn;
        PciCfg1.u.bits.Enable = TRUE;

        DumpCfgSpace(&PciCfg1);

    }
    return S_OK;
}

DECLARE_API( ecs )
/*++

Routine Description:

    Edit PCI ConfigSpace

Arguments:

    args - Bus.Dev.Fn
           Dword Offset
           Data

Return Value:

    None

--*/
{

    dprintf("Edit PCI ConfigSpace - must use one of the following:\n"
            "!ecd - edit dword\n"
            "!ecw - edit word\n"
            "!ecb - edit byte\n");

    return S_OK;
}

DECLARE_API( ecb )
/*++

Routine Description:

    Edit PCI ConfigSpace BYTE

Arguments:

    args - Bus.Dev.Fn Offset Data

Return Value:

    None

--*/
{
    LONG                lcArgs;
    DWORD               bus = 0, dev = 0, fn = 0;
    DWORD               offset = 0, data = 0;
    PCI_TYPE1_CFG_BITS  pcicfg;

    lcArgs = sscanf(args, "%lx.%lx.%lx %lx %lx", &bus, &dev, &fn, &offset, &data);
    if (lcArgs != 5)
    {
        dprintf("invalid command syntax\n"
                "Usage: ecb <Bus>.<Dev>.<Func> Offset Data\n");
    }else{

        //
        // Init for PCI config.
        //
        pcicfg.u.AsULONG = 0;
        pcicfg.u.bits.BusNumber = bus;
        pcicfg.u.bits.DeviceNumber = dev;
        pcicfg.u.bits.FunctionNumber = fn;
        pcicfg.u.bits.Enable = TRUE;

        if (!(WritePci (&pcicfg, (PUCHAR)&data, offset, sizeof(UCHAR)))){
            dprintf("write operation failed!\n");
            return S_FALSE;
        }
    }
    return S_OK;
}

DECLARE_API( ecw )
/*++

Routine Description:

    Edit PCI ConfigSpace WORD

Arguments:

    args - Bus.Dev.Fn Offset Data

Return Value:

    None

--*/
{
    LONG                lcArgs;
    DWORD               bus = 0, dev = 0, fn = 0;
    DWORD               offset = 0, data = 0;
    PCI_TYPE1_CFG_BITS  pcicfg;

    lcArgs = sscanf(args, "%lx.%lx.%lx %lx %lx", &bus, &dev, &fn, &offset, &data);
    if (lcArgs != 5)
    {
        dprintf("invalid command syntax\n"
                "Usage: ecw <Bus>.<Dev>.<Func> Offset Data\n");
    }else{

        if ((offset & 0x1) || (offset > 0xfe)) {
            //
            //  not word aligned.
            //
            dprintf("offset must be word aligned and no greater than 0xfe\n");
            return S_OK;
        }

        //
        // Init for PCI config.
        //
        pcicfg.u.AsULONG = 0;
        pcicfg.u.bits.BusNumber = bus;
        pcicfg.u.bits.DeviceNumber = dev;
        pcicfg.u.bits.FunctionNumber = fn;
        pcicfg.u.bits.Enable = TRUE;

        if (!(WritePci (&pcicfg, (PUCHAR)&data, offset, sizeof(USHORT)))){
            dprintf("write operation failed!\n");
            return S_FALSE;
        }

    }
    return S_OK;
}

DECLARE_API( ecd )
/*++

Routine Description:

    Edit PCI ConfigSpace DWORD

Arguments:

    args - Bus.Dev.Fn Offset Data

Return Value:

    None

--*/
{
    LONG                lcArgs;
    DWORD               bus = 0, dev = 0, fn = 0;
    DWORD               offset = 0, data = 0;
    PCI_TYPE1_CFG_BITS  pcicfg;

    lcArgs = sscanf(args, "%lx.%lx.%lx %lx %lx", &bus, &dev, &fn, &offset, &data);
    if (lcArgs != 5)
    {
        dprintf("invalid command syntax\n"
                "Usage: ecd <Bus>.<Dev>.<Func> Offset Data\n");
    }else{

        if ((offset & 0x3) || (offset > 0xfc)) {
            //
            //  not dword aligned.
            //
            dprintf("offset must be dword aligned and no greater than 0xfc\n");
            return S_OK;
        }

        //
        // Init for PCI config.
        //
        pcicfg.u.AsULONG = 0;
        pcicfg.u.bits.BusNumber = bus;
        pcicfg.u.bits.DeviceNumber = dev;
        pcicfg.u.bits.FunctionNumber = fn;
        pcicfg.u.bits.Enable = TRUE;

        if (!(WritePci (&pcicfg, (PUCHAR)&data, offset, sizeof(ULONG)))){
            dprintf("write operation failed!\n");
            return S_FALSE;
        }

    }
    return S_OK;
}

DECLARE_API( cbreg )
/*++

Routine Description:

    Dumps CardBus registers

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/
{
    BOOL rc = TRUE;
    LONG lcArgs;
    BOOL fPhysical = FALSE;
    DWORD dwAddr = 0;

    if (args == NULL)
    {
        dprintf("invalid command syntax\n"
                "Usage: cbreg <RegBaseAddr>\n");
        rc = FALSE;
    }
    else if ((args[0] == '%') && (args[1] == '%'))
    {
        lcArgs = sscanf(&args[2], "%lx", &dwAddr);
        fPhysical = TRUE;
    }
    else
    {
        lcArgs = sscanf(args, "%lx", &dwAddr);
    }

    if ((rc == TRUE) && (lcArgs == 1))
    {
        BYTE abCBRegs[0x14];
        BYTE abExCARegs[0x47];
        DWORD dwSize;

        if (fPhysical)
        {
            ULONG64 phyaddr = 0;

            phyaddr = dwAddr;
            ReadPhysicalWithFlags(phyaddr, abCBRegs, sizeof(abCBRegs), PHYS_FLAG_UNCACHED, &dwSize);
            if (dwSize != sizeof(abCBRegs))
            {
                dprintf("failed to read physical CBRegs (SizeRead=%x)\n",
                        dwSize);
                rc = FALSE;
            }
            else
            {
                phyaddr += 0x800;
                ReadPhysicalWithFlags(phyaddr, abExCARegs, sizeof(abExCARegs), PHYS_FLAG_UNCACHED, &dwSize);
                if (dwSize != sizeof(abExCARegs))
                {
                    dprintf("failed to read physical ExCARegs (SizeRead=%x)\n",
                            dwSize);
                    rc = FALSE;
                }
            }
        }
        else if (!ReadMemory(dwAddr, abCBRegs, sizeof(abCBRegs), &dwSize) ||
                 (dwSize != sizeof(abCBRegs)))
        {
            dprintf("failed to read CBRegs (SizeRead=%x)\n", dwSize);
            rc = FALSE;
        }
        else if (!ReadMemory(dwAddr + 0x800, abExCARegs, sizeof(abExCARegs),
                             &dwSize) ||
                 (dwSize != sizeof(abExCARegs)))
        {
            dprintf("failed to read CBRegs (SizeRead=%x)\n", dwSize);
            rc = FALSE;
        }

        if (rc == TRUE)
        {
            dprintf("\nCardBus Registers:\n");
            DumpCBRegs(abCBRegs);
            dprintf("\nExCA Registers:\n");
            DumpExCARegs(abExCARegs, sizeof(abExCARegs));
        }
    }
    return S_OK;
}

DECLARE_API( exca )
/*++

Routine Description:

    Dumps CardBus ExCA registers

Arguments:

    args - Supplies <BasePort>.<SktNum>

Return Value:

    None

--*/
{
    LONG lcArgs;
    DWORD dwBasePort = 0;
    DWORD dwSktNum = 0;

    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("X86 target only API.\n");
        return E_INVALIDARG;
    }

    lcArgs = sscanf(args, "%lx.%lx", &dwBasePort, &dwSktNum);
    if (lcArgs != 2)
    {
        dprintf("invalid command syntax\n"
                "Usage: exca <BasePort>.<SocketNum>\n");
    }
    else
    {
        int i;
        BYTE abExCARegs[0x40];

        for (i = 0; i < sizeof(abExCARegs); ++i)
        {
            abExCARegs[i] = ReadExCAByte(dwBasePort,
                                         (ULONG)(dwSktNum*0x40 + i));
        }

        DumpExCARegs(abExCARegs, sizeof(abExCARegs));
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\pci.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pci.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 18-August-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "pci.h"
#include "pcip.h"
#pragma hdrstop


#define DUMP_VERBOSE                    0x01
#define DUMP_TO_MAX_BUS                 0x02        // from 0 to max
#define DUMP_RAW_BYTES                  0x04        // hex dump dump raw bytes
#define DUMP_RAW_DWORDS                 0x08        // hex dump dump raw dwords

#define DUMP_ALLOW_INVALID_DEVICE       0x10
#define DUMP_ALLOW_INVALID_FUNCTION     0x20
#define DUMP_CAPABILITIES               0x40
#define DUMP_INTEL                      0x80

#define DUMP_CONFIGSPACE               0x100

#define ANY                 0xFF

UCHAR PCIDeref[4][4] = { {4,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };

VOID
HexDump (
    IN ULONG    indent,
    IN ULONG    va,
    IN ULONG    len,
    IN ULONG    width,
    IN PUCHAR   buf
    )
{
    UCHAR   s[80], t[80];
    PUCHAR  ps, pt;
    ULONG   i;
    static  UCHAR rgHexDigit[] = "0123456789abcdef";

    i = 0;

    //
    // If width = 4, dull dump, similar to debugger's dd command.
    //

    if (width == 4) {
        if (len & 3) {
            dprintf("hexdump internal error, dump dword, (len & 3) != 0\n");

            // round up.

            len += 3;
            len &= ~3;
        }
        while (len) {
            if (i == 0) {
                dprintf("%*s%08x: ", indent, "", va);
                va += 16;
            }
            dprintf(" %08x", *(ULONG UNALIGNED *)buf);
            len -= 4;
            buf += 4;
            if (i == 3) {
                dprintf("\n");
                i = 0;
            } else {
                i++;
            }
        }
        return;
    }

    if (width != 1) {
        dprintf ("hexdump internal error\n");
        return ;
    }

    //
    // Width = 1, pretty dump, similar to debugger's db command.
    //

    while (len) {
        ps = s;
        pt = t;

        ps[0] = 0;
        pt[0] = '*';
        pt++;

        for (i=0; i < 16; i++) {
            ps[0] = ' ';
            ps[1] = ' ';
            ps[2] = ' ';

            if (len) {
                ps[0] = rgHexDigit[buf[0] >> 4];
                ps[1] = rgHexDigit[buf[0] & 0xf];
                pt[0] = buf[0] < ' ' || buf[0] > 'z' ? '.' : buf[0];

                len -= 1;
                buf += 1;
                pt  += 1;
            }
            ps += 3;
        }

        ps[0] = 0;
        pt[0] = '*';
        pt[1] = 0;
        s[23] = '-';

        if (s[0]) {
            dprintf ("%*s%08lx: %s  %s\n", indent, "", va, s, t);
            va += 16;
        }
    }

}

BOOL
ReadPci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    OUT PUCHAR                  Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )
{
    ULONG                   InputSize;
    ULONG                   IoSize;
    ULONG                   i;
    BUSDATA                 busData;
    PCI_SLOT_NUMBER         slot;
    BOOL                    b;
    
    //
    // Zap input buffer
    //

    for (i=0; i < Length; i++) {
        Buffer[i] = 0xff;
    }

    //
    // It appears that we are only safe to call the HAL for reading
    // configuration space if the HAL has actually been initialized far
    // enough to do so.  Since we have already hit a case where we hadnt
    // initialized everything and it crashed the debugger, we are restoring
    // X86 so that it reads configspace the way it always used to do.
    //
    // For non-X86 (i.e IA64) we are forced to call the HAL because we
    // currently have no other option.  This means we may still crash on
    // those platforms in the case where
    // the HAL hasnt been initialized enough to handle it.
    //

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

        while (Length) {
            PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
            IoSize = sizeof(ULONG);
#ifdef IG_IO_SPACE_RETURN
            b = 
#else
            b = TRUE;
#endif          
                WriteIoSpace64 ( PCI_TYPE1_ADDR_PORT, PciCfg1->u.AsULONG, &IoSize );
            if (!b) {
                return FALSE;
            }
            IoSize = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
            i = IoSize;
    
            ReadIoSpace64 (
                PCI_TYPE1_DATA_PORT + (Offset % sizeof(ULONG)),
                (PULONG) Buffer,
                &i
                );
    
            Offset += IoSize;
            Buffer += IoSize;
            Length -= IoSize;
        }
    }else{
    
        //
        //  Here we are going to call the debugger api that results in the 
        //  call to HalGetBusDataByOffset for the read.
        //  
        //  Note: This will crash the current debug session of attempted too
        //  early in boot.
        //

        slot.u.AsULONG              = 0;
        slot.u.bits.DeviceNumber    = PciCfg1->u.bits.DeviceNumber;
        slot.u.bits.FunctionNumber  = PciCfg1->u.bits.FunctionNumber;
    
        busData.BusDataType         = PCIConfiguration;
        busData.BusNumber           = PciCfg1->u.bits.BusNumber;
        busData.SlotNumber          = slot.u.AsULONG;
        busData.Offset              = Offset;
        busData.Buffer              = Buffer;
        busData.Length              = Length;
    
        //
        // Read it
        //
#ifdef IG_IO_SPACE_RETURN
        b = 
#else
        b = TRUE;
#endif          
        Ioctl(IG_GET_BUS_DATA, &busData, sizeof(busData));
        if (!b) {
            return FALSE;
        }
    }
    return TRUE;
}

BOOLEAN
WritePci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )
{
    
    ULONG                   IoSize;
    ULONG                   i;
    BUSDATA                 busData;
    PCI_SLOT_NUMBER         slot;
    
    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

        //
        //  For the same reasons as the read, we are only calling the HAL
        //  on non-x86 targets for now.
        // 
    
        while (Length) {
            PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
            IoSize = sizeof(ULONG);
            WriteIoSpace64 ((ULONG) PCI_TYPE1_ADDR_PORT, PciCfg1->u.AsULONG, &IoSize );
    
            IoSize = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
            i = IoSize;
    
            WriteIoSpace64 (
                PCI_TYPE1_DATA_PORT + (Offset % sizeof(ULONG)),
                *(PULONG)Buffer,
                &i);
    
            Offset += IoSize;
            Buffer += IoSize;
            Length -= IoSize;
        }
    }else{

        slot.u.AsULONG              = 0;
        slot.u.bits.DeviceNumber    = PciCfg1->u.bits.DeviceNumber;
        slot.u.bits.FunctionNumber  = PciCfg1->u.bits.FunctionNumber;
    
        busData.BusDataType         = PCIConfiguration;
        busData.BusNumber           = PciCfg1->u.bits.BusNumber;
        busData.SlotNumber          = slot.u.AsULONG;
        busData.Offset              = Offset;
        busData.Buffer              = Buffer;
        busData.Length              = Length;

        //
        // Write it
        //
        if (!(Ioctl(IG_SET_BUS_DATA, &busData, sizeof(busData)))){
            return FALSE;
        }


    }

    return TRUE;
}

VOID
DumpPciBar (
    IN ULONG        barno,
    IN ULONG        indent,
    IN ULONG        bar,
    IN OUT PULONG   state
    )
{
    ULONG       type, i;
    CHAR        m[20], str[80];

    if (bar) {

        if (bar & 1) {
            sprintf (str, "IO[%d]:%x  ", barno, bar);

        } else {
            type = (bar >> 1) & 0x3;

            if (bar & 8) {
                strcpy (m, "MPF");
            } else {
                strcpy (m, "MEM");
            }

            if (type == 0x01) {
                m[1] = '1';         // less then 1M
            }

            sprintf (str, "%s[%d]:%x  ", m, barno, bar);

            if (type == 0x10) {
                dprintf ("warning - 64bit bar not decoded\n");
                *state = 0;
            }
            if (type == 0x11) {
                dprintf ("bar type is reserved\n");
                *state = 0;
            }
        }

        if (!*state) {
            dprintf ("%*s", indent, "");
        }

        i = strlen(str);
        dprintf("%s%*s", str, 17-i, "");
        *state += i;
    }
}


VOID
DumpPciType2Bar(
    IN BOOLEAN    barIsIo,
    IN BOOLEAN    barIsBase,
    IN ULONG      barno,
    IN ULONG      indent,
    IN ULONG      bar,
    IN OUT PULONG state
    )
{
   ULONG      i;
   CHAR       str[80];
   if (bar) {
     if (barIsIo) {
          sprintf (str, "IO[%d].%s:%x  ", barno, (barIsBase?"base":"limit"), bar);
     } else {
          sprintf (str, "MEM[%d].%s:%x  ", barno, (barIsBase?"base":"limit"), bar);
     }
     if (!*state) {
          dprintf("%*s", indent, "");
     }
     i = strlen(str);
     dprintf("%s%*s", str, 17-i, "");
     *state += i;
   }
}
    
               
VOID
DumpPciBarComplete(
    IN OUT PULONG   state
    )
{
    if (*state) {
        dprintf ("\n");
        *state = 0;
    }
}


VOID
DumpCapabilities(
    IN UCHAR                    CapPtr,
    IN PPCI_TYPE1_CFG_BITS      PciCfg1
    )
{
    union _cap_buffer {
        PCI_CAPABILITIES_HEADER header;
        PCI_PM_CAPABILITY       pm;
        PCI_AGP_CAPABILITY      agp;
        PCI_HT_CAPABILITY       ht;
    } cap;

    PCHAR ts;
    ULONG  t;

    do {
        if (CapPtr < PCI_COMMON_HDR_LENGTH) {

            dprintf("       Error: Capability pointer 0x%02x points to common header (invalid).\n",
                CapPtr
                );
            break;
        }

        if (CapPtr & 0x3) {

            dprintf("       Error: Capability pointer 0x%02x not DWORD aligned (invalid).\n",
                CapPtr
                );
            break;
        }

        ReadPci (
            PciCfg1,
            (PUCHAR)&cap,
            CapPtr,
            sizeof(cap.header)
            );

        switch (cap.header.CapabilityID) {
            case PCI_CAPABILITY_ID_POWER_MANAGEMENT:

                ReadPci (
                    PciCfg1,
                    (PUCHAR)&cap,
                    CapPtr,
                    sizeof(cap.pm)
                    );
                t = cap.pm.PMC.AsUSHORT;
                dprintf("      Cap[%02x] ID %02x PowerManagement\n",
                    CapPtr,
                    cap.header.CapabilityID
                    );
                dprintf("          PMC   %04x (%s%s%s%s%s%s %s%s%s%s%s%sv%x)\n",
                    t,
                    t & 0xf800 ? "PME from D" : "<No PME>",
                    t & 0x8000 ? "3C" : "",
                    t & 0x4000 ? "3H" : "",
                    t & 0x2000 ? "2" : "",
                    t & 0x1000 ? "1" : "",
                    t & 0x0800 ? "0" : "",
                    t & 0x0600 ? "Supports D" : "",
                    cap.pm.PMC.Capabilities.Support.D2 ? "2" : "",
                    cap.pm.PMC.Capabilities.Support.D1 ? "1" : "",
                    t & 0x0600 ? " " : "",
                    cap.pm.PMC.Capabilities.DeviceSpecificInitialization ?
                        "DSI " : "",
                    cap.pm.PMC.Capabilities.PMEClock ? "PME needs Clock, " : "",
                    cap.pm.PMC.Capabilities.Version
                    );
                        
                t &= 0x01d0;
                if (t) {
                    dprintf("                         WARNING PMC non-zero reserved fields %04x\n",
                        t
                        );
                }

                t = cap.pm.PMCSR.AsUSHORT;
                dprintf("          PMCSR %04x (PME_Status=%d PME_En=%d State=D%d%s)\n",
                    t,
                    cap.pm.PMCSR.ControlStatus.PMEStatus,
                    cap.pm.PMCSR.ControlStatus.PMEEnable,
                    cap.pm.PMCSR.ControlStatus.PowerState,
                    cap.pm.PMCSR.ControlStatus.PowerState == 3 ?
                        "hot" : ""
                    );

                //
                // Here would be a good time to run
                // run down the data registers if
                // they exist.
                //

                break;

            case PCI_CAPABILITY_ID_AGP_TARGET:
            case PCI_CAPABILITY_ID_AGP:

                ReadPci (
                    PciCfg1,
                    (PUCHAR)&cap,
                    CapPtr,
                    sizeof(cap.agp)
                    );

                switch (cap.agp.AGPStatus.Rate) {
                    case 1:
                        ts = "1X";
                        break;
                    case 2:
                        ts = "2X";
                        break;
                    case 3:
                        ts = "1,2X";
                        break;
                    default:
                        ts = "<inv>";
                        break;
                }
                t = *(PULONG)&cap.agp.AGPStatus;

                dprintf("      Cap[%02x] ID %02x AGP mj/mn=%x/%x\n",
                    CapPtr,
                    cap.header.CapabilityID,
                    cap.agp.Major,
                    cap.agp.Minor
                    );

                dprintf("          Status  %08x (Rq:%02x SBA:%x FW:%x Rate:%x (%s))\n",
                    t,
                    cap.agp.AGPStatus.RequestQueueDepthMaximum,
                    cap.agp.AGPStatus.SideBandAddressing,
                    cap.agp.AGPStatus.FastWrite,
                    cap.agp.AGPStatus.Rate,
                    ts
                    );

                switch (cap.agp.AGPCommand.Rate) {
                    case 1:
                        ts = "1X";
                        break;
                    case 2:
                        ts = "2X";
                        break;
                    case 4:
                        ts = "4X";
                        break;
                    default:
                        ts = "<not set>";
                        break;
                }
                t = *(PULONG)&cap.agp.AGPCommand;

                dprintf("          Command %08x (Rq:%02x SBA:%x FW:%x AGP:%x Rate:%x (%s)\n",
                    t,
                    cap.agp.AGPCommand.RequestQueueDepth,
                    cap.agp.AGPCommand.SBAEnable,
                    cap.agp.AGPCommand.FastWriteEnable,
                    cap.agp.AGPCommand.AGPEnable,
                    cap.agp.AGPCommand.Rate,
                    ts
                    );

                break;

            case PCI_CAPABILITY_ID_HYPERTRANSPORT:

                ReadPci(
                    PciCfg1,
                    (PUCHAR)&cap,
                    CapPtr,
                    sizeof(cap.ht)
                    );

                dprintf("      Cap[%02x] ID %02x HyperTransport\n",
                    CapPtr,
                    cap.header.CapabilityID
                    );
                dprintf("          ");
                PrintPciHtCommandReg((PPCI_HT_CAPABILITY) &cap.ht);
                //
                //  PrintPciHtCommandReg() doesnt print a new line if the 
                //  type happens to be interruptdiscovery
                //
                if (cap.ht.Command.Generic.CapabilityType == HTInterruptDiscoveryConfig) {
                    dprintf("\n");
                }
                break;

            case PCI_CAPABILITY_ID_VPD:
                dprintf("      Cap[%02x] ID %02x VPD\n",
                        CapPtr,
                        cap.header.CapabilityID
                        );
                break;

            case PCI_CAPABILITY_ID_SLOT_ID:
                dprintf("      Cap[%02x] ID %02x SLOT ID\n",
                        CapPtr,
                        cap.header.CapabilityID
                        );
                break;


            case PCI_CAPABILITY_ID_CPCI_HOTSWAP:
                dprintf("      Cap[%02x] ID %02x CPCI HotSwap\n",
                        CapPtr,
                        cap.header.CapabilityID
                        );
                break;

            case PCI_CAPABILITY_ID_PCIX:
                dprintf("      Cap[%02x] ID %02x PCI-X\n",
                        CapPtr,
                        cap.header.CapabilityID
                        );
                break;


            case PCI_CAPABILITY_ID_VENDOR_SPECIFIC:
                dprintf("      Cap[%02x] ID %02x Vendor Specific\n",
                        CapPtr,
                        cap.header.CapabilityID
                        );
                break;

            case PCI_CAPABILITY_ID_DEBUG_PORT:
                dprintf("      Cap[%02x] ID %02x Debug Port\n",
                        CapPtr,
                        cap.header.CapabilityID
                        );
                break;

            case PCI_CAPABILITY_ID_CPCI_RES_CTRL:
                dprintf("      Cap[%02x] ID %02x CPCI Resource Control\n",
                        CapPtr,
                        cap.header.CapabilityID
                        );
                
                break;

            case PCI_CAPABILITY_ID_SHPC:
                dprintf("      Cap[%02x] ID %02x SHPC\n",
                        CapPtr,
                        cap.header.CapabilityID
                        );
                break;

            default:

                dprintf("      Cap[%02x] ID %02x Unknown\n",
                    CapPtr,
                    cap.header.CapabilityID
                    );

                break;
        }
        CapPtr = cap.header.Next;
    } while (CapPtr != 0);
}

VOID
pcidump (
    IN ULONG        Flags,
    IN ULONG        MinBus,
    IN ULONG        MaxBus,
    IN ULONG        MinDevice,
    IN ULONG        MaxDevice,
    IN ULONG        MinFunction,
    IN ULONG        MaxFunction,
    IN ULONG        MinAddr,
    IN ULONG        MaxAddr
    )
{
    ULONG                   Bus, Device, Function;
    PCI_TYPE1_CFG_BITS      PciCfg1;
    PCI_COMMON_CONFIG       PciHdr;
    BOOLEAN                 BusHeader, SkipLine, BarIsIo;
    ULONG                   Type, Len, i;
    UCHAR                   s[40];
    PUCHAR                  Buf;
    ULONG                   state;
    ULONG                   bar, barno;

    if (MinBus > 0xFF || MaxBus > 0xFF ||
        MinDevice > PCI_MAX_DEVICES || MaxDevice > PCI_MAX_DEVICES ||
        MinFunction > PCI_MAX_FUNCTION || MaxFunction > PCI_MAX_FUNCTION ||
        MinAddr > 0xFF || MaxAddr > 0x100 || MinAddr > MaxAddr) {

        dprintf ("Bad pci dump parameter\n");

        //dprintf ("Flags %d  MinBus %d  MaxBus %d\n", Flags, MinBus, MaxBus);
        //dprintf ("MinDev %d  MaxDev %d  MinFnc %d MinFnc %d\n", MinDevice, MaxDevice, MinFunction, MaxFunction);

        return ;
    }

    //dprintf ("Flags %d  MinAddr %d  MaxAddr %d\n", Flags, MinAddr, MaxAddr);

    for (Bus=MinBus; Bus <= MaxBus; Bus++) {

        BusHeader = FALSE;

        for (Device=MinDevice; Device <= MaxDevice; Device++) {

            if (CheckControlC()) {
                return;
            }

            //
            // Read the device ID
            //

            PciCfg1.u.AsULONG = 0;
            PciCfg1.u.bits.BusNumber = Bus;
            PciCfg1.u.bits.DeviceNumber = Device;
            PciCfg1.u.bits.FunctionNumber = 0;
            PciCfg1.u.bits.Enable = TRUE;

            ReadPci (&PciCfg1, (PUCHAR) &PciHdr, 0, sizeof(ULONG));

            //
            // If not a valid ID, skip to next device

            if (PciHdr.VendorID == PCI_INVALID_VENDORID) {
                if (!(Flags & DUMP_ALLOW_INVALID_DEVICE)) {
                    dprintf ("%02x\r", Device);
                    continue;
                }
            }


            for (Function=MinFunction; Function <= MaxFunction; Function++) {

                if (CheckControlC()) {
                    return;
                }

                PciCfg1.u.bits.FunctionNumber = Function;

                //
                // Read device ID
                //

                if (Function) {
                    ReadPci (&PciCfg1, (PUCHAR) &PciHdr, 0, sizeof(ULONG));
                }

                if (PciHdr.VendorID == PCI_INVALID_VENDORID) {
                    if (!(Flags & DUMP_ALLOW_INVALID_DEVICE)) {
                        continue;
                    }
                }

                //
                // Dump ID
                //

                if (!BusHeader) {
                    dprintf ("PCI Bus %s%x\n", 
                             (Bus ? "0x" : ""),
                             Bus);
                    BusHeader = TRUE;
                }

                dprintf ("%02x:%x  %04x:%04x",
                        Device,
                        Function,
                        PciHdr.VendorID,
                        PciHdr.DeviceID
                        );

                //
                // Read the rest of the common header
                //

                ReadPci (
                    &PciCfg1,
                    ((PUCHAR) &PciHdr)  + sizeof(ULONG),
                    0                   + sizeof(ULONG),
                    PCI_COMMON_HDR_LENGTH
                    );

                Type = PciHdr.HeaderType & ~PCI_MULTIFUNCTION;

                if (Type == 0x7f && PciHdr.BaseClass == 0xff && PciHdr.SubClass == 0xff) {
                    if (!(Flags & DUMP_ALLOW_INVALID_FUNCTION)) {
                        dprintf ("  bogus, skipping rest of device\n");
                        break;
                    }
                }

                //
                // Dump it
                //

                s[0] = PciHdr.Command & PCI_ENABLE_IO_SPACE                 ? 'i' : '.';
                s[1] = PciHdr.Command & PCI_ENABLE_MEMORY_SPACE             ? 'm' : '.';
                s[2] = PciHdr.Command & PCI_ENABLE_BUS_MASTER               ? 'b' : '.';
                s[3] = PciHdr.Command & PCI_ENABLE_VGA_COMPATIBLE_PALETTE   ? 'v' : '.';
                s[4] = PciHdr.Command & PCI_ENABLE_PARITY                   ? 'p' : '.';
                s[5] = PciHdr.Command & PCI_ENABLE_SERR                     ? 's' : '.';
                s[6] = 0;
                dprintf (".%02x  Cmd[%04x:%s]  ", PciHdr.RevisionID, PciHdr.Command, s);

                s[0] = PciHdr.Status & PCI_STATUS_CAPABILITIES_LIST        ? 'c' : '.';
                s[1] = PciHdr.Status & PCI_STATUS_66MHZ_CAPABLE            ? '6' : '.';
                s[2] = PciHdr.Status & PCI_STATUS_DATA_PARITY_DETECTED     ? 'P' : '.';
                s[3] = PciHdr.Status & PCI_STATUS_SIGNALED_TARGET_ABORT    ? 'A' : '.';
                s[4] = PciHdr.Status & PCI_STATUS_SIGNALED_SYSTEM_ERROR    ? 'S' : '.';
                s[5] = 0;
                dprintf ("Sts[%04x:%s]  ", PciHdr.Status, s);


                //
                // Search for a vendor name match
                //
                PCHAR Desc = GetVendorDesc(PciHdr.VendorID, FALSE);

                if (Desc) {
                    dprintf ("%s ", Desc);
                }

                //
                // Search for a class code match
                //
                Desc = GetClassDesc(PciHdr.BaseClass, PciHdr.SubClass, PciHdr.ProgIf, SubClassDescription);

                if (Desc) {
                    dprintf ("%s", Desc);
                } else {
                    dprintf ("Class:%x:%x:%x",
                        PciHdr.BaseClass,
                        PciHdr.SubClass,
                        PciHdr.ProgIf
                        );
                }

                switch (Type) {
                    case PCI_DEVICE_TYPE:

                        if (PciHdr.u.type0.SubVendorID || PciHdr.u.type0.SubSystemID) {
                            dprintf ("  SubID:%04x:%04x",
                                PciHdr.u.type0.SubVendorID,
                                PciHdr.u.type0.SubSystemID
                                );
                        }
                        break;

                    case PCI_BRIDGE_TYPE:
                        dprintf(" %s%x->%s%x-%s%x",
                            (PciHdr.u.type1.PrimaryBus ? "0x" : ""),
                            PciHdr.u.type1.PrimaryBus,
                            (PciHdr.u.type1.SecondaryBus ? "0x" : ""),
                            PciHdr.u.type1.SecondaryBus,
                            (PciHdr.u.type1.SubordinateBus ? "0x" : ""),
                            PciHdr.u.type1.SubordinateBus
                            );
                        break;

                    case PCI_CARDBUS_BRIDGE_TYPE:
                        dprintf(" %s%x->%s%x-%s%x",
                            (PciHdr.u.type2.PrimaryBus > 0 ? "0x" : ""),    
                            PciHdr.u.type2.PrimaryBus,
                            (PciHdr.u.type2.SecondaryBus > 0 ? "0x" : ""),
                            PciHdr.u.type2.SecondaryBus,
                            (PciHdr.u.type2.SubordinateBus > 0 ? "0x" : ""),
                            PciHdr.u.type2.SubordinateBus
                            );
                        break;

                    default:
                        dprintf ("type %x", Type);
                        break;
                }

                dprintf ("\n");
                SkipLine = FALSE;

                if (Flags & DUMP_VERBOSE) {
                    SkipLine = TRUE;
                    PciCfg1.u.bits.RegisterNumber = 0;
                    switch (Type) {
                        case PCI_DEVICE_TYPE:
                            dprintf ("      cf8:%x  IntPin:%x  IntLine:%x  Rom:%x  cis:%x  cap:%x\n",
                                PciCfg1.u.AsULONG,
                                PciHdr.u.type0.InterruptPin,
                                PciHdr.u.type0.InterruptLine,
                                PciHdr.u.type0.ROMBaseAddress,
                                PciHdr.u.type0.CIS,
                                PciHdr.u.type0.CapabilitiesPtr
                            );

                            state = 0;
                            for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
                                bar = PciHdr.u.type0.BaseAddresses[i];
                                DumpPciBar(i, 6, bar, &state);
                            }
                            DumpPciBarComplete(&state);
                            break;

                        case PCI_BRIDGE_TYPE:
                            i = PciHdr.u.type1.BridgeControl;
                            dprintf ("      cf8:%x  IntPin:%x  IntLine:%x  Rom:%x  cap:%x  2sts:%x  BCtrl:%x%s%s%s\n",
                                PciCfg1.u.AsULONG,
                                PciHdr.u.type1.InterruptPin,
                                PciHdr.u.type1.InterruptLine,
                                PciHdr.u.type1.ROMBaseAddress,
                                PciHdr.u.type1.CapabilitiesPtr,
                                PciHdr.u.type1.SecondaryStatus,
                                PciHdr.u.type1.BridgeControl,
                                i & PCI_ENABLE_BRIDGE_VGA   ? " VGA" : "",
                                i & PCI_ENABLE_BRIDGE_ISA   ? " ISA" : "",
                                i & PCI_ASSERT_BRIDGE_RESET ? " RESET" : ""
                                );

                            dprintf ("      IO:%x-%x  Mem:%x-%x  PMem:%x-%x\n",
                                PciBridgeIO2Base (PciHdr.u.type1.IOBase,  PciHdr.u.type1.IOBaseUpper16),
                                PciBridgeIO2Limit(PciHdr.u.type1.IOLimit, PciHdr.u.type1.IOLimitUpper16),
                                PciBridgeMemory2Base (PciHdr.u.type1.MemoryBase),
                                PciBridgeMemory2Limit(PciHdr.u.type1.MemoryLimit),
                                PciBridgeMemory2Base (PciHdr.u.type1.PrefetchBase),
                                PciBridgeMemory2Limit(PciHdr.u.type1.PrefetchLimit)
                                );

                            state = 0;
                            for (i=0; i < PCI_TYPE1_ADDRESSES; i++) {
                                bar = PciHdr.u.type1.BaseAddresses[i];
                                DumpPciBar(i, 6, bar, &state);
                            }
                            DumpPciBarComplete(&state);
                            break;

                        case PCI_CARDBUS_BRIDGE_TYPE:
                            i = PciHdr.u.type2.BridgeControl;
                            dprintf ("      cf8:%x  IntPin:%x  IntLine:%x  SocketRegBase:%x  cap:%x  2sts:%x  BCtrl:%x%s%s%s\n",
                                PciCfg1.u.AsULONG,
                                PciHdr.u.type2.InterruptPin,
                                PciHdr.u.type2.InterruptLine,
                                PciHdr.u.type2.SocketRegistersBaseAddress,
                                PciHdr.u.type2.CapabilitiesPtr,
                                PciHdr.u.type2.SecondaryStatus,
                                PciHdr.u.type2.BridgeControl,
                                i & PCI_ENABLE_BRIDGE_VGA   ? " VGA" : "",
                                i & PCI_ENABLE_BRIDGE_ISA   ? " ISA" : "",
                                i & PCI_ASSERT_BRIDGE_RESET ? " RESET" : ""
                                );
                            dprintf("\n");
                            state=0;
                            for (i = 0; i < (PCI_TYPE2_ADDRESSES - 1); i++) {
                                bar = PciHdr.u.type2.Range[i].Base;
                                //
                                // First 2 BARs (base+limit) are memory
                                //
                                BarIsIo =  (i > 1);
                                barno =  i;
                                if (BarIsIo) {
                                      barno -= 2;
                                }
                                DumpPciType2Bar(BarIsIo,TRUE, barno, 6, bar, &state);

                                bar = PciHdr.u.type2.Range[i].Limit;
                                DumpPciType2Bar(BarIsIo, FALSE, i, 6, bar, &state);
                            }
                            DumpPciBarComplete(&state);
                            break;
                    }
                }

                //
                // Dump CAPABILITIES if any.
                //

                if (Flags & DUMP_CAPABILITIES) {
                    if (PciHdr.Status & PCI_STATUS_CAPABILITIES_LIST) {
                        UCHAR capPtr = 0;

                        SkipLine = TRUE;

                        switch (Type) {
                            case PCI_DEVICE_TYPE:
                                capPtr = PciHdr.u.type0.CapabilitiesPtr;
                                break;
        
                            case PCI_BRIDGE_TYPE:
                                capPtr = PciHdr.u.type1.CapabilitiesPtr;
                                break;
        
                            case PCI_CARDBUS_BRIDGE_TYPE:
                                capPtr = PciHdr.u.type2.CapabilitiesPtr;
                                break;
                        }

                        if (capPtr != 0) {
                            DumpCapabilities(capPtr, &PciCfg1);
                        } else {

                            //
                            // Capabilities flag is set in Status but
                            // pointer is 0???  Something's broken.
                            //

                            dprintf("       Warning: Capability bit set in Status but capability pointer is 0.\n");
                        }
                    }
                }

                //
                // Dump hex bytes
                //

                if (Flags & DUMP_RAW_BYTES) {

                    ULONG w;

                    //
                    // Raw dump requested, if no range default to common
                    // config.
                    //

                    if (!MinAddr && !MaxAddr) {
                        MaxAddr = PCI_COMMON_HDR_LENGTH - 1;
                    }

                    //
                    // Default width to 1.  If dumping dwords, set width
                    // width to 4 and round min and max accordingly.
                    //

                    w = 1;
                    if (Flags & DUMP_RAW_DWORDS) {
                        w = 4;
                        MinAddr &= ~3;
                        MaxAddr &= ~3;
                        MaxAddr += 3;
                    }
                    Buf = ((PUCHAR) &PciHdr) + MinAddr;
                    Len = MaxAddr - MinAddr + 1;

                    if (MinAddr <= PCI_COMMON_HDR_LENGTH) {
                        if (MaxAddr > PCI_COMMON_HDR_LENGTH) {
                            ReadPci (
                                &PciCfg1,
                                PciHdr.DeviceSpecific,
                                PCI_COMMON_HDR_LENGTH,
                                MaxAddr - PCI_COMMON_HDR_LENGTH
                                );
                        }

                    } else {
                        ReadPci (&PciCfg1, Buf, MinAddr, Len);
                    }

                    HexDump (w == 4 ? 6 : 1, MinAddr, Len, w, Buf);
                    SkipLine = TRUE;

                } else if ((Flags & DUMP_INTEL) && PciHdr.VendorID == 0x8086) {

                    Buf = PciHdr.DeviceSpecific;
                    Len = sizeof (PciHdr) - PCI_COMMON_HDR_LENGTH;

                    ReadPci (&PciCfg1, Buf, PCI_COMMON_HDR_LENGTH, Len);
                    HexDump (1, PCI_COMMON_HDR_LENGTH,  Len, 1, Buf);
                    SkipLine = TRUE;
                }

                if (Flags & DUMP_CONFIGSPACE) {
                    
                    dprintf ("Config Space: (Bus: %x  Device: %x  Func: %x)\n", 
                             PciCfg1.u.bits.BusNumber,
                             PciCfg1.u.bits.DeviceNumber,
                             PciCfg1.u.bits.FunctionNumber);
                    
                    DumpCfgSpace(&PciCfg1);
                    dprintf ("\n");
                }

                if (SkipLine) {
                    dprintf ("\n");
                }

                //
                // If no more functions on this device, skip the rest
                // of the functions
                //

                if (Function == 0 && !(PciHdr.HeaderType & PCI_MULTIFUNCTION)) {
                    if (!(Flags & DUMP_ALLOW_INVALID_FUNCTION)) {
                        break;
                    }
                }

            }
        }
    }
}


DECLARE_API( pci )

/*++

Routine Description:

    Dumps pci type2 config data

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/
{
    LONG        noargs;
    ULONG       Flags;
    ULONG       MinBus, MaxBus;
    ULONG       Device, MinDevice, MaxDevice;
    ULONG       Function, MinFunction, MaxFunction;
    ULONG       MinAddr, MaxAddr;

    MinBus = 0;
    MaxBus = 0;
    MinDevice = 0;
    MaxDevice = PCI_MAX_DEVICES - 1;
    MinFunction = 0;
    MaxFunction = PCI_MAX_FUNCTION - 1;
    MinAddr = 0;
    MaxAddr = 0;
    Flags = 0;
    
   if (g_TargetQual == DEBUG_DUMP_SMALL || 
       g_TargetQual == DEBUG_DUMP_DEFAULT || 
       g_TargetQual == DEBUG_DUMP_FULL) {
        dprintf("!pci does not work for dump targets\n");
        return E_INVALIDARG;
    }
    
    {
    INIT_API();


    noargs = sscanf(args,"%lX %lX %lX %lX %lX %lX",
                    &Flags,         // 1
                    &MaxBus,        // 2
                    &Device,        // 3
                    &Function,      // 4
                    &MinAddr,       // 5
                    &MaxAddr        // 6
                    );

    MinBus = MaxBus;
    if (Flags & DUMP_TO_MAX_BUS) {
        MinBus = 0;
    }

    if (noargs >= 3) {
        Flags |= DUMP_ALLOW_INVALID_DEVICE;
        MinDevice = Device;
        MaxDevice = Device;
    }

    if (noargs >= 4) {
        MinFunction = Function;
        MaxFunction = Function;
    }

    if (MinAddr || MaxAddr) {
        Flags |= DUMP_RAW_BYTES;
    }

    if (Flags & DUMP_RAW_DWORDS) {
        Flags |= DUMP_RAW_BYTES;
    }

    pcidump (
        Flags,
        MinBus,        MaxBus,
        MinDevice,     MaxDevice,
        MinFunction,   MaxFunction,
        MinAddr,       MaxAddr
        );

    EXIT_API();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\pcskthw.h ===
/*** pcskthw.h - PC Card Socket Hardware Definitions
 *
 *  Copyright (c) 1995,1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/28/95
 *
 *  MODIFICATION HISTORY
 */


#ifndef _PCSKTHW_H
#define _PCSKTHW_H


//#ifdef CARDBUS

/*** CardBus Constants
 */

//PCI IDs
#define PCIID_TI_PCI1130                0xac12104c
#define PCIID_TI_PCI1131		0xac15104c
#define PCIID_TI_PCI1031		0xac13104c
#define PCIID_OPTI_82C824		0xc8241045
#define PCIID_OPTI_82C814		0xc8141045	//Docking chip
//#define PCIID_TO_TOPIC95                0x06031179	//Seattle2
#define PCIID_TO_TOPIC95		0x060a1179	//SeattleX
#define PCIID_CL_PD6832			0x11101013
#define PCIID_DBK_DB87144		0x310610b3
#define PCIID_RICOH_RL5C466		0x04661180

//ConfigSpace Registers
#define CFGSPACE_VENDOR_ID              0x00
#define CFGSPACE_DEVICE_ID              0x02
#define CFGSPACE_COMMAND                0x04
#define CFGSPACE_STATUS                 0x06
#define CFGSPACE_REV_ID                 0x08
#define CFGSPACE_CLASS_CODE             0x09
#define CFGSPACE_CLASSCODE_PI           0x09
#define CFGSPACE_CLASSCODE_SUBCLASS     0x0a
#define CFGSPACE_CLASSCODE_BASECLASS    0x0b
#define CFGSPACE_CACHE_LINESIZE         0x0c
#define CFGSPACE_LATENCY_TIMER          0x0d
#define CFGSPACE_HEADER_TYPE            0x0e
#define CFGSPACE_BIST                   0x0f
#define CFGSPACE_REGBASE_ADDR           0x10
#define CFGSPACE_SECOND_STATUS          0x16
#define CFGSPACE_PCI_BUSNUM             0x18
#define CFGSPACE_CARDBUS_BUSNUM         0x19
#define CFGSPACE_SUB_BUSNUM             0x1a
#define CFGSPACE_CB_LATENCY_TIMER       0x1b
#define CFGSPACE_MEMBASE_0              0x1c
#define CFGSPACE_MEMLIMIT_0             0x20
#define CFGSPACE_MEMBASE_1              0x24
#define CFGSPACE_MEMLIMIT_1             0x28
#define CFGSPACE_IOBASE_0               0x2c
#define CFGSPACE_IOLIMIT_0              0x30
#define CFGSPACE_IOBASE_1               0x34
#define CFGSPACE_IOLIMIT_1              0x38
#define CFGSPACE_INT_LINE               0x3c
#define CFGSPACE_INT_PIN                0x3d
#define CFGSPACE_BRIDGE_CTRL            0x3e
#define CFGSPACE_SUBSYS_VENDOR_ID       0x40
#define CFGSPACE_SUBSYS_ID              0x42
#define CFGSPACE_LEGACY_MODE_BASE_ADDR	0x44

//Command Register bits
#define CMD_IOSPACE_ENABLE		0x0001
#define CMD_MEMSPACE_ENABLE		0x0002
#define CMD_BUSMASTER_ENABLE		0x0004
#define CMD_SPECIALCYCLE_ENABLE		0x0008
#define CMD_MEMWR_INVALIDATE_ENABLE	0x0010
#define CMD_VGA_PALETTE_SNOOP		0x0020
#define CMD_PARITY_ERROR_ENABLE		0x0040
#define CMD_WAIT_CYCLE_CTRL		0x0080
#define CMD_SYSTEM_ERROR_ENABLE		0x0100
#define CMD_FAST_BACKTOBACK_ENABLE	0x0200

//Bridge Control Register bits
#define BCTRL_PERR_RESPONSE_ENABLE	0x0001
#define BCTRL_SERR_ENABLE		0x0002
#define BCTRL_ISA_ENABLE		0x0004
#define BCTRL_VGA_ENABLE		0x0008
#define BCTRL_MASTER_ABORT_MODE		0x0020
#define BCTRL_CRST			0x0040
#define BCTRL_IRQROUTING_ENABLE		0x0080
#define BCTRL_MEMWIN0_PREFETCH_ENABLE	0x0100
#define BCTRL_MEMWIN1_PREFETCH_ENABLE	0x0200
#define BCTRL_WRITE_POSTING_ENABLE	0x0400
#define BCTRL_CL_CSCIRQROUTING_ENABLE	0x0800

//ConfigSpace Registers (TI PCI1130)
#define CFGSPACE_TI_SYSTEM_CTRL		0x80
#define CFGSPACE_TI_RETRY_STATUS        0x90
#define CFGSPACE_TI_CARD_CTRL           0x91
#define CFGSPACE_TI_DEV_CTRL            0x92
#define CFGSPACE_TI_BUFF_CTRL           0x93

//ConfigSpace Registers (TOPIC95)
#define CFGSPACE_TO_PC16_SKTCTRL	0x90
#define CFGSPACE_TO_SLOT_CTRL		0xa0
#define CFGSPACE_TO_CARD_CTRL		0xa1
#define CFGSPACE_TO_CD_CTRL		0xa3
#define CFGSPACE_TO_CBREG_CTRL		0xa4

//ConfigSpace Registers (OPTi 82C824)
#define CFGSPACE_OPTI_HF_CTRL           0x50
#define HFC_ZV_SUPPORT                  0x80

//ConfigSpace Registers (RICOH RL5C466)
#define CFGSPACE_RICOH_MISC_CTRL        0x82
#define CFGSPACE_RICOH_IF16_CTRL        0x84
#define CFGSPACE_RICOH_IO16_TIMING0     0x88
#define CFGSPACE_RICOH_MEM16_TIMING0    0x8a
#define CFGSPACE_RICOH_DMA_SLAVE_CFG    0x90

//RICOH 16-bit Interface Control Register bits
#define IF16_INDEX_RANGE_SELECT         0x0008
#define IF16_LEGACY_LEVEL_1             0x0010
#define IF16_LEGACY_LEVEL_2             0x0020
#define IF16_IO16_ENHANCE_TIMING        0x0100
#define IF16_MEM16_ENHANCE_TIMING       0x0200

//PC Card-16 Socket Control Register bits (TOPIC95)
#define S16CTRL_CSC_ISAIRQ		0x00000001

//Card Control Register bits (TOPIC95)
#define CARDCTRL_INTPIN_ASSIGNMASK	0x30
#define CARDCTRL_INTPIN_NONE		0x00
#define CARDCTRL_INTPIN_INTA		0x01
#define CARDCTRL_INTPIN_INTB		0x02

//Card Detect Control Register bits (TOPIC95)
#define CDCTRL_SW_DETECT		0x01
#define CDCTRL_VS_MASK			0x06
#define CDCTRL_PCCARD_16_32		0x80

//System Control Register bits (TI PCI1130)
#define SYSCTRL_PCICLKRUN_ENABLE	0x00000001
#define SYSCTRL_KEEPCLK_ENABLE		0x00000002
#define SYSCTRL_ASYNC_INTMODE		0x00000004
#define SYSCTRL_PCPCI_DMA_ENABLE	0x00000008
#define SYSCTRL_CBDATAPARITY_SERR	0x00000010
#define SYSCTRL_EXCAIDREV_READONLY	0x00000020
#define SYSCTRL_INTERROGATING		0x00000100
#define SYSCTRL_POWERING_UP		0x00000200
#define SYSCTRL_POWERING_DOWN		0x00000400
#define SYSCTRL_POWER_STREAMING		0x00000800
#define SYSCTRL_SOCKET_ACTIVITY		0x00001000
#define SYSCTRL_PCPCI_DMA_CHAN_MASK	0x00070000
#define SYSCTRL_PCPCI_DMA_CARD_ENABLE	0x00080000
#define SYSCTRL_REDUCED_ZV_ENABLE	0x00100000
#define SYSCTRL_VCC_PROTECT_OVERRIDE	0x00200000
#define SYSCTRL_SMI_INT_ENABLE		0x01000000
#define SYSCTRL_SMI_INT_ROUTING_SELECT	0x02000000

//Retry Status Register bits (TI PCI1130)
#define RETRY_PCIM_RETRY_EXPIRED	0x01
#define RETRY_PCI_RETRY_EXPIRED		0x02
#define RETRY_CBMA_RETRY_EXPIRED	0x04
#define RETRY_CBA_RETRY_EXPIRED		0x08
#define RETRY_CBMB_RETRY_EXPIRED	0x10
#define RETRY_CBB_RETRY_EXPIRED		0x20
#define RETRY_CBRETRY_TIMEOUT_ENABLE	0x40
#define RETRY_PCIRETRY_TIMEOUT_ENABLE	0x80

//Card Control Register bits (TI PCI1130)
#define CARDCTRL_PCCARD_INTFLAG         0x01
#define CARDCTRL_SPKR_ENABLE            0x02
#define CARDCTRL_CSCINT_ENABLE          0x08
#define CARDCTRL_FUNCINT_ENABLE         0x10
#define CARDCTRL_PCIINT_ENABLE          0x20
#define CARDCTRL_ZV_ENABLE		0x40
#define CARDCTRL_RIOUT_ENABLE           0x80

//Device Control Register bits (TI PCI1130)
#define DEVCTRL_INTMODE_MASK            0x06
#define DEVCTRL_INTMODE_DISABLED        0x00
#define DEVCTRL_INTMODE_ISA             0x02
#define DEVCTRL_INTMODE_COMPAQ          0x04
#define DEVCTRL_INTMODE_SERIAL		0x06
#define DEVCTRL_ALWAYS_ONE              0x10
#define DEVCTRL_3V_ENABLE               0x20
#define DEVCTRL_5V_ENABLE               0x40

//CardBus Registers
#define CBREG_SKTEVENT                  0x00
#define CBREG_SKTMASK                   0x04
#define CBREG_SKTSTATE                  0x08
#define CBREG_SKTFORCE                  0x0c
#define CBREG_SKTPOWER                  0x10

//Socket Event Register bits
#define SKTEVENT_CSTSCHG                0x00000001L
#define SKTEVENT_CCD1                   0x00000002L
#define SKTEVENT_CCD2                   0x00000004L
#define SKTEVENT_CCD_MASK		(SKTEVENT_CCD1 | SKTEVENT_CCD2)
#define SKTEVENT_POWERCYCLE             0x00000008L
#define SKTEVENT_MASK                   0x0000000fL

//Socket Mask Register bits
#define SKTMSK_CSTSCHG                  0x00000001L
#define SKTMSK_CCD                      0x00000006L
#define SKTMSK_CCD1                     0x00000002L
#define SKTMSK_CCD2                     0x00000004L
#define SKTMSK_POWERCYCLE               0x00000008L

//Socket Present State Register bits
#define SKTSTATE_CSTSCHG                0x00000001L
#define SKTSTATE_CCD1                   0x00000002L
#define SKTSTATE_CCD2                   0x00000004L
#define SKTSTATE_CCD_MASK               (SKTSTATE_CCD1 | SKTSTATE_CCD2)
#define SKTSTATE_POWERCYCLE             0x00000008L
#define SKTSTATE_CARDTYPE_MASK		0x00000030L
#define SKTSTATE_R2CARD                 0x00000010L
#define SKTSTATE_CBCARD                 0x00000020L
#define SKTSTATE_OPTI_DOCK		0x00000030L
#define CARDTYPE(dw)			((dw) & SKTSTATE_CARDTYPE_MASK)
#define SKTSTATE_CARDINT                0x00000040L
#define SKTSTATE_NOTACARD               0x00000080L
#define SKTSTATE_DATALOST               0x00000100L
#define SKTSTATE_BADVCCREQ              0x00000200L
#define SKTSTATE_5VCARD                 0x00000400L
#define SKTSTATE_3VCARD                 0x00000800L
#define SKTSTATE_XVCARD                 0x00001000L
#define SKTSTATE_YVCARD                 0x00002000L
#define SKTSTATE_CARDVCC_MASK		(SKTSTATE_5VCARD | SKTSTATE_3VCARD | \
					 SKTSTATE_XVCARD | SKTSTATE_YVCARD)
#define SKTSTATE_5VSOCKET               0x10000000L
#define SKTSTATE_3VSOCKET               0x20000000L
#define SKTSTATE_XVSOCKET               0x40000000L
#define SKTSTATE_YVSOCKET               0x80000000L
#define SKTSTATE_SKTVCC_MASK		(SKTSTATE_5VSOCKET | \
					 SKTSTATE_3VSOCKET | \
					 SKTSTATE_XVSOCKET | \
					 SKTSTATE_YVSOCKET)

//Socket Froce Register bits
#define SKTFORCE_CSTSCHG                0x00000001L
#define SKTFORCE_CCD1                   0x00000002L
#define SKTFORCE_CCD2                   0x00000004L
#define SKTFORCE_POWERCYCLE             0x00000008L
#define SKTFORCE_R2CARD                 0x00000010L
#define SKTFORCE_CBCARD                 0x00000020L
#define SKTFORCE_NOTACARD               0x00000080L
#define SKTFORCE_DATALOST               0x00000100L
#define SKTFORCE_BADVCCREQ              0x00000200L
#define SKTFORCE_5VCARD                 0x00000400L
#define SKTFORCE_3VCARD                 0x00000800L
#define SKTFORCE_XVCARD                 0x00001000L
#define SKTFORCE_YVCARD                 0x00002000L
#define SKTFORCE_CVSTEST                0x00004000L
#define SKTFORCE_5VSOCKET		0x10000000L
#define SKTFORCE_3VSOCKET		0x20000000L
#define SKTFORCE_XVSOCKET		0x40000000L
#define SKTFORCE_YVSOCKET		0x80000000L

//Power Control Register bits
#define SKTPOWER_VPP_CONTROL            0x00000007L
#define SKTPOWER_VPP_OFF                0x00000000L
#define SKTPOWER_VPP_120V               0x00000001L
#define SKTPOWER_VPP_050V               0x00000002L
#define SKTPOWER_VPP_033V               0x00000003L
#define SKTPOWER_VPP_0XXV               0x00000004L
#define SKTPOWER_VPP_0YYV               0x00000005L
#define SKTPOWER_VCC_CONTROL            0x00000070L
#define SKTPOWER_VCC_OFF                0x00000000L
#define SKTPOWER_VCC_050V               0x00000020L
#define SKTPOWER_VCC_033V               0x00000030L
#define SKTPOWER_VCC_0XXV               0x00000040L
#define SKTPOWER_VCC_0YYV               0x00000050L
#define SKTPOWER_STOPCLOCK              0x00000080L

//Misc. CardBus Constants
#define NUMWIN_BRIDGE                   4       //2 Mem + 2 IO
#define EXCAREG_OFFSET                  0x0800


/*** CardBus Type and Structure Definitions
 */

typedef struct cfgspace_s {
    WORD  wVendorID;
    WORD  wDeviceID;
    WORD  wCommand;
    WORD  wStatus;
    BYTE  bRevID;
    BYTE  bClassCodePI;
    BYTE  bClassCodeSubClass;
    BYTE  bClassCodeBaseClass;
    BYTE  bCacheLineSize;
    BYTE  bLatencyTimer;
    BYTE  bHeaderType;
    BYTE  bBIST;
    DWORD dwRegBaseAddr;
    BYTE  bPCIBusNum;
    BYTE  bCBBusNum;
    BYTE  bSubBusNum;
    BYTE  bCBLatencyTimer;
    DWORD dwMemBase0;
    DWORD dwMemLimit0;
    DWORD dwMemBase1;
    DWORD dwMemLimit1;
    DWORD dwIOBase0;
    DWORD dwIOLimit0;
    DWORD dwIOBase1;
    DWORD dwIOLimit1;
    BYTE  bIntLine;
    BYTE  bIntPin;
    BYTE  bBridgeCtrl;
    WORD  wSubSysVendorID;
    WORD  wSubSysID;
} CFGSPACE;
typedef CFGSPACE *PCFGSPACE;

typedef struct cbregs_s {
    DWORD dwSktEvent;
    DWORD dwSktMask;
    DWORD dwSktState;
    DWORD dwSktForce;
    DWORD dwSktPower;
} CBREGS;
typedef CBREGS *PCBREGS;

//#endif  //ifdef CARDBUS


/*** 16-Bit Socket Constants
 */

//Device IDs for various controllers
#define DEVID_VALID_LO			0x82
#define DEVID_CL			0x82
#define DEVID_VADEM			0x83
#define DEVID_RICOH			0x83
#define DEVID_GEN_PCIC			0x84
#define DEVID_IBM_KING			0x8a
#define DEVID_OPTI_82C824		0x87
#define DEVID_OPTI_82C852		0x8f

//ExCA Registers
#define EXCAREG_IDREV                   0x00
#define EXCAREG_VLSI_EA0		0x00
#define EXCAREG_INTERFACE_STATUS        0x01
#define EXCAREG_VLSI_EA1		0x01
#define EXCAREG_POWER_CTRL              0x02
#define EXCAREG_VLSI_EA2		0x02
#define EXCAREG_INT_GENCTRL             0x03
#define EXCAREG_VLSI_EXT_CHIPCTRL	0x03
#define EXCAREG_CARD_STATUS             0x04
#define EXCAREG_CSC_CFG                 0x05
#define EXCAREG_WIN_ENABLE              0x06
#define EXCAREG_IO_CTRL                 0x07
#define EXCAREG_IOWIN0_START            0x08
#define EXCAREG_IOWIN0_END              0x0a
#define EXCAREG_IOWIN1_START            0x0c
#define EXCAREG_IOWIN1_END              0x0e
#define EXCAREG_MEMWIN0_START           0x10
#define EXCAREG_MEMWIN0_END             0x12
#define EXCAREG_MEMWIN0_OFFSET          0x14
#define EXCAREG_CARDDET_GENCTRL		0x16
#define EXCAREG_CL_MISC_CTRL1		0x16
#define EXCAREG_TO_ADDITIONAL_GENCTRL	0x16
#define EXCAREG_CL_FIFO_CTRL		0x17
#define EXCAREG_KING_CVS		0x17
#define EXCAREG_MEMWIN1_START           0x18
#define EXCAREG_MEMWIN1_END             0x1a
#define EXCAREG_MEMWIN1_OFFSET          0x1c
#define EXCAREG_GLOBAL_CTRL		0x1e
#define EXCAREG_CL_MISC_CTRL2		0x1e
#define EXCAREG_CL_CHIP_INFO		0x1f
#define EXCAREG_VADEM_VSENSE		0x1f
#define EXCAREG_MEMWIN2_START           0x20
#define EXCAREG_MEMWIN2_END             0x22
#define EXCAREG_MEMWIN2_OFFSET          0x24
#define EXCAREG_CL_ATA_CTRL		0x26
#define EXCAREG_MEMWIN3_START           0x28
#define EXCAREG_MEMWIN3_END             0x2a
#define EXCAREG_MEMWIN3_OFFSET          0x2c
#define EXCAREG_CL_EXT_INDEX		0x2e
#define EXCAREG_CL_EXT_DATA		0x2f
#define EXCAREG_VADEM_VSEL		0x2f
#define EXCAREG_RICOH_MISC_CTRL1        0x2f
#define EXCAREG_MEMWIN4_START           0x30
#define EXCAREG_MEMWIN4_END             0x32
#define EXCAREG_MEMWIN4_OFFSET          0x34
#define EXCAREG_CL_IOWIN0_OFFSET	0x36
#define EXCAREG_CL_IOWIN1_OFFSET	0x38
#define EXCAREG_CL_SETUP_TIMING0	0x3a
#define EXCAREG_VADEM_MISC		0x3a
#define EXCAREG_CL_COMMAND_TIMING0	0x3b
#define EXCAREG_DBK_ZV_ENABLE		0x3b
#define EXCAREG_TO_MMI_CTRL		0x3c
#define EXCAREG_CL_RECOVERY_TIMING0	0x3c
#define EXCAREG_CL_SETUP_TIMING1	0x3d
#define EXCAREG_CL_COMMAND_TIMING1	0x3e
#define EXCAREG_TO_FUNC_CTRL		0x3e
#define EXCAREG_CL_RECOVERY_TIMING1	0x3f
#define EXCAREG_MEMWIN0_HI              0x40
#define EXCAREG_MEMWIN1_HI              0x41
#define EXCAREG_MEMWIN2_HI              0x42
#define EXCAREG_MEMWIN3_HI              0x43
#define EXCAREG_MEMWIN4_HI              0x44
#define EXCAREG_CL_IOWIN0_HI            0x45
#define EXCAREG_CL_IOWIN1_HI            0x46
#define EXCAREG_CL_EXT_CTRL1            0x103
#define EXCAREG_CL_EXTERNAL_DATA        0x10a
#define EXCAREG_CL_EXT_CTRL2            0x10b
#define EXCAREG_CL_MISC_CTRL3           0x125
#define EXCAREG_CL_MASK_REV		0x134
#define EXCAREG_CL_PRODUCT_ID		0x135
#define EXCAREG_CL_DEV_CAP_A		0x136
#define EXCAREG_CL_DEV_CAP_B		0x137
#define EXCAREG_CL_DEV_IMP_A		0x138
#define EXCAREG_CL_DEV_IMP_B		0x139
#define EXCAREG_CL_DEV_IMP_C		0x13a
#define EXCAREG_CL_DEV_IMP_D		0x13b

//TI PCI-1130 specific registers
#define EXCAREG_TI_MEMWIN_PAGE		0x40

//ID and Revision Register bits
#define IDREV_REV_MASK                  0x0f
#define IDREV_IFID_MASK                 0xc0
#define IDREV_IFID_IO                   0x00
#define IDREV_IFID_MEM                  0x40
#define IDREV_IFID_IOMEM                0x80

//Interface Status Register bits
#define IFS_BVD_MASK                    0x03
#define IFS_BVD1                        0x01
#define IFS_BVD2                        0x02
#define IFS_CD_MASK                     0x0c
#define IFS_CD1                         0x04
#define IFS_CD2                         0x08
#define IFS_WP                          0x10
#define IFS_RDYBSY                      0x20
#define IFS_CARDPWR_ACTIVE              0x40
#define IFS_VPP_VALID                   0x80

//Power and RESETDRV Control Register bits
#define PC_VPP1_MASK                    0x03
#define PC_VPP2_MASK                    0x0c
#define PC_CARDPWR_ENABLE               0x10
#define PC_AUTOPWR_ENABLE               0x20
#define PC_RESETDRV_DISABLE             0x40
#define PC_OUTPUT_ENABLE                0x80

#define PC_VPP_NO_CONNECT		0x00
#define PC_VPP_SETTO_VCC		0x01
#define PC_VPP_SETTO_VPP		0x02
#define PC_VPP_RESERVED			0x03

#define PC_VPP_VLSI_MASK		0x03
#define PC_VPP_VLSI_NO_CONNECT		0x00
#define PC_VPP_VLSI_050V		0x01
#define PC_VPP_VLSI_120V		0x02
#define PC_VPP_VLSI_RESERVED		0x03

#define PC_VCC_TOPIC_033V		0x08

#define PC_VCC_VLSI_MASK		0x18
#define PC_VCC_VLSI_NO_CONNECT		0x00
#define PC_VCC_VLSI_RESERVED		0x08
#define PC_VCC_VLSI_050V		0x10
#define PC_VCC_VLSI_033V		0x18

#define PC_VPP_KING_MASK		0x03
#define PC_VPP_KING_NO_CONNECT		0x00
#define PC_VPP_KING_050V		0x01
#define PC_VPP_KING_120V		0x02
#define PC_VPP_KING_SETTO_VCC		0x03

#define PC_VCC_KING_MASK		0x0c
#define PC_VCC_KING_NO_CONNECT		0x00
#define PC_VCC_KING_050V		0x04
#define PC_VCC_KING_RESERVED		0x08
#define PC_VCC_KING_033V		0x0c

#define PC_VPP_OPTI_MASK		0x03
#define PC_VPP_OPTI_NO_CONNECT		0x00
#define PC_VPP_OPTI_SETTO_VCC		0x01
#define PC_VPP_OPTI_120V		0x02
#define PC_VPP_OPTI_0V			0x03

#define PC_VCC_OPTI_MASK		0x18
#define PC_VCC_OPTI_NO_CONNECT		0x00
#define PC_VCC_OPTI_033V		0x08
#define PC_VCC_OPTI_050V		0x10
#define PC_VCC_OPTI_0XXV		0x18

//Interrupt and General Control Register bits
#define IGC_IRQ_MASK                    0x0f
#define IGC_INTR_ENABLE                 0x10
#define IGC_PCCARD_IO                   0x20
#define IGC_PCCARD_RESETLO              0x40
#define IGC_RINGIND_ENABLE              0x80

//Card Status Change Register bits
#define CSC_CHANGE_MASK                 0x0f
#define CSC_BATT_DEAD                   0x01
#define CSC_BATT_WARNING                0x02
#define CSC_BATT_MASK			(CSC_BATT_DEAD | CSC_BATT_WARNING)
#define CSC_READY_CHANGE                0x04
#define CSC_CD_CHANGE                   0x08

//Card Status Change Interrupt Configuration Register bits
#define CSCFG_ENABLE_MASK               0x0f
#define CSCFG_BATT_DEAD                 0x01
#define CSCFG_BATT_WARNING              0x02
#define CSCFG_BATT_MASK			(CSCFG_BATT_DEAD | CSCFG_BATT_WARNING)
#define CSCFG_READY_ENABLE              0x04
#define CSCFG_CD_ENABLE                 0x08
#define CSCFG_IRQ_MASK                  0xf0

//Address Window Enable Register bits
#define WE_MEM0_ENABLE                  0x01
#define WE_MEM1_ENABLE                  0x02
#define WE_MEM2_ENABLE                  0x04
#define WE_MEM3_ENABLE                  0x08
#define WE_MEM4_ENABLE                  0x10
#define WE_MEMWIN_MASK			(WE_MEM0_ENABLE | WE_MEM1_ENABLE | \
					 WE_MEM2_ENABLE | WE_MEM3_ENABLE | \
					 WE_MEM4_ENABLE)
#define WE_MEMCS16_DECODE               0x20
#define WE_IO0_ENABLE                   0x40
#define WE_IO1_ENABLE                   0x80
#define WE_IOWIN_MASK			(WE_IO0_ENABLE | WE_IO1_ENABLE)

//I/O Control Register bits
#define IOC_IO0_MASK                    0x0f
#define IOC_IO0_DATASIZE                0x01
#define IOC_IO0_IOCS16                  0x02
#define IOC_IO0_ZEROWS                  0x04
#define IOC_IO0_WAITSTATE               0x08
#define IOC_IO1_MASK                    0xf0
#define IOC_IO1_DATASIZE                0x10
#define IOC_IO1_IOCS16                  0x20
#define IOC_IO1_ZEROWS                  0x40
#define IOC_IO1_WAITSTATE               0x80

//Card Detection and General Control Register
#define CDGC_SW_DET_INT			0x20

//Memory Window Start Register bits
#define MEMBASE_ADDR_MASK               0x0fff
#define MEMBASE_ZEROWS                  0x4000
#define MEMBASE_16BIT                   0x8000

//Memory Window Stop Register bits
#define MEMEND_ADDR_MASK                0x0fff
#define MEMEND_WS_MASK                  0xc000

//Memory Window Offset Register bits
#define MEMOFF_ADDR_MASK                0x3fff
#define MEMOFF_REG_ACTIVE               0x4000
#define MEMOFF_WP                       0x8000

//Cirrus Logic Miscellaneous Control 1 Register bits
#define CL_MC1_5V_DETECT		0x01
#define CL_MC1_MM_ENABLE		0x01
#define CL_MC1_VCC_33V			0x02
#define CL_MC1_PULSE_MGMT_INT		0x04
#define CL_MC1_PULSE_SYSTEM_IRQ		0x08
#define CL_MC1_SPKR_ENABLE		0x10
#define CL_MC1_INPACK_ENABLE		0x80

//Cirrus Logic Miscellaneous Control 2 Register bits
#define CL_MC2_BFS			0x01
#define CL_MC2_LPDYNAMIC_MODE		0x02
#define CL_MC2_SUSPEND			0x04
#define CL_MC2_5VCORE			0x08
#define CL_MC2_DRIVELED_ENABLE		0x10
#define CL_MC2_TIMERCLK_DIVIDE		0x10
#define CL_MC2_3STATE_BIT7		0x20
#define CL_MC2_DMA_SYSTEM		0x40
#define CL_MC2_IRQ15_RIOUT		0x80

//Cirrus Logic Miscellaneous Control 3 Register bits
#define CL_MC3_INTMODE_MASK             0x03
#define CL_MC3_INTMODE_SERIAL           0x00
#define CL_MC3_INTMODE_EXTHW            0x01
#define CL_MC3_INTMODE_PCIWAY           0x02
#define CL_MC3_INTMODE_PCI              0x03    //default
#define CL_MC3_PWRMODE_MASK             0x0c
#define CL_MC3_HWSUSPEND_ENABLE         0x10
#define CL_MC3_MM_ARM			0x80

//Cirrus Logic Chip Info Register bits
#define CL_CI_REV_MASK			0x1e
#define CL_CI_DUAL_SOCKET		0x20
#define CL_CI_CHIP_ID			0xc0

//Cirrus Logic Mask Revision Register bits
#define CL_MSKREV_MASK			0x0f

//Cirrus Logic Product ID Register bits
#define CL_PID_PRODUCT_CODE_MASK	0x0f
#define CL_PID_FAMILY_CODE_MASK		0xf0

//Cirrus Logic Device Capability Register A bits
#define CL_CAPA_NUMSKT_MASK		0x03
#define CL_CAPA_IDE_INTERFACE		0x04
#define CL_CAPA_SLAVE_DMA		0x08
#define CL_CAPA_CPSTB_CAPABLE		0x20
#define CL_CAPA_PER_SKT_LED		0x80

//Cirrus Logic Device Capability Register B bits
#define CL_CAPB_CARDBUS_CAPABLE		0x01
#define CL_CAPB_LOCK_SUPPORT		0x02
#define CL_CAPB_CLKRUN_SUPPORT		0x04
#define CL_CAPB_EXT_DEF			0x80

//Cirrus Logic Device Implementation Register A bits
#define CL_IMPA_NUMSKT_MASK		0x03
#define CL_IMPA_SLAVE_DMA		0x04
#define CL_IMPA_VS1_VS2			0x08
#define CL_IMPA_GPSTB_A			0x10
#define CL_IMPA_GPSTB_B			0x20
#define CL_IMPA_HW_SUSPEND		0x40
#define CL_IMPA_RI_OUT			0x80

//Cirrus Logic Device Implementation Register B bits
#define CL_IMPB_033_VCC			0x01
#define CL_IMPB_050_VCC			0x02
#define CL_IMPB_0YY_VCC			0x04
#define CL_IMPB_0XX_VCC			0x08
#define CL_IMPB_120_VPP			0x10
#define CL_IMPB_VPP_VCC_1A		0x20
#define CL_IMPB_RFRATED_SKT		0x40

//Cirrus Logic Device Implementation Register C bits
#define CL_IMPC_LED			0x01
#define CL_IMPC_PER_SKT_LED		0x02
#define CL_IMPC_SPK			0x04
#define CL_IMPC_ZVP_A			0x08
#define CL_IMPC_ZVP_B			0x10

//Cirrus Logic Device Implementation Register D bits
#define CL_IMPD_CLKRUN			0x01
#define CL_IMPD_LOCK			0x02
#define CL_IMPD_EXT_CLK			0x40

//Cirrus Logic Extension Registers
#define CLEXTREG_EXTCTRL_1		0x03
#define CLEXTREG_MEMWIN0_HIADDR		0x05
#define CLEXTREG_MEMWIN1_HIADDR		0x06
#define CLEXTREG_MEMWIN2_HIADDR		0x07
#define CLEXTREG_MEMWIN3_HIADDR		0x08
#define CLEXTREG_MEMWIN4_HIADDR		0x09
#define CLEXTREG_EXT_DATA		0x0a
#define CLEXTREG_EXTCTRL_2		0x0b

//Cirrus Logic External Data Register bits (Index=0x6f,ExtIndex=0x0a)
#define CL_EDATA_A_VS1			0x01
#define CL_EDATA_A_VS2			0x02
#define CL_EDATA_A_5V			(CL_EDATA_A_VS1 | CL_EDATA_A_VS2)
#define CL_EDATA_B_VS1			0x04
#define CL_EDATA_B_VS2			0x08
#define CL_EDATA_B_5V			(CL_EDATA_B_VS1 | CL_EDATA_B_VS2)

//Toshiba TOPIC95 Function Control Register bits
#define TO_FCTRL_CARDPWR_ENABLE		0x01
#define TO_FCTRL_VSSTATUS_ENABLE	0x02
#define TO_FCTRL_PPEC_TIMING_ENABLE	0x04
#define TO_FCTRL_CARD_TIMING_ENABLE	0x08
#define TO_FCTRL_CARD_MEMPAGE_ENABLE	0x10
#define TO_FCTRL_DMA_ENABLE		0x20
#define TO_FCTRL_PWRCTRL_BUFFER_ENABLE	0x40

//Toshiba TOPIC95 Multimedia Interface Control Register bits
#define TO_MMI_VIDEO_CTRL		0x01
#define TO_MMI_AUDIO_CTRL		0x02
#define TO_MMI_REV_BIT			0x80

//Toshiba TOPIC95 Addition General Control Register bits
#define TO_GCTRL_CARDREMOVAL_RESET	0x02
#define TO_GCTRL_SWCD_INT		0x20

//Databook DB87144 Zoom Video Port Enable Register
#define DBK_ZVE_MODE_MASK		0x03
#define DBK_ZVE_STANDARD_MODE		0x00
#define DBK_ZVE_MM_MODE			0x03

//OPTi Global Control Register bits
#define OPTI_ZV_ENABLE                  0x20

//VLSI ELC Constants
#define VLSI_ELC_ALIAS			0x8000
#define VLSI_EA2_EA_ENABLE		0x10
#define VLSI_CC_VS1			0x04

//VADEM Constants
#define VADEM_UNLOCK_SEQ1		0x0e
#define VADEM_UNLOCK_SEQ2		0x37
#define VADEM_MISC_UNLOCK_VADEMREV	0xc0
#define VADEM_IDREV_VG469_REV		0x0c
#define VADEM_VSEL_VCC_MASK		0x03
#define VADEM_VSEL_VCC_050V		0x00
#define VADEM_VSEL_VCC_033V		0x01
#define VADEM_VSEL_VCC_XXXV		0x02
#define VADEM_VSEL_VCC_033VB		0x03
#define VADEM_VSEL_SKT_MIXEDVOLT	0x40
#define VADEM_VSENSE_A_VS1		0x01
#define VADEM_VSENSE_A_VS2		0x02
#define VADEM_VSENSE_B_VS1		0x04
#define VADEM_VSENSE_B_VS2		0x08
#define VADEM_VSENSE_050V_ONLY		0x03

//IBM King Constants
#define KING_CVS_VS1			0x01
#define KING_CVS_VS2			0x02
#define KING_CVS_VS_MASK		(KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_5V			(KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_GPI			0x80

//Ricoh RL5C466 Miscellaneous Control 1 Register bits
#define RICOH_MC1_VS                    0x01
#define RICOH_MC1_IREQ_SENSE_SEL        0x02
#define RICOH_MC1_INPACK_ENABLE         0x04
#define RICOH_MC1_ZV_ENABLE             0x08
#define RICOH_MC1_DMA_ENABLE_MASK       0x30
#define RICOH_MC1_DMA_DISABLE           0x00
#define RICOH_MC1_DMA_INPACK            0x10
#define RICOH_MC1_DMA_IOIS16            0x20
#define RICOH_MC1_DMA_SPKR              0x30

//Misc. Constants
#define EXCAREGBASE_SPACE		0x40
#define NUMWIN_PCCARD16                 7       //5 mem + 2 io per socket
#define NUMWIN_PC16_MEM                 5
#define NUMWIN_PC16_IO                  2
#define PCCARD_IOWIN_START              5

//These are default values for the slowest and fastest memory speeds supported.
//It may be necessary to change the actual values with arguments, if the bus
//speed is not the default 8MHz/8.33MHz, which gives 120ns-125ns per cycle.
//Note that the SLOW_MEM_SPEED should be the same as the default
//WaitToSpeed[3], and FAST_MEM_SPEED might as well be 1ns, since the socket
//will support arbitrarily fast memory.
#define SLOW_MEM_SPEED                  0x72    //700ns
#define FAST_MEM_SPEED                  0x08    //1ns

#define RESET_DELAY                     2000    //2ms
#define PWRON_DELAY                     300000  //300ms

//I/O Control Register default nibble values
//The Xircom net PC cards fails with a 16-bit wait on the AcerNote which
//has a Cirrus Logic controller.  Why the addition of a wait state causes
//this to fail is a mystery.  The Socket EA PC card fails on the IBM ThinkPad
//755 if the 16-bit wait state is not set.
#define DEF_IOC_8BIT                    0x00
#define DEF_IOC_16BIT                   (IOC_IO0_DATASIZE | IOC_IO0_IOCS16 | \
                                         IOC_IO0_WAITSTATE)


/*** ExCA Type and Structure Definitions
 */

typedef struct excaregs_s {
    BYTE  bIDRev;                       //0x00
    BYTE  bInterfaceStatus;             //0x01
    BYTE  bPowerControl;                //0x02
    BYTE  bIntGenControl;               //0x03
    BYTE  bCardStatusChange;            //0x04
    BYTE  bCardStatusIntConfig;         //0x05
    BYTE  bWindowEnable;                //0x06
    BYTE  bIOControl;                   //0x07
    BYTE  bIO0StartLo;                  //0x08
    BYTE  bIO0StartHi;                  //0x09
    BYTE  bIO0StopLo;                   //0x0a
    BYTE  bIO0StopHi;                   //0x0b
    BYTE  bIO1StartLo;                  //0x0c
    BYTE  bIO1StartHi;                  //0x0d
    BYTE  bIO1StopLo;                   //0x0e
    BYTE  bIO1StopHi;                   //0x0f
    BYTE  bMem0StartLo;                 //0x10
    BYTE  bMem0StartHi;                 //0x11
    BYTE  bMem0StopLo;                  //0x12
    BYTE  bMem0StopHi;                  //0x13
    BYTE  bMem0OffsetLo;                //0x14
    BYTE  bMem0OffsetHi;                //0x15
    WORD  wReserved0;                   //0x16
    BYTE  bMem1StartLo;                 //0x18
    BYTE  bMem1StartHi;                 //0x19
    BYTE  bMem1StopLo;                  //0x1a
    BYTE  bMem1StopHi;                  //0x1b
    BYTE  bMem1OffsetLo;                //0x1c
    BYTE  bMem1OffsetHi;                //0x1d
    WORD  wReserved1;                   //0x1e
    BYTE  bMem2StartLo;                 //0x20
    BYTE  bMem2StartHi;                 //0x21
    BYTE  bMem2StopLo;                  //0x22
    BYTE  bMem2StopHi;                  //0x23
    BYTE  bMem2OffsetLo;                //0x24
    BYTE  bMem2OffsetHi;                //0x25
    WORD  wReserved2;                   //0x26
    BYTE  bMem3StartLo;                 //0x28
    BYTE  bMem3StartHi;                 //0x29
    BYTE  bMem3StopLo;                  //0x2a
    BYTE  bMem3StopHi;                  //0x2b
    BYTE  bMem3OffsetLo;                //0x2c
    BYTE  bMem3OffsetHi;                //0x2d
    WORD  wReserved3;                   //0x2e
    BYTE  bMem4StartLo;                 //0x30
    BYTE  bMem4StartHi;                 //0x31
    BYTE  bMem4StopLo;                  //0x32
    BYTE  bMem4StopHi;                  //0x33
    BYTE  bMem4OffsetLo;                //0x34
    BYTE  bMem4OffsetHi;                //0x35
    WORD  wReserved4;                   //0x36
    DWORD dgReserved5;                  //0x38
    DWORD dgReserved6;                  //0x3c
} EXCAREGS;
typedef EXCAREGS *PEXCAREGS;


#endif  //ifndef _PCSKTHW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\physical.cpp ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:
    physical.cpp

Abstract:
    Extensions to read/display physocal memory

Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 5/9/2001

--*/

#include "precomp.h"
#pragma hdrstop

#define PHYS_READ_MATCH_DUMPSIZE       0x100

#define PHYS_FLAG_MESSAGE \
    "If you know the caching attributes used for the memory,\n" \
    "try specifying [c], [uc] or [wc], as in !dd [c] <params>.\n" \
    "WARNING: Incorrect use of these flags will cause unpredictable\n" \
    "processor corruption.  This may immediately (or at any time in\n" \
    "the future until reboot) result in a system hang, incorrect data\n" \
    "being displayed or other strange crashes and corruption.\n"

ULONG64 g_LastAddress = 0;

VOID
ReadPhysicalInChunks(
    ULONG64 Address,
    PUCHAR Buffer,
    ULONG BufferSize,
    ULONG Flags,
    ULONG ChunkSize,
    PULONG ActualRead
    )
{
    if ((Flags & PHYS_READ_MATCH_DUMPSIZE) &&
        (ChunkSize != 0)) {
        DWORD i, ret;
        PUCHAR pReadBuff;

        Flags &= 0xf;

        for (i=0, pReadBuff = Buffer; i<BufferSize;
             i+=ChunkSize, pReadBuff+=ChunkSize) {
            ReadPhysicalWithFlags(Address + i,
                                  pReadBuff,ChunkSize,Flags,&ret);
            if (ret != ChunkSize) {
                break;
            }
            *ActualRead += ret;
        }
    } else {
        Flags &= 0xf;
        ReadPhysicalWithFlags(Address,Buffer,BufferSize,Flags,ActualRead);
    }
    return;
}
/*++

Routine Description:

    Dumps specified range of physical memory in given format

Arguments:

    Address - Address to start

    NumEntries - Number of entries to dump

    EntrySize - Size of each entry

    ShowAsAscii - print corresponding ascii chars

Return Value:

    None.


--*/
BOOL
DumpPhysicalMemory(
    ULONG64 Address,
    ULONG NumEntries,
    ULONG EntrySize,
    BOOL ShowAsAscii,
    ULONG Flags
    )
{
#define NumberBytesToRead 32*4

    UCHAR Buffer[NumberBytesToRead];
    ULONG ActualRead=0;

    if ((EntrySize != 1) && (EntrySize != 2) && (EntrySize != 4) && (EntrySize != 8)) {
        EntrySize=4;
    }
    while (1) {
        if (CheckControlC()) {
            break;
        }
        ReadPhysicalInChunks(Address,Buffer,sizeof(Buffer),Flags, EntrySize,&ActualRead);
        if (ActualRead != sizeof(Buffer) &&
            ActualRead < NumEntries*EntrySize) {
            dprintf("Physical memory read at %I64lx failed\n", Address);
            if (Flags == PHYS_FLAG_DEFAULT && ActualRead == 0) {
                dprintf(PHYS_FLAG_MESSAGE);
            }
            return FALSE;
        } else {
            PCHAR DumpByte = (PCHAR)&Buffer[0], pRow;
            ULONG cnt;
            for(cnt=0;cnt<NumberBytesToRead;DumpByte+=EntrySize) {
                if (!(cnt & 0xf)) {
                    dprintf("#%8I64lx", Address+cnt);
                    pRow = DumpByte;
                }
                switch (EntrySize) {
                case 1:
                    dprintf("%c%02lx", ((cnt&0xf) == 8 ? '-' : ' '),*((PUCHAR)DumpByte));
                    break;
                case 2:
                    dprintf(" %04lx", *((PUSHORT) DumpByte));
                    break;
                case 4:
                    dprintf(" %08lx", *((PULONG) DumpByte));
                    break;
                case 8:
                    dprintf(" %08lx'%08lx", *((PULONG) DumpByte), *((PULONG) (DumpByte+4)));
                    break;
                }

                cnt+=EntrySize, NumEntries--;
                if ((cnt && !(cnt & 0xf)) || !NumEntries) {
                    if (ShowAsAscii) {
                        unsigned char ch;
                        dprintf(" ");
                        for (ULONG d=0; d < 16; d++) {
                            ch = (UCHAR) pRow[d];
                            if (ch < 0x20 || ch > 0x7e) {
                                ch = '.';
                            }
                            dprintf("%c", ch);
                        }
                    }
                    dprintf("\n");

                }
                if (!NumEntries) {
                    break;
                }
            }
            Address += cnt;
            if (!NumEntries) {
                break;
            }
        }
    }
    g_LastAddress = Address;

    return TRUE;
}

/*++

Routine Description:

    Reverse sign extension of the value returned by GetExpression()
    based on the assumption that no physical address may be bigger
    than 0xfffffff00000000.

Arguments:

    Val - points to the value to reverse sign extension

Return Value:

    None.

--*/

void
ReverseSignExtension(ULONG64* Val)
{
    if ((*Val & 0xffffffff00000000) == 0xffffffff00000000)
    {
        *Val &= 0x00000000ffffffff;
    }
}

PCSTR
GetPhyFlags(PCSTR Args, PULONG Flags)
{
    *Flags = PHYS_FLAG_DEFAULT;

    while (*Args && (*Args == ' ' || *Args == '\t')) {
        ++Args;
    }

    if (*Args == '[') {
        Args++;
        if (*Args == 'c') {
            *Flags = PHYS_FLAG_CACHED;
            Args++;
        } else if (*Args == 'u' && *(Args + 1) == 'c') {
            *Flags = PHYS_FLAG_UNCACHED;
            Args += 2;
        } else if (*Args == 'w' && *(Args + 1) == 'c') {
            *Flags = PHYS_FLAG_WRITE_COMBINED;
            Args += 2;
        }
        if (*Args != ']') {
            *Flags = PHYS_FLAG_DEFAULT;
            dprintf("Unknown physical memory caching attribute\n");
        } else {
            Args++;
        }
    }
    if (*Args == '-' || *Args == '\\') {
        ++Args;
        if (tolower(*Args) == 'm') {
            *Flags |= PHYS_READ_MATCH_DUMPSIZE;
        } else {
            dprintf("Bad argument -%s\n", Args);
        }
        ++Args;
    }
    return Args;
}

void
GetPhyDumpArgs(
    PCSTR Args,
    PULONG64 Address,
    PULONG Range,
    PULONG Flags
    )
{
    CHAR Buffer[100]={0};

    *Flags = PHYS_FLAG_DEFAULT;

    if(*Args == '\0') {
        *Address=g_LastAddress;
    } else {
        Args = GetPhyFlags(Args, Flags);
        while (*Args && (*Args == ' ' || *Args == '\t')) {
            ++Args;
        }
        if(*Args == '\0') {
            *Address=g_LastAddress;
        } else {
            GetExpressionEx(Args, Address, &Args);
            ReverseSignExtension(Address);
            *Address &= (~0x3);      // Truncate to dword boundary
            g_LastAddress=*Address;
            while (*Args && (*Args == ' ' || *Args == '\t')) {
                ++Args;
            }
            if (*Args == 'l' || *Args == 'L') {
                ++Args;
                *Range = (ULONG) GetExpression(Args);
            }
        }
    }
    return;
}

DECLARE_API( db )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;
    ULONG Flags;

    GetPhyDumpArgs(args, &Address, &Range, &Flags);
    if (!Range) {
        Range = 128;
    }
    DumpPhysicalMemory(Address, Range, 1, TRUE, Flags);
    return S_OK;
}

DECLARE_API( dd )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;
    ULONG Flags;

    GetPhyDumpArgs(args, &Address, &Range, &Flags);
    if (!Range) {
        Range = 32;
    }
    DumpPhysicalMemory(Address, Range, 4, FALSE, Flags);
    return S_OK;
}

DECLARE_API( dw )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;
    ULONG Flags;

    GetPhyDumpArgs(args, &Address, &Range, &Flags);
    if (!Range) {
        Range = 64;
    }
    DumpPhysicalMemory(Address, Range, 2, FALSE, Flags);
    return S_OK;
}

DECLARE_API( dp )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;
    ULONG Flags;

    GetPhyDumpArgs(args, &Address, &Range, &Flags);
    if (!Range) {
        Range = IsPtr64() ? 16 : 32;
    }
    DumpPhysicalMemory(Address, Range, IsPtr64() ? 8 : 4, FALSE, Flags);
    return S_OK;
}
DECLARE_API( dc )

/*++

Routine Description:

    Does a read of N ULONGS from the physical memory of the target machine,
    dumping both hex and ASCII.

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;
    ULONG Flags;

    GetPhyDumpArgs(args, &Address, &Range, &Flags);
    if (!Range) {
        Range = 32;
    }
    DumpPhysicalMemory(Address, Range, 4, TRUE, Flags);
    return S_OK;
}

DECLARE_API( du )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0, ActualRead;
    WCHAR Buffer[MAX_PATH]={0};
    ULONG Flags;

    GetPhyDumpArgs(args, &Address, &Range, &Flags);
    if (Range>MAX_PATH) {
        Range = MAX_PATH;
    }
    if (!Range) {
        Range = 16;
    }
    ReadPhysicalWithFlags(Address,Buffer,Range * sizeof(WCHAR),Flags,&ActualRead);
    if (ActualRead != Range*sizeof(WCHAR)) {
        dprintf("Physical memory read at %I64lx failed\n", Address);
        if (Flags == PHYS_FLAG_DEFAULT && ActualRead == 0) {
            dprintf(PHYS_FLAG_MESSAGE);
        }
        return FALSE;
    } else {
        ULONG cnt;

        dprintf("#%8I64lx \"", Address);
        for (ULONG d=0; d < Range; d++) {
            WCHAR ch = Buffer[d];
            if (ch == 0) {
                break;
            }
            if (ch < 0x20 || ch > 0x7e) {
                ch = '.';
            }
            dprintf("%wc", ch);
        }
        dprintf("\"\n");
    }
    return S_OK;
}


DECLARE_API( ed )

/*++

Routine Description:

    Writes a sequence of ULONGs into a given physical address on the
    target machine.

Arguments:

    arg - Supplies both the target address and the data in the form of
          "PHYSICAL_ADDRESS ULONG [ULONG, ULONG,...]"

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG Buffer;
    ULONG ActualWritten=0;
    PCHAR NextToken;
    ULONG Flags;

    args = GetPhyFlags(args, &Flags);

    Address = GetExpression(args);

    strtok((PSTR)args," \t,");      // The first token is the address

    // Since we're picking off one ULONG at a time, we'll make
    // one DbgKdWritePhysicalMemoryAddress call per ULONG.  This
    // is slow, but easy to code.
    while((NextToken=strtok(NULL," \t,")) != NULL) {
        if (!sscanf(NextToken,"%lx",&Buffer)) {
            break;
        }
        WritePhysicalWithFlags(Address,&Buffer,sizeof(Buffer),Flags,
                               &ActualWritten);
        if (ActualWritten != sizeof(Buffer)) {
            dprintf("Physical memory write at %I64lx failed\n", Address);
            if (Flags == PHYS_FLAG_DEFAULT && ActualWritten == 0) {
                dprintf(PHYS_FLAG_MESSAGE);
            }
        }
        Address+=sizeof(Buffer);
    }
    return S_OK;
}


DECLARE_API( eb )

/*++

Routine Description:

    Writes a sequence of BYTEs into a given physical address on the
    target machine.

Arguments:

    arg - Supplies both the target address and the data in the form of
          "PHYSICAL_ADDRESS ULONG [ULONG, ULONG,...]"

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG Buffer;
    UCHAR c;
    ULONG ActualWritten;
    PCHAR NextToken;
    ULONG Flags;

    UNREFERENCED_PARAMETER (Client);

    args = GetPhyFlags(args, &Flags);

    Address = GetExpression(args);

    strtok((PSTR)args," \t,");      // The first token is the address

    // Since we're picking off one BYTE at a time, we'll make
    // one DbgKdWritePhysicalMemoryAddress call per BYTE.  This
    // is slow, but easy to code.
    while((NextToken=strtok(NULL," \t,")) != NULL) {
        if (!sscanf(NextToken,"%lx",&Buffer)) {
            break;
        }
        c = (UCHAR)Buffer;
        WritePhysicalWithFlags(Address,&c,sizeof(UCHAR),Flags,&ActualWritten);
        if (ActualWritten != sizeof(UCHAR)) {
            dprintf("Physical memory write at %I64lx failed\n", Address);
            if (Flags == PHYS_FLAG_DEFAULT && ActualWritten == 0) {
                dprintf(PHYS_FLAG_MESSAGE);
            }
        }
        Address+=sizeof(UCHAR);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\pooltag.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    pooltag.cpp

Abstract:


Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 3/5/2001

--*/

#include "precomp.h"
#include <copystr.h>


ULONG
MatchPoolTag(
    PSTR Tag,
    PSTR TagToMatch
    )
{
    BOOL Partial = FALSE;
    ULONG CharMatched = 0;
    for (ULONG i = 0; i<4; i++)
    {
        switch (Tag[i])
        {
        case '*':
            // Match the reminder
            return CharMatched;
        case '?':
            Partial = TRUE;
            break;
        default:
            // Cannot match a non widcard character after '?'
            if (!Partial && (Tag[i] == TagToMatch[i]))
            {
                CharMatched=i+1;
            } else
            {
                return FALSE;
            }
        }
    }
    return CharMatched;
}

BOOL
FindOwnerAndComponent(
    PSTR pszDesc,
    PDEBUG_POOLTAG_DESCRIPTION pDetails
    )
{
    PSTR pSrch, szTmp, pCurr, pLast;

    //
    // POOLTAG - filename.bin - description text - owner
    //           ^
    //            pszDesc starts from here
    //
    if (pszDesc) {
        pLast = pszDesc + strlen(pszDesc);
        pSrch = strchr(pszDesc, '-');

        if (pSrch)
        {
            CHAR PossibleBinName[50]={0};

            StringCchCatN(PossibleBinName, sizeof(PossibleBinName), pszDesc,
                          (ULONG) ((ULONG_PTR)pSrch - (ULONG_PTR)pszDesc));
            pCurr = PossibleBinName + strlen(PossibleBinName);

            // eat up trailing spaces
            while ((*pCurr == '\0' || *pCurr == ' ' || *pCurr == '\t')  && (pCurr > PossibleBinName) )
            {
                *pCurr = '\0';
                --pCurr;
            }

            if (strcmp(PossibleBinName, "<unknown>"))
            {
                StringCchCopy(pDetails->Binary, sizeof(PossibleBinName), PossibleBinName);
            }
            ++pSrch;
            while (*pSrch == ' ' || *pSrch == '\t') ++pSrch;

            pszDesc = pSrch;
        }

        pSrch = strrchr(pszDesc, '-');
        if (pSrch) {
            pCurr = pSrch;
            pSrch++;


            while (*pSrch == ' ' || *pSrch == '\t') ++pSrch;

            if (!strncmp(pSrch, "OWNER", 5)) {

                pSrch += strlen("OWNER");
                while (*pSrch == ' ' || *pSrch == '\t') ++pSrch;
                szTmp = pSrch;
                if (strlen(szTmp) < sizeof(pDetails->Owner)) {
                    strcpy(pDetails->Owner, szTmp);
                }

                pSrch = strchr(pszDesc, '-');
                pLast = pCurr;
            }
        }

        if (((ULONG) (pLast - pszDesc)+1) < sizeof(pDetails->Description)) {
            pDetails->Description[0] = 0;
            StringCchCatN(pDetails->Description, sizeof(pDetails->Description), pszDesc, (ULONG) (pLast - pszDesc));
            while (*pLast == '\n' || *pLast == '\r' || *pLast == '\0')
            {
                *pLast = 0;
                --pLast;
            }
            pDetails->Description[(ULONG) (pLast - pszDesc)+1] = 0;
        }
    } else {
        return FALSE;
    }
    return TRUE;
}

PSTR
GetNextLine(
    HANDLE hFile,
    BOOL bRestart
    )
// Returns next line in the file hFile
// Returns NULL if EOF is reached
{
    static CHAR FileLines1[MAX_PATH] = {0}, FileLines2[MAX_PATH] = {0};
    static CHAR FileLine[MAX_PATH];
    PCHAR pEOL;
    ULONG BytesRead;
    PCHAR pEndOfBuff;
    ULONG BuffLen, ReadLen;

    pEOL = NULL;
    if (bRestart)
    {
        FileLines1[0] = 0;
    }
    if (!(pEOL = strchr(FileLines1, '\n'))) {
        // We have something that was already read but it isn't enough for a whole line
        // We need to read the data

        BuffLen = strlen(FileLines1);

        // sanity check
        if (BuffLen >= sizeof(FileLines1)) {
            return NULL;
        }

        pEndOfBuff = &FileLines1[0] + BuffLen;
        ReadLen = sizeof(FileLines1) - BuffLen;

        ZeroMemory(pEndOfBuff, ReadLen);
        if (ReadFile(hFile, pEndOfBuff, ReadLen - 1, &BytesRead, NULL)) {
            pEOL = strchr(FileLines1, '\n');
        }
    }

    if (pEOL) {
        FileLine[0] = 0;

        strncat(FileLine,FileLines1, (ULONG) (pEOL - &FileLines1[0]));
        strcpy(FileLines2, pEOL+1);
        strcpy(FileLines1, FileLines2);
        pEOL = strchr(FileLine, '\n');
        if (pEOL) *pEOL = 0;
        return FileLine;
    }

    return NULL;
}


BOOL
GetPoolTagDescriptionFromTxtFile(
    IN ULONG PoolTag,
    PDEBUG_POOLTAG_DESCRIPTION pDetails
    )
//
// Get pool tag description from pooltag.txt file, if present, in current dir
//
{
    const LPSTR PoolTagTxtFile = "triage\\pooltag.txt";
    static CHAR TagDesc[MAX_PATH];
    CHAR *pPoolTagTxtFile, ExeDir[MAX_PATH+50];  // make it big enough to append PoolTagTxtFile
    PSTR pCurrLine, pDescription, pOwner;
    CHAR PoolTagStr[5], PossiblePoolTag[5];
    ULONG i=0;
    ULONG Match, PrevMatch;
    BOOL bRestart = TRUE;
    HANDLE hFile;


    // Get the directory the debugger executable is in.
    if (!GetModuleFileName(NULL, ExeDir, MAX_PATH)) {
        // Error.  Use the current directory.
        strcpy(ExeDir, ".");
    } else {
        // Remove the executable name.
        PCHAR pszTmp = strrchr(ExeDir, '\\');
        if (pszTmp)
        {
            *pszTmp = 0;
        }
    }
    strcat(ExeDir, "\\");
    strcat(ExeDir, PoolTagTxtFile);
    pPoolTagTxtFile = &ExeDir[0];
    hFile = CreateFile(pPoolTagTxtFile, GENERIC_READ, FILE_SHARE_READ,
                       NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN,
                       NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    *((PULONG) PoolTagStr) = PoolTag;
    PoolTagStr[4] = 0;

    PrevMatch = 0;
    while (pCurrLine = GetNextLine(hFile, bRestart)) {
        bRestart = FALSE;
        ++i;
        while (*pCurrLine == ' ' || *pCurrLine == '\t') {
            ++pCurrLine;
        }

        if (*pCurrLine == '%' || !_strnicmp(pCurrLine, "rem", 3)) {
            // a commented line
            continue;
        }

        strncpy(PossiblePoolTag, pCurrLine, 4);
        PossiblePoolTag[4] = 0;

        pCurrLine +=4;
        while (*pCurrLine == ' ' || *pCurrLine == '\t') {
            ++pCurrLine;
        }
        if (*pCurrLine == '-' && (Match = MatchPoolTag(PossiblePoolTag, PoolTagStr))) {
            // Its a match
            ++pCurrLine;
            while (*pCurrLine == ' ' || *pCurrLine == '\t') {
                ++pCurrLine;
            }
            if (Match > PrevMatch && (Match > 1)) // Match at least 2 chars
            {
                PrevMatch = Match;
                FindOwnerAndComponent(pCurrLine, pDetails);
            }
            if (Match == 4)
            {
                // Found exact match
                break;
            }
        }
    }

    CloseHandle(hFile);

    return TRUE;

}

BOOL
GetPoolTagDescription(
    IN ULONG PoolTag,
    OUT PDEBUG_POOLTAG_DESCRIPTION pDescription
    )
{
    ULONG lo;

    return GetPoolTagDescriptionFromTxtFile(PoolTag, pDescription);
}

EXTENSION_API ( GetPoolTagDescription ) (
     IN ULONG PoolTag,
     OUT PDEBUG_POOLTAG_DESCRIPTION pDescription
     )
{
    if (!pDescription || (pDescription->SizeOfStruct != sizeof(DEBUG_POOLTAG_DESCRIPTION))) {
        return E_INVALIDARG;
    }
    if (GetPoolTagDescription(PoolTag, pDescription)) {
        return S_OK;
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\pcip.h ===
#ifndef _PCIP_
#define _PCIP_

typedef enum {
    BaseClassDescription,
    SubClassDescription,
    ProgIfDescription
} PCI_CLASSCODEDESC;


typedef struct _PCI_BRIDBG_CTRL_REG {
    USHORT PERRREnable:1;
    USHORT SERREnable:1;
    USHORT ISAEnable:1;
    USHORT VGAEnable:1;

    USHORT Reserved:1;
    USHORT MasterAbort:1;
    USHORT CBRst:1;
    USHORT IRQRoutingEnable:1;

    USHORT Mem0Prefetch:1;
    USHORT Mem1Prefetch:1;
    USHORT WritePostEnable:1;

    USHORT Reserved1:5;
} PCI_BRIDBG_CTRL_REG;

//
// Cardbus has extra configuration information beyond the common
// header. (stolen from the PCI driver)
//
typedef struct _PCI_TYPE2_HEADER_EXTRAS {
    USHORT  SubVendorID;
    USHORT  SubSystemID;
    ULONG   LegacyModeBaseAddress;
} PCI_TYPE2_HEADER_EXTRAS, *PPCI_TYPE2_HEADER_EXTRAS;

#define CONFIG_OFFSET(x)    \
        FIELD_OFFSET(PCI_COMMON_CONFIG, x)

#define TYPE0_OFFSET(x)     \
        CONFIG_OFFSET(u.type0.x)
        
#define TYPE1_OFFSET(x)     \
        CONFIG_OFFSET(u.type1.x)
        
#define TYPE2_OFFSET(x)     \
        CONFIG_OFFSET(u.type2.x)
        
VOID
PrintPciHtCommandReg(
    IN PPCI_HT_CAPABILITY PciHtCap
    );

VOID
DumpCfgSpace (
    IN PPCI_TYPE1_CFG_BITS PciCfg1
    );

PCHAR 
GetClassDesc(
    IN UCHAR BaseClass, 
    IN UCHAR SubClass, 
    IN UCHAR ProgIf,
    IN PCI_CLASSCODEDESC ClassDesc
    );

PCHAR
GetVendorDesc(
    IN USHORT VendorID,
    IN BOOL FullVenDesc
    );

BOOL
ReadPci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    OUT PUCHAR                  Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

BOOLEAN
WritePci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

static struct _PCI_CLASSCODETABLE{
	UCHAR BaseClass;
	UCHAR SubClass;
	UCHAR ProgIf;
	PCHAR BaseDesc;
	PCHAR SubDesc;
	PCHAR ProgDesc;   
} PciClassCodeTable[] = {

	{ 0x00, 0x00, 0x00, "Pre-2.0 PCI Specification Device", "Non-VGA",NULL } ,
	{ 0x00, 0x01, 0x00, "Pre-2.0 PCI Specification Device", "VGA Compatible", NULL } ,

	{ 0x01, 0x00, 0x00, "Mass Storage Controller", "SCSI Controller", NULL } ,
	{ 0x01, 0x01, 0x00, "Mass Storage Controller", "IDE Controller", NULL } ,
	{ 0x01, 0x02, 0x00, "Mass Storage Controller", "Floppy Disk Controller", NULL } ,
	{ 0x01, 0x03, 0x00, "Mass Storage Controller", "IPI Controller", NULL } ,
	{ 0x01, 0x04, 0x00, "Mass Storage Controller", "RAID Controller", NULL } ,
	{ 0x01, 0x80, 0x00, "Mass Storage Controller", "Other Storage Controller", NULL } ,

	{ 0x02, 0x00, 0x00, "Network Controller", "Ethernet Controller", NULL } ,
	{ 0x02, 0x01, 0x00, "Network Controller", "Token Ring Controller", NULL } ,
	{ 0x02, 0x02, 0x00, "Network Controller", "FDDI Controller", NULL } ,
	{ 0x02, 0x03, 0x00, "Network Controller", "ATM Controller", NULL } ,
	{ 0x02, 0x04, 0x00, "Network Controller", "ISDN Controller", NULL } ,
	{ 0x02, 0x80, 0x00, "Network Controller", "Other Network Controller", NULL } ,

	{ 0x03, 0x00, 0x00, "Display Controller", "VGA Compatible Controller", "VGA" } ,
	{ 0x03, 0x00, 0x01, "Display Controller", "VGA Compatible Controller", "8514" } ,
	{ 0x03, 0x01, 0x00, "Display Controller", "XGA Controller", NULL } ,
	{ 0x03, 0x02, 0x00, "Display Controller", "3D Controller", NULL } ,
	{ 0x03, 0x80, 0x00, "Display Controller", "Other Display Controller", NULL } ,

	{ 0x04, 0x00, 0x00, "Multimedia Device", "Video Device", NULL } ,
	{ 0x04, 0x01, 0x00, "Multimedia Device", "Audio Device", NULL } ,
	{ 0x04, 0x02, 0x00, "Multimedia Device", "Telephony Device", NULL } ,
	{ 0x04, 0x80, 0x00, "Multimedia Device", "Other Device", NULL } ,

	{ 0x05, 0x00, 0x00, "Memory Controller", "RAM Controller", NULL } ,
	{ 0x05, 0x01, 0x00, "Memory Controller", "Flash Controller", NULL } ,
	{ 0x05, 0x80, 0x00, "Memory Controller", "Other Memory Controller", NULL } ,

	{ 0x06, 0x00, 0x00, "Bridge Device", "Host Bridge", NULL } ,
	{ 0x06, 0x01, 0x00, "Bridge Device", "ISA Bridge", NULL } ,
	{ 0x06, 0x02, 0x00, "Bridge Device", "EISA Bridge", NULL } ,
	{ 0x06, 0x03, 0x00, "Bridge Device", "MCA Bridge", NULL } ,
	{ 0x06, 0x04, 0x00, "Bridge Device", "PCI-PCI Bridge", NULL } ,
	{ 0x06, 0x04, 0x01, "Bridge Device", "PCI-PCI Bridge", "Subtractive" } ,
	{ 0x06, 0x05, 0x00, "Bridge Device", "PCMCIA Bridge", NULL } ,
	{ 0x06, 0x06, 0x00, "Bridge Device", "NuBus Bridge", NULL } ,
	{ 0x06, 0x07, 0x00, "Bridge Device", "CardBus Bridge", NULL } ,
	{ 0x06, 0x08, 0x00, "Bridge Device", "RACEway Bridge", "Transparent" } ,
	{ 0x06, 0x08, 0x01, "Bridge Device", "RACEway Bridge", "End-Point" } ,
	{ 0x06, 0x80, 0x00, "Bridge Device", "Other Bridge", NULL } ,

	{ 0x07, 0x00, 0x00, "Simple Communications Controller", "Serial Controller", "Generic XT Compatible" } ,
	{ 0x07, 0x00, 0x01, "Simple Communications Controller", "Serial Controller", "16450 Compatible" } ,
	{ 0x07, 0x00, 0x02, "Simple Communications Controller", "Serial Controller", "16550 Compatible" } ,
	{ 0x07, 0x00, 0x03, "Simple Communications Controller", "Serial Controller", "16650 Compatible" } ,
	{ 0x07, 0x00, 0x04, "Simple Communications Controller", "Serial Controller", "16750 Compatible" } ,
	{ 0x07, 0x00, 0x05, "Simple Communications Controller", "Serial Controller", "16850 Compatible" } ,
	{ 0x07, 0x00, 0x06, "Simple Communications Controller", "Serial Controller", "16950 Compatible" } ,
	{ 0x07, 0x01, 0x00, "Simple Communications Controller", "Parallel Port", "Standard" } ,
	{ 0x07, 0x01, 0x01, "Simple Communications Controller", "Parallel Port", "Bidirectional" } ,
	{ 0x07, 0x01, 0x02, "Simple Communications Controller", "Parallel Port", "ECP 1.X Compliant" } ,
	{ 0x07, 0x01, 0x03, "Simple Communications Controller", "Parallel Port", "IEEE 1284 controller" } ,
	{ 0x07, 0x01, 0xFE, "Simple Communications Controller", "Parallel Port", "IEEE 1284 target" } ,
	{ 0x07, 0x02, 0x00, "Simple Communications Controller", "Multiport Serial Controller", NULL } ,
	{ 0x07, 0x03, 0x00, "Simple Communications Controller", "Generic Modem", NULL } ,
	{ 0x07, 0x03, 0x01, "Simple Communications Controller", "Hayes-Compatible Modem", "16450" } ,
	{ 0x07, 0x03, 0x02, "Simple Communications Controller", "Hayes-Compatible Modem", "16550" } ,
	{ 0x07, 0x03, 0x03, "Simple Communications Controller", "Hayes-Compatible Modem", "16650" } ,
	{ 0x07, 0x03, 0x04, "Simple Communications Controller", "Hayes-Compatible Modem", "16750" } ,
	{ 0x07, 0x80, 0x00, "Simple Communications Controller", "Other Communications Controller", NULL } ,

	{ 0x08, 0x00, 0x00, "Base Systems Peripheral", "Interrupt Controller", "Generic 8259" } ,
	{ 0x08, 0x00, 0x01, "Base Systems Peripheral", "Interrupt Controller", "ISA" } ,
	{ 0x08, 0x00, 0x02, "Base Systems Peripheral", "Interrupt Controller", "EISA" } ,
	{ 0x08, 0x00, 0x10, "Base Systems Peripheral", "Interrupt Controller", "IO APIC" } ,
	{ 0x08, 0x00, 0x20, "Base Systems Peripheral", "Interrupt Controller", "IO(x) APIC" } ,
	{ 0x08, 0x01, 0x00, "Base Systems Peripheral", "DMA Controller", "Generic 8237" } ,
	{ 0x08, 0x01, 0x01, "Base Systems Peripheral", "DMA Controller", "ISA" } ,
	{ 0x08, 0x01, 0x02, "Base Systems Peripheral", "DMA Controller", "EISA" } ,
	{ 0x08, 0x02, 0x00, "Base Systems Peripheral", "System Timer", "Generic 8254" } ,
	{ 0x08, 0x02, 0x01, "Base Systems Peripheral", "System Timer", "ISA" } ,
	{ 0x08, 0x02, 0x02, "Base Systems Peripheral", "System Timer", "EISA" } ,
	{ 0x08, 0x03, 0x00, "Base Systems Peripheral", "RTC (Real Time Clock)", "Generic" } ,
	{ 0x08, 0x03, 0x01, "Base Systems Peripheral", "RTC (Real Time Clock)", "ISA" } ,
	{ 0x08, 0x04, 0x00, "Base Systems Peripheral", "PCI Hot-Plug Controller", "Generic" } ,
	{ 0x08, 0x80, 0x00, "Base Systems Peripheral", "Other System Peripheral", NULL } ,

	{ 0x09, 0x00, 0x00, "Input Device", "Keyboard Controller", NULL } ,
	{ 0x09, 0x01, 0x00, "Input Device", "Digitizer (Pen)", NULL } ,
	{ 0x09, 0x02, 0x00, "Input Device", "Mouse Controller", NULL } ,
	{ 0x09, 0x03, 0x00, "Input Device", "Scanner Controller", NULL } ,
	{ 0x09, 0x04, 0x00, "Input Device", "Game Port Controller", "Generic" } ,
	{ 0x09, 0x04, 0x10, "Input Device", "Game Port Controller", "Legacy" } ,
	{ 0x09, 0x80, 0x00, "Input Device", "Other Input Controller", NULL } ,

	{ 0x0A, 0x00, 0x00, "Docking Station", "Generic", NULL } ,
	{ 0x0A, 0x80, 0x00, "Docking Station", "Other", NULL } ,

	{ 0x0B, 0x00, 0x00, "Processor", "386", NULL } ,
	{ 0x0B, 0x01, 0x00, "Processor", "486", NULL } ,
	{ 0x0B, 0x02, 0x00, "Processor", "Pentium", NULL } ,
	{ 0x0B, 0x10, 0x00, "Processor", "Alpha", NULL } ,
	{ 0x0B, 0x20, 0x00, "Processor", "Power PC", NULL } ,
	{ 0x0B, 0x30, 0x00, "Processor", "MIPS", NULL } ,
	{ 0x0B, 0x40, 0x00, "Processor", "Co-processor", NULL } ,

	{ 0x0C, 0x00, 0x00, "Serial Bus Controller", "IEEE 1394 Controller", "Firewire" } ,
	{ 0x0C, 0x00, 0x10, "Serial Bus Controller", "IEEE 1394 Controller", "OpenHCI" } ,
	{ 0x0C, 0x01, 0x00, "Serial Bus Controller", "ACCESS.bus", NULL } ,
	{ 0x0C, 0x02, 0x00, "Serial Bus Controller", "SSA (Serial Storage Archetecture)", NULL } ,
	{ 0x0C, 0x03, 0x00, "Serial Bus Controller", "USB Controller", "Universal Host Controller" } ,
	{ 0x0C, 0x03, 0x10, "Serial Bus Controller", "USB Controller", "Open Host Controller" } ,
    { 0x0C, 0x03, 0x20, "Serial Bus Controller", "USB2 Controller", "USB2 Enhanced Interface" } ,
	{ 0x0C, 0x03, 0x80, "Serial Bus Controller", "USB Controller", "Non-specific Controller" } ,
	{ 0x0C, 0x03, 0xFE, "Serial Bus Controller", "USB Controller", "Device" } ,
	{ 0x0C, 0x04, 0x00, "Serial Bus Controller", "Fibre Channel", NULL } ,
	{ 0x0C, 0x05, 0x00, "Serial Bus Controller", "SMBus Controller", NULL } ,

	{ 0x0D, 0x00, 0x00, "Wireless", "iRDA-compatible Controller", NULL } ,
	{ 0x0D, 0x01, 0x00, "Wireless", "Consumer IR Controller", NULL } ,
	{ 0x0D, 0x10, 0x00, "Wireless", "RF Controller", NULL } ,
	{ 0x0D, 0x80, 0x00, "Wireless", "Other Wireless Controller", NULL } ,

	{ 0x0E, 0x00, 0x00, "Intelligent IO Controller", "I2O Controller", NULL } ,

	{ 0x0F, 0x01, 0x00, "Satellite Communications Controller", "TV Sat Controller", NULL } ,
	{ 0x0F, 0x02, 0x00, "Satellite Communications Controller", "Audio Sat Controller", NULL } ,
	{ 0x0F, 0x03, 0x00, "Satellite Communications Controller", "Voice Sat Controller", NULL } ,
	{ 0x0F, 0x04, 0x00, "Satellite Communications Controller", "Data Sat Controller", NULL } ,

	{ 0x10, 0x00, 0x00, "Encryption Controller", "Network/Computing Encryption Controller", NULL } ,
	{ 0x10, 0x10, 0x00, "Encryption Controller", "Entertainment Encryption Controller", NULL } ,
	{ 0x10, 0x80, 0x00, "Encryption Controller", "Other Encryption Controller", NULL } ,

	{ 0x11, 0x00, 0x00, "Signal Processing", "DPIO  Controller", NULL } ,
	{ 0x11, 0x80, 0x00, "Signal Processing", "Other Signal Processing Controller", NULL } ,

	{ 0xFF, 0xFF, 0xFF, "Unknown", "Unknown", "Unknown" } ,
    { 0x00, 0x00, 0x00, NULL, NULL, NULL}
};

static struct _PCI_VENTABLE{
    USHORT VenId;
    PCHAR VenShort;
    PCHAR VenFull;
} PciVenTable[] = {
    { 0x0000, "Gammagraphx", "Gammagraphx, Inc." } ,
    { 0x001A, "Ascend", "Ascend Communications, Inc." } ,
    { 0x0033, NULL, "Paradyne Corp." } ,
    { 0x003D, "Lockheed Martin", "Lockheed Martin Corp" } ,
    { 0x0070, "Hauppauge", "Hauppauge Computer Works Inc." } ,
    { 0x0100, NULL, "Ncipher Corp. Ltd" } ,
    { 0x0123, NULL, "General Dynamics" } ,
    { 0x0160, "USR", "us robotics" } ,
    { 0x0675, "Dynalink", "Dynalink" } ,
    { 0x0871, "Berkom", "Berkom" } ,
    { 0x0A89, "BREA", "BREA Technologies Inc." } ,
    { 0x0E11, "Compaq", "Compaq Computer Corp." } ,
    { 0x1000, "LSI", "LSI Logic" } ,
    { 0x1001, "KOLTER", "Kolter Electronic - Germany" } ,
    { 0x1002, "ATI", "ATI Technologies" } ,
    { 0x1003, "ULSI", "ULSI" } ,
    { 0x1004, "VLSI", "VLSI Technology" } ,
    { 0x1005, "Avance", "Avance Logic Inc." } ,
    { 0x1006, "Reply", "Reply Group" } ,
    { 0x1007, "NetFrame", "Netframe Systems" } ,
    { 0x1008, "Epson", "Epson" } ,
    { 0x100A, "Phoenix", "Phoenix Technologies Ltd." } ,
    { 0x100B, "NSC", "National Semiconductor" } ,
    { 0x100C, "Tseng", "Tseng Labs" } ,
    { 0x100D, "AST", "AST Research" } ,
    { 0x100E, "Weitek", "Weitek" } ,
    { 0x1010, "VLogic", "Video Logic Ltd." } ,
    { 0x1011, "DEC", "Digital Equipment Corporation" } ,
    { 0x1012, "Micronics", "Micronics Computers Inc." } ,
    { 0x1013, "Cirrus", "Cirrus Logic" } ,
    { 0x1014, "IBM", "International Business Machines Corp." } ,
    { 0x1015, "LSIL", "LSI Logic Corp of Canada" } ,
    { 0x1016, "Fujitsu ICL", "Fujitsu ICL Computers" } ,
    { 0x1017, "Spea", "Spea Software AG" } ,
    { 0x1018, "Unisys", "Unisys Systems" } ,
    { 0x1019, "ECS", "Elitegroup Computer Sys" } ,
    { 0x101A, "NCR", "NCR/AT&T GIS" } ,
    { 0x101B, "Vitesse", "Vitesse Semiconductor" } ,
    { 0x101C, "WD", "Western Digital" } ,
    { 0x101E, "AMI", "American Megatrends Inc." } ,
    { 0x101F, "PictureTel", "PictureTel Corp." } ,
    { 0x1020, "Hitachi", "Hitachi Computer Electronics" } ,
    { 0x1021, "OKI", "Oki Electric Industry" } ,
    { 0x1022, "AMD", "Advanced Micro Devices" } ,
    { 0x1023, "Trident", "Trident Microsystems" } ,
    { 0x1024, "Zenith", "Zenith Data Systems" } ,
    { 0x1025, "Acer", "Acer Incorporated" } ,
    { 0x1028, "Dell", "Dell Computer Corporation" } ,
    { 0x1029, "Siem-Nix", "Siemens Nixdorf AG" } ,
    { 0x102A, "LSI", "LSI Logic Headland Div" } ,
    { 0x102B, "Matrox", "Matrox" } ,
    { 0x102C, "C&T", "Chips And Technologies" } ,
    { 0x102D, "Wyse", "Wyse Technologies" } ,
    { 0x102E, "Olivetti", "Olivetti Advanced Technology" } ,
    { 0x102F, "Toshiba", "Toshiba America" } ,
    { 0x1030, "TMC", "TMC Research" } ,
    { 0x1031, "miro", "miro Computer Products AG" } ,
    { 0x1032, "Compaq", "Compaq" } ,
    { 0x1033, "NEC", "NEC Corporation" } ,
    { 0x1034, "Burndy", "Burndy Corporation" } ,
    { 0x1035, "C&CRL", "Computer&Communication Research Lab" } ,
    { 0x1036, "FDomain", "Future Domain" } ,
    { 0x1037, "Hitachi", "Hitachi Micro Systems Inc" } ,
    { 0x1038, "AMP", "AMP Incorporated" } ,
    { 0x1039, "SiS", "Silicon Integrated System" } ,
    { 0x103A, "Seiko", "Seiko Epson Corporation" } ,
    { 0x103B, "Tatung", "Tatung Corp. Of America" } ,
    { 0x103C, "HP", "Hewlett-Packard Company" } ,
    { 0x103E, "Solliday", "Solliday Engineering" } ,
    { 0x103F, "Logic Mod.", "Logic Modeling" } ,
    { 0x1040, "Kubota", "Kubota Pacific Computer Inc." } ,
    { 0x1041, "Computrend", "Computrend" } ,
    { 0x1042, "PC Tech.", "PC Technology" } ,
    { 0x1043, "Asustek", "Asustek Computer Inc." } ,
    { 0x1044, "DPT", "Distributed Processing Tech" } ,
    { 0x1045, "OPTi", "OPTi Inc." } ,
    { 0x1046, "IPC", "IPC Corporation LTD" } ,
    { 0x1047, "Genoa", "Genoa Systems Corp." } ,
    { 0x1048, "ELSA", "ELSA AG" } ,
    { 0x1049, "Fountain", "Fountain Technology" } ,
    { 0x104A, "STM", "STMicroelectronics" } ,
    { 0x104B, "Mylex", "Mylex Corporation" } ,
    { 0x104C, "TI", "Texas Instruments" } ,
    { 0x104D, "Sony", "Sony Corporation" } ,
    { 0x104E, "Oak", "Oak Technology" } ,
    { 0x104F, "Co-Time", "Co-Time Computer Ltd." } ,
    { 0x1050, "Winbond", "Winbond Electronics Corp." } ,
    { 0x1051, "Anigma", "Anigma Corp." } ,
    { 0x1052, "Young", "Young Micro Systems" } ,
    { 0x1054, "Hitachi", "Hitachi LTD" } ,
    { 0x1055, "SMSC", "Standard Microsystems Corp." } ,
    { 0x1056, "ICL", "ICL" } ,
    { 0x1057, "Motorola", "Motorola" } ,
    { 0x1058, "E&TR", "Electronics & Telecommunication Res" } ,
    { 0x1059, "Teknor", "Teknor Microsystems" } ,
    { 0x105A, "Promise", "Promise Technology" } ,
    { 0x105B, "Foxconn", "Foxconn International" } ,
    { 0x105C, "Wipro", "Wipro Infotech Limited" } ,
    { 0x105D, "Number-Nine", "Number Nine Visual Technology" } ,
    { 0x105E, "Vtech", "Vtech Engineering Canada Ltd." } ,
    { 0x105F, "Infotronic", "Infotronic America Inc." } ,
    { 0x1060, "UMC", "United Microelectronics" } ,
    { 0x1061, "8x8", "8x8 Inc." } ,
    { 0x1062, "Maspar", "Maspar Computer Corp." } ,
    { 0x1063, "OOA", "Ocean Office Automation" } ,
    { 0x1064, "Alcatel", "Alcatel Cit" } ,
    { 0x1065, "TM", "Texas Microsystems" } ,
    { 0x1066, "Picopower", "Picopower Technology" } ,
    { 0x1067, "Mitsubishi", "Mitsubishi Electronics" } ,
    { 0x1068, "Div. Tech.", "Diversified Technology" } ,
    { 0x1069, "Mylex", "IBM Corporation" } ,
    { 0x106A, "Aten", "Aten Research Inc." } ,
    { 0x106B, "Apple", "Apple Computer Inc." } ,
    { 0x106C, "Hyundai", "Hyundai Electronics America" } ,
    { 0x106D, "Sequent", "Sequent" } ,
    { 0x106E, "DFI", "DFI Inc." } ,
    { 0x106F, "CityGate", "City Gate Development LTD" } ,
    { 0x1070, "Daewoo", "Daewoo Telecom Ltd." } ,
    { 0x1071, "Mitac", "Mitac" } ,
    { 0x1072, "GIT", "GIT Co. Ltd." } ,
    { 0x1073, "Yamaha", "Yamaha Corporation" } ,
    { 0x1074, "Nexgen", "Nexgen Microsysteme" } ,
    { 0x1075, "AIR", "Advanced Integration Research" } ,
    { 0x1076, "Chaintech", "Chaintech Computer Co. Ltd." } ,
    { 0x1077, "Q Logic", "Q Logic" } ,
    { 0x1078, "Cyrix", "Cyrix Corporation" } ,
    { 0x1079, "I-Bus", "I-Bus" } ,
    { 0x107A, "Networth", "Networth" } ,
    { 0x107B, "Gateway", "Gateway 2000" } ,
    { 0x107C, "Goldstar", "Goldstar Co. Ltd." } ,
    { 0x107D, "Leadtek", "Leadtek Research" } ,
    { 0x107E, "Interphase", "Interphase Corporation" } ,
    { 0x107F, "DTC", "Data Technology Corporation" } ,
    { 0x1080, "Contaq", "Contaq Microsystems" } ,
    { 0x1081, "Supermac", "Supermac Technology Inc." } ,
    { 0x1082, "EFA", "EFA Corporation Of America" } ,
    { 0x1083, "Forex", "Forex Computer Corporation" } ,
    { 0x1084, "Parador", "Parador" } ,
    { 0x1085, "Tulip", "Tulip Computers Int'l BV" } ,
    { 0x1086, "J. Bond", "J. Bond Computer Systems" } ,
    { 0x1087, "Cache", "Cache Computer" } ,
    { 0x1088, "MS Son", "Microcomputer Systems (M) Son" } ,
    { 0x1089, "DG", "Data General Corporation" } ,
    { 0x108A, "Bit3", "Bit3 Computer" } ,
    { 0x108C, "Elonex", "Elonex PLC c/o Oakleigh Systems Inc." } ,
    { 0x108D, "Olicom", "Olicom" } ,
    { 0x108E, "Sun", "Sun Microsystems" } ,
    { 0x108F, "Systemsoft", "Systemsoft Corporation" } ,
    { 0x1090, "Encore", "Encore Computer Corporation" } ,
    { 0x1091, "Intergraph", "Intergraph Corporation" } ,
    { 0x1092, "Diamond", "Diamond Computer Systems" } ,
    { 0x1093, "Nat. Inst.", "National Instruments" } ,
    { 0x1094, "FIC", "First Int'l Computers" } ,
    { 0x1095, "CMD", "CMD Technology Inc." } ,
    { 0x1096, "Alacron", "Alacron" } ,
    { 0x1097, "Appian", "Appian Graphics" } ,
    { 0x1098, "Quantum", "Quantum Designs Ltd." } ,
    { 0x1099, "Samsung", "Samsung Electronics Co. Ltd." } ,
    { 0x109A, "Packard-Bell", "Packard Bell" } ,
    { 0x109B, "Gemlight", "Gemlight Computer Ltd." } ,
    { 0x109C, "Megachips", "Megachips Corporation" } ,
    { 0x109D, "Zida", "Zida Technologies Ltd." } ,
    { 0x109E, "Brooktree", "Brooktree Corporation" } ,
    { 0x109F, "Trigem", "Trigem Computer Inc." } ,
    { 0x10A0, "Meidensha", "Meidensha Corporation" } ,
    { 0x10A1, "Juko", "Juko Electronics Inc. Ltd." } ,
    { 0x10A2, "Quantum", "Quantum Corporation" } ,
    { 0x10A3, "Everex", "Everex Systems Inc." } ,
    { 0x10A4, "Globe", "Globe Manufacturing Sales" } ,
    { 0x10A5, "Racal", "Racal Interlan" } ,
    { 0x10A6, "Informtech", "Informtech Industrial Ltd." } ,
    { 0x10A7, "Benchmarq", "Benchmarq Microelectronics" } ,
    { 0x10A8, "Sierra", "Sierra Semiconductor" } ,
    { 0x10A9, "SG", "Silicon Graphics" } ,
    { 0x10AA, "ACC", "ACC Microelectronics" } ,
    { 0x10AB, "Digicom", "Digicom" } ,
    { 0x10AC, "Honeywell", "Honeywell IASD" } ,
    { 0x10AD, "Symphony", "Symphony Labs" } ,
    { 0x10AE, "Cornerstone", "Cornerstone Technology" } ,
    { 0x10AF, "MCS", "Micro Computer Systems Inc." } ,
    { 0x10B0, "Cardexpert", "Cardexpert Technology" } ,
    { 0x10B1, "Cabletron", "Cabletron Systems Inc." } ,
    { 0x10B2, "Raytheon", "Raytheon Company" } ,
    { 0x10B3, "Databook", "Databook Inc." } ,
    { 0x10B4, "STB", "STB Systems" } ,
    { 0x10B5, "PLX", "PLX Technology" } ,
    { 0x10B6, "Madge", "Madge Networks" } ,
    { 0x10B7, "3Com", "3Com Corporation" } ,
    { 0x10B8, "SMC", "Standard Microsystems Corporation" } ,
    { 0x10B9, "ALi", "Acer Labs Inc." } ,
    { 0x10BA, "Mitsubishi", "Mitsubishi Electronics Corp." } ,
    { 0x10BB, "Dapha", "Dapha Electronics Corporation" } ,
    { 0x10BC, "ALR", "Advanced Logic Research Inc." } ,
    { 0x10BD, "Surecom", "Surecom Technology" } ,
    { 0x10BE, "Tseng", "Tsenglabs International Corp." } ,
    { 0x10BF, "MOST", "MOST Corp." } ,
    { 0x10C0, "Boca", "Boca Research Inc." } ,
    { 0x10C1, "ICM", "ICM Corp. Ltd." } ,
    { 0x10C2, "Auspex", "Auspex Systems Inc." } ,
    { 0x10C3, "Samsung", "Samsung Semiconductors" } ,
    { 0x10C4, "Award", "Award Software Int'l Inc." } ,
    { 0x10C5, "Xerox", "Xerox Corporation" } ,
    { 0x10C6, "Rambus", "Rambus Inc." } ,
    { 0x10C7, "Media Vision", "Media Vision" } ,
    { 0x10C8, "Neomagic", "Neomagic Corporation" } ,
    { 0x10C9, "Dataexpert", "Dataexpert Corporation" } ,
    { 0x10CA, "Fujitsu", "Fujitsu" } ,
    { 0x10CB, "Omron", "Omron Corporation" } ,
    { 0x10CC, "Mentor", "Mentor Arc Inc." } ,
    { 0x10CD, "AdvanSys", "Advanced System Products" } ,
    { 0x10CE, "Radius", "Radius Inc." } ,
    { 0x10CF, "Fujitsu", "Fujitsu Ltd." } ,
    { 0x10D0, "Fujitsu", "Fujitsu Limited" } ,
    { 0x10D1, "Future+", "Future+ Systems" } ,
    { 0x10D2, "Molex", "Molex Incorporated" } ,
    { 0x10D3, "Jabil", "Jabil Circuit Inc." } ,
    { 0x10D4, "Hualon", "Hualon Microelectronics" } ,
    { 0x10D5, "Autologic", "Autologic Inc." } ,
    { 0x10D6, "Cetia", "Cetia" } ,
    { 0x10D7, "BCM", "BCM Advanced Research" } ,
    { 0x10D8, "APL", "Advanced Peripherals Labs" } ,
    { 0x10D9, "Macronix", "Macronix International Co. Ltd." } ,
    { 0x10DA, "T-C", "Thomas-Conrad Corporation" } ,
    { 0x10DB, "Rohm", "Rohm Research" } ,
    { 0x10DC, "CERN", "CERN-European Lab. for Particle Physics" } ,
    { 0x10DD, "E&S", "Evans & Sutherland" } ,
    { 0x10DE, "Nvidia", "Nvidia Corporation" } ,
    { 0x10DF, "Emulex", "Emulex Corporation" } ,
    { 0x10E0, "IMS", "Integrated Micro Solutions" } ,
    { 0x10E1, "Tekram", "Tekram Technology Corp. Ltd." } ,
    { 0x10E2, "Aptix", "Aptix Corporation" } ,
    { 0x10E3, "Tundra", "Tundra Semiconductor Corp." } ,
    { 0x10E4, "Tandem", "Tandem Computers" } ,
    { 0x10E5, "MIC", "Micro Industries Corporation" } ,
    { 0x10E6, "Gainbery", "Gainbery Computer Products Inc." } ,
    { 0x10E7, "Vadem", "Vadem" } ,
    { 0x10E8, "AMCC", "Applied Micro Circuits Corp." } ,
    { 0x10E9, "Alps", "Alps Electronic Corp. Ltd." } ,
    { 0x10EA, "IGS", "InterGraphics Systems" } ,
    { 0x10EB, "Artist", "Artist Graphics" } ,
    { 0x10EC, "Realtek", "Realtek Semiconductor" } ,
    { 0x10ED, "Ascii", "Ascii Corporation" } ,
    { 0x10EE, "Xilinx", "Xilinx Corporation" } ,
    { 0x10EF, "Racore", "Racore Computer Products" } ,
    { 0x10F0, "Peritek", "Peritek Corporation" } ,
    { 0x10F1, "Tyan", "Tyan Computer" } ,
    { 0x10F2, "Achme", "Achme Computer Inc." } ,
    { 0x10F3, "Alaris", "Alaris Inc." } ,
    { 0x10F4, "S-Mos", "S-Mos Systems" } ,
    { 0x10F5, "NKK", "NKK Corporation" } ,
    { 0x10F6, "Creative", "Creative Electronic Systems SA" } ,
    { 0x10F7, "Matsushita", "Matsushita Electric Industrial Corp." } ,
    { 0x10F8, "Altos", "Altos India Ltd." } ,
    { 0x10F9, "PC-Direct", "PC Direct" } ,
    { 0x10FA, "Truevision", "Truevision" } ,
    { 0x10FB, "Thesys", "Thesys Microelectronic's" } ,
    { 0x10FC, "I-O", "I-O Data Device Inc." } ,
    { 0x10FD, "Soyo", "Soyo Technology Corp. Ltd." } ,
    { 0x10FE, "Fast", "Fast Electronic GmbH" } ,
    { 0x10FF, "Ncube", "Ncube" } ,
    { 0x1100, "Jazz", "Jazz Multimedia" } ,
    { 0x1101, "Initio", "Initio Corporation" } ,
    { 0x1102, "Creative Labs", "Creative Labs" } ,
    { 0x1103, "HighPoint", "HighPoint Technologies Inc." } ,
    { 0x1104, "Rasterops", "Rasterops" } ,
    { 0x1105, "Sigma", "Sigma Designs Inc." } ,
    { 0x1106, "VIA", "VIA Technologies Inc" } ,
    { 0x1107, "Stratus", "Stratus Computer" } ,
    { 0x1108, "Proteon", "Proteon Inc." } ,
    { 0x1109, "Cogent", "Cogent Data Technologies" } ,
    { 0x110A, "Infineon", "Infineon Technologies" } ,
    { 0x110B, "Chromatic", "Chromatic Research Inc" } ,
    { 0x110C, "Mini-Max", "Mini-Max Technology Inc." } ,
    { 0x110D, "ZNYX", "ZNYX Corporation" } ,
    { 0x110E, "CPU Tech.", "CPU Technology" } ,
    { 0x110F, "Ross", "Ross Technology" } ,
    { 0x1110, "Powerhouse", "Powerhouse Systems" } ,
    { 0x1111, "SCO", "Santa Cruz Operation" } ,
    { 0x1112, "Osicom", "Osicom Technologies Inc." } ,
    { 0x1113, "Accton", "Accton Technology Corporation" } ,
    { 0x1114, "Atmel", "Atmel Corp." } ,
    { 0x1115, "Dupont", "Dupont Pixel Systems Ltd." } ,
    { 0x1116, "Data Trans.", "Data Translation" } ,
    { 0x1117, "Datacube", "Datacube Inc." } ,
    { 0x1118, "Berg", "Berg Electronics" } ,
    { 0x1119, "Vortex", "ICP vortex Computersysteme GmbH" } ,
    { 0x111A, "Eff. Net.", "Efficent Networks" } ,
    { 0x111B, "Teledyne", "Teledyne Electronic Systems" } ,
    { 0x111C, "Tricord", "Tricord Systems Inc." } ,
    { 0x111D, "IDT", "Integrated Device Technology Inc." } ,
    { 0x111E, "Eldec", "Eldec Corp." } ,
    { 0x111F, "PDI", "Precision Digital Images" } ,
    { 0x1120, "EMC", "EMC Corp." } ,
    { 0x1121, "Zilog", "Zilog" } ,
    { 0x1122, "Multi-Tech", "Multi-Tech Systems Inc." } ,
    { 0x1123, "EDI", "Excellent Design Inc." } ,
    { 0x1124, "Leutron", "Leutron Vision AG" } ,
    { 0x1125, "Eurocore", "Eurocore/Vigra" } ,
    { 0x1126, "Vigra", "Vigra" } ,
    { 0x1127, "FORE", "FORE Systems" } ,
    { 0x1129, "Firmworks", "Firmworks" } ,
    { 0x112A, "Hermes", "Hermes Electronics Co. Ltd." } ,
    { 0x112B, "Linotype", "Linotype - Hell AG" } ,
    { 0x112C, "Zenith", "Zenith Data Systems" } ,
    { 0x112D, "Ravicad", "Ravicad" } ,
    { 0x112E, "Infomedia", "Infomedia" } ,
    { 0x112F, "ImagTech", "Imaging Technology" } ,
    { 0x1130, "Computervision", "Computervision" } ,
    { 0x1131, "Philips", "Philips Semiconductors" } ,
    { 0x1132, "Mitel", "Mitel Corp." } ,
    { 0x1133, "EIC", "Eicon Technology Corporation" } ,
    { 0x1134, "MCS", "Mercury Computer Systems Inc." } ,
    { 0x1135, "Fuji", "Fuji Xerox Co Ltd" } ,
    { 0x1136, "Momentum", "Momentum Data Systems" } ,
    { 0x1137, "Cisco", "Cisco Systems Inc" } ,
    { 0x1138, "Ziatech", "Ziatech Corporation" } ,
    { 0x1139, "Dyn. Pict.", "Dynamic Pictures Inc" } ,
    { 0x113A, "FWB", "FWB  Inc" } ,
    { 0x113B, "NCD", "Network Computing Devices" } ,
    { 0x113C, "Cyclone", "Cyclone Microsystems Inc." } ,
    { 0x113D, "Leading Edge", "Leading Edge Products Inc" } ,
    { 0x113E, "Sanyo", "Sanyo Electric Co" } ,
    { 0x113F, "Equinox", "Equinox Systems" } ,
    { 0x1140, "Intervoice", "Intervoice Inc" } ,
    { 0x1141, "Crest", "Crest Microsystem Inc" } ,
    { 0x1142, "Alliance", "Alliance Semiconductor CA - USA" } ,
    { 0x1143, "Netpower", "Netpower Inc" } ,
    { 0x1144, "Cinn. Mil.", "Cincinnati Milacron" } ,
    { 0x1145, "Workbit", "Workbit Corp" } ,
    { 0x1146, "Force", "Force Computers" } ,
    { 0x1147, "Interface", "Interface Corp" } ,
    { 0x1148, "S&K", "Schneider & Koch" } ,
    { 0x1149, "Win System", "Win System Corporation" } ,
    { 0x114A, "VMIC", "VMIC" } ,
    { 0x114B, "Canopus", "Canopus Co. Ltd" } ,
    { 0x114C, "Annabooks", "Annabooks" } ,
    { 0x114D, "IC Corp.", "IC Corporation" } ,
    { 0x114E, "Nikon", "Nikon Systems Inc" } ,
    { 0x114F, "Digi", "Digi International" } ,
    { 0x1150, "TMC", "Thinking Machines Corporation" } ,
    { 0x1151, "JAE", "JAE Electronics Inc." } ,
    { 0x1152, "Megatek", "Megatek" } ,
    { 0x1153, "Land Win", "Land Win Electronic Corp" } ,
    { 0x1154, "Melco", "Melco Inc" } ,
    { 0x1155, "Pine", "Pine Technology Ltd" } ,
    { 0x1156, "Periscope", "Periscope Engineering" } ,
    { 0x1157, "Avsys", "Avsys Corporation" } ,
    { 0x1158, "Voarx", "Voarx R&D Inc" } ,
    { 0x1159, "Mutech", "Mutech" } ,
    { 0x115A, "Harlequin", "Harlequin Ltd" } ,
    { 0x115B, "Parallax", "Parallax Graphics" } ,
    { 0x115C, "Photron", "Photron Ltd." } ,
    { 0x115D, "Xircom", "Xircom" } ,
    { 0x115E, "Peer", "Peer Protocols Inc" } ,
    { 0x115F, "Maxtor", "Maxtor Corporation" } ,
    { 0x1160, "Megasoft", "Megasoft Inc" } ,
    { 0x1161, "PFU", "PFU Ltd" } ,
    { 0x1162, "OA Lab", "OA Laboratory Co Ltd" } ,
    { 0x1163, "Rendition", "Rendition Inc" } ,
    { 0x1164, "APT", "Advanced Peripherals Tech" } ,
    { 0x1165, "Imagraph", "Imagraph Corporation" } ,
    { 0x1166, "RCC/ServerWorks", "Reliance Computer Corp./ServerWorks" } ,
    { 0x1167, "Mutoh", "Mutoh Industries Inc" } ,
    { 0x1168, "Thine", "Thine Electronics Inc" } ,
    { 0x1169, "CDAC", "Centre f/Dev. of Adv. Computing" } ,
    { 0x116A, "Polaris", "Polaris Communications" } ,
    { 0x116B, "Connectware", "Connectware Inc" } ,
    { 0x116C, "Int Res.", "Intelligent Resources" } ,
    { 0x116E, "EFI", "Electronics for Imaging" } ,
    { 0x116F, "WkSta. Tech.", "Workstation Technology" } ,
    { 0x1170, "Inventec", "Inventec Corporation" } ,
    { 0x1171, "Lough. Sound", "Loughborough Sound Images" } ,
    { 0x1172, "Altera", "Altera Corporation" } ,
    { 0x1173, "Adobe", "Adobe Systems" } ,
    { 0x1174, "Bridgeport", "Bridgeport Machines" } ,
    { 0x1175, "Mitron", "Mitron Computer Inc." } ,
    { 0x1176, "SBE", "SBE" } ,
    { 0x1177, "Silicon Eng.", "Silicon Engineering" } ,
    { 0x1178, "Alfa", "Alfa Inc" } ,
    { 0x1179, "Toshiba", "Toshiba America Info Systems" } ,
    { 0x117A, "A-Trend", "A-Trend Technology" } ,
    { 0x117B, "LG Elec.", "LG Electronics Inc." } ,
    { 0x117C, "Atto", "Atto Technology" } ,
    { 0x117D, "B&D", "Becton & Dickinson" } ,
    { 0x117E, "T/R", "T/R Systems" } ,
    { 0x117F, "ICS", "Integrated Circuit Systems" } ,
    { 0x1180, "CAC", "Communication Automation Corporation" } ,
    { 0x1181, "Telmatics", "Telmatics International" } ,
    { 0x1183, "Fujikura", "Fujikura Ltd" } ,
    { 0x1184, "Forks", "Forks Inc" } ,
    { 0x1185, "Dataworld", "Dataworld" } ,
    { 0x1186, "D-Link", "D-Link System Inc" } ,
    { 0x1187, "ATL", "Advanced Technology Laboratories" } ,
    { 0x1188, "Shima", "Shima Seiki Manufacturing Ltd." } ,
    { 0x1189, "Matsushita", "Matsushita Electronics" } ,
    { 0x118A, "Hilevel", "Hilevel Technology" } ,
    { 0x118B, "Hypertec", "Hypertec Pty Ltd" } ,
    { 0x118C, "Corollary", "Corollary Inc" } ,
    { 0x118D, "BitFlow", "BitFlow Inc" } ,
    { 0x118E, "Hermstedt", "Hermstedt GmbH" } ,
    { 0x118F, "Green", "Green Logic" } ,
    { 0x1190, "Tripace", "Tripace" } ,
    { 0x1191, "ACARD", "ACARD Technology" } ,
    { 0x1192, "Densan", "Densan Co. Ltd" } ,
    { 0x1193, "Zeitnet", "Zeitnet Inc." } ,
    { 0x1194, "Toucan", "Toucan Technology" } ,
    { 0x1195, "Ratoc", "Ratoc System Inc" } ,
    { 0x1196, "Hytec", "Hytec Electronics Ltd" } ,
    { 0x1197, "Gage", "Gage Applied Sciences Inc." } ,
    { 0x1198, "Lambda", "Lambda Systems Inc" } ,
    { 0x1199, "Attachmate", "Attachmate Corp." } ,
    { 0x119A, "Mind Share", "Mind Share Inc." } ,
    { 0x119B, "Omega", "Omega Micro Inc." } ,
    { 0x119C, "ITI", "Information Technology Inst." } ,
    { 0x119D, "Bug", "Bug Sapporo Japan" } ,
    { 0x119E, "Fujitsu", "Fujitsu Microelectronics Ltd." } ,
    { 0x119F, "Bull", "Bull Hn Information Systems" } ,
    { 0x11A0, "Convex", "Convex Computer Corporation" } ,
    { 0x11A1, "Hamamatsu", "Hamamatsu Photonics K.K." } ,
    { 0x11A2, "Sierra", "Sierra Research and Technology" } ,
    { 0x11A3, "Deuretzbacher", "Deuretzbacher GmbH & Co. Eng. KG" } ,
    { 0x11A4, "Barco", "Barco" } ,
    { 0x11A5, "MicroUnity", "MicroUnity Systems Engineering Inc." } ,
    { 0x11A6, "Pure Data", "Pure Data" } ,
    { 0x11A7, "Power Comp.", "Power Computing Corp." } ,
    { 0x11A8, "Systech", "Systech Corp." } ,
    { 0x11A9, "InnoSys", "InnoSys Inc." } ,
    { 0x11AA, "Actel", "Actel" } ,
    { 0x11AB, "Galileo", "Galileo Technology Ltd." } ,
    { 0x11AC, "Canon", "Canon Information Systems" } ,
    { 0x11AD, "Lite-On", "Lite-On Communications Inc" } ,
    { 0x11AE, "Scitex", "Scitex Corporation Ltd" } ,
    { 0x11AF, "Avid", "Avid Technology Inc." } ,
    { 0x11B0, "V3", "V3 Semiconductor Inc." } ,
    { 0x11B1, "Apricot", "Apricot Computers" } ,
    { 0x11B2, "Kodak", "Eastman Kodak" } ,
    { 0x11B3, "Barr", "Barr Systems Inc." } ,
    { 0x11B4, "Leitch", "Leitch Technology International" } ,
    { 0x11B5, "Radstone", "Radstone Technology Plc" } ,
    { 0x11B6, "United Video", "United Video Corp" } ,
    { 0x11B7, "Motorola", "Motorola" } ,
    { 0x11B8, "Xpoint", "Xpoint Technologies Inc" } ,
    { 0x11B9, "Pathlight", "Pathlight Technology Inc." } ,
    { 0x11BA, "Videotron", "Videotron Corp" } ,
    { 0x11BB, "Pyramid", "Pyramid Technology" } ,
    { 0x11BC, "Net. Periph.", "Network Peripherals Inc" } ,
    { 0x11BD, "Pinnacle", "Pinnacle Systems Inc." } ,
    { 0x11BE, "IMI", "International Microcircuits Inc" } ,
    { 0x11BF, "Astrodesign", "Astrodesign Inc." } ,
    { 0x11C0, "HP", "Hewlett-Packard" } ,
    { 0x11C1, "Agere", "Agere Systems" } ,
    { 0x11C2, "Sand", "Sand Microelectronics" } ,
    { 0x11C3, "NEC", "NEC Corporation" } ,
    { 0x11C4, "Doc. Tech.", "Document Technologies Ind." } ,
    { 0x11C5, "Shiva", "Shiva Corporatin" } ,
    { 0x11C6, "Dainippon", "Dainippon Screen Mfg. Co" } ,
    { 0x11C7, "D.C.M.", "D.C.M. Data Systems" } ,
    { 0x11C8, "Dolphin", "Dolphin Interconnect Solutions" } ,
    { 0x11C9, "MAGMA", "MAGMA" } ,
    { 0x11CA, "LSI Sys.", "LSI Systems Inc" } ,
    { 0x11CB, "Specialix", "Specialix International Ltd." } ,
    { 0x11CC, "M&K", "Michels & Kleberhoff Computer GmbH" } ,
    { 0x11CD, "HAL", "HAL Computer Systems Inc." } ,
    { 0x11CE, "PRI", "Primary Rate Inc" } ,
    { 0x11CF, "PEC", "Pioneer Electronic Corporation" } ,
    { 0x11D0, "Loral", "Loral Frederal Systems - Manassas" } ,
    { 0x11D1, "AuraVision", "AuraVision Corporation" } ,
    { 0x11D2, "Intercom", "Intercom Inc." } ,
    { 0x11D3, "Trancell", "Trancell Systems Inc" } ,
    { 0x11D4, "AD", "Analog Devices" } ,
    { 0x11D5, "Ikon", "Ikon Corp" } ,
    { 0x11D6, "Tekelec", "Tekelec Technologies" } ,
    { 0x11D7, "Trenton", "Trenton Terminals Inc" } ,
    { 0x11D8, "ITD", "Image Technologies Development" } ,
    { 0x11D9, "Tec", "Tec Corporation" } ,
    { 0x11DA, "Novell", "Novell" } ,
    { 0x11DB, "Sega", "Sega Enterprises Ltd" } ,
    { 0x11DC, "Questra", "Questra Corp" } ,
    { 0x11DD, "Crosfield", "Crosfield Electronics Ltd" } ,
    { 0x11DE, "Zoran", "Zoran Corporation" } ,
    { 0x11DF, "New Wave", "New Wave Pdg" } ,
    { 0x11E0, "Cray", "Cray Communications A/S" } ,
    { 0x11E1, "Gec Plessey", "Gec Plessey Semi Inc" } ,
    { 0x11E2, "Samsung", "Samsung Information Systems America" } ,
    { 0x11E3, "Quicklogic", "Quicklogic Corp" } ,
    { 0x11E4, "Second Wave", "Second Wave Inc" } ,
    { 0x11E5, "IIX", "IIX Consulting" } ,
    { 0x11E6, "Mitsui", "Mitsui-Zosen System Research" } ,
    { 0x11E7, "Toshiba", "Toshiba America Elec. Co" } ,
    { 0x11E8, "DPSI", "Digital Processing Systems Inc" } ,
    { 0x11E9, "Highwater", "Highwater Designs Ltd" } ,
    { 0x11EA, "Elsag", "Elsag Bailey" } ,
    { 0x11EB, "Formation", "Formation Inc" } ,
    { 0x11EC, "Coreco", "Coreco Inc" } ,
    { 0x11ED, "Mediamatics", "Mediamatics" } ,
    { 0x11EE, "Dome", "Dome Imaging Systems Inc" } ,
    { 0x11EF, "Nicolet", "Nicolet Technologies BV" } ,
    { 0x11F0, "Compu-Shack", "Compu-Shack GmbH" } ,
    { 0x11F1, "Symbios", "Symbios Logic Inc" } ,
    { 0x11F2, "Pic-Tel", "Picture Tel Japan KK" } ,
    { 0x11F3, "Keithley", "Keithley Metrabyte" } ,
    { 0x11F4, "Kinetic", "Kinetic Systems Corporation" } ,
    { 0x11F5, "Comp Dev", "Computing Devices Intl" } ,
    { 0x11F6, "Powermatic", "Powermatic Data Systems Ltd" } ,
    { 0x11F7, "S-A", "Scientific Atlanta" } ,
    { 0x11F8, "PMC-Sierra", "PMC-Sierra Inc." } ,
    { 0x11F9, "I-Cube", "I-Cube Inc" } ,
    { 0x11FA, "Kasan", "Kasan Electronics Co Ltd" } ,
    { 0x11FB, "Datel", "Datel Inc" } ,
    { 0x11FC, "Silicon Magic", "Silicon Magic" } ,
    { 0x11FD, "High Street", "High Street Consultants" } ,
    { 0x11FE, "Comtrol", "Comtrol Corp" } ,
    { 0x11FF, "Scion", "Scion Corp" } ,
    { 0x1200, "CSS", "CSS Corp" } ,
    { 0x1201, "Vista", "Vista Controls Corp" } ,
    { 0x1202, "Network Gen", "Network General Corp" } ,
    { 0x1203, "Agfa", "Bayer Corporation Agfa Div" } ,
    { 0x1204, "Lattice", "Lattice Semiconductor Corp" } ,
    { 0x1205, "Array", "Array Corp" } ,
    { 0x1206, "Amdahl", "Amdahl Corp" } ,
    { 0x1208, "Parsytec", "Parsytec GmbH" } ,
    { 0x1209, "Sci Sys", "Sci Systems Inc" } ,
    { 0x120A, "Synaptel", "Synaptel" } ,
    { 0x120B, "Adaptive", "Adaptive Solutions" } ,
    { 0x120D, "Comp Labs", "Compression Labs Inc." } ,
    { 0x120E, "Cyclades", "Cyclades Corporation" } ,
    { 0x120F, "Essential", "Essential Communications" } ,
    { 0x1210, "Hyperparallel", "Hyperparallel Technologies" } ,
    { 0x1211, "Braintech", "Braintech Inc" } ,
    { 0x1212, "Kingston", "Kingston Technology Corp" } ,
    { 0x1213, "AISI", "Applied Intelligent Systems Inc" } ,
    { 0x1214, "Perf Tech", "Performance Technologies Inc" } ,
    { 0x1215, "Interware", "Interware Co Ltd" } ,
    { 0x1216, "Purup Eskofot", "Purup-Eskofot A/S" } ,
    { 0x1217, "O2Micro", "O2Micro Inc" } ,
    { 0x1218, "Hybricon", "Hybricon Corp" } ,
    { 0x1219, "First Virtual", "First Virtual Corp" } ,
    { 0x121A, "3dfx", "3dfx Interactive Inc" } ,
    { 0x121B, "ATM", "Advanced Telecommunications Modules" } ,
    { 0x121C, "Nippon Texa", "Nippon Texa Co Ltd" } ,
    { 0x121D, "Lippert", "Lippert Automationstechnik GmbH" } ,
    { 0x121E, "CSPI", "CSPI" } ,
    { 0x121F, "Arcus", "Arcus Technology Inc" } ,
    { 0x1220, "Ariel", "Ariel Corporation" } ,
    { 0x1221, "Contec", "Contec Co Ltd" } ,
    { 0x1222, "Ancor", "Ancor Communications Inc" } ,
    { 0x1223, "Heurikon", "Heurikon/Computer Products" } ,
    { 0x1224, "Int. Img.", "Interactive Images" } ,
    { 0x1225, "Power IO", "Power I/O Inc." } ,
    { 0x1227, "Tech-Source", "Tech-Source" } ,
    { 0x1228, "Norsk", "Norsk Elektro Optikk A/S" } ,
    { 0x1229, "Data Kin", "Data Kinesis Inc." } ,
    { 0x122A, "Int. Telecom", "Integrated Telecom" } ,
    { 0x122B, "LG Ind.", "LG Industrial Systems Co. Ltd." } ,
    { 0x122C, "sci-worx", "sci-worx GmbH" } ,
    { 0x122D, "Aztech", "Aztech System Ltd" } ,
    { 0x122E, "Xyratex", "Xyratex" } ,
    { 0x122F, "Andrew", "Andrew Corp." } ,
    { 0x1230, "Fishcamp", "Fishcamp Engineering" } ,
    { 0x1231, "WMI", "Woodward McCoach Inc." } ,
    { 0x1232, "GPT", "GPT Ltd." } ,
    { 0x1233, "Bus-Tech", "Bus-Tech Inc." } ,
    { 0x1234, "Technical", "Technical Corp" } ,
    { 0x1235, "Risq Mod", "Risq Modular Systems Inc." } ,
    { 0x1236, "Sigma", "Sigma Designs Corp." } ,
    { 0x1237, "Alta Tech", "Alta Technology Corp." } ,
    { 0x1238, "Adtran", "Adtran" } ,
    { 0x1239, "3DO", "The 3DO Company" } ,
    { 0x123A, "Visicom", "Visicom Laboratories Inc." } ,
    { 0x123B, "Seeq", "Seeq Technology Inc." } ,
    { 0x123C, "Century Sys", "Century Systems Inc." } ,
    { 0x123D, "EDT", "Engineering Design Team Inc." } ,
    { 0x123F, "C-Cube", "C-Cube Microsystems" } ,
    { 0x1240, "Marathon", "Marathon Technologies Corp." } ,
    { 0x1241, "DSC", "DSC Communications" } ,
    { 0x1242, "JNI", "JNI Corporation" } ,
    { 0x1243, "Delphax", "Delphax" } ,
    { 0x1244, "AVM", "AVM AUDIOVISUELLES MKTG & Computer GmbH" } ,
    { 0x1245, "APD", "APD S.A." } ,
    { 0x1246, "Dipix", "Dipix Technologies Inc" } ,
    { 0x1247, "Xylon", "Xylon Research Inc." } ,
    { 0x1248, "Central Data", "Central Data Corp." } ,
    { 0x1249, "Samsung", "Samsung Electronics Co. Ltd." } ,
    { 0x124A, "AEG", "AEG Electrocom GmbH" } ,
    { 0x124B, "GreenSpring", "GreenSpring Computers" } ,
    { 0x124C, "Solitron", "Solitron Technologies Inc." } ,
    { 0x124D, "Stallion", "Stallion Technologies" } ,
    { 0x124E, "Cylink", "Cylink" } ,
    { 0x124F, "Infortrend", "Infortrend Technology Inc" } ,
    { 0x1250, "Hitachi", "Hitachi Microcomputer System Ltd." } ,
    { 0x1251, "VLSI Sol.", "VLSI Solution OY" } ,
    { 0x1253, "Guzik", "Guzik Technical Enterprises" } ,
    { 0x1254, "Linear Systems", "Linear Systems Ltd." } ,
    { 0x1255, "Optibase", "Optibase Ltd." } ,
    { 0x1256, "Perceptive", "Perceptive Solutions Inc." } ,
    { 0x1257, "Vertex", "Vertex Networks Inc." } ,
    { 0x1258, "Gilbarco", "Gilbarco Inc." } ,
    { 0x1259, "Allied Tsyn", "Allied Telesyn International" } ,
    { 0x125A, "ABB Pwr", "ABB Power Systems" } ,
    { 0x125B, "Asix", "Asix Electronics Corp." } ,
    { 0x125C, "Aurora", "Aurora Technologies Inc." } ,
    { 0x125D, "ESS", "ESS Technology" } ,
    { 0x125E, "Specvideo", "Specialvideo Engineering SRL" } ,
    { 0x125F, "Concurrent", "Concurrent Technologies Inc." } ,
    { 0x1260, "Intersil", "Intersil Corporation" } ,
    { 0x1261, "Matsushita", "Matsushita-Kotobuki Electronics Indu" } ,
    { 0x1262, "ES Comp.", "ES Computer Co. Ltd." } ,
    { 0x1263, "Sonic Sol.", "Sonic Solutions" } ,
    { 0x1264, "Aval Nag.", "Aval Nagasaki Corp." } ,
    { 0x1265, "Casio", "Casio Computer Co. Ltd." } ,
    { 0x1266, "Microdyne", "Microdyne Corp." } ,
    { 0x1267, "SA Telecom", "S.A. Telecommunications" } ,
    { 0x1268, "Tektronix", "Tektronix" } ,
    { 0x1269, "Thomson-CSF", "Thomson-CSF/TTM" } ,
    { 0x126A, "Lexmark", "Lexmark International Inc." } ,
    { 0x126B, "Adax", "Adax Inc." } ,
    { 0x126C, "NorTel", "Northern Telecom" } ,
    { 0x126D, "Splash", "Splash Technology Inc." } ,
    { 0x126E, "Sumitomo", "Sumitomo Metal Industries Ltd." } ,
    { 0x126F, "Sil Motion", "Silicon Motion" } ,
    { 0x1270, "Olympus", "Olympus Optical Co. Ltd." } ,
    { 0x1271, "GW Instr.", "GW Instruments" } ,
    { 0x1272, "Telematics", "Telematics International" } ,
    { 0x1273, "Hughes", "Hughes Network Systems" } ,
    { 0x1274, "Ensoniq", "Ensoniq" } ,
    { 0x1275, "NetApp", "Network Appliance" } ,
    { 0x1276, "Sw Net Tech", "Switched Network Technologies Inc." } ,
    { 0x1277, "Comstream", "Comstream" } ,
    { 0x1278, "Transtech", "Transtech Parallel Systems" } ,
    { 0x1279, "Transmeta", "Transmeta Corp." } ,
    { 0x127A, "Conexant", "Conexant Systems" } ,
    { 0x127B, "Pixera", "Pixera Corp" } ,
    { 0x127C, "Crosspoint", "Crosspoint Solutions Inc." } ,
    { 0x127D, "Vela Res", "Vela Research" } ,
    { 0x127E, "Winnow", "Winnov L.P." } ,
    { 0x127F, "Fujifilm", "Fujifilm" } ,
    { 0x1280, "Photoscript", "Photoscript Group Ltd." } ,
    { 0x1281, "Yokogawa", "Yokogawa Electronic Corp." } ,
    { 0x1282, "Davicom", "Davicom Semiconductor Inc." } ,
    { 0x1283, "ITExpress", "Integrated Technology Express Inc." } ,
    { 0x1284, "Sahara", "Sahara Networks Inc." } ,
    { 0x1285, "Plat Tech", "Platform Technologies Inc." } ,
    { 0x1286, "Mazet", "Mazet GmbH" } ,
    { 0x1287, "LuxSonor", "LuxSonor Inc." } ,
    { 0x1288, "Timestep", "Timestep Corp." } ,
    { 0x1289, "AVC Tech", "AVC Technology Inc." } ,
    { 0x128A, "Asante", "Asante Technologies Inc." } ,
    { 0x128B, "Transwitch", "Transwitch Corp." } ,
    { 0x128C, "Retix", "Retix Corp." } ,
    { 0x128D, "G2 Net", "G2 Networks Inc." } ,
    { 0x128E, "Samho", "Samho Multi Tech Ltd." } ,
    { 0x128F, "Tateno", "Tateno Dennou Inc." } ,
    { 0x1290, "Sord", "Sord Computer Corp." } ,
    { 0x1291, "NCS Comp", "NCS Computer Italia" } ,
    { 0x1292, "Tritech", "Tritech Microelectronics Intl PTE" } ,
    { 0x1293, "M Reality", "Media Reality Technology" } ,
    { 0x1294, "Rhetorex", "Rhetorex Inc." } ,
    { 0x1295, "Imagenation", "Imagenation Corp." } ,
    { 0x1296, "Kofax", "Kofax Image Products" } ,
    { 0x1297, "Holco", "Holco Enterprise" } ,
    { 0x1298, "Spellcaster", "Spellcaster Telecommunications Inc." } ,
    { 0x1299, "Know Tech", "Knowledge Technology Laboratories" } ,
    { 0x129A, "VMETRO", "VMETRO Inc." } ,
    { 0x129B, "Img Access", "Image Access" } ,
    { 0x129D, "CompCore", "CompCore Multimedia Inc." } ,
    { 0x129E, "Victor Jpn", "Victor Co. of Japan Ltd." } ,
    { 0x129F, "OEC Med", "OEC Medical Systems Inc." } ,
    { 0x12A0, "A-B", "Allen Bradley Co." } ,
    { 0x12A1, "Simpact", "Simpact Inc" } ,
    { 0x12A2, "NewGen", "NewGen Systems Corp." } ,
    { 0x12A3, "Lucent", "Lucent Technologies AMR" } ,
    { 0x12A4, "NTT Elect", "NTT Electronics Technology Co." } ,
    { 0x12A5, "Vision Dyn", "Vision Dynamics Ltd." } ,
    { 0x12A6, "Scalable", "Scalable Networks Inc." } ,
    { 0x12A7, "AMO", "AMO GmbH" } ,
    { 0x12A8, "News Datacom", "News Datacom" } ,
    { 0x12A9, "Xiotech", "Xiotech Corp." } ,
    { 0x12AA, "SDL", "SDL Communications Inc." } ,
    { 0x12AB, "Yuan Yuan", "Yuan Yuan Enterprise Co. Ltd." } ,
    { 0x12AC, "MeasureX", "MeasureX Corp." } ,
    { 0x12AD, "Multidata", "Multidata GmbH" } ,
    { 0x12AE, "Alteon", "Alteon Networks Inc." } ,
    { 0x12AF, "TDK USA", "TDK USA Corp." } ,
    { 0x12B0, "Jorge Sci", "Jorge Scientific Corp." } ,
    { 0x12B1, "GammaLink", "GammaLink" } ,
    { 0x12B2, "Gen Signal", "General Signal Networks" } ,
    { 0x12B3, "Inter-Face", "Inter-Face Co. Ltd." } ,
    { 0x12B4, "Future Tel", "Future Tel Inc." } ,
    { 0x12B5, "Granite", "Granite Systems Inc." } ,
    { 0x12B6, "Nat Micro", "Natural Microsystems" } ,
    { 0x12B7, "Acumen", "Acumen" } ,
    { 0x12B8, "Korg", "Korg" } ,
    { 0x12B9, "US Robotics", "US Robotics" } ,
    { 0x12BA, "Bittware", "Bittware Research Systems Inc" } ,
    { 0x12BB, "Nippon Uni", "Nippon Unisoft Corp." } ,
    { 0x12BC, "Array Micro", "Array Microsystems" } ,
    { 0x12BD, "Computerm", "Computerm Corp." } ,
    { 0x12BE, "Anchor Chips", "Anchor Chips Inc." } ,
    { 0x12BF, "Fujifilm", "Fujifilm Microdevices" } ,
    { 0x12C0, "Infimed", "Infimed" } ,
    { 0x12C1, "GMM Res", "GMM Research Corp." } ,
    { 0x12C2, "Mentec", "Mentec Ltd." } ,
    { 0x12C3, "Holtek", "Holtek Microelectronics Inc." } ,
    { 0x12C4, "Conn Tech", "Connect Tech Inc." } ,
    { 0x12C5, "PicturEl", "Picture Elements Inc." } ,
    { 0x12C6, "Mitani", "Mitani Corp." } ,
    { 0x12C7, "Dialogic", "Dialogic Corp." } ,
    { 0x12C8, "G Force", "G Force Co. Ltd." } ,
    { 0x12C9, "Gigi Ops", "Gigi Operations" } ,
    { 0x12CA, "ICE", "Integrated Computing Engines, Inc." } ,
    { 0x12CB, "Antex", "Antex Electronics Corp." } ,
    { 0x12CC, "Pluto", "Pluto Technologies International" } ,
    { 0x12CD, "Aims Lab", "Aims Lab" } ,
    { 0x12CE, "Netspeed", "Netspeed Inc." } ,
    { 0x12CF, "Prophet", "Prophet Systems Inc." } ,
    { 0x12D0, "GDE Sys", "GDE Systems Inc." } ,
    { 0x12D1, "PsiTech", "PsiTech" } ,
    { 0x12D2, "NVidia", "NVidia / SGS Thomson" } ,
    { 0x12D3, "Vingmed", "Vingmed Sound A/S" } ,
    { 0x12D4, "DGM&S", "DGM & S" } ,
    { 0x12D5, "Equator", "Equator Technologies" } ,
    { 0x12D6, "Analogic", "Analogic Corp." } ,
    { 0x12D7, "Biotronic", "Biotronic SRL" } ,
    { 0x12D8, "Pericom", "Pericom Semiconductor" } ,
    { 0x12D9, "Aculab", "Aculab Plc." } ,
    { 0x12DA, "TrueTime", "TrueTime" } ,
    { 0x12DB, "Annapolis", "Annapolis Micro Systems Inc." } ,
    { 0x12DC, "Symicron", "Symicron Computer Communication Ltd." } ,
    { 0x12DD, "MGI", "Management Graphics Inc." } ,
    { 0x12DE, "Rainbow", "Rainbow Technologies" } ,
    { 0x12DF, "SBS Tech", "SBS Technologies Inc." } ,
    { 0x12E0, "Chase", "Chase Research PLC" } ,
    { 0x12E1, "Nintendo", "Nintendo Co. Ltd." } ,
    { 0x12E2, "Datum", "Datum Inc. Bancomm-Timing Division" } ,
    { 0x12E3, "Imation", "Imation Corp. - Medical Imaging Syst" } ,
    { 0x12E4, "Brooktrout", "Brooktrout Technology Inc." } ,
    { 0x12E6, "Cirel", "Cirel Systems" } ,
    { 0x12E7, "Sebring", "Sebring Systems Inc" } ,
    { 0x12E8, "CRISC", "CRISC Corp." } ,
    { 0x12E9, "GE Spacenet", "GE Spacenet" } ,
    { 0x12EA, "Zuken", "Zuken" } ,
    { 0x12EB, "Aureal", "Aureal Semiconductor" } ,
    { 0x12EC, "3A Intl", "3A International Inc." } ,
    { 0x12ED, "Optivision", "Optivision Inc." } ,
    { 0x12EE, "Orange Micro", "Orange Micro, Inc." } ,
    { 0x12EF, "Vienna", "Vienna Systems" } ,
    { 0x12F0, "Pentek", "Pentek" } ,
    { 0x12F1, "Sorenson", "Sorenson Vision Inc." } ,
    { 0x12F2, "Gammagraphx", "Gammagraphx Inc." } ,
    { 0x12F4, "Megatel", "Megatel" } ,
    { 0x12F5, "Forks", "Forks" } ,
    { 0x12F6, "Dawson Fr", "Dawson France" } ,
    { 0x12F7, "Cognex", "Cognex" } ,
    { 0x12F8, "Electronic-Design", "Electronic-Design GmbH" } ,
    { 0x12F9, "FFT", "FourFold Technologies" } ,
    { 0x12FB, "SSP", "Spectrum Signal Processing" } ,
    { 0x12FC, NULL, "Capital Equipment Corp" } ,
    { 0x12FE, "ESD", "ESD Electronic System Design GmbH" } ,
    { 0x1304, NULL, "Juniper Networks Inc." } ,
    { 0x1307, "ComputerBoards", "ComputerBoards" } ,
    { 0x1308, "Jato", "Jato Technologies Inc." } ,
    { 0x130A, NULL, "Mitsubishi Electric Microcomputer" } ,
    { 0x130B, NULL, "Colorgraphic Communications Corp" } ,
    { 0x130F, NULL, "Advanet Inc." } ,
    { 0x1310, NULL, "Gespac" } ,
    { 0x1312, "RVSI", "Robotic Vision Systems Incorporated" } ,
    { 0x1313, NULL, "Yaskawa Electric Co." } ,
    { 0x1316, NULL, "Teradyne Inc." } ,
    { 0x1317, NULL, "Admtek Inc" } ,
    { 0x1318, "Packet Engines", "Packet Engines, Inc." } ,
    { 0x1319, "Forte Media", "Forte Media, Inc." } ,
    { 0x131f, NULL, "SIIG" } ,
    { 0x1325, NULL, "Salix Technologies Inc" } ,
    { 0x1326, NULL, "Seachange International" } ,
    { 0x1331, "RadiSys", "RadiSys Corporation" } ,
    { 0x1335, "Videomail", "Videomail Inc." } ,
    { 0x133D, NULL, "Prisa Networks" } ,
    { 0x133F, NULL, "SCM Microsystems" } ,
    { 0x1342, NULL, "Promax Systems Inc" } ,
    { 0x1344, "Micron", "Micron Technology, Inc." } ,
    { 0x1347, "Odetics", "Odetics" } ,
    { 0x134A, "DTC", "DTC Technology Corp." } ,
    { 0x134B, NULL, "ARK Research Corp." } ,
    { 0x134C, NULL, "Chori Joho System Co. Ltd" } ,
    { 0x134D, "PCTEL", "PCTEL Inc." } ,
    { 0x135A, NULL, "Brain Boxes Limited" } ,
    { 0x135B, NULL, "Giganet Inc." } ,
    { 0x135C, NULL, "Quatech Inc" } ,
    { 0x135D, "ABB Network Partn", "ABB Network Partner AB" } ,
    { 0x135E, "Sealevel", "Sealevel Systems Inc." } ,
    { 0x135F, NULL, "I-Data International A-S" } ,
    { 0x1360, NULL, "Meinberg Funkuhren" } ,
    { 0x1361, NULL, "Soliton Systems K.K." } ,
    { 0x1363, NULL, "Phoenix Technologies Ltd" } ,
    { 0x1365, "Hypercope", "Hypercope Corp." } ,
    { 0x1366, "Teijin", "Teijin Seiki Co. Ltd." } ,
    { 0x1367, NULL, "Hitachi Zosen Corporation" } ,
    { 0x1368, NULL, "Skyware Corporation" } ,
    { 0x1369, NULL, "Digigram" } ,
    { 0x136B, NULL, "Kawasaki Steel Corporation" } ,
    { 0x136C, NULL, "Adtek System Science Co Ltd" } ,
    { 0x1375, NULL, "Boeing - Sunnyvale" } ,
    { 0x1377, NULL, "GMBH" } ,
    { 0x137A, NULL, "Mark Of The Unicorn Inc" } ,
    { 0x137B, NULL, "PPT Vision" } ,
    { 0x137C, NULL, "Iwatsu Electric Co Ltd" } ,
    { 0x137D, NULL, "Dynachip Corporation" } ,
    { 0x137E, "PTSC", "Patriot Scientific Corp." } ,
    { 0x1380, NULL, "Sanritz Automation Co LTC" } ,
    { 0x1381, NULL, "Brains Co. Ltd" } ,
    { 0x1382, "Marian", "Marian - Electronic & Software" } ,
    { 0x1384, NULL, "Stellar Semiconductor Inc" } ,
    { 0x1385, "Netgear", "Netgear" } ,
    { 0x1387, NULL, "Systran Corp" } ,
    { 0x1388, NULL, "Hitachi Information Technology Co Ltd" } ,
    { 0x1389, "Applicom", "Applicom International" } ,
    { 0x138B, NULL, "Tokimec Inc" } ,
    { 0x138E, NULL, "Basler GMBH" } ,
    { 0x138F, NULL, "Patapsco Designs Inc" } ,
    { 0x1390, "CDI", "Concept Development Inc." } ,
    { 0x1393, NULL, "Moxa Technologies Co Ltd" } ,
    { 0x1395, NULL, "Ambicom Inc" } ,
    { 0x1396, NULL, "Cipher Systems Inc" } ,
    { 0x1397, "Cologne", "Cologne Chip Designs GmbH" } ,
    { 0x1398, NULL, "Clarion Co. Ltd" } ,
    { 0x139A, NULL, "Alacritech Inc" } ,
    { 0x139D, NULL, "Xstreams PLC/ EPL Limited" } ,
    { 0x139E, NULL, "Echostar Data Networks" } ,
    { 0x13A0, NULL, "Crystal Group Inc" } ,
    { 0x13A1, NULL, "Kawasaki Heavy Industries Ltd" } ,
    { 0x13A3, "HI-FN", "HI-FN Inc." } ,
    { 0x13A4, NULL, "Rascom Inc" } ,
    { 0x13A7, NULL, "Teles AG" } ,
    { 0x13A8, "XR", "Exar Corp." } ,
    { 0x13A9, NULL, "Siemens Medical Systems Ultrasound Group" } ,
    { 0x13AA, NULL, "Nortel Networks - BWA Division" } ,
    { 0x13AF, NULL, "T.Sqware" } ,
    { 0x13B1, NULL, "Tamura Corporation" } ,
    { 0x13B4, NULL, "Wellbean Co Inc" } ,
    { 0x13B5, NULL, "ARM Ltd" } ,
    { 0x13B6, NULL, "DLoG GMBH" } ,
    { 0x13B8, NULL, "Nokia Telecommunications OY" } ,
    { 0x13BD, "SHARP", "Sharp Corporation" } ,
    { 0x13BF, NULL, "Sharewave Inc" } ,
    { 0x13C0, "Microgate", "Microgate Corp." } ,
    { 0x13C1, "3ware", "3ware Inc." } ,
    { 0x13C2, NULL, "Technotrend Systemtechnik GMBH" } ,
    { 0x13C3, NULL, "Janz Computer AG" } ,
    { 0x13C7, NULL, "Blue Chip Technology Ltd" } ,
    { 0x13CC, NULL, "Metheus Corporation" } ,
    { 0x13CF, NULL, "Studio Audio & Video Ltd" } ,
    { 0x13D0, NULL, "B2C2 Inc" } ,
    { 0x13D1, NULL, "Abocom Systems Inc" } ,
    { 0x13D4, NULL, "Graphics Microsystems Inc" } ,
    { 0x13D6, NULL, "K.I. Technology Co Ltd" } ,
    { 0x13D7, NULL, "Toshiba Engineering Corporation" } ,
    { 0x13D8, NULL, "Phobos Corporation" } ,
    { 0x13D9, NULL, "Apex Inc" } ,
    { 0x13DC, NULL, "Netboost Corporation" } ,
    { 0x13DE, NULL, "ABB Robotics Products AB" } ,
    { 0x13DF, "E-Tech", "E-Tech Inc." } ,
    { 0x13E0, NULL, "GVC Corporation" } ,
    { 0x13E3, NULL, "Nest Inc" } ,
    { 0x13E4, NULL, "Calculex Inc" } ,
    { 0x13E5, NULL, "Telesoft Design Ltd" } ,
    { 0x13E9, NULL, "Intraserver Technology Inc" } ,
    { 0x13EA, NULL, "Dallas Semiconductor" } ,
    { 0x13F0, NULL, "Sundance Technology Inc" } ,
    { 0x13F1, NULL, "OCE - Industries S.A." } ,
    { 0x13F4, NULL, "Troika Networks Inc" } ,
    { 0x13F6, "C-Media", "C-Media Electronics Inc." } ,
    { 0x13F9, NULL, "NTT Advanced Technology Corp." } ,
    { 0x13FA, "Pentland", "Pentland Systems Ltd." } ,
    { 0x13FB, NULL, "Aydin Corp" } ,
    { 0x13FD, NULL, "Micro Science Inc" } ,
    { 0x13FE, "Advantech", "Advantech Co., Ltd." } ,
    { 0x1400, NULL, "ARTX Inc" } ,
    { 0x1402, "Meilhaus Electronic", "Meilhaus Electronic GmbH Germany" } ,
    { 0x1404, NULL, "Fundamental Software Inc" } ,
    { 0x1406, "Oc", "Oc Printing Systems" } ,
    { 0x1407, "LAVA", "Lava Computer MFG Inc." } ,
    { 0x1408, NULL, "Aloka Co. Ltd" } ,
    { 0x1409, NULL, "eTIMedia Technology Co Ltd" } ,
    { 0x140A, NULL, "DSP Research Inc" } ,
    { 0x140B, NULL, "Ramix Inc" } ,
    { 0x140D, NULL, "Matsushita Electric Works Ltd" } ,
    { 0x140F, NULL, "Salient Systems Corp" } ,
    { 0x1412, "IC Ensemble", "IC Ensemble, Inc." } ,
    { 0x1413, NULL, "Addonics" } ,
    { 0x1415, NULL, "Oxford Semiconductor Ltd" } ,
    { 0x1418, NULL, "Kyushu Electronics Systems Inc" } ,
    { 0x1419, NULL, "Excel Switching Corp" } ,
    { 0x141B, NULL, "Zoom Telephonics Inc" } ,
    { 0x141c, "Zoom", "Zoom Telephonics, Inc" } ,
    { 0x141E, NULL, "Fanuc Co. Ltd" } ,
    { 0x141F, NULL, "Visiontech Ltd" } ,
    { 0x1420, NULL, "Psion Dacom PLC" } ,
    { 0x1425, NULL, "ASIC Designers Inc" } ,
    { 0x1428, NULL, "Edec Co Ltd" } ,
    { 0x1429, NULL, "Unex Technology Corp." } ,
    { 0x142A, NULL, "Kingmax Technology Inc" } ,
    { 0x142B, NULL, "Radiolan" } ,
    { 0x142C, NULL, "Minton Optic Industry Co Ltd" } ,
    { 0x142D, NULL, "Pixstream Inc" } ,
    { 0x1430, NULL, "ITT Aerospace/Communications Division" } ,
    { 0x1433, NULL, "Eltec Elektronik AG" } ,
    { 0x1435, "RTD-USA", "Real Time Devices USA, Inc." } ,
    { 0x1436, NULL, "CIS Technology Inc" } ,
    { 0x1437, NULL, "Nissin Inc Co" } ,
    { 0x1438, NULL, "Atmel-Dream" } ,
    { 0x143F, NULL, "Lightwell Co Ltd - Zax Division" } ,
    { 0x1441, NULL, "Agie SA." } ,
    { 0x1445, NULL, "Logical Co Ltd" } ,
    { 0x1446, NULL, "Graphin Co. Ltd" } ,
    { 0x1447, NULL, "Aim GMBH" } ,
    { 0x1448, "Alesis", "Alesis Studio" } ,
    { 0x144A, "ADLINK", "ADLINK Technology Inc" } ,
    { 0x144B, "Loronix", "Loronix Information Systems, Inc." } ,
    { 0x144D, NULL, "Samsung Electronics Co Ltd" } ,
    { 0x1450, NULL, "Octave Communications Ind." } ,
    { 0x1451, NULL, "SP3D Chip Design GMBH" } ,
    { 0x1453, NULL, "Mycom Inc" } ,
    { 0x1455, NULL, "Logic Plus PLUS Inc" } ,
    { 0x1458, "Giga-Byte", "Giga-Byte Technologies" } ,
    { 0x145C, NULL, "Cryptek" } ,
    { 0x145F, "Baldor", "Baldor Electric Company" } ,
    { 0x1460, NULL, "Dynarc Inc" } ,
    { 0x1462, NULL, "Micro-Star International Co Ltd" } ,
    { 0x1463, NULL, "Fast Corporation" } ,
    { 0x1464, "ICS", "Interactive Circuits & Systems Ltd" } ,
    { 0x1465, NULL, "GN Nettest Telecom Div." } ,
    { 0x1468, NULL, "Ambit Microsystems Corp." } ,
    { 0x1469, NULL, "Cleveland Motion Controls" } ,
    { 0x146C, NULL, "Ruby Tech Corp." } ,
    { 0x146D, NULL, "Tachyon Inc." } ,
    { 0x146E, NULL, "WMS Gaming" } ,
    { 0x1471, NULL, "Integrated Telecom Express Inc" } ,
    { 0x1473, NULL, "Zapex Technologies Inc" } ,
    { 0x1474, NULL, "Doug Carson & Associates" } ,
    { 0x1477, NULL, "Net Insight" } ,
    { 0x1478, NULL, "Diatrend Corporation" } ,
    { 0x147B, NULL, "Abit Computer Corp." } ,
    { 0x147F, NULL, "Nihon Unisys Ltd." } ,
    { 0x1482, NULL, "Isytec - Integrierte Systemtechnik Gmbh" } ,
    { 0x1483, NULL, "Labway Coporation" } ,
    { 0x1485, NULL, "Erma - Electronic GMBH" } ,
    { 0x1489, NULL, "KYE Systems Corporation" } ,
    { 0x148A, NULL, "Opto 22" } ,
    { 0x148B, NULL, "Innomedialogic Inc." } ,
    { 0x148D, "Digicom", "Digicom Systems Inc." } ,
    { 0x148E, NULL, "OSI Plus Corporation" } ,
    { 0x148F, NULL, "Plant Equipment Inc." } ,
    { 0x1490, NULL, "TC Labs Pty Ltd." } ,
    { 0x1493, NULL, "Maker Communications" } ,
    { 0x1495, NULL, "Tokai Communications Industry Co. Ltd" } ,
    { 0x1496, NULL, "Joytech Computer Co. Ltd." } ,
    { 0x1497, NULL, "SMA Regelsysteme GMBH" } ,
    { 0x1499, NULL, "Micro-Technology Co Ltd" } ,
    { 0x149B, NULL, "Seiko Instruments Inc" } ,
    { 0x149E, NULL, "Mapletree Networks Inc." } ,
    { 0x149F, NULL, "Lectron Co Ltd" } ,
    { 0x14A0, NULL, "Softing GMBH" } ,
    { 0x14A2, NULL, "Millennium Engineering Inc" } ,
    { 0x14A4, NULL, "GVC/BCM Advanced Research" } ,
    { 0x14A5, NULL, "Xionics Document Technologies Inc." } ,
    { 0x14A9, NULL, "Hivertec Inc." } ,
    { 0x14AB, NULL, "Mentor Graphics Corp." } ,
    { 0x14B1, NULL, "Nextcom K.K." } ,
    { 0x14B3, "Xpeed", "Xpeed Inc." } ,
    { 0x14B4, NULL, "Philips Business Electronics B.V." } ,
    { 0x14B6, NULL, "Quantum Data Corp." } ,
    { 0x14B7, "Proxim", "Proxim Inc." } ,
    { 0x14B9, "Aironet", "Aironet Wireless Communication" } ,
    { 0x14BA, NULL, "Internix Inc." } ,
    { 0x14BB, NULL, "Semtech Corporation" } ,
    { 0x14BE, NULL, "L3 Communications" } ,
    { 0x14C1, NULL, "Myricom Inc." } ,
    { 0x14C2, NULL, "DTK Computer" } ,
    { 0x14C4, NULL, "Iwasaki Information Systems Co Ltd" } ,
    { 0x14C5, NULL, "ABB Automation Products AB" } ,
    { 0x14C6, NULL, "Data Race Inc" } ,
    { 0x14C7, "Modtech", "Modular Technology Ltd." } ,
    { 0x14C8, "Turbocomm", "Turbocomm Tech Inc" } ,
    { 0x14C9, NULL, "Odin Telesystems Inc" } ,
    { 0x14CB, NULL, "Billionton Systems Inc./Cadmus Micro Inc" } ,
    { 0x14CD, NULL, "Universal Scientific Ind." } ,
    { 0x14CF, NULL, "TEK Microsystems Inc." } ,
    { 0x14D2, "OX", "Oxford Semiconductor" } ,
    { 0x14D4, "PANACOM", "Panacom Technology Corporation" } ,
    { 0x14D5, NULL, "Nitsuko Corporation" } ,
    { 0x14D6, NULL, "Accusys Inc" } ,
    { 0x14D7, NULL, "Hirakawa Hewtech Corp" } ,
    { 0x14D8, NULL, "Hopf Elektronik GMBH" } ,
    { 0x14D9, NULL, "Alpha Processor Inc" } ,
    { 0x14DB, "Avlab", "Avlab Technology Inc." } ,
    { 0x14DC, "Amplicon", "Amplicon Liveline Inc." } ,
    { 0x14DD, NULL, "Imodl Inc." } ,
    { 0x14DE, NULL, "Applied Integration Corporation" } ,
    { 0x14E3, NULL, "Amtelco" } ,
    { 0x14E4, NULL, "Broadcom Corporation" } ,
    { 0x14EB, NULL, "Seiko Epson Corporation" } ,
    { 0x14EC, NULL, "Acqiris" } ,
    { 0x14ED, NULL, "Datakinetics Ltd" } ,
    { 0x14EF, NULL, "Carry Computer Eng. Co Ltd" } ,
    { 0x14F1, "Conexant", "Conexant Systems, Inc." } ,
    { 0x14F2, "Mobility", "Mobility Electronics, Inc." } ,
    { 0x14F4, NULL, "Tokyo Electronic Industry Co. Ltd." } ,
    { 0x14F5, NULL, "Sopac Ltd" } ,
    { 0x14F6, NULL, "Coyote Technologies LLC" } ,
    { 0x14F7, NULL, "Wolf Technology Inc" } ,
    { 0x14F8, NULL, "Audiocodes Inc" } ,
    { 0x14F9, NULL, "AG Communications" } ,
    { 0x14FB, NULL, "Transas Marine (UK) Ltd" } ,
    { 0x14FC, NULL, "Quadrics Supercomputers World" } ,
    { 0x14FD, NULL, "Japan Computer Industry Inc." } ,
    { 0x14FE, NULL, "Archtek Telecom Corp." } ,
    { 0x14FF, NULL, "Twinhead International Corp." } ,
    { 0x1500, "DELTA", "DELTA Electronics, Inc." } ,
    { 0x1501, NULL, "Banksoft Canada Ltd" } ,
    { 0x1502, NULL, "Mitsubishi Electric Logistics Support Co" } ,
    { 0x1503, NULL, "Kawasaki LSI USA Inc" } ,
    { 0x1504, NULL, "Kaiser Electronics" } ,
    { 0x1506, NULL, "Chameleon Systems Inc" } ,
    { 0x1507, "Htec", "Htec Ltd." } ,
    { 0x1509, NULL, "First International Computer Inc" } ,
    { 0x150B, NULL, "Yamashita Systems Corp" } ,
    { 0x150C, NULL, "Kyopal Co Ltd" } ,
    { 0x150D, NULL, "Warpspped Inc" } ,
    { 0x150E, NULL, "C-Port Corporation" } ,
    { 0x150F, NULL, "Intec GMBH" } ,
    { 0x1510, NULL, "Behavior Tech Computer Corp" } ,
    { 0x1511, NULL, "Centillium Technology Corp" } ,
    { 0x1512, NULL, "Rosun Technologies Inc" } ,
    { 0x1513, NULL, "Raychem" } ,
    { 0x1514, NULL, "TFL LAN Inc" } ,
    { 0x1515, NULL, "ICS Advent" } ,
    { 0x1516, NULL, "Myson Technology Inc" } ,
    { 0x1517, NULL, "Echotek Corporation" } ,
    { 0x1518, NULL, "PEP Modular Computers GMBH" } ,
    { 0x1519, NULL, "Telefon Aktiebolaget LM Ericsson" } ,
    { 0x151A, "Globetek", "Globetek Inc." } ,
    { 0x151B, NULL, "Combox Ltd" } ,
    { 0x151C, NULL, "Digital Audio Labs Inc" } ,
    { 0x151D, NULL, "Fujitsu Computer Products Of America" } ,
    { 0x151E, NULL, "Matrix Corp." } ,
    { 0x151F, NULL, "Topic Semiconductor Corp" } ,
    { 0x1520, NULL, "Chaplet System Inc" } ,
    { 0x1521, NULL, "Bell Corporation" } ,
    { 0x1522, "Mainpine", "Mainpine Limited" } ,
    { 0x1523, NULL, "Music Semiconductors" } ,
    { 0x1524, NULL, "ENE Technology Inc" } ,
    { 0x1525, NULL, "Impact Technologies" } ,
    { 0x1526, NULL, "ISS Inc" } ,
    { 0x1527, NULL, "Solectron" } ,
    { 0x1528, NULL, "Acksys" } ,
    { 0x1529, NULL, "American Microsystems Inc" } ,
    { 0x152A, NULL, "Quickturn Design Systems" } ,
    { 0x152B, NULL, "Flytech Technology Co Ltd" } ,
    { 0x152C, NULL, "Macraigor Systems LLC" } ,
    { 0x152D, NULL, "Quanta Computer Inc" } ,
    { 0x152E, NULL, "Melec Inc" } ,
    { 0x152F, NULL, "Philips - Crypto" } ,
    { 0x1532, NULL, "Echelon Corporation" } ,
    { 0x1533, NULL, "Baltimore" } ,
    { 0x1534, NULL, "Road Corporation" } ,
    { 0x1535, NULL, "Evergreen Technologies Inc" } ,
    { 0x1537, NULL, "Datalex Communcations" } ,
    { 0x1538, NULL, "Aralion Inc." } ,
    { 0x1539, NULL, "Atelier Informatiques et Electronique Et" } ,
    { 0x153A, NULL, "ONO Sokki" } ,
    { 0x153B, NULL, "Terratec Electronic GMBH" } ,
    { 0x153C, NULL, "Antal Electronic" } ,
    { 0x153D, NULL, "Filanet Corporation" } ,
    { 0x153E, NULL, "Techwell Inc" } ,
    { 0x153F, NULL, "MIPS Denmark" } ,
    { 0x1540, NULL, "Provideo Multimedia Co Ltd" } ,
    { 0x1541, NULL, "Telocity Inc." } ,
    { 0x1542, NULL, "Vivid Technology Inc" } ,
    { 0x1543, NULL, "Silicon Laboratories" } ,
    { 0x1544, NULL, "DCM Data Systems" } ,
    { 0x1545, NULL, "Visiontek" } ,
    { 0x1546, NULL, "IOI Technology Corp." } ,
    { 0x1547, NULL, "Mitutoyo Corporation" } ,
    { 0x1548, NULL, "Jet Propulsion Laboratory" } ,
    { 0x1549, "ISS", "Interconnect Systems Solutions" } ,
    { 0x154A, NULL, "Max Technologies Inc." } ,
    { 0x154B, NULL, "Computex Co Ltd" } ,
    { 0x154C, NULL, "Visual Technology Inc." } ,
    { 0x154D, NULL, "PAN International Industrial Corp" } ,
    { 0x154E, NULL, "Servotest Ltd" } ,
    { 0x154F, NULL, "Stratabeam Technology" } ,
    { 0x1550, NULL, "Open Network Co Ltd" } ,
    { 0x1551, NULL, "Smart Electronic Development GMBH" } ,
    { 0x1552, NULL, "Racal Airtech Ltd" } ,
    { 0x1553, NULL, "Chicony Electronics Co Ltd" } ,
    { 0x1554, NULL, "Prolink Microsystems Corp." } ,
    { 0x1556, NULL, "PLD Applications" } ,
    { 0x1557, NULL, "Mediastar Co. Ltd" } ,
    { 0x1558, NULL, "Clevo/Kapok Computer" } ,
    { 0x1559, NULL, "SI Logic Ltd" } ,
    { 0x155A, NULL, "Innomedia Inc" } ,
    { 0x155B, NULL, "Protac International Corp" } ,
    { 0x155C, NULL, "Cemax-Icon Inc" } ,
    { 0x155D, NULL, "MAC System Co Ltd" } ,
    { 0x155E, NULL, "LP Elektronik GMBH" } ,
    { 0x155F, NULL, "Perle Systems Limited" } ,
    { 0x1560, NULL, "Terayon Communications Systems" } ,
    { 0x1561, NULL, "Viewgraphics Inc" } ,
    { 0x1562, NULL, "Symbol Technologies" } ,
    { 0x1563, NULL, "A-Trend Technology Co Ltd" } ,
    { 0x1564, NULL, "Yamakatsu Electronics Industry Co Ltd" } ,
    { 0x1565, NULL, "Biostar Microtech Intl Corp" } ,
    { 0x1566, NULL, "Ardent Technologies Inc" } ,
    { 0x1567, NULL, "Jungsoft" } ,
    { 0x1568, NULL, "DDK Electronics Inc" } ,
    { 0x1569, NULL, "Palit Microsystems Inc" } ,
    { 0x156A, NULL, "Avtec Systems" } ,
    { 0x156B, NULL, "2wire Inc" } ,
    { 0x156C, NULL, "Vidac Electronics GMBH" } ,
    { 0x156D, NULL, "Alpha-Top Corp" } ,
    { 0x156E, NULL, "Alfa Inc." } ,
    { 0x156F, NULL, "M-Systems Flash Disk Pioneers Ltd" } ,
    { 0x1570, NULL, "Lecroy Corporation" } ,
    { 0x1571, NULL, "Contemporary Controls" } ,
    { 0x1572, NULL, "Otis Elevator Company" } ,
    { 0x1573, NULL, "Lattice - Vantis" } ,
    { 0x1574, NULL, "Fairchild Semiconductor" } ,
    { 0x1575, NULL, "Voltaire Advanced Data Security Ltd" } ,
    { 0x1576, NULL, "Viewcast Com" } ,
    { 0x1578, NULL, "Hitt" } ,
    { 0x1579, NULL, "Dual Technology Corporation" } ,
    { 0x157A, NULL, "Japan Elecronics Ind. Inc" } ,
    { 0x157B, NULL, "Star Multimedia Corp." } ,
    { 0x157C, "Eurosoft", "Eurosoft (UK)" } ,
    { 0x157D, NULL, "Gemflex Networks" } ,
    { 0x157E, NULL, "Transition Networks" } ,
    { 0x157F, NULL, "PX Instruments Technology Ltd" } ,
    { 0x1580, NULL, "Primex Aerospace Co." } ,
    { 0x1581, NULL, "SEH Computertechnik GMBH" } ,
    { 0x1582, NULL, "Cytec Corporation" } ,
    { 0x1583, NULL, "Inet Technologies Inc" } ,
    { 0x1584, NULL, "Uniwill Computer Corp." } ,
    { 0x1585, NULL, "Marconi Commerce Systems SRL" } ,
    { 0x1586, NULL, "Lancast Inc" } ,
    { 0x1587, NULL, "Konica Corporation" } ,
    { 0x1588, NULL, "Solidum Systems Corp" } ,
    { 0x1589, NULL, "Atlantek Microsystems Pty Ltd" } ,
    { 0x158A, NULL, "Digalog Systems Inc" } ,
    { 0x158B, NULL, "Allied Data Technologies" } ,
    { 0x158C, NULL, "Hitachi Semiconductor & Devices Sales Co" } ,
    { 0x158D, NULL, "Point Multimedia Systems" } ,
    { 0x158E, NULL, "Lara Technology Inc" } ,
    { 0x158F, NULL, "Ditect Coop" } ,
    { 0x1590, NULL, "3pardata Inc." } ,
    { 0x1591, NULL, "ARN" } ,
    { 0x1592, "Syba", "Syba Tech Ltd." } ,
    { 0x1593, NULL, "Bops Inc" } ,
    { 0x1594, NULL, "Netgame Ltd" } ,
    { 0x1595, NULL, "Diva Systems Corp." } ,
    { 0x1596, NULL, "Folsom Research Inc" } ,
    { 0x1597, NULL, "Memec Design Services" } ,
    { 0x1598, NULL, "Granite Microsystems" } ,
    { 0x1599, NULL, "Delta Electronics Inc" } ,
    { 0x159A, NULL, "General Instrument" } ,
    { 0x159B, NULL, "Faraday Technology Corp" } ,
    { 0x159C, NULL, "Stratus Computer Systems" } ,
    { 0x159D, NULL, "Ningbo Harrison Electronics Co Ltd" } ,
    { 0x159E, NULL, "A-Max Technology Co Ltd" } ,
    { 0x159F, NULL, "Galea Network Security" } ,
    { 0x15A0, NULL, "Compumaster SRL" } ,
    { 0x15A1, NULL, "Geocast Network Systems Inc" } ,
    { 0x15A2, NULL, "Catalyst Enterprises Inc" } ,
    { 0x15A3, NULL, "Italtel" } ,
    { 0x15A4, NULL, "X-Net OY" } ,
    { 0x15A5, NULL, "Toyota MACS Inc" } ,
    { 0x15A6, NULL, "Sunlight Ultrasound Technologies Ltd" } ,
    { 0x15A7, NULL, "SSE Telecom Inc" } ,
    { 0x15A8, NULL, "Shanghai Communications Technologies Cen" } ,
    { 0x15AA, NULL, "Moreton Bay" } ,
    { 0x15AB, NULL, "Bluesteel Networks Inc" } ,
    { 0x15AC, NULL, "North Atlantic Instruments" } ,
    { 0x15AD, "VMware", "VMware Inc." } ,
    { 0x15AE, NULL, "Amersham Pharmacia Biotech" } ,
    { 0x15B0, NULL, "Zoltrix International Limited" } ,
    { 0x15B1, NULL, "Source Technology Inc" } ,
    { 0x15B2, NULL, "Mosaid Technologies Inc." } ,
    { 0x15B3, NULL, "Mellanox Technology" } ,
    { 0x15B4, NULL, "CCI/Triad" } ,
    { 0x15B5, NULL, "Cimetrics Inc" } ,
    { 0x15B6, NULL, "Texas Memory Systems Inc" } ,
    { 0x15B7, NULL, "Sandisk Corp." } ,
    { 0x15B8, NULL, "Addi-Data GMBH" } ,
    { 0x15B9, NULL, "Maestro Digital Communications" } ,
    { 0x15BA, NULL, "Impacct Technology Corp" } ,
    { 0x15BB, NULL, "Portwell Inc" } ,
    { 0x15BC, "Agilent", "Agilent Technologies" } ,
    { 0x15BD, NULL, "DFI Inc." } ,
    { 0x15BE, NULL, "Sola Electronics" } ,
    { 0x15BF, NULL, "High Tech Computer Corp (HTC)" } ,
    { 0x15C0, "BVM", "BVM Limited" } ,
    { 0x15C1, NULL, "Quantel" } ,
    { 0x15C2, NULL, "Newer Technology Inc" } ,
    { 0x15C3, NULL, "Taiwan Mycomp Co Ltd" } ,
    { 0x15C4, NULL, "EVSX Inc" } ,
    { 0x15C5, NULL, "Procomp Informatics Ltd" } ,
    { 0x15C6, NULL, "Technical University Of Budapest" } ,
    { 0x15C7, NULL, "Tateyama System Laboratory Co Ltd" } ,
    { 0x15C8, NULL, "Penta Media Co. Ltd" } ,
    { 0x15C9, NULL, "Serome Technology Inc" } ,
    { 0x15CA, NULL, "Bitboys OY" } ,
    { 0x15CB, NULL, "AG Electronics Ltd" } ,
    { 0x15CC, NULL, "Hotrail Inc." } ,
    { 0x15CD, NULL, "Dreamtech Co Ltd" } ,
    { 0x15CE, NULL, "Genrad Inc." } ,
    { 0x15CF, NULL, "Hilscher GMBH" } ,
    { 0x15D1, "Infineon", "Infineon Technologies AG" } ,
    { 0x15D2, NULL, "FIC (First International Computer Inc)" } ,
    { 0x15D3, NULL, "NDS Technologies Israel Ltd" } ,
    { 0x15D4, NULL, "Iwill Corporation" } ,
    { 0x15D5, NULL, "Tatung Co." } ,
    { 0x15D6, NULL, "Entridia Corporation" } ,
    { 0x15D7, NULL, "Rockwell-Collins Inc" } ,
    { 0x15D8, NULL, "Cybernetics Technology Co Ltd" } ,
    { 0x15D9, NULL, "Super Micro Computer Inc" } ,
    { 0x15DA, NULL, "Cyberfirm Inc." } ,
    { 0x15DB, NULL, "Applied Computing Systems Inc." } ,
    { 0x15DC, "Litronic", "Litronic Inc." } ,
    { 0x15DD, NULL, "Sigmatel Inc." } ,
    { 0x15DE, NULL, "Malleable Technologies Inc" } ,
    { 0x15DF, NULL, "Infinilink Corp." } ,
    { 0x15E0, NULL, "Cacheflow Inc" } ,
    { 0x15E1, "VTG", "Voice Technologies Group" } ,
    { 0x15E2, NULL, "Quicknet Technologies Inc" } ,
    { 0x15E3, NULL, "Networth Technologies Inc" } ,
    { 0x15E4, NULL, "VSN Systemen BV" } ,
    { 0x15E5, NULL, "Valley Technologies Inc" } ,
    { 0x15E6, NULL, "Agere Inc." } ,
    { 0x15E7, NULL, "GET Engineering Corp." } ,
    { 0x15E8, NULL, "National Datacomm Corp." } ,
    { 0x15E9, NULL, "Pacific Digital Corp." } ,
    { 0x15EA, NULL, "Tokyo Denshi Sekei K.K." } ,
    { 0x15EB, NULL, "Drsearch GMBH" } ,
    { 0x15EC, NULL, "Beckhoff GMBH" } ,
    { 0x15ED, NULL, "Macrolink Inc" } ,
    { 0x15EE, NULL, "IN Win Development Inc." } ,
    { 0x15EF, NULL, "Intelligent Paradigm Inc" } ,
    { 0x15F0, NULL, "B-Tree Systems Inc" } ,
    { 0x15F1, NULL, "Times N Systems Inc" } ,
    { 0x15F2, NULL, "Diagnostic Instruments Inc" } ,
    { 0x15F3, NULL, "Digitmedia Corp." } ,
    { 0x15F4, NULL, "Valuesoft" } ,
    { 0x15F5, NULL, "Power Micro Research" } ,
    { 0x15F6, NULL, "Extreme Packet Device Inc" } ,
    { 0x15F7, NULL, "Banctec" } ,
    { 0x15F8, NULL, "Koga Electronics Co" } ,
    { 0x15F9, NULL, "Zenith Electronics Corporation" } ,
    { 0x15FA, NULL, "J.P. Axzam Corporation" } ,
    { 0x15FB, NULL, "Zilog Inc." } ,
    { 0x15FC, NULL, "Techsan Electronics Co Ltd" } ,
    { 0x15FD, NULL, "N-Cubed.Net" } ,
    { 0x15FE, NULL, "Kinpo Electronics Inc" } ,
    { 0x15FF, NULL, "Fastpoint Technologies Inc." } ,
    { 0x1600, NULL, "Northrop Grumman - Canada Ltd" } ,
    { 0x1601, NULL, "Tenta Technology" } ,
    { 0x1602, NULL, "Prosys-TEC Inc." } ,
    { 0x1603, NULL, "Nokia Wireless Business Communications" } ,
    { 0x1604, NULL, "Central System Research Co Ltd" } ,
    { 0x1605, NULL, "Pairgain Technologies" } ,
    { 0x1606, NULL, "Europop AG" } ,
    { 0x1607, NULL, "Lava Semiconductor Manufacturing Inc." } ,
    { 0x1608, NULL, "Automated Wagering International" } ,
    { 0x1609, NULL, "Sciemetric Instruments Inc" } ,
    { 0x160A, NULL, "Kollmorgen Servotronix" } ,
    { 0x160B, NULL, "Onkyo Corp." } ,
    { 0x160C, NULL, "Oregon Micro Systems Inc." } ,
    { 0x160D, NULL, "Aaeon Electronics Inc" } ,
    { 0x160E, NULL, "CML Emergency Services" } ,
    { 0x160F, NULL, "ITEC Co Ltd" } ,
    { 0x1610, NULL, "Tottori Sanyo Electric Co Ltd" } ,
    { 0x1611, NULL, "Bel Fuse Inc." } ,
    { 0x1612, NULL, "Telesynergy Research Inc." } ,
    { 0x1613, NULL, "System Craft Inc." } ,
    { 0x1614, NULL, "Jace Tech Inc." } ,
    { 0x1615, NULL, "Equus Computer Systems Inc" } ,
    { 0x1616, NULL, "Iotech Inc." } ,
    { 0x1617, NULL, "Rapidstream Inc" } ,
    { 0x1618, NULL, "Esec SA" } ,
    { 0x1619, "FarSite", "FarSite Communications Limited" } ,
    { 0x161A, NULL, "Wvinten Ltd" } ,
    { 0x161B, NULL, "Mobilian Israel Ltd" } ,
    { 0x161C, NULL, "Berkshire Products" } ,
    { 0x161D, NULL, "Gatec" } ,
    { 0x161E, NULL, "Kyoei Sangyo Co Ltd" } ,
    { 0x161F, NULL, "Arima Computer Co" } ,
    { 0x1620, NULL, "Sigmacom Co Ltd" } ,
    { 0x1621, NULL, "Lynx Studio Technology Inc" } ,
    { 0x1622, "NHC", "Nokia Home Communications" } ,
    { 0x1623, NULL, "KRF Tech Ltd" } ,
    { 0x1624, NULL, "CE Infosys GMBH" } ,
    { 0x1625, NULL, "Warp Nine Engineering" } ,
    { 0x1626, NULL, "TDK Semiconductor Corp." } ,
    { 0x1627, NULL, "BCom Electronics Inc" } ,
    { 0x1629, NULL, "Kongsberg Spacetec a.s." } ,
    { 0x162A, NULL, "Sejin Computerland Co Ltd" } ,
    { 0x162B, NULL, "Shanghai Bell Company Limited" } ,
    { 0x162C, NULL, "C&H Technologies Inc" } ,
    { 0x162D, NULL, "Reprosoft Co Ltd" } ,
    { 0x162E, NULL, "Margi Systems Inc" } ,
    { 0x162F, NULL, "Rohde & Schwarz GMBH & Co KG" } ,
    { 0x1630, NULL, "Sky Computers Inc" } ,
    { 0x1631, NULL, "NEC Computer International" } ,
    { 0x1632, NULL, "Verisys Inc" } ,
    { 0x1633, NULL, "Adac Corporation" } ,
    { 0x1634, NULL, "Visionglobal Network Corp." } ,
    { 0x1635, NULL, "Decros" } ,
    { 0x1636, NULL, "Jean Company Ltd" } ,
    { 0x1637, NULL, "NSI" } ,
    { 0x1638, NULL, "Eumitcom Technology Inc" } ,
    { 0x163A, NULL, "Air Prime Inc" } ,
    { 0x163B, NULL, "Glotrex Co Ltd" } ,
    { 0x163C, NULL, "Smart Link" } ,
    { 0x163D, NULL, "Heidelberg Digital LLC" } ,
    { 0x163E, NULL, "3dpower" } ,
    { 0x163F, NULL, "Renishaw PLC" } ,
    { 0x1640, NULL, "Intelliworxx Inc" } ,
    { 0x1641, NULL, "MKNet Corporation" } ,
    { 0x1642, NULL, "Bitland" } ,
    { 0x1643, NULL, "Hajime Industries Ltd" } ,
    { 0x1644, NULL, "Western Avionics Ltd" } ,
    { 0x1645, NULL, "Quick-Serv. Computer Co. Ltd" } ,
    { 0x1646, NULL, "Nippon Systemware Co Ltd" } ,
    { 0x1647, NULL, "Hertz Systemtechnik GMBH" } ,
    { 0x1648, NULL, "MeltDown Systems LLC" } ,
    { 0x1649, NULL, "Jupiter Systems" } ,
    { 0x164A, NULL, "Aiwa Co. Ltd" } ,
    { 0x164C, NULL, "Department Of Defense" } ,
    { 0x164D, NULL, "Ishoni Networks" } ,
    { 0x164E, NULL, "Micrel Inc." } ,
    { 0x164F, NULL, "Datavoice (Pty) Ltd." } ,
    { 0x1650, NULL, "Admore Technology Inc." } ,
    { 0x1651, NULL, "Chaparral Network Storage" } ,
    { 0x1652, NULL, "Spectrum Digital Inc." } ,
    { 0x1653, NULL, "Nature Worldwide Technology Corp" } ,
    { 0x1654, NULL, "Sonicwall Inc" } ,
    { 0x1655, NULL, "Dazzle Multimedia Inc." } ,
    { 0x1656, NULL, "Insyde Software Corp" } ,
    { 0x1657, NULL, "Brocade Communications Systems" } ,
    { 0x1658, NULL, "Med Associates Inc." } ,
    { 0x1659, NULL, "Shiba Denshi Systems Inc." } ,
    { 0x165A, NULL, "Epix Inc." } ,
    { 0x165B, NULL, "Real-Time Digital Inc." } ,
    { 0x165C, NULL, "Gidel Ltd." } ,
    { 0x165D, NULL, "Hsing Tech. Enterprise Co. Ltd." } ,
    { 0x165E, NULL, "Hyunju Computer Co. Ltd." } ,
    { 0x165F, NULL, "Add One Company" } ,
    { 0x1660, NULL, "Network Security Technologies Inc. (Net " } ,
    { 0x1661, NULL, "Worldspace Corp." } ,
    { 0x1662, NULL, "Int Labs" } ,
    { 0x1663, NULL, "Elmec Inc. Ltd." } ,
    { 0x1664, NULL, "Fastfame Technology Co. Ltd." } ,
    { 0x1665, NULL, "Edax Inc." } ,
    { 0x1666, NULL, "Norpak Corporation" } ,
    { 0x1667, NULL, "CoSystems Inc." } ,
    { 0x1668, "Actiontec", "Actiontec Electronics Inc." } ,
    { 0x166A, NULL, "Komatsu Ltd." } ,
    { 0x166B, NULL, "Supernet Inc." } ,
    { 0x166C, NULL, "Shade Ltd." } ,
    { 0x166D, NULL, "Sibyte Inc." } ,
    { 0x166E, NULL, "Schneider Automation Inc." } ,
    { 0x166F, NULL, "Televox Software Inc." } ,
    { 0x1670, NULL, "Rearden Steel" } ,
    { 0x1671, NULL, "Atan Technology Inc." } ,
    { 0x1672, NULL, "Unitec Co. Ltd." } ,
    { 0x1673, NULL, "Connex" } ,
    { 0x1675, NULL, "Square Wave Technology" } ,
    { 0x1676, NULL, "Emachines Inc." } ,
    { 0x1677, NULL, "Bernecker + Rainer" } ,
    { 0x1678, NULL, "INH Semiconductor" } ,
    { 0x1679, NULL, "Tokyo Electron Device Ltd." } ,
    { 0x168A, "USA", "Utimaco Safeware AG" } ,
    { 0x16AE, "SFNT", "SafeNet Inc." } ,
    { 0x1755, "Alchemy", "Alchemy Semiconductor Inc." } ,
    { 0x1813, NULL, "Modem Silicon Operation" } ,
    { 0X1898, "DICIT", "DIC INFORMATION TECHNOLOGY ,LTD" } ,
    { 0x1A08, "Sierra", "Sierra Semiconductor" } ,
    { 0x1B13, NULL, "Jaton Corporation" } ,
    { 0x1C1C, "Symphony", "Symphony" } ,
    { 0x1D44, "DPT", "Distributed Processing Technology" } ,
    { 0x1DE1, "Tekram", "Tekram" } ,
    { 0x1DE2, "A/DHOC", "A/DHOC Systmes" } ,
    { 0x1DEA, "LST", "Lasentec" } ,
    { 0x2001, NULL, "Temporal Research Ltd" } ,
    { 0x2002, "AT", "Automation Technology GmbH" } ,
    { 0x2014, "NONTECH", "NONTECH Nonnenmacher GmbH" } ,
    { 0x2348, "Racore", "Racore" } ,
    { 0x2646, NULL, "Kingston Technology Co." } ,
    { 0x270F, "ChainTech", "ChainTech Computer Co. Ltd." } ,
    { 0x2EC1, NULL, "Zenic Inc" } ,
    { 0x3000, "Hansol", "Hansol Electronics Inc." } ,
    { 0x3142, "PostImpressions", "Post Impressions Systems" } ,
    { 0x3388, "Hint", "Hint Corp." } ,
    { 0x3411, NULL, "Quantum Designs (H.K.) Inc." } ,
    { 0x3513, "ARCOM", "ARCOM Control Systems Ltd." } ,
    { 0x38EF, NULL, "4links" } ,
    { 0x3D3D, "3DLabs", "3Dlabs, Inc. Ltd" } ,
    { 0x4005, "Avance", "Avance Logic Inc." } ,
    { 0x4033, "Addtron", "Addtron Technology Co., Inc." } ,
    { 0x4143, "DEC", "Digital Equipment Corp." } ,
    { 0x416C, NULL, "Aladdin Knowledge Systems" } ,
    { 0x4444, "ICompression", "ICompression Inc." } ,
    { 0x4468, "Bridgeport", "Bridgeport Machines" } ,
    { 0x4550, "TDT", "Tucker-Davis Technologies" } ,
    { 0x4594, NULL, "Cogetec Informatique Inc." } ,
    { 0x45FB, "Baldor", "Baldor Electric Company" } ,
    { 0x4680, "UMAX Comp", "UMAX Computer Corp." } ,
    { 0x4843, "Hercules", "Hercules Computer Technology" } ,
    { 0x4943, NULL, "Growth Networks" } ,
    { 0x4954, "Integral", "Integral Technologies" } ,
    { 0x4978, "Axil", "Axil Computer Inc." } ,
    { 0x4A14, "NetVin", "NetVin" } ,
    { 0x4abd, "ABI", "Applied Biosystems Division" } ,
    { 0x4B10, "Buslogic", "Buslogic Inc" } ,
    { 0x4C48, "Lung Hwa", "Lung Hwa Electronics" } ,
    { 0x4C53, NULL, "SBS-OR Industrial Computers" } ,
    { 0x4CA1, NULL, "Seanix Technology Inc" } ,
    { 0x4D51, "Mediaq", "Mediaq Inc." } ,
    { 0x4D54, NULL, "Microtechnica Co Ltd" } ,
    { 0x4DDC, "ILC", "ILC Data Device Corp." } ,
    { 0x5046, "Guillemot", "Guillemot" } ,
    { 0x5053, "TBS/Voyetra", "TBS/Voyetra Technologies" } ,
    { 0x5136, NULL, "S S Technologies" } ,
    { 0x5143, "Qualcomm", "Qualcomm Inc." } ,
    { 0x5145, "ENSONIQ", "ENSONIQ" } ,
    { 0x5301, "Alliance", "Alliance Semicondutor Corp." } ,
    { 0x5333, "S3", "S3 Incorporated" } ,
    { 0x544C, NULL, "Teralogic Inc" } ,
    { 0x5455, "TU-Berlin", "Technische Universtiaet Berlin" } ,
    { 0x5519, "Cnet", "Cnet Technoliges, Inc." } ,
    { 0x5544, "Dunord", "Dunord Technologies" } ,
    { 0x5555, "Genroco", "Genroco Inc." } ,
    { 0x5700, "Netpower", "Netpower" } ,
    { 0x6356, "UltraStor", "UltraStor" } ,
    { 0x6374, "C4T", "c't Magazin f_r Computertechnik" } ,
    { 0x6409, NULL, "Logitec Corp." } ,
    { 0x6666, "Decision", "Decision Computer International Co." } ,
    { 0x7604, "O.N.", "O.N. Electric Co. Ltd." } ,
    { 0x7747, "DaoGuo", "DaoGuo Technology Co.,Ltd" } ,
    { 0x7BDE, "MIDAC", "MIDAC Corporation" } ,
    { 0x7FED, "PowerTV", "PowerTV" } ,
    { 0x8001, "BEYERTONE", "Beyertone AG - Germany" } ,
    { 0x8008, "QUANCOM", "QUANCOM Informationssysteme GmbH" } ,
    { 0x8086, "Intel", "Intel Corporation" } ,
    { 0x8800, "Trigem", "Trigem Computer" } ,
    { 0x8866, "T-Square", "T-Square Design Inc." } ,
    { 0x8888, "Sil Magic", "Silicon Magic" } ,
    { 0x8E0E, "Computone", "Computone Corporation" } ,
    { 0x8E2E, "KTI", "KTI" } ,
    { 0x9004, "Adaptec", "Adaptec" } ,
    { 0x9005, "Adaptec", "Adaptec" } ,
    { 0x907F, "Atronics", "Atronics" } ,
    { 0x919A, NULL, "Gigapixel Corp" } ,
    { 0x9412, "Holtek", "Holtek" } ,
    { 0x9699, NULL, "Omni Media Technology Inc." } ,
    { 0x9710, "Netmos", "Netmos" } ,
    { 0x9877, "surveyors", "pan asia superitendence corp" } ,
    { 0x9902, "StarGen", "StarGen, Inc." } ,
    { 0xA0A0, "Aopen", "Aopen Inc." } ,
    { 0xA0F1, NULL, "Unisys Corporation" } ,
    { 0xA200, "NEC", "NEC Corp." } ,
    { 0xA259, NULL, "Hewlett Packard" } ,
    { 0xA25B, "Hewlett Packard", "Hewlett Packard GmbH PL24-MKT" } ,
    { 0xA304, "Sony", "Sony" } ,
    { 0xA727, NULL, "3com Corporation" } ,
    { 0xAA42, "Scitex", "Scitex Digital Video" } ,
    { 0xAC1E, NULL, "Digital Receiver Technology Inc" } ,
    { 0xAECB, NULL, "Adrienne Electronics Corporation" } ,
    { 0xB00C, "IC Book", "IC Book Labs" } ,
    { 0xB1B3, "Shiva", "Shiva Europe Ltd." } ,
    { 0xB894, NULL, "Brown & Sharpe Mfg. Co." } ,
    { 0xC001, "TSI", "TSI Telsys" } ,
    { 0xC0A9, "Micron/Crucial", "Micron/Crucial Technology" } ,
    { 0xC0DE, NULL, "Motorola" } ,
    { 0xC0FE, "Mot Engrg", "Motion Engineering Inc." } ,
    { 0xC622, NULL, "Hudson Soft Co Ltd" } ,
    { 0xCA50, "Varian", "Varian Australia Pty. Ltd." } ,
    { 0xCAFE, NULL, "Chrysalis-ITS" } ,
    { 0xCCCC, NULL, "Catapult Communications" } ,
    { 0xCDDD, "Tyzx Inc.", "Tyzx Inc." } ,
    { 0xD4D4, "DY4", "DY4 Systems Inc." } ,
    { 0xD84D, "Exsys", "Exsys" } ,
    { 0xDC93, NULL, "Dawicontrol" } ,
    { 0xDEAD, "Indigita", "Indigita Corporation" } ,
    { 0xDEAF, NULL, "Middle Digital, Inc" } ,
    { 0xE000, "Winbond", "Winbond" } ,
    { 0xE159, "Tiger Jet", "Tiger Jet Network Inc" } ,
    { 0xE4BF, NULL, "EKF Elektronik GMBH" } ,
    { 0xEA01, NULL, "Eagle Technology" } ,
    { 0xECC0, "Echo", "Echo Corporation" } ,
    { 0xEDD8, "ARK Logic", "ARK Logic, Inc" } ,
    { 0xF5F5, NULL, "F5 Networks Inc." } ,
    { 0xFA57, "FAST", "Fast Search & Transfer ASA" } ,
    { 0xFEDA, NULL, "Epigram Inc"} ,
    { 0xFFFE, "VMware", "VMware Inc."} ,
    { 0x16da, "MarekMicro", "MarekMicro GmbH"},
    { 0xFFFF, NULL, NULL}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\kextdll\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <dbgeng.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#include "extsfns.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#ifndef EXTENSION_API
#define EXTENSION_API( name )  \
HRESULT _EFN_##name
#endif // EXTENSION_API

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS2       g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

extern ULONG64  STeip;
extern ULONG64  STebp;
extern ULONG64  STesp;
extern ULONG64  EXPRLastDump;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);


//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;
extern ULONG g_TargetQual;
extern ULONG g_TargetBuild;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\uextdll\handle.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    handle.cpp

Abstract:

    !handle using the debug engine handle query interface.

--*/

#include "precomp.h"
#pragma hdrstop

char * AccessMask[] = { "Delete", "ReadControl", "WriteDac", "WriteOwner",
                        "Synch", "", "", "",
                        "Sacl", "MaxAllowed", "", "",
                        "GenericAll", "GenericExec", "GenericWrite", "GenericRead"};

char * TokenRights[] = {"AssignPrimary", "Duplicate", "Impersonate", "Query",
                        "QuerySource", "AdjustPriv", "AdjustGroup", "AdjustDef"};

char * KeyRights[] = {  "QueryValue", "SetValue", "CreateSubKey", "EnumSubKey",
                        "Notify", "CreateLink", "", "" };

char * EventRights[] = {"QueryState", "ModifyState" };

char * MutantRights[]={ "QueryState" };

char * SemaphoreRights[] = { "QueryState", "ModifyState" };

char * TimerRights[] = {"QueryState", "ModifyState" };

char * ProfileRights[]={"Control"};

char * ProcessRights[]={"Terminate", "CreateThread", "", "VMOp",
                        "VMRead", "VMWrite", "DupHandle", "CreateProcess",
                        "SetQuota", "SetInfo", "QueryInfo", "SetPort" };

char * ThreadRights[] ={"Terminate", "Suspend", "Alert", "GetContext",
                        "SetContext", "SetInfo", "QueryInfo", "SetToken",
                        "Impersonate", "DirectImpersonate" };

char * SectionRights[]={"Query", "MapWrite", "MapRead", "MapExecute",
                        "Extend"};

char * FileRights[] = { "Read/List", "Write/Add", "Append/SubDir/CreatePipe", "ReadEA",
                        "WriteEA", "Execute/Traverse", "DelChild", "ReadAttr",
                        "WriteAttr"};

char * PortRights[] = { "Connect" };

char * DirRights[]  = { "Query", "Traverse", "Create", "CreateSubdir" };

char * SymLinkRights[]={"Query" };

char * WinstaRights[]={ "EnumDesktops", "ReadAttr", "Clipboard", "CreateDesktop",
                        "WriteAttr", "GlobalAtom", "ExitWindows", "",
                        "Enumerate", "ReadScreen" };

char * DesktopRights[]={"ReadObjects", "CreateWindow", "CreateMenu", "HookControl",
                        "JournalRecord", "JournalPlayback", "Enumerate", "WriteObjects",
                        "SwitchDesktop" };

char * CompletionRights[] = { "Query", "Modify" };

char * ChannelRights[] = { "ReadMessage", "WriteMessage", "Query", "SetInfo" };

char * JobRights[] = { "AssignProcess", "SetAttr", "Query", "Terminate", "SetSecAttr" };

char * DebugObjectRights[] = { "ReadEvent", "ProcessAssign",
                               "SetInformation", "QueryInformation" };

char * KeyedEventRights[] = { "Wait", "Wake" };

#define GHI_TYPE        0x00000001
#define GHI_BASIC       0x00000002
#define GHI_NAME        0x00000004
#define GHI_SPECIFIC    0x00000008
#define GHI_VERBOSE     0x00000010
#define GHI_NOLOOKUP    0x00000020
#define GHI_SILENT      0x00000100

#define TYPE_NONE       0
#define TYPE_EVENT      1
#define TYPE_SECTION    2
#define TYPE_FILE       3
#define TYPE_PORT       4
#define TYPE_DIRECTORY  5
#define TYPE_LINK       6
#define TYPE_MUTANT     7
#define TYPE_WINSTA     8
#define TYPE_SEM        9
#define TYPE_KEY        10
#define TYPE_TOKEN      11
#define TYPE_PROCESS    12
#define TYPE_THREAD     13
#define TYPE_DESKTOP    14
#define TYPE_COMPLETE   15
#define TYPE_CHANNEL    16
#define TYPE_TIMER      17
#define TYPE_JOB        18
#define TYPE_WPORT      19
#define TYPE_DEBUG_OBJECT 20
#define TYPE_KEYED_EVENT  21
#define TYPE_MAX          22

typedef struct _TYPEINFO
{
    PSTR        Name;
    char * *    AccessRights;
    DWORD       NumberRights;
} TYPEINFO, * PTYPEINFO;

TYPEINFO g_TypeNames[TYPE_MAX] =
{
    { "None", NULL, 0 },
    { "Event", EventRights, 2 },
    { "Section", SectionRights, 5 },
    { "File", FileRights, 9 },
    { "Port", PortRights, 1 },
    { "Directory", DirRights, 4 },
    { "SymbolicLink", SymLinkRights, 1 },
    { "Mutant", MutantRights, 2 },
    { "WindowStation", WinstaRights, 10 },
    { "Semaphore", SemaphoreRights, 2 },
    { "Key", KeyRights, 6 },
    { "Token", TokenRights, 8 },
    { "Process", ProcessRights, 12 },
    { "Thread", ThreadRights, 10 },
    { "Desktop", DesktopRights, 10 },
    { "IoCompletion", CompletionRights, 2 },
    { "Channel", ChannelRights, 4},
    { "Timer", TimerRights, 2 },
    { "Job", JobRights, 5 },
    { "WaitablePort", PortRights, 1 },
    { "DebugObject", DebugObjectRights, 4 },
    { "KeyedEvent", KeyedEventRights, 2 }
};

void DisplayFlags(  DWORD       Flags,
                    DWORD       FlagLimit,
                    char        *flagset[],
                    PSTR        Buffer)
{
    char *         offset;
    DWORD          mask, test, i;
    DWORD          scratch;

    if (!Flags)
    {
        strcpy(Buffer, "None");
        return;
    }

    mask = 0;
    offset = Buffer;
    test = 1;
    for (i = 0 ; i < FlagLimit ; i++ )
    {
        if (Flags & test)
        {
            scratch = strlen(flagset[i]);
            memcpy(offset, flagset[i], scratch + 1);
            offset += scratch;
            mask |= test;
            if (Flags & (~mask))
            {
                *offset++ = ',';
            }
        }
        test <<= 1;
    }
}

DWORD
GetObjectTypeIndex(
    LPCSTR TypeName
    )
{
    DWORD   i;

    for ( i = 1 ; i < TYPE_MAX ; i++ )
    {
        if (_stricmp( g_TypeNames[i].Name, TypeName ) == 0 )
        {
            return( i );
        }
    }

    return( (DWORD) -1 );
}

DWORD
GetHandleInfo(
    ULONG64 hThere,
    DWORD   Flags,
    DWORD * Type)
{
    HRESULT Status;
    DWORD   SuccessCount = 0;
    DWORD   i;
    CHAR    Buffer[1024];
    CHAR    szBuf[256];

    if ( (Flags & GHI_SILENT) == 0)
    {
        dprintf("Handle %p\n", hThere );
    }

    *Type = 0;

    if (Flags & (GHI_TYPE | GHI_NAME))
    {
        if (g_ExtData->
            ReadHandleData(hThere,
                           DEBUG_HANDLE_DATA_TYPE_TYPE_NAME,
                           Buffer, sizeof(Buffer), NULL) == S_OK)
        {
            // We were able to get a type, so count this
            // as success even if we can't identify the type name.
            if (Flags & GHI_TYPE)
            {
                SuccessCount++;
            }

            for (i = 1; i < TYPE_MAX ; i++)
            {
                if (strcmp(Buffer, g_TypeNames[i].Name) == 0)
                {
                    *Type = i;
                    break;
                }
            }
        }
        else
        {
            strcpy(Buffer, "<Error retrieving type>");
        }

        if (Flags & GHI_TYPE)
        {
            if ((Flags & GHI_SILENT) == 0)
            {
                dprintf("  Type         \t%s\n", Buffer);
            }
        }
    }

    if (Flags & GHI_BASIC)
    {
        DEBUG_HANDLE_DATA_BASIC Basic;

        if (g_ExtData->
            ReadHandleData(hThere,
                           DEBUG_HANDLE_DATA_TYPE_BASIC,
                           &Basic, sizeof(Basic), NULL) == S_OK)
        {
            dprintf("  Attributes   \t%#x\n", Basic.Attributes );
            dprintf("  GrantedAccess\t%#x:\n", Basic.GrantedAccess );
            DisplayFlags( Basic.GrantedAccess >> 16,
                          16,
                          AccessMask,
                          szBuf);
            dprintf("         %s\n", szBuf);
            DisplayFlags( Basic.GrantedAccess & 0xFFFF,
                          g_TypeNames[ *Type ].NumberRights,
                          g_TypeNames[ *Type ].AccessRights,
                          szBuf);
            dprintf("         %s\n", szBuf);
            dprintf("  HandleCount  \t%d\n", Basic.HandleCount );
            dprintf("  PointerCount \t%d\n", Basic.PointerCount );
            SuccessCount++;
        }
        else
        {
            dprintf("unable to query object information\n");
        }
    }

    if ((Flags & GHI_NAME) &&
        *Type != TYPE_FILE)
    {
        if (g_ExtData->
            ReadHandleData(hThere,
                           DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME,
                           Buffer, sizeof(Buffer), NULL) == S_OK)
        {
            dprintf("  Name         \t%s\n",
                    Buffer[0] ? Buffer : "<none>" );
            SuccessCount++;
        }
        else
        {
            dprintf("unable to query object information\n");
        }
    }

    if ( Flags & GHI_SPECIFIC )
    {
        dprintf("  No object specific information available\n");
    }

    return( SuccessCount );
}

/*++

Routine Description:

    This function is called as an NTSD extension to mimic the !handle
    kd command.  This will walk through the debuggee's handle table
    and duplicate the handle into the ntsd process, then call NtQueryobjectInfo
    to find out what it is.

    Called as:

        !handle [handle [flags [Type]]]

    If the handle is 0 or -1, all handles are scanned.  If the handle is not
    zero, that particular handle is examined.  The flags are as follows
    (corresponding to secexts.c):
        1   - Get type information (default)
        2   - Get basic information
        4   - Get name information
        8   - Get object specific info (where available)

    If Type is specified, only object of that type are scanned.  Type is a
    standard NT type name, e.g. Event, Semaphore, etc.  Case sensitive, of
    course.

    Examples:

        !handle     -- dumps the types of all the handles, and a summary table
        !handle 0 0 -- dumps a summary table of all the open handles
        !handle 0 f -- dumps everything we can find about a handle.
        !handle 0 f Event
                    -- dumps everything we can find about open events

--*/
DECLARE_API( handle )
{
    ULONG64 hThere;
    DWORD   Type;
    DWORD   Mask;
    DWORD   HandleCount;
    DWORD   Total;
    DWORD   TypeCounts[TYPE_MAX];
    DWORD   Handle;
    DWORD   Hits;
    DWORD   Matches;
    DWORD   ObjectType;
    ULONG   SessionType;
    ULONG   SessionQual;

    INIT_API();

    //
    // This particular implementation is only used for
    // dump debug sessions as more information can be
    // retrieved on live sessions via the NtQuery APIs.
    // If this isn't a dump session let the !handle
    // search continue on.
    //

    if (g_ExtControl == NULL ||
        g_ExtControl->
        GetDebuggeeType(&SessionType, &SessionQual) != S_OK)
    {
        SessionType = DEBUG_CLASS_USER_WINDOWS;
        SessionQual = DEBUG_USER_WINDOWS_PROCESS;
    }
    if (SessionType == DEBUG_CLASS_USER_WINDOWS &&
        SessionQual == DEBUG_USER_WINDOWS_PROCESS)
    {
        ExtRelease();
        return DEBUG_EXTENSION_CONTINUE_SEARCH;
    }

    Mask = GHI_TYPE;
    hThere = (ULONG64)(LONG_PTR)INVALID_HANDLE_VALUE;
    Type = 0;

    while (*args == ' ')
    {
        args++;
    }

    if ( strcmp( args, "-?" ) == 0 )
    {
        ExtRelease();
        return DEBUG_EXTENSION_CONTINUE_SEARCH;
    }

    hThere = GetExpression( args );

    while (*args && (*args != ' ') )
    {
        args++;
    }
    while (*args == ' ')
    {
        args++;
    }

    if (*args)
    {
        Mask = (DWORD)GetExpression( args );
    }

    while (*args && (*args != ' ') )
    {
        args++;
    }
    while (*args == ' ')
    {
        args++;
    }

    if (*args)
    {
        Type = GetObjectTypeIndex( (LPSTR)args );
        if (Type == (DWORD) -1)
        {
            dprintf("Unknown type '%s'\n", args );
            goto Exit;
        }
    }

    //
    // if they specified 0, they just want the summary.  Make sure nothing
    // sneaks out.
    //

    if ( Mask == 0 )
    {
        Mask = GHI_SILENT;
    }

    if (g_ExtData->
        ReadHandleData(0, DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT,
                       &HandleCount, sizeof(HandleCount),
                       NULL) != S_OK) {
        dprintf("Unable to read handle information\n");
        goto Exit;
    }

    //
    // hThere of 0 indicates all handles.
    //
    if ((hThere == 0) || (hThere == (ULONG64)(LONG_PTR)INVALID_HANDLE_VALUE))
    {
        Hits = 0;
        Handle = 0;
        Matches = 0;
        ZeroMemory( TypeCounts, sizeof(TypeCounts) );

        while ( Hits < HandleCount )
        {
            if (CheckControlC())
            {
                break;
            }
            if ( Type )
            {
                if (GetHandleInfo( Handle,
                                   GHI_TYPE | GHI_SILENT,
                                   &ObjectType ) )
                {
                    Hits++;
                    if ( ObjectType == Type )
                    {
                        GetHandleInfo( Handle,
                                       Mask,
                                       &ObjectType );
                        Matches ++;
                    }
                }
            }
            else
            {
                if (GetHandleInfo( Handle,
                                   GHI_TYPE | GHI_SILENT,
                                   &ObjectType) )
                {
                    Hits++;
                    TypeCounts[ ObjectType ] ++;

                    GetHandleInfo( Handle,
                                   Mask,
                                   &ObjectType );
                }
            }

            Handle += 4;
        }

        if ( Type == 0 )
        {
            dprintf( "%d Handles\n", Hits );
            dprintf( "Type           \tCount\n");
            for (Type = 0; Type < TYPE_MAX ; Type++ )
            {
                if (TypeCounts[Type])
                {
                    dprintf("%-15s\t%d\n",
                            g_TypeNames[Type].Name, TypeCounts[Type]);
                }
            }
        }
        else
        {
            dprintf("%d handles of type %s\n",
                    Matches, g_TypeNames[Type].Name );
        }
    }
    else
    {
        GetHandleInfo( hThere, Mask, &Type );
    }

 Exit:
    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\uextdll\evlog.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    evlog.cpp

Abstract:

    !evlog using the debug engine evlog query interface

Environment:

    User Mode

--*/

//
// TODO: Feature to see exact formatted desc string for specific event id
// TODO: Feature to see correct loaded category name for specific event id
// TODO: Feature to list cat and desc strings for given msg dll(?)
//

#include "precomp.h"
#pragma hdrstop

#include <cmnutil.hpp>

#include "messages.h"

//
//  Global display constants
//

const CHAR *g_pcszEventType[] = {
    "None",               // 0
    "Error",              // 1
    "Warning",            // 2
    "",
    "Information",        // 4
    "",
    "",
    "",
    "Success Audit",      // 8
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Failure Audit",      // 16
};

const CHAR *g_pcszAppEventCategory[] = {
    "None",               // 0
    "Devices",            // 1
    "Disk",               // 2
    "Printers",           // 3
    "Services",           // 4
    "Shell",              // 5
    "System Event",       // 6
    "Network",            // 7
};

//
// TODO: Really we should load the CategoryMessageFile from the registry
// but that requires lots of calls to RegOpenKeyEx, RegQueryValueEx,
// LoadLibrary and FormatMessage.  So we just create a known static
// list that works for most cases.
//

const CHAR *g_pcszSecEventCategory[] = {
    "None",                     // 0
    "System Event",             // 1
    "Logon/Logoff",             // 2
    "Object Access",            // 3
    "Privilege Use",            // 4
    "Detailed Tracking",        // 5
    "Policy Change",            // 6
    "Account Management",       // 7
    "Directory Service Access", // 8
    "Account Logon",            // 9
};

//
//  Display text for read direction
//

const CHAR g_cszBackwardsRead[] = "Backwards";
const CHAR g_cszForwardsRead[] = "Forwards";
const CHAR g_cszUnknownRead[] = "<unknown>";

//
//  Global Variables and Constants:
//
//  g_cdwDefaultMaxRecords:  
//  arbitrary to prevent too much output, ctrl+c will interrupt display
//
//  g_cdwDefaultReadFlags:
//  starts from beginning (FORWARDS) or end (BACKWARDS) of event log
//
//  g_cwMaxDataDisplayWidth:
//  allows for 32 columns of 8 byte chunks
//
//  g_cwDefaultDataDisplayWidth
//  same as event log display. Can never be < 1 or > g_cdwMaxDataDisplayWidth  
//

const DWORD BACKWARDS_READ = EVENTLOG_BACKWARDS_READ;
const DWORD FORWARDS_READ =  EVENTLOG_FORWARDS_READ;
const DWORD g_cdwDefaultMaxRecords = 20;
const DWORD g_cdwDefaultRecordOffset = 0;
const DWORD g_cdwDefaultReadFlags = BACKWARDS_READ;
const WORD  g_cwMaxDataDisplayWidth = 256;
const BYTE  g_cwDefaultDataDisplayWidth = 8;

//
//  Global static vars
//
//  These are used to persist settings for !evlog option command
//

static DWORD g_dwMaxRecords = g_cdwDefaultMaxRecords;
static DWORD g_dwRecordOffsetAppEvt = g_cdwDefaultRecordOffset;
static DWORD g_dwRecordOffsetSecEvt = g_cdwDefaultRecordOffset;
static DWORD g_dwRecordOffsetSysEvt = g_cdwDefaultRecordOffset;
static DWORD g_dwReadFlags = g_cdwDefaultReadFlags;
static WORD g_wDataDisplayWidth = g_cwDefaultDataDisplayWidth;

//
//  Macros
//

#define SKIP_WSPACE(s)  while (*s && (*s == ' ' || *s == '\t')) {++s;}


//----------------------------------------------------------------------------
//
// Generic support/utility functions
//
//----------------------------------------------------------------------------


HRESULT
GetEvLogNewestRecord ( const CHAR *szEventLog , OUT DWORD *pdwNewestRecord)
/*++

Routine Description:

    This function is used to retrieve the most recent event record number 
    logged to the specified event log.

Arguments:

    szEventLog      - Supplies name of event log (Application, System,
                        Security)
    pdwNewestRecord - Supplies buffer for record number
    
Return Value:

    E_POINTER if either argument is NULL
    E_UNEXPECTED if Status is (mistakenly) not set during code execution
    GetLastError() converted to HRESULT otherwise

--*/
{
    HANDLE hEventLog = NULL;
    DWORD dwRecords = 0;
    DWORD dwOldestRecord = 0xFFFFFFFF;
    HRESULT Status = E_UNEXPECTED;

    if ((NULL == szEventLog) || (NULL == pdwNewestRecord))
    {
        Status = E_POINTER;
        ExtErr("Internal error: null event log string or null oldest record "
               "pointer\n");
        goto Exit;
    }

    // Open the event log.
    hEventLog = OpenEventLog(
                    NULL,         // uses local computer
                    szEventLog); // source name
    if (NULL == hEventLog)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to open '%s' event log, 0x%08X\n", szEventLog, Status);
        goto Exit;
    }

    // Get the number of records in the event log.
    if (!GetNumberOfEventLogRecords(
            hEventLog,  // handle to event log
            &dwRecords)) // buffer for number of records
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to count '%s' event log records, 0x%08X\n",
               szEventLog, Status);
        goto Exit;
    }
    
    if (!GetOldestEventLogRecord(
            hEventLog,          // handle to event log
            &dwOldestRecord)) // buffer for number of records
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to get oldest '%s' event log record, 0x%08X\n",
               szEventLog, Status);
        goto Exit;
    }

    //
    // If there are zero events we should have failed above
    // when trying to get the oldest event log record because
    // it does not exist.
    //
    // If there is at least one, the math should work.
    //
    // The logging should result in sequential numbers for
    // the events, however, the first event will not always
    // start at #1
    //

    *pdwNewestRecord = dwOldestRecord + dwRecords - 1;
    
    Status = S_OK;

Exit:
    if (hEventLog)
    {
        CloseEventLog(hEventLog);
    }
    return Status;
}


void
PrintEvLogTimeGenerated( EVENTLOGRECORD *pevlr )
/*++

Routine Description:

    This function is used to display two lines with the local date and time
    info from an EVENTLOGRECORD structure.

Arguments:

    pevlr       - Supplies the pointer to any EVENTLOGRECORD structure

Return Value:

    None

--*/
{
    FILETIME FileTime, LocalFileTime;
    SYSTEMTIME SysTime;
    __int64 lgTemp;
    __int64 SecsTo1970 = 116444736000000000;

    if (NULL == pevlr)
        goto Exit;

    lgTemp = Int32x32To64(pevlr->TimeGenerated,10000000) + SecsTo1970;

    FileTime.dwLowDateTime = (DWORD) lgTemp;
    FileTime.dwHighDateTime = (DWORD)(lgTemp >> 32);

    // TODO: Could use GetTimeFormat to be more consistent w/Event Log
    //         cch = GetTimeFormat(LOCALE_USER_DEFAULT,
    //                   0,
    //                   &stGenerated,
    //                   NULL,
    //                   wszBuf,
    //                   cchBuf);
    FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &SysTime);

    ExtOut("Date:\t\t%02d/%02d/%04d\n",
              SysTime.wMonth,
              SysTime.wDay,
              SysTime.wYear);
    ExtOut("Time:\t\t%02d:%02d:%02d\n",
              SysTime.wHour,
              SysTime.wMinute,
              SysTime.wSecond);
    
Exit:
        return;
}


void
PrintEvLogData( EVENTLOGRECORD *pevlr )
/*++

Routine Description:

    This function is used to display an event record's data section.  If there
    is no data to display, nothing is displayed, not even the "Data:" header.

    Example:
    ========
    Data: (40432 bytes)
    0000: 0d 00 0a 00 0d 00 0a 00   ........
    0008: 41 00 70 00 70 00 6c 00   A.p.p.l.
    
Arguments:

    pevlr       - Supplies the pointer to any EVENTLOGRECORD structure
    
Return Value:

    None

--*/
{
    PBYTE pbData = NULL;
    DWORD dwDataLen = pevlr->DataLength;
    DWORD dwCurPos = 0;
    // 0000: 0d 00 0a 00 0d 00 0a 00   ........
    // 4 + 4 bytes for leading offset 0000: (+4 more in case bounds exceeded)
    // 2 bytes for ": " separator
    // 3 * g_cdwMaxDataDisplayWidth bytes for hex display
    // 2 bytes for "  " separator
    // g_cdwMaxDataDisplayWidth bytes for trailing ASCII display
    // 1 byte for trailing newline
    // 1 byte for terminating nul '\0'
    // = 1042 bytes required, round up to 1280 to be safe
    const cDataOutputDisplayWidth =
        4+4+4+2+3*g_cwMaxDataDisplayWidth+2+g_cwMaxDataDisplayWidth+1+1;
    CHAR szDataDisplay[cDataOutputDisplayWidth];
    CHAR szTempBuffer[MAX_PATH+1];

        if (NULL == pevlr)
            goto Exit;

    ZeroMemory(szDataDisplay, sizeof(szDataDisplay));
    
    // Only display Data section if data is present
    if (0 != dwDataLen)
    {
        ExtOut("Data: (%u bytes [=0x%04X])\n", dwDataLen, dwDataLen);

        if (dwDataLen >= g_wDataDisplayWidth)
        {
            do
            {
                unsigned int i = 0;
               
                pbData = (PBYTE)pevlr + pevlr->DataOffset + dwCurPos;

                //ExtOut("%04x: "
                //       "%02x %02x %02x %02x %02x %02x %02x %02x   ",
                //       dwCurPos,
                //       pbData[0], pbData[1], pbData[2], pbData[3],
                //       pbData[4], pbData[5], pbData[6], pbData[7]);

                // Print offset for this line of data
                PrintString(szDataDisplay,
                            sizeof(szDataDisplay),
                            "%04x: ",
                            dwCurPos);

                // Fill in hex values for next g_wDataDisplayWidth bytes
                for (i = 0; i < g_wDataDisplayWidth; i++)
                {
                    PrintString(szTempBuffer,
                                sizeof(szTempBuffer),
                                "%02x ",
                                pbData[i]);
                    CatString(szDataDisplay,
                              szTempBuffer,
                              sizeof(szDataDisplay));
                }

                // Pad with two extra spaces
                CatString(szDataDisplay, "  ", sizeof(szDataDisplay));
                
                for (i = 0; i < g_wDataDisplayWidth; i++)
                {
                    if (isprint(pbData[i]))
                    {
                        PrintString(szTempBuffer,
                                    sizeof(szTempBuffer),
                                    "%c",
                                    pbData[i]);
                    }
                    else
                    {
                        PrintString(szTempBuffer, sizeof(szTempBuffer), ".");
                    }

                    CatString(szDataDisplay,
                              szTempBuffer,
                              sizeof(szDataDisplay));
                }
    
                CatString(szDataDisplay, "\n", sizeof(szDataDisplay));

                ExtOut(szDataDisplay);
                
                if (CheckControlC())
                {
                    ExtOut("Terminated w/ctrl-C...\n");
                    goto Exit;
                }
            
                // Display data 8 bytes at a time like event log
                // unless overridden by !evlog option setting
                dwCurPos += sizeof(BYTE) * g_wDataDisplayWidth;

            } while (dwCurPos < (dwDataLen - g_wDataDisplayWidth));
        }

        // Sometimes there will be fewer than 8 bytes on last line
        if (dwCurPos < dwDataLen)
        {
            pbData = (PBYTE)pevlr + pevlr->DataOffset + dwCurPos;
            
            ExtOut("%04x: ", dwCurPos);

            for (unsigned int i = 0; i < (dwDataLen - dwCurPos); i++)
            {
                ExtOut("%02x ", pbData[i]);
            }

            for (i = 0; i < g_wDataDisplayWidth - (dwDataLen - dwCurPos); i++)
            {
                ExtOut("   ");
            }
            ExtOut("  ");

            for (i = 0; i < (dwDataLen - dwCurPos); i++)
            {
                if (isprint(pbData[i]))
                    ExtOut("%c", pbData[i]);
                else
                    ExtOut(".");
            }
            ExtOut("\n");
        }
    }
    
Exit:
    return;
}


void
PrintEvLogDescription( EVENTLOGRECORD *pevlr )
/*++

Routine Description:

    This function is used to display an event record's description insertion
    strings (%1, %2, etc).

    Currently it does not look up the message string from the event message
    file.
    
Arguments:

    pevlr       - Supplies the pointer to any EVENTLOGRECORD structure
    
Return Value:

    None

--*/
{
    DWORD dwOffset = 0;
    CHAR *pString = NULL;

    if (NULL == pevlr)
        goto Exit;
    
    ExtOut("Description: (%u strings)\n", pevlr->NumStrings);

    for (int i = 0; i < pevlr->NumStrings; i++)
    {
        // TODO: Should break this up into chunks in case it is really long
        //       and add Ctrl+C handling
        pString = (CHAR *)(BYTE *)pevlr + pevlr->StringOffset + dwOffset;
        ExtOut("%s\n", pString);
        dwOffset += strlen(pString) + 1;
    }

Exit:
    return;
}


void
PrintEvLogEvent( const CHAR *szEventLog, EVENTLOGRECORD *pevlr )
/*++

Routine Description:

    This function is used to display an event record.  The format used for
    display attempts to duplicate the format you see when you use the "copy
    to clipboard" button while viewing an event in eventvwr.

    Example:
    ========
    -------------- 01 --------------
    Record #: 7923

    Event Type:     Error (1)
    Event Source:   Userenv
    Event Category: None (0)
    Event ID:       1030 (0xC0000406)
    Date:           01/06/2002
    Time:           18:13:05
    Description: (0 strings)

Arguments:

    pevlr       - Supplies the pointer to any EVENTLOGRECORD structure
    
Return Value:

    None

--*/
{
    const CHAR *cszCategory;
    const CHAR cszDefaultCategory[] = "None";
    
    if (NULL == pevlr)
        goto Exit;

    if (!_stricmp(szEventLog, "System"))
    {
        cszCategory = cszDefaultCategory;
    }
    else if (!_stricmp(szEventLog, "Security"))
    {
        if (pevlr->EventCategory <= 9)
        {
            cszCategory = g_pcszSecEventCategory[pevlr->EventCategory];
        }
        else
        {
            cszCategory = "";
        }
    }
    else // Application
    {
        if (pevlr->EventCategory <= 7)
        {
            cszCategory = g_pcszAppEventCategory[pevlr->EventCategory];
        }
        else
        {
            cszCategory = "";
        }
    }
    
    // Output format similar to copy to clipboard format in event viewer
    ExtOut("Record #: %u\n\n", pevlr->RecordNumber);
    ExtOut("Event Type:\t%s (%u)\n",
              (pevlr->EventType <= 16)
                  ? g_pcszEventType[pevlr->EventType]
                  : "None",
              pevlr->EventType);
    ExtOut("Event Source:\t%s\n",
              (CHAR *)(BYTE *)pevlr + sizeof(EVENTLOGRECORD));
    ExtOut("Event Category:\t%s (%u)\n",
              cszCategory,
              pevlr->EventCategory);
    if (pevlr->EventID > 0xFFFF)
        ExtOut("Event ID:\t%u (0x%08X)\n",
                  0xFFFF & pevlr->EventID,
                  pevlr->EventID);
    else
        ExtOut("Event ID:\t%u\n",
                  pevlr->EventID);
    PrintEvLogTimeGenerated(pevlr);
    PrintEvLogDescription(pevlr);
    PrintEvLogData(pevlr);
    
Exit:
    return;
}


HRESULT
PrintEvLogSummary ( const CHAR *szEventLog )
/*++

Routine Description:

    This function is used to display summary information about a specific
    event log.

    Example:
    ========
    --------------------------------
    Application Event Log:
      # Records       : 7923
      Oldest Record # : 1
      Newest Record # : 7923
      Event Log Full  : false
    --------------------------------
    System Event Log:
      # Records       : 5046
      Oldest Record # : 1
      Newest Record # : 5046
      Event Log Full  : false
    --------------------------------
    Security Event Log:
      # Records       : 24256
      Oldest Record # : 15164
      Newest Record # : 39419
      Event Log Full  : false
    --------------------------------
    
Arguments:

    szEventLog      - Supplies name of event log (Application, System,
                        Security)
    
Return Value:

    None

--*/
{
    HANDLE hEventLog = NULL;
    DWORD dwRecords = 0;
    DWORD dwOldestRecord = 0xFFFFFFFF;
    HRESULT Status = E_FAIL;

    if (NULL == szEventLog)
    {
        ExtErr("Internal error: null event log string\n");
        return E_INVALIDARG;
    }

    ExtOut("--------------------------------\n");
    // Open the event log.
    hEventLog = OpenEventLog(
                    NULL,         // uses local computer
                    szEventLog); // source name

    if (NULL == hEventLog)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to open '%s' event log, 0x%08X\n", szEventLog, Status);
        return Status;
    }

    // Get the number of records in the event log.
    if (!GetNumberOfEventLogRecords(
            hEventLog,  // handle to event log
            &dwRecords)) // buffer for number of records
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to count '%s' event log records, 0x%08X\n",
               szEventLog, Status);
        goto Exit;
    }

    ExtOut("%s Event Log:\n  # Records       : %u\n", szEventLog, dwRecords); 

    if (!GetOldestEventLogRecord(
            hEventLog,        // handle to event log
            &dwOldestRecord)) // buffer for number of records
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to get oldest '%s' event log record, 0x%08X\n",
               szEventLog, Status);
        goto Exit;
    }

    ExtOut("  Oldest Record # : %u\n", dwOldestRecord);
    ExtOut("  Newest Record # : %u\n", dwOldestRecord + dwRecords - 1);
    
    DWORD dwBytesNeeded = 0;
    DWORD dwBufSize = 0;
    EVENTLOG_FULL_INFORMATION *pevfi;

    // Only try this once - we could retry if dwBufSize too small
    dwBufSize = sizeof(EVENTLOG_FULL_INFORMATION);
    pevfi = (EVENTLOG_FULL_INFORMATION *)calloc(1, dwBufSize);
    if (!pevfi)
    {
        Status = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        ExtErr("Unable to allocate buffer, 0x%08X\n", Status);
    }
    else
    {
        if ((S_OK == (Status = InitDynamicCalls(&g_Advapi32CallsDesc))) &&
            g_Advapi32Calls.GetEventLogInformation)
        {
            if (!g_Advapi32Calls.GetEventLogInformation(
                       hEventLog,          // handle to event log
                       EVENTLOG_FULL_INFO, // information to retrieve
                       pevfi,              // buffer for read data
                       dwBufSize,          // size of buffer in bytes
                       &dwBytesNeeded))    // number of bytes needed
            {
                Status = HRESULT_FROM_WIN32(GetLastError());
                ExtErr("Unable to get full status from '%s', 0x%08X\n",
                       szEventLog, Status);
            }
            else
            {
                ExtOut("  Event Log Full  : %s\n",
                          (pevfi->dwFull) ? "true"
                                          : "false");
                Status = S_OK;
            }
        }

        free(pevfi);
    }

Exit:

    CloseEventLog(hEventLog);

    return Status;
}


void
PrintEvLogOptionSettings ( void )
/*++

Routine Description:

    This function is used to display the option settings used by the !evlog
    extension for various defaults.

    Currently all cached option settings are used by the read command only.

    Example:
    ========
    Default EvLog Option Settings:
    --------------------------------
    Max Records Returned: 20
    Search Order:         Backwards
    Data Display Width:   8
    --------------------------------
    Bounding Record Numbers:
      Application Event Log: 0
      System Event Log:      0
      Security Event Log:    0
    --------------------------------

Arguments:

    None
    
Return Value:

    None

--*/
{
    CHAR szSearchOrder[MAX_PATH];

    if (FORWARDS_READ == g_dwReadFlags)
    {
        CopyString(szSearchOrder, g_cszForwardsRead, sizeof(szSearchOrder));
    }
    else if (BACKWARDS_READ == g_dwReadFlags)
    {
        CopyString(szSearchOrder, g_cszBackwardsRead, sizeof(szSearchOrder));
    }
    else
    {
        PrintString(szSearchOrder,
                    sizeof(szSearchOrder),
                    "Unknown (%08X)",
                    g_dwReadFlags);
    }

    ExtOut("Default EvLog Option Settings:\n");
    ExtOut("--------------------------------\n");
    ExtOut("Max Records Returned: %u\n", g_dwMaxRecords);
    ExtOut("Search Order:         %s\n", szSearchOrder);
    ExtOut("Data Display Width:   %u\n", g_wDataDisplayWidth);
    ExtOut("--------------------------------\n");
    ExtOut("Bounding Record Numbers:\n");
    ExtOut("  Application Event Log: %u\n", g_dwRecordOffsetAppEvt);
    ExtOut("  System Event Log:      %u\n", g_dwRecordOffsetSysEvt);
    ExtOut("  Security Event Log:    %u\n", g_dwRecordOffsetSecEvt);
    ExtOut("--------------------------------\n");
}


//----------------------------------------------------------------------------
//
// Debugger extension(s) options implementation
//
//----------------------------------------------------------------------------


HRESULT
EvLogAddSource ( PDEBUG_CLIENT Client, PCSTR args )
/*++

Routine Description:

    This function handles parsing and execution for the addsource command to
    the !evlog extension.  It is used to add an event source to the registry
    so the events logged by that source display their description correctly
    instead of displaying the error message:

    Example: (of bad event source)
    ========
    Description:
    The description for Event ID ( 2 ) in Source ( DebuggerExtensions ) 
    cannot be found. The local computer may not have the necessary registry
    information or message DLL files to display messages from a remote
    computer. You may be able to use the /AUXSOURCE= flag to retrieve this
    description; see Help and Support for details. The following information
    is part of the event: Test Message with Event ID 2.

    Example: (of good event source registered correctly)
    ========
    Description:
    Test Message with Event ID 4000For more information, see Help and Support
    Center at http://go.microsoft.com/fwlink/events.asp.

Arguments:

    Client  - Pointer to IDebugClient passed to !evlog extension
                [not used by this command]
    args    - Pointer to command line arguments passed to this command from
                !evlog extension
    
Return Value:

    E_INVALIDARG if invalid argument syntax detected
    ERROR_BUFFER_OVERFLOW if argument length too long
    GetLastError() converted to HRESULT otherwise

--*/
{
    HKEY hk = NULL;
    HMODULE hModule = NULL;
    DWORD dwTypesSupported = 0;
    DWORD dwDisposition = 0;
    DWORD lResult = ERROR_SUCCESS;
    const DWORD cdwDefaultTypesSupported = 
                    EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE |
                    EVENTLOG_INFORMATION_TYPE |
                    EVENTLOG_AUDIT_SUCCESS | EVENTLOG_AUDIT_FAILURE;
    CHAR szParamValue[MAX_PATH];
    CHAR szSource[MAX_PATH+1];
    CHAR szMessageFile[MAX_PATH+1];
    CHAR szRegPath[MAX_PATH+1];
    const CHAR cszUsage[] = "Usage:\n"
        "  !evlog addsource [-d] [-s <source>] [-t <types>] [-f <msgfile>]"
          "\n\n"
        "Adds an event source to the registry. By default, only adds "
          "DebuggerExtensions\n"
        "event source to support !evlog report.\n\n"
        "Use !dreg to see the values added.\n\n"
        "Example:\n"
        "  !dreg hklm\\system\\currentcontrolset\\services\\eventlog\\"
          "Application\\<source>!*\n\n"
        "Optional parameters:\n"
        "-d         : Use defaults\n"
        "<source>   : (default: DebuggerExtensions)\n"
        "<types>    : All (default: 31), Success, Error (1), Warning (2),\n"
        "             Information (4), Audit_Success (8), or Audit_Failure "
          "(16)\n"
        "<msgfile>  : (default: local path to ext.dll)\n";
    const CHAR cszDefaultSource[] = "DebuggerExtensions";
    const CHAR cszDefaultExtensionDll[] = "uext.dll";
    
    INIT_API();

    ZeroMemory(szParamValue, sizeof(szParamValue));
    CopyString(szSource, cszDefaultSource, sizeof(szSource));
    dwTypesSupported = cdwDefaultTypesSupported;
    
    hModule = GetModuleHandle(cszDefaultExtensionDll);
    GetModuleFileName(hModule, szMessageFile, MAX_PATH);
    
    if (args)
    {
        SKIP_WSPACE(args);
    }
    
    if (!args || !args[0] ||
        !strncmp(args, "-h", 2) ||
        !strncmp(args, "-?", 2))
    {
        Status = E_INVALIDARG;
        ExtErr(cszUsage);
        goto Exit;
    }

    // Parse args
    while (*args)
    {
        SKIP_WSPACE(args);

        // Check for optional argument options to appear first
        if (('-' == *args) || ('/' == *args))
        {
            CHAR ch = *(++args); // Get next char + advance arg ptr
            ++args; // Skip one more char
            
            CHAR *szEndOfValue = NULL; // Ptr to last char in value
            size_t cchValue = 0; // Count of chars in value
            
            SKIP_WSPACE(args); // Advance to start of param value

            // Skip looking for value if this is start of another
            // parameter
            if (('-' != *args) && ('/' != *args))
            {
                // Parameter value is delimited by next space in string, or,
                // if quoted, by next quote
                if ('"' == *args)
                {
                    ++args;
                    szEndOfValue = strchr(args, '"');
                }
                else
                {
                    szEndOfValue = strchr(args, ' ');
                }
            
                if (NULL == szEndOfValue)
                {
                    // copy to end of line
                    CopyString(szParamValue, args, sizeof(szParamValue));
                    args += min(sizeof(szParamValue), strlen(args));
                }
                else
                {
                    cchValue = szEndOfValue - args;
                    if (cchValue < sizeof(szParamValue))
                    {
                        // copy next N chars
                        CopyString(szParamValue, args, cchValue+1);
                        args += cchValue;
                    }
                    else
                    {
                        Status = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                        ExtErr("ERROR: Argument string too long. Aborting.\n");
                        goto Exit;
                    }

                    // skip past (theoretically) paired quote
                    if ('"' == *args)
                    {
                        ++args;
                    }
                }
            }
            switch (ch)
            {
                case 'd': // Use defaults
                    ExtVerb("Using defaults...\n");
                    // do nothing
                    break;
                case 's': // Source (string)
                    ExtVerb("Setting Source...\n");
                    CopyString(szSource, szParamValue, sizeof(szSource));
                    break;
                case 't': // Event Type (number or string)
                    ExtVerb("Setting Event Type...\n");
                    if (!_strnicmp(szParamValue, "All", 3))
                    {
                        dwTypesSupported = EVENTLOG_ERROR_TYPE |
                                           EVENTLOG_WARNING_TYPE |
                                           EVENTLOG_INFORMATION_TYPE |
                                           EVENTLOG_AUDIT_SUCCESS |
                                           EVENTLOG_AUDIT_FAILURE;
                    }
                    else if (!_strnicmp(szParamValue, "Error", 5))
                    {
                        dwTypesSupported = EVENTLOG_ERROR_TYPE;
                    }
                    else if (!_strnicmp(szParamValue, "Warning", 7))
                    {
                        dwTypesSupported = EVENTLOG_WARNING_TYPE;
                    }
                    else if (!_strnicmp(szParamValue, "Information", 11))
                    {
                        dwTypesSupported = EVENTLOG_INFORMATION_TYPE;
                    }
                    else if (!_strnicmp(szParamValue, "Audit_Success", 13))
                    {
                        dwTypesSupported = EVENTLOG_AUDIT_SUCCESS;
                    }
                    else if (!_strnicmp(szParamValue, "Audit_Failure", 13))
                    {
                        dwTypesSupported = EVENTLOG_AUDIT_FAILURE;
                    }
                    else
                    {
                        dwTypesSupported = strtoul(szParamValue, NULL, 10);
                    }
                    break;
                case 'f': // Message File
                    ExtVerb("Setting Message File...\n");
                    CopyString(szMessageFile,
                               szParamValue,
                               sizeof(szMessageFile));
                    break;
                default:
                    Status = E_INVALIDARG;
                    ExtErr("Invalid arg '-%c' specified\n", *args);
                    ExtErr(cszUsage);
                    goto Exit;
                    break;
            }
            
            ZeroMemory(szParamValue, sizeof(szParamValue)); // reset
        }
        else // Everything to end of line is message string
        {
            Status = E_INVALIDARG;
            ExtErr("Invalid arg '%s' specified\n", args);
            ExtErr(cszUsage);
            goto Exit;
        }
        
    }

    // Add source name as subkey under Application in EventLog registry key
    PrintString(szRegPath,
                sizeof(szRegPath),
                "SYSTEM\\CurrentControlSet\\Services\\EventLog\\"
                  "Application\\%s",
                szSource);
    lResult = RegCreateKeyEx(
                  HKEY_LOCAL_MACHINE, // key
                  szRegPath,       // subkey to open or create
                  0,               // reserved, must be zero
                  "",              // object type class
                  REG_OPTION_NON_VOLATILE, // special options (preserves data
                                           //   after system restart)
                  KEY_READ | KEY_WRITE,    // access mask
                  NULL,            // security descriptor (NULL = not inherited
                                   //   by child processes)
                  &hk,             // returned handle to opened or created key
                  &dwDisposition); // returns REG_CREATED_NEW_KEY or
                                   //   REG_OPENED_EXISTING_KEY
    if (ERROR_SUCCESS != lResult)
    {
        Status = HRESULT_FROM_WIN32(lResult);
        ExtErr("Could not open or create key, %u\n", lResult);
        goto Exit;
    }

    if (REG_CREATED_NEW_KEY == dwDisposition)
    {
        ExtOut("Created key:\nHKLM\\%s\n", szRegPath);
    }
    else if (REG_OPENED_EXISTING_KEY == dwDisposition)
    {
        ExtOut("Opened key:\nHKLM\\%s\n", szRegPath);
    }
    else
    {
        ExtWarn("Warning: Unexpected disposition action %u\n"
                "key: HKLM\\%s",
                szRegPath,
                dwDisposition);
    }

    // Set the value for EventMessageFile
    ExtVerb("Setting EventMessageFile to %s...\n", szMessageFile);
    lResult = RegSetValueEx(
                  hk,                          // subkey handle
                  "EventMessageFile",          // value name
                  0,                           // must be zero
                  REG_EXPAND_SZ,               // value type
                  (LPBYTE) szMessageFile,      // pointer to value data
                  strlen(szMessageFile) + 1);  // length of value data 
    if (ERROR_SUCCESS != lResult)
    {
        Status = HRESULT_FROM_WIN32(lResult);
        ExtErr("Could not set EventMessageFile, %u\n", lResult);
        goto Exit;
    }
    
    ExtOut("  EventMessageFile: %s\n", szMessageFile);
 
    // Set the supported event types value in the TypesSupported
    ExtVerb("Setting TypesSupported to %u...\n", dwTypesSupported);
    lResult = RegSetValueEx(
                  hk,               // subkey handle
                  "TypesSupported", // value name
                  0,                // must be zero
                  REG_DWORD,        // value type
                  (LPBYTE) &dwTypesSupported, // pointer to value data
                  sizeof(DWORD));   // length of value data
    if (ERROR_SUCCESS != lResult)
    {
        Status = HRESULT_FROM_WIN32(lResult);
        ExtErr("Could not set TypesSupported, %u\n", lResult);
        goto Exit;
    }
    
    ExtOut("  TypesSupported:   %u\n", dwTypesSupported);

    Status = S_OK;

Exit:
    if (NULL != hk)
    {
        RegCloseKey(hk);
    }
    EXIT_API();
    return Status;
}


HRESULT
EvLogBackup ( PDEBUG_CLIENT Client, PCSTR args )
/*++

Routine Description:

    This function handles parsing and execution for the backup command to the
    !evlog extension.  It is used to create a backup of an event log to a
    file.
    
Arguments:

    Client  - Pointer to IDebugClient passed to !evlog extension
              [not used by this command]
    args    - Pointer to command line arguments passed to this command from
              d!evlog extension
    
Return Value:

    E_INVALIDARG if invalid argument syntax detected
    ERROR_BUFFER_OVERFLOW if argument length too long
    GetLastError() converted to HRESULT otherwise

--*/
{
    HANDLE hEventLog = NULL;
    DWORD dwDirLen = 0;
    CHAR szParamValue[MAX_PATH];
    CHAR szEventLog[MAX_PATH+1];
    CHAR szBackupFileName[MAX_PATH+1];
    const CHAR cszUsage[] = "Usage:\n"
        "  !evlog backup [-d] [-l <eventlog>] [-f <filename>]\n\n"
        "Makes backup of specified event log to a file.\n\n"
        "Optional parameters:\n"
        "-d         : Use defaults\n"
        "<eventlog> : Application (default), System, Security\n"
        "<filename> : (default: %%cwd%%\\<eventlog>_backup.evt)\n";
    const CHAR cszDefaultEventLog[] = "Application";
    const CHAR cszDefaultFileNameAppend[] = "_backup.evt";

    INIT_API();

    // Initialize defaults
    ZeroMemory(szParamValue, sizeof(szParamValue));
    CopyString(szEventLog, cszDefaultEventLog, sizeof(szEventLog));
    // Create default backup filename: %cwd%\Application_backup.evt
    dwDirLen = GetCurrentDirectory(sizeof(szEventLog)/sizeof(TCHAR),
                                   szEventLog); // temp use of szEventLog
    if (0 == dwDirLen)
    {
        ExtErr("ERROR: Current directory length too long.  Using '.' for "
               "directory\n");
        CopyString(szEventLog, ".", sizeof(szEventLog));
    }
    PrintString(szBackupFileName,
                sizeof(szBackupFileName),
                "%s\\%s%s",
                szEventLog,
                cszDefaultEventLog,
                cszDefaultFileNameAppend);
    ZeroMemory(szEventLog, sizeof(szEventLog));
    CopyString(szEventLog, cszDefaultEventLog, sizeof(szEventLog));

    if (args)
    {
        SKIP_WSPACE(args);
    }
    
    if (!args || !args[0] ||
        !strncmp(args, "-h", 2) ||
        !strncmp(args, "-?", 2))
    {
        Status = E_INVALIDARG;
        ExtErr(cszUsage);
        goto Exit;
    }

    // Parse args
    while (*args)
    {
        SKIP_WSPACE(args);

        // Check for optional argument options to appear first
        if (('-' == *args) || ('/' == *args))
        {
            CHAR ch = *(++args); // Get next char + advance arg ptr
            ++args; // Skip one more char
            
            CHAR *szEndOfValue = NULL; // Ptr to last char in value
            size_t cchValue = 0; // Count of chars in value
            
            SKIP_WSPACE(args); // Advance to start of param value

            if (('-' != *args) && ('/' != *args))
            {
                // Parameter value is delimited by next space in string, or,
                // if quoted, by next quote
                if ('"' == *args)
                {
                    ++args;
                    szEndOfValue = strchr(args, '"');
                }
                else
                {
                    szEndOfValue = strchr(args, ' ');
                }
            
                if (NULL == szEndOfValue)
                {
                    // copy to end of line
                    CopyString(szParamValue, args, sizeof(szParamValue));
                    args += min(sizeof(szParamValue), strlen(args));
                }
                else
                {
                    cchValue = szEndOfValue - args;
                    if (cchValue < sizeof(szParamValue))
                    {
                        // copy next N chars
                        CopyString(szParamValue, args, cchValue+1);
                        args += cchValue;
                    }
                    else
                    {
                        Status = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                        ExtErr("ERROR: Argument string too long. Aborting.\n");
                        goto Exit;
                    }

                    // skip past (theoretically) paired quote
                    if ('"' == *args)
                    {
                        ++args;
                    }
                }
            }
            switch (ch)
            {
                case 'd': // Use defaults
                    ExtVerb("Using defaults...\n");
                    // do nothing
                    break;
                case 'l': // Source (string)
                    ExtVerb("Setting Event Log...\n");
                    CopyString(szEventLog, szParamValue, sizeof(szEventLog));
                    break;
                case 'f': // Message File
                    ExtVerb("Setting Backup File Name...\n");
                    CopyString(szBackupFileName,
                               szParamValue,
                               sizeof(szBackupFileName));
                    break;
                default:
                    Status = E_INVALIDARG;
                    ExtErr("Invalid arg '-%c' specified\n", *args);
                    ExtErr(cszUsage);
                    goto Exit;
                    break;
            }
            
            ZeroMemory(szParamValue, sizeof(szParamValue)); // reset
        }
        else // Everything to end of line is message string
        {
            Status = E_INVALIDARG;
            ExtErr("Invalid arg '%s' specified\n", args);
            ExtErr(cszUsage);
            goto Exit;
        }
        
    }

    // Get a handle to the event log
    ExtVerb("Opening event log '%s'...", szEventLog);
    hEventLog = OpenEventLog(
                    NULL,        // uses local computer
                    szEventLog); // source name
    if (NULL == hEventLog)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to open '%s' event log, 0x%08X\n", szEventLog, Status);
        goto Exit;
    }

    // Backup event log
    ExtOut("Backing up '%s' event log...\n", szEventLog);
    if (!BackupEventLog(
             hEventLog,         // handle to event log
             szBackupFileName)) // name of backup file
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to backup event log to '%s', 0x%08X\n",
               szBackupFileName,
               Status);
        goto Exit;
    }

    ExtOut("Event log successfully backed up to '%s'\n", szBackupFileName);

    Status = S_OK;

Exit:
    if (hEventLog)
    {
        CloseEventLog(hEventLog); 
    }
    EXIT_API();
    return Status;

}


HRESULT
EvLogOption( PDEBUG_CLIENT Client, PCSTR args )
/*++

Routine Description:

    This function handles parsing and execution for the option command to the
    !evlog extension.  It is used to modify and display the cached settings.
    Currently all cached option settings are used by the read command only.
    
Arguments:

    Client  - Pointer to IDebugClient passed to !evlog extension
              [not used by this command]
    args    - Pointer to command line arguments passed to this command from
              !evlog extension
    
Return Value:

    E_INVALIDARG if invalid argument syntax detected
    ERROR_BUFFER_OVERFLOW if argument length too long
    GetLastError() converted to HRESULT otherwise

--*/
{
    WORD wDataDisplayWidth = g_wDataDisplayWidth;
    DWORD dwRecordOffset = g_cdwDefaultRecordOffset;
    DWORD dwReadFlags = g_cdwDefaultReadFlags;
    enum
    {
        MASK_IGNORE_RECORD_OFFSET=0x0000,
        MASK_RESET_RECORD_OFFSET_DEFAULT=0x0001,
        MASK_SET_MAX_RECORD_OFFSET=0x0002,
        MASK_SET_RECORD_OFFSET=0x0004
    } fMaskRecordOffset = MASK_IGNORE_RECORD_OFFSET;
    CHAR szEventLog[MAX_PATH+1];
    CHAR szParamValue[MAX_PATH];
    const CHAR cszUsage[] = "Usage:\n"
        "  !evlog option [-d] [-!] [-n <count>] [[-l <eventlog>] -+ | "
          "-r <record>]\n"
        "               [-o <order>] [-w <width>]\n\n"
        "Sets and resets default search option parameters for read command."
          "\n\n"
        "A backwards search order implies that by default all searches start "
          "from the\n"
        "most recent record logged to the event log and the search continues "
          "in\n"
        "reverse chronological order as matching records are found.\n\n"
        "Bounding record numbers for each event log allow searches to "
          "terminate after\n"
        "a known record number is encountered. This can be useful when you "
          "want to\n"
        "view all records logged after a certain event only.\n\n"
        "Optional parameters:\n"
        "-d         : Display defaults\n"
        "-!         : Reset all defaults\n"
        "<count>    : Count of max N records to retrieve for any query "
          "(default: 20)\n"
        "<eventlog> : All (default), Application, System, Security\n"
        "-+         : Set bounding record # to current max record #\n"
        "<record>   : Use as bounding record # in read queries (default: 0 = "
          "ignore)\n"
        "<order>    : Search order Forwards, Backwards (default: Backwards)\n"
        "<width>    : Set data display width (in bytes).  This is the width "
          "that \"Data:\"\n"
        "             sections display. (default: 8, same as event log)\n";    
    const CHAR cszDefaultEventLog[] = "All";    

    INIT_API();

    // Initialize defaults
    ZeroMemory(szParamValue, sizeof(szParamValue));
    CopyString(szEventLog, cszDefaultEventLog, sizeof(szEventLog));
    
    if (args)
    {
        SKIP_WSPACE(args);
    }
    
    if (!args || !args[0] ||
        !strncmp(args, "-h", 2) ||
        !strncmp(args, "-?", 2))
    {
        Status = E_INVALIDARG;
        ExtErr(cszUsage);
        goto Exit;
    }

    // Parse args
    while (*args)
    {
        SKIP_WSPACE(args);

        // Check for optional argument options
        if (('-' == *args) || ('/' == *args))
        {
            CHAR ch = *(++args); // Get next char + advance arg ptr
            ++args; // Skip one more char
            
            CHAR *szEndOfValue = NULL; // Ptr to last char in value
            size_t cchValue = 0; // Count of chars in value
            
            SKIP_WSPACE(args); // Advance to start of param value

            // Parameter value is delimited by next space in string, or,
            // if quoted, by next quote
            if ('"' == *args)
            {
                ++args;
                szEndOfValue = strchr(args, '"');
            }
            else
            {
                szEndOfValue = strchr(args, ' ');
            }

            if (NULL == szEndOfValue)
            {
                // copy to end of line
                CopyString(szParamValue, args, sizeof(szParamValue));
                args += strlen(args);
            }
            else
            {
                cchValue = szEndOfValue - args;
                if (cchValue < sizeof(szParamValue))
                {
                    // copy next N chars
                    CopyString(szParamValue, args, cchValue+1);
                    args += cchValue;
                }
                else
                {
                    Status = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                    ExtErr("ERROR: Argument string too long. Aborting.\n");
                    goto Exit;
                }

                if ('"' == *args) // skip past (theoretically) paired quote
                {
                    ++args;
                }
            }

            switch (ch)
            {
                case 'd': // Use defaults
                    ExtVerb("Using defaults...\n");
                    // do nothing
                    break;
                case 'l': // Source (string)
                    ExtVerb("Setting Event Log...\n");
                    CopyString(szEventLog, szParamValue, sizeof(szEventLog));
                    break;
                case 'n': // number of records to retrieve
                    ExtVerb("Setting Max Record Count...\n");
                    g_dwMaxRecords = strtoul(szParamValue, NULL, 10);
                    break;
                case '!': // Use defaults
                    ExtVerb("Resetting Defaults...\n");
                    fMaskRecordOffset = MASK_RESET_RECORD_OFFSET_DEFAULT;
                    g_dwMaxRecords = g_cdwDefaultMaxRecords;
                    g_dwReadFlags = g_cdwDefaultReadFlags;
                    g_wDataDisplayWidth = g_cwMaxDataDisplayWidth;
                    break;
                case '+': // Set to max record number for event source
                    ExtVerb(
                        "Setting Record Number to Max Record Number...\n");
                    fMaskRecordOffset = MASK_SET_MAX_RECORD_OFFSET;
                    break;
                case 'r': // record offset for bounds
                    ExtVerb("Setting Record Number...\n");
                    if (!_strnicmp(szParamValue, "0x", 2))
                    {
                        dwRecordOffset = strtoul(szParamValue, NULL, 16);
                    }
                    else
                    {
                        dwRecordOffset = strtoul(szParamValue, NULL, 10);
                    }
                    dwReadFlags = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
                    fMaskRecordOffset = MASK_SET_RECORD_OFFSET;
                    break;
                case 'o': // Source (string)
                    ExtVerb("Setting Search Order...\n");
                    if (!_stricmp(szParamValue, "Forwards"))
                    {
                        g_dwReadFlags ^= BACKWARDS_READ;
                        g_dwReadFlags |= FORWARDS_READ;
                    }
                    else if (!_stricmp(szParamValue, "Backwards"))
                    {
                        g_dwReadFlags ^= FORWARDS_READ;
                        g_dwReadFlags |= BACKWARDS_READ;
                    }
                    else
                    {
                        ExtErr("Ignoring invalid search order option '%s'\n",
                               szParamValue);
                    }
                    break;
                case 'w': // record offset for bounds
                    ExtVerb("Setting Data Display Width...\n");
                    if (!_strnicmp(szParamValue, "0x", 2))
                    {
                        wDataDisplayWidth = (WORD)strtoul(szParamValue,
                                                          NULL,
                                                          16);
                    }
                    else
                    {
                        wDataDisplayWidth = (WORD)strtoul(szParamValue,
                                                          NULL,
                                                          10);
                    }
                    
                    if ((0 == wDataDisplayWidth) ||
                        (wDataDisplayWidth > g_cwMaxDataDisplayWidth))
                    {
                        Status = E_INVALIDARG;
                        ExtErr("ERROR: Data display width %u exceeds bounds "
                               "(1...%u)\n",
                               wDataDisplayWidth, g_cwMaxDataDisplayWidth);
                        goto Exit;
                    }
                    g_wDataDisplayWidth = wDataDisplayWidth;
                    break;
                default:
                    Status = E_INVALIDARG;
                    ExtErr("Invalid arg '-%c' specified\n", *args);
                    ExtErr(cszUsage);
                    goto Exit;
                    break;
            }
            
            ZeroMemory(szParamValue, sizeof(szParamValue)); // reset
        }
        else // Everything to end of line is message string
        {
            Status = E_INVALIDARG;
            ExtErr("Invalid arg '%s' specified\n", args);
            ExtErr(cszUsage);
            goto Exit;
        }
        
    }

    // Set any variables not already set here
    if (!_stricmp(szEventLog, "Application"))
    {
        if (MASK_SET_RECORD_OFFSET & fMaskRecordOffset)
        {
            g_dwRecordOffsetAppEvt = dwRecordOffset;
        }
        else if (MASK_RESET_RECORD_OFFSET_DEFAULT & fMaskRecordOffset)
        {
            g_dwRecordOffsetAppEvt = g_cdwDefaultRecordOffset;
        }
        else if (MASK_SET_MAX_RECORD_OFFSET & fMaskRecordOffset)
        {
            GetEvLogNewestRecord("Application", &g_dwRecordOffsetAppEvt); 
        }
        else
        {
            ; // error
        }
        
    }
    else if (!_stricmp(szEventLog, "System"))
    {
        if (MASK_SET_RECORD_OFFSET & fMaskRecordOffset)
        {
            g_dwRecordOffsetSysEvt = dwRecordOffset;
        }
        else if (MASK_RESET_RECORD_OFFSET_DEFAULT & fMaskRecordOffset)
        {
            g_dwRecordOffsetSysEvt = g_cdwDefaultRecordOffset;
        }
        else if (MASK_SET_MAX_RECORD_OFFSET & fMaskRecordOffset)
        {
            GetEvLogNewestRecord("System", &g_dwRecordOffsetSysEvt); 
        }
        else
        {
            ; // error
        }
    }
    else if (!_stricmp(szEventLog, "Security"))
    {
        if (MASK_SET_RECORD_OFFSET & fMaskRecordOffset)
        {
            g_dwRecordOffsetSecEvt = dwRecordOffset;
        }
        else if (MASK_RESET_RECORD_OFFSET_DEFAULT & fMaskRecordOffset)
        {
            g_dwRecordOffsetSecEvt = g_cdwDefaultRecordOffset;
        }
        else if (MASK_SET_MAX_RECORD_OFFSET& fMaskRecordOffset)
        {
            GetEvLogNewestRecord("Security", &g_dwRecordOffsetSecEvt); 
        }
        else
        {
            ; // error
        }
    }
    else
    {
        if (MASK_SET_RECORD_OFFSET & fMaskRecordOffset)
        {
            g_dwRecordOffsetAppEvt = dwRecordOffset;
            g_dwRecordOffsetSysEvt = dwRecordOffset;
            g_dwRecordOffsetSecEvt = dwRecordOffset;
        }
        else if (MASK_RESET_RECORD_OFFSET_DEFAULT & fMaskRecordOffset)
        {
            g_dwRecordOffsetAppEvt = g_cdwDefaultRecordOffset;
            g_dwRecordOffsetSysEvt = g_cdwDefaultRecordOffset;
            g_dwRecordOffsetSecEvt = g_cdwDefaultRecordOffset;
        }
        else if (MASK_SET_MAX_RECORD_OFFSET & fMaskRecordOffset)
        {
            GetEvLogNewestRecord("Application", &g_dwRecordOffsetAppEvt);
            GetEvLogNewestRecord("System", &g_dwRecordOffsetSysEvt); 
            GetEvLogNewestRecord("Security", &g_dwRecordOffsetSecEvt); 
        }
        else
        {
            if (fMaskRecordOffset)
            {
                Status = E_INVALIDARG;
                ExtErr("ERROR: Must specify -!, -+, or -r option\n");
                goto Exit;
            }
        }
    }
    
    // Display defaults here
    PrintEvLogOptionSettings();

    Status = S_OK;
    
Exit:
    EXIT_API();
    return Status;
}


HRESULT
EvLogClear ( PDEBUG_CLIENT Client, PCSTR args )
/*++

Routine Description:

    This function handles parsing and execution for the clear command to the
    !evlog extension.  It is used to clear and, optionally, backup an event
    log to a file.
    
Arguments:

    Client  - Pointer to IDebugClient passed to !evlog extension
              [not used by this command]
    args    - Pointer to command line arguments passed to this command from
              !evlog extension
    
Return Value:

    E_INVALIDARG if invalid argument syntax detected
    ERROR_BUFFER_OVERFLOW if argument length too long
    GetLastError() converted to HRESULT otherwise

--*/
{
    HANDLE hEventLog = NULL;
    BOOL fIgnoreBackup = FALSE;
    DWORD dwDirLen = 0;
    CHAR szParamValue[MAX_PATH];
    CHAR szEventLog[MAX_PATH+1];
    CHAR szBackupFileName[MAX_PATH+1];
    PCHAR pszBackupFileName = NULL;

    const CHAR cszUsage[] = "Usage:\n"
        "  !evlog clear [-!] [-d] [-l <eventlog>] [-f <filename>]\n\n"
        "Clears and creates backup of specified event log.\n\n"
        "Optional parameters:\n"
        "-!         : Ignore backup\n"
        "-d         : Use defaults\n"
        "<eventlog> : Application (default), System, Security\n"
        "<filename> : (default: %%cwd%%\\<eventlog>_backup.evt)\n";
    const CHAR cszDefaultEventLog[] = "Application";
    const CHAR cszDefaultFileNameAppend[] = "_backup.evt";

    INIT_API();

    // Initialize default
    ZeroMemory(szParamValue, sizeof(szParamValue));
    CopyString(szEventLog, cszDefaultEventLog, sizeof(szEventLog));
    // Create default backup filename: %cwd%\Application_backup.evt
    dwDirLen = GetCurrentDirectory(sizeof(szEventLog)/sizeof(TCHAR),
                                   szEventLog); // temp use of szEventLog
    if (0 == dwDirLen)
    {
        ExtErr("ERROR: Current directory length too long.  Using '.' for "
               "directory\n");
        CopyString(szEventLog, ".", sizeof(szEventLog));
    }
    PrintString(szBackupFileName,
                sizeof(szBackupFileName),
                "%s\\%s%s",
                szEventLog,
                cszDefaultEventLog,
                cszDefaultFileNameAppend);
    ZeroMemory(szEventLog, sizeof(szEventLog));
    CopyString(szEventLog, cszDefaultEventLog, sizeof(szEventLog));

    if (args)
    {
        SKIP_WSPACE(args);
    }
    
    if (!args || !args[0] ||
        !strncmp(args, "-h", 2) ||
        !strncmp(args, "-?", 2))
    {
        Status = E_INVALIDARG;
        ExtErr(cszUsage);
        goto Exit;
    }

    // Parse args
    while (*args)
    {
        SKIP_WSPACE(args);

        // Check for optional argument options to appear first
        if (('-' == *args) || ('/' == *args))
        {
            CHAR ch = *(++args); // Get next char + advance arg ptr
            ++args; // Skip one more char
            
            CHAR *szEndOfValue = NULL; // Ptr to last char in value
            size_t cchValue = 0; // Count of chars in value
            
            SKIP_WSPACE(args); // Advance to start of param value

            if (('-' != *args) && ('/' != *args))
            {
                // Parameter value is delimited by next space in string, or,
                // if quoted, by next quote
                if ('"' == *args)
                {
                    ++args;
                    szEndOfValue = strchr(args, '"');
                }
                else
                {
                    szEndOfValue = strchr(args, ' ');
                }
            
                if (NULL == szEndOfValue)
                {
                    // copy to end of line
                    CopyString(szParamValue, args, sizeof(szParamValue));
                    args += strlen(args);
                }
                else
                {
                    cchValue = szEndOfValue - args;
                    if (cchValue < sizeof(szParamValue))
                    {
                        // copy next N chars
                        CopyString(szParamValue, args, cchValue+1);
                        args += cchValue;
                    }
                    else
                    {
                        Status = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                        ExtErr("ERROR: Argument string too long. Aborting.\n");
                        goto Exit;
                    }

                    // skip past (theoretically) paired quote
                    if ('"' == *args)
                    {
                        ++args;
                    }
                }
            }
            switch (ch)
            {
                case '!': // Use defaults
                    ExtVerb("Ignoring default backup procedure...\n");
                    fIgnoreBackup = TRUE;
                    break;
                case 'd': // Use defaults
                    ExtVerb("Using defaults...\n");
                    // do nothing
                    break;
                case 'l': // Source (string)
                    ExtVerb("Setting Event Log...\n");
                    CopyString(szEventLog, szParamValue, sizeof(szEventLog));
                    break;
                case 'f': // Message File
                    ExtVerb("Setting Backup File Name...\n");
                    CopyString(szBackupFileName,
                               szParamValue,
                               sizeof(szBackupFileName));
                    break;
                default:
                    Status = E_INVALIDARG;
                    ExtErr("Invalid arg '-%c' specified\n", *args);
                    ExtErr(cszUsage);
                    goto Exit;
                    break;
            }
            
            ZeroMemory(szParamValue, sizeof(szParamValue)); // reset
        }
        else // Everything to end of line is message string
        {
            Status = E_INVALIDARG;
            ExtErr("Invalid arg '%s' specified\n", args);
            ExtErr(cszUsage);
            goto Exit;
        }
        
    }

    // Get a handle to the event log
    ExtVerb("Opening event log '%s'...", szEventLog);
    hEventLog = OpenEventLog(
                    NULL,        // uses local computer
                    szEventLog); // source name
    if (NULL == hEventLog)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to open '%s' event log, 0x%08X\n", szEventLog, Status);
        goto Exit;
    }

    if (fIgnoreBackup)
    {
        pszBackupFileName = NULL;
    }
    else
    {
        pszBackupFileName = szBackupFileName;
    }
    
    // Clear event log
    ExtOut("Clearing '%s' event log...\n", szEventLog);
    if (!ClearEventLog(
             hEventLog,         // handle to event log
             pszBackupFileName)) // name of backup file
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to clear event log and backup to '%s', 0x%08X\n",
               szBackupFileName,
               Status);
        goto Exit;
    }

    ExtOut("Event log successfully backed up to '%s'\n", szBackupFileName);

    Status = S_OK;

Exit:
    if (hEventLog)
    {
        CloseEventLog(hEventLog); 
    }
    EXIT_API();
    return Status;
}


HRESULT
EvLogInfo ( PDEBUG_CLIENT Client, PCSTR args )
/*++

Routine Description:

    This function handles parsing and execution for the info command to the
    !evlog extension.  It is used to display summary information about all 3
    standard event logs: Application, System, and Security.

    A user without rights to see the System or Security event log will
    probably get an error.
    
Arguments:

    Client  - Pointer to IDebugClient passed to !evlog extension
              [not used by this command]
    args    - Pointer to command line arguments passed to this command from
              !evlog extension
    
Return Value:

    S_OK

--*/
{
    INIT_API();

    PrintEvLogSummary("Application");
    PrintEvLogSummary("System");
    PrintEvLogSummary("Security");

    ExtOut("--------------------------------\n");
    
    EXIT_API();
    return S_OK;
}


HRESULT
EvLogRead ( PDEBUG_CLIENT Client, PCSTR args )
/*++

Routine Description:

    This function handles parsing and execution for the read command to the
    !evlog extension.  It is used to display event records from any event
    log.
    
    Some search parameters can be set to filter the list of events displayed.
    Also, the !evlog option command can be used to set some default
    parameters.

    A user without rights to see the System or Security event log will
    probably get an error.

    There are a few common scenarios where this extension command might be
    used:
    1) To identify when the last event was logged (may have been a few
       minutes ago or days...)
    2) To search for recent occurrences of specific known "interesting"
       events
    3) To monitor events logged as a result of (or side effect of) stepping
       over an instruction
    
Arguments:

    Client  - Pointer to IDebugClient passed to !evlog extension
              [not used by this command]
    args    - Pointer to command line arguments passed to this command from
              !evlog extension
    
Return Value:

    E_INVALIDARG if invalid argument syntax detected
    ERROR_BUFFER_OVERFLOW if argument length too long
    GetLastError() converted to HRESULT otherwise

--*/
{
    HANDLE hEventLog = NULL;
    EVENTLOGRECORD *pevlr = NULL;
    BYTE *pbBuffer = NULL;
    LPCSTR cszMessage = NULL;
    DWORD dwEventID = 0; // default (normally event id is non-zero)
    WORD wEventCategory = 0; // default (normally categories start at 1)
    WORD wEventType = 0; // default
    const DWORD cdwDefaultBufSize = 4096; // default
    DWORD dwBufSize = cdwDefaultBufSize;
    DWORD dwBytesRead = 0;
    DWORD dwBytesNeeded = 0;
    DWORD dwReadFlags = g_dwReadFlags | EVENTLOG_SEQUENTIAL_READ;
    DWORD dwRecordOffset = 0; // 0 = ignored for sequential reads
    DWORD dwNumRecords = 0; // Count of records matched/found
    DWORD dwTotalRecords = 0; // Count of records enumerated (for debugging)
    DWORD dwMaxRecords = g_dwMaxRecords;
    DWORD dwBoundingEventRecord = 0;
    DWORD dwLastErr = 0;
    BOOL fSuccess = FALSE;
    BOOL fMatchSource = FALSE;
    BOOL fMatchEventID = FALSE;
    BOOL fMatchEventCategory = FALSE;
    BOOL fMatchEventType = FALSE;
    CHAR szEventLog[MAX_PATH+1];
    CHAR szSource[MAX_PATH+1];
    CHAR szParamValue[MAX_PATH];
    // Note: this could get really fancy, searching on description, date
    // ranges, event id ranges, data, etc.  Keep it simple to just display
    // last few events logged.
    const CHAR cszUsage[] = "Usage:\n"
        "  !evlog read [-d] [-l <eventlog>] [-s <source>] "
        "[-e <id>] [-c <category>]\n"
        "              [-t <type>] [-n <count>] [-r <record>]\n\n"
        "Displays last N events logged to the specified event log, in "
          "reverse\n"
        "chronological order by default. If -n option is not specified, a "
          "default max\n"
        "of 20 records is enforced.\n\n"
        "However, if -r is specified, only the specific event record will "
          "be\n"
        "displayed unless the -n option is also specified.\n\n"
        "!evlog option can be used to override some defaults, including the "
          "search\n"
        "order of backwards.  See !evlog option -d for default settings.\n\n"
        "Optional parameters:\n"
        "-d         : Use defaults\n"
        "<eventlog> : Application (default), System, Security\n"
        "<source>   : DebuggerExtensions (default: none)\n"
        "<id>       : 0, 1000, 2000, 3000, 4000, etc... (default: 0)\n"
        "<category> : None (default: 0), Devices (1), Disk (2), Printers "
          "(3),\n"
        "             Services (4), Shell (5), System_Event (6), Network "
          "(7)\n"
        "<type>     : Success (default: 0), Error (1), Warning (2), "
        "Information (4),\n"
        "             Audit_Success (8), or Audit_Failure (16)\n"
        "<count>    : Count of last N event records to retrieve (default: "
          "1)\n"
        "<record>   : Specific record # to retrieve\n";
    const CHAR cszDefaultEventLog[] = "Application";
    const CHAR cszDefaultSource[] = "DebuggerExtensions";

    INIT_API();

    // Initialize defaults
    ZeroMemory(szParamValue, sizeof(szParamValue));
    CopyString(szEventLog, cszDefaultEventLog, sizeof(szEventLog));
    
    if (args)
    {
        SKIP_WSPACE(args);
    }
    
    if (!args || !args[0] ||
        !strncmp(args, "-h", 2) ||
        !strncmp(args, "-?", 2))
    {
        Status = E_INVALIDARG;
        ExtErr(cszUsage);
        goto Exit;
    }

    // Parse args
    while (*args)
    {
        SKIP_WSPACE(args);

        // Check for optional argument options
        if (('-' == *args) || ('/' == *args))
        {
            CHAR ch = *(++args); // Get next char + advance arg ptr
            ++args; // Skip one more char
            
            CHAR *szEndOfValue = NULL; // Ptr to last char in value
            size_t cchValue = 0; // Count of chars in value
            
            SKIP_WSPACE(args); // Advance to start of param value

            // Parameter value is delimited by next space in string, or,
            // if quoted, by next quote
            if ('"' == *args)
            {
                ++args;
                szEndOfValue = strchr(args, '"');
            }
            else
            {
                szEndOfValue = strchr(args, ' ');
            }

            if (NULL == szEndOfValue)
            {
                // copy to end of line
                CopyString(szParamValue, args, sizeof(szParamValue));
                args += strlen(args);
            }
            else
            {
                cchValue = szEndOfValue - args;
                if (cchValue < sizeof(szParamValue))
                {
                    // copy next N chars
                    CopyString(szParamValue, args, cchValue+1);
                    args += cchValue;
                }
                else
                {
                    Status = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                    ExtErr("ERROR: Argument string too long. Aborting.\n");
                    goto Exit;
                }

                // skip past (theoretically) paired quote
                if ('"' == *args)
                {
                    ++args;
                }
            }

            switch (ch)
            {
                case 'd': // Use defaults
                    ExtVerb("Using defaults...\n");
                    // do nothing
                    break;
                case 'l': // Source (string)
                    ExtVerb("Setting Event Log...\n");
                    CopyString(szEventLog, szParamValue, sizeof(szEventLog));
                    break;
                case 's': // Source (string)
                    ExtVerb("Setting Source...\n");
                    CopyString(szSource, szParamValue, sizeof(szSource));
                    fMatchSource = TRUE;
                    break;
                case 'e': // Event ID (number or string)
                    ExtVerb("Setting Event ID...\n");
                    //
                    // Some events only display the low WORD, but the high
                    // WORD actually contains a status code like 8000 or
                    // C000.
                    // So allow for hex input as well as decimal...
                    //
                    if (!_strnicmp(szParamValue, "0x", 2))
                    {
                        dwEventID = strtoul(szParamValue, NULL, 16);
                    }
                    else
                    {
                        dwEventID = strtoul(szParamValue, NULL, 10);
                    }
                    fMatchEventID = TRUE;
                    break;
                case 'c': // Event Category (number or string)
                    ExtVerb("Setting Category...\n");
                    if (!_strnicmp(szParamValue, "None", 4))
                    {
                        wEventCategory = 0;
                    }
                    else if (!_strnicmp(szParamValue, "Devices", 7))
                    {
                        wEventCategory = 1;
                    }
                    else if (!_strnicmp(szParamValue, "Disk", 4))
                    {
                        wEventCategory = 2;
                    }
                    else if (!_strnicmp(szParamValue, "Printers", 8))
                    {
                        wEventCategory = 3;
                    }
                    else if (!_strnicmp(szParamValue, "Services", 8))
                    {
                        wEventCategory = 4;
                    }
                    else if (!_strnicmp(szParamValue, "Shell", 5))
                    {
                        wEventCategory = 5;
                    }
                    else if (!_strnicmp(szParamValue, "System_Event", 12))
                    {
                        wEventCategory = 6;
                    }
                    else if (!_strnicmp(szParamValue, "Network", 7))
                    {
                        wEventCategory = 7;
                    }
                    else
                    {
                        wEventCategory = (WORD)strtoul(szParamValue,
                                                       NULL, 10);
                    }
                    fMatchEventCategory = TRUE;
                    break;
                case 't': // Event Type (number or string)
                    ExtVerb("Setting Event Type...\n");
                    if (!_strnicmp(szParamValue, "Success", 7))
                    {
                        wEventType = EVENTLOG_SUCCESS;
                    }
                    else if (!_strnicmp(szParamValue, "Error", 5))
                    {
                        wEventType = EVENTLOG_ERROR_TYPE;
                    }
                    else if (!_strnicmp(szParamValue, "Warning", 7))
                    {
                        wEventType = EVENTLOG_WARNING_TYPE;
                    }
                    else if (!_strnicmp(szParamValue, "Information", 11))
                    {
                        wEventType = EVENTLOG_INFORMATION_TYPE;
                    }
                    else if (!_strnicmp(szParamValue, "Audit_Success", 13))
                    {
                        wEventType = EVENTLOG_AUDIT_SUCCESS;
                    }
                    else if (!_strnicmp(szParamValue, "Audit_Failure", 13))
                    {
                        wEventType = EVENTLOG_AUDIT_FAILURE;
                    }
                    else
                    {
                        wEventType = (WORD)strtoul(szParamValue, NULL, 10);
                    }
                    fMatchEventType = TRUE;
                    break;
                case 'n': // number of records to retrieve
                    ExtVerb("Setting Max Record Count...\n");
                    dwMaxRecords = strtoul(szParamValue, NULL, 10);
                    break;
                case 'r': // record offset + switch flags to do seek
                    ExtVerb("Setting Record Number...\n");
                    dwRecordOffset = strtoul(szParamValue, NULL, 10);
                    dwReadFlags ^= EVENTLOG_SEQUENTIAL_READ; // disable
                    dwReadFlags |= EVENTLOG_SEEK_READ; // enable
                    dwMaxRecords = 1;
                    break;
                default:
                    Status = E_INVALIDARG;
                    ExtErr("Invalid arg '-%c' specified\n", *args);
                    ExtErr(cszUsage);
                    goto Exit;
                    break;
            }
            
            ZeroMemory(szParamValue, sizeof(szParamValue)); // reset
        }
        else // Everything to end of line is message string
        {
            SKIP_WSPACE(args);
            cszMessage = args;
            args += strlen(args);
        }
        
    }
        
    // Get a handle to the event log
    ExtVerb("Opening event log '%s'...", szEventLog);
    hEventLog = OpenEventLog(NULL, szEventLog);
    if (!hEventLog)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to open event log, 0x%08X\n", Status);
        goto Exit;
    }

    // If this record number is hit during read, it will
    // not be displayed and reads will halt immediately
    if (!strcmp(szEventLog, "System"))
    {
        dwBoundingEventRecord = g_dwRecordOffsetSysEvt;
    }
    else if (!strcmp(szEventLog, "Security"))
    {
        dwBoundingEventRecord = g_dwRecordOffsetSecEvt;
    }
    else  // szEventLog == "Application" or default
    {
        dwBoundingEventRecord = g_dwRecordOffsetAppEvt;
    }
    
    ExtVerb("Using Bounding Event Record %u...\n", dwBoundingEventRecord);
    
    do
    {
        // Allocate buffer if unallocated
        if (NULL == pbBuffer)
        {
            pbBuffer = (BYTE *)calloc(dwBufSize, sizeof(BYTE));
            if (NULL == pbBuffer)
            {
                Status = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                ExtErr("Unable to allocate buffer, 0x%08X\n", Status);
                goto Exit;
            }
        }

        // Reposition to beginning of buffer for next read
        pevlr = (EVENTLOGRECORD *) pbBuffer;

        // Read next N event records that fit into dwBufSize
        fSuccess = ReadEventLog(
                       hEventLog,       // handle to event log
                       dwReadFlags,     // how to read log
                       dwRecordOffset,  // initial record offset
                       pevlr,           // buffer for read data
                       dwBufSize,       // bytes to read
                       &dwBytesRead,    // number of bytes read
                       &dwBytesNeeded); // bytes required
        if (!fSuccess)
        {
            dwLastErr = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == dwLastErr)
            {
                ExtVerb("Increasing buffer from %u to %u bytes\n",
                           dwBufSize, dwBufSize+cdwDefaultBufSize);
                // Retry ReadEventLog with larger buffer next time
                dwBufSize += cdwDefaultBufSize;
                free(pbBuffer);
                pbBuffer = NULL; // allow reallocation above
                
                // TODO: Really should put upper limit on buffer size
                continue; // retry ReadEventLog
            }
            else if (ERROR_HANDLE_EOF == dwLastErr)
            {
                Status = S_OK;
                goto Exit;
            }
            else
            {
                ExtErr("Error reading event log, %u\n", dwLastErr);
                Status = HRESULT_FROM_WIN32(dwLastErr);
                goto Exit;
            }
        }
        
        // Go through all records returned from last successful read
        // Display only the ones that match the criteria
        do
        {
            if (dwBoundingEventRecord == pevlr->RecordNumber)
            {
                ExtWarn("Bounding record #%u reached. Terminating search.\n",
                        dwBoundingEventRecord);
                ExtWarn("Use !evlog option -d to view defaults.\n");
                goto Exit;
            }
        
            BOOL fDisplayRecord = TRUE;
            dwTotalRecords++;
            
            // Ignore this record if it does not match criteria
            if (fMatchSource &&
                    _stricmp(szSource,
                            (CHAR *)(BYTE *)pevlr + sizeof(EVENTLOGRECORD)))
            {
                fDisplayRecord = FALSE;
            }

            if (fMatchEventID && (dwEventID != pevlr->EventID))
            {
                fDisplayRecord = FALSE;
            }

            if (fMatchEventCategory &&
                (wEventCategory != pevlr->EventCategory))
            {
                fDisplayRecord = FALSE;
            }

            if (fMatchEventType && (wEventType != pevlr->EventType))
            {
                fDisplayRecord = FALSE;
            }
            
            if (fDisplayRecord)
            {
                dwNumRecords++;
            
                if (dwNumRecords > dwMaxRecords)
                {
                    ExtWarn("WARNING: Max record count (%u) exceeded, "
                            "increase record count to view more\n",
                            dwMaxRecords);
                    goto Exit;
                }
                
                ExtOut("-------------- %02u --------------\n", dwNumRecords);
                PrintEvLogEvent(szEventLog, pevlr);
            }
            
            if (dwTotalRecords % 20)
            {
                ExtVerb("dwTotalRecords = %u, "
                        "Current Record # = %u, "
                        "dwRecordOffset = %u\n",
                        dwTotalRecords,
                        pevlr->RecordNumber,
                        dwRecordOffset);
            }

            if (CheckControlC())
            {
                ExtOut("Terminated w/ctrl-C...\n");
                goto Exit;
            }
            
            if (dwReadFlags & (EVENTLOG_SEEK_READ |
                               EVENTLOG_FORWARDS_READ))
            {
                // Start next read at new "forward" seek position
                dwRecordOffset = pevlr->RecordNumber + 1;
            }
            else if (dwReadFlags &
                     (EVENTLOG_SEEK_READ | EVENTLOG_BACKWARDS_READ))
            {
                // Start next read at new "backwards" seek position
                dwRecordOffset = pevlr->RecordNumber - 1;
            }
            
            dwBytesRead -= pevlr->Length;
            pevlr = (EVENTLOGRECORD *) ((BYTE *)pevlr + pevlr->Length);

        } while (dwBytesRead > 0);
    } while (TRUE);

    Status = S_OK;

 Exit:
    if ((0 == dwNumRecords) && (S_OK == Status))
    {
        ExtOut("No matching event records found.\n");
    }
    if (hEventLog)
    {
        CloseEventLog(hEventLog); 
    }

    free(pbBuffer);
    pbBuffer = NULL;

    EXIT_API();
    return Status;
}


HRESULT
EvLogReport ( PDEBUG_CLIENT Client, PCSTR args )
/*++

Routine Description:

    This function handles parsing and execution for the report command to the
    !evlog extension.  It is used to log events to the Application event log
    ONLY.

    To make the events view nicely in the event viewer, there must be a
    registered event source. The !evlog addsource command can be used to
    register the uext.dll as a an event message file for any event source.
    Since this feature is implemented under the guise of a debugger extension,
    the default source name is "DebuggerExtensions".
    
    There are a few reasons why this extension command might be handy:
    1) A developer can log a note to recall later
    2) A large lab with many machines running cdb/ntsd/windbg user mode
       debuggers can set a command to log an event when the machine breaks
       into the debugger. The event might then be monitored by a central
       console which might, in turn, send an e-mail notification or page
       someone immediately regarding the break.
    
Arguments:

    Client  - Pointer to IDebugClient passed to !evlog extension
              [not used by this command]
    args    - Pointer to command line arguments passed to this command from
              !evlog extension
    
Return Value:

    E_INVALIDARG if invalid argument syntax detected
    ERROR_BUFFER_OVERFLOW if argument length too long
    GetLastError() converted to HRESULT otherwise

--*/
{
    HANDLE hEventSource = NULL;
    LPCSTR cszMessage = NULL;
    WORD wEventCategory = 0; // default (normally categories start at 1)
    WORD wEventType = 0; // default
    DWORD dwEventID = 0; // default (normally event id is non-zero)
    CHAR szParamValue[MAX_PATH];
    CHAR szSource[MAX_PATH+1];
    const CHAR cszUsage[] = "Usage:\n"
        "  !evlog report [-s <source>] "
        "[-e <id>] [-c <category>] [-t <type>] <message>\n\n"
        "Logs an event to the application event log.\n\n"
        "Use !evlog addsource to configure an event source in the registry."
          "Once\n"
        "configured, the following Event IDs will be recognized by the event "
          "viewer:\n\n"
        "    0     Displays raw message in event description field\n"
        "    1000  Prefixes description with \"Information:\"\n"
        "    2000  Prefixes description with \"Success:\"\n"
        "    3000  Prefixes description with \"Warning:\"\n"
        "    4000  Prefixes description with \"Error:\"\n\n"
        "Optional parameters:\n"
        "<source>   : (default: DebuggerExtensions)\n"
        "<id>       : 0, 1000, 2000, 3000, 4000, etc... (default: 0)\n"
        "<category> : None (default: 0), Devices (1), Disk (2), Printers "
          "(3),\n"
        "             Services (4), Shell (5), System_Event (6), Network "
          "(7)\n"
        "<type>     : Success (default: 0), Error (1), Warning (2), "
        "Information (4),\n"
        "             Audit_Success (8), or Audit_Failure (16)\n"
        "<message>  : Text message to add to description\n";
    const CHAR cszDefaultSource[] = "DebuggerExtensions";
    
    INIT_API();

    // Initialize defaults
    ZeroMemory(szParamValue, sizeof(szParamValue));
    CopyString(szSource, cszDefaultSource, sizeof(szSource));
    
    if (args)
    {
        SKIP_WSPACE(args);
    }
    
    if (!args || !args[0] ||
        !strncmp(args, "-h", 2) ||
        !strncmp(args, "-?", 2))
    {
        Status = E_INVALIDARG;
        ExtErr(cszUsage);
        goto Exit;
    }

    // Parse args
    while (*args)
    {
        SKIP_WSPACE(args);

        // Check for optional argument options to appear first
        if (('-' == *args) || ('/' == *args))
        {
            CHAR ch = *(++args); // Get next char + advance arg ptr
            ++args; // Skip one more char
            
            CHAR *szEndOfValue = NULL; // Ptr to last char in value
            size_t cchValue = 0; // Count of chars in value
            
            SKIP_WSPACE(args); // Advance to start of param value

            // Parameter value is delimited by next space in string
            szEndOfValue = strchr(args, ' ');
            if (NULL == szEndOfValue)
            {
                // copy to end of line
                CopyString(szParamValue, args, sizeof(szParamValue));
                args += strlen(args);
            }
            else
            {
                cchValue = szEndOfValue - args;
                if (cchValue < sizeof(szParamValue))
                {
                    // copy next N chars
                    CopyString(szParamValue, args, cchValue+1);
                    args += cchValue;
                }
                else
                {
                    Status = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                    ExtErr("ERROR: Argument string too long. Aborting.\n");
                    goto Exit;
                }
            }

            switch (ch)
            {
                case 's': // Source (string)
                    ExtVerb("Setting Source...\n");
                    CopyString(szSource, szParamValue, sizeof(szSource));
                    break;
                case 'e': // Event ID (number or string)
                    ExtVerb("Setting Event ID...\n");
                    if (!_strnicmp(szParamValue, "0x", 2))
                    {
                        dwEventID = strtoul(szParamValue, NULL, 16);
                    }
                    else
                    {
                        dwEventID = strtoul(szParamValue, NULL, 10);
                    }
                    break;
                case 'c': // Event Category (number or string)
                    ExtVerb("Setting Category...\n");
                    if (!_strnicmp(szParamValue, "None", 4))
                    {
                        wEventCategory = 0;
                    }
                    else if (!_strnicmp(szParamValue, "Devices", 7))
                    {
                        wEventCategory = 1;
                    }
                    else if (!_strnicmp(szParamValue, "Disk", 4))
                    {
                        wEventCategory = 2;
                    }
                    else if (!_strnicmp(szParamValue, "Printers", 8))
                    {
                        wEventCategory = 3;
                    }
                    else if (!_strnicmp(szParamValue, "Services", 8))
                    {
                        wEventCategory = 4;
                    }
                    else if (!_strnicmp(szParamValue, "Shell", 5))
                    {
                        wEventCategory = 5;
                    }
                    else if (!_strnicmp(szParamValue, "System_Event", 12))
                    {
                        wEventCategory = 6;
                    }
                    else if (!_strnicmp(szParamValue, "Network", 7))
                    {
                        wEventCategory = 7;
                    }
                    else
                    {
                        wEventCategory = (WORD)strtoul(szParamValue,
                                                       NULL, 10);
                    }
                    break;
                case 't': // Event Type (number or string)
                    ExtVerb("Setting Event Type...\n");
                    if (!_strnicmp(szParamValue, "Success", 7))
                    {
                        wEventType = EVENTLOG_SUCCESS;
                    }
                    else if (!_strnicmp(szParamValue, "Error", 5))
                    {
                        wEventType = EVENTLOG_ERROR_TYPE;
                    }
                    else if (!_strnicmp(szParamValue, "Warning", 7))
                    {
                        wEventType = EVENTLOG_WARNING_TYPE;
                    }
                    else if (!_strnicmp(szParamValue, "Information", 11))
                    {
                        wEventType = EVENTLOG_INFORMATION_TYPE;
                    }
                    else if (!_strnicmp(szParamValue, "Audit_Success", 13))
                    {
                        wEventType = EVENTLOG_AUDIT_SUCCESS;
                    }
                    else if (!_strnicmp(szParamValue, "Audit_Failure", 13))
                    {
                        wEventType = EVENTLOG_AUDIT_FAILURE;
                    }
                    else
                    {
                        wEventType = (WORD)strtoul(szParamValue, NULL, 10);
                    }
                    break;
                default:
                    Status = E_INVALIDARG;
                    ExtErr("Invalid arg '-%c' specified\n", *args);
                    ExtErr(cszUsage);
                    goto Exit;
                    break;
            }
            
            ZeroMemory(szParamValue, sizeof(szParamValue)); // reset
        }
        else // Everything to end of line is message string
        {
            SKIP_WSPACE(args);
            cszMessage = args;
            args += strlen(args);
        }
        
    }

    // Fix defaults for DebuggerExtensions events when wEventType not set
    if (!strcmp(szSource, cszDefaultSource) && (0 == wEventType))
    {
        if ((EVENT_MSG_GENERIC == dwEventID) ||
            (EVENT_MSG_INFORMATIONAL == dwEventID))
        {
            wEventType = EVENTLOG_INFORMATION_TYPE;
        }
        else if (EVENT_MSG_SUCCESS == dwEventID)
        {
            wEventType = EVENTLOG_SUCCESS;
        }
        else if (EVENT_MSG_WARNING == dwEventID)
        {
            wEventType = EVENTLOG_WARNING_TYPE;
        }
        else if (EVENT_MSG_ERROR == dwEventID)
        {
            wEventType = EVENTLOG_ERROR_TYPE;
        }
    }
    
    // Get a handle to the NT application log
    hEventSource = RegisterEventSource(NULL, szSource);
    if (!hEventSource)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to open event log, 0x%08X\n", Status);
        goto Exit;
    }

    if (!ReportEvent(hEventSource, // event log handle
            wEventType,     // event type
            wEventCategory, // category
            dwEventID,      // event identifier
            NULL,           // no user security identifier
            1,              // one substitution string
            0,              // no data
            &cszMessage,    // pointer to string array 
            NULL))          // pointer to data
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to report event, 0x%08X\n", Status);
        goto Exit;
    }

    Status = S_OK;

    // Output format similar to copy to clipboard format in event viewer
    ExtOut("Event Type:\t%s (%u)\n",
              (wEventType <= 16)
                  ? g_pcszEventType[wEventType]
                  : "None",
              wEventType);
    ExtOut("Event Source:\t%s\n", szSource);
    ExtOut("Event Category:\t%s (%u)\n",
              (!strcmp(szSource, cszDefaultSource) && wEventCategory <= 7)
                  ? g_pcszAppEventCategory[wEventCategory]
                  : "",
              wEventCategory);
    ExtOut("Event ID:\t%u\n", dwEventID);
    ExtOut("Description:\n%s\n", cszMessage);
    ExtVerb("Event successfully written.\n");

 Exit:
    if (hEventSource)
    {
        DeregisterEventSource(hEventSource); 
    }
    EXIT_API();
    return Status;
}

//----------------------------------------------------------------------------
//
// Debugger extension(s) implementation
//
//----------------------------------------------------------------------------


DECLARE_API( evlog )
/*++

Routine Description:

    This is the function exported through the uext extension interface.  It
    is used to delegate the real work to the extension command specified as
    an  argument.

    All event log related commands can be combined as sub-commands under this
    one !evlog command.
    
Arguments:

    Client  - Pointer to IDebugClient passed to !evlog extension
              [not used by this command]
    args    - Pointer to command line arguments passed to this command from
              !evlog extension
    
Return Value:

    E_INVALIDARG if invalid argument syntax detected
    ERROR_BUFFER_OVERFLOW if argument length too long
    GetLastError() converted to HRESULT otherwise

--*/
{
    CHAR *szEndOfValue = NULL; // Ptr to last char in value
    size_t cchValue = 0; // Count of chars in value
    CHAR szParamValue[MAX_PATH];
    const CHAR cszUsage[] = "Usage:\n"
        "The following Event Log commands are available:\n\n"
        "!evlog             Display this help message\n"
        "!evlog addsource   Adds event source entry to registry\n"
        "!evlog backup      Makes backup of event log\n"
        "!evlog clear       Clears and creates backup of event log\n"
        "!evlog info        Displays summary info for event log\n"
        "!evlog option      Sets and clears cached option settings used "
          "during read\n"
        "!evlog read        Reads event records from event log\n"
        "!evlog report      Writes event records to event log\n\n"
        "Try command with -? or no parameters to see help.\n";

    INIT_API();
    
    if (args)
    {
        SKIP_WSPACE(args);
    }
    
    if (!args || !args[0] ||
        !strncmp(args, "-h", 2) ||
        !strncmp(args, "-?", 2))
    {
        Status = E_INVALIDARG;
        ExtErr(cszUsage);
        goto Exit;
    }
            
    // whitespace already skipped...
    ZeroMemory(szParamValue, sizeof(szParamValue));
    
    // Parameter value (command) is delimited by next space in string
    szEndOfValue = strchr(args, ' ');
    if (NULL == szEndOfValue)
    {
        // copy to end of line
        CopyString(szParamValue, args, sizeof(szParamValue));
        args += strlen(args);
    }
    else
    {
        cchValue = szEndOfValue - args;
        if (cchValue < sizeof(szParamValue))
        {
            // copy next N chars
            CopyString(szParamValue, args, cchValue+1);
            args += cchValue;
        }
        else
        {
            Status = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            ExtErr("ERROR: Argument string too long. Aborting.\n");
            goto Exit;
        }

        ++args; // skip space
    }

    if (!_stricmp(szParamValue, "addsource"))
    {
        Status = EvLogAddSource(Client, args);
    }
    else if (!_stricmp(szParamValue, "backup"))
    {
        Status = EvLogBackup(Client, args);
    }
    else if (!_stricmp(szParamValue, "option"))
    {
        Status = EvLogOption(Client, args);
    }
    else if (!_stricmp(szParamValue, "clear"))
    {
        Status = EvLogClear(Client, args);
    }
    else if (!_stricmp(szParamValue, "info"))
    {
        Status = EvLogInfo(Client, args);
    }
    else if (!_stricmp(szParamValue, "read"))
    {
        Status = EvLogRead(Client, args);
    }
    else if (!_stricmp(szParamValue, "report"))
    {
        Status = EvLogReport(Client, args);
    }
    else
    {
        Status = E_INVALIDARG;
        ExtErr("Invalid command '%s' specified\n", szParamValue);
        ExtErr(cszUsage);
        goto Exit;
    }

    // do not set Status to S_OK here, it is returned above

Exit:
    EXIT_API();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\uextdll\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <windows.h>
#include <wdbgexts.h>
#include <cmnutil.hpp>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbgeng.h>
#include <dllimp.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES2   g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

extern ULONG64  STeip;
extern ULONG64  STebp;
extern ULONG64  STesp;
extern ULONG64  EXPRLastDump;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...);
// Error output.
void __cdecl
ExtErr(PCSTR Format, ...);
// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...);
// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...);

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\uextdll\uext.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    exts.cpp

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES2   g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces2),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &Qualifier)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

DECLARE_API( help )
{

    dprintf("evlog [Option [-?]]          - Allows operations on the host event log\n");
    dprintf("handle [Handle [UMFlags [TypeName]]] - Display info about open handles\n");
    dprintf("help                         - Show this help\n");
    dprintf("vadump [-v]                  - Display all virtual memory allocation ranges\n");
    dprintf("                               and their corresponding protection info\n");
    dprintf("vprot [Address]              - Display virtual memory protection info\n");

    //dprintf("uniqstack [b,v,p,n]        - Like debugger's built-in ~* k [b,v,p,n], but\n"
    //        "                             this will exclude stacks that look like other\n"
    //        "                             stacks already printed.\n");

    dprintf("\nType \".hh [command]\" for more detailed help\n");

    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\uextdll\uniqstack.cpp ===
// Removes duplicate call stacks (useful for thread pools,
// when there are many threads all waiting for an event).
//
// Author: spenlow
// Revisions:
// 2002.04.07 martinc   Removed dead code

#include "precomp.h"
#pragma hdrstop

#include <malloc.h>
#include <set>
#include <string>


class Frames
{
public:
    Frames (DEBUG_STACK_FRAME* rg, SIZE_T count)
        : m_rg (new DEBUG_STACK_FRAME [count]), m_count (count)
    {
        if (m_rg != NULL)
        {
            memcpy (m_rg, rg, count * sizeof (m_rg [0]));
        }
    }

    Frames (const Frames& orig)
        : m_rg (new DEBUG_STACK_FRAME [orig.m_count]), m_count (orig.m_count)
    {
        if (m_rg != NULL)
        {
            memcpy (m_rg, orig.m_rg, m_count * sizeof (m_rg [0]));
        }
    }

    ~Frames()
    {
        delete[] m_rg;
    }

    bool
    operator<(const Frames& other) const
    {
        int cmp = 0;

        for (SIZE_T i = 0; i < min(m_count, other.m_count); ++i)
        {
            cmp = m_rg[i].InstructionOffset - other.m_rg[i].InstructionOffset;
            if (cmp != 0)
                break;
        }

        if (cmp == 0)
        {
            cmp = m_count - other.m_count;
        }

        return cmp < 0;
    }

private:
    operator=(const Frames&);

    DEBUG_STACK_FRAME*  m_rg;
    SIZE_T              m_count;
};

//  uniqstack
//
//
//  Implementation Notes:
//      I'm too lazy to do return value checking all over the place like a moron
//      so I throw C++ exceptions on any error and use auto classes to clean stuff up.
//
HRESULT CALLBACK
uniqstack(PDEBUG_CLIENT Client, PCSTR args)
{
    PDEBUG_EXTENSION_CALL   pfn = uniqstack;
    IDebugControl*          pDbgCtrl = NULL;
    IDebugSystemObjects*    pDbgSys = NULL;
    const ULONG             threadIdInvalid = ~0;
    ULONG                   initialThreadId = 0;
    ULONG                   eventThreadId = 0;
    ULONG                   cthreads = 0;
    ULONG*                  rgThreadIds = NULL;
    DEBUG_STACK_FRAME       rgFrames [100];
    std::set< Frames >      framesSeen;
    std::set< ULONG >       dups;
    std::string             str;
    ULONG                   StackTraceFlags = 0;
    ULONG                   sysProcessId = 0;

    Client->QueryInterface (__uuidof (IDebugSystemObjects), (void**) &pDbgSys);
    Client->QueryInterface (__uuidof (IDebugControl), (void**) &pDbgCtrl);

    //  In argument parsing, only allow one type of b,v,p but user may add in n.

    for (SIZE_T ich = 0; args[ich] != '\0'; ++ich)
    {
        CHAR    ch = args[ich];

        if (ch == 'b' || ch == 'B')
        {
            StackTraceFlags = DEBUG_STACK_ARGUMENTS | (StackTraceFlags & DEBUG_STACK_FRAME_NUMBERS);
            if (pDbgCtrl->IsPointer64Bit () == S_OK)
            {
                StackTraceFlags |= DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY;
            }
        }
        else if (ch == 'v' || ch == 'V')
        {
            StackTraceFlags = DEBUG_STACK_FUNCTION_INFO | DEBUG_STACK_ARGUMENTS | DEBUG_STACK_NONVOLATILE_REGISTERS | (StackTraceFlags & DEBUG_STACK_FRAME_NUMBERS);
        }
        else if (ch == 'p' || ch == 'P')
        {
            StackTraceFlags = DEBUG_STACK_PARAMETERS | (StackTraceFlags & DEBUG_STACK_FRAME_NUMBERS);
        }
        else if (ch == 'n' || ch == 'N')
        {
            StackTraceFlags |= DEBUG_STACK_FRAME_NUMBERS;
        }
    }

    pDbgSys->GetCurrentThreadId (&initialThreadId);
    if (S_OK != pDbgSys->GetEventThread (&eventThreadId))
    {
        eventThreadId = threadIdInvalid;
    }
    pDbgSys->GetNumberThreads (&cthreads);
    pDbgSys->GetCurrentProcessSystemId(&sysProcessId);

    rgThreadIds = (ULONG*)_alloca (sizeof (rgThreadIds [0]) * cthreads);

    pDbgSys->GetThreadIdsByIndex (0, cthreads, rgThreadIds, NULL);
    for (ULONG ithread = 0; ithread < cthreads; ++ithread)
    {
        pDbgSys->SetCurrentThreadId (rgThreadIds [ithread]);

        ULONG   cFramesFilled = 0;
        pDbgCtrl->GetStackTrace (0, 0, 0, rgFrames, sizeof (rgFrames) / sizeof (rgFrames [0]), &cFramesFilled);

        Frames  fr(rgFrames, cFramesFilled);

        std::set< Frames >::iterator    i = framesSeen.find (fr);

        if (i == framesSeen.end ())
        {
            framesSeen.insert(fr);

            CHAR    status;

            if (initialThreadId == rgThreadIds [ithread])
            {
                status = '.';
            }
            else if (eventThreadId == rgThreadIds [ithread])
            {
                status = '#';
            }
            else
            {
                status = ' ';
            }
            ULONG   sysThreadId;
            ULONG64 teb;
            pDbgSys->GetCurrentThreadSystemId(&sysThreadId);
            pDbgSys->GetCurrentThreadDataOffset(&teb);

            dprintf ("\n%c%3ld  id: 0x%lx.0x%lx   Teb 0x%I64x\n",
                status,
                rgThreadIds [ithread],
                sysProcessId,
                sysThreadId,
                teb
                );

            pDbgCtrl->OutputStackTrace (
                DEBUG_OUTCTL_ALL_CLIENTS |   // Flags on what to do with output
                DEBUG_OUTCTL_OVERRIDE_MASK |
                DEBUG_OUTCTL_NOT_LOGGED,
                rgFrames,
                cFramesFilled,
                DEBUG_STACK_COLUMN_NAMES |
                DEBUG_STACK_FRAME_ADDRESSES |
                DEBUG_STACK_SOURCE_LINE |
                StackTraceFlags);
        }
        else
        {
            dups.insert(rgThreadIds [ithread]);
        }
    }

    for (std::set< ULONG >::iterator    i = dups.begin(); i != dups.end(); i++)
    {
        CHAR    sz[20];
        sprintf(sz, i == dups.begin() ? "%d" : ", %d", *i);
        str.append (sz);
    }

    dprintf ("\nTotal threads: %d, Duplicate callstacks: %d (windbg thread #s follow):\n", cthreads, dups.size());
    dprintf ("%s\n", str.c_str ());

    pDbgSys->SetCurrentThreadId (initialThreadId);

    pDbgSys->Release ();
    pDbgCtrl->Release ();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\uextdll\vmem.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    vmem.cpp

Abstract:

    !vprot using the debug engine virtual query interface.

--*/

#include "precomp.h"
#pragma hdrstop

#define PAGE_ALL (PAGE_READONLY|\
                  PAGE_READWRITE|\
                  PAGE_WRITECOPY|\
                  PAGE_EXECUTE|\
                  PAGE_EXECUTE_READ|\
                  PAGE_EXECUTE_READWRITE|\
                  PAGE_EXECUTE_WRITECOPY|\
                  PAGE_NOACCESS)

VOID
PrintPageFlags(DWORD Flags)
{
    switch(Flags & PAGE_ALL)
    {
    case PAGE_READONLY:
        dprintf("PAGE_READONLY");
        break;
    case PAGE_READWRITE:
        dprintf("PAGE_READWRITE");
        break;
    case PAGE_WRITECOPY:
        dprintf("PAGE_WRITECOPY");
        break;
    case PAGE_EXECUTE:
        dprintf("PAGE_EXECUTE");
        break;
    case PAGE_EXECUTE_READ:
        dprintf("PAGE_EXECUTE_READ");
        break;
    case PAGE_EXECUTE_READWRITE:
        dprintf("PAGE_EXECUTE_READWRITE");
        break;
    case PAGE_EXECUTE_WRITECOPY:
        dprintf("PAGE_EXECUTE_WRITECOPY");
        break;
    case PAGE_NOACCESS:
        if ((Flags & ~PAGE_NOACCESS) == 0)
        {
            dprintf("PAGE_NOACCESS");
            break;
        } // else fall through
    default:
        dprintf("*** Invalid page protection ***\n");
        return;
    }

    if (Flags & PAGE_NOCACHE)
    {
        dprintf(" + PAGE_NOCACHE");
    }
    if (Flags & PAGE_GUARD)
    {
        dprintf(" + PAGE_GUARD");
    }
    dprintf("\n");
}

void
DumpMemBasicInfo(PMEMORY_BASIC_INFORMATION64 Basic,
                 BOOL Verbose)
{
    dprintf("BaseAddress:       %p\n", Basic->BaseAddress);
    if (Verbose)
    {
        dprintf("AllocationBase:    %p\n", Basic->AllocationBase);
        if (Basic->State != MEM_FREE ||
            Basic->AllocationProtect)
        {
            dprintf("AllocationProtect: %08x  ", Basic->AllocationProtect);
            PrintPageFlags(Basic->AllocationProtect);
        }
    }

    dprintf("RegionSize:        %p\n", Basic->RegionSize);
    dprintf("State:             %08x  ", Basic->State);
    switch(Basic->State)
    {
    case MEM_COMMIT:
        dprintf("MEM_COMMIT\n");
        break;
    case MEM_FREE:
        dprintf("MEM_FREE\n");
        break;
    case MEM_RESERVE:
        dprintf("MEM_RESERVE\n");
        break;
    default:
        dprintf("*** Invalid page state ***\n");
        break;
    }

    if (Basic->State != MEM_RESERVE ||
        Basic->Protect)
    {
        dprintf("Protect:           %08x  ", Basic->Protect);
        PrintPageFlags(Basic->Protect);
    }

    if (Basic->State != MEM_FREE ||
        Basic->Type)
    {
        dprintf("Type:              %08x  ", Basic->Type);
        switch(Basic->Type)
        {
        case MEM_IMAGE:
            dprintf("MEM_IMAGE\n");
            break;
        case MEM_MAPPED:
            dprintf("MEM_MAPPED\n");
            break;
        case MEM_PRIVATE:
            dprintf("MEM_PRIVATE\n");
            break;
        default:
            dprintf("*** Invalid page type ***\n");
            break;
        }
    }
}

DECLARE_API( vprot )
/*++

Routine Description:

    This debugger extension dumps the virtual memory info for the
    address specified.

Arguments:


Return Value:

--*/
{
    ULONG64 Address;
    MEMORY_BASIC_INFORMATION64 Basic;

    INIT_API();

    Address = GetExpression( args );

    if ((Status = g_ExtData->QueryVirtual(Address, &Basic)) != S_OK)
    {
        dprintf("vprot: QueryVirtual failed, error = 0x%08X\n", Status);
        goto Exit;
    }

    if (Basic.BaseAddress > Address ||
        Basic.BaseAddress + Basic.RegionSize <= Address)
    {
        dprintf("vprot: No containing memory region found.\n");
        goto Exit;
    }
    
    DumpMemBasicInfo(&Basic, TRUE);

 Exit:
    EXIT_API();
    return S_OK;
}

DECLARE_API( vadump )
{
    ULONG64 Address;
    MEMORY_BASIC_INFORMATION64 Basic;
    ULONG SessClass, SessQual;
    BOOL Verbose = FALSE; 

    INIT_API();

    for (;;)
    {
        while (*args == ' ' || *args == '\t')
        {
            args++;
        }
        if (*args != '-' && *args != '/')
        {
            break;
        }

        args++;
        switch(*args)
        {
        case 'v':
            Verbose = TRUE;
            break;
        default:
            ExtErr("Unknown option '%c'\n", *args);
            break;
        }
        args++;
    }
    
    if (g_ExtControl->GetDebuggeeType(&SessClass, &SessQual) != S_OK)
    {
        ExtErr("Unable to get debuggee type\n");
        goto Exit;
    }
                      
    Address = 0;

    for (;;)
    {
        if ((Status = g_ExtData->QueryVirtual(Address, &Basic)) != S_OK)
        {
            break;
        }

        if (SessQual != DEBUG_USER_WINDOWS_SMALL_DUMP)
        {
            // Full dumps contain the real memory info
            // so show all of the information.
            DumpMemBasicInfo(&Basic, Verbose);
        }
        else
        {
            // Minidumps don't contain extended memory
            // info so just show the region addresses.
            dprintf("BaseAddress: %p\n", Basic.BaseAddress);
            dprintf("RegionSize:  %p\n", Basic.RegionSize);
        }

        dprintf("\n");
        Address = Basic.BaseAddress + Basic.RegionSize;
    }

 Exit:
    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\sources.inc ===
!include ..\makefile.inc

# Old decem had encrypted mnemonics which it
# modified at startup so string pooling and read-only
# strings had to be turned off.  This is no longer
# necessary.
!if 0
NO_READONLY_STRINGS = 1
NO_STRING_POOLING = 1
!endif

386_STDCALL = 0
        
DISASM_INC = disem.h
DECODER_INC = decem.h

XVER_MAJOR = 9
XVER_MINOR = 60                 ### 2 digits, 09 maybe a problem ?!
API_MAJOR  = 9
API_MINOR  = 6

VFLAG = -DDISASM_NAME=\"$(DISASM_INC)\"                        \
        -DDECODER_NAME=\"$(DECODER_INC)\"                      \
        -DVER=$(VER) -DVER_STR=$(VER) -DAPI_MINOR=$(API_MINOR) \
        -DAPI_MAJOR=$(API_MAJOR) -DXVER_MAJOR=$(XVER_MAJOR)    \
        -DXVER_MINOR=$(XVER_MINOR)

INCLUDES = $(IA64_DIS_INC);..\iel

USE_MSVCRT = 1

TARGETLIBS = \
        ..\iel\$O\iel.lib\
        $(SDK_LIB_PATH)\kernel32.lib

UMTYPE = console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\makefile.inc ===
EMDBDIR = ..\emdb
PERL = perl
PERL_INCLIST = -I $(IA64_DIS_INC) -I $(EMDBDIR)
EEXT = .exe
MHDR = $(PERL) $(IA64_DIS_INC)\makehdr.pl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\decision_tree.c ===
/*** decision_tree.c ***/

#include "decision_tree.h"

Node_t em_decision_tree[] = {
/*00000*/     {80, 33, 3},
/*00001*/     {424, 33, 3},
/*00002*/     {476, 33, 1},
/*00003*/     {594, 27, 6},
/*00004*/     {850, 27, 9},
/*00005*/     {0, -1, -1},
/*00006*/     {1362, 33, 3},
/*00007*/     {1434, 33, 1},
/*00008*/     {1572, 32, 4},
/*00009*/     {0, -1, -1},
/*00010*/     {0, -1, -1},
/*00011*/     {0, -1, -1},
/*00012*/     {0, -1, -1},
/*00013*/     {1620, 27, 6},
/*00014*/     {0, -1, -1},
/*00015*/     {0, -1, -1},
/*00016*/     {0, -1, -1},
/*00017*/     {0, -1, -1},
/*00018*/     {1, -1, -1},
/*00019*/     {0, -1, -1},
/*00020*/     {173, -1, -1},
/*00021*/     {1828, 30, 7},
/*00022*/     {2628, 33, 4},
/*00023*/     {2676, 33, 3},
/*00024*/     {0, -1, -1},
/*00025*/     {2844, 33, 3},
/*00026*/     {2880, 28, 8},
/*00027*/     {3136, 12, 1},
/*00028*/     {3138, 33, 3},
/*00029*/     {0, -1, -1},
/*00030*/     {0, -1, -1},
/*00031*/     {3162, 30, 7},
/*00032*/     {0, -1, -1},
/*00033*/     {1, -1, -1},
/*00034*/     {3802, 20, 1},
/*00035*/     {3804, 32, 5},
/*00036*/     {4008, 28, 8},
/*00037*/     {0, -1, -1},
/*00038*/     {4264, 0, 6},
/*00039*/     {0, -1, -1},
/*00040*/     {4336, 33, 3},
/*00041*/     {4540, 33, 3},
/*00042*/     {4744, 34, 3},
/*00043*/     {0, -1, -1},
/*00044*/     {0, -1, -1},
/*00045*/     {20, -1, -1},
/*00046*/     {20, -1, -1},
/*00047*/     {4752, 34, 3},
/*00048*/     {0, -1, -1},
/*00049*/     {0, -1, -1},
/*00050*/     {0, -1, -1},
/*00051*/     {0, -1, -1},
/*00052*/     {4760, 34, 3},
/*00053*/     {0, -1, -1},
/*00054*/     {0, -1, -1},
/*00055*/     {0, -1, -1},
/*00056*/     {0, -1, -1},
/*00057*/     {4768, 34, 3},
/*00058*/     {0, -1, -1},
/*00059*/     {0, -1, -1},
/*00060*/     {4776, 33, 3},
/*00061*/     {4816, 33, 3},
/*00062*/     {4856, 34, 3},
/*00063*/     {0, -1, -1},
/*00064*/     {4864, 33, 3},
/*00065*/     {4952, 33, 3},
/*00066*/     {4992, 33, 3},
/*00067*/     {5032, 34, 3},
/*00068*/     {0, -1, -1},
/*00069*/     {5040, 33, 3},
/*00070*/     {5064, 33, 3},
/*00071*/     {5104, 33, 3},
/*00072*/     {5144, 36, 1},
/*00073*/     {0, -1, -1},
/*00074*/     {0, -1, -1},
/*00075*/     {0, -1, -1},
/*00076*/     {0, -1, -1},
/*00077*/     {0, -1, -1},
/*00078*/     {0, -1, -1},
/*00079*/     {0, -1, -1},
/*00080*/     {88, 27, 6},
/*00081*/     {192, -1, -1},
/*00082*/     {207, -1, -1},
/*00083*/     {206, -1, -1},
/*00084*/     {0, -1, -1},
/*00085*/     {0, -1, -1},
/*00086*/     {0, -1, -1},
/*00087*/     {152, 20, 4},
/*00088*/     {190, -1, -1},
/*00089*/     {191, -1, -1},
/*00090*/     {0, -1, -1},
/*00091*/     {0, -1, -1},
/*00092*/     {0, -1, -1},
/*00093*/     {0, -1, -1},
/*00094*/     {0, -1, -1},
/*00095*/     {0, -1, -1},
/*00096*/     {0, -1, -1},
/*00097*/     {0, -1, -1},
/*00098*/     {211, -1, -1},
/*00099*/     {0, -1, -1},
/*00100*/     {0, -1, -1},
/*00101*/     {0, -1, -1},
/*00102*/     {0, -1, -1},
/*00103*/     {0, -1, -1},
/*00104*/     {213, -1, -1},
/*00105*/     {214, -1, -1},
/*00106*/     {215, -1, -1},
/*00107*/     {0, -1, -1},
/*00108*/     {216, -1, -1},
/*00109*/     {217, -1, -1},
/*00110*/     {218, -1, -1},
/*00111*/     {0, -1, -1},
/*00112*/     {219, -1, -1},
/*00113*/     {220, -1, -1},
/*00114*/     {0, -1, -1},
/*00115*/     {0, -1, -1},
/*00116*/     {221, -1, -1},
/*00117*/     {222, -1, -1},
/*00118*/     {0, -1, -1},
/*00119*/     {0, -1, -1},
/*00120*/     {0, -1, -1},
/*00121*/     {0, -1, -1},
/*00122*/     {0, -1, -1},
/*00123*/     {0, -1, -1},
/*00124*/     {0, -1, -1},
/*00125*/     {0, -1, -1},
/*00126*/     {0, -1, -1},
/*00127*/     {0, -1, -1},
/*00128*/     {0, -1, -1},
/*00129*/     {0, -1, -1},
/*00130*/     {210, -1, -1},
/*00131*/     {0, -1, -1},
/*00132*/     {0, -1, -1},
/*00133*/     {0, -1, -1},
/*00134*/     {0, -1, -1},
/*00135*/     {0, -1, -1},
/*00136*/     {208, -1, -1},
/*00137*/     {205, -1, -1},
/*00138*/     {212, -1, -1},
/*00139*/     {209, -1, -1},
/*00140*/     {0, -1, -1},
/*00141*/     {0, -1, -1},
/*00142*/     {0, -1, -1},
/*00143*/     {0, -1, -1},
/*00144*/     {0, -1, -1},
/*00145*/     {0, -1, -1},
/*00146*/     {0, -1, -1},
/*00147*/     {0, -1, -1},
/*00148*/     {0, -1, -1},
/*00149*/     {0, -1, -1},
/*00150*/     {0, -1, -1},
/*00151*/     {0, -1, -1},
/*00152*/     {168, 9, 4},
/*00153*/     {184, 9, 4},
/*00154*/     {200, 9, 4},
/*00155*/     {216, 9, 4},
/*00156*/     {232, 9, 4},
/*00157*/     {248, 9, 4},
/*00158*/     {264, 9, 4},
/*00159*/     {280, 9, 4},
/*00160*/     {296, 9, 4},
/*00161*/     {312, 9, 4},
/*00162*/     {328, 9, 4},
/*00163*/     {344, 9, 4},
/*00164*/     {360, 9, 4},
/*00165*/     {376, 9, 4},
/*00166*/     {392, 9, 4},
/*00167*/     {408, 9, 4},
/*00168*/     {193, -1, -1},
/*00169*/     {0, -1, -1},
/*00170*/     {0, -1, -1},
/*00171*/     {0, -1, -1},
/*00172*/     {0, -1, -1},
/*00173*/     {0, -1, -1},
/*00174*/     {0, -1, -1},
/*00175*/     {0, -1, -1},
/*00176*/     {0, -1, -1},
/*00177*/     {0, -1, -1},
/*00178*/     {0, -1, -1},
/*00179*/     {0, -1, -1},
/*00180*/     {0, -1, -1},
/*00181*/     {0, -1, -1},
/*00182*/     {0, -1, -1},
/*00183*/     {0, -1, -1},
/*00184*/     {195, -1, -1},
/*00185*/     {0, -1, -1},
/*00186*/     {0, -1, -1},
/*00187*/     {0, -1, -1},
/*00188*/     {0, -1, -1},
/*00189*/     {0, -1, -1},
/*00190*/     {0, -1, -1},
/*00191*/     {0, -1, -1},
/*00192*/     {0, -1, -1},
/*00193*/     {0, -1, -1},
/*00194*/     {0, -1, -1},
/*00195*/     {0, -1, -1},
/*00196*/     {0, -1, -1},
/*00197*/     {0, -1, -1},
/*00198*/     {0, -1, -1},
/*00199*/     {0, -1, -1},
/*00200*/     {197, -1, -1},
/*00201*/     {0, -1, -1},
/*00202*/     {0, -1, -1},
/*00203*/     {0, -1, -1},
/*00204*/     {0, -1, -1},
/*00205*/     {0, -1, -1},
/*00206*/     {0, -1, -1},
/*00207*/     {0, -1, -1},
/*00208*/     {0, -1, -1},
/*00209*/     {0, -1, -1},
/*00210*/     {0, -1, -1},
/*00211*/     {0, -1, -1},
/*00212*/     {0, -1, -1},
/*00213*/     {0, -1, -1},
/*00214*/     {0, -1, -1},
/*00215*/     {0, -1, -1},
/*00216*/     {195, -1, -1},
/*00217*/     {0, -1, -1},
/*00218*/     {0, -1, -1},
/*00219*/     {0, -1, -1},
/*00220*/     {0, -1, -1},
/*00221*/     {0, -1, -1},
/*00222*/     {0, -1, -1},
/*00223*/     {0, -1, -1},
/*00224*/     {0, -1, -1},
/*00225*/     {0, -1, -1},
/*00226*/     {0, -1, -1},
/*00227*/     {0, -1, -1},
/*00228*/     {0, -1, -1},
/*00229*/     {0, -1, -1},
/*00230*/     {0, -1, -1},
/*00231*/     {0, -1, -1},
/*00232*/     {199, -1, -1},
/*00233*/     {0, -1, -1},
/*00234*/     {0, -1, -1},
/*00235*/     {0, -1, -1},
/*00236*/     {0, -1, -1},
/*00237*/     {0, -1, -1},
/*00238*/     {0, -1, -1},
/*00239*/     {0, -1, -1},
/*00240*/     {0, -1, -1},
/*00241*/     {0, -1, -1},
/*00242*/     {0, -1, -1},
/*00243*/     {0, -1, -1},
/*00244*/     {0, -1, -1},
/*00245*/     {0, -1, -1},
/*00246*/     {0, -1, -1},
/*00247*/     {0, -1, -1},
/*00248*/     {201, -1, -1},
/*00249*/     {0, -1, -1},
/*00250*/     {0, -1, -1},
/*00251*/     {0, -1, -1},
/*00252*/     {0, -1, -1},
/*00253*/     {0, -1, -1},
/*00254*/     {0, -1, -1},
/*00255*/     {0, -1, -1},
/*00256*/     {0, -1, -1},
/*00257*/     {0, -1, -1},
/*00258*/     {0, -1, -1},
/*00259*/     {0, -1, -1},
/*00260*/     {0, -1, -1},
/*00261*/     {0, -1, -1},
/*00262*/     {0, -1, -1},
/*00263*/     {0, -1, -1},
/*00264*/     {203, -1, -1},
/*00265*/     {0, -1, -1},
/*00266*/     {0, -1, -1},
/*00267*/     {0, -1, -1},
/*00268*/     {0, -1, -1},
/*00269*/     {0, -1, -1},
/*00270*/     {0, -1, -1},
/*00271*/     {0, -1, -1},
/*00272*/     {0, -1, -1},
/*00273*/     {0, -1, -1},
/*00274*/     {0, -1, -1},
/*00275*/     {0, -1, -1},
/*00276*/     {0, -1, -1},
/*00277*/     {0, -1, -1},
/*00278*/     {0, -1, -1},
/*00279*/     {0, -1, -1},
/*00280*/     {201, -1, -1},
/*00281*/     {0, -1, -1},
/*00282*/     {0, -1, -1},
/*00283*/     {0, -1, -1},
/*00284*/     {0, -1, -1},
/*00285*/     {0, -1, -1},
/*00286*/     {0, -1, -1},
/*00287*/     {0, -1, -1},
/*00288*/     {0, -1, -1},
/*00289*/     {0, -1, -1},
/*00290*/     {0, -1, -1},
/*00291*/     {0, -1, -1},
/*00292*/     {0, -1, -1},
/*00293*/     {0, -1, -1},
/*00294*/     {0, -1, -1},
/*00295*/     {0, -1, -1},
/*00296*/     {194, -1, -1},
/*00297*/     {0, -1, -1},
/*00298*/     {0, -1, -1},
/*00299*/     {0, -1, -1},
/*00300*/     {0, -1, -1},
/*00301*/     {0, -1, -1},
/*00302*/     {0, -1, -1},
/*00303*/     {0, -1, -1},
/*00304*/     {0, -1, -1},
/*00305*/     {0, -1, -1},
/*00306*/     {0, -1, -1},
/*00307*/     {0, -1, -1},
/*00308*/     {0, -1, -1},
/*00309*/     {0, -1, -1},
/*00310*/     {0, -1, -1},
/*00311*/     {0, -1, -1},
/*00312*/     {196, -1, -1},
/*00313*/     {0, -1, -1},
/*00314*/     {0, -1, -1},
/*00315*/     {0, -1, -1},
/*00316*/     {0, -1, -1},
/*00317*/     {0, -1, -1},
/*00318*/     {0, -1, -1},
/*00319*/     {0, -1, -1},
/*00320*/     {0, -1, -1},
/*00321*/     {0, -1, -1},
/*00322*/     {0, -1, -1},
/*00323*/     {0, -1, -1},
/*00324*/     {0, -1, -1},
/*00325*/     {0, -1, -1},
/*00326*/     {0, -1, -1},
/*00327*/     {0, -1, -1},
/*00328*/     {198, -1, -1},
/*00329*/     {0, -1, -1},
/*00330*/     {0, -1, -1},
/*00331*/     {0, -1, -1},
/*00332*/     {0, -1, -1},
/*00333*/     {0, -1, -1},
/*00334*/     {0, -1, -1},
/*00335*/     {0, -1, -1},
/*00336*/     {0, -1, -1},
/*00337*/     {0, -1, -1},
/*00338*/     {0, -1, -1},
/*00339*/     {0, -1, -1},
/*00340*/     {0, -1, -1},
/*00341*/     {0, -1, -1},
/*00342*/     {0, -1, -1},
/*00343*/     {0, -1, -1},
/*00344*/     {196, -1, -1},
/*00345*/     {0, -1, -1},
/*00346*/     {0, -1, -1},
/*00347*/     {0, -1, -1},
/*00348*/     {0, -1, -1},
/*00349*/     {0, -1, -1},
/*00350*/     {0, -1, -1},
/*00351*/     {0, -1, -1},
/*00352*/     {0, -1, -1},
/*00353*/     {0, -1, -1},
/*00354*/     {0, -1, -1},
/*00355*/     {0, -1, -1},
/*00356*/     {0, -1, -1},
/*00357*/     {0, -1, -1},
/*00358*/     {0, -1, -1},
/*00359*/     {0, -1, -1},
/*00360*/     {200, -1, -1},
/*00361*/     {0, -1, -1},
/*00362*/     {0, -1, -1},
/*00363*/     {0, -1, -1},
/*00364*/     {0, -1, -1},
/*00365*/     {0, -1, -1},
/*00366*/     {0, -1, -1},
/*00367*/     {0, -1, -1},
/*00368*/     {0, -1, -1},
/*00369*/     {0, -1, -1},
/*00370*/     {0, -1, -1},
/*00371*/     {0, -1, -1},
/*00372*/     {0, -1, -1},
/*00373*/     {0, -1, -1},
/*00374*/     {0, -1, -1},
/*00375*/     {0, -1, -1},
/*00376*/     {202, -1, -1},
/*00377*/     {0, -1, -1},
/*00378*/     {0, -1, -1},
/*00379*/     {0, -1, -1},
/*00380*/     {0, -1, -1},
/*00381*/     {0, -1, -1},
/*00382*/     {0, -1, -1},
/*00383*/     {0, -1, -1},
/*00384*/     {0, -1, -1},
/*00385*/     {0, -1, -1},
/*00386*/     {0, -1, -1},
/*00387*/     {0, -1, -1},
/*00388*/     {0, -1, -1},
/*00389*/     {0, -1, -1},
/*00390*/     {0, -1, -1},
/*00391*/     {0, -1, -1},
/*00392*/     {204, -1, -1},
/*00393*/     {0, -1, -1},
/*00394*/     {0, -1, -1},
/*00395*/     {0, -1, -1},
/*00396*/     {0, -1, -1},
/*00397*/     {0, -1, -1},
/*00398*/     {0, -1, -1},
/*00399*/     {0, -1, -1},
/*00400*/     {0, -1, -1},
/*00401*/     {0, -1, -1},
/*00402*/     {0, -1, -1},
/*00403*/     {0, -1, -1},
/*00404*/     {0, -1, -1},
/*00405*/     {0, -1, -1},
/*00406*/     {0, -1, -1},
/*00407*/     {0, -1, -1},
/*00408*/     {202, -1, -1},
/*00409*/     {0, -1, -1},
/*00410*/     {0, -1, -1},
/*00411*/     {0, -1, -1},
/*00412*/     {0, -1, -1},
/*00413*/     {0, -1, -1},
/*00414*/     {0, -1, -1},
/*00415*/     {0, -1, -1},
/*00416*/     {0, -1, -1},
/*00417*/     {0, -1, -1},
/*00418*/     {0, -1, -1},
/*00419*/     {0, -1, -1},
/*00420*/     {0, -1, -1},
/*00421*/     {0, -1, -1},
/*00422*/     {0, -1, -1},
/*00423*/     {0, -1, -1},
/*00424*/     {432, 27, 4},
/*00425*/     {0, -1, -1},
/*00426*/     {0, -1, -1},
/*00427*/     {0, -1, -1},
/*00428*/     {1051, -1, -1},
/*00429*/     {1052, -1, -1},
/*00430*/     {1053, -1, -1},
/*00431*/     {1054, -1, -1},
/*00432*/     {448, 31, 2},
/*00433*/     {452, 31, 2},
/*00434*/     {456, 31, 2},
/*00435*/     {460, 31, 2},
/*00436*/     {1106, -1, -1},
/*00437*/     {1107, -1, -1},
/*00438*/     {1108, -1, -1},
/*00439*/     {1109, -1, -1},
/*00440*/     {464, 31, 2},
/*00441*/     {0, -1, -1},
/*00442*/     {468, 31, 2},
/*00443*/     {0, -1, -1},
/*00444*/     {472, 31, 2},
/*00445*/     {0, -1, -1},
/*00446*/     {0, -1, -1},
/*00447*/     {0, -1, -1},
/*00448*/     {1078, -1, -1},
/*00449*/     {1055, -1, -1},
/*00450*/     {1056, -1, -1},
/*00451*/     {1059, -1, -1},
/*00452*/     {1079, -1, -1},
/*00453*/     {0, -1, -1},
/*00454*/     {0, -1, -1},
/*00455*/     {1060, -1, -1},
/*00456*/     {0, -1, -1},
/*00457*/     {1064, -1, -1},
/*00458*/     {1057, -1, -1},
/*00459*/     {0, -1, -1},
/*00460*/     {0, -1, -1},
/*00461*/     {1065, -1, -1},
/*00462*/     {1058, -1, -1},
/*00463*/     {1061, -1, -1},
/*00464*/     {0, -1, -1},
/*00465*/     {0, -1, -1},
/*00466*/     {1069, -1, -1},
/*00467*/     {0, -1, -1},
/*00468*/     {1063, -1, -1},
/*00469*/     {0, -1, -1},
/*00470*/     {0, -1, -1},
/*00471*/     {0, -1, -1},
/*00472*/     {1062, -1, -1},
/*00473*/     {0, -1, -1},
/*00474*/     {0, -1, -1},
/*00475*/     {0, -1, -1},
/*00476*/     {478, 27, 6},
/*00477*/     {586, 34, 3},
/*00478*/     {1552, -1, -1},
/*00479*/     {1553, -1, -1},
/*00480*/     {0, -1, -1},
/*00481*/     {0, -1, -1},
/*00482*/     {542, 34, 2},
/*00483*/     {546, 34, 2},
/*00484*/     {0, -1, -1},
/*00485*/     {0, -1, -1},
/*00486*/     {550, 34, 2},
/*00487*/     {0, -1, -1},
/*00488*/     {0, -1, -1},
/*00489*/     {0, -1, -1},
/*00490*/     {0, -1, -1},
/*00491*/     {0, -1, -1},
/*00492*/     {0, -1, -1},
/*00493*/     {0, -1, -1},
/*00494*/     {1488, -1, -1},
/*00495*/     {1489, -1, -1},
/*00496*/     {1490, -1, -1},
/*00497*/     {0, -1, -1},
/*00498*/     {554, 34, 2},
/*00499*/     {558, 34, 2},
/*00500*/     {562, 34, 2},
/*00501*/     {566, 34, 2},
/*00502*/     {570, 34, 2},
/*00503*/     {574, 34, 2},
/*00504*/     {578, 34, 2},
/*00505*/     {582, 34, 2},
/*00506*/     {1539, -1, -1},
/*00507*/     {0, -1, -1},
/*00508*/     {0, -1, -1},
/*00509*/     {0, -1, -1},
/*00510*/     {0, -1, -1},
/*00511*/     {0, -1, -1},
/*00512*/     {0, -1, -1},
/*00513*/     {0, -1, -1},
/*00514*/     {0, -1, -1},
/*00515*/     {0, -1, -1},
/*00516*/     {0, -1, -1},
/*00517*/     {0, -1, -1},
/*00518*/     {1496, -1, -1},
/*00519*/     {0, -1, -1},
/*00520*/     {0, -1, -1},
/*00521*/     {0, -1, -1},
/*00522*/     {1500, -1, -1},
/*00523*/     {1501, -1, -1},
/*00524*/     {1502, -1, -1},
/*00525*/     {1503, -1, -1},
/*00526*/     {0, -1, -1},
/*00527*/     {0, -1, -1},
/*00528*/     {0, -1, -1},
/*00529*/     {0, -1, -1},
/*00530*/     {1497, -1, -1},
/*00531*/     {1498, -1, -1},
/*00532*/     {1499, -1, -1},
/*00533*/     {0, -1, -1},
/*00534*/     {0, -1, -1},
/*00535*/     {1491, -1, -1},
/*00536*/     {1492, -1, -1},
/*00537*/     {1493, -1, -1},
/*00538*/     {1494, -1, -1},
/*00539*/     {1495, -1, -1},
/*00540*/     {0, -1, -1},
/*00541*/     {0, -1, -1},
/*00542*/     {1540, -1, -1},
/*00543*/     {1541, -1, -1},
/*00544*/     {1542, -1, -1},
/*00545*/     {1543, -1, -1},
/*00546*/     {1544, -1, -1},
/*00547*/     {1545, -1, -1},
/*00548*/     {1546, -1, -1},
/*00549*/     {1547, -1, -1},
/*00550*/     {1548, -1, -1},
/*00551*/     {1549, -1, -1},
/*00552*/     {1550, -1, -1},
/*00553*/     {1551, -1, -1},
/*00554*/     {1424, -1, -1},
/*00555*/     {1425, -1, -1},
/*00556*/     {1426, -1, -1},
/*00557*/     {1427, -1, -1},
/*00558*/     {1428, -1, -1},
/*00559*/     {1429, -1, -1},
/*00560*/     {1430, -1, -1},
/*00561*/     {1431, -1, -1},
/*00562*/     {1432, -1, -1},
/*00563*/     {1433, -1, -1},
/*00564*/     {1434, -1, -1},
/*00565*/     {1435, -1, -1},
/*00566*/     {1436, -1, -1},
/*00567*/     {1437, -1, -1},
/*00568*/     {1438, -1, -1},
/*00569*/     {1439, -1, -1},
/*00570*/     {1507, -1, -1},
/*00571*/     {1508, -1, -1},
/*00572*/     {1509, -1, -1},
/*00573*/     {1510, -1, -1},
/*00574*/     {1511, -1, -1},
/*00575*/     {1512, -1, -1},
/*00576*/     {1513, -1, -1},
/*00577*/     {1514, -1, -1},
/*00578*/     {1515, -1, -1},
/*00579*/     {1516, -1, -1},
/*00580*/     {1517, -1, -1},
/*00581*/     {1518, -1, -1},
/*00582*/     {1519, -1, -1},
/*00583*/     {1520, -1, -1},
/*00584*/     {1521, -1, -1},
/*00585*/     {1522, -1, -1},
/*00586*/     {1408, -1, -1},
/*00587*/     {1409, -1, -1},
/*00588*/     {1410, -1, -1},
/*00589*/     {1411, -1, -1},
/*00590*/     {1416, -1, -1},
/*00591*/     {1417, -1, -1},
/*00592*/     {1418, -1, -1},
/*00593*/     {1419, -1, -1},
/*00594*/     {1320, -1, -1},
/*00595*/     {0, -1, -1},
/*00596*/     {1312, -1, -1},
/*00597*/     {0, -1, -1},
/*00598*/     {1313, -1, -1},
/*00599*/     {1314, -1, -1},
/*00600*/     {0, -1, -1},
/*00601*/     {0, -1, -1},
/*00602*/     {1315, -1, -1},
/*00603*/     {1316, -1, -1},
/*00604*/     {0, -1, -1},
/*00605*/     {0, -1, -1},
/*00606*/     {1317, -1, -1},
/*00607*/     {1318, -1, -1},
/*00608*/     {0, -1, -1},
/*00609*/     {0, -1, -1},
/*00610*/     {1319, -1, -1},
/*00611*/     {0, -1, -1},
/*00612*/     {0, -1, -1},
/*00613*/     {0, -1, -1},
/*00614*/     {0, -1, -1},
/*00615*/     {0, -1, -1},
/*00616*/     {0, -1, -1},
/*00617*/     {0, -1, -1},
/*00618*/     {0, -1, -1},
/*00619*/     {0, -1, -1},
/*00620*/     {0, -1, -1},
/*00621*/     {0, -1, -1},
/*00622*/     {0, -1, -1},
/*00623*/     {0, -1, -1},
/*00624*/     {0, -1, -1},
/*00625*/     {0, -1, -1},
/*00626*/     {658, 33, 3},
/*00627*/     {762, 33, 3},
/*00628*/     {0, -1, -1},
/*00629*/     {0, -1, -1},
/*00630*/     {0, -1, -1},
/*00631*/     {0, -1, -1},
/*00632*/     {0, -1, -1},
/*00633*/     {0, -1, -1},
/*00634*/     {0, -1, -1},
/*00635*/     {0, -1, -1},
/*00636*/     {0, -1, -1},
/*00637*/     {0, -1, -1},
/*00638*/     {0, -1, -1},
/*00639*/     {0, -1, -1},
/*00640*/     {0, -1, -1},
/*00641*/     {0, -1, -1},
/*00642*/     {0, -1, -1},
/*00643*/     {0, -1, -1},
/*00644*/     {0, -1, -1},
/*00645*/     {0, -1, -1},
/*00646*/     {0, -1, -1},
/*00647*/     {0, -1, -1},
/*00648*/     {0, -1, -1},
/*00649*/     {0, -1, -1},
/*00650*/     {0, -1, -1},
/*00651*/     {0, -1, -1},
/*00652*/     {0, -1, -1},
/*00653*/     {0, -1, -1},
/*00654*/     {0, -1, -1},
/*00655*/     {0, -1, -1},
/*00656*/     {0, -1, -1},
/*00657*/     {0, -1, -1},
/*00658*/     {666, 6, 3},
/*00659*/     {678, 6, 3},
/*00660*/     {690, 6, 3},
/*00661*/     {702, 6, 3},
/*00662*/     {714, 6, 3},
/*00663*/     {726, 6, 3},
/*00664*/     {738, 6, 3},
/*00665*/     {750, 6, 3},
/*00666*/     {674, 12, 1},
/*00667*/     {676, 12, 1},
/*00668*/     {0, -1, -1},
/*00669*/     {0, -1, -1},
/*00670*/     {0, -1, -1},
/*00671*/     {0, -1, -1},
/*00672*/     {0, -1, -1},
/*00673*/     {0, -1, -1},
/*00674*/     {1232, -1, -1},
/*00675*/     {1233, -1, -1},
/*00676*/     {1248, -1, -1},
/*00677*/     {1249, -1, -1},
/*00678*/     {686, 12, 1},
/*00679*/     {688, 12, 1},
/*00680*/     {0, -1, -1},
/*00681*/     {0, -1, -1},
/*00682*/     {0, -1, -1},
/*00683*/     {0, -1, -1},
/*00684*/     {0, -1, -1},
/*00685*/     {0, -1, -1},
/*00686*/     {1234, -1, -1},
/*00687*/     {1235, -1, -1},
/*00688*/     {1250, -1, -1},
/*00689*/     {1251, -1, -1},
/*00690*/     {698, 12, 1},
/*00691*/     {700, 12, 1},
/*00692*/     {0, -1, -1},
/*00693*/     {0, -1, -1},
/*00694*/     {0, -1, -1},
/*00695*/     {0, -1, -1},
/*00696*/     {0, -1, -1},
/*00697*/     {0, -1, -1},
/*00698*/     {1236, -1, -1},
/*00699*/     {1237, -1, -1},
/*00700*/     {1252, -1, -1},
/*00701*/     {1253, -1, -1},
/*00702*/     {710, 12, 1},
/*00703*/     {712, 12, 1},
/*00704*/     {0, -1, -1},
/*00705*/     {0, -1, -1},
/*00706*/     {0, -1, -1},
/*00707*/     {0, -1, -1},
/*00708*/     {0, -1, -1},
/*00709*/     {0, -1, -1},
/*00710*/     {1238, -1, -1},
/*00711*/     {1239, -1, -1},
/*00712*/     {1254, -1, -1},
/*00713*/     {1255, -1, -1},
/*00714*/     {722, 12, 1},
/*00715*/     {724, 12, 1},
/*00716*/     {0, -1, -1},
/*00717*/     {0, -1, -1},
/*00718*/     {0, -1, -1},
/*00719*/     {0, -1, -1},
/*00720*/     {0, -1, -1},
/*00721*/     {0, -1, -1},
/*00722*/     {1240, -1, -1},
/*00723*/     {1241, -1, -1},
/*00724*/     {1256, -1, -1},
/*00725*/     {1257, -1, -1},
/*00726*/     {734, 12, 1},
/*00727*/     {736, 12, 1},
/*00728*/     {0, -1, -1},
/*00729*/     {0, -1, -1},
/*00730*/     {0, -1, -1},
/*00731*/     {0, -1, -1},
/*00732*/     {0, -1, -1},
/*00733*/     {0, -1, -1},
/*00734*/     {1242, -1, -1},
/*00735*/     {1243, -1, -1},
/*00736*/     {1258, -1, -1},
/*00737*/     {1259, -1, -1},
/*00738*/     {746, 12, 1},
/*00739*/     {748, 12, 1},
/*00740*/     {0, -1, -1},
/*00741*/     {0, -1, -1},
/*00742*/     {0, -1, -1},
/*00743*/     {0, -1, -1},
/*00744*/     {0, -1, -1},
/*00745*/     {0, -1, -1},
/*00746*/     {1244, -1, -1},
/*00747*/     {1245, -1, -1},
/*00748*/     {1260, -1, -1},
/*00749*/     {1261, -1, -1},
/*00750*/     {758, 12, 1},
/*00751*/     {760, 12, 1},
/*00752*/     {0, -1, -1},
/*00753*/     {0, -1, -1},
/*00754*/     {0, -1, -1},
/*00755*/     {0, -1, -1},
/*00756*/     {0, -1, -1},
/*00757*/     {0, -1, -1},
/*00758*/     {1246, -1, -1},
/*00759*/     {1247, -1, -1},
/*00760*/     {1262, -1, -1},
/*00761*/     {1263, -1, -1},
/*00762*/     {770, 6, 3},
/*00763*/     {780, 6, 3},
/*00764*/     {790, 6, 3},
/*00765*/     {800, 6, 3},
/*00766*/     {810, 6, 3},
/*00767*/     {820, 6, 3},
/*00768*/     {830, 6, 3},
/*00769*/     {840, 6, 3},
/*00770*/     {0, -1, -1},
/*00771*/     {0, -1, -1},
/*00772*/     {0, -1, -1},
/*00773*/     {0, -1, -1},
/*00774*/     {778, 12, 1},
/*00775*/     {0, -1, -1},
/*00776*/     {0, -1, -1},
/*00777*/     {0, -1, -1},
/*00778*/     {1264, -1, -1},
/*00779*/     {1265, -1, -1},
/*00780*/     {0, -1, -1},
/*00781*/     {0, -1, -1},
/*00782*/     {0, -1, -1},
/*00783*/     {0, -1, -1},
/*00784*/     {788, 12, 1},
/*00785*/     {0, -1, -1},
/*00786*/     {0, -1, -1},
/*00787*/     {0, -1, -1},
/*00788*/     {1266, -1, -1},
/*00789*/     {1267, -1, -1},
/*00790*/     {0, -1, -1},
/*00791*/     {0, -1, -1},
/*00792*/     {0, -1, -1},
/*00793*/     {0, -1, -1},
/*00794*/     {798, 12, 1},
/*00795*/     {0, -1, -1},
/*00796*/     {0, -1, -1},
/*00797*/     {0, -1, -1},
/*00798*/     {1268, -1, -1},
/*00799*/     {1269, -1, -1},
/*00800*/     {0, -1, -1},
/*00801*/     {0, -1, -1},
/*00802*/     {0, -1, -1},
/*00803*/     {0, -1, -1},
/*00804*/     {808, 12, 1},
/*00805*/     {0, -1, -1},
/*00806*/     {0, -1, -1},
/*00807*/     {0, -1, -1},
/*00808*/     {1270, -1, -1},
/*00809*/     {1271, -1, -1},
/*00810*/     {0, -1, -1},
/*00811*/     {0, -1, -1},
/*00812*/     {0, -1, -1},
/*00813*/     {0, -1, -1},
/*00814*/     {818, 12, 1},
/*00815*/     {0, -1, -1},
/*00816*/     {0, -1, -1},
/*00817*/     {0, -1, -1},
/*00818*/     {1272, -1, -1},
/*00819*/     {1273, -1, -1},
/*00820*/     {0, -1, -1},
/*00821*/     {0, -1, -1},
/*00822*/     {0, -1, -1},
/*00823*/     {0, -1, -1},
/*00824*/     {828, 12, 1},
/*00825*/     {0, -1, -1},
/*00826*/     {0, -1, -1},
/*00827*/     {0, -1, -1},
/*00828*/     {1274, -1, -1},
/*00829*/     {1275, -1, -1},
/*00830*/     {0, -1, -1},
/*00831*/     {0, -1, -1},
/*00832*/     {0, -1, -1},
/*00833*/     {0, -1, -1},
/*00834*/     {838, 12, 1},
/*00835*/     {0, -1, -1},
/*00836*/     {0, -1, -1},
/*00837*/     {0, -1, -1},
/*00838*/     {1276, -1, -1},
/*00839*/     {1277, -1, -1},
/*00840*/     {0, -1, -1},
/*00841*/     {0, -1, -1},
/*00842*/     {0, -1, -1},
/*00843*/     {0, -1, -1},
/*00844*/     {848, 12, 1},
/*00845*/     {0, -1, -1},
/*00846*/     {0, -1, -1},
/*00847*/     {0, -1, -1},
/*00848*/     {1278, -1, -1},
/*00849*/     {1279, -1, -1},
/*00850*/     {1554, -1, -1},
/*00851*/     {1555, -1, -1},
/*00852*/     {0, -1, -1},
/*00853*/     {0, -1, -1},
/*00854*/     {0, -1, -1},
/*00855*/     {0, -1, -1},
/*00856*/     {0, -1, -1},
/*00857*/     {0, -1, -1},
/*00858*/     {0, -1, -1},
/*00859*/     {0, -1, -1},
/*00860*/     {0, -1, -1},
/*00861*/     {0, -1, -1},
/*00862*/     {0, -1, -1},
/*00863*/     {0, -1, -1},
/*00864*/     {0, -1, -1},
/*00865*/     {0, -1, -1},
/*00866*/     {0, -1, -1},
/*00867*/     {0, -1, -1},
/*00868*/     {0, -1, -1},
/*00869*/     {0, -1, -1},
/*00870*/     {0, -1, -1},
/*00871*/     {0, -1, -1},
/*00872*/     {0, -1, -1},
/*00873*/     {0, -1, -1},
/*00874*/     {0, -1, -1},
/*00875*/     {0, -1, -1},
/*00876*/     {0, -1, -1},
/*00877*/     {0, -1, -1},
/*00878*/     {0, -1, -1},
/*00879*/     {0, -1, -1},
/*00880*/     {0, -1, -1},
/*00881*/     {0, -1, -1},
/*00882*/     {0, -1, -1},
/*00883*/     {0, -1, -1},
/*00884*/     {0, -1, -1},
/*00885*/     {0, -1, -1},
/*00886*/     {0, -1, -1},
/*00887*/     {0, -1, -1},
/*00888*/     {0, -1, -1},
/*00889*/     {0, -1, -1},
/*00890*/     {0, -1, -1},
/*00891*/     {0, -1, -1},
/*00892*/     {0, -1, -1},
/*00893*/     {0, -1, -1},
/*00894*/     {0, -1, -1},
/*00895*/     {0, -1, -1},
/*00896*/     {0, -1, -1},
/*00897*/     {0, -1, -1},
/*00898*/     {0, -1, -1},
/*00899*/     {0, -1, -1},
/*00900*/     {0, -1, -1},
/*00901*/     {0, -1, -1},
/*00902*/     {0, -1, -1},
/*00903*/     {0, -1, -1},
/*00904*/     {0, -1, -1},
/*00905*/     {0, -1, -1},
/*00906*/     {0, -1, -1},
/*00907*/     {0, -1, -1},
/*00908*/     {0, -1, -1},
/*00909*/     {0, -1, -1},
/*00910*/     {0, -1, -1},
/*00911*/     {0, -1, -1},
/*00912*/     {0, -1, -1},
/*00913*/     {0, -1, -1},
/*00914*/     {0, -1, -1},
/*00915*/     {0, -1, -1},
/*00916*/     {0, -1, -1},
/*00917*/     {0, -1, -1},
/*00918*/     {0, -1, -1},
/*00919*/     {0, -1, -1},
/*00920*/     {0, -1, -1},
/*00921*/     {0, -1, -1},
/*00922*/     {0, -1, -1},
/*00923*/     {0, -1, -1},
/*00924*/     {0, -1, -1},
/*00925*/     {0, -1, -1},
/*00926*/     {0, -1, -1},
/*00927*/     {0, -1, -1},
/*00928*/     {0, -1, -1},
/*00929*/     {0, -1, -1},
/*00930*/     {0, -1, -1},
/*00931*/     {0, -1, -1},
/*00932*/     {0, -1, -1},
/*00933*/     {0, -1, -1},
/*00934*/     {0, -1, -1},
/*00935*/     {0, -1, -1},
/*00936*/     {0, -1, -1},
/*00937*/     {0, -1, -1},
/*00938*/     {0, -1, -1},
/*00939*/     {0, -1, -1},
/*00940*/     {0, -1, -1},
/*00941*/     {0, -1, -1},
/*00942*/     {0, -1, -1},
/*00943*/     {0, -1, -1},
/*00944*/     {0, -1, -1},
/*00945*/     {0, -1, -1},
/*00946*/     {0, -1, -1},
/*00947*/     {0, -1, -1},
/*00948*/     {0, -1, -1},
/*00949*/     {0, -1, -1},
/*00950*/     {0, -1, -1},
/*00951*/     {0, -1, -1},
/*00952*/     {0, -1, -1},
/*00953*/     {0, -1, -1},
/*00954*/     {0, -1, -1},
/*00955*/     {0, -1, -1},
/*00956*/     {0, -1, -1},
/*00957*/     {0, -1, -1},
/*00958*/     {0, -1, -1},
/*00959*/     {0, -1, -1},
/*00960*/     {0, -1, -1},
/*00961*/     {0, -1, -1},
/*00962*/     {0, -1, -1},
/*00963*/     {0, -1, -1},
/*00964*/     {0, -1, -1},
/*00965*/     {0, -1, -1},
/*00966*/     {0, -1, -1},
/*00967*/     {0, -1, -1},
/*00968*/     {0, -1, -1},
/*00969*/     {0, -1, -1},
/*00970*/     {0, -1, -1},
/*00971*/     {0, -1, -1},
/*00972*/     {0, -1, -1},
/*00973*/     {0, -1, -1},
/*00974*/     {0, -1, -1},
/*00975*/     {0, -1, -1},
/*00976*/     {0, -1, -1},
/*00977*/     {0, -1, -1},
/*00978*/     {0, -1, -1},
/*00979*/     {0, -1, -1},
/*00980*/     {0, -1, -1},
/*00981*/     {0, -1, -1},
/*00982*/     {0, -1, -1},
/*00983*/     {0, -1, -1},
/*00984*/     {0, -1, -1},
/*00985*/     {0, -1, -1},
/*00986*/     {0, -1, -1},
/*00987*/     {0, -1, -1},
/*00988*/     {0, -1, -1},
/*00989*/     {0, -1, -1},
/*00990*/     {0, -1, -1},
/*00991*/     {0, -1, -1},
/*00992*/     {0, -1, -1},
/*00993*/     {0, -1, -1},
/*00994*/     {0, -1, -1},
/*00995*/     {0, -1, -1},
/*00996*/     {0, -1, -1},
/*00997*/     {0, -1, -1},
/*00998*/     {0, -1, -1},
/*00999*/     {0, -1, -1},
/*01000*/     {0, -1, -1},
/*01001*/     {0, -1, -1},
/*01002*/     {0, -1, -1},
/*01003*/     {0, -1, -1},
/*01004*/     {0, -1, -1},
/*01005*/     {0, -1, -1},
/*01006*/     {0, -1, -1},
/*01007*/     {0, -1, -1},
/*01008*/     {0, -1, -1},
/*01009*/     {0, -1, -1},
/*01010*/     {0, -1, -1},
/*01011*/     {0, -1, -1},
/*01012*/     {0, -1, -1},
/*01013*/     {0, -1, -1},
/*01014*/     {0, -1, -1},
/*01015*/     {0, -1, -1},
/*01016*/     {0, -1, -1},
/*01017*/     {0, -1, -1},
/*01018*/     {0, -1, -1},
/*01019*/     {0, -1, -1},
/*01020*/     {0, -1, -1},
/*01021*/     {0, -1, -1},
/*01022*/     {0, -1, -1},
/*01023*/     {0, -1, -1},
/*01024*/     {0, -1, -1},
/*01025*/     {0, -1, -1},
/*01026*/     {0, -1, -1},
/*01027*/     {0, -1, -1},
/*01028*/     {0, -1, -1},
/*01029*/     {0, -1, -1},
/*01030*/     {0, -1, -1},
/*01031*/     {0, -1, -1},
/*01032*/     {0, -1, -1},
/*01033*/     {0, -1, -1},
/*01034*/     {0, -1, -1},
/*01035*/     {0, -1, -1},
/*01036*/     {0, -1, -1},
/*01037*/     {0, -1, -1},
/*01038*/     {0, -1, -1},
/*01039*/     {0, -1, -1},
/*01040*/     {0, -1, -1},
/*01041*/     {0, -1, -1},
/*01042*/     {0, -1, -1},
/*01043*/     {0, -1, -1},
/*01044*/     {0, -1, -1},
/*01045*/     {0, -1, -1},
/*01046*/     {0, -1, -1},
/*01047*/     {0, -1, -1},
/*01048*/     {0, -1, -1},
/*01049*/     {0, -1, -1},
/*01050*/     {0, -1, -1},
/*01051*/     {0, -1, -1},
/*01052*/     {0, -1, -1},
/*01053*/     {0, -1, -1},
/*01054*/     {0, -1, -1},
/*01055*/     {0, -1, -1},
/*01056*/     {0, -1, -1},
/*01057*/     {0, -1, -1},
/*01058*/     {0, -1, -1},
/*01059*/     {0, -1, -1},
/*01060*/     {0, -1, -1},
/*01061*/     {0, -1, -1},
/*01062*/     {0, -1, -1},
/*01063*/     {0, -1, -1},
/*01064*/     {0, -1, -1},
/*01065*/     {0, -1, -1},
/*01066*/     {0, -1, -1},
/*01067*/     {0, -1, -1},
/*01068*/     {0, -1, -1},
/*01069*/     {0, -1, -1},
/*01070*/     {0, -1, -1},
/*01071*/     {0, -1, -1},
/*01072*/     {0, -1, -1},
/*01073*/     {0, -1, -1},
/*01074*/     {0, -1, -1},
/*01075*/     {0, -1, -1},
/*01076*/     {0, -1, -1},
/*01077*/     {0, -1, -1},
/*01078*/     {0, -1, -1},
/*01079*/     {0, -1, -1},
/*01080*/     {0, -1, -1},
/*01081*/     {0, -1, -1},
/*01082*/     {0, -1, -1},
/*01083*/     {0, -1, -1},
/*01084*/     {0, -1, -1},
/*01085*/     {0, -1, -1},
/*01086*/     {0, -1, -1},
/*01087*/     {0, -1, -1},
/*01088*/     {0, -1, -1},
/*01089*/     {0, -1, -1},
/*01090*/     {0, -1, -1},
/*01091*/     {0, -1, -1},
/*01092*/     {0, -1, -1},
/*01093*/     {0, -1, -1},
/*01094*/     {0, -1, -1},
/*01095*/     {0, -1, -1},
/*01096*/     {0, -1, -1},
/*01097*/     {0, -1, -1},
/*01098*/     {0, -1, -1},
/*01099*/     {0, -1, -1},
/*01100*/     {0, -1, -1},
/*01101*/     {0, -1, -1},
/*01102*/     {0, -1, -1},
/*01103*/     {0, -1, -1},
/*01104*/     {0, -1, -1},
/*01105*/     {0, -1, -1},
/*01106*/     {0, -1, -1},
/*01107*/     {0, -1, -1},
/*01108*/     {0, -1, -1},
/*01109*/     {0, -1, -1},
/*01110*/     {0, -1, -1},
/*01111*/     {0, -1, -1},
/*01112*/     {0, -1, -1},
/*01113*/     {0, -1, -1},
/*01114*/     {0, -1, -1},
/*01115*/     {0, -1, -1},
/*01116*/     {0, -1, -1},
/*01117*/     {0, -1, -1},
/*01118*/     {0, -1, -1},
/*01119*/     {0, -1, -1},
/*01120*/     {0, -1, -1},
/*01121*/     {0, -1, -1},
/*01122*/     {0, -1, -1},
/*01123*/     {0, -1, -1},
/*01124*/     {0, -1, -1},
/*01125*/     {0, -1, -1},
/*01126*/     {0, -1, -1},
/*01127*/     {0, -1, -1},
/*01128*/     {0, -1, -1},
/*01129*/     {0, -1, -1},
/*01130*/     {0, -1, -1},
/*01131*/     {0, -1, -1},
/*01132*/     {0, -1, -1},
/*01133*/     {0, -1, -1},
/*01134*/     {0, -1, -1},
/*01135*/     {0, -1, -1},
/*01136*/     {0, -1, -1},
/*01137*/     {0, -1, -1},
/*01138*/     {0, -1, -1},
/*01139*/     {0, -1, -1},
/*01140*/     {0, -1, -1},
/*01141*/     {0, -1, -1},
/*01142*/     {0, -1, -1},
/*01143*/     {0, -1, -1},
/*01144*/     {0, -1, -1},
/*01145*/     {0, -1, -1},
/*01146*/     {0, -1, -1},
/*01147*/     {0, -1, -1},
/*01148*/     {0, -1, -1},
/*01149*/     {0, -1, -1},
/*01150*/     {0, -1, -1},
/*01151*/     {0, -1, -1},
/*01152*/     {0, -1, -1},
/*01153*/     {0, -1, -1},
/*01154*/     {0, -1, -1},
/*01155*/     {0, -1, -1},
/*01156*/     {0, -1, -1},
/*01157*/     {0, -1, -1},
/*01158*/     {0, -1, -1},
/*01159*/     {0, -1, -1},
/*01160*/     {0, -1, -1},
/*01161*/     {0, -1, -1},
/*01162*/     {0, -1, -1},
/*01163*/     {0, -1, -1},
/*01164*/     {0, -1, -1},
/*01165*/     {0, -1, -1},
/*01166*/     {0, -1, -1},
/*01167*/     {0, -1, -1},
/*01168*/     {0, -1, -1},
/*01169*/     {0, -1, -1},
/*01170*/     {0, -1, -1},
/*01171*/     {0, -1, -1},
/*01172*/     {0, -1, -1},
/*01173*/     {0, -1, -1},
/*01174*/     {0, -1, -1},
/*01175*/     {0, -1, -1},
/*01176*/     {0, -1, -1},
/*01177*/     {0, -1, -1},
/*01178*/     {0, -1, -1},
/*01179*/     {0, -1, -1},
/*01180*/     {0, -1, -1},
/*01181*/     {0, -1, -1},
/*01182*/     {0, -1, -1},
/*01183*/     {0, -1, -1},
/*01184*/     {0, -1, -1},
/*01185*/     {0, -1, -1},
/*01186*/     {0, -1, -1},
/*01187*/     {0, -1, -1},
/*01188*/     {0, -1, -1},
/*01189*/     {0, -1, -1},
/*01190*/     {0, -1, -1},
/*01191*/     {0, -1, -1},
/*01192*/     {0, -1, -1},
/*01193*/     {0, -1, -1},
/*01194*/     {0, -1, -1},
/*01195*/     {0, -1, -1},
/*01196*/     {0, -1, -1},
/*01197*/     {0, -1, -1},
/*01198*/     {0, -1, -1},
/*01199*/     {0, -1, -1},
/*01200*/     {0, -1, -1},
/*01201*/     {0, -1, -1},
/*01202*/     {0, -1, -1},
/*01203*/     {0, -1, -1},
/*01204*/     {0, -1, -1},
/*01205*/     {0, -1, -1},
/*01206*/     {0, -1, -1},
/*01207*/     {0, -1, -1},
/*01208*/     {0, -1, -1},
/*01209*/     {0, -1, -1},
/*01210*/     {0, -1, -1},
/*01211*/     {0, -1, -1},
/*01212*/     {0, -1, -1},
/*01213*/     {0, -1, -1},
/*01214*/     {0, -1, -1},
/*01215*/     {0, -1, -1},
/*01216*/     {0, -1, -1},
/*01217*/     {0, -1, -1},
/*01218*/     {0, -1, -1},
/*01219*/     {0, -1, -1},
/*01220*/     {0, -1, -1},
/*01221*/     {0, -1, -1},
/*01222*/     {0, -1, -1},
/*01223*/     {0, -1, -1},
/*01224*/     {0, -1, -1},
/*01225*/     {0, -1, -1},
/*01226*/     {0, -1, -1},
/*01227*/     {0, -1, -1},
/*01228*/     {0, -1, -1},
/*01229*/     {0, -1, -1},
/*01230*/     {0, -1, -1},
/*01231*/     {0, -1, -1},
/*01232*/     {0, -1, -1},
/*01233*/     {0, -1, -1},
/*01234*/     {0, -1, -1},
/*01235*/     {0, -1, -1},
/*01236*/     {0, -1, -1},
/*01237*/     {0, -1, -1},
/*01238*/     {0, -1, -1},
/*01239*/     {0, -1, -1},
/*01240*/     {0, -1, -1},
/*01241*/     {0, -1, -1},
/*01242*/     {0, -1, -1},
/*01243*/     {0, -1, -1},
/*01244*/     {0, -1, -1},
/*01245*/     {0, -1, -1},
/*01246*/     {0, -1, -1},
/*01247*/     {0, -1, -1},
/*01248*/     {0, -1, -1},
/*01249*/     {0, -1, -1},
/*01250*/     {0, -1, -1},
/*01251*/     {0, -1, -1},
/*01252*/     {0, -1, -1},
/*01253*/     {0, -1, -1},
/*01254*/     {0, -1, -1},
/*01255*/     {0, -1, -1},
/*01256*/     {0, -1, -1},
/*01257*/     {0, -1, -1},
/*01258*/     {0, -1, -1},
/*01259*/     {0, -1, -1},
/*01260*/     {0, -1, -1},
/*01261*/     {0, -1, -1},
/*01262*/     {0, -1, -1},
/*01263*/     {0, -1, -1},
/*01264*/     {0, -1, -1},
/*01265*/     {0, -1, -1},
/*01266*/     {0, -1, -1},
/*01267*/     {0, -1, -1},
/*01268*/     {0, -1, -1},
/*01269*/     {0, -1, -1},
/*01270*/     {0, -1, -1},
/*01271*/     {0, -1, -1},
/*01272*/     {0, -1, -1},
/*01273*/     {0, -1, -1},
/*01274*/     {0, -1, -1},
/*01275*/     {0, -1, -1},
/*01276*/     {0, -1, -1},
/*01277*/     {0, -1, -1},
/*01278*/     {0, -1, -1},
/*01279*/     {0, -1, -1},
/*01280*/     {0, -1, -1},
/*01281*/     {0, -1, -1},
/*01282*/     {0, -1, -1},
/*01283*/     {0, -1, -1},
/*01284*/     {0, -1, -1},
/*01285*/     {0, -1, -1},
/*01286*/     {0, -1, -1},
/*01287*/     {0, -1, -1},
/*01288*/     {0, -1, -1},
/*01289*/     {0, -1, -1},
/*01290*/     {0, -1, -1},
/*01291*/     {0, -1, -1},
/*01292*/     {0, -1, -1},
/*01293*/     {0, -1, -1},
/*01294*/     {0, -1, -1},
/*01295*/     {0, -1, -1},
/*01296*/     {0, -1, -1},
/*01297*/     {0, -1, -1},
/*01298*/     {0, -1, -1},
/*01299*/     {0, -1, -1},
/*01300*/     {0, -1, -1},
/*01301*/     {0, -1, -1},
/*01302*/     {0, -1, -1},
/*01303*/     {0, -1, -1},
/*01304*/     {0, -1, -1},
/*01305*/     {0, -1, -1},
/*01306*/     {0, -1, -1},
/*01307*/     {0, -1, -1},
/*01308*/     {0, -1, -1},
/*01309*/     {0, -1, -1},
/*01310*/     {0, -1, -1},
/*01311*/     {0, -1, -1},
/*01312*/     {0, -1, -1},
/*01313*/     {0, -1, -1},
/*01314*/     {0, -1, -1},
/*01315*/     {0, -1, -1},
/*01316*/     {0, -1, -1},
/*01317*/     {0, -1, -1},
/*01318*/     {0, -1, -1},
/*01319*/     {0, -1, -1},
/*01320*/     {0, -1, -1},
/*01321*/     {0, -1, -1},
/*01322*/     {0, -1, -1},
/*01323*/     {0, -1, -1},
/*01324*/     {0, -1, -1},
/*01325*/     {0, -1, -1},
/*01326*/     {0, -1, -1},
/*01327*/     {0, -1, -1},
/*01328*/     {0, -1, -1},
/*01329*/     {0, -1, -1},
/*01330*/     {0, -1, -1},
/*01331*/     {0, -1, -1},
/*01332*/     {0, -1, -1},
/*01333*/     {0, -1, -1},
/*01334*/     {0, -1, -1},
/*01335*/     {0, -1, -1},
/*01336*/     {0, -1, -1},
/*01337*/     {0, -1, -1},
/*01338*/     {0, -1, -1},
/*01339*/     {0, -1, -1},
/*01340*/     {0, -1, -1},
/*01341*/     {0, -1, -1},
/*01342*/     {0, -1, -1},
/*01343*/     {0, -1, -1},
/*01344*/     {0, -1, -1},
/*01345*/     {0, -1, -1},
/*01346*/     {0, -1, -1},
/*01347*/     {0, -1, -1},
/*01348*/     {0, -1, -1},
/*01349*/     {0, -1, -1},
/*01350*/     {0, -1, -1},
/*01351*/     {0, -1, -1},
/*01352*/     {0, -1, -1},
/*01353*/     {0, -1, -1},
/*01354*/     {0, -1, -1},
/*01355*/     {0, -1, -1},
/*01356*/     {0, -1, -1},
/*01357*/     {0, -1, -1},
/*01358*/     {0, -1, -1},
/*01359*/     {0, -1, -1},
/*01360*/     {0, -1, -1},
/*01361*/     {0, -1, -1},
/*01362*/     {1370, 27, 6},
/*01363*/     {1049, -1, -1},
/*01364*/     {0, -1, -1},
/*01365*/     {1050, -1, -1},
/*01366*/     {0, -1, -1},
/*01367*/     {0, -1, -1},
/*01368*/     {1073, -1, -1},
/*01369*/     {0, -1, -1},
/*01370*/     {1089, -1, -1},
/*01371*/     {1090, -1, -1},
/*01372*/     {1091, -1, -1},
/*01373*/     {1092, -1, -1},
/*01374*/     {1093, -1, -1},
/*01375*/     {1094, -1, -1},
/*01376*/     {1095, -1, -1},
/*01377*/     {0, -1, -1},
/*01378*/     {0, -1, -1},
/*01379*/     {1110, -1, -1},
/*01380*/     {1111, -1, -1},
/*01381*/     {1112, -1, -1},
/*01382*/     {1113, -1, -1},
/*01383*/     {1114, -1, -1},
/*01384*/     {1096, -1, -1},
/*01385*/     {1097, -1, -1},
/*01386*/     {1098, -1, -1},
/*01387*/     {1099, -1, -1},
/*01388*/     {1100, -1, -1},
/*01389*/     {1101, -1, -1},
/*01390*/     {1102, -1, -1},
/*01391*/     {1104, -1, -1},
/*01392*/     {1103, -1, -1},
/*01393*/     {1105, -1, -1},
/*01394*/     {1082, -1, -1},
/*01395*/     {1083, -1, -1},
/*01396*/     {1115, -1, -1},
/*01397*/     {1116, -1, -1},
/*01398*/     {0, -1, -1},
/*01399*/     {0, -1, -1},
/*01400*/     {1117, -1, -1},
/*01401*/     {1118, -1, -1},
/*01402*/     {0, -1, -1},
/*01403*/     {1077, -1, -1},
/*01404*/     {1070, -1, -1},
/*01405*/     {0, -1, -1},
/*01406*/     {1072, -1, -1},
/*01407*/     {1076, -1, -1},
/*01408*/     {0, -1, -1},
/*01409*/     {0, -1, -1},
/*01410*/     {0, -1, -1},
/*01411*/     {1075, -1, -1},
/*01412*/     {1068, -1, -1},
/*01413*/     {0, -1, -1},
/*01414*/     {1071, -1, -1},
/*01415*/     {1074, -1, -1},
/*01416*/     {1087, -1, -1},
/*01417*/     {1088, -1, -1},
/*01418*/     {1066, -1, -1},
/*01419*/     {1084, -1, -1},
/*01420*/     {1085, -1, -1},
/*01421*/     {1086, -1, -1},
/*01422*/     {1067, -1, -1},
/*01423*/     {0, -1, -1},
/*01424*/     {0, -1, -1},
/*01425*/     {0, -1, -1},
/*01426*/     {1080, -1, -1},
/*01427*/     {1081, -1, -1},
/*01428*/     {0, -1, -1},
/*01429*/     {0, -1, -1},
/*01430*/     {1119, -1, -1},
/*01431*/     {0, -1, -1},
/*01432*/     {0, -1, -1},
/*01433*/     {0, -1, -1},
/*01434*/     {1436, 27, 6},
/*01435*/     {1564, 34, 3},
/*01436*/     {0, -1, -1},
/*01437*/     {0, -1, -1},
/*01438*/     {0, -1, -1},
/*01439*/     {0, -1, -1},
/*01440*/     {0, -1, -1},
/*01441*/     {0, -1, -1},
/*01442*/     {0, -1, -1},
/*01443*/     {0, -1, -1},
/*01444*/     {0, -1, -1},
/*01445*/     {0, -1, -1},
/*01446*/     {0, -1, -1},
/*01447*/     {0, -1, -1},
/*01448*/     {0, -1, -1},
/*01449*/     {0, -1, -1},
/*01450*/     {0, -1, -1},
/*01451*/     {0, -1, -1},
/*01452*/     {1504, -1, -1},
/*01453*/     {1505, -1, -1},
/*01454*/     {1506, -1, -1},
/*01455*/     {0, -1, -1},
/*01456*/     {1500, 34, 2},
/*01457*/     {1504, 34, 2},
/*01458*/     {1508, 34, 2},
/*01459*/     {1512, 34, 2},
/*01460*/     {1516, 34, 2},
/*01461*/     {1520, 34, 2},
/*01462*/     {1524, 34, 2},
/*01463*/     {1528, 34, 2},
/*01464*/     {0, -1, -1},
/*01465*/     {0, -1, -1},
/*01466*/     {0, -1, -1},
/*01467*/     {0, -1, -1},
/*01468*/     {0, -1, -1},
/*01469*/     {0, -1, -1},
/*01470*/     {0, -1, -1},
/*01471*/     {0, -1, -1},
/*01472*/     {0, -1, -1},
/*01473*/     {0, -1, -1},
/*01474*/     {0, -1, -1},
/*01475*/     {0, -1, -1},
/*01476*/     {0, -1, -1},
/*01477*/     {0, -1, -1},
/*01478*/     {0, -1, -1},
/*01479*/     {0, -1, -1},
/*01480*/     {0, -1, -1},
/*01481*/     {0, -1, -1},
/*01482*/     {0, -1, -1},
/*01483*/     {0, -1, -1},
/*01484*/     {1532, 34, 2},
/*01485*/     {1536, 34, 2},
/*01486*/     {1540, 34, 2},
/*01487*/     {1544, 34, 2},
/*01488*/     {1548, 34, 2},
/*01489*/     {1552, 34, 2},
/*01490*/     {1556, 34, 2},
/*01491*/     {1560, 34, 2},
/*01492*/     {0, -1, -1},
/*01493*/     {0, -1, -1},
/*01494*/     {0, -1, -1},
/*01495*/     {0, -1, -1},
/*01496*/     {0, -1, -1},
/*01497*/     {0, -1, -1},
/*01498*/     {0, -1, -1},
/*01499*/     {0, -1, -1},
/*01500*/     {1440, -1, -1},
/*01501*/     {1441, -1, -1},
/*01502*/     {1442, -1, -1},
/*01503*/     {1443, -1, -1},
/*01504*/     {1444, -1, -1},
/*01505*/     {1445, -1, -1},
/*01506*/     {1446, -1, -1},
/*01507*/     {1447, -1, -1},
/*01508*/     {1448, -1, -1},
/*01509*/     {1449, -1, -1},
/*01510*/     {1450, -1, -1},
/*01511*/     {1451, -1, -1},
/*01512*/     {1452, -1, -1},
/*01513*/     {1453, -1, -1},
/*01514*/     {1454, -1, -1},
/*01515*/     {1455, -1, -1},
/*01516*/     {1523, -1, -1},
/*01517*/     {1524, -1, -1},
/*01518*/     {1525, -1, -1},
/*01519*/     {1526, -1, -1},
/*01520*/     {1527, -1, -1},
/*01521*/     {1528, -1, -1},
/*01522*/     {1529, -1, -1},
/*01523*/     {1530, -1, -1},
/*01524*/     {1531, -1, -1},
/*01525*/     {1532, -1, -1},
/*01526*/     {1533, -1, -1},
/*01527*/     {1534, -1, -1},
/*01528*/     {1535, -1, -1},
/*01529*/     {1536, -1, -1},
/*01530*/     {1537, -1, -1},
/*01531*/     {1538, -1, -1},
/*01532*/     {1456, -1, -1},
/*01533*/     {1457, -1, -1},
/*01534*/     {1458, -1, -1},
/*01535*/     {1459, -1, -1},
/*01536*/     {1460, -1, -1},
/*01537*/     {1461, -1, -1},
/*01538*/     {1462, -1, -1},
/*01539*/     {1463, -1, -1},
/*01540*/     {1464, -1, -1},
/*01541*/     {1465, -1, -1},
/*01542*/     {1466, -1, -1},
/*01543*/     {1467, -1, -1},
/*01544*/     {1468, -1, -1},
/*01545*/     {1469, -1, -1},
/*01546*/     {1470, -1, -1},
/*01547*/     {1471, -1, -1},
/*01548*/     {1472, -1, -1},
/*01549*/     {1473, -1, -1},
/*01550*/     {1474, -1, -1},
/*01551*/     {1475, -1, -1},
/*01552*/     {1476, -1, -1},
/*01553*/     {1477, -1, -1},
/*01554*/     {1478, -1, -1},
/*01555*/     {1479, -1, -1},
/*01556*/     {1480, -1, -1},
/*01557*/     {1481, -1, -1},
/*01558*/     {1482, -1, -1},
/*01559*/     {1483, -1, -1},
/*01560*/     {1484, -1, -1},
/*01561*/     {1485, -1, -1},
/*01562*/     {1486, -1, -1},
/*01563*/     {1487, -1, -1},
/*01564*/     {1412, -1, -1},
/*01565*/     {1413, -1, -1},
/*01566*/     {1414, -1, -1},
/*01567*/     {1415, -1, -1},
/*01568*/     {1420, -1, -1},
/*01569*/     {1421, -1, -1},
/*01570*/     {1422, -1, -1},
/*01571*/     {1423, -1, -1},
/*01572*/     {1588, 12, 1},
/*01573*/     {1590, 12, 1},
/*01574*/     {1592, 12, 1},
/*01575*/     {1594, 12, 1},
/*01576*/     {1596, 12, 1},
/*01577*/     {1598, 12, 1},
/*01578*/     {1600, 12, 1},
/*01579*/     {1602, 12, 1},
/*01580*/     {1604, 12, 1},
/*01581*/     {1606, 12, 1},
/*01582*/     {1608, 12, 1},
/*01583*/     {1610, 12, 1},
/*01584*/     {1612, 12, 1},
/*01585*/     {1614, 12, 1},
/*01586*/     {1616, 12, 1},
/*01587*/     {1618, 12, 1},
/*01588*/     {1280, -1, -1},
/*01589*/     {1281, -1, -1},
/*01590*/     {1280, -1, -1},
/*01591*/     {1281, -1, -1},
/*01592*/     {1280, -1, -1},
/*01593*/     {1281, -1, -1},
/*01594*/     {1282, -1, -1},
/*01595*/     {1283, -1, -1},
/*01596*/     {1280, -1, -1},
/*01597*/     {1281, -1, -1},
/*01598*/     {1284, -1, -1},
/*01599*/     {1285, -1, -1},
/*01600*/     {1280, -1, -1},
/*01601*/     {1281, -1, -1},
/*01602*/     {1286, -1, -1},
/*01603*/     {1287, -1, -1},
/*01604*/     {1288, -1, -1},
/*01605*/     {1289, -1, -1},
/*01606*/     {1288, -1, -1},
/*01607*/     {1289, -1, -1},
/*01608*/     {1288, -1, -1},
/*01609*/     {1289, -1, -1},
/*01610*/     {1290, -1, -1},
/*01611*/     {1291, -1, -1},
/*01612*/     {1288, -1, -1},
/*01613*/     {1289, -1, -1},
/*01614*/     {1292, -1, -1},
/*01615*/     {1293, -1, -1},
/*01616*/     {1288, -1, -1},
/*01617*/     {1289, -1, -1},
/*01618*/     {1294, -1, -1},
/*01619*/     {1295, -1, -1},
/*01620*/     {1321, -1, -1},
/*01621*/     {0, -1, -1},
/*01622*/     {0, -1, -1},
/*01623*/     {0, -1, -1},
/*01624*/     {0, -1, -1},
/*01625*/     {0, -1, -1},
/*01626*/     {0, -1, -1},
/*01627*/     {0, -1, -1},
/*01628*/     {0, -1, -1},
/*01629*/     {0, -1, -1},
/*01630*/     {0, -1, -1},
/*01631*/     {0, -1, -1},
/*01632*/     {0, -1, -1},
/*01633*/     {0, -1, -1},
/*01634*/     {0, -1, -1},
/*01635*/     {0, -1, -1},
/*01636*/     {1684, 0, 6},
/*01637*/     {1756, 0, 6},
/*01638*/     {0, -1, -1},
/*01639*/     {0, -1, -1},
/*01640*/     {0, -1, -1},
/*01641*/     {0, -1, -1},
/*01642*/     {0, -1, -1},
/*01643*/     {0, -1, -1},
/*01644*/     {0, -1, -1},
/*01645*/     {0, -1, -1},
/*01646*/     {0, -1, -1},
/*01647*/     {0, -1, -1},
/*01648*/     {0, -1, -1},
/*01649*/     {0, -1, -1},
/*01650*/     {0, -1, -1},
/*01651*/     {0, -1, -1},
/*01652*/     {0, -1, -1},
/*01653*/     {0, -1, -1},
/*01654*/     {0, -1, -1},
/*01655*/     {0, -1, -1},
/*01656*/     {0, -1, -1},
/*01657*/     {0, -1, -1},
/*01658*/     {0, -1, -1},
/*01659*/     {0, -1, -1},
/*01660*/     {0, -1, -1},
/*01661*/     {0, -1, -1},
/*01662*/     {0, -1, -1},
/*01663*/     {0, -1, -1},
/*01664*/     {0, -1, -1},
/*01665*/     {0, -1, -1},
/*01666*/     {0, -1, -1},
/*01667*/     {0, -1, -1},
/*01668*/     {0, -1, -1},
/*01669*/     {0, -1, -1},
/*01670*/     {0, -1, -1},
/*01671*/     {0, -1, -1},
/*01672*/     {0, -1, -1},
/*01673*/     {0, -1, -1},
/*01674*/     {0, -1, -1},
/*01675*/     {0, -1, -1},
/*01676*/     {0, -1, -1},
/*01677*/     {0, -1, -1},
/*01678*/     {0, -1, -1},
/*01679*/     {0, -1, -1},
/*01680*/     {0, -1, -1},
/*01681*/     {0, -1, -1},
/*01682*/     {0, -1, -1},
/*01683*/     {0, -1, -1},
/*01684*/     {1748, 35, 1},
/*01685*/     {0, -1, -1},
/*01686*/     {0, -1, -1},
/*01687*/     {0, -1, -1},
/*01688*/     {0, -1, -1},
/*01689*/     {0, -1, -1},
/*01690*/     {0, -1, -1},
/*01691*/     {0, -1, -1},
/*01692*/     {1750, 35, 1},
/*01693*/     {0, -1, -1},
/*01694*/     {0, -1, -1},
/*01695*/     {0, -1, -1},
/*01696*/     {0, -1, -1},
/*01697*/     {0, -1, -1},
/*01698*/     {0, -1, -1},
/*01699*/     {0, -1, -1},
/*01700*/     {1752, 35, 1},
/*01701*/     {0, -1, -1},
/*01702*/     {0, -1, -1},
/*01703*/     {0, -1, -1},
/*01704*/     {0, -1, -1},
/*01705*/     {0, -1, -1},
/*01706*/     {0, -1, -1},
/*01707*/     {0, -1, -1},
/*01708*/     {1754, 35, 1},
/*01709*/     {0, -1, -1},
/*01710*/     {0, -1, -1},
/*01711*/     {0, -1, -1},
/*01712*/     {0, -1, -1},
/*01713*/     {0, -1, -1},
/*01714*/     {0, -1, -1},
/*01715*/     {0, -1, -1},
/*01716*/     {0, -1, -1},
/*01717*/     {0, -1, -1},
/*01718*/     {0, -1, -1},
/*01719*/     {0, -1, -1},
/*01720*/     {0, -1, -1},
/*01721*/     {0, -1, -1},
/*01722*/     {0, -1, -1},
/*01723*/     {0, -1, -1},
/*01724*/     {0, -1, -1},
/*01725*/     {0, -1, -1},
/*01726*/     {0, -1, -1},
/*01727*/     {0, -1, -1},
/*01728*/     {0, -1, -1},
/*01729*/     {0, -1, -1},
/*01730*/     {0, -1, -1},
/*01731*/     {0, -1, -1},
/*01732*/     {0, -1, -1},
/*01733*/     {0, -1, -1},
/*01734*/     {0, -1, -1},
/*01735*/     {0, -1, -1},
/*01736*/     {0, -1, -1},
/*01737*/     {0, -1, -1},
/*01738*/     {0, -1, -1},
/*01739*/     {0, -1, -1},
/*01740*/     {0, -1, -1},
/*01741*/     {0, -1, -1},
/*01742*/     {0, -1, -1},
/*01743*/     {0, -1, -1},
/*01744*/     {0, -1, -1},
/*01745*/     {0, -1, -1},
/*01746*/     {0, -1, -1},
/*01747*/     {0, -1, -1},
/*01748*/     {1304, -1, -1},
/*01749*/     {1305, -1, -1},
/*01750*/     {1304, -1, -1},
/*01751*/     {1305, -1, -1},
/*01752*/     {1306, -1, -1},
/*01753*/     {1307, -1, -1},
/*01754*/     {1304, -1, -1},
/*01755*/     {1305, -1, -1},
/*01756*/     {1820, 35, 1},
/*01757*/     {0, -1, -1},
/*01758*/     {0, -1, -1},
/*01759*/     {0, -1, -1},
/*01760*/     {0, -1, -1},
/*01761*/     {0, -1, -1},
/*01762*/     {0, -1, -1},
/*01763*/     {0, -1, -1},
/*01764*/     {1822, 35, 1},
/*01765*/     {0, -1, -1},
/*01766*/     {0, -1, -1},
/*01767*/     {0, -1, -1},
/*01768*/     {0, -1, -1},
/*01769*/     {0, -1, -1},
/*01770*/     {0, -1, -1},
/*01771*/     {0, -1, -1},
/*01772*/     {1824, 35, 1},
/*01773*/     {0, -1, -1},
/*01774*/     {0, -1, -1},
/*01775*/     {0, -1, -1},
/*01776*/     {0, -1, -1},
/*01777*/     {0, -1, -1},
/*01778*/     {0, -1, -1},
/*01779*/     {0, -1, -1},
/*01780*/     {1826, 35, 1},
/*01781*/     {0, -1, -1},
/*01782*/     {0, -1, -1},
/*01783*/     {0, -1, -1},
/*01784*/     {0, -1, -1},
/*01785*/     {0, -1, -1},
/*01786*/     {0, -1, -1},
/*01787*/     {0, -1, -1},
/*01788*/     {0, -1, -1},
/*01789*/     {0, -1, -1},
/*01790*/     {0, -1, -1},
/*01791*/     {0, -1, -1},
/*01792*/     {0, -1, -1},
/*01793*/     {0, -1, -1},
/*01794*/     {0, -1, -1},
/*01795*/     {0, -1, -1},
/*01796*/     {0, -1, -1},
/*01797*/     {0, -1, -1},
/*01798*/     {0, -1, -1},
/*01799*/     {0, -1, -1},
/*01800*/     {0, -1, -1},
/*01801*/     {0, -1, -1},
/*01802*/     {0, -1, -1},
/*01803*/     {0, -1, -1},
/*01804*/     {0, -1, -1},
/*01805*/     {0, -1, -1},
/*01806*/     {0, -1, -1},
/*01807*/     {0, -1, -1},
/*01808*/     {0, -1, -1},
/*01809*/     {0, -1, -1},
/*01810*/     {0, -1, -1},
/*01811*/     {0, -1, -1},
/*01812*/     {0, -1, -1},
/*01813*/     {0, -1, -1},
/*01814*/     {0, -1, -1},
/*01815*/     {0, -1, -1},
/*01816*/     {0, -1, -1},
/*01817*/     {0, -1, -1},
/*01818*/     {0, -1, -1},
/*01819*/     {0, -1, -1},
/*01820*/     {1308, -1, -1},
/*01821*/     {1309, -1, -1},
/*01822*/     {1308, -1, -1},
/*01823*/     {1309, -1, -1},
/*01824*/     {1310, -1, -1},
/*01825*/     {1311, -1, -1},
/*01826*/     {1308, -1, -1},
/*01827*/     {1309, -1, -1},
/*01828*/     {1956, 27, 3},
/*01829*/     {1964, 27, 3},
/*01830*/     {1972, 27, 3},
/*01831*/     {1980, 27, 3},
/*01832*/     {1988, 27, 3},
/*01833*/     {1996, 27, 3},
/*01834*/     {2004, 27, 3},
/*01835*/     {2012, 27, 3},
/*01836*/     {2020, 27, 3},
/*01837*/     {2028, 27, 3},
/*01838*/     {2036, 27, 3},
/*01839*/     {2044, 27, 3},
/*01840*/     {2052, 27, 3},
/*01841*/     {2060, 27, 3},
/*01842*/     {2068, 27, 3},
/*01843*/     {2076, 27, 3},
/*01844*/     {2084, 27, 3},
/*01845*/     {2092, 27, 3},
/*01846*/     {2100, 27, 3},
/*01847*/     {2108, 27, 3},
/*01848*/     {2116, 27, 3},
/*01849*/     {2124, 27, 3},
/*01850*/     {2132, 27, 3},
/*01851*/     {2140, 27, 3},
/*01852*/     {0, -1, -1},
/*01853*/     {0, -1, -1},
/*01854*/     {0, -1, -1},
/*01855*/     {2148, 27, 3},
/*01856*/     {2156, 27, 1},
/*01857*/     {2158, 27, 1},
/*01858*/     {2160, 27, 1},
/*01859*/     {2162, 27, 1},
/*01860*/     {2164, 27, 3},
/*01861*/     {2172, 27, 3},
/*01862*/     {2180, 27, 3},
/*01863*/     {2188, 27, 3},
/*01864*/     {2196, 27, 3},
/*01865*/     {2204, 27, 3},
/*01866*/     {2212, 27, 3},
/*01867*/     {2220, 27, 3},
/*01868*/     {2228, 27, 3},
/*01869*/     {2236, 27, 3},
/*01870*/     {2244, 27, 3},
/*01871*/     {2252, 27, 3},
/*01872*/     {0, -1, -1},
/*01873*/     {0, -1, -1},
/*01874*/     {0, -1, -1},
/*01875*/     {0, -1, -1},
/*01876*/     {2260, 27, 3},
/*01877*/     {2268, 27, 3},
/*01878*/     {2276, 27, 3},
/*01879*/     {2284, 27, 3},
/*01880*/     {2292, 27, 3},
/*01881*/     {2300, 27, 3},
/*01882*/     {2308, 27, 3},
/*01883*/     {2316, 27, 3},
/*01884*/     {0, -1, -1},
/*01885*/     {0, -1, -1},
/*01886*/     {0, -1, -1},
/*01887*/     {2324, 27, 3},
/*01888*/     {0, -1, -1},
/*01889*/     {0, -1, -1},
/*01890*/     {0, -1, -1},
/*01891*/     {0, -1, -1},
/*01892*/     {2332, 27, 3},
/*01893*/     {2340, 27, 3},
/*01894*/     {2348, 27, 3},
/*01895*/     {2356, 27, 3},
/*01896*/     {2364, 27, 3},
/*01897*/     {2372, 27, 3},
/*01898*/     {2380, 27, 3},
/*01899*/     {2388, 27, 3},
/*01900*/     {2396, 27, 3},
/*01901*/     {2404, 27, 3},
/*01902*/     {2412, 27, 3},
/*01903*/     {2420, 27, 3},
/*01904*/     {2428, 27, 3},
/*01905*/     {2436, 27, 3},
/*01906*/     {2444, 27, 3},
/*01907*/     {2452, 27, 3},
/*01908*/     {2460, 27, 3},
/*01909*/     {2468, 27, 3},
/*01910*/     {2476, 27, 3},
/*01911*/     {2484, 27, 3},
/*01912*/     {2492, 27, 3},
/*01913*/     {2500, 27, 3},
/*01914*/     {2508, 27, 3},
/*01915*/     {2516, 27, 3},
/*01916*/     {0, -1, -1},
/*01917*/     {0, -1, -1},
/*01918*/     {0, -1, -1},
/*01919*/     {2524, 27, 3},
/*01920*/     {0, -1, -1},
/*01921*/     {0, -1, -1},
/*01922*/     {0, -1, -1},
/*01923*/     {0, -1, -1},
/*01924*/     {2532, 27, 3},
/*01925*/     {2540, 27, 3},
/*01926*/     {2548, 27, 3},
/*01927*/     {2556, 27, 3},
/*01928*/     {2564, 27, 3},
/*01929*/     {2572, 27, 3},
/*01930*/     {2580, 27, 3},
/*01931*/     {2588, 27, 3},
/*01932*/     {2596, 27, 3},
/*01933*/     {2604, 27, 3},
/*01934*/     {2612, 27, 3},
/*01935*/     {2620, 27, 3},
/*01936*/     {0, -1, -1},
/*01937*/     {0, -1, -1},
/*01938*/     {0, -1, -1},
/*01939*/     {0, -1, -1},
/*01940*/     {0, -1, -1},
/*01941*/     {0, -1, -1},
/*01942*/     {0, -1, -1},
/*01943*/     {0, -1, -1},
/*01944*/     {0, -1, -1},
/*01945*/     {0, -1, -1},
/*01946*/     {0, -1, -1},
/*01947*/     {0, -1, -1},
/*01948*/     {0, -1, -1},
/*01949*/     {0, -1, -1},
/*01950*/     {0, -1, -1},
/*01951*/     {0, -1, -1},
/*01952*/     {0, -1, -1},
/*01953*/     {0, -1, -1},
/*01954*/     {0, -1, -1},
/*01955*/     {0, -1, -1},
/*01956*/     {223, -1, -1},
/*01957*/     {993, -1, -1},
/*01958*/     {224, -1, -1},
/*01959*/     {994, -1, -1},
/*01960*/     {223, -1, -1},
/*01961*/     {993, -1, -1},
/*01962*/     {225, -1, -1},
/*01963*/     {995, -1, -1},
/*01964*/     {226, -1, -1},
/*01965*/     {996, -1, -1},
/*01966*/     {227, -1, -1},
/*01967*/     {997, -1, -1},
/*01968*/     {226, -1, -1},
/*01969*/     {996, -1, -1},
/*01970*/     {228, -1, -1},
/*01971*/     {998, -1, -1},
/*01972*/     {229, -1, -1},
/*01973*/     {999, -1, -1},
/*01974*/     {230, -1, -1},
/*01975*/     {1000, -1, -1},
/*01976*/     {229, -1, -1},
/*01977*/     {999, -1, -1},
/*01978*/     {231, -1, -1},
/*01979*/     {1001, -1, -1},
/*01980*/     {232, -1, -1},
/*01981*/     {1002, -1, -1},
/*01982*/     {233, -1, -1},
/*01983*/     {1003, -1, -1},
/*01984*/     {232, -1, -1},
/*01985*/     {1002, -1, -1},
/*01986*/     {234, -1, -1},
/*01987*/     {1004, -1, -1},
/*01988*/     {235, -1, -1},
/*01989*/     {1005, -1, -1},
/*01990*/     {236, -1, -1},
/*01991*/     {1006, -1, -1},
/*01992*/     {235, -1, -1},
/*01993*/     {1005, -1, -1},
/*01994*/     {237, -1, -1},
/*01995*/     {1007, -1, -1},
/*01996*/     {238, -1, -1},
/*01997*/     {1008, -1, -1},
/*01998*/     {239, -1, -1},
/*01999*/     {1009, -1, -1},
/*02000*/     {238, -1, -1},
/*02001*/     {1008, -1, -1},
/*02002*/     {240, -1, -1},
/*02003*/     {1010, -1, -1},
/*02004*/     {241, -1, -1},
/*02005*/     {1011, -1, -1},
/*02006*/     {242, -1, -1},
/*02007*/     {1012, -1, -1},
/*02008*/     {241, -1, -1},
/*02009*/     {1011, -1, -1},
/*02010*/     {243, -1, -1},
/*02011*/     {1013, -1, -1},
/*02012*/     {244, -1, -1},
/*02013*/     {1014, -1, -1},
/*02014*/     {245, -1, -1},
/*02015*/     {1015, -1, -1},
/*02016*/     {244, -1, -1},
/*02017*/     {1014, -1, -1},
/*02018*/     {246, -1, -1},
/*02019*/     {1016, -1, -1},
/*02020*/     {247, -1, -1},
/*02021*/     {1017, -1, -1},
/*02022*/     {248, -1, -1},
/*02023*/     {1018, -1, -1},
/*02024*/     {247, -1, -1},
/*02025*/     {1017, -1, -1},
/*02026*/     {249, -1, -1},
/*02027*/     {1019, -1, -1},
/*02028*/     {250, -1, -1},
/*02029*/     {1020, -1, -1},
/*02030*/     {251, -1, -1},
/*02031*/     {1021, -1, -1},
/*02032*/     {250, -1, -1},
/*02033*/     {1020, -1, -1},
/*02034*/     {252, -1, -1},
/*02035*/     {1022, -1, -1},
/*02036*/     {253, -1, -1},
/*02037*/     {1023, -1, -1},
/*02038*/     {254, -1, -1},
/*02039*/     {1024, -1, -1},
/*02040*/     {253, -1, -1},
/*02041*/     {1023, -1, -1},
/*02042*/     {255, -1, -1},
/*02043*/     {1025, -1, -1},
/*02044*/     {256, -1, -1},
/*02045*/     {1026, -1, -1},
/*02046*/     {257, -1, -1},
/*02047*/     {1027, -1, -1},
/*02048*/     {256, -1, -1},
/*02049*/     {1026, -1, -1},
/*02050*/     {258, -1, -1},
/*02051*/     {1028, -1, -1},
/*02052*/     {259, -1, -1},
/*02053*/     {0, -1, -1},
/*02054*/     {260, -1, -1},
/*02055*/     {0, -1, -1},
/*02056*/     {259, -1, -1},
/*02057*/     {0, -1, -1},
/*02058*/     {261, -1, -1},
/*02059*/     {0, -1, -1},
/*02060*/     {262, -1, -1},
/*02061*/     {0, -1, -1},
/*02062*/     {263, -1, -1},
/*02063*/     {0, -1, -1},
/*02064*/     {262, -1, -1},
/*02065*/     {0, -1, -1},
/*02066*/     {264, -1, -1},
/*02067*/     {0, -1, -1},
/*02068*/     {265, -1, -1},
/*02069*/     {0, -1, -1},
/*02070*/     {266, -1, -1},
/*02071*/     {0, -1, -1},
/*02072*/     {265, -1, -1},
/*02073*/     {0, -1, -1},
/*02074*/     {267, -1, -1},
/*02075*/     {0, -1, -1},
/*02076*/     {268, -1, -1},
/*02077*/     {0, -1, -1},
/*02078*/     {269, -1, -1},
/*02079*/     {0, -1, -1},
/*02080*/     {268, -1, -1},
/*02081*/     {0, -1, -1},
/*02082*/     {270, -1, -1},
/*02083*/     {0, -1, -1},
/*02084*/     {271, -1, -1},
/*02085*/     {0, -1, -1},
/*02086*/     {272, -1, -1},
/*02087*/     {0, -1, -1},
/*02088*/     {271, -1, -1},
/*02089*/     {0, -1, -1},
/*02090*/     {273, -1, -1},
/*02091*/     {0, -1, -1},
/*02092*/     {274, -1, -1},
/*02093*/     {0, -1, -1},
/*02094*/     {275, -1, -1},
/*02095*/     {0, -1, -1},
/*02096*/     {274, -1, -1},
/*02097*/     {0, -1, -1},
/*02098*/     {276, -1, -1},
/*02099*/     {0, -1, -1},
/*02100*/     {277, -1, -1},
/*02101*/     {1029, -1, -1},
/*02102*/     {278, -1, -1},
/*02103*/     {1030, -1, -1},
/*02104*/     {277, -1, -1},
/*02105*/     {1029, -1, -1},
/*02106*/     {279, -1, -1},
/*02107*/     {1031, -1, -1},
/*02108*/     {280, -1, -1},
/*02109*/     {1032, -1, -1},
/*02110*/     {281, -1, -1},
/*02111*/     {1033, -1, -1},
/*02112*/     {280, -1, -1},
/*02113*/     {1032, -1, -1},
/*02114*/     {282, -1, -1},
/*02115*/     {1034, -1, -1},
/*02116*/     {283, -1, -1},
/*02117*/     {0, -1, -1},
/*02118*/     {284, -1, -1},
/*02119*/     {0, -1, -1},
/*02120*/     {283, -1, -1},
/*02121*/     {0, -1, -1},
/*02122*/     {285, -1, -1},
/*02123*/     {0, -1, -1},
/*02124*/     {286, -1, -1},
/*02125*/     {0, -1, -1},
/*02126*/     {287, -1, -1},
/*02127*/     {0, -1, -1},
/*02128*/     {286, -1, -1},
/*02129*/     {0, -1, -1},
/*02130*/     {288, -1, -1},
/*02131*/     {0, -1, -1},
/*02132*/     {289, -1, -1},
/*02133*/     {1035, -1, -1},
/*02134*/     {290, -1, -1},
/*02135*/     {1036, -1, -1},
/*02136*/     {289, -1, -1},
/*02137*/     {1035, -1, -1},
/*02138*/     {291, -1, -1},
/*02139*/     {1037, -1, -1},
/*02140*/     {292, -1, -1},
/*02141*/     {1038, -1, -1},
/*02142*/     {293, -1, -1},
/*02143*/     {1039, -1, -1},
/*02144*/     {292, -1, -1},
/*02145*/     {1038, -1, -1},
/*02146*/     {294, -1, -1},
/*02147*/     {1040, -1, -1},
/*02148*/     {295, -1, -1},
/*02149*/     {0, -1, -1},
/*02150*/     {296, -1, -1},
/*02151*/     {0, -1, -1},
/*02152*/     {295, -1, -1},
/*02153*/     {0, -1, -1},
/*02154*/     {297, -1, -1},
/*02155*/     {0, -1, -1},
/*02156*/     {0, -1, -1},
/*02157*/     {1045, -1, -1},
/*02158*/     {0, -1, -1},
/*02159*/     {1046, -1, -1},
/*02160*/     {0, -1, -1},
/*02161*/     {1047, -1, -1},
/*02162*/     {0, -1, -1},
/*02163*/     {1048, -1, -1},
/*02164*/     {298, -1, -1},
/*02165*/     {0, -1, -1},
/*02166*/     {299, -1, -1},
/*02167*/     {0, -1, -1},
/*02168*/     {298, -1, -1},
/*02169*/     {0, -1, -1},
/*02170*/     {300, -1, -1},
/*02171*/     {0, -1, -1},
/*02172*/     {301, -1, -1},
/*02173*/     {0, -1, -1},
/*02174*/     {302, -1, -1},
/*02175*/     {0, -1, -1},
/*02176*/     {301, -1, -1},
/*02177*/     {0, -1, -1},
/*02178*/     {303, -1, -1},
/*02179*/     {0, -1, -1},
/*02180*/     {304, -1, -1},
/*02181*/     {0, -1, -1},
/*02182*/     {305, -1, -1},
/*02183*/     {0, -1, -1},
/*02184*/     {304, -1, -1},
/*02185*/     {0, -1, -1},
/*02186*/     {306, -1, -1},
/*02187*/     {0, -1, -1},
/*02188*/     {307, -1, -1},
/*02189*/     {0, -1, -1},
/*02190*/     {308, -1, -1},
/*02191*/     {0, -1, -1},
/*02192*/     {307, -1, -1},
/*02193*/     {0, -1, -1},
/*02194*/     {309, -1, -1},
/*02195*/     {0, -1, -1},
/*02196*/     {310, -1, -1},
/*02197*/     {0, -1, -1},
/*02198*/     {311, -1, -1},
/*02199*/     {0, -1, -1},
/*02200*/     {310, -1, -1},
/*02201*/     {0, -1, -1},
/*02202*/     {312, -1, -1},
/*02203*/     {0, -1, -1},
/*02204*/     {313, -1, -1},
/*02205*/     {0, -1, -1},
/*02206*/     {314, -1, -1},
/*02207*/     {0, -1, -1},
/*02208*/     {313, -1, -1},
/*02209*/     {0, -1, -1},
/*02210*/     {315, -1, -1},
/*02211*/     {0, -1, -1},
/*02212*/     {316, -1, -1},
/*02213*/     {0, -1, -1},
/*02214*/     {317, -1, -1},
/*02215*/     {0, -1, -1},
/*02216*/     {316, -1, -1},
/*02217*/     {0, -1, -1},
/*02218*/     {318, -1, -1},
/*02219*/     {0, -1, -1},
/*02220*/     {319, -1, -1},
/*02221*/     {0, -1, -1},
/*02222*/     {320, -1, -1},
/*02223*/     {0, -1, -1},
/*02224*/     {319, -1, -1},
/*02225*/     {0, -1, -1},
/*02226*/     {321, -1, -1},
/*02227*/     {0, -1, -1},
/*02228*/     {322, -1, -1},
/*02229*/     {0, -1, -1},
/*02230*/     {323, -1, -1},
/*02231*/     {0, -1, -1},
/*02232*/     {322, -1, -1},
/*02233*/     {0, -1, -1},
/*02234*/     {324, -1, -1},
/*02235*/     {0, -1, -1},
/*02236*/     {325, -1, -1},
/*02237*/     {0, -1, -1},
/*02238*/     {326, -1, -1},
/*02239*/     {0, -1, -1},
/*02240*/     {325, -1, -1},
/*02241*/     {0, -1, -1},
/*02242*/     {327, -1, -1},
/*02243*/     {0, -1, -1},
/*02244*/     {328, -1, -1},
/*02245*/     {0, -1, -1},
/*02246*/     {329, -1, -1},
/*02247*/     {0, -1, -1},
/*02248*/     {328, -1, -1},
/*02249*/     {0, -1, -1},
/*02250*/     {330, -1, -1},
/*02251*/     {0, -1, -1},
/*02252*/     {331, -1, -1},
/*02253*/     {0, -1, -1},
/*02254*/     {332, -1, -1},
/*02255*/     {0, -1, -1},
/*02256*/     {331, -1, -1},
/*02257*/     {0, -1, -1},
/*02258*/     {333, -1, -1},
/*02259*/     {0, -1, -1},
/*02260*/     {556, -1, -1},
/*02261*/     {0, -1, -1},
/*02262*/     {556, -1, -1},
/*02263*/     {0, -1, -1},
/*02264*/     {556, -1, -1},
/*02265*/     {0, -1, -1},
/*02266*/     {557, -1, -1},
/*02267*/     {0, -1, -1},
/*02268*/     {558, -1, -1},
/*02269*/     {0, -1, -1},
/*02270*/     {558, -1, -1},
/*02271*/     {0, -1, -1},
/*02272*/     {558, -1, -1},
/*02273*/     {0, -1, -1},
/*02274*/     {559, -1, -1},
/*02275*/     {0, -1, -1},
/*02276*/     {560, -1, -1},
/*02277*/     {0, -1, -1},
/*02278*/     {560, -1, -1},
/*02279*/     {0, -1, -1},
/*02280*/     {560, -1, -1},
/*02281*/     {0, -1, -1},
/*02282*/     {561, -1, -1},
/*02283*/     {0, -1, -1},
/*02284*/     {562, -1, -1},
/*02285*/     {0, -1, -1},
/*02286*/     {562, -1, -1},
/*02287*/     {0, -1, -1},
/*02288*/     {562, -1, -1},
/*02289*/     {0, -1, -1},
/*02290*/     {563, -1, -1},
/*02291*/     {0, -1, -1},
/*02292*/     {564, -1, -1},
/*02293*/     {0, -1, -1},
/*02294*/     {564, -1, -1},
/*02295*/     {0, -1, -1},
/*02296*/     {564, -1, -1},
/*02297*/     {0, -1, -1},
/*02298*/     {565, -1, -1},
/*02299*/     {0, -1, -1},
/*02300*/     {566, -1, -1},
/*02301*/     {0, -1, -1},
/*02302*/     {566, -1, -1},
/*02303*/     {0, -1, -1},
/*02304*/     {566, -1, -1},
/*02305*/     {0, -1, -1},
/*02306*/     {567, -1, -1},
/*02307*/     {0, -1, -1},
/*02308*/     {568, -1, -1},
/*02309*/     {0, -1, -1},
/*02310*/     {568, -1, -1},
/*02311*/     {0, -1, -1},
/*02312*/     {568, -1, -1},
/*02313*/     {0, -1, -1},
/*02314*/     {569, -1, -1},
/*02315*/     {0, -1, -1},
/*02316*/     {570, -1, -1},
/*02317*/     {0, -1, -1},
/*02318*/     {570, -1, -1},
/*02319*/     {0, -1, -1},
/*02320*/     {570, -1, -1},
/*02321*/     {0, -1, -1},
/*02322*/     {571, -1, -1},
/*02323*/     {0, -1, -1},
/*02324*/     {572, -1, -1},
/*02325*/     {0, -1, -1},
/*02326*/     {572, -1, -1},
/*02327*/     {0, -1, -1},
/*02328*/     {572, -1, -1},
/*02329*/     {0, -1, -1},
/*02330*/     {573, -1, -1},
/*02331*/     {0, -1, -1},
/*02332*/     {334, -1, -1},
/*02333*/     {0, -1, -1},
/*02334*/     {335, -1, -1},
/*02335*/     {0, -1, -1},
/*02336*/     {334, -1, -1},
/*02337*/     {0, -1, -1},
/*02338*/     {336, -1, -1},
/*02339*/     {0, -1, -1},
/*02340*/     {337, -1, -1},
/*02341*/     {0, -1, -1},
/*02342*/     {338, -1, -1},
/*02343*/     {0, -1, -1},
/*02344*/     {337, -1, -1},
/*02345*/     {0, -1, -1},
/*02346*/     {339, -1, -1},
/*02347*/     {0, -1, -1},
/*02348*/     {340, -1, -1},
/*02349*/     {0, -1, -1},
/*02350*/     {341, -1, -1},
/*02351*/     {0, -1, -1},
/*02352*/     {340, -1, -1},
/*02353*/     {0, -1, -1},
/*02354*/     {342, -1, -1},
/*02355*/     {0, -1, -1},
/*02356*/     {343, -1, -1},
/*02357*/     {0, -1, -1},
/*02358*/     {344, -1, -1},
/*02359*/     {0, -1, -1},
/*02360*/     {343, -1, -1},
/*02361*/     {0, -1, -1},
/*02362*/     {345, -1, -1},
/*02363*/     {0, -1, -1},
/*02364*/     {346, -1, -1},
/*02365*/     {0, -1, -1},
/*02366*/     {347, -1, -1},
/*02367*/     {0, -1, -1},
/*02368*/     {346, -1, -1},
/*02369*/     {0, -1, -1},
/*02370*/     {348, -1, -1},
/*02371*/     {0, -1, -1},
/*02372*/     {349, -1, -1},
/*02373*/     {0, -1, -1},
/*02374*/     {350, -1, -1},
/*02375*/     {0, -1, -1},
/*02376*/     {349, -1, -1},
/*02377*/     {0, -1, -1},
/*02378*/     {351, -1, -1},
/*02379*/     {0, -1, -1},
/*02380*/     {352, -1, -1},
/*02381*/     {0, -1, -1},
/*02382*/     {353, -1, -1},
/*02383*/     {0, -1, -1},
/*02384*/     {352, -1, -1},
/*02385*/     {0, -1, -1},
/*02386*/     {354, -1, -1},
/*02387*/     {0, -1, -1},
/*02388*/     {355, -1, -1},
/*02389*/     {0, -1, -1},
/*02390*/     {356, -1, -1},
/*02391*/     {0, -1, -1},
/*02392*/     {355, -1, -1},
/*02393*/     {0, -1, -1},
/*02394*/     {357, -1, -1},
/*02395*/     {0, -1, -1},
/*02396*/     {358, -1, -1},
/*02397*/     {0, -1, -1},
/*02398*/     {359, -1, -1},
/*02399*/     {0, -1, -1},
/*02400*/     {358, -1, -1},
/*02401*/     {0, -1, -1},
/*02402*/     {360, -1, -1},
/*02403*/     {0, -1, -1},
/*02404*/     {361, -1, -1},
/*02405*/     {0, -1, -1},
/*02406*/     {362, -1, -1},
/*02407*/     {0, -1, -1},
/*02408*/     {361, -1, -1},
/*02409*/     {0, -1, -1},
/*02410*/     {363, -1, -1},
/*02411*/     {0, -1, -1},
/*02412*/     {364, -1, -1},
/*02413*/     {0, -1, -1},
/*02414*/     {365, -1, -1},
/*02415*/     {0, -1, -1},
/*02416*/     {364, -1, -1},
/*02417*/     {0, -1, -1},
/*02418*/     {366, -1, -1},
/*02419*/     {0, -1, -1},
/*02420*/     {367, -1, -1},
/*02421*/     {0, -1, -1},
/*02422*/     {368, -1, -1},
/*02423*/     {0, -1, -1},
/*02424*/     {367, -1, -1},
/*02425*/     {0, -1, -1},
/*02426*/     {369, -1, -1},
/*02427*/     {0, -1, -1},
/*02428*/     {370, -1, -1},
/*02429*/     {0, -1, -1},
/*02430*/     {371, -1, -1},
/*02431*/     {0, -1, -1},
/*02432*/     {370, -1, -1},
/*02433*/     {0, -1, -1},
/*02434*/     {372, -1, -1},
/*02435*/     {0, -1, -1},
/*02436*/     {373, -1, -1},
/*02437*/     {0, -1, -1},
/*02438*/     {374, -1, -1},
/*02439*/     {0, -1, -1},
/*02440*/     {373, -1, -1},
/*02441*/     {0, -1, -1},
/*02442*/     {375, -1, -1},
/*02443*/     {0, -1, -1},
/*02444*/     {376, -1, -1},
/*02445*/     {0, -1, -1},
/*02446*/     {377, -1, -1},
/*02447*/     {0, -1, -1},
/*02448*/     {376, -1, -1},
/*02449*/     {0, -1, -1},
/*02450*/     {378, -1, -1},
/*02451*/     {0, -1, -1},
/*02452*/     {379, -1, -1},
/*02453*/     {0, -1, -1},
/*02454*/     {380, -1, -1},
/*02455*/     {0, -1, -1},
/*02456*/     {379, -1, -1},
/*02457*/     {0, -1, -1},
/*02458*/     {381, -1, -1},
/*02459*/     {0, -1, -1},
/*02460*/     {382, -1, -1},
/*02461*/     {0, -1, -1},
/*02462*/     {383, -1, -1},
/*02463*/     {0, -1, -1},
/*02464*/     {382, -1, -1},
/*02465*/     {0, -1, -1},
/*02466*/     {384, -1, -1},
/*02467*/     {0, -1, -1},
/*02468*/     {385, -1, -1},
/*02469*/     {0, -1, -1},
/*02470*/     {386, -1, -1},
/*02471*/     {0, -1, -1},
/*02472*/     {385, -1, -1},
/*02473*/     {0, -1, -1},
/*02474*/     {387, -1, -1},
/*02475*/     {0, -1, -1},
/*02476*/     {388, -1, -1},
/*02477*/     {0, -1, -1},
/*02478*/     {389, -1, -1},
/*02479*/     {0, -1, -1},
/*02480*/     {388, -1, -1},
/*02481*/     {0, -1, -1},
/*02482*/     {390, -1, -1},
/*02483*/     {0, -1, -1},
/*02484*/     {391, -1, -1},
/*02485*/     {0, -1, -1},
/*02486*/     {392, -1, -1},
/*02487*/     {0, -1, -1},
/*02488*/     {391, -1, -1},
/*02489*/     {0, -1, -1},
/*02490*/     {393, -1, -1},
/*02491*/     {0, -1, -1},
/*02492*/     {394, -1, -1},
/*02493*/     {0, -1, -1},
/*02494*/     {395, -1, -1},
/*02495*/     {0, -1, -1},
/*02496*/     {394, -1, -1},
/*02497*/     {0, -1, -1},
/*02498*/     {396, -1, -1},
/*02499*/     {0, -1, -1},
/*02500*/     {397, -1, -1},
/*02501*/     {0, -1, -1},
/*02502*/     {398, -1, -1},
/*02503*/     {0, -1, -1},
/*02504*/     {397, -1, -1},
/*02505*/     {0, -1, -1},
/*02506*/     {399, -1, -1},
/*02507*/     {0, -1, -1},
/*02508*/     {400, -1, -1},
/*02509*/     {0, -1, -1},
/*02510*/     {401, -1, -1},
/*02511*/     {0, -1, -1},
/*02512*/     {400, -1, -1},
/*02513*/     {0, -1, -1},
/*02514*/     {402, -1, -1},
/*02515*/     {0, -1, -1},
/*02516*/     {403, -1, -1},
/*02517*/     {0, -1, -1},
/*02518*/     {404, -1, -1},
/*02519*/     {0, -1, -1},
/*02520*/     {403, -1, -1},
/*02521*/     {0, -1, -1},
/*02522*/     {405, -1, -1},
/*02523*/     {0, -1, -1},
/*02524*/     {406, -1, -1},
/*02525*/     {0, -1, -1},
/*02526*/     {407, -1, -1},
/*02527*/     {0, -1, -1},
/*02528*/     {406, -1, -1},
/*02529*/     {0, -1, -1},
/*02530*/     {408, -1, -1},
/*02531*/     {0, -1, -1},
/*02532*/     {409, -1, -1},
/*02533*/     {0, -1, -1},
/*02534*/     {410, -1, -1},
/*02535*/     {0, -1, -1},
/*02536*/     {409, -1, -1},
/*02537*/     {0, -1, -1},
/*02538*/     {411, -1, -1},
/*02539*/     {0, -1, -1},
/*02540*/     {412, -1, -1},
/*02541*/     {0, -1, -1},
/*02542*/     {413, -1, -1},
/*02543*/     {0, -1, -1},
/*02544*/     {412, -1, -1},
/*02545*/     {0, -1, -1},
/*02546*/     {414, -1, -1},
/*02547*/     {0, -1, -1},
/*02548*/     {415, -1, -1},
/*02549*/     {0, -1, -1},
/*02550*/     {416, -1, -1},
/*02551*/     {0, -1, -1},
/*02552*/     {415, -1, -1},
/*02553*/     {0, -1, -1},
/*02554*/     {417, -1, -1},
/*02555*/     {0, -1, -1},
/*02556*/     {418, -1, -1},
/*02557*/     {0, -1, -1},
/*02558*/     {419, -1, -1},
/*02559*/     {0, -1, -1},
/*02560*/     {418, -1, -1},
/*02561*/     {0, -1, -1},
/*02562*/     {420, -1, -1},
/*02563*/     {0, -1, -1},
/*02564*/     {421, -1, -1},
/*02565*/     {0, -1, -1},
/*02566*/     {422, -1, -1},
/*02567*/     {0, -1, -1},
/*02568*/     {421, -1, -1},
/*02569*/     {0, -1, -1},
/*02570*/     {423, -1, -1},
/*02571*/     {0, -1, -1},
/*02572*/     {424, -1, -1},
/*02573*/     {0, -1, -1},
/*02574*/     {425, -1, -1},
/*02575*/     {0, -1, -1},
/*02576*/     {424, -1, -1},
/*02577*/     {0, -1, -1},
/*02578*/     {426, -1, -1},
/*02579*/     {0, -1, -1},
/*02580*/     {427, -1, -1},
/*02581*/     {0, -1, -1},
/*02582*/     {428, -1, -1},
/*02583*/     {0, -1, -1},
/*02584*/     {427, -1, -1},
/*02585*/     {0, -1, -1},
/*02586*/     {429, -1, -1},
/*02587*/     {0, -1, -1},
/*02588*/     {430, -1, -1},
/*02589*/     {0, -1, -1},
/*02590*/     {431, -1, -1},
/*02591*/     {0, -1, -1},
/*02592*/     {430, -1, -1},
/*02593*/     {0, -1, -1},
/*02594*/     {432, -1, -1},
/*02595*/     {0, -1, -1},
/*02596*/     {433, -1, -1},
/*02597*/     {0, -1, -1},
/*02598*/     {434, -1, -1},
/*02599*/     {0, -1, -1},
/*02600*/     {433, -1, -1},
/*02601*/     {0, -1, -1},
/*02602*/     {435, -1, -1},
/*02603*/     {0, -1, -1},
/*02604*/     {436, -1, -1},
/*02605*/     {0, -1, -1},
/*02606*/     {437, -1, -1},
/*02607*/     {0, -1, -1},
/*02608*/     {436, -1, -1},
/*02609*/     {0, -1, -1},
/*02610*/     {438, -1, -1},
/*02611*/     {0, -1, -1},
/*02612*/     {439, -1, -1},
/*02613*/     {0, -1, -1},
/*02614*/     {440, -1, -1},
/*02615*/     {0, -1, -1},
/*02616*/     {439, -1, -1},
/*02617*/     {0, -1, -1},
/*02618*/     {441, -1, -1},
/*02619*/     {0, -1, -1},
/*02620*/     {442, -1, -1},
/*02621*/     {0, -1, -1},
/*02622*/     {443, -1, -1},
/*02623*/     {0, -1, -1},
/*02624*/     {442, -1, -1},
/*02625*/     {0, -1, -1},
/*02626*/     {444, -1, -1},
/*02627*/     {0, -1, -1},
/*02628*/     {2644, 12, 1},
/*02629*/     {2646, 12, 1},
/*02630*/     {2648, 12, 1},
/*02631*/     {2650, 12, 1},
/*02632*/     {2652, 12, 1},
/*02633*/     {2654, 12, 1},
/*02634*/     {2656, 12, 1},
/*02635*/     {2658, 12, 1},
/*02636*/     {2660, 12, 1},
/*02637*/     {2662, 12, 1},
/*02638*/     {2664, 12, 1},
/*02639*/     {2666, 12, 1},
/*02640*/     {2668, 12, 1},
/*02641*/     {2670, 12, 1},
/*02642*/     {2672, 12, 1},
/*02643*/     {2674, 12, 1},
/*02644*/     {1374, -1, -1},
/*02645*/     {1390, -1, -1},
/*02646*/     {1382, -1, -1},
/*02647*/     {1398, -1, -1},
/*02648*/     {1375, -1, -1},
/*02649*/     {1391, -1, -1},
/*02650*/     {1383, -1, -1},
/*02651*/     {1399, -1, -1},
/*02652*/     {1376, -1, -1},
/*02653*/     {1392, -1, -1},
/*02654*/     {1384, -1, -1},
/*02655*/     {1400, -1, -1},
/*02656*/     {1377, -1, -1},
/*02657*/     {1393, -1, -1},
/*02658*/     {1385, -1, -1},
/*02659*/     {1401, -1, -1},
/*02660*/     {1378, -1, -1},
/*02661*/     {1394, -1, -1},
/*02662*/     {1386, -1, -1},
/*02663*/     {1402, -1, -1},
/*02664*/     {1379, -1, -1},
/*02665*/     {1395, -1, -1},
/*02666*/     {1387, -1, -1},
/*02667*/     {1403, -1, -1},
/*02668*/     {1380, -1, -1},
/*02669*/     {1396, -1, -1},
/*02670*/     {1388, -1, -1},
/*02671*/     {1404, -1, -1},
/*02672*/     {1381, -1, -1},
/*02673*/     {1397, -1, -1},
/*02674*/     {1389, -1, -1},
/*02675*/     {1405, -1, -1},
/*02676*/     {2684, 6, 3},
/*02677*/     {2704, 6, 3},
/*02678*/     {2724, 6, 3},
/*02679*/     {2744, 6, 3},
/*02680*/     {2764, 6, 3},
/*02681*/     {2784, 6, 3},
/*02682*/     {2804, 6, 3},
/*02683*/     {2824, 6, 3},
/*02684*/     {2692, 12, 1},
/*02685*/     {0, -1, -1},
/*02686*/     {2694, 12, 1},
/*02687*/     {2696, 12, 1},
/*02688*/     {0, -1, -1},
/*02689*/     {2698, 12, 1},
/*02690*/     {2700, 12, 1},
/*02691*/     {2702, 12, 1},
/*02692*/     {1120, -1, -1},
/*02693*/     {1121, -1, -1},
/*02694*/     {1136, -1, -1},
/*02695*/     {1137, -1, -1},
/*02696*/     {1152, -1, -1},
/*02697*/     {1153, -1, -1},
/*02698*/     {1168, -1, -1},
/*02699*/     {1169, -1, -1},
/*02700*/     {1184, -1, -1},
/*02701*/     {1185, -1, -1},
/*02702*/     {1200, -1, -1},
/*02703*/     {1201, -1, -1},
/*02704*/     {2712, 12, 1},
/*02705*/     {0, -1, -1},
/*02706*/     {2714, 12, 1},
/*02707*/     {2716, 12, 1},
/*02708*/     {0, -1, -1},
/*02709*/     {2718, 12, 1},
/*02710*/     {2720, 12, 1},
/*02711*/     {2722, 12, 1},
/*02712*/     {1122, -1, -1},
/*02713*/     {1123, -1, -1},
/*02714*/     {1138, -1, -1},
/*02715*/     {1139, -1, -1},
/*02716*/     {1154, -1, -1},
/*02717*/     {1155, -1, -1},
/*02718*/     {1170, -1, -1},
/*02719*/     {1171, -1, -1},
/*02720*/     {1186, -1, -1},
/*02721*/     {1187, -1, -1},
/*02722*/     {1202, -1, -1},
/*02723*/     {1203, -1, -1},
/*02724*/     {2732, 12, 1},
/*02725*/     {0, -1, -1},
/*02726*/     {2734, 12, 1},
/*02727*/     {2736, 12, 1},
/*02728*/     {0, -1, -1},
/*02729*/     {2738, 12, 1},
/*02730*/     {2740, 12, 1},
/*02731*/     {2742, 12, 1},
/*02732*/     {1124, -1, -1},
/*02733*/     {1125, -1, -1},
/*02734*/     {1140, -1, -1},
/*02735*/     {1141, -1, -1},
/*02736*/     {1156, -1, -1},
/*02737*/     {1157, -1, -1},
/*02738*/     {1172, -1, -1},
/*02739*/     {1173, -1, -1},
/*02740*/     {1188, -1, -1},
/*02741*/     {1189, -1, -1},
/*02742*/     {1204, -1, -1},
/*02743*/     {1205, -1, -1},
/*02744*/     {2752, 12, 1},
/*02745*/     {0, -1, -1},
/*02746*/     {2754, 12, 1},
/*02747*/     {2756, 12, 1},
/*02748*/     {0, -1, -1},
/*02749*/     {2758, 12, 1},
/*02750*/     {2760, 12, 1},
/*02751*/     {2762, 12, 1},
/*02752*/     {1126, -1, -1},
/*02753*/     {1127, -1, -1},
/*02754*/     {1142, -1, -1},
/*02755*/     {1143, -1, -1},
/*02756*/     {1158, -1, -1},
/*02757*/     {1159, -1, -1},
/*02758*/     {1174, -1, -1},
/*02759*/     {1175, -1, -1},
/*02760*/     {1190, -1, -1},
/*02761*/     {1191, -1, -1},
/*02762*/     {1206, -1, -1},
/*02763*/     {1207, -1, -1},
/*02764*/     {2772, 12, 1},
/*02765*/     {0, -1, -1},
/*02766*/     {2774, 12, 1},
/*02767*/     {2776, 12, 1},
/*02768*/     {0, -1, -1},
/*02769*/     {2778, 12, 1},
/*02770*/     {2780, 12, 1},
/*02771*/     {2782, 12, 1},
/*02772*/     {1128, -1, -1},
/*02773*/     {1129, -1, -1},
/*02774*/     {1144, -1, -1},
/*02775*/     {1145, -1, -1},
/*02776*/     {1160, -1, -1},
/*02777*/     {1161, -1, -1},
/*02778*/     {1176, -1, -1},
/*02779*/     {1177, -1, -1},
/*02780*/     {1192, -1, -1},
/*02781*/     {1193, -1, -1},
/*02782*/     {1208, -1, -1},
/*02783*/     {1209, -1, -1},
/*02784*/     {2792, 12, 1},
/*02785*/     {0, -1, -1},
/*02786*/     {2794, 12, 1},
/*02787*/     {2796, 12, 1},
/*02788*/     {0, -1, -1},
/*02789*/     {2798, 12, 1},
/*02790*/     {2800, 12, 1},
/*02791*/     {2802, 12, 1},
/*02792*/     {1130, -1, -1},
/*02793*/     {1131, -1, -1},
/*02794*/     {1146, -1, -1},
/*02795*/     {1147, -1, -1},
/*02796*/     {1162, -1, -1},
/*02797*/     {1163, -1, -1},
/*02798*/     {1178, -1, -1},
/*02799*/     {1179, -1, -1},
/*02800*/     {1194, -1, -1},
/*02801*/     {1195, -1, -1},
/*02802*/     {1210, -1, -1},
/*02803*/     {1211, -1, -1},
/*02804*/     {2812, 12, 1},
/*02805*/     {0, -1, -1},
/*02806*/     {2814, 12, 1},
/*02807*/     {2816, 12, 1},
/*02808*/     {0, -1, -1},
/*02809*/     {2818, 12, 1},
/*02810*/     {2820, 12, 1},
/*02811*/     {2822, 12, 1},
/*02812*/     {1132, -1, -1},
/*02813*/     {1133, -1, -1},
/*02814*/     {1148, -1, -1},
/*02815*/     {1149, -1, -1},
/*02816*/     {1164, -1, -1},
/*02817*/     {1165, -1, -1},
/*02818*/     {1180, -1, -1},
/*02819*/     {1181, -1, -1},
/*02820*/     {1196, -1, -1},
/*02821*/     {1197, -1, -1},
/*02822*/     {1212, -1, -1},
/*02823*/     {1213, -1, -1},
/*02824*/     {2832, 12, 1},
/*02825*/     {0, -1, -1},
/*02826*/     {2834, 12, 1},
/*02827*/     {2836, 12, 1},
/*02828*/     {0, -1, -1},
/*02829*/     {2838, 12, 1},
/*02830*/     {2840, 12, 1},
/*02831*/     {2842, 12, 1},
/*02832*/     {1134, -1, -1},
/*02833*/     {1135, -1, -1},
/*02834*/     {1150, -1, -1},
/*02835*/     {1151, -1, -1},
/*02836*/     {1166, -1, -1},
/*02837*/     {1167, -1, -1},
/*02838*/     {1182, -1, -1},
/*02839*/     {1183, -1, -1},
/*02840*/     {1198, -1, -1},
/*02841*/     {1199, -1, -1},
/*02842*/     {1214, -1, -1},
/*02843*/     {1215, -1, -1},
/*02844*/     {2852, 12, 2},
/*02845*/     {2864, 12, 2},
/*02846*/     {2876, 13, 1},
/*02847*/     {2878, 26, 1},
/*02848*/     {0, -1, -1},
/*02849*/     {0, -1, -1},
/*02850*/     {167, -1, -1},
/*02851*/     {172, -1, -1},
/*02852*/     {2856, 36, 1},
/*02853*/     {2858, 36, 1},
/*02854*/     {2860, 36, 1},
/*02855*/     {2862, 36, 1},
/*02856*/     {174, -1, -1},
/*02857*/     {176, -1, -1},
/*02858*/     {175, -1, -1},
/*02859*/     {177, -1, -1},
/*02860*/     {182, -1, -1},
/*02861*/     {184, -1, -1},
/*02862*/     {183, -1, -1},
/*02863*/     {185, -1, -1},
/*02864*/     {2868, 36, 1},
/*02865*/     {2870, 36, 1},
/*02866*/     {2872, 36, 1},
/*02867*/     {2874, 36, 1},
/*02868*/     {178, -1, -1},
/*02869*/     {180, -1, -1},
/*02870*/     {179, -1, -1},
/*02871*/     {181, -1, -1},
/*02872*/     {186, -1, -1},
/*02873*/     {188, -1, -1},
/*02874*/     {187, -1, -1},
/*02875*/     {189, -1, -1},
/*02876*/     {168, -1, -1},
/*02877*/     {169, -1, -1},
/*02878*/     {170, -1, -1},
/*02879*/     {171, -1, -1},
/*02880*/     {445, -1, -1},
/*02881*/     {446, -1, -1},
/*02882*/     {445, -1, -1},
/*02883*/     {447, -1, -1},
/*02884*/     {448, -1, -1},
/*02885*/     {449, -1, -1},
/*02886*/     {448, -1, -1},
/*02887*/     {450, -1, -1},
/*02888*/     {451, -1, -1},
/*02889*/     {452, -1, -1},
/*02890*/     {451, -1, -1},
/*02891*/     {453, -1, -1},
/*02892*/     {454, -1, -1},
/*02893*/     {455, -1, -1},
/*02894*/     {454, -1, -1},
/*02895*/     {456, -1, -1},
/*02896*/     {457, -1, -1},
/*02897*/     {458, -1, -1},
/*02898*/     {457, -1, -1},
/*02899*/     {459, -1, -1},
/*02900*/     {460, -1, -1},
/*02901*/     {461, -1, -1},
/*02902*/     {460, -1, -1},
/*02903*/     {462, -1, -1},
/*02904*/     {463, -1, -1},
/*02905*/     {464, -1, -1},
/*02906*/     {463, -1, -1},
/*02907*/     {465, -1, -1},
/*02908*/     {466, -1, -1},
/*02909*/     {467, -1, -1},
/*02910*/     {466, -1, -1},
/*02911*/     {468, -1, -1},
/*02912*/     {469, -1, -1},
/*02913*/     {470, -1, -1},
/*02914*/     {469, -1, -1},
/*02915*/     {471, -1, -1},
/*02916*/     {472, -1, -1},
/*02917*/     {473, -1, -1},
/*02918*/     {472, -1, -1},
/*02919*/     {474, -1, -1},
/*02920*/     {475, -1, -1},
/*02921*/     {476, -1, -1},
/*02922*/     {475, -1, -1},
/*02923*/     {477, -1, -1},
/*02924*/     {478, -1, -1},
/*02925*/     {479, -1, -1},
/*02926*/     {478, -1, -1},
/*02927*/     {480, -1, -1},
/*02928*/     {481, -1, -1},
/*02929*/     {482, -1, -1},
/*02930*/     {481, -1, -1},
/*02931*/     {483, -1, -1},
/*02932*/     {484, -1, -1},
/*02933*/     {485, -1, -1},
/*02934*/     {484, -1, -1},
/*02935*/     {486, -1, -1},
/*02936*/     {487, -1, -1},
/*02937*/     {488, -1, -1},
/*02938*/     {487, -1, -1},
/*02939*/     {489, -1, -1},
/*02940*/     {490, -1, -1},
/*02941*/     {491, -1, -1},
/*02942*/     {490, -1, -1},
/*02943*/     {492, -1, -1},
/*02944*/     {493, -1, -1},
/*02945*/     {494, -1, -1},
/*02946*/     {493, -1, -1},
/*02947*/     {495, -1, -1},
/*02948*/     {496, -1, -1},
/*02949*/     {497, -1, -1},
/*02950*/     {496, -1, -1},
/*02951*/     {498, -1, -1},
/*02952*/     {499, -1, -1},
/*02953*/     {500, -1, -1},
/*02954*/     {499, -1, -1},
/*02955*/     {501, -1, -1},
/*02956*/     {502, -1, -1},
/*02957*/     {503, -1, -1},
/*02958*/     {502, -1, -1},
/*02959*/     {504, -1, -1},
/*02960*/     {505, -1, -1},
/*02961*/     {506, -1, -1},
/*02962*/     {505, -1, -1},
/*02963*/     {507, -1, -1},
/*02964*/     {508, -1, -1},
/*02965*/     {509, -1, -1},
/*02966*/     {508, -1, -1},
/*02967*/     {510, -1, -1},
/*02968*/     {511, -1, -1},
/*02969*/     {512, -1, -1},
/*02970*/     {511, -1, -1},
/*02971*/     {513, -1, -1},
/*02972*/     {514, -1, -1},
/*02973*/     {515, -1, -1},
/*02974*/     {514, -1, -1},
/*02975*/     {516, -1, -1},
/*02976*/     {0, -1, -1},
/*02977*/     {0, -1, -1},
/*02978*/     {0, -1, -1},
/*02979*/     {0, -1, -1},
/*02980*/     {0, -1, -1},
/*02981*/     {0, -1, -1},
/*02982*/     {0, -1, -1},
/*02983*/     {0, -1, -1},
/*02984*/     {0, -1, -1},
/*02985*/     {0, -1, -1},
/*02986*/     {0, -1, -1},
/*02987*/     {0, -1, -1},
/*02988*/     {517, -1, -1},
/*02989*/     {518, -1, -1},
/*02990*/     {517, -1, -1},
/*02991*/     {519, -1, -1},
/*02992*/     {0, -1, -1},
/*02993*/     {0, -1, -1},
/*02994*/     {0, -1, -1},
/*02995*/     {0, -1, -1},
/*02996*/     {0, -1, -1},
/*02997*/     {0, -1, -1},
/*02998*/     {0, -1, -1},
/*02999*/     {0, -1, -1},
/*03000*/     {0, -1, -1},
/*03001*/     {0, -1, -1},
/*03002*/     {0, -1, -1},
/*03003*/     {0, -1, -1},
/*03004*/     {0, -1, -1},
/*03005*/     {0, -1, -1},
/*03006*/     {0, -1, -1},
/*03007*/     {0, -1, -1},
/*03008*/     {520, -1, -1},
/*03009*/     {521, -1, -1},
/*03010*/     {520, -1, -1},
/*03011*/     {522, -1, -1},
/*03012*/     {523, -1, -1},
/*03013*/     {524, -1, -1},
/*03014*/     {523, -1, -1},
/*03015*/     {525, -1, -1},
/*03016*/     {526, -1, -1},
/*03017*/     {527, -1, -1},
/*03018*/     {526, -1, -1},
/*03019*/     {528, -1, -1},
/*03020*/     {529, -1, -1},
/*03021*/     {530, -1, -1},
/*03022*/     {529, -1, -1},
/*03023*/     {531, -1, -1},
/*03024*/     {532, -1, -1},
/*03025*/     {533, -1, -1},
/*03026*/     {532, -1, -1},
/*03027*/     {534, -1, -1},
/*03028*/     {535, -1, -1},
/*03029*/     {536, -1, -1},
/*03030*/     {535, -1, -1},
/*03031*/     {537, -1, -1},
/*03032*/     {538, -1, -1},
/*03033*/     {539, -1, -1},
/*03034*/     {538, -1, -1},
/*03035*/     {540, -1, -1},
/*03036*/     {541, -1, -1},
/*03037*/     {542, -1, -1},
/*03038*/     {541, -1, -1},
/*03039*/     {543, -1, -1},
/*03040*/     {544, -1, -1},
/*03041*/     {545, -1, -1},
/*03042*/     {544, -1, -1},
/*03043*/     {546, -1, -1},
/*03044*/     {547, -1, -1},
/*03045*/     {548, -1, -1},
/*03046*/     {547, -1, -1},
/*03047*/     {549, -1, -1},
/*03048*/     {550, -1, -1},
/*03049*/     {551, -1, -1},
/*03050*/     {550, -1, -1},
/*03051*/     {552, -1, -1},
/*03052*/     {553, -1, -1},
/*03053*/     {554, -1, -1},
/*03054*/     {553, -1, -1},
/*03055*/     {555, -1, -1},
/*03056*/     {0, -1, -1},
/*03057*/     {0, -1, -1},
/*03058*/     {0, -1, -1},
/*03059*/     {0, -1, -1},
/*03060*/     {0, -1, -1},
/*03061*/     {0, -1, -1},
/*03062*/     {0, -1, -1},
/*03063*/     {0, -1, -1},
/*03064*/     {0, -1, -1},
/*03065*/     {0, -1, -1},
/*03066*/     {0, -1, -1},
/*03067*/     {0, -1, -1},
/*03068*/     {0, -1, -1},
/*03069*/     {0, -1, -1},
/*03070*/     {0, -1, -1},
/*03071*/     {0, -1, -1},
/*03072*/     {574, -1, -1},
/*03073*/     {574, -1, -1},
/*03074*/     {574, -1, -1},
/*03075*/     {575, -1, -1},
/*03076*/     {576, -1, -1},
/*03077*/     {576, -1, -1},
/*03078*/     {576, -1, -1},
/*03079*/     {577, -1, -1},
/*03080*/     {578, -1, -1},
/*03081*/     {578, -1, -1},
/*03082*/     {578, -1, -1},
/*03083*/     {579, -1, -1},
/*03084*/     {580, -1, -1},
/*03085*/     {580, -1, -1},
/*03086*/     {580, -1, -1},
/*03087*/     {581, -1, -1},
/*03088*/     {582, -1, -1},
/*03089*/     {582, -1, -1},
/*03090*/     {582, -1, -1},
/*03091*/     {583, -1, -1},
/*03092*/     {584, -1, -1},
/*03093*/     {584, -1, -1},
/*03094*/     {584, -1, -1},
/*03095*/     {585, -1, -1},
/*03096*/     {586, -1, -1},
/*03097*/     {586, -1, -1},
/*03098*/     {586, -1, -1},
/*03099*/     {587, -1, -1},
/*03100*/     {588, -1, -1},
/*03101*/     {588, -1, -1},
/*03102*/     {588, -1, -1},
/*03103*/     {589, -1, -1},
/*03104*/     {0, -1, -1},
/*03105*/     {0, -1, -1},
/*03106*/     {0, -1, -1},
/*03107*/     {0, -1, -1},
/*03108*/     {0, -1, -1},
/*03109*/     {0, -1, -1},
/*03110*/     {0, -1, -1},
/*03111*/     {0, -1, -1},
/*03112*/     {0, -1, -1},
/*03113*/     {0, -1, -1},
/*03114*/     {0, -1, -1},
/*03115*/     {0, -1, -1},
/*03116*/     {590, -1, -1},
/*03117*/     {590, -1, -1},
/*03118*/     {590, -1, -1},
/*03119*/     {591, -1, -1},
/*03120*/     {0, -1, -1},
/*03121*/     {0, -1, -1},
/*03122*/     {0, -1, -1},
/*03123*/     {0, -1, -1},
/*03124*/     {0, -1, -1},
/*03125*/     {0, -1, -1},
/*03126*/     {0, -1, -1},
/*03127*/     {0, -1, -1},
/*03128*/     {0, -1, -1},
/*03129*/     {0, -1, -1},
/*03130*/     {0, -1, -1},
/*03131*/     {0, -1, -1},
/*03132*/     {0, -1, -1},
/*03133*/     {0, -1, -1},
/*03134*/     {0, -1, -1},
/*03135*/     {0, -1, -1},
/*03136*/     {1406, -1, -1},
/*03137*/     {1407, -1, -1},
/*03138*/     {3146, 12, 1},
/*03139*/     {3148, 12, 1},
/*03140*/     {3150, 12, 1},
/*03141*/     {3152, 12, 1},
/*03142*/     {3154, 12, 1},
/*03143*/     {3156, 12, 1},
/*03144*/     {3158, 12, 1},
/*03145*/     {3160, 12, 1},
/*03146*/     {1216, -1, -1},
/*03147*/     {1217, -1, -1},
/*03148*/     {1218, -1, -1},
/*03149*/     {1219, -1, -1},
/*03150*/     {1220, -1, -1},
/*03151*/     {1221, -1, -1},
/*03152*/     {1222, -1, -1},
/*03153*/     {1223, -1, -1},
/*03154*/     {1224, -1, -1},
/*03155*/     {1225, -1, -1},
/*03156*/     {1226, -1, -1},
/*03157*/     {1227, -1, -1},
/*03158*/     {1228, -1, -1},
/*03159*/     {1229, -1, -1},
/*03160*/     {1230, -1, -1},
/*03161*/     {1231, -1, -1},
/*03162*/     {3290, 27, 3},
/*03163*/     {3298, 27, 3},
/*03164*/     {3306, 27, 3},
/*03165*/     {3314, 27, 3},
/*03166*/     {3322, 27, 3},
/*03167*/     {3330, 27, 3},
/*03168*/     {3338, 27, 3},
/*03169*/     {3346, 27, 3},
/*03170*/     {3354, 27, 3},
/*03171*/     {3362, 27, 3},
/*03172*/     {3370, 27, 3},
/*03173*/     {3378, 27, 3},
/*03174*/     {3386, 27, 3},
/*03175*/     {3394, 27, 3},
/*03176*/     {3402, 27, 3},
/*03177*/     {3410, 27, 3},
/*03178*/     {0, -1, -1},
/*03179*/     {0, -1, -1},
/*03180*/     {0, -1, -1},
/*03181*/     {0, -1, -1},
/*03182*/     {0, -1, -1},
/*03183*/     {0, -1, -1},
/*03184*/     {0, -1, -1},
/*03185*/     {0, -1, -1},
/*03186*/     {0, -1, -1},
/*03187*/     {0, -1, -1},
/*03188*/     {0, -1, -1},
/*03189*/     {3418, 27, 3},
/*03190*/     {3426, 27, 1},
/*03191*/     {3428, 27, 1},
/*03192*/     {3430, 27, 1},
/*03193*/     {3432, 27, 1},
/*03194*/     {3434, 27, 3},
/*03195*/     {3442, 27, 3},
/*03196*/     {3450, 27, 3},
/*03197*/     {3458, 27, 3},
/*03198*/     {3466, 27, 3},
/*03199*/     {3474, 27, 3},
/*03200*/     {3482, 27, 3},
/*03201*/     {3490, 27, 3},
/*03202*/     {0, -1, -1},
/*03203*/     {0, -1, -1},
/*03204*/     {0, -1, -1},
/*03205*/     {0, -1, -1},
/*03206*/     {3498, 27, 3},
/*03207*/     {3506, 27, 3},
/*03208*/     {3514, 27, 3},
/*03209*/     {3522, 27, 3},
/*03210*/     {3530, 27, 3},
/*03211*/     {3538, 27, 3},
/*03212*/     {3546, 27, 3},
/*03213*/     {3554, 27, 3},
/*03214*/     {0, -1, -1},
/*03215*/     {0, -1, -1},
/*03216*/     {0, -1, -1},
/*03217*/     {0, -1, -1},
/*03218*/     {0, -1, -1},
/*03219*/     {0, -1, -1},
/*03220*/     {0, -1, -1},
/*03221*/     {3562, 27, 3},
/*03222*/     {0, -1, -1},
/*03223*/     {0, -1, -1},
/*03224*/     {0, -1, -1},
/*03225*/     {0, -1, -1},
/*03226*/     {3570, 27, 3},
/*03227*/     {3578, 27, 3},
/*03228*/     {3586, 27, 3},
/*03229*/     {3594, 27, 3},
/*03230*/     {3602, 27, 3},
/*03231*/     {3610, 27, 3},
/*03232*/     {3618, 27, 3},
/*03233*/     {3626, 27, 3},
/*03234*/     {3634, 27, 3},
/*03235*/     {3642, 27, 3},
/*03236*/     {3650, 27, 3},
/*03237*/     {3658, 27, 3},
/*03238*/     {3666, 27, 3},
/*03239*/     {3674, 27, 3},
/*03240*/     {3682, 27, 3},
/*03241*/     {3690, 27, 3},
/*03242*/     {0, -1, -1},
/*03243*/     {0, -1, -1},
/*03244*/     {0, -1, -1},
/*03245*/     {0, -1, -1},
/*03246*/     {0, -1, -1},
/*03247*/     {0, -1, -1},
/*03248*/     {0, -1, -1},
/*03249*/     {0, -1, -1},
/*03250*/     {0, -1, -1},
/*03251*/     {0, -1, -1},
/*03252*/     {0, -1, -1},
/*03253*/     {3698, 27, 3},
/*03254*/     {0, -1, -1},
/*03255*/     {0, -1, -1},
/*03256*/     {0, -1, -1},
/*03257*/     {0, -1, -1},
/*03258*/     {3706, 27, 3},
/*03259*/     {3714, 27, 3},
/*03260*/     {3722, 27, 3},
/*03261*/     {3730, 27, 3},
/*03262*/     {3738, 27, 3},
/*03263*/     {3746, 27, 3},
/*03264*/     {3754, 27, 3},
/*03265*/     {3762, 27, 3},
/*03266*/     {0, -1, -1},
/*03267*/     {0, -1, -1},
/*03268*/     {0, -1, -1},
/*03269*/     {0, -1, -1},
/*03270*/     {3770, 27, 3},
/*03271*/     {3778, 27, 3},
/*03272*/     {3786, 27, 3},
/*03273*/     {3794, 27, 3},
/*03274*/     {0, -1, -1},
/*03275*/     {0, -1, -1},
/*03276*/     {0, -1, -1},
/*03277*/     {0, -1, -1},
/*03278*/     {0, -1, -1},
/*03279*/     {0, -1, -1},
/*03280*/     {0, -1, -1},
/*03281*/     {0, -1, -1},
/*03282*/     {0, -1, -1},
/*03283*/     {0, -1, -1},
/*03284*/     {0, -1, -1},
/*03285*/     {0, -1, -1},
/*03286*/     {0, -1, -1},
/*03287*/     {0, -1, -1},
/*03288*/     {0, -1, -1},
/*03289*/     {0, -1, -1},
/*03290*/     {601, -1, -1},
/*03291*/     {0, -1, -1},
/*03292*/     {602, -1, -1},
/*03293*/     {0, -1, -1},
/*03294*/     {601, -1, -1},
/*03295*/     {0, -1, -1},
/*03296*/     {603, -1, -1},
/*03297*/     {0, -1, -1},
/*03298*/     {598, -1, -1},
/*03299*/     {843, -1, -1},
/*03300*/     {599, -1, -1},
/*03301*/     {844, -1, -1},
/*03302*/     {598, -1, -1},
/*03303*/     {843, -1, -1},
/*03304*/     {600, -1, -1},
/*03305*/     {845, -1, -1},
/*03306*/     {592, -1, -1},
/*03307*/     {837, -1, -1},
/*03308*/     {593, -1, -1},
/*03309*/     {838, -1, -1},
/*03310*/     {592, -1, -1},
/*03311*/     {837, -1, -1},
/*03312*/     {594, -1, -1},
/*03313*/     {839, -1, -1},
/*03314*/     {595, -1, -1},
/*03315*/     {840, -1, -1},
/*03316*/     {596, -1, -1},
/*03317*/     {841, -1, -1},
/*03318*/     {595, -1, -1},
/*03319*/     {840, -1, -1},
/*03320*/     {597, -1, -1},
/*03321*/     {842, -1, -1},
/*03322*/     {613, -1, -1},
/*03323*/     {0, -1, -1},
/*03324*/     {614, -1, -1},
/*03325*/     {0, -1, -1},
/*03326*/     {613, -1, -1},
/*03327*/     {0, -1, -1},
/*03328*/     {615, -1, -1},
/*03329*/     {0, -1, -1},
/*03330*/     {610, -1, -1},
/*03331*/     {852, -1, -1},
/*03332*/     {611, -1, -1},
/*03333*/     {853, -1, -1},
/*03334*/     {610, -1, -1},
/*03335*/     {852, -1, -1},
/*03336*/     {612, -1, -1},
/*03337*/     {854, -1, -1},
/*03338*/     {604, -1, -1},
/*03339*/     {846, -1, -1},
/*03340*/     {605, -1, -1},
/*03341*/     {847, -1, -1},
/*03342*/     {604, -1, -1},
/*03343*/     {846, -1, -1},
/*03344*/     {606, -1, -1},
/*03345*/     {848, -1, -1},
/*03346*/     {607, -1, -1},
/*03347*/     {849, -1, -1},
/*03348*/     {608, -1, -1},
/*03349*/     {850, -1, -1},
/*03350*/     {607, -1, -1},
/*03351*/     {849, -1, -1},
/*03352*/     {609, -1, -1},
/*03353*/     {851, -1, -1},
/*03354*/     {625, -1, -1},
/*03355*/     {0, -1, -1},
/*03356*/     {626, -1, -1},
/*03357*/     {0, -1, -1},
/*03358*/     {625, -1, -1},
/*03359*/     {0, -1, -1},
/*03360*/     {627, -1, -1},
/*03361*/     {0, -1, -1},
/*03362*/     {622, -1, -1},
/*03363*/     {861, -1, -1},
/*03364*/     {623, -1, -1},
/*03365*/     {862, -1, -1},
/*03366*/     {622, -1, -1},
/*03367*/     {861, -1, -1},
/*03368*/     {624, -1, -1},
/*03369*/     {863, -1, -1},
/*03370*/     {616, -1, -1},
/*03371*/     {855, -1, -1},
/*03372*/     {617, -1, -1},
/*03373*/     {856, -1, -1},
/*03374*/     {616, -1, -1},
/*03375*/     {855, -1, -1},
/*03376*/     {618, -1, -1},
/*03377*/     {857, -1, -1},
/*03378*/     {619, -1, -1},
/*03379*/     {858, -1, -1},
/*03380*/     {620, -1, -1},
/*03381*/     {859, -1, -1},
/*03382*/     {619, -1, -1},
/*03383*/     {858, -1, -1},
/*03384*/     {621, -1, -1},
/*03385*/     {860, -1, -1},
/*03386*/     {637, -1, -1},
/*03387*/     {0, -1, -1},
/*03388*/     {638, -1, -1},
/*03389*/     {0, -1, -1},
/*03390*/     {637, -1, -1},
/*03391*/     {0, -1, -1},
/*03392*/     {639, -1, -1},
/*03393*/     {0, -1, -1},
/*03394*/     {634, -1, -1},
/*03395*/     {870, -1, -1},
/*03396*/     {635, -1, -1},
/*03397*/     {871, -1, -1},
/*03398*/     {634, -1, -1},
/*03399*/     {870, -1, -1},
/*03400*/     {636, -1, -1},
/*03401*/     {872, -1, -1},
/*03402*/     {628, -1, -1},
/*03403*/     {864, -1, -1},
/*03404*/     {629, -1, -1},
/*03405*/     {865, -1, -1},
/*03406*/     {628, -1, -1},
/*03407*/     {864, -1, -1},
/*03408*/     {630, -1, -1},
/*03409*/     {866, -1, -1},
/*03410*/     {631, -1, -1},
/*03411*/     {867, -1, -1},
/*03412*/     {632, -1, -1},
/*03413*/     {868, -1, -1},
/*03414*/     {631, -1, -1},
/*03415*/     {867, -1, -1},
/*03416*/     {633, -1, -1},
/*03417*/     {869, -1, -1},
/*03418*/     {640, -1, -1},
/*03419*/     {0, -1, -1},
/*03420*/     {641, -1, -1},
/*03421*/     {0, -1, -1},
/*03422*/     {640, -1, -1},
/*03423*/     {0, -1, -1},
/*03424*/     {642, -1, -1},
/*03425*/     {0, -1, -1},
/*03426*/     {0, -1, -1},
/*03427*/     {1041, -1, -1},
/*03428*/     {0, -1, -1},
/*03429*/     {1042, -1, -1},
/*03430*/     {0, -1, -1},
/*03431*/     {1043, -1, -1},
/*03432*/     {0, -1, -1},
/*03433*/     {1044, -1, -1},
/*03434*/     {652, -1, -1},
/*03435*/     {0, -1, -1},
/*03436*/     {653, -1, -1},
/*03437*/     {0, -1, -1},
/*03438*/     {652, -1, -1},
/*03439*/     {0, -1, -1},
/*03440*/     {654, -1, -1},
/*03441*/     {0, -1, -1},
/*03442*/     {649, -1, -1},
/*03443*/     {879, -1, -1},
/*03444*/     {650, -1, -1},
/*03445*/     {880, -1, -1},
/*03446*/     {649, -1, -1},
/*03447*/     {879, -1, -1},
/*03448*/     {651, -1, -1},
/*03449*/     {881, -1, -1},
/*03450*/     {643, -1, -1},
/*03451*/     {873, -1, -1},
/*03452*/     {644, -1, -1},
/*03453*/     {874, -1, -1},
/*03454*/     {643, -1, -1},
/*03455*/     {873, -1, -1},
/*03456*/     {645, -1, -1},
/*03457*/     {875, -1, -1},
/*03458*/     {646, -1, -1},
/*03459*/     {876, -1, -1},
/*03460*/     {647, -1, -1},
/*03461*/     {877, -1, -1},
/*03462*/     {646, -1, -1},
/*03463*/     {876, -1, -1},
/*03464*/     {648, -1, -1},
/*03465*/     {878, -1, -1},
/*03466*/     {664, -1, -1},
/*03467*/     {0, -1, -1},
/*03468*/     {665, -1, -1},
/*03469*/     {0, -1, -1},
/*03470*/     {664, -1, -1},
/*03471*/     {0, -1, -1},
/*03472*/     {666, -1, -1},
/*03473*/     {0, -1, -1},
/*03474*/     {661, -1, -1},
/*03475*/     {888, -1, -1},
/*03476*/     {662, -1, -1},
/*03477*/     {889, -1, -1},
/*03478*/     {661, -1, -1},
/*03479*/     {888, -1, -1},
/*03480*/     {663, -1, -1},
/*03481*/     {890, -1, -1},
/*03482*/     {655, -1, -1},
/*03483*/     {882, -1, -1},
/*03484*/     {656, -1, -1},
/*03485*/     {883, -1, -1},
/*03486*/     {655, -1, -1},
/*03487*/     {882, -1, -1},
/*03488*/     {657, -1, -1},
/*03489*/     {884, -1, -1},
/*03490*/     {658, -1, -1},
/*03491*/     {885, -1, -1},
/*03492*/     {659, -1, -1},
/*03493*/     {886, -1, -1},
/*03494*/     {658, -1, -1},
/*03495*/     {885, -1, -1},
/*03496*/     {660, -1, -1},
/*03497*/     {887, -1, -1},
/*03498*/     {945, -1, -1},
/*03499*/     {0, -1, -1},
/*03500*/     {946, -1, -1},
/*03501*/     {0, -1, -1},
/*03502*/     {947, -1, -1},
/*03503*/     {0, -1, -1},
/*03504*/     {948, -1, -1},
/*03505*/     {0, -1, -1},
/*03506*/     {949, -1, -1},
/*03507*/     {0, -1, -1},
/*03508*/     {950, -1, -1},
/*03509*/     {0, -1, -1},
/*03510*/     {951, -1, -1},
/*03511*/     {0, -1, -1},
/*03512*/     {952, -1, -1},
/*03513*/     {0, -1, -1},
/*03514*/     {953, -1, -1},
/*03515*/     {0, -1, -1},
/*03516*/     {954, -1, -1},
/*03517*/     {0, -1, -1},
/*03518*/     {955, -1, -1},
/*03519*/     {0, -1, -1},
/*03520*/     {956, -1, -1},
/*03521*/     {0, -1, -1},
/*03522*/     {957, -1, -1},
/*03523*/     {0, -1, -1},
/*03524*/     {958, -1, -1},
/*03525*/     {0, -1, -1},
/*03526*/     {959, -1, -1},
/*03527*/     {0, -1, -1},
/*03528*/     {960, -1, -1},
/*03529*/     {0, -1, -1},
/*03530*/     {823, -1, -1},
/*03531*/     {0, -1, -1},
/*03532*/     {823, -1, -1},
/*03533*/     {0, -1, -1},
/*03534*/     {823, -1, -1},
/*03535*/     {0, -1, -1},
/*03536*/     {824, -1, -1},
/*03537*/     {0, -1, -1},
/*03538*/     {821, -1, -1},
/*03539*/     {0, -1, -1},
/*03540*/     {821, -1, -1},
/*03541*/     {0, -1, -1},
/*03542*/     {821, -1, -1},
/*03543*/     {0, -1, -1},
/*03544*/     {822, -1, -1},
/*03545*/     {0, -1, -1},
/*03546*/     {817, -1, -1},
/*03547*/     {0, -1, -1},
/*03548*/     {817, -1, -1},
/*03549*/     {0, -1, -1},
/*03550*/     {817, -1, -1},
/*03551*/     {0, -1, -1},
/*03552*/     {818, -1, -1},
/*03553*/     {0, -1, -1},
/*03554*/     {819, -1, -1},
/*03555*/     {0, -1, -1},
/*03556*/     {819, -1, -1},
/*03557*/     {0, -1, -1},
/*03558*/     {819, -1, -1},
/*03559*/     {0, -1, -1},
/*03560*/     {820, -1, -1},
/*03561*/     {0, -1, -1},
/*03562*/     {825, -1, -1},
/*03563*/     {0, -1, -1},
/*03564*/     {825, -1, -1},
/*03565*/     {0, -1, -1},
/*03566*/     {825, -1, -1},
/*03567*/     {0, -1, -1},
/*03568*/     {826, -1, -1},
/*03569*/     {0, -1, -1},
/*03570*/     {676, -1, -1},
/*03571*/     {0, -1, -1},
/*03572*/     {677, -1, -1},
/*03573*/     {0, -1, -1},
/*03574*/     {676, -1, -1},
/*03575*/     {0, -1, -1},
/*03576*/     {678, -1, -1},
/*03577*/     {0, -1, -1},
/*03578*/     {673, -1, -1},
/*03579*/     {897, -1, -1},
/*03580*/     {674, -1, -1},
/*03581*/     {898, -1, -1},
/*03582*/     {673, -1, -1},
/*03583*/     {897, -1, -1},
/*03584*/     {675, -1, -1},
/*03585*/     {899, -1, -1},
/*03586*/     {667, -1, -1},
/*03587*/     {891, -1, -1},
/*03588*/     {668, -1, -1},
/*03589*/     {892, -1, -1},
/*03590*/     {667, -1, -1},
/*03591*/     {891, -1, -1},
/*03592*/     {669, -1, -1},
/*03593*/     {893, -1, -1},
/*03594*/     {670, -1, -1},
/*03595*/     {894, -1, -1},
/*03596*/     {671, -1, -1},
/*03597*/     {895, -1, -1},
/*03598*/     {670, -1, -1},
/*03599*/     {894, -1, -1},
/*03600*/     {672, -1, -1},
/*03601*/     {896, -1, -1},
/*03602*/     {688, -1, -1},
/*03603*/     {0, -1, -1},
/*03604*/     {689, -1, -1},
/*03605*/     {0, -1, -1},
/*03606*/     {688, -1, -1},
/*03607*/     {0, -1, -1},
/*03608*/     {690, -1, -1},
/*03609*/     {0, -1, -1},
/*03610*/     {685, -1, -1},
/*03611*/     {906, -1, -1},
/*03612*/     {686, -1, -1},
/*03613*/     {907, -1, -1},
/*03614*/     {685, -1, -1},
/*03615*/     {906, -1, -1},
/*03616*/     {687, -1, -1},
/*03617*/     {908, -1, -1},
/*03618*/     {679, -1, -1},
/*03619*/     {900, -1, -1},
/*03620*/     {680, -1, -1},
/*03621*/     {901, -1, -1},
/*03622*/     {679, -1, -1},
/*03623*/     {900, -1, -1},
/*03624*/     {681, -1, -1},
/*03625*/     {902, -1, -1},
/*03626*/     {682, -1, -1},
/*03627*/     {903, -1, -1},
/*03628*/     {683, -1, -1},
/*03629*/     {904, -1, -1},
/*03630*/     {682, -1, -1},
/*03631*/     {903, -1, -1},
/*03632*/     {684, -1, -1},
/*03633*/     {905, -1, -1},
/*03634*/     {700, -1, -1},
/*03635*/     {0, -1, -1},
/*03636*/     {701, -1, -1},
/*03637*/     {0, -1, -1},
/*03638*/     {700, -1, -1},
/*03639*/     {0, -1, -1},
/*03640*/     {702, -1, -1},
/*03641*/     {0, -1, -1},
/*03642*/     {697, -1, -1},
/*03643*/     {915, -1, -1},
/*03644*/     {698, -1, -1},
/*03645*/     {916, -1, -1},
/*03646*/     {697, -1, -1},
/*03647*/     {915, -1, -1},
/*03648*/     {699, -1, -1},
/*03649*/     {917, -1, -1},
/*03650*/     {691, -1, -1},
/*03651*/     {909, -1, -1},
/*03652*/     {692, -1, -1},
/*03653*/     {910, -1, -1},
/*03654*/     {691, -1, -1},
/*03655*/     {909, -1, -1},
/*03656*/     {693, -1, -1},
/*03657*/     {911, -1, -1},
/*03658*/     {694, -1, -1},
/*03659*/     {912, -1, -1},
/*03660*/     {695, -1, -1},
/*03661*/     {913, -1, -1},
/*03662*/     {694, -1, -1},
/*03663*/     {912, -1, -1},
/*03664*/     {696, -1, -1},
/*03665*/     {914, -1, -1},
/*03666*/     {712, -1, -1},
/*03667*/     {0, -1, -1},
/*03668*/     {713, -1, -1},
/*03669*/     {0, -1, -1},
/*03670*/     {712, -1, -1},
/*03671*/     {0, -1, -1},
/*03672*/     {714, -1, -1},
/*03673*/     {0, -1, -1},
/*03674*/     {709, -1, -1},
/*03675*/     {924, -1, -1},
/*03676*/     {710, -1, -1},
/*03677*/     {925, -1, -1},
/*03678*/     {709, -1, -1},
/*03679*/     {924, -1, -1},
/*03680*/     {711, -1, -1},
/*03681*/     {926, -1, -1},
/*03682*/     {703, -1, -1},
/*03683*/     {918, -1, -1},
/*03684*/     {704, -1, -1},
/*03685*/     {919, -1, -1},
/*03686*/     {703, -1, -1},
/*03687*/     {918, -1, -1},
/*03688*/     {705, -1, -1},
/*03689*/     {920, -1, -1},
/*03690*/     {706, -1, -1},
/*03691*/     {921, -1, -1},
/*03692*/     {707, -1, -1},
/*03693*/     {922, -1, -1},
/*03694*/     {706, -1, -1},
/*03695*/     {921, -1, -1},
/*03696*/     {708, -1, -1},
/*03697*/     {923, -1, -1},
/*03698*/     {715, -1, -1},
/*03699*/     {0, -1, -1},
/*03700*/     {716, -1, -1},
/*03701*/     {0, -1, -1},
/*03702*/     {715, -1, -1},
/*03703*/     {0, -1, -1},
/*03704*/     {717, -1, -1},
/*03705*/     {0, -1, -1},
/*03706*/     {727, -1, -1},
/*03707*/     {0, -1, -1},
/*03708*/     {728, -1, -1},
/*03709*/     {0, -1, -1},
/*03710*/     {727, -1, -1},
/*03711*/     {0, -1, -1},
/*03712*/     {729, -1, -1},
/*03713*/     {0, -1, -1},
/*03714*/     {724, -1, -1},
/*03715*/     {933, -1, -1},
/*03716*/     {725, -1, -1},
/*03717*/     {934, -1, -1},
/*03718*/     {724, -1, -1},
/*03719*/     {933, -1, -1},
/*03720*/     {726, -1, -1},
/*03721*/     {935, -1, -1},
/*03722*/     {718, -1, -1},
/*03723*/     {927, -1, -1},
/*03724*/     {719, -1, -1},
/*03725*/     {928, -1, -1},
/*03726*/     {718, -1, -1},
/*03727*/     {927, -1, -1},
/*03728*/     {720, -1, -1},
/*03729*/     {929, -1, -1},
/*03730*/     {721, -1, -1},
/*03731*/     {930, -1, -1},
/*03732*/     {722, -1, -1},
/*03733*/     {931, -1, -1},
/*03734*/     {721, -1, -1},
/*03735*/     {930, -1, -1},
/*03736*/     {723, -1, -1},
/*03737*/     {932, -1, -1},
/*03738*/     {739, -1, -1},
/*03739*/     {0, -1, -1},
/*03740*/     {740, -1, -1},
/*03741*/     {0, -1, -1},
/*03742*/     {739, -1, -1},
/*03743*/     {0, -1, -1},
/*03744*/     {741, -1, -1},
/*03745*/     {0, -1, -1},
/*03746*/     {736, -1, -1},
/*03747*/     {942, -1, -1},
/*03748*/     {737, -1, -1},
/*03749*/     {943, -1, -1},
/*03750*/     {736, -1, -1},
/*03751*/     {942, -1, -1},
/*03752*/     {738, -1, -1},
/*03753*/     {944, -1, -1},
/*03754*/     {730, -1, -1},
/*03755*/     {936, -1, -1},
/*03756*/     {731, -1, -1},
/*03757*/     {937, -1, -1},
/*03758*/     {730, -1, -1},
/*03759*/     {936, -1, -1},
/*03760*/     {732, -1, -1},
/*03761*/     {938, -1, -1},
/*03762*/     {733, -1, -1},
/*03763*/     {939, -1, -1},
/*03764*/     {734, -1, -1},
/*03765*/     {940, -1, -1},
/*03766*/     {733, -1, -1},
/*03767*/     {939, -1, -1},
/*03768*/     {735, -1, -1},
/*03769*/     {941, -1, -1},
/*03770*/     {961, -1, -1},
/*03771*/     {0, -1, -1},
/*03772*/     {962, -1, -1},
/*03773*/     {0, -1, -1},
/*03774*/     {963, -1, -1},
/*03775*/     {0, -1, -1},
/*03776*/     {964, -1, -1},
/*03777*/     {0, -1, -1},
/*03778*/     {965, -1, -1},
/*03779*/     {0, -1, -1},
/*03780*/     {966, -1, -1},
/*03781*/     {0, -1, -1},
/*03782*/     {967, -1, -1},
/*03783*/     {0, -1, -1},
/*03784*/     {968, -1, -1},
/*03785*/     {0, -1, -1},
/*03786*/     {969, -1, -1},
/*03787*/     {0, -1, -1},
/*03788*/     {970, -1, -1},
/*03789*/     {0, -1, -1},
/*03790*/     {971, -1, -1},
/*03791*/     {0, -1, -1},
/*03792*/     {972, -1, -1},
/*03793*/     {0, -1, -1},
/*03794*/     {973, -1, -1},
/*03795*/     {0, -1, -1},
/*03796*/     {974, -1, -1},
/*03797*/     {0, -1, -1},
/*03798*/     {975, -1, -1},
/*03799*/     {0, -1, -1},
/*03800*/     {976, -1, -1},
/*03801*/     {0, -1, -1},
/*03802*/     {1556, -1, -1},
/*03803*/     {0, -1, -1},
/*03804*/     {0, -1, -1},
/*03805*/     {0, -1, -1},
/*03806*/     {3836, 28, 2},
/*03807*/     {0, -1, -1},
/*03808*/     {0, -1, -1},
/*03809*/     {0, -1, -1},
/*03810*/     {3848, 28, 4},
/*03811*/     {0, -1, -1},
/*03812*/     {3864, 28, 4},
/*03813*/     {0, -1, -1},
/*03814*/     {3880, 28, 4},
/*03815*/     {0, -1, -1},
/*03816*/     {3896, 28, 4},
/*03817*/     {0, -1, -1},
/*03818*/     {3912, 28, 4},
/*03819*/     {0, -1, -1},
/*03820*/     {3928, 28, 4},
/*03821*/     {0, -1, -1},
/*03822*/     {3944, 28, 4},
/*03823*/     {0, -1, -1},
/*03824*/     {3960, 28, 4},
/*03825*/     {0, -1, -1},
/*03826*/     {0, -1, -1},
/*03827*/     {0, -1, -1},
/*03828*/     {3976, 28, 4},
/*03829*/     {0, -1, -1},
/*03830*/     {0, -1, -1},
/*03831*/     {0, -1, -1},
/*03832*/     {3992, 28, 4},
/*03833*/     {0, -1, -1},
/*03834*/     {0, -1, -1},
/*03835*/     {0, -1, -1},
/*03836*/     {3840, 30, 2},
/*03837*/     {126, -1, -1},
/*03838*/     {3844, 30, 2},
/*03839*/     {125, -1, -1},
/*03840*/     {154, -1, -1},
/*03841*/     {161, -1, -1},
/*03842*/     {0, -1, -1},
/*03843*/     {0, -1, -1},
/*03844*/     {151, -1, -1},
/*03845*/     {0, -1, -1},
/*03846*/     {0, -1, -1},
/*03847*/     {0, -1, -1},
/*03848*/     {0, -1, -1},
/*03849*/     {159, -1, -1},
/*03850*/     {0, -1, -1},
/*03851*/     {157, -1, -1},
/*03852*/     {0, -1, -1},
/*03853*/     {0, -1, -1},
/*03854*/     {0, -1, -1},
/*03855*/     {0, -1, -1},
/*03856*/     {0, -1, -1},
/*03857*/     {166, -1, -1},
/*03858*/     {0, -1, -1},
/*03859*/     {0, -1, -1},
/*03860*/     {0, -1, -1},
/*03861*/     {0, -1, -1},
/*03862*/     {0, -1, -1},
/*03863*/     {0, -1, -1},
/*03864*/     {0, -1, -1},
/*03865*/     {144, -1, -1},
/*03866*/     {0, -1, -1},
/*03867*/     {0, -1, -1},
/*03868*/     {138, -1, -1},
/*03869*/     {145, -1, -1},
/*03870*/     {141, -1, -1},
/*03871*/     {0, -1, -1},
/*03872*/     {129, -1, -1},
/*03873*/     {0, -1, -1},
/*03874*/     {132, -1, -1},
/*03875*/     {148, -1, -1},
/*03876*/     {0, -1, -1},
/*03877*/     {0, -1, -1},
/*03878*/     {0, -1, -1},
/*03879*/     {0, -1, -1},
/*03880*/     {135, -1, -1},
/*03881*/     {0, -1, -1},
/*03882*/     {136, -1, -1},
/*03883*/     {146, -1, -1},
/*03884*/     {139, -1, -1},
/*03885*/     {0, -1, -1},
/*03886*/     {142, -1, -1},
/*03887*/     {147, -1, -1},
/*03888*/     {130, -1, -1},
/*03889*/     {0, -1, -1},
/*03890*/     {133, -1, -1},
/*03891*/     {0, -1, -1},
/*03892*/     {0, -1, -1},
/*03893*/     {127, -1, -1},
/*03894*/     {0, -1, -1},
/*03895*/     {128, -1, -1},
/*03896*/     {0, -1, -1},
/*03897*/     {0, -1, -1},
/*03898*/     {0, -1, -1},
/*03899*/     {0, -1, -1},
/*03900*/     {0, -1, -1},
/*03901*/     {0, -1, -1},
/*03902*/     {0, -1, -1},
/*03903*/     {0, -1, -1},
/*03904*/     {0, -1, -1},
/*03905*/     {0, -1, -1},
/*03906*/     {149, -1, -1},
/*03907*/     {0, -1, -1},
/*03908*/     {0, -1, -1},
/*03909*/     {0, -1, -1},
/*03910*/     {0, -1, -1},
/*03911*/     {0, -1, -1},
/*03912*/     {0, -1, -1},
/*03913*/     {0, -1, -1},
/*03914*/     {0, -1, -1},
/*03915*/     {0, -1, -1},
/*03916*/     {0, -1, -1},
/*03917*/     {164, -1, -1},
/*03918*/     {0, -1, -1},
/*03919*/     {0, -1, -1},
/*03920*/     {0, -1, -1},
/*03921*/     {0, -1, -1},
/*03922*/     {150, -1, -1},
/*03923*/     {0, -1, -1},
/*03924*/     {0, -1, -1},
/*03925*/     {0, -1, -1},
/*03926*/     {0, -1, -1},
/*03927*/     {0, -1, -1},
/*03928*/     {155, -1, -1},
/*03929*/     {0, -1, -1},
/*03930*/     {152, -1, -1},
/*03931*/     {0, -1, -1},
/*03932*/     {162, -1, -1},
/*03933*/     {0, -1, -1},
/*03934*/     {0, -1, -1},
/*03935*/     {0, -1, -1},
/*03936*/     {0, -1, -1},
/*03937*/     {0, -1, -1},
/*03938*/     {0, -1, -1},
/*03939*/     {0, -1, -1},
/*03940*/     {0, -1, -1},
/*03941*/     {0, -1, -1},
/*03942*/     {0, -1, -1},
/*03943*/     {0, -1, -1},
/*03944*/     {156, -1, -1},
/*03945*/     {0, -1, -1},
/*03946*/     {153, -1, -1},
/*03947*/     {0, -1, -1},
/*03948*/     {163, -1, -1},
/*03949*/     {0, -1, -1},
/*03950*/     {0, -1, -1},
/*03951*/     {0, -1, -1},
/*03952*/     {0, -1, -1},
/*03953*/     {0, -1, -1},
/*03954*/     {0, -1, -1},
/*03955*/     {0, -1, -1},
/*03956*/     {0, -1, -1},
/*03957*/     {0, -1, -1},
/*03958*/     {0, -1, -1},
/*03959*/     {0, -1, -1},
/*03960*/     {0, -1, -1},
/*03961*/     {160, -1, -1},
/*03962*/     {0, -1, -1},
/*03963*/     {158, -1, -1},
/*03964*/     {0, -1, -1},
/*03965*/     {0, -1, -1},
/*03966*/     {0, -1, -1},
/*03967*/     {0, -1, -1},
/*03968*/     {0, -1, -1},
/*03969*/     {0, -1, -1},
/*03970*/     {0, -1, -1},
/*03971*/     {0, -1, -1},
/*03972*/     {0, -1, -1},
/*03973*/     {0, -1, -1},
/*03974*/     {0, -1, -1},
/*03975*/     {0, -1, -1},
/*03976*/     {0, -1, -1},
/*03977*/     {0, -1, -1},
/*03978*/     {137, -1, -1},
/*03979*/     {0, -1, -1},
/*03980*/     {140, -1, -1},
/*03981*/     {0, -1, -1},
/*03982*/     {143, -1, -1},
/*03983*/     {0, -1, -1},
/*03984*/     {131, -1, -1},
/*03985*/     {0, -1, -1},
/*03986*/     {134, -1, -1},
/*03987*/     {0, -1, -1},
/*03988*/     {0, -1, -1},
/*03989*/     {0, -1, -1},
/*03990*/     {0, -1, -1},
/*03991*/     {0, -1, -1},
/*03992*/     {0, -1, -1},
/*03993*/     {0, -1, -1},
/*03994*/     {0, -1, -1},
/*03995*/     {0, -1, -1},
/*03996*/     {0, -1, -1},
/*03997*/     {165, -1, -1},
/*03998*/     {0, -1, -1},
/*03999*/     {0, -1, -1},
/*04000*/     {0, -1, -1},
/*04001*/     {0, -1, -1},
/*04002*/     {0, -1, -1},
/*04003*/     {0, -1, -1},
/*04004*/     {0, -1, -1},
/*04005*/     {0, -1, -1},
/*04006*/     {0, -1, -1},
/*04007*/     {0, -1, -1},
/*04008*/     {751, -1, -1},
/*04009*/     {752, -1, -1},
/*04010*/     {751, -1, -1},
/*04011*/     {753, -1, -1},
/*04012*/     {748, -1, -1},
/*04013*/     {749, -1, -1},
/*04014*/     {748, -1, -1},
/*04015*/     {750, -1, -1},
/*04016*/     {742, -1, -1},
/*04017*/     {743, -1, -1},
/*04018*/     {742, -1, -1},
/*04019*/     {744, -1, -1},
/*04020*/     {745, -1, -1},
/*04021*/     {746, -1, -1},
/*04022*/     {745, -1, -1},
/*04023*/     {747, -1, -1},
/*04024*/     {763, -1, -1},
/*04025*/     {764, -1, -1},
/*04026*/     {763, -1, -1},
/*04027*/     {765, -1, -1},
/*04028*/     {760, -1, -1},
/*04029*/     {761, -1, -1},
/*04030*/     {760, -1, -1},
/*04031*/     {762, -1, -1},
/*04032*/     {754, -1, -1},
/*04033*/     {755, -1, -1},
/*04034*/     {754, -1, -1},
/*04035*/     {756, -1, -1},
/*04036*/     {757, -1, -1},
/*04037*/     {758, -1, -1},
/*04038*/     {757, -1, -1},
/*04039*/     {759, -1, -1},
/*04040*/     {775, -1, -1},
/*04041*/     {776, -1, -1},
/*04042*/     {775, -1, -1},
/*04043*/     {777, -1, -1},
/*04044*/     {772, -1, -1},
/*04045*/     {773, -1, -1},
/*04046*/     {772, -1, -1},
/*04047*/     {774, -1, -1},
/*04048*/     {766, -1, -1},
/*04049*/     {767, -1, -1},
/*04050*/     {766, -1, -1},
/*04051*/     {768, -1, -1},
/*04052*/     {769, -1, -1},
/*04053*/     {770, -1, -1},
/*04054*/     {769, -1, -1},
/*04055*/     {771, -1, -1},
/*04056*/     {787, -1, -1},
/*04057*/     {788, -1, -1},
/*04058*/     {787, -1, -1},
/*04059*/     {789, -1, -1},
/*04060*/     {784, -1, -1},
/*04061*/     {785, -1, -1},
/*04062*/     {784, -1, -1},
/*04063*/     {786, -1, -1},
/*04064*/     {778, -1, -1},
/*04065*/     {779, -1, -1},
/*04066*/     {778, -1, -1},
/*04067*/     {780, -1, -1},
/*04068*/     {781, -1, -1},
/*04069*/     {782, -1, -1},
/*04070*/     {781, -1, -1},
/*04071*/     {783, -1, -1},
/*04072*/     {0, -1, -1},
/*04073*/     {0, -1, -1},
/*04074*/     {0, -1, -1},
/*04075*/     {0, -1, -1},
/*04076*/     {0, -1, -1},
/*04077*/     {0, -1, -1},
/*04078*/     {0, -1, -1},
/*04079*/     {0, -1, -1},
/*04080*/     {0, -1, -1},
/*04081*/     {0, -1, -1},
/*04082*/     {0, -1, -1},
/*04083*/     {0, -1, -1},
/*04084*/     {0, -1, -1},
/*04085*/     {0, -1, -1},
/*04086*/     {0, -1, -1},
/*04087*/     {0, -1, -1},
/*04088*/     {0, -1, -1},
/*04089*/     {0, -1, -1},
/*04090*/     {0, -1, -1},
/*04091*/     {0, -1, -1},
/*04092*/     {0, -1, -1},
/*04093*/     {0, -1, -1},
/*04094*/     {0, -1, -1},
/*04095*/     {0, -1, -1},
/*04096*/     {0, -1, -1},
/*04097*/     {0, -1, -1},
/*04098*/     {0, -1, -1},
/*04099*/     {0, -1, -1},
/*04100*/     {0, -1, -1},
/*04101*/     {0, -1, -1},
/*04102*/     {0, -1, -1},
/*04103*/     {0, -1, -1},
/*04104*/     {0, -1, -1},
/*04105*/     {0, -1, -1},
/*04106*/     {0, -1, -1},
/*04107*/     {0, -1, -1},
/*04108*/     {0, -1, -1},
/*04109*/     {0, -1, -1},
/*04110*/     {0, -1, -1},
/*04111*/     {0, -1, -1},
/*04112*/     {0, -1, -1},
/*04113*/     {0, -1, -1},
/*04114*/     {0, -1, -1},
/*04115*/     {0, -1, -1},
/*04116*/     {790, -1, -1},
/*04117*/     {791, -1, -1},
/*04118*/     {790, -1, -1},
/*04119*/     {792, -1, -1},
/*04120*/     {0, -1, -1},
/*04121*/     {0, -1, -1},
/*04122*/     {0, -1, -1},
/*04123*/     {0, -1, -1},
/*04124*/     {0, -1, -1},
/*04125*/     {0, -1, -1},
/*04126*/     {0, -1, -1},
/*04127*/     {0, -1, -1},
/*04128*/     {0, -1, -1},
/*04129*/     {0, -1, -1},
/*04130*/     {0, -1, -1},
/*04131*/     {0, -1, -1},
/*04132*/     {0, -1, -1},
/*04133*/     {0, -1, -1},
/*04134*/     {0, -1, -1},
/*04135*/     {0, -1, -1},
/*04136*/     {802, -1, -1},
/*04137*/     {803, -1, -1},
/*04138*/     {802, -1, -1},
/*04139*/     {804, -1, -1},
/*04140*/     {799, -1, -1},
/*04141*/     {800, -1, -1},
/*04142*/     {799, -1, -1},
/*04143*/     {801, -1, -1},
/*04144*/     {793, -1, -1},
/*04145*/     {794, -1, -1},
/*04146*/     {793, -1, -1},
/*04147*/     {795, -1, -1},
/*04148*/     {796, -1, -1},
/*04149*/     {797, -1, -1},
/*04150*/     {796, -1, -1},
/*04151*/     {798, -1, -1},
/*04152*/     {814, -1, -1},
/*04153*/     {815, -1, -1},
/*04154*/     {814, -1, -1},
/*04155*/     {816, -1, -1},
/*04156*/     {811, -1, -1},
/*04157*/     {812, -1, -1},
/*04158*/     {811, -1, -1},
/*04159*/     {813, -1, -1},
/*04160*/     {805, -1, -1},
/*04161*/     {806, -1, -1},
/*04162*/     {805, -1, -1},
/*04163*/     {807, -1, -1},
/*04164*/     {808, -1, -1},
/*04165*/     {809, -1, -1},
/*04166*/     {808, -1, -1},
/*04167*/     {810, -1, -1},
/*04168*/     {0, -1, -1},
/*04169*/     {0, -1, -1},
/*04170*/     {0, -1, -1},
/*04171*/     {0, -1, -1},
/*04172*/     {0, -1, -1},
/*04173*/     {0, -1, -1},
/*04174*/     {0, -1, -1},
/*04175*/     {0, -1, -1},
/*04176*/     {0, -1, -1},
/*04177*/     {0, -1, -1},
/*04178*/     {0, -1, -1},
/*04179*/     {0, -1, -1},
/*04180*/     {0, -1, -1},
/*04181*/     {0, -1, -1},
/*04182*/     {0, -1, -1},
/*04183*/     {0, -1, -1},
/*04184*/     {977, -1, -1},
/*04185*/     {978, -1, -1},
/*04186*/     {979, -1, -1},
/*04187*/     {980, -1, -1},
/*04188*/     {981, -1, -1},
/*04189*/     {982, -1, -1},
/*04190*/     {983, -1, -1},
/*04191*/     {984, -1, -1},
/*04192*/     {985, -1, -1},
/*04193*/     {986, -1, -1},
/*04194*/     {987, -1, -1},
/*04195*/     {988, -1, -1},
/*04196*/     {989, -1, -1},
/*04197*/     {990, -1, -1},
/*04198*/     {991, -1, -1},
/*04199*/     {992, -1, -1},
/*04200*/     {833, -1, -1},
/*04201*/     {833, -1, -1},
/*04202*/     {833, -1, -1},
/*04203*/     {834, -1, -1},
/*04204*/     {831, -1, -1},
/*04205*/     {831, -1, -1},
/*04206*/     {831, -1, -1},
/*04207*/     {832, -1, -1},
/*04208*/     {827, -1, -1},
/*04209*/     {827, -1, -1},
/*04210*/     {827, -1, -1},
/*04211*/     {828, -1, -1},
/*04212*/     {829, -1, -1},
/*04213*/     {829, -1, -1},
/*04214*/     {829, -1, -1},
/*04215*/     {830, -1, -1},
/*04216*/     {0, -1, -1},
/*04217*/     {0, -1, -1},
/*04218*/     {0, -1, -1},
/*04219*/     {0, -1, -1},
/*04220*/     {0, -1, -1},
/*04221*/     {0, -1, -1},
/*04222*/     {0, -1, -1},
/*04223*/     {0, -1, -1},
/*04224*/     {0, -1, -1},
/*04225*/     {0, -1, -1},
/*04226*/     {0, -1, -1},
/*04227*/     {0, -1, -1},
/*04228*/     {0, -1, -1},
/*04229*/     {0, -1, -1},
/*04230*/     {0, -1, -1},
/*04231*/     {0, -1, -1},
/*04232*/     {0, -1, -1},
/*04233*/     {0, -1, -1},
/*04234*/     {0, -1, -1},
/*04235*/     {0, -1, -1},
/*04236*/     {0, -1, -1},
/*04237*/     {0, -1, -1},
/*04238*/     {0, -1, -1},
/*04239*/     {0, -1, -1},
/*04240*/     {0, -1, -1},
/*04241*/     {0, -1, -1},
/*04242*/     {0, -1, -1},
/*04243*/     {0, -1, -1},
/*04244*/     {835, -1, -1},
/*04245*/     {835, -1, -1},
/*04246*/     {835, -1, -1},
/*04247*/     {836, -1, -1},
/*04248*/     {0, -1, -1},
/*04249*/     {0, -1, -1},
/*04250*/     {0, -1, -1},
/*04251*/     {0, -1, -1},
/*04252*/     {0, -1, -1},
/*04253*/     {0, -1, -1},
/*04254*/     {0, -1, -1},
/*04255*/     {0, -1, -1},
/*04256*/     {0, -1, -1},
/*04257*/     {0, -1, -1},
/*04258*/     {0, -1, -1},
/*04259*/     {0, -1, -1},
/*04260*/     {0, -1, -1},
/*04261*/     {0, -1, -1},
/*04262*/     {0, -1, -1},
/*04263*/     {0, -1, -1},
/*04264*/     {4328, 35, 1},
/*04265*/     {0, -1, -1},
/*04266*/     {0, -1, -1},
/*04267*/     {0, -1, -1},
/*04268*/     {0, -1, -1},
/*04269*/     {0, -1, -1},
/*04270*/     {0, -1, -1},
/*04271*/     {0, -1, -1},
/*04272*/     {4330, 35, 1},
/*04273*/     {0, -1, -1},
/*04274*/     {0, -1, -1},
/*04275*/     {0, -1, -1},
/*04276*/     {0, -1, -1},
/*04277*/     {0, -1, -1},
/*04278*/     {0, -1, -1},
/*04279*/     {0, -1, -1},
/*04280*/     {4332, 35, 1},
/*04281*/     {0, -1, -1},
/*04282*/     {0, -1, -1},
/*04283*/     {0, -1, -1},
/*04284*/     {0, -1, -1},
/*04285*/     {0, -1, -1},
/*04286*/     {0, -1, -1},
/*04287*/     {0, -1, -1},
/*04288*/     {4334, 35, 1},
/*04289*/     {0, -1, -1},
/*04290*/     {0, -1, -1},
/*04291*/     {0, -1, -1},
/*04292*/     {0, -1, -1},
/*04293*/     {0, -1, -1},
/*04294*/     {0, -1, -1},
/*04295*/     {0, -1, -1},
/*04296*/     {0, -1, -1},
/*04297*/     {0, -1, -1},
/*04298*/     {0, -1, -1},
/*04299*/     {0, -1, -1},
/*04300*/     {0, -1, -1},
/*04301*/     {0, -1, -1},
/*04302*/     {0, -1, -1},
/*04303*/     {0, -1, -1},
/*04304*/     {0, -1, -1},
/*04305*/     {0, -1, -1},
/*04306*/     {0, -1, -1},
/*04307*/     {0, -1, -1},
/*04308*/     {0, -1, -1},
/*04309*/     {0, -1, -1},
/*04310*/     {0, -1, -1},
/*04311*/     {0, -1, -1},
/*04312*/     {0, -1, -1},
/*04313*/     {0, -1, -1},
/*04314*/     {0, -1, -1},
/*04315*/     {0, -1, -1},
/*04316*/     {0, -1, -1},
/*04317*/     {0, -1, -1},
/*04318*/     {0, -1, -1},
/*04319*/     {0, -1, -1},
/*04320*/     {0, -1, -1},
/*04321*/     {0, -1, -1},
/*04322*/     {0, -1, -1},
/*04323*/     {0, -1, -1},
/*04324*/     {0, -1, -1},
/*04325*/     {0, -1, -1},
/*04326*/     {0, -1, -1},
/*04327*/     {0, -1, -1},
/*04328*/     {1296, -1, -1},
/*04329*/     {1297, -1, -1},
/*04330*/     {1298, -1, -1},
/*04331*/     {1299, -1, -1},
/*04332*/     {1300, -1, -1},
/*04333*/     {1301, -1, -1},
/*04334*/     {1302, -1, -1},
/*04335*/     {1303, -1, -1},
/*04336*/     {4344, 29, 4},
/*04337*/     {0, -1, -1},
/*04338*/     {4384, 27, 6},
/*04339*/     {4474, 29, 4},
/*04340*/     {18, -1, -1},
/*04341*/     {0, -1, -1},
/*04342*/     {19, -1, -1},
/*04343*/     {0, -1, -1},
/*04344*/     {4360, 27, 2},
/*04345*/     {4364, 27, 2},
/*04346*/     {4368, 27, 2},
/*04347*/     {4372, 27, 2},
/*04348*/     {11, -1, -1},
/*04349*/     {0, -1, -1},
/*04350*/     {12, -1, -1},
/*04351*/     {0, -1, -1},
/*04352*/     {0, -1, -1},
/*04353*/     {4376, 27, 2},
/*04354*/     {0, -1, -1},
/*04355*/     {4380, 27, 2},
/*04356*/     {0, -1, -1},
/*04357*/     {0, -1, -1},
/*04358*/     {0, -1, -1},
/*04359*/     {0, -1, -1},
/*04360*/     {2, -1, -1},
/*04361*/     {3, -1, -1},
/*04362*/     {0, -1, -1},
/*04363*/     {0, -1, -1},
/*04364*/     {5, -1, -1},
/*04365*/     {4, -1, -1},
/*04366*/     {0, -1, -1},
/*04367*/     {0, -1, -1},
/*04368*/     {6, -1, -1},
/*04369*/     {0, -1, -1},
/*04370*/     {0, -1, -1},
/*04371*/     {0, -1, -1},
/*04372*/     {7, -1, -1},
/*04373*/     {8, -1, -1},
/*04374*/     {9, -1, -1},
/*04375*/     {10, -1, -1},
/*04376*/     {0, -1, -1},
/*04377*/     {13, -1, -1},
/*04378*/     {0, -1, -1},
/*04379*/     {0, -1, -1},
/*04380*/     {14, -1, -1},
/*04381*/     {15, -1, -1},
/*04382*/     {16, -1, -1},
/*04383*/     {17, -1, -1},
/*04384*/     {4448, 36, 1},
/*04385*/     {4450, 36, 1},
/*04386*/     {4452, 36, 1},
/*04387*/     {4454, 36, 1},
/*04388*/     {4456, 36, 1},
/*04389*/     {4458, 36, 1},
/*04390*/     {4460, 36, 1},
/*04391*/     {4462, 36, 1},
/*04392*/     {0, -1, -1},
/*04393*/     {0, -1, -1},
/*04394*/     {4464, 36, 1},
/*04395*/     {4466, 36, 1},
/*04396*/     {0, -1, -1},
/*04397*/     {0, -1, -1},
/*04398*/     {4468, 36, 1},
/*04399*/     {0, -1, -1},
/*04400*/     {0, -1, -1},
/*04401*/     {0, -1, -1},
/*04402*/     {0, -1, -1},
/*04403*/     {0, -1, -1},
/*04404*/     {0, -1, -1},
/*04405*/     {0, -1, -1},
/*04406*/     {0, -1, -1},
/*04407*/     {0, -1, -1},
/*04408*/     {0, -1, -1},
/*04409*/     {0, -1, -1},
/*04410*/     {0, -1, -1},
/*04411*/     {0, -1, -1},
/*04412*/     {0, -1, -1},
/*04413*/     {0, -1, -1},
/*04414*/     {0, -1, -1},
/*04415*/     {0, -1, -1},
/*04416*/     {0, -1, -1},
/*04417*/     {0, -1, -1},
/*04418*/     {0, -1, -1},
/*04419*/     {0, -1, -1},
/*04420*/     {4470, 36, 1},
/*04421*/     {4472, 36, 1},
/*04422*/     {0, -1, -1},
/*04423*/     {0, -1, -1},
/*04424*/     {0, -1, -1},
/*04425*/     {0, -1, -1},
/*04426*/     {0, -1, -1},
/*04427*/     {0, -1, -1},
/*04428*/     {0, -1, -1},
/*04429*/     {0, -1, -1},
/*04430*/     {0, -1, -1},
/*04431*/     {0, -1, -1},
/*04432*/     {0, -1, -1},
/*04433*/     {0, -1, -1},
/*04434*/     {0, -1, -1},
/*04435*/     {0, -1, -1},
/*04436*/     {0, -1, -1},
/*04437*/     {0, -1, -1},
/*04438*/     {0, -1, -1},
/*04439*/     {0, -1, -1},
/*04440*/     {0, -1, -1},
/*04441*/     {0, -1, -1},
/*04442*/     {0, -1, -1},
/*04443*/     {0, -1, -1},
/*04444*/     {0, -1, -1},
/*04445*/     {0, -1, -1},
/*04446*/     {0, -1, -1},
/*04447*/     {0, -1, -1},
/*04448*/     {93, -1, -1},
/*04449*/     {95, -1, -1},
/*04450*/     {96, -1, -1},
/*04451*/     {0, -1, -1},
/*04452*/     {98, -1, -1},
/*04453*/     {0, -1, -1},
/*04454*/     {100, -1, -1},
/*04455*/     {0, -1, -1},
/*04456*/     {102, -1, -1},
/*04457*/     {104, -1, -1},
/*04458*/     {105, -1, -1},
/*04459*/     {0, -1, -1},
/*04460*/     {107, -1, -1},
/*04461*/     {0, -1, -1},
/*04462*/     {109, -1, -1},
/*04463*/     {0, -1, -1},
/*04464*/     {111, -1, -1},
/*04465*/     {0, -1, -1},
/*04466*/     {113, -1, -1},
/*04467*/     {0, -1, -1},
/*04468*/     {115, -1, -1},
/*04469*/     {0, -1, -1},
/*04470*/     {117, -1, -1},
/*04471*/     {119, -1, -1},
/*04472*/     {120, -1, -1},
/*04473*/     {122, -1, -1},
/*04474*/     {4490, 27, 2},
/*04475*/     {4502, 27, 2},
/*04476*/     {4514, 27, 2},
/*04477*/     {4522, 27, 2},
/*04478*/     {4528, 36, 1},
/*04479*/     {0, -1, -1},
/*04480*/     {4530, 36, 1},
/*04481*/     {0, -1, -1},
/*04482*/     {0, -1, -1},
/*04483*/     {4532, 27, 2},
/*04484*/     {0, -1, -1},
/*04485*/     {0, -1, -1},
/*04486*/     {0, -1, -1},
/*04487*/     {0, -1, -1},
/*04488*/     {0, -1, -1},
/*04489*/     {0, -1, -1},
/*04490*/     {4494, 36, 1},
/*04491*/     {4496, 36, 1},
/*04492*/     {4498, 36, 1},
/*04493*/     {4500, 36, 1},
/*04494*/     {94, -1, -1},
/*04495*/     {0, -1, -1},
/*04496*/     {97, -1, -1},
/*04497*/     {0, -1, -1},
/*04498*/     {99, -1, -1},
/*04499*/     {0, -1, -1},
/*04500*/     {101, -1, -1},
/*04501*/     {0, -1, -1},
/*04502*/     {4506, 36, 1},
/*04503*/     {4508, 36, 1},
/*04504*/     {4510, 36, 1},
/*04505*/     {4512, 36, 1},
/*04506*/     {103, -1, -1},
/*04507*/     {0, -1, -1},
/*04508*/     {106, -1, -1},
/*04509*/     {0, -1, -1},
/*04510*/     {108, -1, -1},
/*04511*/     {0, -1, -1},
/*04512*/     {110, -1, -1},
/*04513*/     {0, -1, -1},
/*04514*/     {0, -1, -1},
/*04515*/     {0, -1, -1},
/*04516*/     {4518, 36, 1},
/*04517*/     {4520, 36, 1},
/*04518*/     {112, -1, -1},
/*04519*/     {0, -1, -1},
/*04520*/     {114, -1, -1},
/*04521*/     {0, -1, -1},
/*04522*/     {0, -1, -1},
/*04523*/     {0, -1, -1},
/*04524*/     {4526, 36, 1},
/*04525*/     {0, -1, -1},
/*04526*/     {116, -1, -1},
/*04527*/     {0, -1, -1},
/*04528*/     {123, -1, -1},
/*04529*/     {0, -1, -1},
/*04530*/     {124, -1, -1},
/*04531*/     {0, -1, -1},
/*04532*/     {4536, 36, 1},
/*04533*/     {4538, 36, 1},
/*04534*/     {0, -1, -1},
/*04535*/     {0, -1, -1},
/*04536*/     {118, -1, -1},
/*04537*/     {0, -1, -1},
/*04538*/     {121, -1, -1},
/*04539*/     {0, -1, -1},
/*04540*/     {4548, 29, 4},
/*04541*/     {0, -1, -1},
/*04542*/     {4588, 27, 6},
/*04543*/     {4678, 29, 4},
/*04544*/     {18, -1, -1},
/*04545*/     {0, -1, -1},
/*04546*/     {19, -1, -1},
/*04547*/     {0, -1, -1},
/*04548*/     {4564, 27, 2},
/*04549*/     {4568, 27, 2},
/*04550*/     {4572, 27, 2},
/*04551*/     {4576, 27, 2},
/*04552*/     {11, -1, -1},
/*04553*/     {0, -1, -1},
/*04554*/     {12, -1, -1},
/*04555*/     {0, -1, -1},
/*04556*/     {0, -1, -1},
/*04557*/     {4580, 27, 2},
/*04558*/     {0, -1, -1},
/*04559*/     {4584, 27, 2},
/*04560*/     {0, -1, -1},
/*04561*/     {0, -1, -1},
/*04562*/     {0, -1, -1},
/*04563*/     {0, -1, -1},
/*04564*/     {2, -1, -1},
/*04565*/     {3, -1, -1},
/*04566*/     {0, -1, -1},
/*04567*/     {0, -1, -1},
/*04568*/     {5, -1, -1},
/*04569*/     {4, -1, -1},
/*04570*/     {0, -1, -1},
/*04571*/     {0, -1, -1},
/*04572*/     {6, -1, -1},
/*04573*/     {0, -1, -1},
/*04574*/     {0, -1, -1},
/*04575*/     {0, -1, -1},
/*04576*/     {7, -1, -1},
/*04577*/     {8, -1, -1},
/*04578*/     {9, -1, -1},
/*04579*/     {10, -1, -1},
/*04580*/     {0, -1, -1},
/*04581*/     {13, -1, -1},
/*04582*/     {0, -1, -1},
/*04583*/     {0, -1, -1},
/*04584*/     {14, -1, -1},
/*04585*/     {15, -1, -1},
/*04586*/     {16, -1, -1},
/*04587*/     {17, -1, -1},
/*04588*/     {4652, 36, 1},
/*04589*/     {4654, 36, 1},
/*04590*/     {4656, 36, 1},
/*04591*/     {4658, 36, 1},
/*04592*/     {4660, 36, 1},
/*04593*/     {4662, 36, 1},
/*04594*/     {4664, 36, 1},
/*04595*/     {4666, 36, 1},
/*04596*/     {0, -1, -1},
/*04597*/     {0, -1, -1},
/*04598*/     {4668, 36, 1},
/*04599*/     {4670, 36, 1},
/*04600*/     {0, -1, -1},
/*04601*/     {0, -1, -1},
/*04602*/     {4672, 36, 1},
/*04603*/     {0, -1, -1},
/*04604*/     {0, -1, -1},
/*04605*/     {0, -1, -1},
/*04606*/     {0, -1, -1},
/*04607*/     {0, -1, -1},
/*04608*/     {0, -1, -1},
/*04609*/     {0, -1, -1},
/*04610*/     {0, -1, -1},
/*04611*/     {0, -1, -1},
/*04612*/     {0, -1, -1},
/*04613*/     {0, -1, -1},
/*04614*/     {0, -1, -1},
/*04615*/     {0, -1, -1},
/*04616*/     {0, -1, -1},
/*04617*/     {0, -1, -1},
/*04618*/     {0, -1, -1},
/*04619*/     {0, -1, -1},
/*04620*/     {0, -1, -1},
/*04621*/     {0, -1, -1},
/*04622*/     {0, -1, -1},
/*04623*/     {0, -1, -1},
/*04624*/     {4674, 36, 1},
/*04625*/     {4676, 36, 1},
/*04626*/     {0, -1, -1},
/*04627*/     {0, -1, -1},
/*04628*/     {0, -1, -1},
/*04629*/     {0, -1, -1},
/*04630*/     {0, -1, -1},
/*04631*/     {0, -1, -1},
/*04632*/     {0, -1, -1},
/*04633*/     {0, -1, -1},
/*04634*/     {0, -1, -1},
/*04635*/     {0, -1, -1},
/*04636*/     {0, -1, -1},
/*04637*/     {0, -1, -1},
/*04638*/     {0, -1, -1},
/*04639*/     {0, -1, -1},
/*04640*/     {0, -1, -1},
/*04641*/     {0, -1, -1},
/*04642*/     {0, -1, -1},
/*04643*/     {0, -1, -1},
/*04644*/     {0, -1, -1},
/*04645*/     {0, -1, -1},
/*04646*/     {0, -1, -1},
/*04647*/     {0, -1, -1},
/*04648*/     {0, -1, -1},
/*04649*/     {0, -1, -1},
/*04650*/     {0, -1, -1},
/*04651*/     {0, -1, -1},
/*04652*/     {93, -1, -1},
/*04653*/     {95, -1, -1},
/*04654*/     {96, -1, -1},
/*04655*/     {0, -1, -1},
/*04656*/     {98, -1, -1},
/*04657*/     {0, -1, -1},
/*04658*/     {100, -1, -1},
/*04659*/     {0, -1, -1},
/*04660*/     {102, -1, -1},
/*04661*/     {104, -1, -1},
/*04662*/     {105, -1, -1},
/*04663*/     {0, -1, -1},
/*04664*/     {107, -1, -1},
/*04665*/     {0, -1, -1},
/*04666*/     {109, -1, -1},
/*04667*/     {0, -1, -1},
/*04668*/     {111, -1, -1},
/*04669*/     {0, -1, -1},
/*04670*/     {113, -1, -1},
/*04671*/     {0, -1, -1},
/*04672*/     {115, -1, -1},
/*04673*/     {0, -1, -1},
/*04674*/     {117, -1, -1},
/*04675*/     {119, -1, -1},
/*04676*/     {120, -1, -1},
/*04677*/     {122, -1, -1},
/*04678*/     {4694, 27, 2},
/*04679*/     {4706, 27, 2},
/*04680*/     {4718, 27, 2},
/*04681*/     {4726, 27, 2},
/*04682*/     {4732, 36, 1},
/*04683*/     {0, -1, -1},
/*04684*/     {4734, 36, 1},
/*04685*/     {0, -1, -1},
/*04686*/     {0, -1, -1},
/*04687*/     {4736, 27, 2},
/*04688*/     {0, -1, -1},
/*04689*/     {0, -1, -1},
/*04690*/     {0, -1, -1},
/*04691*/     {0, -1, -1},
/*04692*/     {0, -1, -1},
/*04693*/     {0, -1, -1},
/*04694*/     {4698, 36, 1},
/*04695*/     {4700, 36, 1},
/*04696*/     {4702, 36, 1},
/*04697*/     {4704, 36, 1},
/*04698*/     {94, -1, -1},
/*04699*/     {0, -1, -1},
/*04700*/     {97, -1, -1},
/*04701*/     {0, -1, -1},
/*04702*/     {99, -1, -1},
/*04703*/     {0, -1, -1},
/*04704*/     {101, -1, -1},
/*04705*/     {0, -1, -1},
/*04706*/     {4710, 36, 1},
/*04707*/     {4712, 36, 1},
/*04708*/     {4714, 36, 1},
/*04709*/     {4716, 36, 1},
/*04710*/     {103, -1, -1},
/*04711*/     {0, -1, -1},
/*04712*/     {106, -1, -1},
/*04713*/     {0, -1, -1},
/*04714*/     {108, -1, -1},
/*04715*/     {0, -1, -1},
/*04716*/     {110, -1, -1},
/*04717*/     {0, -1, -1},
/*04718*/     {0, -1, -1},
/*04719*/     {0, -1, -1},
/*04720*/     {4722, 36, 1},
/*04721*/     {4724, 36, 1},
/*04722*/     {112, -1, -1},
/*04723*/     {0, -1, -1},
/*04724*/     {114, -1, -1},
/*04725*/     {0, -1, -1},
/*04726*/     {0, -1, -1},
/*04727*/     {0, -1, -1},
/*04728*/     {4730, 36, 1},
/*04729*/     {0, -1, -1},
/*04730*/     {116, -1, -1},
/*04731*/     {0, -1, -1},
/*04732*/     {123, -1, -1},
/*04733*/     {0, -1, -1},
/*04734*/     {124, -1, -1},
/*04735*/     {0, -1, -1},
/*04736*/     {4740, 36, 1},
/*04737*/     {4742, 36, 1},
/*04738*/     {0, -1, -1},
/*04739*/     {0, -1, -1},
/*04740*/     {118, -1, -1},
/*04741*/     {0, -1, -1},
/*04742*/     {121, -1, -1},
/*04743*/     {0, -1, -1},
/*04744*/     {1322, -1, -1},
/*04745*/     {1323, -1, -1},
/*04746*/     {1324, -1, -1},
/*04747*/     {1325, -1, -1},
/*04748*/     {1326, -1, -1},
/*04749*/     {1327, -1, -1},
/*04750*/     {1328, -1, -1},
/*04751*/     {1329, -1, -1},
/*04752*/     {1330, -1, -1},
/*04753*/     {1331, -1, -1},
/*04754*/     {1332, -1, -1},
/*04755*/     {1333, -1, -1},
/*04756*/     {1334, -1, -1},
/*04757*/     {1335, -1, -1},
/*04758*/     {1336, -1, -1},
/*04759*/     {1337, -1, -1},
/*04760*/     {1338, -1, -1},
/*04761*/     {1339, -1, -1},
/*04762*/     {1340, -1, -1},
/*04763*/     {1341, -1, -1},
/*04764*/     {1342, -1, -1},
/*04765*/     {1343, -1, -1},
/*04766*/     {1344, -1, -1},
/*04767*/     {1345, -1, -1},
/*04768*/     {1346, -1, -1},
/*04769*/     {1347, -1, -1},
/*04770*/     {1348, -1, -1},
/*04771*/     {1349, -1, -1},
/*04772*/     {1350, -1, -1},
/*04773*/     {1351, -1, -1},
/*04774*/     {1352, -1, -1},
/*04775*/     {1353, -1, -1},
/*04776*/     {4784, 36, 1},
/*04777*/     {4790, 36, 1},
/*04778*/     {4796, 36, 1},
/*04779*/     {4802, 36, 1},
/*04780*/     {4808, 12, 1},
/*04781*/     {4810, 12, 1},
/*04782*/     {4812, 12, 1},
/*04783*/     {4814, 12, 1},
/*04784*/     {4786, 12, 1},
/*04785*/     {4788, 12, 1},
/*04786*/     {21, -1, -1},
/*04787*/     {24, -1, -1},
/*04788*/     {45, -1, -1},
/*04789*/     {48, -1, -1},
/*04790*/     {4792, 12, 1},
/*04791*/     {4794, 12, 1},
/*04792*/     {27, -1, -1},
/*04793*/     {30, -1, -1},
/*04794*/     {51, -1, -1},
/*04795*/     {54, -1, -1},
/*04796*/     {4798, 12, 1},
/*04797*/     {4800, 12, 1},
/*04798*/     {33, -1, -1},
/*04799*/     {36, -1, -1},
/*04800*/     {57, -1, -1},
/*04801*/     {60, -1, -1},
/*04802*/     {4804, 12, 1},
/*04803*/     {4806, 12, 1},
/*04804*/     {39, -1, -1},
/*04805*/     {42, -1, -1},
/*04806*/     {63, -1, -1},
/*04807*/     {66, -1, -1},
/*04808*/     {69, -1, -1},
/*04809*/     {72, -1, -1},
/*04810*/     {75, -1, -1},
/*04811*/     {78, -1, -1},
/*04812*/     {81, -1, -1},
/*04813*/     {84, -1, -1},
/*04814*/     {87, -1, -1},
/*04815*/     {90, -1, -1},
/*04816*/     {4824, 36, 1},
/*04817*/     {4830, 36, 1},
/*04818*/     {4836, 36, 1},
/*04819*/     {4842, 36, 1},
/*04820*/     {4848, 12, 1},
/*04821*/     {4850, 12, 1},
/*04822*/     {4852, 12, 1},
/*04823*/     {4854, 12, 1},
/*04824*/     {4826, 12, 1},
/*04825*/     {4828, 12, 1},
/*04826*/     {21, -1, -1},
/*04827*/     {24, -1, -1},
/*04828*/     {45, -1, -1},
/*04829*/     {48, -1, -1},
/*04830*/     {4832, 12, 1},
/*04831*/     {4834, 12, 1},
/*04832*/     {27, -1, -1},
/*04833*/     {30, -1, -1},
/*04834*/     {51, -1, -1},
/*04835*/     {54, -1, -1},
/*04836*/     {4838, 12, 1},
/*04837*/     {4840, 12, 1},
/*04838*/     {33, -1, -1},
/*04839*/     {36, -1, -1},
/*04840*/     {57, -1, -1},
/*04841*/     {60, -1, -1},
/*04842*/     {4844, 12, 1},
/*04843*/     {4846, 12, 1},
/*04844*/     {39, -1, -1},
/*04845*/     {42, -1, -1},
/*04846*/     {63, -1, -1},
/*04847*/     {66, -1, -1},
/*04848*/     {69, -1, -1},
/*04849*/     {72, -1, -1},
/*04850*/     {75, -1, -1},
/*04851*/     {78, -1, -1},
/*04852*/     {81, -1, -1},
/*04853*/     {84, -1, -1},
/*04854*/     {87, -1, -1},
/*04855*/     {90, -1, -1},
/*04856*/     {1354, -1, -1},
/*04857*/     {1355, -1, -1},
/*04858*/     {1356, -1, -1},
/*04859*/     {1357, -1, -1},
/*04860*/     {1358, -1, -1},
/*04861*/     {1359, -1, -1},
/*04862*/     {1360, -1, -1},
/*04863*/     {1361, -1, -1},
/*04864*/     {4872, 6, 3},
/*04865*/     {4882, 6, 3},
/*04866*/     {4892, 6, 3},
/*04867*/     {4902, 6, 3},
/*04868*/     {4912, 6, 3},
/*04869*/     {4922, 6, 3},
/*04870*/     {4932, 6, 3},
/*04871*/     {4942, 6, 3},
/*04872*/     {4880, 12, 1},
/*04873*/     {0, -1, -1},
/*04874*/     {0, -1, -1},
/*04875*/     {0, -1, -1},
/*04876*/     {0, -1, -1},
/*04877*/     {0, -1, -1},
/*04878*/     {0, -1, -1},
/*04879*/     {0, -1, -1},
/*04880*/     {1557, -1, -1},
/*04881*/     {1558, -1, -1},
/*04882*/     {4890, 12, 1},
/*04883*/     {0, -1, -1},
/*04884*/     {0, -1, -1},
/*04885*/     {0, -1, -1},
/*04886*/     {0, -1, -1},
/*04887*/     {0, -1, -1},
/*04888*/     {0, -1, -1},
/*04889*/     {0, -1, -1},
/*04890*/     {1559, -1, -1},
/*04891*/     {1560, -1, -1},
/*04892*/     {4900, 12, 1},
/*04893*/     {0, -1, -1},
/*04894*/     {0, -1, -1},
/*04895*/     {0, -1, -1},
/*04896*/     {0, -1, -1},
/*04897*/     {0, -1, -1},
/*04898*/     {0, -1, -1},
/*04899*/     {0, -1, -1},
/*04900*/     {1561, -1, -1},
/*04901*/     {1562, -1, -1},
/*04902*/     {4910, 12, 1},
/*04903*/     {0, -1, -1},
/*04904*/     {0, -1, -1},
/*04905*/     {0, -1, -1},
/*04906*/     {0, -1, -1},
/*04907*/     {0, -1, -1},
/*04908*/     {0, -1, -1},
/*04909*/     {0, -1, -1},
/*04910*/     {1563, -1, -1},
/*04911*/     {1564, -1, -1},
/*04912*/     {4920, 12, 1},
/*04913*/     {0, -1, -1},
/*04914*/     {0, -1, -1},
/*04915*/     {0, -1, -1},
/*04916*/     {0, -1, -1},
/*04917*/     {0, -1, -1},
/*04918*/     {0, -1, -1},
/*04919*/     {0, -1, -1},
/*04920*/     {1565, -1, -1},
/*04921*/     {1566, -1, -1},
/*04922*/     {4930, 12, 1},
/*04923*/     {0, -1, -1},
/*04924*/     {0, -1, -1},
/*04925*/     {0, -1, -1},
/*04926*/     {0, -1, -1},
/*04927*/     {0, -1, -1},
/*04928*/     {0, -1, -1},
/*04929*/     {0, -1, -1},
/*04930*/     {1567, -1, -1},
/*04931*/     {1568, -1, -1},
/*04932*/     {4940, 12, 1},
/*04933*/     {0, -1, -1},
/*04934*/     {0, -1, -1},
/*04935*/     {0, -1, -1},
/*04936*/     {0, -1, -1},
/*04937*/     {0, -1, -1},
/*04938*/     {0, -1, -1},
/*04939*/     {0, -1, -1},
/*04940*/     {1569, -1, -1},
/*04941*/     {1570, -1, -1},
/*04942*/     {4950, 12, 1},
/*04943*/     {0, -1, -1},
/*04944*/     {0, -1, -1},
/*04945*/     {0, -1, -1},
/*04946*/     {0, -1, -1},
/*04947*/     {0, -1, -1},
/*04948*/     {0, -1, -1},
/*04949*/     {0, -1, -1},
/*04950*/     {1571, -1, -1},
/*04951*/     {1572, -1, -1},
/*04952*/     {4960, 36, 1},
/*04953*/     {4966, 36, 1},
/*04954*/     {4972, 36, 1},
/*04955*/     {4978, 36, 1},
/*04956*/     {4984, 12, 1},
/*04957*/     {4986, 12, 1},
/*04958*/     {4988, 12, 1},
/*04959*/     {4990, 12, 1},
/*04960*/     {4962, 12, 1},
/*04961*/     {4964, 12, 1},
/*04962*/     {22, -1, -1},
/*04963*/     {25, -1, -1},
/*04964*/     {46, -1, -1},
/*04965*/     {49, -1, -1},
/*04966*/     {4968, 12, 1},
/*04967*/     {4970, 12, 1},
/*04968*/     {28, -1, -1},
/*04969*/     {31, -1, -1},
/*04970*/     {52, -1, -1},
/*04971*/     {55, -1, -1},
/*04972*/     {4974, 12, 1},
/*04973*/     {4976, 12, 1},
/*04974*/     {34, -1, -1},
/*04975*/     {37, -1, -1},
/*04976*/     {58, -1, -1},
/*04977*/     {61, -1, -1},
/*04978*/     {4980, 12, 1},
/*04979*/     {4982, 12, 1},
/*04980*/     {40, -1, -1},
/*04981*/     {43, -1, -1},
/*04982*/     {64, -1, -1},
/*04983*/     {67, -1, -1},
/*04984*/     {70, -1, -1},
/*04985*/     {73, -1, -1},
/*04986*/     {76, -1, -1},
/*04987*/     {79, -1, -1},
/*04988*/     {82, -1, -1},
/*04989*/     {85, -1, -1},
/*04990*/     {88, -1, -1},
/*04991*/     {91, -1, -1},
/*04992*/     {5000, 36, 1},
/*04993*/     {5006, 36, 1},
/*04994*/     {5012, 36, 1},
/*04995*/     {5018, 36, 1},
/*04996*/     {5024, 12, 1},
/*04997*/     {5026, 12, 1},
/*04998*/     {5028, 12, 1},
/*04999*/     {5030, 12, 1},
/*05000*/     {5002, 12, 1},
/*05001*/     {5004, 12, 1},
/*05002*/     {22, -1, -1},
/*05003*/     {25, -1, -1},
/*05004*/     {46, -1, -1},
/*05005*/     {49, -1, -1},
/*05006*/     {5008, 12, 1},
/*05007*/     {5010, 12, 1},
/*05008*/     {28, -1, -1},
/*05009*/     {31, -1, -1},
/*05010*/     {52, -1, -1},
/*05011*/     {55, -1, -1},
/*05012*/     {5014, 12, 1},
/*05013*/     {5016, 12, 1},
/*05014*/     {34, -1, -1},
/*05015*/     {37, -1, -1},
/*05016*/     {58, -1, -1},
/*05017*/     {61, -1, -1},
/*05018*/     {5020, 12, 1},
/*05019*/     {5022, 12, 1},
/*05020*/     {40, -1, -1},
/*05021*/     {43, -1, -1},
/*05022*/     {64, -1, -1},
/*05023*/     {67, -1, -1},
/*05024*/     {70, -1, -1},
/*05025*/     {73, -1, -1},
/*05026*/     {76, -1, -1},
/*05027*/     {79, -1, -1},
/*05028*/     {82, -1, -1},
/*05029*/     {85, -1, -1},
/*05030*/     {88, -1, -1},
/*05031*/     {91, -1, -1},
/*05032*/     {1362, -1, -1},
/*05033*/     {1363, -1, -1},
/*05034*/     {1364, -1, -1},
/*05035*/     {1365, -1, -1},
/*05036*/     {1366, -1, -1},
/*05037*/     {1367, -1, -1},
/*05038*/     {1368, -1, -1},
/*05039*/     {1369, -1, -1},
/*05040*/     {5048, 12, 1},
/*05041*/     {5050, 12, 1},
/*05042*/     {5052, 12, 1},
/*05043*/     {5054, 12, 1},
/*05044*/     {5056, 12, 1},
/*05045*/     {5058, 12, 1},
/*05046*/     {5060, 12, 1},
/*05047*/     {5062, 12, 1},
/*05048*/     {1573, -1, -1},
/*05049*/     {1574, -1, -1},
/*05050*/     {1575, -1, -1},
/*05051*/     {1576, -1, -1},
/*05052*/     {1577, -1, -1},
/*05053*/     {1578, -1, -1},
/*05054*/     {1579, -1, -1},
/*05055*/     {1580, -1, -1},
/*05056*/     {1581, -1, -1},
/*05057*/     {1582, -1, -1},
/*05058*/     {1583, -1, -1},
/*05059*/     {1584, -1, -1},
/*05060*/     {1585, -1, -1},
/*05061*/     {1586, -1, -1},
/*05062*/     {1587, -1, -1},
/*05063*/     {1588, -1, -1},
/*05064*/     {5072, 36, 1},
/*05065*/     {5078, 36, 1},
/*05066*/     {5084, 36, 1},
/*05067*/     {5090, 36, 1},
/*05068*/     {5096, 12, 1},
/*05069*/     {5098, 12, 1},
/*05070*/     {5100, 12, 1},
/*05071*/     {5102, 12, 1},
/*05072*/     {5074, 12, 1},
/*05073*/     {5076, 12, 1},
/*05074*/     {23, -1, -1},
/*05075*/     {26, -1, -1},
/*05076*/     {47, -1, -1},
/*05077*/     {50, -1, -1},
/*05078*/     {5080, 12, 1},
/*05079*/     {5082, 12, 1},
/*05080*/     {29, -1, -1},
/*05081*/     {32, -1, -1},
/*05082*/     {53, -1, -1},
/*05083*/     {56, -1, -1},
/*05084*/     {5086, 12, 1},
/*05085*/     {5088, 12, 1},
/*05086*/     {35, -1, -1},
/*05087*/     {38, -1, -1},
/*05088*/     {59, -1, -1},
/*05089*/     {62, -1, -1},
/*05090*/     {5092, 12, 1},
/*05091*/     {5094, 12, 1},
/*05092*/     {41, -1, -1},
/*05093*/     {44, -1, -1},
/*05094*/     {65, -1, -1},
/*05095*/     {68, -1, -1},
/*05096*/     {71, -1, -1},
/*05097*/     {74, -1, -1},
/*05098*/     {77, -1, -1},
/*05099*/     {80, -1, -1},
/*05100*/     {83, -1, -1},
/*05101*/     {86, -1, -1},
/*05102*/     {89, -1, -1},
/*05103*/     {92, -1, -1},
/*05104*/     {5112, 36, 1},
/*05105*/     {5118, 36, 1},
/*05106*/     {5124, 36, 1},
/*05107*/     {5130, 36, 1},
/*05108*/     {5136, 12, 1},
/*05109*/     {5138, 12, 1},
/*05110*/     {5140, 12, 1},
/*05111*/     {5142, 12, 1},
/*05112*/     {5114, 12, 1},
/*05113*/     {5116, 12, 1},
/*05114*/     {23, -1, -1},
/*05115*/     {26, -1, -1},
/*05116*/     {47, -1, -1},
/*05117*/     {50, -1, -1},
/*05118*/     {5120, 12, 1},
/*05119*/     {5122, 12, 1},
/*05120*/     {29, -1, -1},
/*05121*/     {32, -1, -1},
/*05122*/     {53, -1, -1},
/*05123*/     {56, -1, -1},
/*05124*/     {5126, 12, 1},
/*05125*/     {5128, 12, 1},
/*05126*/     {35, -1, -1},
/*05127*/     {38, -1, -1},
/*05128*/     {59, -1, -1},
/*05129*/     {62, -1, -1},
/*05130*/     {5132, 12, 1},
/*05131*/     {5134, 12, 1},
/*05132*/     {41, -1, -1},
/*05133*/     {44, -1, -1},
/*05134*/     {65, -1, -1},
/*05135*/     {68, -1, -1},
/*05136*/     {71, -1, -1},
/*05137*/     {74, -1, -1},
/*05138*/     {77, -1, -1},
/*05139*/     {80, -1, -1},
/*05140*/     {83, -1, -1},
/*05141*/     {86, -1, -1},
/*05142*/     {89, -1, -1},
/*05143*/     {92, -1, -1},
/*05144*/     {1373, -1, -1},
/*05145*/     {5146, 34, 2},
/*05146*/     {1370, -1, -1},
/*05147*/     {0, -1, -1},
/*05148*/     {1372, -1, -1},
/*05149*/     {1371, -1, -1}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\decoder.c ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <assert.h>
#define INT64
#include "decfn_emdb.h"
#include "decision_tree.h"
#pragma function (memset)


#include "decoder_priv.h"

/***************************************************************************/

#define STATIC

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#define PRED_SIZE EM_PREDICATE_BITS

#define INIT_PSEUDO_TROLES_TAB_ENTRY(Entry,Slot0,Slot1,Slot2)				\
{																			\
	pseudo_troles_tab[Entry][0] = (Slot0);									\
	pseudo_troles_tab[Entry][1] = (Slot1);									\
	pseudo_troles_tab[Entry][2] = (Slot2);									\
}

#define EM_DECODER_FLAGS__NO_MEMSET(Flags) ((Flags) & EM_DECODER_FLAG_NO_MEMSET)

/***************************************************************************/

U4byte IEL_t1, IEL_t2, IEL_t3, IEL_t4;
U32  IEL_tempc;
U64  IEL_et1, IEL_et2;
U128 IEL_ext1, IEL_ext2, IEL_ext3, IEL_ext4, IEL_ext5;
S128 IEL_ts1, IEL_ts2;

extern struct EM_version_s deccpu_emdb_version;

const U32 decoder_bundle_size = IEL_CONST32(EM_BUNDLE_SIZE);
    
STATIC Temp_role_t 		pseudo_troles_tab[16][3];
STATIC int				troles_tab_initialized = FALSE;

STATIC EM_Decoder_Err em_decoding(const EM_Decoder_Id, const unsigned char *,
                                  const int, const EM_IL, EM_Decoder_Info *);

STATIC EM_Decoder_Err em_inst_decode(const EM_Decoder_Id,  U64, const Temp_role_t,
                                     const U128 *, EM_Decoder_Info *);

STATIC void em_decoder_init_decoder_info(EM_Decoder_Info *decoder_info);

STATIC void em_decoder_init_bundle_info(EM_Decoder_Bundle_Info *bundle_info);

STATIC void init_pseudo_troles_tab(void);


/****************************************************************************
 *                      init_pseudo_troles_tab                              *
 *  initalizes pseudo_troles_tab. If only template-# changes, update EM.h   *
 *  is enough to update the decoder.                                        *
 ****************************************************************************/

STATIC void init_pseudo_troles_tab(void)
{
	/*** In the following table EM_TEMP_ROLE_MEM means M/A & same for _INT ***/
	int i;
	
	/*** initialize all entries as reserved ***/
	for (i = 0; i < EM_NUM_OF_TEMPLATES; i++)
		INIT_PSEUDO_TROLES_TAB_ENTRY(i, EM_TEMP_ROLE_NONE, EM_TEMP_ROLE_NONE,
									 EM_TEMP_ROLE_NONE);

	/*** initialize specific entries ***/

    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mii  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_INT , EM_TEMP_ROLE_INT );
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mi_i , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_INT , EM_TEMP_ROLE_INT );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mlx  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_LONG, EM_TEMP_ROLE_LONG);
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mmi  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_MEM , EM_TEMP_ROLE_INT );
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_m_mi , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_MEM , EM_TEMP_ROLE_INT );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mfi  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_FP  , EM_TEMP_ROLE_INT );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mmf  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_MEM , EM_TEMP_ROLE_FP  );
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mib  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_INT , EM_TEMP_ROLE_BR  );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mbb  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_BR  , EM_TEMP_ROLE_BR  );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_bbb  , EM_TEMP_ROLE_BR  , \
								 EM_TEMP_ROLE_BR  , EM_TEMP_ROLE_BR  );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mmb  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_MEM , EM_TEMP_ROLE_BR );
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mfb  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_FP  , EM_TEMP_ROLE_BR  );
 
	/*** avoid multpiple initializations ***/
	troles_tab_initialized = TRUE;  
};


#ifdef BIG_ENDIAN

#define ENTITY_SWAP(E)  entity_swap((unsigned char *)(&(E)), sizeof(E))


/***************************** entity_swap *******************************/
/* swap any number of bytes                                              */
/*************************************************************************/

STATIC  void    entity_swap(unsigned char *entity_1st, unsigned int size)
{
    unsigned char       tmp8, *p, *q;
    
    for (q = (p = entity_1st) + (size-1);
         p < q;
         p++, q--)
    {
        tmp8 = *q;
        *q = *p;
        *p = tmp8;
    }
}
#else

#define ENTITY_SWAP(E)  {}

#endif

/*
STATIC dec_2_emdb_trole[] = 
{
	EM_TEMP_ROLE_INT,
	EM_TEMP_ROLE_MEM,
	EM_TEMP_ROLE_FP,
	EM_TEMP_ROLE_BR,
	EM_TEMP_ROLE_LONG
};
*/

/********************************************************************************/
/* em_decoder_open: opens a new entry in the em_clients_table and returns the   */
/*               index of the entry.                                            */
/********************************************************************************/

 EM_Decoder_Id em_decoder_open(void)
{
    int i;
    Client_Entry initiate_entry={1,
                                 DEFAULT_MACHINE_TYPE, 
                                 DEFAULT_MACHINE_MODE,
                                 NULL
                                };

    
    for (i=0 ; i < EM_DECODER_MAX_CLIENTS ; i++)
    {
        if ( !(em_clients_table[i].is_used) )
        {
            em_clients_table[i] = initiate_entry;
			if (!troles_tab_initialized)
				init_pseudo_troles_tab();
            return(i);
        }
    }
    return(-1);
}

/*****************************************************************************/
/* legal_id: check whether a given id suits an active entry in the           */
/*   clients table.                                                          */
/*****************************************************************************/

STATIC int legal_id(int id)
{
    if ((id<0)||(id>=EM_DECODER_MAX_CLIENTS))
    {
        return(FALSE);
    }
    if (!em_clients_table[id].is_used)
    {
        return(FALSE);
    }
    return(TRUE);
}

/*****************************************************************************/
/* em_decoder_close: closes an entry in the clients table for later use.     */
/*****************************************************************************/

 EM_Decoder_Err em_decoder_close(const EM_Decoder_Id id)
{
    if (legal_id(id))
    {
        em_clients_table[id].is_used=0;
        if (em_clients_table[id].info_ptr != NULL)
        {
            free(em_clients_table[id].info_ptr);
        }
        return(EM_DECODER_NO_ERROR);
    }
    else
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }
}

/*****************************************************************************/
/* legal_type:                                                               */
/*****************************************************************************/

STATIC int legal_type(EM_Decoder_Machine_Type type)
{
    if (type < EM_DECODER_CPU_LAST)
    {
        return(TRUE);
    }
    return(FALSE);
}

/*****************************************************************************/
/* legal_mode:                                                               */
/*****************************************************************************/

STATIC int legal_mode(EM_Decoder_Machine_Type type, EM_Decoder_Machine_Mode mode)
{
    if (mode == EM_DECODER_MODE_NO_CHANGE)
    {
        return(TRUE);
    }

    if ((mode > EM_DECODER_MODE_NO_CHANGE) && (mode < EM_DECODER_MODE_LAST))
    {
        if ((mode == EM_DECODER_MODE_EM) && (type != EM_DECODER_CPU_P7))
        {
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }

    }
    return(FALSE);
}


/*****************************************************************************/
/* legal_inst:                                                               */
/*****************************************************************************/

STATIC int legal_inst(EM_Decoder_Inst_Id inst, EM_Decoder_Machine_Type type)
{
    if (inst < EM_INST_LAST)
    {
		/* unsigned int cpu_flag = deccpu_EMDB_info[inst].impls; */
		
		switch (type)
		{
			case EM_DECODER_CPU_P7:
			  return TRUE;
			default:
			  /*assert(0);*/
			  break;
		}	
    }
    return(FALSE);
}

/****************************************************************************/
/* em_decoder_setenv: sets the machine type and machine mode variables.     */
/****************************************************************************/

 EM_Decoder_Err em_decoder_setenv(const EM_Decoder_Id            id,
                                  const EM_Decoder_Machine_Type  type,
                                  const EM_Decoder_Machine_Mode  mode)
{
    if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

    if (!legal_type(type))
    {
        return(EM_DECODER_INVALID_MACHINE_TYPE);
    }

    if (!legal_mode(type, mode))
    {
        return(EM_DECODER_INVALID_MACHINE_MODE);
    }

    if (type == EM_DECODER_CPU_DEFAULT)
    {
        em_clients_table[id].machine_type = DEFAULT_MACHINE_TYPE;
    }
    else if (type != EM_DECODER_CPU_NO_CHANGE)
    {
        em_clients_table[id].machine_type = type;
    }

    if (mode == EM_DECODER_MODE_DEFAULT)
    {
        em_clients_table[id].machine_mode = DEFAULT_MACHINE_MODE;
    }
    else if (mode != EM_DECODER_MODE_NO_CHANGE)
    {
        em_clients_table[id].machine_mode = mode;
    }

    return(EM_DECODER_NO_ERROR);
}

/******************************************************************************/
/* em_decoder_setup: sets the machine type, machine mode variables and flags. */
/******************************************************************************/

 EM_Decoder_Err em_decoder_setup(const EM_Decoder_Id            id,
                                 const EM_Decoder_Machine_Type  type,
                                 const EM_Decoder_Machine_Mode  mode,
								 unsigned long            flags)
{
	EM_Decoder_Err err;
	
	if ((err=em_decoder_setenv(id, type, mode)) != EM_DECODER_NO_ERROR)
	{
		return (err);
	}

	em_clients_table[id].flags = flags;

	return (EM_DECODER_NO_ERROR);
}

/********************************************************************************/
/* em_decoder_init_decoder_info: initializes decoder_info in case of no memset. */
/********************************************************************************/

STATIC void em_decoder_init_decoder_info(EM_Decoder_Info *decoder_info)
{
	decoder_info->pred.valid = FALSE;
	
	decoder_info->src1.type = EM_DECODER_NO_OPER;
	decoder_info->src1.oper_flags = 0;
	decoder_info->src2.type = EM_DECODER_NO_OPER;
	decoder_info->src2.oper_flags = 0;
	decoder_info->src3.type = EM_DECODER_NO_OPER;
	decoder_info->src3.oper_flags = 0;
	decoder_info->src4.type = EM_DECODER_NO_OPER;
	decoder_info->src4.oper_flags = 0;
	decoder_info->src5.type = EM_DECODER_NO_OPER;
	decoder_info->src5.oper_flags = 0;
	decoder_info->dst1.type = EM_DECODER_NO_OPER;
	decoder_info->dst1.oper_flags = 0;
	decoder_info->dst2.type = EM_DECODER_NO_OPER;
	decoder_info->dst1.oper_flags = 0;
}

/******************************************************************************/
/* em_decoder_init_bundle_info: initializes bundle_info in case of no memset. */
/******************************************************************************/

STATIC void em_decoder_init_bundle_info(EM_Decoder_Bundle_Info *bundle_info)
{
	unsigned int slot;
	  
	for (slot=0; slot<3; slot++)
	{  
	  em_decoder_init_decoder_info(bundle_info->inst_info+slot);
	  bundle_info->inst_info[slot].EM_info.em_flags = 0;
	}  
}	

/*******************************************************************************/
/* em_decoder_associate_one: adds to the client's entry a pointer to an extra  */
/* information about a single instruction (inst).                              */
/*******************************************************************************/

 EM_Decoder_Err em_decoder_associate_one(const EM_Decoder_Id       id,
                                         const EM_Decoder_Inst_Id  inst,
                                         const void *           client_info)
{
    int     i;
    int     n_insts;
    
    if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

    if (!legal_inst(inst, em_clients_table[id].machine_type))
    {
        return(EM_DECODER_INVALID_INST_ID);
    }
    {
        n_insts = EM_INST_LAST;  /*** assume MAX. repair ***/
    }
    if (em_clients_table[id].info_ptr == NULL)
    {
        em_clients_table[id].info_ptr = calloc((size_t)n_insts, sizeof(void *));
        if (!em_clients_table[id].info_ptr)
        {
            return EM_DECODER_INTERNAL_ERROR;
        }

        for (i=0 ; i < n_insts ; i++)
        {
            em_clients_table[id].info_ptr[i] = NULL;
        }
    }
    em_clients_table[id].info_ptr[inst] = (void *)client_info;
    return(EM_DECODER_NO_ERROR);
}


/***************************************************************************** 
 * em_decoder_associate_check - check the client's array of association      * 
 *                           valid for P7 cpu only                           * 
 *****************************************************************************/

 EM_Decoder_Err em_decoder_associate_check(const EM_Decoder_Id  id,
                                           EM_Decoder_Inst_Id * inst)
{
    EM_Decoder_Inst_Id i;
    
    if(!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }
    if (em_clients_table[id].machine_type == EM_DECODER_CPU_P7)
    {
        if (em_clients_table[id].machine_mode == EM_DECODER_MODE_EM)
        {
            if(em_clients_table[id].info_ptr == NULL)
            {
                *inst = 1;
                return(EM_DECODER_ASSOCIATE_MISS);
            }

            for (i = 1;
                 (i < EM_INST_LAST) &&
                 (em_clients_table[id].info_ptr[i] != NULL);
                 i++);

            if (i < EM_INST_LAST)
            {
                *inst = i;
                return(EM_DECODER_ASSOCIATE_MISS);
            }
        }
        else    /***   iA   ***/
        {
        }
        *inst = EM_DECODER_INST_NONE;
        return(EM_DECODER_NO_ERROR);
    }
    else     /* cpu is p5, p6 */
    {
        *inst = EM_DECODER_INST_NONE;
        return(EM_DECODER_NO_ERROR);
    }
}


/******************************************************************************
 * em_decoder_decode                                                          *
 *                                                                            *
 * params:                                                                    *
 *          id - decoder client id                                            *
 *          code - pointer to instruction buffer                              *
 *          max_code_size - instruction buffer size                           *
 *          decoder_info - pointer to decoder_info to fill                    *
 *                                                                            *
 * returns:                                                                   *
 *          EM_Decoder_Err                                                    *
 *                                                                            *
 *****************************************************************************/

 EM_Decoder_Err em_decoder_decode(const EM_Decoder_Id   id,
                                  const unsigned char * code,
                                  const int             max_code_size,
                                  const EM_IL           location,
                                  EM_Decoder_Info *     decoder_info)
{
    EM_Decoder_Err     err = EM_DECODER_NO_ERROR;


    if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

    if (decoder_info == NULL)
    {
        return(EM_DECODER_NULL_PTR);
    }

    if (code == NULL)
    {
        return(EM_DECODER_TOO_SHORT_ERR);
    }

	if (EM_DECODER_FLAGS__NO_MEMSET(em_clients_table[id].flags))
	{
		em_decoder_init_decoder_info(decoder_info);
	}
	else
	{  
		memset(decoder_info, 0, sizeof(EM_Decoder_Info));
	}	

	if (em_clients_table[id].machine_mode == EM_DECODER_MODE_EM)
    {
        err = em_decoding(id, code, max_code_size, location, decoder_info);
    }
    else 
    {
        err = EM_DECODER_INVALID_MACHINE_MODE;
    }

    return(err);
}

/*****************************************************************************/
/* em_decoder_inst_static_info: return instruction static info (flags,       */
/*             client_info pointer and static_info pointer)                  */
/*****************************************************************************/

 EM_Decoder_Err em_decoder_inst_static_info(const EM_Decoder_Id            id,
      									    const EM_Decoder_Inst_Id       inst_id,
									        EM_Decoder_Inst_Static_Info *  static_info)
{
    if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

    if (!legal_inst(inst_id, em_clients_table[id].machine_type))
    {
        return(EM_DECODER_INVALID_INST_ID);
    }

    if (static_info == NULL)
    {
        return(EM_DECODER_NULL_PTR);
    }

    if (em_clients_table[id].info_ptr != NULL)
    {
        static_info->client_info = em_clients_table[id].info_ptr[inst_id];
    }
    else
    {
        static_info->client_info = NULL;
    }

	static_info->static_info = em_decoder_static_info + inst_id;
	
    return(EM_DECODER_NO_ERROR);
}



/******************************************************************************
 * em_decoder_decode_bundle - decode em bundle                                *
 *                                                                            *
 * params:                                                                    *
 *          id - decoder client id                                            *
 *          code - pointer to instruction buffer                              *
 *          max_code_size - instruction buffer size(Should be at least 3*128  *
 *          bundle_info - pointer to bundle_info to fill                      *
 *                                                                            *
 * returns:                                                                   *
 *          EM_Decoder_Err                                                    *
 *                                                                            *
 *****************************************************************************/

 EM_Decoder_Err em_decoder_decode_bundle(const EM_Decoder_Id      id,
                                         const unsigned char*     code,
                                         const int                max_size,
                                         EM_Decoder_Bundle_Info*  bundle_info)
{
    unsigned int        slot_no;
    U128                bundle;
    U64                 instr;
    EM_template_t       templt;
    Temp_role_t         temp_role;
    EM_Decoder_Info    *decoder_info;
    int                 bundle_stop;
    EM_Decoder_Err      err, return_err = EM_DECODER_NO_ERROR;

	if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

	if (bundle_info == NULL)
    {
        return(EM_DECODER_NULL_PTR);
    }
	
	if (EM_DECODER_FLAGS__NO_MEMSET(em_clients_table[id].flags))
	{
		em_decoder_init_bundle_info(bundle_info);
	}
	else
	{  
		memset(bundle_info, 0, sizeof(EM_Decoder_Bundle_Info));
	}
	
	bundle = *(const U128 *)code;
	ENTITY_SWAP(bundle);
	templt = EM_GET_TEMPLATE(bundle);
	
    if (max_size < EM_BUNDLE_SIZE)
    {
        return(EM_DECODER_TOO_SHORT_ERR);
    }

    bundle_info->em_bundle_info.flags = 0;
    
    if (bundle_stop = (IEL_GETDW0(bundle) & (1<<EM_SBIT_POS)))
        bundle_info->em_bundle_info.flags |= EM_DECODER_BIT_BUNDLE_STOP;
    
    if (EM_TEMPLATE_IS_RESERVED(templt))
        return(EM_DECODER_INVALID_TEMPLATE);

    bundle_info->em_bundle_info.b_template = templt;

    /*** Decode 3 instruction (unless long 2-slot instruction) ***/
       
    for(slot_no = 0;  slot_no < 3; slot_no++)
    {
        decoder_info = &(bundle_info->inst_info[slot_no]);
		decoder_info->EM_info.slot_no = slot_no;

        temp_role = pseudo_troles_tab[templt][slot_no];
		
		/*** DECODER_NEXT should work even if error occurs ***/
		decoder_info->size = 1 + (temp_role == EM_TEMP_ROLE_LONG);

		if (temp_role == EM_TEMP_ROLE_LONG)  /*** 2-slot instruction ***/
		{
                    if (slot_no >= EM_SLOT_LAST - 1)
                    {
                        err = EM_DECODER_INVALID_INST_SLOT;
                    }
                    else
                    {
			EM_GET_SYLLABLE(instr, bundle, slot_no+1); /* opcode is in slot 3 */
			err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
                    }

		   	if (err == EM_DECODER_INVALID_PRM_OPCODE)
			{
				/* try to find nop.i or break.i in this slot */
				temp_role = EM_TEMP_ROLE_INT;

				err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
				if (!err)
				{
					if (!EM_DECODER_CHECK_OK_IN_MLX(decoder_info))
						err = EM_DECODER_INVALID_PRM_OPCODE;
				}
			}
		}

		else
		{
			EM_GET_SYLLABLE(instr, bundle, slot_no);
		
			err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
		

			if (!err)
			{
				if ((EM_DECODER_CHECK_SLOT2_ONLY(decoder_info)) && (slot_no != 2))
					/*** intruction must be in slot 2 only, but... ***/  
					err = EM_DECODER_INVALID_SLOT_BRANCH_INST;
				else if (EM_DECODER_CHECK_GROUP_LAST(decoder_info) &&
					    (((slot_no != 2) || !bundle_stop) && ((slot_no != 0) || (templt != EM_template_m_mi))))
				     /*** instruction fails to be the last in instruction group ***/
				     err = EM_DECODER_MUST_BE_GROUP_LAST;
				  
			}
		}

        /* return_err = the first worst error */
		if (err)
		{  
			FILL_PREDICATE_INFO(instr, decoder_info);
        	if ((!return_err) || (EM_DECODER_ERROR_IS_INST_FATAL(err)
								  && !EM_DECODER_ERROR_IS_INST_FATAL(return_err)))
            	return_err = err;
		}	
        bundle_info->error[slot_no] = err;

        decoder_info->EM_info.em_bundle_info = bundle_info->em_bundle_info;
		
        if (decoder_info->size == 2) /*** 2-slot instruction - exit for loop ***/
		{
			slot_no++;
            break;
		}
    }

/*   if ((!err) && EM_DECODER_CHECK_GROUP_LAST(decoder_info) &&
		(!EM_DECODER_BUNDLE_STOP(decoder_info)))
	{  
		*** instruction fails to be the last in instruction group ***
		bundle_info->error[slot_no-1] = EM_DECODER_MUST_BE_GROUP_LAST;
		if (!return_err)
		   return_err = EM_DECODER_MUST_BE_GROUP_LAST;
	}*/
	
    bundle_info->inst_num = slot_no;

    bundle_info->inst_info[slot_no-1].EM_info.em_flags |=
        EM_DECODER_BIT_LAST_INST;
    
    if (bundle_stop)
        bundle_info->inst_info[slot_no-1].EM_info.em_flags |=
            EM_DECODER_BIT_CYCLE_BREAK;

    if (templt == EM_template_m_mi)
        bundle_info->inst_info[0].EM_info.em_flags |=
            EM_DECODER_BIT_CYCLE_BREAK;
    
    if (templt == EM_template_mi_i)
        bundle_info->inst_info[1].EM_info.em_flags |=
            EM_DECODER_BIT_CYCLE_BREAK;
    
    return(return_err);
}

/******************************************************************************
 * em_decoding - decode em (2.0- till ??) single instruction + bundle info    *
 *                                                                            *
 * params:                                                                    *
 *          id - decoder client id                                            *
 *          code - pointer to instruction buffer                              *
 *          max_code_size - instruction buffer size                           *
 *          location - syllable location, used to get slot #                  *
 *          decoder_info - pointer to decoder_info to fill                    *
 *                                                                            *
 * returns:                                                                   *
 *          EM_Decoder_Err                                                    *
 *                                                                            *
 *****************************************************************************/

STATIC EM_Decoder_Err      em_decoding   ( const EM_Decoder_Id    id,
                                           const unsigned char  * code,
                                           const int              max_code_size,
                                           const EM_IL            location,
                                           EM_Decoder_Info      * decoder_info)
{
    unsigned int            slot_no = EM_IL_GET_SLOT_NO(location);
    U128                    bundle;
    U64                     instr;
    EM_template_t           templt;
    Temp_role_t             temp_role;
    int                     bundle_stop, cycle_break;
    EM_Decoder_Err          err;

    IEL_ZERO(instr);
    bundle = *(const U128 *)code;
    ENTITY_SWAP(bundle);
    templt = EM_GET_TEMPLATE(bundle);

    /*** DECODER_NEXT should work even if error occurs ***/
    decoder_info->size = 1;
	
    if (max_code_size < EM_BUNDLE_SIZE)
    {
        return(EM_DECODER_TOO_SHORT_ERR);
    }
    
    /******************************************************************/
    /** fill EM_Info  and check it                                  ***/
    /******************************************************************/
    
    decoder_info->EM_info.em_flags =
        decoder_info->EM_info.em_bundle_info.flags = 0;
    
    if (bundle_stop = (IEL_GETDW0(bundle) & (1<<EM_SBIT_POS)))
        decoder_info->EM_info.em_bundle_info.flags |=
            EM_DECODER_BIT_BUNDLE_STOP;

    
    if (EM_TEMPLATE_IS_RESERVED(templt))
        return(EM_DECODER_INVALID_TEMPLATE);

    decoder_info->EM_info.em_bundle_info.b_template = templt;

    if (slot_no > EM_SLOT_2)
    {
        return(EM_DECODER_INVALID_INST_SLOT);
    }
    
	decoder_info->EM_info.slot_no = slot_no;
    
    /***********************/
    /*** decode syllable ***/
    /***********************/

    /*** get instruction binary. DON'T mask bits 41 and on ***/

    temp_role = pseudo_troles_tab[templt][slot_no];

	if (temp_role == EM_TEMP_ROLE_LONG)  /*** 2-slot instruction ***/
	{
            if (slot_no >= EM_SLOT_LAST - 1)
            {
                err = EM_DECODER_INVALID_INST_SLOT;
            }
            else
            {
		decoder_info->size = 2;
		EM_GET_SYLLABLE(instr, bundle, slot_no+1); /* opcode is in slot 3 */
		err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
            }
		if (err == EM_DECODER_INVALID_PRM_OPCODE)
		{
			/* try to find nop.i or break.i in this slot */
			temp_role = EM_TEMP_ROLE_INT;
			slot_no = EM_DECODER_SLOT_2;
			err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
			if (!err)
			{
				if (!EM_DECODER_CHECK_OK_IN_MLX(decoder_info))
					err = EM_DECODER_INVALID_PRM_OPCODE;
			}
		}
	}
	else
	{
		EM_GET_SYLLABLE(instr, bundle, slot_no);

		err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
	

		if (!err)
		{  
			if ((EM_DECODER_CHECK_SLOT2_ONLY(decoder_info)) && (slot_no != 2))
			{  
				/*** intruction must be in slot 2 only, but... ***/
				err = EM_DECODER_INVALID_SLOT_BRANCH_INST;
			}	
			else if (EM_DECODER_CHECK_GROUP_LAST(decoder_info) && 
					(((slot_no != 2) || !bundle_stop) && ((slot_no != 0) || (templt != EM_template_m_mi))))
			{  
				  /* instruction fails to be the last in instruction group */
				  err = EM_DECODER_MUST_BE_GROUP_LAST;
			}
		}	

	}
	if (err) FILL_PREDICATE_INFO(instr, decoder_info);
	
    if ((slot_no == EM_DECODER_SLOT_2)||(decoder_info->size == 2) /* 2-slot instruction */)
    {
        cycle_break = (bundle_stop != 0);
        decoder_info->EM_info.em_flags |= EM_DECODER_BIT_LAST_INST;
    }
    else
    {
        cycle_break = ((slot_no==0) && (templt == EM_template_m_mi)) ||
                      ((slot_no==1) && (templt == EM_template_mi_i));
    }
    decoder_info->EM_info.em_flags |= (cycle_break*EM_DECODER_BIT_CYCLE_BREAK);
    
	return(err);
}

/******************************************************************************
 * em_inst_decode - decode em (2.0- till ??) single syllable                  *
 *                                                                            *
 * params:                                                                    *
 *          id - decoder client id                                            *
 *          instr - 64 bit, 0-40 are the syllable binary, 41-63 irrelevant    *
 *          pseudo_trole - M/A, I/A, FP, or BR                                *
 *          bundle - original pointer to bundle, for 64-bit imm extraction    *
 *          decoder_info - pointer to decoder_info to fill                    *
 *                                                                            *
 * returns:                                                                   *
 *          EM_Decoder_Err                                                    *
 *                                                                            *
 *****************************************************************************/

STATIC EM_Decoder_Err  em_inst_decode( const EM_Decoder_Id    id,
                                       U64                    instr,
                                       const Temp_role_t      pseudo_trole,
                                       const U128           * bundle_p,
                                       EM_Decoder_Info      * decoder_info)
{
    Inst_id_t         inst_id;
    EM_Decoder_Err    err;
    U64               tmp64;
    unsigned int      major_opc, inst_center;
    Node_t            node;
    int               part_place, part_size, part_value, index;
    deccpu_EMDB_info_t * emdb_entry_p;
	EM_Decoder_static_info_t *static_entry_p;
    Template_role_t   trole;

	
    /*** find major opcode ***/

    major_opc = IEL_GETDW1(instr);              /*** assumes pos > 31    ***/
    major_opc >>= (EM_MAJOR_OPCODE_POS - 32);   
    major_opc &= ((1<<EM_MAJOR_OPCODE_BITS)-1); /*** mask out bits 41-64 ***/
    
    /*** instruction bits 6-36 (without pred/major-opcode) to inst_center ***/
    /*** done to accelerate mask/shift in main loop (aviods IEL use).     ***/
	
    IEL_SHR(tmp64, instr, PRED_SIZE); /*** bits 6-40 --> 0-34 ***/
    inst_center = IEL_GETDW0(tmp64);  /*** original bits 6-37 ***/

    /*** walk through decoder decision tree ***/
    
    node = em_decision_tree[SQUARE(major_opc, pseudo_trole)];
    while (!NODE_IS_LEAF(node))
    {
        part_place = GET_NODE_POS(node) - PRED_SIZE;
        part_size  = GET_NODE_SIZE(node);
		
		if (part_place < 0)     /*** extensions in bits 0-5 ***/
		{
			part_place += PRED_SIZE;
			part_value = (IEL_GETDW0(instr) >> part_place) & ((1<<part_size)-1);
		}	
		else	
		    part_value = (inst_center >> part_place) & ((1<<part_size)-1);
		
        index = GET_NEXT_NODE_INDEX(node) + part_value;
        node = em_decision_tree[index];
    }

    /*** leaf found - emdb line identified ***/
    
    inst_id = GET_NEXT_NODE_INDEX(node);
	decoder_info->flags = 0;
	/*define machine behaviour within illegal opcode */
	{
		Behaviour_ill_opcode machine_behaviour;
		/*Template_role_t em_trole = dec_2_emdb_trole[pseudo_trole];*/
		PRED_BEHAVIOUR(pseudo_trole, major_opc, machine_behaviour);
		if (machine_behaviour == BEHAVIOUR_UNDEF)
		{
			/* branch region with opcode 0 */
			/* check bit 32*/
			int decision_bit;
			GET_BRANCH_BEHAVIOUR_BIT(instr, decision_bit);
			if (decision_bit)
			{
				machine_behaviour = BEHAVIOUR_FAULT;
			}
			else
			{
				machine_behaviour = BEHAVIOUR_IGNORE_ON_FALSE_QP;
			}
		}
		if (machine_behaviour == BEHAVIOUR_FAULT)
		{
			EM_DECODER_SET_UNC_ILLEGAL_FAULT(decoder_info);
		}
	}
    if ((inst_id >= EM_INST_LAST) || inst_id == EM_ILLOP)
    {
		if (pseudo_trole == EM_TEMP_ROLE_BR)
		{
			/*** search for ignored fields ***/
			switch (major_opc)
			{
				case 0:
				{
				   unsigned int x6_ext;
				   U64 ext;

   				   /*** get extention in bits 27:32 ***/
				   IEL_SHR(ext, instr, 27);
				   x6_ext = IEL_GETDW0(ext) & ((1<<6) - 1);
				   if (x6_ext == 1)
				   {
					   /*** nop.b has to be returned ***/
					   inst_id = EM_NOP_B_IMM21;
				   }
				   else
					 return(EM_DECODER_INVALID_PRM_OPCODE);

				   break;
				}   
				   
				case 2:
				{
				   unsigned int x6_ext;
				   U64 ext;

   				   /*** get extention in bits 27:32 ***/
				   IEL_SHR(ext, instr, 27);
				   x6_ext = IEL_GETDW0(ext) & ((1<<6) - 1);
				   switch (x6_ext)
				   {
					   case 0:
					   case 16:
					   case 17:
					      return (EM_DECODER_INVALID_PRM_OPCODE);
					   default:
						  /*** nop.b has to be returned ***/
						  inst_id = EM_NOP_B_IMM21;
				   }

				   break;
				}  
				   
				default:
				   return(EM_DECODER_INVALID_PRM_OPCODE);
			}

			/*** zero the inst encoding: pred and operands extracted below will be 0 ***/
			IEL_ZERO(instr);
		}	
        else return(EM_DECODER_INVALID_PRM_OPCODE);
    }

	if (! legal_inst(inst_id, em_clients_table[id].machine_type))
	{   /*** inst does not belong to the specified machine IS ***/
		return(EM_DECODER_INVALID_PRM_OPCODE);
	}
	
    decoder_info->inst = inst_id;
    emdb_entry_p = deccpu_EMDB_info + inst_id;
	static_entry_p = (EM_Decoder_static_info_t *)em_decoder_static_info + inst_id;

    /*** get instruction static info ***/

    decoder_info->flags |= static_entry_p->flags;
    decoder_info->EM_info.eut = trole = static_entry_p->template_role;
    
    if (EM_DECODER_CHECK_TWO_SLOT(decoder_info))
    {
		/*** IMPORTANT: emdb flags already set from the static info !!! ***/
        decoder_info->EM_info.em_flags |= EM_DECODER_BIT_LONG_INST;
        /*** decoder_info->size = 2; *** should be already done ***/
    }
    /*** else *** should be already done ***
    {
        decoder_info->size = 1;
    }
	***/

    /*** handle client and static info ***/
    
    if (em_clients_table[id].info_ptr != NULL)
    {
        decoder_info->client_info = em_clients_table[id].info_ptr[inst_id];
    }
    else
    {
        decoder_info->client_info = NULL;
    }

	decoder_info->static_info = static_entry_p;

    
    /*** Decode predicate register ***/

    if (static_entry_p->flags & EM_FLAG_PRED)
    {
		FILL_PREDICATE_INFO(instr, decoder_info)
    }

    /*** decode operands NYI ***/

    err = emdb_entry_p->format_function(emdb_entry_p, instr, bundle_p, 
                                        decoder_info);
    return(err);
}


/************************ misc. API functions ********************************/


const char* em_decoder_ver_str()
{
    return(em_ver_string);
}

const char* em_decoder_err_msg(EM_Decoder_Err error)
{
    if (error>=EM_DECODER_LAST_ERROR)
    {
        error = EM_DECODER_INTERNAL_ERROR;
    }
    return(em_err_msg[error]);
}

void em_decoder_get_version(EM_library_version_t *dec_version)
{
	if (dec_version != NULL)
	{
	  dec_version->xversion.major = XVER_MAJOR;
	  dec_version->xversion.minor = XVER_MINOR;
	  dec_version->api.major      = API_MAJOR;
	  dec_version->api.minor      = API_MINOR;
	  dec_version->emdb.major     = deccpu_emdb_version.major;
	  dec_version->emdb.minor     = deccpu_emdb_version.minor;
	  strcpy(dec_version->date, __DATE__);
	  strcpy(dec_version->time, __TIME__);
	}
}


/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\decoder.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef EM_DECODER_H
#define EM_DECODER_H

#include "inst_ids.h"
#include "emdb_types.h"
#include "EM.h"

#define EM_DECODER_INST_NONE  EM_INST_NONE

typedef Inst_id_t  EM_Decoder_Inst_Id;

typedef unsigned char  EM_Decoder_imp_oper_t;

#include "EM_tools.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef enum em_cmp_rel_s
{
	EM_CMP_REL_NONE  = 0,
	EM_CMP_REL_GEU   = 1,
	EM_CMP_REL_LTU   = 2,
	EM_CMP_REL_EQ    = 3,
	EM_CMP_REL_NE    = 4,
	EM_CMP_REL_LT    = 5,
	EM_CMP_REL_GE    = 6,
	EM_CMP_REL_GT    = 7,
	EM_CMP_REL_LE    = 8,
    EM_CMP_REL_UNORD = 9,
	EM_CMP_REL_ORD   = 10,
	EM_CMP_REL_NEQ   = 11,
	EM_CMP_REL_NLT   = 12,
	EM_CMP_REL_NLE   = 13,
	EM_CMP_REL_LAST  = 14
} EM_cmp_rel_t;

typedef enum em_fp_precision_s
{
	EM_FP_PRECISION_NONE    = 0,
	EM_FP_PRECISION_SINGLE  = 1,
	EM_FP_PRECISION_DOUBLE  = 2,
	EM_FP_PRECISION_DYNAMIC = 3,
	EM_FP_PRECISION_LAST    = 4
} EM_fp_precision_t;	

typedef enum em_fp_status_s
{
	EM_FP_STATUS_NONE = 0,
	EM_FP_STATUS_S0   = 1,
	EM_FP_STATUS_S1   = 2,
	EM_FP_STATUS_S2   = 3,
	EM_FP_STATUS_S3   = 4,
	EM_FP_STATUS_LAST = 5
} EM_fp_status_t;

typedef enum EM_decoder_imp_operand
{
	EM_DECODER_IMP_OPERAND_NONE = 0,
	EM_DECODER_IMP_OPERAND_AR_LC,
	EM_DECODER_IMP_OPERAND_RR,
    EM_DECODER_IMP_OPERAND_AR_BSPSTORE,
    EM_DECODER_IMP_OPERAND_APP_REG_GRP_HIGH,
    EM_DECODER_IMP_OPERAND_DTR,
    EM_DECODER_IMP_OPERAND_AR_UNAT,
    EM_DECODER_IMP_OPERAND_CR_IIM,
    EM_DECODER_IMP_OPERAND_PSR,
    EM_DECODER_IMP_OPERAND_CFM,
    EM_DECODER_IMP_OPERAND_CR_IFS,
    EM_DECODER_IMP_OPERAND_CR_ISR,
    EM_DECODER_IMP_OPERAND_AR_BSP,
    EM_DECODER_IMP_OPERAND_AR_RSC,
    EM_DECODER_IMP_OPERAND_AR_EC,
    EM_DECODER_IMP_OPERAND_AR_PFS,
    EM_DECODER_IMP_OPERAND_FPSR,
    EM_DECODER_IMP_OPERAND_APP_CCV,
	EM_DECODER_IMP_OPERAND_PR63,
	EM_DECODER_IMP_OPERAND_DCR,
	EM_DECODER_IMP_OPERAND_CR_IIP,
	EM_DECODER_IMP_OPERAND_IPSR,
	EM_DECODER_IMP_OPERAND_CSD,
	EM_DECODER_IMP_OPERAND_IP,
	EM_DECODER_IMP_OPERAND_EIP,
	EM_DECODER_IMP_OPERAND_MSR_XIP,
	EM_DECODER_IMP_OPERAND_MSR_XPSR,
	EM_DECODER_IMP_OPERAND_MSR_XFS,
    EM_DECODER_IMP_OPERAND_AR_ITC,
    EM_DECODER_IMP_OPERAND_AR_RNAT,
    EM_DECODER_IMP_OPERAND_AR_RCS,
    EM_DECODER_IMP_OPERAND_CR_CMCV,
    EM_DECODER_IMP_OPERAND_CR_EOI,
    EM_DECODER_IMP_OPERAND_CR_GPTA,
    EM_DECODER_IMP_OPERAND_CR_IFA,
    EM_DECODER_IMP_OPERAND_CR_IHA,
    EM_DECODER_IMP_OPERAND_CR_IIPA,
    EM_DECODER_IMP_OPERAND_CR_ITIR,
    EM_DECODER_IMP_OPERAND_CR_ITM,
    EM_DECODER_IMP_OPERAND_CR_ITV,
    EM_DECODER_IMP_OPERAND_CR_IVA,
    EM_DECODER_IMP_OPERAND_CR_IVR,
    EM_DECODER_IMP_OPERAND_CR_LID,
    EM_DECODER_IMP_OPERAND_CR_PMV,
    EM_DECODER_IMP_OPERAND_CR_PTA,
    EM_DECODER_IMP_OPERAND_CR_TPR,
	EM_DECODER_IMP_OPERAND_LAST
} EM_Decoder_Imp_Operand;

typedef enum EM_decoder_err
{ 
    EM_DECODER_NO_ERROR = 0,
	EM_DECODER_INVALID_SLOT_BRANCH_INST,
    EM_DECODER_MUST_BE_GROUP_LAST,
	EM_DECODER_BASE_EQUAL_DEST,
	EM_DECODER_EQUAL_DESTS,
	EM_DECODER_ODD_EVEN_DESTS,
	EM_DECODER_WRITE_TO_ZERO_REGISTER,
	EM_DECODER_WRITE_TO_SPECIAL_FP_REGISTER,
	EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE,
	EM_DECODER_REGISTER_RESERVED_VALUE,
	EM_DECODER_IMMEDIATE_VALUE_OUT_OF_RANGE,
	EM_DECODER_IMMEDIATE_INVALID_VALUE,
	EM_DECODER_STACK_FRAME_SIZE_OUT_OF_RANGE,
	EM_DECODER_LOCALS_SIZE_LARGER_STACK_FRAME,
	EM_DECODER_ROTATING_SIZE_LARGER_STACK_FRAME,
	EM_DECODER_HARD_CODED_PREDICATE_INVALID_VALUE,
	EM_DECODER_FIRST_FATAL_INST_ERROR,
    EM_DECODER_INVALID_PRM_OPCODE = EM_DECODER_FIRST_FATAL_INST_ERROR,
	EM_DECODER_INVALID_INST_SLOT,
	EM_DECODER_FIRST_FATAL_ERROR,
	EM_DECODER_INVALID_TEMPLATE = EM_DECODER_FIRST_FATAL_ERROR,
    EM_DECODER_INVALID_CLIENT_ID,
    EM_DECODER_NULL_PTR,
    EM_DECODER_TOO_SHORT_ERR,
    EM_DECODER_ASSOCIATE_MISS,
    EM_DECODER_INVALID_INST_ID,
    EM_DECODER_INVALID_MACHINE_MODE,
    EM_DECODER_INVALID_MACHINE_TYPE,
    EM_DECODER_INTERNAL_ERROR,
    EM_DECODER_LAST_ERROR
} EM_Decoder_Err;

typedef EM_Decoder_Err DecErr();

typedef enum EM_decoder_machine_type
{ 
    EM_DECODER_CPU_NO_CHANGE=0,
    EM_DECODER_CPU_DEFAULT,
    EM_DECODER_CPU_P7 = 4,
    EM_DECODER_CPU_LAST = 7
} EM_Decoder_Machine_Type;

typedef enum EM_decoder_machine_mode
{
    EM_DECODER_MODE_NO_CHANGE = 0,
    EM_DECODER_MODE_DEFAULT,
	EM_DECODER_MODE_EM = 8,
    EM_DECODER_MODE_LAST = 9
} EM_Decoder_Machine_Mode;

typedef enum EM_decoder_operand_type
{
    EM_DECODER_NO_OPER = 0,
    EM_DECODER_REGISTER,
    EM_DECODER_MEMORY,
    EM_DECODER_IMMEDIATE,
    EM_DECODER_IP_RELATIVE,
	EM_DECODER_REGFILE,
    EM_DECODER_OPERAND_LAST
} EM_Decoder_Operand_Type;

typedef enum EM_decoder_reg_type
{
    EM_DECODER_NO_REG_TYPE = 0,
    EM_DECODER_INT_REG = 7,
    EM_DECODER_FP_REG,
    EM_DECODER_APP_REG,
    EM_DECODER_BR_REG,
    EM_DECODER_PRED_REG = 13,
	EM_DECODER_CR_REG,
	EM_DECODER_APP_CCV_REG,
	EM_DECODER_APP_PFS_REG,
	EM_DECODER_PR_REG,
	EM_DECODER_PR_ROT_REG,
	EM_DECODER_PSR_REG,
	EM_DECODER_PSR_L_REG,
	EM_DECODER_PSR_UM_REG = 20,
	EM_DECODER_IP_REG,            /* IP register type */
    EM_DECODER_REG_TYPE_LAST
} EM_Decoder_Reg_Type;

typedef enum EM_decoder_reg_name
{
    EM_DECODER_NO_REG=0,
    EM_DECODER_REG_R0 = 98,
    EM_DECODER_REG_R1,
    EM_DECODER_REG_R2,
    EM_DECODER_REG_R3,
    EM_DECODER_REG_R4,
    EM_DECODER_REG_R5,
    EM_DECODER_REG_R6,
    EM_DECODER_REG_R7,
    EM_DECODER_REG_R8,
    EM_DECODER_REG_R9,
    EM_DECODER_REG_R10,
    EM_DECODER_REG_R11,
    EM_DECODER_REG_R12,
    EM_DECODER_REG_R13,
    EM_DECODER_REG_R14,
    EM_DECODER_REG_R15,
    EM_DECODER_REG_R16,
    EM_DECODER_REG_R17,
    EM_DECODER_REG_R18,
    EM_DECODER_REG_R19,
    EM_DECODER_REG_R20,
    EM_DECODER_REG_R21,
    EM_DECODER_REG_R22,
    EM_DECODER_REG_R23,
    EM_DECODER_REG_R24,
    EM_DECODER_REG_R25,
    EM_DECODER_REG_R26,
    EM_DECODER_REG_R27,
    EM_DECODER_REG_R28,
    EM_DECODER_REG_R29,
    EM_DECODER_REG_R30,
    EM_DECODER_REG_R31,
    EM_DECODER_REG_R32,
    EM_DECODER_REG_R33,
    EM_DECODER_REG_R34,
    EM_DECODER_REG_R35,
    EM_DECODER_REG_R36,
    EM_DECODER_REG_R37,
    EM_DECODER_REG_R38,
    EM_DECODER_REG_R39,
    EM_DECODER_REG_R40,
    EM_DECODER_REG_R41,
    EM_DECODER_REG_R42,
    EM_DECODER_REG_R43,
    EM_DECODER_REG_R44,
    EM_DECODER_REG_R45,
    EM_DECODER_REG_R46,
    EM_DECODER_REG_R47,
    EM_DECODER_REG_R48,
    EM_DECODER_REG_R49,
    EM_DECODER_REG_R50,
    EM_DECODER_REG_R51,
    EM_DECODER_REG_R52,
    EM_DECODER_REG_R53,
    EM_DECODER_REG_R54,
    EM_DECODER_REG_R55,
    EM_DECODER_REG_R56,
    EM_DECODER_REG_R57,
    EM_DECODER_REG_R58,
    EM_DECODER_REG_R59,
    EM_DECODER_REG_R60,
    EM_DECODER_REG_R61,
    EM_DECODER_REG_R62,
    EM_DECODER_REG_R63,
    EM_DECODER_REG_R64,
    EM_DECODER_REG_R65,
    EM_DECODER_REG_R66,
    EM_DECODER_REG_R67,
    EM_DECODER_REG_R68,
    EM_DECODER_REG_R69,
    EM_DECODER_REG_R70,
    EM_DECODER_REG_R71,
    EM_DECODER_REG_R72,
    EM_DECODER_REG_R73,
    EM_DECODER_REG_R74,
    EM_DECODER_REG_R75,
    EM_DECODER_REG_R76,
    EM_DECODER_REG_R77,
    EM_DECODER_REG_R78,
    EM_DECODER_REG_R79,
    EM_DECODER_REG_R80,
    EM_DECODER_REG_R81,
    EM_DECODER_REG_R82,
    EM_DECODER_REG_R83,
    EM_DECODER_REG_R84,
    EM_DECODER_REG_R85,
    EM_DECODER_REG_R86,
    EM_DECODER_REG_R87,
    EM_DECODER_REG_R88,
    EM_DECODER_REG_R89,
    EM_DECODER_REG_R90,
    EM_DECODER_REG_R91,
    EM_DECODER_REG_R92,
    EM_DECODER_REG_R93,
    EM_DECODER_REG_R94,
    EM_DECODER_REG_R95,
    EM_DECODER_REG_R96,
    EM_DECODER_REG_R97,
    EM_DECODER_REG_R98,
    EM_DECODER_REG_R99,
    EM_DECODER_REG_R100,
    EM_DECODER_REG_R101,
    EM_DECODER_REG_R102,
    EM_DECODER_REG_R103,
    EM_DECODER_REG_R104,
    EM_DECODER_REG_R105,
    EM_DECODER_REG_R106,
    EM_DECODER_REG_R107,
    EM_DECODER_REG_R108,
    EM_DECODER_REG_R109,
    EM_DECODER_REG_R110,
    EM_DECODER_REG_R111,
    EM_DECODER_REG_R112,
    EM_DECODER_REG_R113,
    EM_DECODER_REG_R114,
    EM_DECODER_REG_R115,
    EM_DECODER_REG_R116,
    EM_DECODER_REG_R117,
    EM_DECODER_REG_R118,
    EM_DECODER_REG_R119,
    EM_DECODER_REG_R120,
    EM_DECODER_REG_R121,
    EM_DECODER_REG_R122,
    EM_DECODER_REG_R123,
    EM_DECODER_REG_R124,
    EM_DECODER_REG_R125,
    EM_DECODER_REG_R126,
    EM_DECODER_REG_R127,
    EM_DECODER_REG_F0,
    EM_DECODER_REG_F1,
    EM_DECODER_REG_F2,
    EM_DECODER_REG_F3,
    EM_DECODER_REG_F4,
    EM_DECODER_REG_F5,
    EM_DECODER_REG_F6,
    EM_DECODER_REG_F7,
    EM_DECODER_REG_F8,
    EM_DECODER_REG_F9,
    EM_DECODER_REG_F10,
    EM_DECODER_REG_F11,
    EM_DECODER_REG_F12,
    EM_DECODER_REG_F13,
    EM_DECODER_REG_F14,
    EM_DECODER_REG_F15,
    EM_DECODER_REG_F16,
    EM_DECODER_REG_F17,
    EM_DECODER_REG_F18,
    EM_DECODER_REG_F19,
    EM_DECODER_REG_F20,
    EM_DECODER_REG_F21,
    EM_DECODER_REG_F22,
    EM_DECODER_REG_F23,
    EM_DECODER_REG_F24,
    EM_DECODER_REG_F25,
    EM_DECODER_REG_F26,
    EM_DECODER_REG_F27,
    EM_DECODER_REG_F28,
    EM_DECODER_REG_F29,
    EM_DECODER_REG_F30,
    EM_DECODER_REG_F31,
    EM_DECODER_REG_F32,
    EM_DECODER_REG_F33,
    EM_DECODER_REG_F34,
    EM_DECODER_REG_F35,
    EM_DECODER_REG_F36,
    EM_DECODER_REG_F37,
    EM_DECODER_REG_F38,
    EM_DECODER_REG_F39,
    EM_DECODER_REG_F40,
    EM_DECODER_REG_F41,
    EM_DECODER_REG_F42,
    EM_DECODER_REG_F43,
    EM_DECODER_REG_F44,
    EM_DECODER_REG_F45,
    EM_DECODER_REG_F46,
    EM_DECODER_REG_F47,
    EM_DECODER_REG_F48,
    EM_DECODER_REG_F49,
    EM_DECODER_REG_F50,
    EM_DECODER_REG_F51,
    EM_DECODER_REG_F52,
    EM_DECODER_REG_F53,
    EM_DECODER_REG_F54,
    EM_DECODER_REG_F55,
    EM_DECODER_REG_F56,
    EM_DECODER_REG_F57,
    EM_DECODER_REG_F58,
    EM_DECODER_REG_F59,
    EM_DECODER_REG_F60,
    EM_DECODER_REG_F61,
    EM_DECODER_REG_F62,
    EM_DECODER_REG_F63,
    EM_DECODER_REG_F64,
    EM_DECODER_REG_F65,
    EM_DECODER_REG_F66,
    EM_DECODER_REG_F67,
    EM_DECODER_REG_F68,
    EM_DECODER_REG_F69,
    EM_DECODER_REG_F70,
    EM_DECODER_REG_F71,
    EM_DECODER_REG_F72,
    EM_DECODER_REG_F73,
    EM_DECODER_REG_F74,
    EM_DECODER_REG_F75,
    EM_DECODER_REG_F76,
    EM_DECODER_REG_F77,
    EM_DECODER_REG_F78,
    EM_DECODER_REG_F79,
    EM_DECODER_REG_F80,
    EM_DECODER_REG_F81,
    EM_DECODER_REG_F82,
    EM_DECODER_REG_F83,
    EM_DECODER_REG_F84,
    EM_DECODER_REG_F85,
    EM_DECODER_REG_F86,
    EM_DECODER_REG_F87,
    EM_DECODER_REG_F88,
    EM_DECODER_REG_F89,
    EM_DECODER_REG_F90,
    EM_DECODER_REG_F91,
    EM_DECODER_REG_F92,
    EM_DECODER_REG_F93,
    EM_DECODER_REG_F94,
    EM_DECODER_REG_F95,
    EM_DECODER_REG_F96,
    EM_DECODER_REG_F97,
    EM_DECODER_REG_F98,
    EM_DECODER_REG_F99,
    EM_DECODER_REG_F100,
    EM_DECODER_REG_F101,
    EM_DECODER_REG_F102,
    EM_DECODER_REG_F103,
    EM_DECODER_REG_F104,
    EM_DECODER_REG_F105,
    EM_DECODER_REG_F106,
    EM_DECODER_REG_F107,
    EM_DECODER_REG_F108,
    EM_DECODER_REG_F109,
    EM_DECODER_REG_F110,
    EM_DECODER_REG_F111,
    EM_DECODER_REG_F112,
    EM_DECODER_REG_F113,
    EM_DECODER_REG_F114,
    EM_DECODER_REG_F115,
    EM_DECODER_REG_F116,
    EM_DECODER_REG_F117,
    EM_DECODER_REG_F118,
    EM_DECODER_REG_F119,
    EM_DECODER_REG_F120,
    EM_DECODER_REG_F121,
    EM_DECODER_REG_F122,
    EM_DECODER_REG_F123,
    EM_DECODER_REG_F124,
    EM_DECODER_REG_F125,
    EM_DECODER_REG_F126,
    EM_DECODER_REG_F127,
    EM_DECODER_REG_AR0,
    EM_DECODER_REG_AR1,
    EM_DECODER_REG_AR2,
    EM_DECODER_REG_AR3,
    EM_DECODER_REG_AR4,
    EM_DECODER_REG_AR5,
    EM_DECODER_REG_AR6,
    EM_DECODER_REG_AR7,
    EM_DECODER_REG_AR8,
    EM_DECODER_REG_AR9,
    EM_DECODER_REG_AR10,
    EM_DECODER_REG_AR11,
    EM_DECODER_REG_AR12,
    EM_DECODER_REG_AR13,
    EM_DECODER_REG_AR14,
    EM_DECODER_REG_AR15,
    EM_DECODER_REG_AR16,
    EM_DECODER_REG_AR17,
    EM_DECODER_REG_AR18,
    EM_DECODER_REG_AR19,
    EM_DECODER_REG_AR20,
    EM_DECODER_REG_AR21,
    EM_DECODER_REG_AR22,
    EM_DECODER_REG_AR23,
    EM_DECODER_REG_AR24,
    EM_DECODER_REG_AR25,
    EM_DECODER_REG_AR26,
    EM_DECODER_REG_AR27,
    EM_DECODER_REG_AR28,
    EM_DECODER_REG_AR29,
    EM_DECODER_REG_AR30,
    EM_DECODER_REG_AR31,
    EM_DECODER_REG_AR32,
    EM_DECODER_REG_AR33,
    EM_DECODER_REG_AR34,
    EM_DECODER_REG_AR35,
    EM_DECODER_REG_AR36,
    EM_DECODER_REG_AR37,
    EM_DECODER_REG_AR38,
    EM_DECODER_REG_AR39,
    EM_DECODER_REG_AR40,
    EM_DECODER_REG_AR41,
    EM_DECODER_REG_AR42,
    EM_DECODER_REG_AR43,
    EM_DECODER_REG_AR44,
    EM_DECODER_REG_AR45,
    EM_DECODER_REG_AR46,
    EM_DECODER_REG_AR47,
    EM_DECODER_REG_AR48,
    EM_DECODER_REG_AR49,
    EM_DECODER_REG_AR50,
    EM_DECODER_REG_AR51,
    EM_DECODER_REG_AR52,
    EM_DECODER_REG_AR53,
    EM_DECODER_REG_AR54,
    EM_DECODER_REG_AR55,
    EM_DECODER_REG_AR56,
    EM_DECODER_REG_AR57,
    EM_DECODER_REG_AR58,
    EM_DECODER_REG_AR59,
    EM_DECODER_REG_AR60,
    EM_DECODER_REG_AR61,
    EM_DECODER_REG_AR62,
    EM_DECODER_REG_AR63,
    EM_DECODER_REG_AR64,
    EM_DECODER_REG_AR65,
    EM_DECODER_REG_AR66,
    EM_DECODER_REG_AR67,
    EM_DECODER_REG_AR68,
    EM_DECODER_REG_AR69,
    EM_DECODER_REG_AR70,
    EM_DECODER_REG_AR71,
    EM_DECODER_REG_AR72,
    EM_DECODER_REG_AR73,
    EM_DECODER_REG_AR74,
    EM_DECODER_REG_AR75,
    EM_DECODER_REG_AR76,
    EM_DECODER_REG_AR77,
    EM_DECODER_REG_AR78,
    EM_DECODER_REG_AR79,
    EM_DECODER_REG_AR80,
    EM_DECODER_REG_AR81,
    EM_DECODER_REG_AR82,
    EM_DECODER_REG_AR83,
    EM_DECODER_REG_AR84,
    EM_DECODER_REG_AR85,
    EM_DECODER_REG_AR86,
    EM_DECODER_REG_AR87,
    EM_DECODER_REG_AR88,
    EM_DECODER_REG_AR89,
    EM_DECODER_REG_AR90,
    EM_DECODER_REG_AR91,
    EM_DECODER_REG_AR92,
    EM_DECODER_REG_AR93,
    EM_DECODER_REG_AR94,
    EM_DECODER_REG_AR95,
    EM_DECODER_REG_AR96,
    EM_DECODER_REG_AR97,
    EM_DECODER_REG_AR98,
    EM_DECODER_REG_AR99,
    EM_DECODER_REG_AR100,
    EM_DECODER_REG_AR101,
    EM_DECODER_REG_AR102,
    EM_DECODER_REG_AR103,
    EM_DECODER_REG_AR104,
    EM_DECODER_REG_AR105,
    EM_DECODER_REG_AR106,
    EM_DECODER_REG_AR107,
    EM_DECODER_REG_AR108,
    EM_DECODER_REG_AR109,
    EM_DECODER_REG_AR110,
    EM_DECODER_REG_AR111,
    EM_DECODER_REG_AR112,
    EM_DECODER_REG_AR113,
    EM_DECODER_REG_AR114,
    EM_DECODER_REG_AR115,
    EM_DECODER_REG_AR116,
    EM_DECODER_REG_AR117,
    EM_DECODER_REG_AR118,
    EM_DECODER_REG_AR119,
    EM_DECODER_REG_AR120,
    EM_DECODER_REG_AR121,
    EM_DECODER_REG_AR122,
    EM_DECODER_REG_AR123,
    EM_DECODER_REG_AR124,
    EM_DECODER_REG_AR125,
    EM_DECODER_REG_AR126,
    EM_DECODER_REG_AR127,
    EM_DECODER_REG_P0,
    EM_DECODER_REG_P1,
    EM_DECODER_REG_P2,
    EM_DECODER_REG_P3,
    EM_DECODER_REG_P4,
    EM_DECODER_REG_P5,
    EM_DECODER_REG_P6,
    EM_DECODER_REG_P7,
    EM_DECODER_REG_P8,
    EM_DECODER_REG_P9,
    EM_DECODER_REG_P10,
    EM_DECODER_REG_P11,
    EM_DECODER_REG_P12,
    EM_DECODER_REG_P13,
    EM_DECODER_REG_P14,
    EM_DECODER_REG_P15,
    EM_DECODER_REG_P16,
    EM_DECODER_REG_P17,
    EM_DECODER_REG_P18,
    EM_DECODER_REG_P19,
    EM_DECODER_REG_P20,
    EM_DECODER_REG_P21,
    EM_DECODER_REG_P22,
    EM_DECODER_REG_P23,
    EM_DECODER_REG_P24,
    EM_DECODER_REG_P25,
    EM_DECODER_REG_P26,
    EM_DECODER_REG_P27,
    EM_DECODER_REG_P28,
    EM_DECODER_REG_P29,
    EM_DECODER_REG_P30,
    EM_DECODER_REG_P31,
    EM_DECODER_REG_P32,
    EM_DECODER_REG_P33,
    EM_DECODER_REG_P34,
    EM_DECODER_REG_P35,
    EM_DECODER_REG_P36,
    EM_DECODER_REG_P37,
    EM_DECODER_REG_P38,
    EM_DECODER_REG_P39,
    EM_DECODER_REG_P40,
    EM_DECODER_REG_P41,
    EM_DECODER_REG_P42,
    EM_DECODER_REG_P43,
    EM_DECODER_REG_P44,
    EM_DECODER_REG_P45,
    EM_DECODER_REG_P46,
    EM_DECODER_REG_P47,
    EM_DECODER_REG_P48,
    EM_DECODER_REG_P49,
    EM_DECODER_REG_P50,
    EM_DECODER_REG_P51,
    EM_DECODER_REG_P52,
    EM_DECODER_REG_P53,
    EM_DECODER_REG_P54,
    EM_DECODER_REG_P55,
    EM_DECODER_REG_P56,
    EM_DECODER_REG_P57,
    EM_DECODER_REG_P58,
    EM_DECODER_REG_P59,
    EM_DECODER_REG_P60,
    EM_DECODER_REG_P61,
    EM_DECODER_REG_P62,
    EM_DECODER_REG_P63,
    EM_DECODER_REG_BR0 ,
    EM_DECODER_REG_BR1,
    EM_DECODER_REG_BR2,
    EM_DECODER_REG_BR3,
    EM_DECODER_REG_BR4,
    EM_DECODER_REG_BR5,
    EM_DECODER_REG_BR6,
    EM_DECODER_REG_BR7,
	EM_DECODER_REG_PR,
	EM_DECODER_REG_PR_ROT,
	EM_DECODER_REG_CR0,
	EM_DECODER_REG_CR1,
	EM_DECODER_REG_CR2,
	EM_DECODER_REG_CR3,
	EM_DECODER_REG_CR4,
	EM_DECODER_REG_CR5,
	EM_DECODER_REG_CR6,
	EM_DECODER_REG_CR7,
	EM_DECODER_REG_CR8,
	EM_DECODER_REG_CR9,
	EM_DECODER_REG_CR10,
	EM_DECODER_REG_CR11,
	EM_DECODER_REG_CR12,
	EM_DECODER_REG_CR13,
	EM_DECODER_REG_CR14,
	EM_DECODER_REG_CR15,
	EM_DECODER_REG_CR16,
	EM_DECODER_REG_CR17,
	EM_DECODER_REG_CR18,
	EM_DECODER_REG_CR19,
	EM_DECODER_REG_CR20,
	EM_DECODER_REG_CR21,
	EM_DECODER_REG_CR22,
	EM_DECODER_REG_CR23,
	EM_DECODER_REG_CR24,
	EM_DECODER_REG_CR25,
	EM_DECODER_REG_CR26,
	EM_DECODER_REG_CR27,
	EM_DECODER_REG_CR28,
	EM_DECODER_REG_CR29,
	EM_DECODER_REG_CR30,
	EM_DECODER_REG_CR31,
	EM_DECODER_REG_CR32,
	EM_DECODER_REG_CR33,
	EM_DECODER_REG_CR34,
	EM_DECODER_REG_CR35,
	EM_DECODER_REG_CR36,
	EM_DECODER_REG_CR37,
	EM_DECODER_REG_CR38,
	EM_DECODER_REG_CR39,
	EM_DECODER_REG_CR40,
	EM_DECODER_REG_CR41,
	EM_DECODER_REG_CR42,
	EM_DECODER_REG_CR43,
	EM_DECODER_REG_CR44,
	EM_DECODER_REG_CR45,
	EM_DECODER_REG_CR46,
	EM_DECODER_REG_CR47,
	EM_DECODER_REG_CR48,
	EM_DECODER_REG_CR49,
	EM_DECODER_REG_CR50,
	EM_DECODER_REG_CR51,
	EM_DECODER_REG_CR52,
	EM_DECODER_REG_CR53,
	EM_DECODER_REG_CR54,
	EM_DECODER_REG_CR55,
	EM_DECODER_REG_CR56,
	EM_DECODER_REG_CR57,
	EM_DECODER_REG_CR58,
	EM_DECODER_REG_CR59,
	EM_DECODER_REG_CR60,
	EM_DECODER_REG_CR61,
	EM_DECODER_REG_CR62,
	EM_DECODER_REG_CR63,
	EM_DECODER_REG_CR64,
	EM_DECODER_REG_CR65,
	EM_DECODER_REG_CR66,
	EM_DECODER_REG_CR67,
	EM_DECODER_REG_CR68,
	EM_DECODER_REG_CR69,
	EM_DECODER_REG_CR70,
	EM_DECODER_REG_CR71,
	EM_DECODER_REG_CR72,
	EM_DECODER_REG_CR73,
	EM_DECODER_REG_CR74,
	EM_DECODER_REG_CR75,
	EM_DECODER_REG_CR76,
	EM_DECODER_REG_CR77,
	EM_DECODER_REG_CR78,
	EM_DECODER_REG_CR79,
	EM_DECODER_REG_CR80,
	EM_DECODER_REG_CR81,
	EM_DECODER_REG_CR82,
	EM_DECODER_REG_CR83,
	EM_DECODER_REG_CR84,
	EM_DECODER_REG_CR85,
	EM_DECODER_REG_CR86,
	EM_DECODER_REG_CR87,
	EM_DECODER_REG_CR88,
	EM_DECODER_REG_CR89,
	EM_DECODER_REG_CR90,
	EM_DECODER_REG_CR91,
	EM_DECODER_REG_CR92,
	EM_DECODER_REG_CR93,
	EM_DECODER_REG_CR94,
	EM_DECODER_REG_CR95,
	EM_DECODER_REG_CR96,
	EM_DECODER_REG_CR97,
	EM_DECODER_REG_CR98,
	EM_DECODER_REG_CR99,
	EM_DECODER_REG_CR100,
	EM_DECODER_REG_CR101,
	EM_DECODER_REG_CR102,
	EM_DECODER_REG_CR103,
	EM_DECODER_REG_CR104,
	EM_DECODER_REG_CR105,
	EM_DECODER_REG_CR106,
	EM_DECODER_REG_CR107,
	EM_DECODER_REG_CR108,
	EM_DECODER_REG_CR109,
	EM_DECODER_REG_CR110,
	EM_DECODER_REG_CR111,
	EM_DECODER_REG_CR112,
	EM_DECODER_REG_CR113,
	EM_DECODER_REG_CR114,
	EM_DECODER_REG_CR115,
	EM_DECODER_REG_CR116,
	EM_DECODER_REG_CR117,
	EM_DECODER_REG_CR118,
	EM_DECODER_REG_CR119,
	EM_DECODER_REG_CR120,
	EM_DECODER_REG_CR121,
	EM_DECODER_REG_CR122,
	EM_DECODER_REG_CR123,
	EM_DECODER_REG_CR124,
	EM_DECODER_REG_CR125,
	EM_DECODER_REG_CR126,
	EM_DECODER_REG_CR127,
	EM_DECODER_REG_PSR,
	EM_DECODER_REG_PSR_L,
	EM_DECODER_REG_PSR_UM,
    EM_DECODER_REG_IP,      /* register IP name */ 
	EM_DECODER_EM_REG_LAST,

	EM_DECODER_REG_AR_K0   = EM_DECODER_REG_AR0+EM_AR_KR0,
	EM_DECODER_REG_AR_K1   = EM_DECODER_REG_AR0+EM_AR_KR1,
	EM_DECODER_REG_AR_K2   = EM_DECODER_REG_AR0+EM_AR_KR2,
	EM_DECODER_REG_AR_K3   = EM_DECODER_REG_AR0+EM_AR_KR3,
	EM_DECODER_REG_AR_K4   = EM_DECODER_REG_AR0+EM_AR_KR4, /* added AR_K4-7 */
	EM_DECODER_REG_AR_K5   = EM_DECODER_REG_AR0+EM_AR_KR5,
	EM_DECODER_REG_AR_K6   = EM_DECODER_REG_AR0+EM_AR_KR6,
	EM_DECODER_REG_AR_K7   = EM_DECODER_REG_AR0+EM_AR_KR7,
	EM_DECODER_REG_AR_RSC  = EM_DECODER_REG_AR0+EM_AR_RSC,
	EM_DECODER_REG_AR_BSP  = EM_DECODER_REG_AR0+EM_AR_BSP,
	EM_DECODER_REG_AR_BSPSTORE = EM_DECODER_REG_AR0+EM_AR_BSPSTORE,
	EM_DECODER_REG_AR_RNAT = EM_DECODER_REG_AR0+EM_AR_RNAT,
	EM_DECODER_REG_AR_EFLAG= EM_DECODER_REG_AR0+EM_AR_EFLAG,
   	EM_DECODER_REG_AR_CSD  = EM_DECODER_REG_AR0+EM_AR_CSD,
	EM_DECODER_REG_AR_SSD  = EM_DECODER_REG_AR0+EM_AR_SSD,
	EM_DECODER_REG_AR_CFLG = EM_DECODER_REG_AR0+EM_AR_CFLG,
	EM_DECODER_REG_AR_FSR  = EM_DECODER_REG_AR0+EM_AR_FSR,
	EM_DECODER_REG_AR_FIR  = EM_DECODER_REG_AR0+EM_AR_FIR,
	EM_DECODER_REG_AR_FDR  = EM_DECODER_REG_AR0+EM_AR_FDR,
	EM_DECODER_REG_AR_CCV  = EM_DECODER_REG_AR0+EM_AR_CCV,
	EM_DECODER_REG_AR_UNAT = EM_DECODER_REG_AR0+EM_AR_UNAT,
	EM_DECODER_REG_AR_FPSR = EM_DECODER_REG_AR0+EM_AR_FPSR,
	EM_DECODER_REG_AR_ITC  = EM_DECODER_REG_AR0+EM_AR_ITC,	
	EM_DECODER_REG_AR_PFS  = EM_DECODER_REG_AR0+EM_AR_PFS,
	EM_DECODER_REG_AR_LC   = EM_DECODER_REG_AR0+EM_AR_LC,
	EM_DECODER_REG_AR_EC   = EM_DECODER_REG_AR0+EM_AR_EC,

	EM_DECODER_REG_CR_DCR  = EM_DECODER_REG_CR0+EM_CR_DCR,
	EM_DECODER_REG_CR_ITM  = EM_DECODER_REG_CR0+EM_CR_ITM,
	EM_DECODER_REG_CR_IVA  = EM_DECODER_REG_CR0+EM_CR_IVA,
	EM_DECODER_REG_CR_PTA  = EM_DECODER_REG_CR0+EM_CR_PTA,
	EM_DECODER_REG_CR_GPTA = EM_DECODER_REG_CR0+EM_CR_GPTA,
	EM_DECODER_REG_CR_IPSR = EM_DECODER_REG_CR0+EM_CR_IPSR,
	EM_DECODER_REG_CR_ISR  = EM_DECODER_REG_CR0+EM_CR_ISR,
	EM_DECODER_REG_CR_IIP  = EM_DECODER_REG_CR0+EM_CR_IIP,
	EM_DECODER_REG_CR_IFA  = EM_DECODER_REG_CR0+EM_CR_IFA,
	EM_DECODER_REG_CR_ITIR = EM_DECODER_REG_CR0+EM_CR_ITIR,
	EM_DECODER_REG_CR_IIPA = EM_DECODER_REG_CR0+EM_CR_IIPA,
	EM_DECODER_REG_CR_IFS  = EM_DECODER_REG_CR0+EM_CR_IFS,
	EM_DECODER_REG_CR_IIM  = EM_DECODER_REG_CR0+EM_CR_IIM,
	EM_DECODER_REG_CR_IHA  = EM_DECODER_REG_CR0+EM_CR_IHA,

	EM_DECODER_REG_CR_LID  = EM_DECODER_REG_CR0+EM_CR_LID,
	EM_DECODER_REG_CR_IVR  = EM_DECODER_REG_CR0+EM_CR_IVR,
	EM_DECODER_REG_CR_TPR  = EM_DECODER_REG_CR0+EM_CR_TPR,
	EM_DECODER_REG_CR_EOI  = EM_DECODER_REG_CR0+EM_CR_EOI,
	EM_DECODER_REG_CR_IRR0 = EM_DECODER_REG_CR0+EM_CR_IRR0,
	EM_DECODER_REG_CR_IRR1 = EM_DECODER_REG_CR0+EM_CR_IRR1,
	EM_DECODER_REG_CR_IRR2 = EM_DECODER_REG_CR0+EM_CR_IRR2,
	EM_DECODER_REG_CR_IRR3 = EM_DECODER_REG_CR0+EM_CR_IRR3,
	EM_DECODER_REG_CR_ITV  = EM_DECODER_REG_CR0+EM_CR_ITV,
	EM_DECODER_REG_CR_PMV  = EM_DECODER_REG_CR0+EM_CR_PMV,
	EM_DECODER_REG_CR_LRR0 = EM_DECODER_REG_CR0+EM_CR_LRR0,
	EM_DECODER_REG_CR_LRR1 = EM_DECODER_REG_CR0+EM_CR_LRR1,
	EM_DECODER_REG_CR_CMCV = EM_DECODER_REG_CR0+EM_CR_CMCV,
		
/************************************************************/
    EM_DECODER_REG_LAST
} EM_Decoder_Reg_Name;

typedef struct EM_decoder_reg_info
{
    int                  valid;
    EM_Decoder_Reg_Type  type;
    EM_Decoder_Reg_Name  name;
    long                 value;
} EM_Decoder_Reg_Info;

typedef enum EM_DECODER_regfile_name
{
	EM_DECODER_NO_REGFILE = 0,
	EM_DECODER_REGFILE_PMC,
	EM_DECODER_REGFILE_PMD,
	EM_DECODER_REGFILE_PKR,
	EM_DECODER_REGFILE_RR,
	EM_DECODER_REGFILE_IBR,
	EM_DECODER_REGFILE_DBR,
	EM_DECODER_REGFILE_ITR,
	EM_DECODER_REGFILE_DTR,
	EM_DECODER_REGFILE_MSR,
	EM_DECODER_REGFILE_CPUID,
	EM_DECODER_REGFILE_LAST
} EM_Decoder_Regfile_Name;

typedef enum EM_decoder_operand_2nd_role
{
    EM_DECODER_OPER_2ND_ROLE_NONE = 0,
    EM_DECODER_OPER_2ND_ROLE_SRC,
    EM_DECODER_OPER_2ND_ROLE_DST
} EM_Decoder_Operand_2nd_Role;

typedef enum EM_decoder_oper_size
{
    EM_DECODER_OPER_NO_SIZE =  0,
    EM_DECODER_OPER_SIZE_1 =   1,
    EM_DECODER_OPER_SIZE_2 =   2,
    EM_DECODER_OPER_SIZE_4 =   4,
    EM_DECODER_OPER_SIZE_8 =   8,
    EM_DECODER_OPER_SIZE_10 = 10,
    EM_DECODER_OPER_SIZE_16 = 16,
    EM_DECODER_OPER_SIZE_20 = 20,
    EM_DECODER_OPER_SIZE_22 = 22,
    EM_DECODER_OPER_SIZE_24 = 24,  
    EM_DECODER_OPER_SIZE_32 = 32,
    EM_DECODER_OPER_SIZE_64 = 64
} EM_Decoder_Oper_Size;

typedef enum EM_decoder_imm_type
{
	EM_DECODER_IMM_NONE,
	EM_DECODER_IMM_SIGNED,
	EM_DECODER_IMM_UNSIGNED,
	EM_DECODER_IMM_FCLASS,
	EM_DECODER_IMM_MUX1,
	EM_DECODER_IMM_LAST
} EM_Decoder_Imm_Type;

typedef enum EM_decoder_slot
{
	EM_DECODER_SLOT_0 = 0,
	EM_DECODER_SLOT_1 = 1,
	EM_DECODER_SLOT_2 = 2,
	EM_DECODER_SLOT_LAST = 2
} EM_Decoder_Slot;


/***** EM_decoder Structure Defenition ****/

typedef struct EM_decoder_modifiers_s
{
	EM_cmp_type_t           cmp_type;
	EM_cmp_rel_t            cmp_rel;
	EM_branch_type_t        branch_type;
	EM_branch_hint_t        branch_hint;
	EM_fp_precision_t       fp_precision;
	EM_fp_status_t          fp_status;
	EM_memory_access_hint_t mem_access_hint;
} EM_Decoder_modifiers_t;	


typedef struct EM_decoder_oper_static_s
{
	Operand_role_t role;
	Operand_type_t type;
	unsigned long  flags;
} EM_Decoder_oper_static_t;


#define EM_DECODER_MAX_EXP_DST (2)
#define EM_DECODER_MAX_EXP_SRC (5)
#define EM_DECODER_MAX_IMP_DST (8)
#define EM_DECODER_MAX_IMP_SRC (8)

typedef struct EM_decoder_static_info_s
{
	Mnemonic_t               mnemonic;
	Template_role_t          template_role;
	EM_Decoder_oper_static_t explicit_dst[EM_DECODER_MAX_EXP_DST];
	EM_Decoder_oper_static_t explicit_src[EM_DECODER_MAX_EXP_SRC];
	EM_Decoder_imp_oper_t    implicit_dst[EM_DECODER_MAX_IMP_DST];
	EM_Decoder_imp_oper_t    implicit_src[EM_DECODER_MAX_IMP_SRC];
	EM_Decoder_modifiers_t   modifiers;
	Flags_t                  flags;
} EM_Decoder_static_info_t;


extern const EM_Decoder_static_info_t em_decoder_static_info[];


typedef struct EM_decoder_regfile_info
{
    EM_Decoder_Regfile_Name  name;
    EM_Decoder_Reg_Info      index;
} EM_Decoder_Regfile_Info;


typedef struct EM_decoder_imm_info
{
    EM_Decoder_Imm_Type  imm_type;
    unsigned int         size;
    U64                  val64;
} EM_Decoder_Imm_Info;

typedef struct EM_decoder_mem_info
{
    EM_Decoder_Reg_Info    mem_base;
    EM_Decoder_Oper_Size   size;
} EM_Decoder_Mem_Info;

typedef struct em_decoder_em_bundle_info
{
	EM_template_t           b_template;
	unsigned long		    flags;
} EM_Decoder_EM_Bundle_Info;

typedef struct em_decoder_em_info
{
	EM_Decoder_EM_Bundle_Info  em_bundle_info;
	EM_Decoder_Slot            slot_no;
	Template_role_t            eut;
	unsigned long              em_flags;
} EM_Decoder_EM_Info;

typedef struct EM_decoder_inst_static_info
{
    void *                client_info;
	const EM_Decoder_static_info_t *static_info;
    unsigned long         flags;
} EM_Decoder_Inst_Static_Info;


typedef struct EM_decoder_operand_info
{
    EM_Decoder_Operand_Type     type;
	EM_Decoder_Regfile_Info     regfile_info;
    EM_Decoder_Reg_Info         reg_info;
    EM_Decoder_Mem_Info         mem_info;
    EM_Decoder_Imm_Info         imm_info;
    long                        ip_relative_offset;
    unsigned long               oper_flags;
} EM_Decoder_Operand_Info;


typedef struct em_decoder_info
{
    EM_Decoder_Inst_Id       inst;
    EM_Decoder_Reg_Info      pred;
    EM_Decoder_Operand_Info  src1;
    EM_Decoder_Operand_Info  src2;
    EM_Decoder_Operand_Info  src3;
    EM_Decoder_Operand_Info  src4;
    EM_Decoder_Operand_Info  src5;
    EM_Decoder_Operand_Info  dst1;
    EM_Decoder_Operand_Info  dst2;
	EM_Decoder_EM_Info       EM_info;
    void *                   client_info;
    unsigned long            flags;
    unsigned char            size;
	const EM_Decoder_static_info_t *static_info;
} EM_Decoder_Info;


typedef struct em_decoder_bundle_info
{
	unsigned int          	    inst_num;
	EM_Decoder_EM_Bundle_Info	em_bundle_info;
	EM_Decoder_Err           	error[3];
	EM_Decoder_Info          	inst_info[3];
} EM_Decoder_Bundle_Info;
	

typedef int EM_Decoder_Id;


/***********************************************/
/***          Setup flags                    ***/
/***********************************************/
  
#define EM_DECODER_FLAG_NO_MEMSET       0X00000001


extern const U32 em_decoder_bundle_size;

EM_Decoder_Id  em_decoder_open(void);

EM_Decoder_Err em_decoder_associate_one(const EM_Decoder_Id		 id,
								   const EM_Decoder_Inst_Id	     inst,
								   const void                  * client_info);

EM_Decoder_Err em_decoder_associate_check(const EM_Decoder_Id    id,
									       EM_Decoder_Inst_Id  * inst);

EM_Decoder_Err em_decoder_setenv(const EM_Decoder_Id,
                           const EM_Decoder_Machine_Type,
                           const EM_Decoder_Machine_Mode);

EM_Decoder_Err em_decoder_setup(const EM_Decoder_Id,
                           const EM_Decoder_Machine_Type,
                           const EM_Decoder_Machine_Mode,
						   unsigned long flags);

EM_Decoder_Err em_decoder_close(const EM_Decoder_Id);

EM_Decoder_Err em_decoder_decode(const EM_Decoder_Id    id,
						         const unsigned char  * code,
						         const int			    max_code_size,
						         const EM_IL		    location,
						         EM_Decoder_Info      * decoder_info);

 EM_Decoder_Err em_decoder_inst_static_info(const  EM_Decoder_Id,
                                            const  EM_Decoder_Inst_Id,
                                            EM_Decoder_Inst_Static_Info *);

 const char* em_decoder_ver_str(void);

 void  em_decoder_get_version(EM_library_version_t  * dec_version);

 const char* em_decoder_err_msg(EM_Decoder_Err error);

 EM_Decoder_Err em_decoder_decode_bundle(const EM_Decoder_Id        id,
								         const unsigned char      * code,
								         const int                  max_size,
								         EM_Decoder_Bundle_Info   * bundle_info);

/**********************  GET next IL  *************************/
#define EM_DECODER_NEXT(IL, decoder_info)                       \
{                                                               \
	U32 rem_size;												\
	int slot_no = EM_IL_GET_SLOT_NO(IL),						\
	    size = (decoder_info)->size;							\
	switch (slot_no)											\
	{															\
	  case 0:													\
		break;													\
	  case 1:													\
		if (size < 2)											\
			break;		/*** else fall-through ***/				\
	  case 2:													\
		size = EM_BUNDLE_SIZE - slot_no;						\
	}															\
	IEL_CONVERT1(rem_size, size);								\
	IEL_ADDU(IL, IL, rem_size);                                 \
}

#define EM_DECODER_BUNDLE_NEXT(addr)          	                \
{                                                               \
	IEL_ADDU(addr, addr, em_decoder_bundle_size);               \
}


#define EM_DECODER_ERROR_IS_FATAL(_Err)          \
     ((_Err) >= EM_DECODER_FIRST_FATAL_ERROR)

#define EM_DECODER_ERROR_IS_INST_FATAL(_Err)      \
     (((_Err) >= EM_DECODER_FIRST_FATAL_INST_ERROR) && ((_Err) < EM_DECODER_FIRST_FATAL_ERROR))


/*************   EM Instruction Flags Related Macros   ***************/

/*** EM_decoder and static infos flags ***/

/* Flags that copied directly from EMDB */

#define EM_DECODER_BIT_PREDICATE          EM_FLAG_PRED               /* The instruction can get pred  */
#define EM_DECODER_BIT_PRIVILEGED         EM_FLAG_PRIVILEGED         /* The instruction is privileged */
#define EM_DECODER_BIT_LMEM               EM_FLAG_LMEM               /* The instuction is a load inst */
#define EM_DECODER_BIT_SMEM               EM_FLAG_SMEM               /* The instruction is a store    */
#define EM_DECODER_BIT_CHECK_BASE_EQ_DST  EM_FLAG_CHECK_BASE_EQ_DST  /* Base value must differ from destination's */
#define EM_DECODER_BIT_GROUP_FIRST        EM_FLAG_FIRST_IN_INSTRUCTION_GROUP /* Instruction must be the first in instruction group */
#define EM_DECODER_BIT_GROUP_LAST         EM_FLAG_LAST_IN_INSTRUCTION_GROUP  /* Instruction must be the last in instruction group */
#define EM_DECODER_BIT_CHECK_SAME_DSTS    EM_FLAG_CHECK_SAME_DSTS    /* Two destinations should have different values */
#define EM_DECODER_BIT_SLOT2_ONLY         EM_FLAG_SLOT2_ONLY         /* The instruction is allowed in the last slot of bundle */
#define EM_DECODER_BIT_TWO_SLOT           EM_FLAG_TWO_SLOT           /* The instruction is long (2 slots length) */
#define EM_DECODER_BIT_OK_IN_MLX          EM_FLAG_OK_IN_MLX
#define EM_DECODER_BIT_CHECK_EVEN_ODD_FREGS EM_FLAG_CHECK_EVEN_ODD_FREGS
#define EM_DECODER_BIT_CTYPE_UNC          EM_FLAG_CTYPE_UNC          /* If two destinations are equal the instruction
																		allways causes illegal operation fault */
#define EM_DECODER_BIT_UNUSED_HINT_ALIAS  EM_FLAG_UNUSED_HINT_ALIAS
#define EM_DECODER_BIT_ILLEGAL_OP		  EM_FLAG_ILLEGAL_OP
#define EM_DECODER_BIT_IGNORED_OP		  EM_FLAG_IGNORED_OP
#define EM_DECODER_BIT_ENDS_GROUP		  EM_FLAG_ENDS_INSTRUCTION_GROUP
 
 /* Others */
#define EM_DECODER_BIT_SPECULATION        (EMDB_LAST_FLAG << 1)      /* Speculative form of instruction */
#define EM_DECODER_BIT_POSTINCREMENT      (EMDB_LAST_FLAG << 2)      /* Post increment form of instruction */
#define EM_DECODER_BIT_FALSE_PRED_EXEC    (EMDB_LAST_FLAG << 3)      /* Instruction executed when predicate is false */
#define EM_DECODER_BIT_BR_HINT            (EMDB_LAST_FLAG << 4)      /* Branch-hint form of instruction */ 
#define EM_DECODER_BIT_BR                 (EMDB_LAST_FLAG << 5)      /* Branch instruction              */
#define EM_DECODER_BIT_ADV_LOAD           (EMDB_LAST_FLAG << 6)      /* Instruction is an advanced or speculative advanced load */
#define EM_DECODER_BIT_CONTROL_TRANSFER   (EMDB_LAST_FLAG << 7)      /* Instruction violates sequential control flow */
#define EM_DECODER_BIT_UNC_ILLEGAL_FAULT  (EMDB_LAST_FLAG << 8)      /* Illegal opcode causes illegal operation fault 
                                                                        undependent on predicate value */
 
/* Flags that depend on the current bundle encoding */

/* in em_flags: */
#define EM_DECODER_BIT_CYCLE_BREAK 0x10000 /*Inst is last in its group */
#define EM_DECODER_BIT_LAST_INST   0x20000 /*Last instruction in bundle   */

/* Static flags (depend only on inst id) */
 
#define EM_DECODER_BIT_LONG_INST   0x40000 /* 2 slots Inst */

/* in em_bundle_info flags */
#define EM_DECODER_BIT_BUNDLE_STOP 0x80000 /*Stop bit is set in bundle*/


#define EM_DECODER_PREDICATE(di)                (EM_DECODER_BIT_PREDICATE & ((di)->flags))
#define EM_DECODER_PRIVILEGED(di)               (EM_DECODER_BIT_PRIVILEGED & ((di)->flags))
#define EM_DECODER_LMEM(di)                     (EM_DECODER_BIT_LMEM & ((di)->flags))      
#define EM_DECODER_SMEM(di)                     (EM_DECODER_BIT_SMEM & ((di)->flags))
#define EM_DECODER_CHECK_BASE_EQ_DST(di)        (EM_DECODER_BIT_CHECK_BASE_EQ_DST & ((di)->flags))
#define EM_DECODER_CHECK_SPECULATION(di)        (EM_DECODER_BIT_SPECULATION & ((di)->flags))
#define EM_DECODER_CHECK_POSTINCREMENT(di)      (EM_DECODER_BIT_POSTINCREMENT & ((di)->flags))
#define EM_DECODER_CHECK_FALSE_PRED_EXEC(di)    (EM_DECODER_BIT_FALSE_PRED_EXEC & ((di)->flags))
#define EM_DECODER_CHECK_BR_HINT(di)            (EM_DECODER_BIT_BR_HINT & ((di)->flags))
#define EM_DECODER_CHECK_BR(di)                 (EM_DECODER_BIT_BR & ((di)->flags))
#define EM_DECODER_CHECK_GROUP_FIRST(di)        (EM_DECODER_BIT_GROUP_FIRST & ((di)->flags))
#define EM_DECODER_CHECK_GROUP_LAST(di)         (EM_DECODER_BIT_GROUP_LAST & ((di)->flags))
#define EM_DECODER_CHECK_SAME_DSTS(di)          (EM_DECODER_BIT_CHECK_SAME_DSTS & ((di)->flags))
#define EM_DECODER_CHECK_SLOT2_ONLY(di)         (EM_DECODER_BIT_SLOT2_ONLY & ((di)->flags))
#define EM_DECODER_CHECK_TWO_SLOT(di)           (EM_DECODER_BIT_TWO_SLOT & ((di)->flags))
#define EM_DECODER_CHECK_ADV_LOAD(di)           (EM_DECODER_BIT_ADV_LOAD & ((di)->flags))
#define EM_DECODER_CHECK_CONTROL_TRANSFER(di)   (EM_DECODER_BIT_CONTROL_TRANSFER & ((di)->flags))
#define EM_DECODER_CHECK_UNC_ILLEGAL_FAULT(di)  (EM_DECODER_BIT_CTYPE_UNC & ((di)->flags))
#define EM_DECODER_CHECK_OK_IN_MLX(di)          (EM_DECODER_BIT_OK_IN_MLX & ((di)->flags))
#define EM_DECODER_CHECK_UNUSED_HINT_ALIAS(di)	(EM_DECODER_BIT_UNUSED_HINT_ALIAS & ((di)->flags))
#define EM_DECODER_CHECK_ILLEGAL_OP(di)			(EM_DECODER_BIT_ILLEGAL_OP & ((di)->flags))
#define EM_DECODER_CHECK_IGNORED_OP(di)			(EM_DECODER_BIT_IGNORED_OP & ((di)->flags))
#define EM_DECODER_CHECK_ENDS_GROUP(di)			(EM_DECODER_BIT_ENDS_GROUP & ((di)->flags))


#define EM_DECODER_LONG_INST(di)   		\
		(EM_DECODER_BIT_LONG_INST & (((di)->EM_info).em_flags))

#define EM_DECODER_LAST_INST(di)  				\
		(EM_DECODER_BIT_LAST_INST & (((di)->EM_info).em_flags))

#define EM_DECODER_CYCLE_BREAK(di) 		\
		(EM_DECODER_BIT_CYCLE_BREAK & (((di)->EM_info).em_flags))

#define EM_DECODER_BUNDLE_STOP(di) 		\
		(EM_DECODER_BIT_BUNDLE_STOP & 	\
		 (((di)->EM_info).em_bundle_info.flags))



/************** Operand Related macros ****************/
									
#define EM_DECODER_OPER_2ND_ROLE_SRC_BIT  0x00000001  /* Oper second role:  src */
#define EM_DECODER_OPER_2ND_ROLE_DST_BIT  0x00000002  /* Oper second role: dest */
#define EM_DECODER_OPER_IMM_IREG_BIT      0x00000040  /* Operand type is IREG_NUM */
#define EM_DECODER_OPER_IMM_FREG_BIT      0x00000080  /* Operand type is FREG_NUM */

#define EM_DECODER_OPER_2ND_ROLE_SRC(oi)                                         \
							(((oi)->oper_flags) & EM_DECODER_OPER_2ND_ROLE_SRC_BIT)
#define EM_DECODER_OPER_2ND_ROLE_DST(oi)                                         \
							(((oi)->oper_flags) & EM_DECODER_OPER_2ND_ROLE_DST_BIT)
#define EM_DECODER_OPER_NOT_TRUE_SRC(oi)                                         \
							(((oi)->oper_flags) & EM_DECODER_OPER_NOT_TRUE_SRC_BIT)
#define EM_DECODER_OPER_IMP_ENCODED(oi)                                          \
							(((oi)->oper_flags) & EM_DECODER_OPER_IMP_ENCODED_BIT)

#define EM_DECODER_OPER_IMM_REG(oi) 		                                    \
	(((oi)->oper_flags) & (EM_DECODER_OPER_IMM_IREG_BIT |						\
						   EM_DECODER_OPER_IMM_FREG_BIT))

#define EM_DECODER_OPER_IMM_IREG(oi)                                     \
							(((oi)->oper_flags) & EM_DECODER_OPER_IMM_IREG_BIT)
#define EM_DECODER_OPER_IMM_FREG(oi)                                     \
							(((oi)->oper_flags) & EM_DECODER_OPER_IMM_FREG_BIT)



/************* EM_decoder Static Info Related macros ************/

/****** Macros receive pointer to modifiers ******/

#define EM_DECODER_MODIFIERS_CMP_TYPE(Mo) \
                            ((Mo)->cmp_type)

#define EM_DECODER_MODIFIERS_CMP_REL(Mo) \
                            ((Mo)->cmp_rel)

#define EM_DECODER_MODIFIERS_BRANCH_TYPE(Mo) \
                            ((Mo)->branch_type)

#define EM_DECODER_MODIFIERS_BRANCH_HINT(Mo) \
                            ((Mo)->branch_hint)
 
#define EM_DECODER_MODIFIERS_FP_PRECISION(Mo) \
                            ((Mo)->fp_precision)

#define EM_DECODER_MODIFIERS_FP_STATUS(Mo) \
                            ((Mo)->fp_status)

#define EM_DECODER_MODIFIERS_MEMORY_ACCESS_HINT(Mo) \
                            ((Mo)->mem_access_hint)


/****** Macros receive operand flags value ******/

#define EM_DECODER_OPER_FLAGS_2ND_ROLE_SRC(of) \
							((of) & EM_DECODER_OPER_2ND_ROLE_SRC_BIT)

#define EM_DECODER_OPER_FLAGS_2ND_ROLE_DST(of) \
                            ((of) & EM_DECODER_OPER_2ND_ROLE_DST_BIT)

#define EM_DECODER_OPER_FLAGS_IMM_REG(of) \
            	            ((of) & (EM_DECODER_OPER_IMM_IREG_BIT | \
						    EM_DECODER_OPER_IMM_FREG_BIT))

#define EM_DECODER_OPER_FLAGS_IMM_IREG(of) \
							((of) & EM_DECODER_OPER_IMM_IREG_BIT)

#define EM_DECODER_OPER_FLAGS_IMM_FREG(of) \
							((of) & EM_DECODER_OPER_IMM_FREG_BIT)


/****** Macros receive pointer to operand ******/

#define EM_DECODER_OPER_STAT_2ND_ROLE_SRC(oi) \
							EM_DECODER_OPER_FLAGS_2ND_ROLE_SRC((oi)->flags)

#define EM_DECODER_OPER_STAT_2ND_ROLE_DST(oi) \
                            EM_DECODER_OPER_FLAGS_2ND_ROLE_DST((oi)->flags)

#define EM_DECODER_OPER_STAT_IMM_REG(oi) \
                            EM_DECODER_OPER_FLAGS_IMM_REG((oi)->flags)

#define EM_DECODER_OPER_STAT_IMM_BREG(oi) \
							EM_DECODER_OPER_FLAGS_IMM_BREG((oi)->flags)

#define EM_DECODER_OPER_STAT_IMM_IREG(oi) \
							EM_DECODER_OPER_FLAGS_IMM_IREG((oi)->flags)
												  

#define EM_DECODER_OPER_STAT_IMM_FREG(oi) \
							EM_DECODER_OPER_FLAGS_IMM_FREG((oi)->flags)



#define EM_DECODER_OPER_ROLE(oi) \
                            ((oi)->role)

#define EM_DECODER_OPER_TYPE(oi) \
                            ((oi)->type)

#define EM_DECODER_OPER_FLAGS(oi) \
                            ((oi)->flags)


/****** Macros receive instruction flags value ******/

#define EM_DECODER_FLAGS_FLAG_PRED(if) \
                            ((if) & EM_DECODER_BIT_PREDICATE)

#define EM_DECODER_FLAGS_FLAG_PRIVILEGED(if) \
                            ((if) & EM_DECODER_BIT_PRIVILEGED)

#define EM_DECODER_FLAGS_FLAG_LMEM(if) \
                            ((if) & EM_DECODER_BIT_LMEM)

#define EM_DECODER_FLAGS_FLAG_SMEM(if) \
                            ((if) & EM_DECODER_BIT_SMEM)

#define EM_DECODER_FLAGS_FLAG_CHECK_BASE_EQ_DST(if) \
                            ((if) & EM_DECODER_BIT_CHECK_BASE_EQ_DST)

#define EM_DECODER_FLAGS_FLAG_SPECULATION(if) \
                            ((if) & EM_DECODER_BIT_SPECULATION)

#define EM_DECODER_FLAGS_FLAG_POSTINCREMENT(if) \
                            ((if) & EM_DECODER_BIT_POSTINCREMENT)

#define EM_DECODER_FLAGS_FLAG_FALSE_PRED_EXEC(if) \
                            ((if) & EM_DECODER_BIT_FALSE_PRED_EXEC)

#define EM_DECODER_FLAGS_FLAG_BR_HINT(if) \
                            ((if) & EM_DECODER_BIT_BR_HINT)

#define EM_DECODER_FLAGS_FLAG_BR(if) \
                            ((if) & EM_DECODER_BIT_BR)

#define EM_DECODER_FLAGS_FLAG_ADV_LOAD(if) \
                            ((if) & EM_DECODER_CHECK_ADV_LOAD)

#define EM_DECODER_FLAGS_FLAG_GROUP_FIRST(if) \
                            ((if) & EM_DECODER_BIT_GROUP_FIRST)

#define EM_DECODER_FLAGS_FLAG_GROUP_LAST(if) \
                            ((if) & EM_DECODER_BIT_GROUP_LAST)

#define EM_DECODER_FLAGS_FLAG_CHECK_SAME_DSTS(if) \
                            ((if) & EM_DECODER_BIT_CHECK_SAME_DSTS)

#define EM_DECODER_FLAGS_FLAG_CONTROL_TRANSFER(if) \
                            ((if) & EM_DECODER_BIT_CONTROL_TRANSFER)

#define EM_DECODER_FLAGS_FLAG_UNUSED_HINT_ALIAS(if) \
							((if) & EM_DECODER_BIT_UNUSED_HINT_ALIAS)

#define EM_DECODER_FLAGS_FLAG_ILLEGAL_OP(if) \
							((if) & EM_DECODER_BIT_ILLEGAL_OP)

#define EM_DECODER_FLAGS_FLAG_IGNORED_OP(if) \
							((if) & EM_DECODER_BIT_IGNORED_OP)

#define EM_DECODER_FLAGS_FLAG_ENDS_GROUP(if) \
							((if) & EM_DECODER_BIT_ENDS_GROUP)


/****** Macros receive pointer to EM_decoder static info ******/

#define EM_DECODER_STATIC_MNEMONIC(si) \
                            ((si)->mnemonic)

#define EM_DECODER_STATIC_TEMPLATE_ROLE(si) \
                            ((si)->template_role)


#define EM_DECODER_STATIC_EXP_DST_ROLE(si, n) \
                            EM_DECODER_OPER_ROLE(((si)->explicit_dst) + (n))

#define EM_DECODER_STATIC_EXP_DST_TYPE(si, n) \
                            EM_DECODER_OPER_TYPE(((si)->explicit_dst) + (n))

#define EM_DECODER_STATIC_EXP_DST_FLAGS(si, n) \
                            EM_DECODER_OPER_FLAGS(((si)->explicit_dst) + (n))

#define EM_DECODER_STATIC_EXP_SRC_ROLE(si, n) \
                            EM_DECODER_OPER_ROLE(((si)->explicit_src) + (n))

#define EM_DECODER_STATIC_EXP_SRC_TYPE(si, n) \
                            EM_DECODER_OPER_TYPE(((si)->explicit_src) + (n))

#define EM_DECODER_STATIC_EXP_SRC_FLAGS(si, n) \
                            EM_DECODER_OPER_FLAGS(((si)->explicit_src) + (n))


#define EM_DECODER_STATIC_IMP_DST(si, n) \
                            ((si)->implicit_dst[(n)])

#define EM_DECODER_STATIC_IMP_SRC(si, n) \
                            ((si)->implicit_src[(n)])


#define EM_DECODER_STATIC_CMP_TYPE(si) \
                            EM_DECODER_MODIFIERS_CMP_TYPE(&((si)->modifiers))

#define EM_DECODER_STATIC_CMP_REL(si) \
                            EM_DECODER_MODIFIERS_CMP_REL(&((si)->modifiers))

#define EM_DECODER_STATIC_BRANCH_TYPE(si) \
                            EM_DECODER_MODIFIERS_BRANCH_TYPE(&((si)->modifiers))

#define EM_DECODER_STATIC_BRANCH_HINT(si) \
                            EM_DECODER_MODIFIERS_BRANCH_HINT(&((si)->modifiers))

#define EM_DECODER_STATIC_FP_PRECISION(si) \
                            EM_DECODER_MODIFIERS_FP_PRECISION(&((si)->modifiers))

#define EM_DECODER_STATIC_FP_STATUS(si) \
                            EM_DECODER_MODIFIERS_FP_STATUS(&((si)->modifiers))

#define EM_DECODER_STATIC_MEMORY_ACCESS_HINT(si) \
                            EM_DECODER_MODIFIERS_MEMORY_ACCESS_HINT(&((si)->modifiers))


#define EM_DECODER_STATIC_FLAGS(si) \
                            ((si)->flags)

#define EM_DECODER_STATIC_FLAG_PRED(si) \
                            EM_DECODER_FLAGS_FLAG_PRED((si)->flags)

#define EM_DECODER_STATIC_FLAG_PRIVILEGED(si) \
                            EM_DECODER_FLAGS_FLAG_PRIVILEGED((si)->flags)

#define EM_DECODER_STATIC_FLAG_LMEM(si) \
                            EM_DECODER_FLAGS_FLAG_LMEM((si)->flags)

#define EM_DECODER_STATIC_FLAG_SMEM(si) \
                            EM_DECODER_FLAGS_FLAG_SMEM((si)->flags)

#define EM_DECODER_STATIC_FLAG_CHECK_BASE_EQ_DST(si) \
                            EM_DECODER_FLAGS_FLAG_CHECK_BASE_EQ_DST((si)->flags)

#define EM_DECODER_STATIC_FLAG_SPECULATION(si) \
                            EM_DECODER_FLAGS_FLAG_SPECULATION((si)->flags)

#define EM_DECODER_STATIC_FLAG_POSTINCREMENT(si) \
                            EM_DECODER_FLAGS_FLAG_POSTINCREMENT((si)->flags)

#define EM_DECODER_STATIC_FLAG_FALSE_PRED_EXEC(si) \
                            EM_DECODER_FLAGS_FLAG_FALSE_PRED_EXEC((si)->flags)

#define EM_DECODER_STATIC_FLAG_BR_HINT(si) \
                            EM_DECODER_FLAGS_FLAG_BR_HINT((si)->flags)

#define EM_DECODER_STATIC_FLAG_BR(si) \
                            EM_DECODER_FLAGS_FLAG_BR((si)->flags)

#define EM_DECODER_STATIC_FLAG_GROUP_FIRST(si) \
                            EM_DECODER_FLAGS_FLAG_GROUP_FIRST((si)->flags)

#define EM_DECODER_STATIC_FLAG_GROUP_LAST(si) \
                            EM_DECODER_FLAGS_FLAG_GROUP_LAST((si)->flags)

#define EM_DECODER_STATIC_FLAG_CHECK_SAME_DSTS(si) \
                            EM_DECODER_FLAGS_FLAG_CHECK_SAME_DSTS((si)->flags)

#define EM_DECODER_STATIC_FLAG_CONTROL_TRANSFER(si) \
                            EM_DECODER_FLAGS_FLAG_CONTROL_TRANSFER((si)->flags)

#ifdef __cplusplus
}
#endif

#endif /*** EM_DECODER_H ***/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\frmt_mac.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef _FRMT_MAC_H_
#define _FRMT_MAC_H_

#include "decoder_priv.h"
#define PRED_SIZE EM_PREDICATE_BITS

#define GET_REG_VALUE(Value,Binary,Pos,Sz)                   \
{                                                            \
	int mask = (1<<(Sz))-1;                                  \
	U64 tmp64;                                               \
	IEL_SHR(tmp64,(Binary),(Pos));                           \
	(Value) = IEL_GETDW0(tmp64);                             \
	(Value) &= mask;                                         \
}

#define FILL_REG_INFO(Reg_type, Reg_name, Value, Max_value, Dec_oper, Err) \
{                                                                        \
	(Dec_oper).type = EM_DECODER_REGISTER;                               \
	(Dec_oper).reg_info.valid = 1;                                       \
	(Dec_oper).reg_info.value = (Value);                                 \
	(Dec_oper).reg_info.type = (Reg_type);                               \
	(Dec_oper).reg_info.name = (Reg_name)+(Value);                       \
                                                                         \
	if ((Value)>=(Max_value))                                            \
	{                                                                    \
		(Dec_oper).reg_info.valid = 0;                                   \
		if (!(Err))														 \
		   (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;               \
	}                                                                    \
}

#define CHECK_REG_VALUE_0(Value, Dec_oper, Err)                          \
{                                                                        \
    if ((Value) == 0)                                                    \
	{                                                                    \
		(Dec_oper).reg_info.valid = 0;	                                 \
		if (!(Err))                                                      \
		   (Err) = EM_DECODER_WRITE_TO_ZERO_REGISTER;                    \
	}                                                                    \
}

#define CHECK_FP_REG_VALUE_0_1(Value, Dec_oper, Err)                     \
{                                                                        \
    if (((Value) == 0) || ((Value) == 1))                                \
	{                                                                    \
		(Dec_oper).reg_info.valid = 0;	                                 \
		if (!(Err))                                                      \
		   (Err) = EM_DECODER_WRITE_TO_SPECIAL_FP_REGISTER;              \
	}                                                                    \
}

#define CHECK_DEST_AND_BASE(Dec_oper_dest, Dec_oper_base, Err)           \
{                                                                        \
	if ((Dec_oper_dest).reg_info.value ==                                \
		(Dec_oper_base).mem_info.mem_base.value)                         \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_BASE_EQUAL_DEST;                            \
}

#define CHECK_DEST_AND_DEST(Dec_info_p, Err)                             \
{                                                                        \
	if ((Dec_info_p)->dst1.reg_info.value ==                             \
		(Dec_info_p)->dst2.reg_info.value)                               \
	{                                                                    \
	   if (!(Err))														 \
		  (Err) = EM_DECODER_EQUAL_DESTS;                                \
	   if (EM_DECODER_CHECK_UNC_ILLEGAL_FAULT(Dec_info_p))               \
		  EM_DECODER_SET_UNC_ILLEGAL_FAULT(Dec_info_p);                  \
	}																	 \
}

#define CHECK_ODD_EVEN_DSTS(Dec_oper_dest1, Dec_oper_dest2, Err)        \
{                                                                       \
	int reg_val1 = (Dec_oper_dest1).reg_info.value;                     \
	int reg_val2 = (Dec_oper_dest2).reg_info.value;                     \
	if (((reg_val1<32)&& (reg_val2<32))||                               \
		((reg_val1>32)&& (reg_val2>32)))                                \
	  {                                                                 \
		  if (!((reg_val1^reg_val2)&1)) /* both even of odd */          \
		  {                                                             \
			  if (!(Err))                                               \
			    (Err) = EM_DECODER_ODD_EVEN_DESTS;                      \
		  }                                                             \
	  }                                                                 \
}

#define GET_SIMM_VALUE1(Value,Pos1,Sz1,Binary)                           \
{                                                                        \
	int mask = (1<<(Sz1))-1;                                             \
	int or_mask, is_neg,imm_size = (Sz1);                                \
	U64 tmp64;                                                           \
	IEL_SHR(tmp64,(Binary),((Pos1)+PRED_SIZE));                          \
	(Value) = IEL_GETDW0(tmp64);                                         \
	(Value) &= mask;                                                     \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_SIMM_VALUE2(Value,Pos1,Sz1,Pos2,Sz2,Binary)                  \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2);                          \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)));  \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_SIMM_VALUE_NP2(Value,Pos1,Sz1,Pos2,Sz2,Binary)               \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2);                          \
	U64 tmp64;                                                           \
	int tmp;                                                             \
    IEL_SHR(tmp64, Binary, Pos1);                                        \
    tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (tmp & mask1);                                             \
	IEL_SHR(tmp64, Binary, Pos2);                                        \
    tmp = IEL_GETDW0(tmp64);                                             \
    (Value) |= ((tmp & mask2)<<(Sz1));                                   \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_CMP4_UIMM_VALUE2(Value,Pos1,Sz1,Pos2,Sz2,Binary)             \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int or_mask, to_complete,imm_size = (Sz1)+(Sz2);                     \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)));  \
	to_complete = (Value)>>(imm_size-1);                                 \
	or_mask = to_complete * (((1<<(32-imm_size))-1)<<imm_size);          \
	(Value) |= or_mask;                                                  \
}

#define GET_CMP_UIMM_VALUE2(Value64,Pos1,Sz1,Pos2,Sz2,Binary)            \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int or_mask, to_complete,imm_size = (Sz1)+(Sz2);                     \
	U64 tmp64;                                                           \
	int tmp, val1, val2;                                                 \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	val1 = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)));     \
	to_complete = val1>>(imm_size-1);                                    \
	or_mask = to_complete * (((1<<(32-imm_size))-1)<<imm_size);          \
	val1 |= or_mask;                                                     \
	val2 = to_complete * (-1);                                           \
	IEL_CONVERT2((Value64),val1,val2);                                   \
}

#define GET_SIMM_VALUE3(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Binary)         \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2)+(Sz3);                    \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))));                  \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_SIMM_VALUE4(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Pos4,Sz4,Binary) \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int mask4 = (1<<(Sz4))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2)+(Sz3)+(Sz4);              \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))) |                  \
	           (((tmp>>(Pos4))&mask4)<<((Sz1)+(Sz2)+(Sz3))));            \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_SIMM_VALUE5(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Pos4,Sz4,       \
						Pos5,Sz5,Binary)                                 \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int mask4 = (1<<(Sz4))-1;                                            \
	int mask5 = (1<<(Sz5))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2)+(Sz3)+(Sz4)+(Sz5);        \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))) |                  \
	           (((tmp>>(Pos4))&mask4)<<((Sz1)+(Sz2)+(Sz3))) |            \
	           (((tmp>>(Pos5))&mask5)<<((Sz1)+(Sz2)+(Sz3)+(Sz4))));      \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}


#define GET_UIMM_VALUE_NP1(Value,Pos1,Sz1,Binary) \
           GET_UIMM_VALUE1((Value),((Pos1)-PRED_SIZE),(Sz1),(Binary))

#define GET_UIMM_VALUE_NP2(Value,Pos1,Sz1,Pos2,Sz2,Binary)               \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	U64 tmp64;                                                           \
	int tmp1,tmp2;                                                       \
	IEL_SHR(tmp64,(Binary),(Pos1));                                      \
	tmp1 = IEL_GETDW0(tmp64);                                            \
	IEL_SHR(tmp64,(Binary),(Pos2));                                      \
	tmp2 = IEL_GETDW0(tmp64);                                            \
	(Value) = (tmp1 & mask1) | ((tmp2 & mask2)<<(Sz1));                  \
}

#define GET_SIMM_VALUE_NP3(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Binary)      \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	U64 tmp64;                                                           \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2)+(Sz3);                    \
	int tmp1,tmp2,tmp3;                                                  \
	IEL_SHR(tmp64,(Binary),(Pos1));                                      \
	tmp1 = IEL_GETDW0(tmp64);                                            \
	IEL_SHR(tmp64,(Binary),(Pos2));                                      \
	tmp2 = IEL_GETDW0(tmp64);                                            \
	IEL_SHR(tmp64,(Binary),(Pos3));                                      \
	tmp3 = IEL_GETDW0(tmp64);                                            \
	(Value) = (tmp1 & mask1) | ((tmp2 & mask2)<<(Sz1)) |                 \
	          ((tmp3 & mask3)<<((Sz1)+(Sz2)));                           \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_UIMM_VALUE1(Value,Pos1,Sz1,Binary)                           \
{                                                                        \
	int mask = (1<<(Sz1))-1;                                             \
	U64 tmp64;                                                           \
	IEL_SHR(tmp64,(Binary),((Pos1)+PRED_SIZE));                          \
	(Value) = IEL_GETDW0(tmp64);                                         \
	(Value) &= mask;                                                     \
}

#define GET_UIMM_VALUE2(Value,Pos1,Sz1,Pos2,Sz2,Binary)                  \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)));  \
}

#define GET_UIMM_VALUE3(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Binary)         \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))));                  \
}

#define GET_UIMM_VALUE4(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Pos4,Sz4,Binary) \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int mask4 = (1<<(Sz4))-1;                                            \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))) |                  \
	           (((tmp>>(Pos4))&mask4)<<((Sz1)+(Sz2)+(Sz3))));            \
}
#define GET_UIMM_VALUE5(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Pos4,Sz4,       \
						Pos5,Sz5,Binary)                                 \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int mask4 = (1<<(Sz4))-1;                                            \
	int mask5 = (1<<(Sz5))-1;                                            \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))) |                  \
	           (((tmp>>(Pos4))&mask4)<<((Sz1)+(Sz2)+(Sz3))) |            \
	           (((tmp>>(Pos5))&mask5)<<((Sz1)+(Sz2)+(Sz3)+(Sz4))));      \
}

#define FILL_IMM_INFO(Imm_type, Value, Size, Dec_oper)                   \
{                                                                        \
	(Dec_oper).type = EM_DECODER_IMMEDIATE;                              \
	(Dec_oper).imm_info.imm_type = (Imm_type);                           \
	(Dec_oper).imm_info.size = (Size);                                   \
	if (((Imm_type)==EM_DECODER_IMM_SIGNED) && ((Value)<0))              \
	   IEL_CONVERT2((Dec_oper).imm_info.val64,(Value),0xffffffff);       \
	else                                                                 \
	   IEL_CONVERT2((Dec_oper).imm_info.val64,(Value),0);                \
}

#define FILL_LONG_IMM_INFO(Imm_type, Value64, Size, Dec_oper)            \
{                                                                        \
	(Dec_oper).type = EM_DECODER_IMMEDIATE;                              \
	(Dec_oper).imm_info.imm_type = (Imm_type);                           \
	(Dec_oper).imm_info.size = (Size);                                   \
	(Dec_oper).imm_info.val64 = (Value64);                               \
}

#define FILL_MEM_INFO(Value, Mem_size, Dec_oper, Err)                    \
{                                                                        \
	(Dec_oper).type = EM_DECODER_MEMORY;                                 \
	(Dec_oper).mem_info.mem_base.type = EM_DECODER_INT_REG;              \
	(Dec_oper).mem_info.mem_base.name = EM_DECODER_REG_R0+(Value);       \
	(Dec_oper).mem_info.mem_base.value = (Value);                        \
	(Dec_oper).mem_info.mem_base.valid = 1;                              \
	(Dec_oper).mem_info.size = (Mem_size);                               \
	                                                                     \
	if ((Value)>=EM_NUM_OF_GREGS)                                        \
	{                                                                    \
		(Dec_oper).mem_info.mem_base.valid = 0;                          \
		if (!(Err))														 \
		   (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;               \
	}                                                                    \
}

#define FILL_REGFILE_INFO(Reg_name, Value, Dec_oper, Err)                \
{                                                                        \
	(Dec_oper).type = EM_DECODER_REGFILE;                                \
	(Dec_oper).regfile_info.name = (Reg_name);                           \
	(Dec_oper).regfile_info.index.valid = 1;                             \
	(Dec_oper).regfile_info.index.type  = EM_DECODER_INT_REG;            \
	(Dec_oper).regfile_info.index.name  = EM_DECODER_REG_R0+(Value);     \
	(Dec_oper).regfile_info.index.value = (Value);                       \
                                                                         \
	if ((Value)>=EM_NUM_OF_GREGS)                                        \
	{                                                                    \
		(Dec_oper).regfile_info.index.valid = 0;                         \
		if (!(Err))														 \
		   (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;               \
	}                                                                    \
}

#define FILL_LONG_IPREL_INFO(Value64, Size, Dec_oper)                        \
{                                                                            \
        (Dec_oper).type = EM_DECODER_IP_RELATIVE;                            \
        (Dec_oper).imm_info.size = (Size);                                   \
        (Dec_oper).imm_info.val64 = (Value64);	  	 		     \
}

#define FILL_IPREL_INFO(Value, Size, Dec_oper)                           \
{                                                                        \
	(Dec_oper).type = EM_DECODER_IP_RELATIVE;                            \
	(Dec_oper).imm_info.size = (Size);                                   \
	if ((Value)<0)									                     \
	{                                                                    \
		IEL_CONVERT2((Dec_oper).imm_info.val64,(Value),0xffffffff);      \
	}                                                                    \
	else                                                                 \
	{                                                                    \
		IEL_CONVERT2((Dec_oper).imm_info.val64,(Value),0);               \
	}                                                                    \
}

#define CHECK_REG_CR(Value, Dec_oper, Err)                               \
{                                                                        \
	if (EM_CREG_IS_RESERVED(Value))                                      \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_RESERVED_VALUE;                    \
	}                                                                    \
}


#define CHECK_REG_APP_GRP_HIGH(Value, Dec_oper, Err)                     \
{                                                                        \
	if (!EM_APP_REG_IS_I_ROLE(Value))                                    \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;                \
	}                                                                    \
	else if (EM_APP_REG_IS_RESERVED(Value))                              \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_RESERVED_VALUE;                    \
    }                                                                    \
}

#define CHECK_REG_APP_GRP_LOW(Value, Dec_oper, Err)                      \
{                                                                        \
	if (EM_APP_REG_IS_I_ROLE(Value))                                     \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;                \
	}                                                                    \
	else if (EM_APP_REG_IS_RESERVED(Value))                              \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_RESERVED_VALUE;                    \
	}                                                                    \
}

#define CHECK_IMM_COUNT_123(Value, Err)                                  \
{                                                                        \
	if (((Value)<1)||((Value)>3))                                        \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_IMMEDIATE_VALUE_OUT_OF_RANGE;               \
}

#define CHECK_IMM_COUNT_1234(Value, Err)                                 \
{                                                                        \
	if (((Value)<1)||((Value)>4))                                        \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_IMMEDIATE_VALUE_OUT_OF_RANGE;               \
}

#define CHECK_IMM_COUNT_PACK(Value, Err)                                 \
{                                                                        \
	if (((Value)!=0)&&((Value)!=7)&&((Value)!=15)&&((Value)!=16))        \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_IMMEDIATE_INVALID_VALUE;                    \
}

#define CHECK_IMM_MUX1(Value, Err)                                       \
{                                                                        \
    switch(Value)                                                        \
	{                                                                    \
		case EM_MUX_BRCST:                                               \
		case EM_MUX_MIX:                                                 \
		case EM_MUX_SHUF:                                                \
		case EM_MUX_ALT:                                                 \
		case EM_MUX_REV:                                                 \
		   break;                                                        \
		default:                                                         \
		   (Err) = EM_DECODER_IMMEDIATE_INVALID_VALUE;                   \
	}                                                                    \
}

#define CONVERT_IMM_SEMAPHORE_INC(Value, Err)                            \
{                                                                        \
    switch (Value)                                                       \
	{                                                                    \
	   case 0:                                                           \
	     Value = 16;                                                     \
		 break;                                                          \
	   case 1:                                                           \
		 Value = 8;                                                      \
		 break;                                                          \
	   case 2:                                                           \
		 Value = 4;                                                      \
		 break;                                                          \
	   case 3:                                                           \
		 Value = 1;                                                      \
		 break;                                                          \
	   case (-4):                                                        \
		 Value = -16;                                                    \
		 break;                                                          \
	   case (-3):                                                        \
		 Value = -8;                                                     \
		 break;                                                          \
	   case (-2):                                                        \
		 Value = -4;                                                     \
		 break;                                                          \
	   case (-1):                                                        \
		 Value = -1;                                                     \
		 break;                                                          \
	   default:                                                          \
	     if (!(Err))												     \
		    (Err) = EM_DECODER_IMMEDIATE_INVALID_VALUE;                  \
	}	                                                                 \
}

#define CONVERT_IMM_COUNT_PACK(Value)                                    \
{                                                                        \
	switch(Value)                                                        \
	{                                                                    \
	  case (0):                                                          \
		break;                                                           \
	  case (1):                                                          \
		(Value) = 7;                                                     \
		break;                                                           \
	  case (2):                                                          \
		(Value) = 15;                                                    \
		break;                                                           \
	  case (3):                                                          \
		(Value) = 16;                                                    \
		break;                                                           \
	}                                                                    \
}

#define GET_UIMM64_VALUE1(Value64,Start,Pos1,Sz1,Bin128)                 \
{																		 \
	U128 tmp128; 													     \
	U64 mask;															 \
	IEL_CONVERT2(mask, 1, 0);										     \
	IEL_SHL(mask, mask, (Sz1));										     \
	IEL_DECU(mask);													     \
    IEL_SHR(tmp128,(Bin128),(5+41)+(Pos1));	                             \
    IEL_AND(tmp128, tmp128, mask);                                       \
    IEL_SHL(tmp128,tmp128,(Start));                      	             \
    IEL_OR((Value64),(Value64),tmp128);                                  \
}

#define GET_UIMM_2_U64_VALUE1(Value64,Start,Pos1,Sz1,Binary)		     \
{							    									     \
	int mask = (1<<(Sz1))-1;                                             \
	unsigned int Value;												     \
        U64 tmp64;                                                       \
        IEL_SHR(tmp64,(Binary),((Pos1)+PRED_SIZE));                      \
        (Value) = IEL_GETDW0(tmp64);                                     \
        (Value) &= mask;                          					     \
	IEL_CONVERT2(tmp64, Value, 0);										 \
	IEL_SHL(tmp64, tmp64, (Start));										 \
	IEL_OR((Value64), (Value64), tmp64);			  					 \
}

#define GET_UIMM64_VALUE6_1(Value64, Pos1, Sz1, Pos2, Sz2, Pos3, Sz3,    \
						  Pos4, Sz4, Pos5, Sz5, Pos6, Sz6, Bin128)       \
{                                                                        \
	U128 tmp128;                                                         \
	U64  mask;                                                           \
	IEL_SHR(tmp128,Bin128,(5+41));                                       \
	IEL_CONVERT2(mask, 0xffffffff,0x1ff);                                \
	IEL_AND(tmp128, tmp128, mask);                                       \
	IEL_SHL(tmp128,tmp128,((Sz1)+(Sz2)+(Sz3)+(Sz4)));                    \
	IEL_OR((Value64),(Value64),tmp128);                                  \
                                                                         \
}

#define GET_UIMM64_VALUE6_2(Value64, Pos1, Sz1, Pos2, Sz2, Pos3, Sz3,    \
						  Pos4, Sz4, Pos5, Sz5, Pos6, Sz6, Bin128)       \
{                                                                        \
	U128 tmp128;                                                         \
	U64  mask;                                                           \
	IEL_SHR(tmp128,Bin128,((Pos6)+5+41+41));                             \
	IEL_CONVERT2(mask, 1,0);                                             \
	IEL_AND(tmp128, tmp128, mask);                                       \
	IEL_SHL(tmp128,tmp128,((Sz1)+(Sz2)+(Sz3)+(Sz4)+(Sz5)));              \
	IEL_OR((Value64),(Value64),tmp128);                                  \
}	

#define SET_2ND_ROLE_TO_DEST(Dec_oper)  \
               ((Dec_oper).oper_flags |= EM_DECODER_OPER_2ND_ROLE_DST_BIT)

#define SET_2ND_ROLE_TO_SRC(Dec_oper)  \
               ((Dec_oper).oper_flags |= EM_DECODER_OPER_2ND_ROLE_SRC_BIT)


#define GET_PREDICATE_HARD_CODED_VALUE(Value,Binary) \
		   GET_UIMM_VALUE1((Value),((EM_PREDICATE_POS)-PRED_SIZE),(PRED_SIZE),(Binary))
									   
#define CHECK_PREDICATE_HARD_CODED(Value, HC_Value, Err)             \
{                                                                    \
    if ((Value) != (HC_Value))                                       \
	{                                                                \
		if (!(Err))                                                  \
		   (Err) = EM_DECODER_HARD_CODED_PREDICATE_INVALID_VALUE;    \
	}                                                                \
}


#define GET_FIELD_HARD_CODED_VALUE(Value,Pos,Sz,Binary)              \
		   GET_UIMM_VALUE1((Value),((Pos)-PRED_SIZE),(Sz),(Binary))

#define CHECK_FIELD_HARD_CODED(Value, HC_Value, Err)                 \
{                                                                    \
    if ((Value) != (HC_Value))                                       \
	{                                                                \
		if (!(Err))                                                  \
		   (Err) = EM_DECODER_HARD_CODED_FIELD_INVALID_VALUE;        \
	}                                                                \
}


#endif /* FRMT_MAC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\decoder_priv.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


/*****************************************************************************/
/* decoder_priv.h                                                            */
/*****************************************************************************/

#ifndef _DECODER_PRIV_H_
#define _DECODER_PRIV_H_

#define EM_DECODER_MAX_CLIENTS     20

#define DEFAULT_MACHINE_TYPE    EM_DECODER_CPU_P7
#define DEFAULT_MACHINE_MODE    EM_DECODER_MODE_EM


typedef struct
{
    int                      is_used;
    EM_Decoder_Machine_Type  machine_type;
    EM_Decoder_Machine_Mode  machine_mode;
    void **                  info_ptr;     /*** after dynamic allocation,     ***/
                                           /*** info_ptr points to an array   ***/
                                           /*** of pointers. The i'th pointer ***/
                                           /*** in the array is a ptr to the  ***/
                                           /*** client info.                  ***/
	unsigned long            flags;
} Client_Entry;

Client_Entry   em_clients_table[EM_DECODER_MAX_CLIENTS];

#define FILL_PREDICATE_INFO(Inst_code, Dinfo_p)                          \
{                                                                        \
    int pred_no = (IEL_GETDW0(Inst_code) >> EM_PREDICATE_POS) &          \
                  ((1 << EM_PREDICATE_BITS)-1);                          \
    Dinfo_p->pred.valid = TRUE;                                          \
    Dinfo_p->pred.value = pred_no;                                       \
    Dinfo_p->pred.type = EM_DECODER_PRED_REG;                            \
    Dinfo_p->pred.name = EM_DECODER_REG_P0 + pred_no;                    \
}

#define GET_BRANCH_BEHAVIOUR_BIT(Inst_code,Bit)                          \
{                                                                        \
	unsigned int tmp;                                                    \
	U64 tmp64;                                                           \
	IEL_SHR(tmp64,(Inst_code),BRANCH_BEHAVIOUR_BIT);                  \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Bit) = tmp & 1;                                                     \
}

#define EM_DECODER_SET_UNC_ILLEGAL_FAULT(di)  ((di)->flags |= EM_DECODER_BIT_UNC_ILLEGAL_FAULT)



/*** Static variables initialization ***/

static const char em_ver_string[] = VER_STR;  /*** initialized by Makefile ***/
static const char *em_err_msg[EM_DECODER_LAST_ERROR] =
{
	"",
	"EM_DECODER_INVALID_SLOT_BRANCH_INST: Instruction must be in the last slot of the current bundle",
	"EM_DECODER_MUST_BE_GROUP_LAST: Instruction must be the last in instruction group",
	"EM_DECODER_BASE_EQUAL_DEST: Source and destination operands have the same value",
	"EM_DECODER_EQUAL_DESTS: Two destination operands have the same value",
	"EM_DECODER_ODD_EVEN_DESTS: Both destination floating-point registers have odd or even values",
	"EM_DECODER_WRITE_TO_ZERO_REGISTER: Destination general register r0 is invalid",
	"EM_DECODER_WRITE_TO_SPECIAL_FP_REGISTER: Destination floating point register is f0 or f1",
	"EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE: Register value is out of permitted range",
	"EM_DECODER_REGISTER_RESERVED_VALUE: Register operand value is reserved",
	"EM_DECODER_IMMEDIATE_VALUE_OUT_OF_RANGE: Immediate operand value is out of permitted range",
	"EM_DECODER_IMMEDIATE_INVALID_VALUE: Invalid immediate operand value",
	"EM_DECODER_STACK_FRAME_SIZE_OUT_OF_RANGE: Stack frame size is larger than maximum permitted value", 
	"EM_DECODER_LOCALS_SIZE_LARGER_STACK_FRAME: Size of locals is larger than the stack frame",
	"EM_DECODER_ROTATING_SIZE_LARGER_STACK_FRAME: Size of rotating region is larger than the stack frame",
	"EM_DECODER_HARD_CODED_PREDICATE_INVALID_VALUE: Invalid hard-coded predicate value",
	"EM_DECODER_INVALID_PRM_OPCODE: Instruction contains an invalid opcode",
	"EM_DECODER_INVALID_INST_SLOT: Instruction slot is invalid in current bundle",
	"EM_DECODER_INVALID_TEMPLATE: Invalid template is specified",
	"EM_DECODER_INVALID_CLIENT_ID: Invalid client id",
	"EM_DECODER_NULL_PTR: A null pointer was specified in call",
	"EM_DECODER_TOO_SHORT_ERR: Instruction buffer is too short for instruction",
	"EM_DECODER_ASSOCIATE_MISS: There is an unassociated instruction",
	"EM_DECODER_INVALID_INST_ID: Invalid instruction id",
	"EM_DECODER_INVALID_MACHINE_MODE: Invalid machine mode",
	"EM_DECODER_INVALID_MACHINE_TYPE: Invalid machine type",
	"EM_DECODER_INTERNAL_ERROR: Internal data-base collisions"};


typedef enum
{
    BEHAVIOUR_UNDEF = 0,
    BEHAVIOUR_IGNORE_ON_FALSE_QP,
    BEHAVIOUR_FAULT
}Behaviour_ill_opcode;

static const Behaviour_ill_opcode branch_ill_opcode[]=
{
    /* 0*/ BEHAVIOUR_UNDEF,
    /* 1*/ BEHAVIOUR_FAULT,
    /* 2*/ BEHAVIOUR_IGNORE_ON_FALSE_QP,
    /* 3*/ BEHAVIOUR_IGNORE_ON_FALSE_QP,
    /* 4*/ BEHAVIOUR_FAULT,
    /* 5*/ BEHAVIOUR_FAULT,
    /* 6*/ BEHAVIOUR_IGNORE_ON_FALSE_QP,
    /* 7*/ BEHAVIOUR_IGNORE_ON_FALSE_QP,
    /* 8*/ BEHAVIOUR_FAULT,
    /* 9*/ BEHAVIOUR_FAULT,
    /* a*/ BEHAVIOUR_FAULT,
    /* b*/ BEHAVIOUR_FAULT,
    /* c*/ BEHAVIOUR_FAULT,
    /* d*/ BEHAVIOUR_FAULT,
    /* e*/ BEHAVIOUR_FAULT,
    /* f*/ BEHAVIOUR_FAULT
};

#define PRED_BEHAVIOUR(trole, maj_op, behav)             \
{                                                        \
    switch(trole)                                        \
    {                                                    \
        case(EM_TEMP_ROLE_MEM):                          \
        case(EM_TEMP_ROLE_INT):                          \
        case(EM_TEMP_ROLE_LONG):                         \
        case(EM_TEMP_ROLE_FP):                           \
            (behav) = BEHAVIOUR_IGNORE_ON_FALSE_QP;      \
            break;                                       \
        case(EM_TEMP_ROLE_BR):                           \
            (behav) = branch_ill_opcode[(maj_op)];       \
            break;                                       \
        default:                                         \
            (behav) = BEHAVIOUR_FAULT;                   \
    }                                                    \
}

/* this bit is crtical for machine behaviour within
   illegal branch instruction with major opcode 0 */
#define BRANCH_BEHAVIOUR_BIT 32

#endif /* _DECODER_PRIV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\build\dec_priv_col.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef DEC_PRIV_COL_H
#define DEC_PRIV_COL_H
#include "decem.h"
#include "func.h"
typedef unsigned int Mem_size_t;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\makefile.inc ===
!include ..\makefile.inc

COMMON_HEADERS = emdb_types.h EM.h EM_tools.h iel.h EM_hints.h inst_ids.h
EMDB_SOURCES = $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
               $(EMDBDIR)\dec_private.perl $(EMDBDIR)\emdb_formats.txt \
               $(IA64_DIS_INC)\EM_perl.h

EM_BUILDIR = .\build
PERL_INCLIST = $(PERL_INCLIST) -I $(EM_BUILDIR) -I $O
INCLUDES = $(INCLUDES);$(EM_BUILDIR)

$(IA64_DIS_INC)\decem.h : decoder.h
        copy decoder.h $(IA64_DIS_INC)\decem.h

$O\frmt_func.c : $(EM_BUILDIR)/func_build_1.pl \
                 $(EM_BUILDIR)/func_build_2.pl $(EMDB_SOURCES) \
                 $O\deccpu_emdb.h $O\inst_ids.h
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\func_build_1.pl $O $(EMDBDIR)
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\func_build_2.pl $O $(EMDBDIR)

$O\deccpu_emdb.c $O\deccpu_emdb.h : $(EMDB_SOURCES) $O\decoder.txt
        $(PERL) $(EMDBDIR)\emdb_cut.pl -emdb_path $(EMDBDIR) -dir $O \
            -columns $O\decoder.txt \
            -fields inst_id,extensions,format,template_role,ops,flags,mem_size,dec_flags,impls \
            -include $(EM_BUILDIR)\dec_priv_col.h -prefix deccpu

$O\dec_emdb.tab: $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
            $(EM_BUILDIR)\dec_priv_col.h
	echo "building dec_emdb.tab"
        $(PERL) $(EMDBDIR)\emdb_cut.pl -table -emdb_path $(EMDBDIR) -dir $O \
            -fields inst_id,format,major_opcode,template_role -prefix dec


###ign_inst.txt must be the last in '-row' sequence 

$O\dec_ign_emdb.tab: $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
            $O\ign_inst.txt $(EM_BUILDIR)\dec_priv_col.h
	echo "building dec_ign_emdb.tab"
        $(PERL) $(EMDBDIR)\emdb_cut.pl -rows $O\ign_inst.txt \
            -table -emdb_path $(EMDBDIR) -dir $O \
            -fields inst_id,format,major_opcode,template_role \
            -prefix dec_ign

$O\inst_ign_ids.h $O\ign_inst.txt: $(EMDBDIR)\emdb.txt \
            $(EMDBDIR)\emdb_formats.txt $(EM_BUILDIR)\build_ignored_flds.pl
	$(PERL) $(PERL_INCLIST) \
            $(EM_BUILDIR)\build_ignored_flds.pl $O $(EMDBDIR)

$O\inst_emdb.tab: $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
            $(EM_BUILDIR)\dec_priv_col.h
        $(PERL) $(EMDBDIR)\emdb_cut.pl -table -emdb_path $(EMDBDIR) \
            -dir $O -fields inst_id -prefix inst

$O\builder_info.c $O\builder_info.h: $(EMDBDIR)\emdb_formats.txt \
            $(EM_BUILDIR)\tree_builder.perl $O\dec_ign_emdb.tab \
            $(IA64_DIS_INC)\EM_perl.h
	echo "building builder_info.c"
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\tree_builder.perl $O $(EMDBDIR)

$O\decfn_emdb.c: $O\deccpu_emdb.c $O\deccpu_emdb.h \
            $(EM_BUILDIR)\func_build_1.pl \
            $(EM_BUILDIR)\hard_coded_fields_h.perl 
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\func_build_1.pl $O $(EMDBDIR)

$O\dec_static.c: $O\dec1_emdb.c $O\dec1_emdb.h \
            $(EM_BUILDIR)\build_static_info.pl $(IA64_DIS_INC)\EM_perl.h
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\build_static_info.pl $O $(EMDBDIR)


###ign_inst.txt must be the last in '-row' sequence

$O\dec_ign_emdb.c $O\dec_ign_emdb.h : $O\ign_inst.txt \
            $(EMDB_SOURCES)
        $(PERL) $(EMDBDIR)\emdb_cut.pl -emdb_path $(EMDBDIR) -dir $O \
             -rows $O\ign_inst.txt \
             -fields inst_id,extensions,format,template_role,ops,flags \
             -include $(EM_BUILDIR)\dec_priv_col.h -prefix dec_ign
        $(PERL) -p -i.bak -e "s/_IGN\d+// if ( /\s*\{EM_\S*\_IGN\d+,/)" \
            $O\dec_ign_emdb.c	

$O\dec1_emdb.c $O\dec1_emdb.h : $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
            $O\decoder.txt $(EMDBDIR)\dec_stat.txt 
        $(PERL) $(EMDBDIR)\emdb_cut.pl -emdb_path $(EMDBDIR) -dir $O -columns \
            $O\decoder.txt,$(EMDBDIR)\dec_stat.txt -fields\
mnemonic,dec_flags,template_role,ops,modifiers,flags,specul_flag,false_pred_flag,imp_dsts,imp_srcs,br_hint_flag,br_flag,adv_load_flag,control_transfer_flag \
            -prefix dec1

$(IA64_DIS_INC)\EM_hints.h: $O\EM_hints.h
        copy $O\EM_hints.h $(IA64_DIS_INC)\EM_hints.h

$(IA64_DIS_INC)\inst_ids.h: $O\inst_ids.h
        copy $O\inst_ids.h $(IA64_DIS_INC)\inst_ids.h

$O\inst_ids.h: $O\inst_emdb.tab $(EM_BUILDIR)\inst_id.perl \
            ..\copyright\external\c_file
	$(PERL) $(EM_BUILDIR)\inst_id.perl $O $(EMDBDIR)

$O\all_emdb.tab: $(EMDBDIR)\emdb.txt
        $(PERL) $(EMDBDIR)\emdb_cut.pl -table -emdb_path $(EMDBDIR) -dir $O \
             -fields inst_id,mnemonic -prefix all

$O\decoder.txt $O\EM_hints.h: $O\all_emdb.tab $(EMDBDIR)\emdb_cut.pl
	$(PERL) $(EMDBDIR)\dec_private.perl $O $(EMDBDIR)

!if "$(GENERATE_DECISION_TREE)" == ""

$O\decision_tree.c: decision_tree.c
	copy decision_tree.c $O

!else

$O\tree_builder.h : $(EM_BUILDIR)\tree_builder.c 
	echo "building tree_builder.h"
	$(MHDR) $O\tree_builder.h $(EM_BUILDIR)\tree_builder.c

$O\decision_tree.c: $O\tree_builder$(EEXT)
	"$O\tree_builder$(EEXT)" $O\decision_tree.c

$O\builder_info.obj: $O\builder_info.c

$O\dec_ign_emdb.obj: $O\dec_ign_emdb.c

$O\tree_builder.c: $(EM_BUILDIR)\tree_builder.c
        copy $(EM_BUILDIR)\tree_builder.c $O
        
$O\tree_builder.obj: $O\tree_builder.c

$O\tree_builder$(EEXT): $(EM_BUILDIR)\tree.h $O\tree_builder.h \
            $O\inst_ids.h $O\inst_ign_ids.h \
            $O\builder_info.obj $O\dec_ign_emdb.obj $O\tree_builder.obj
        $(LINKER) @<<
$(LINKER_FLAGS: =
)
-subsystem:console
$O\builder_info.obj
$O\dec_ign_emdb.obj
$O\tree_builder.obj
..\iel\$O\iel.lib
$(CRTLIBS)
$(UMLIBS)
$(LINKLIBS)
<<NOKEEP

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\build\decision_tree.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef _DECISION_TREE_H
#define _DECISION_TREE_H

typedef enum
{
	EM_TEMP_ROLE_NONE = 0,
	EM_TEMP_ROLE_INT = EM_TEMP_ROLE_NONE,
	EM_TEMP_ROLE_MEM,
	EM_TEMP_ROLE_FP,
	EM_TEMP_ROLE_BR,
	EM_TEMP_ROLE_LONG,
	EM_TEMP_ROLE_LAST
} Temp_role_t;

typedef struct Node_s
{
	unsigned short next_node;
	char pos;
	char size;
} Node_t;

#define GET_NODE_POS(node) \
        ((node).pos)

#define GET_NODE_SIZE(node) \
        ((node).size)

#define GET_NEXT_NODE_INDEX(node) \
        ((node).next_node)

#define SQUARE(opcode, template_role) \
        (((opcode) * EM_TEMP_ROLE_LAST) + (template_role))

#define NODE_IS_LEAF(node) \
        ((unsigned char)((node).pos) == 0xff)

extern Node_t em_decision_tree[];

#endif /*_DECISION_TREE_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\build\tree.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef _TREE_H
#define _TREE_H

#include "inst_ids.h"

/* 41 bit instruction minus qp(6 bits) and major opcode(4 bits) */
#define EXTENSION_SIZE 31

typedef struct Internal_node_s
{
	int next_node;
	int pos;
	int size;
} Internal_node_t;

typedef enum
{
	EM_TEMP_ROLE_NONE = 0,
	EM_TEMP_ROLE_INT = EM_TEMP_ROLE_NONE,
	EM_TEMP_ROLE_MEM,
	EM_TEMP_ROLE_FP,
	EM_TEMP_ROLE_BR,
	EM_TEMP_ROLE_LAST
} Temp_role_t;

#define SQUARE(opcode, template_role) \
        (((opcode) * EM_TEMP_ROLE_LAST) + (template_role));

#endif /*_TREE_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\decem\build\tree_builder.c ===
/***                                                                                 ***/
/***   INTEL CORPORATION PROPRIETARY INFORMATION                                     ***/
/***                                                                                 ***/
/***   This software is supplied under the terms of a license                        ***/
/***   agreement or nondisclosure agreement with Intel Corporation                   ***/
/***   and may not be copied or disclosed except in accordance with                  ***/
/***   the terms of that agreement.                                                  ***/
/***   Copyright (c) 1992,1993,1994,1995,1996,1997,1998,1999,2000 Intel Corporation. ***/
/***                                                                                 ***/


/* tree_builder.c */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "builder_info.h"
#include "tree_builder.h"
#include "tree.h"
#include "deccpu_emdb.h"
#include "dec_ign_emdb.h"

#define FUNC
#define START_BIT 6     /* start bit of extension calculations, after qp */
#define MAX_NODES 10000  /* empirical desicion of tree size */ 

unsigned int next_free_node = 0; /* global variable, which points to the next
									free node at all times. At the end of
									build_tree(), it holds the number of
									entries in the tree */
U64 ONE64 = IEL_CONST64(1, 0);

U64 emdb_ext_values[DEC_IGN_NUM_INST];
short cover_emdb_lines[DEC_IGN_NUM_INST];
Internal_node_t tree[MAX_NODES];  /* change this when number is known */

/***********************************************************************
  main - this function calculates the value of the extensions for each
  emdb line, builds the decision tree, and prints em_decision_tree
  in decision_tree.c.
***********************************************************************/

FUNC void __cdecl main(int argc, char** argv)
{
	init_arrays();

	build_tree();

	/*** check emdb line coverage ***/
	check_coverage();
	print_tree(argv[1]);
	
	exit(0);
}

/***********************************************************************
  init_arrays - this function calculates the value of the
  extensions for each emdb line, that is, it creates a bit pattern which
  represents the encoding of the extensions of an emdb line.
***********************************************************************/
FUNC void init_arrays()
{
	U64 value, ext_val;
	int i, pos;
	Inst_id_t emdb_entry;
	Format_t format;

	/*** calculate emdb lines extensions ***/
	IEL_ZERO(emdb_ext_values[0]); /* illop */
	for (emdb_entry = EM_INST_NONE+1; emdb_entry < EM_INST_NONE+DEC_IGN_NUM_INST;
		 emdb_entry++)
	{
		format = dec_ign_EMDB_info[emdb_entry].format;
		IEL_ZERO(value);
		for (i = 0; i < MAX_NUM_OF_EXT; i++)
		{
			pos = format_extensions[format][i].pos;
			IEL_CONVERT2(ext_val, dec_ign_EMDB_info[emdb_entry].extensions[i], 0);
			IEL_SHL(ext_val, ext_val, pos);
			IEL_OR(value, value, ext_val);
		}
		IEL_ASSIGNU(emdb_ext_values[emdb_entry], value);
	}

	/*** init cover_emdb_lines[] ***/
	for (emdb_entry = EM_INST_NONE+1; emdb_entry < EM_INST_NONE+DEC_IGN_NUM_INST;
		 emdb_entry++)
	{
		cover_emdb_lines[emdb_entry] = 0;
	}
}

/***********************************************************************
  build_tree - builds the decision tree
***********************************************************************/
FUNC void build_tree()
{
	Square_t square;
	unsigned int cur_node = 0;
	
	next_free_node = cur_node + EM_SQUARE_LAST;
	
	for (square = EM_SQUARE_FIRST; square < EM_SQUARE_LAST; square++)
	{
		build_node(format_extension_masks,
					   square_emdb_lines[square], cur_node);
		cur_node++;
	}
}

/***********************************************************************
  build_node - input: array extension bit masks of each format
                      emdb lines list
					  currrent node
		       builds the current node, calls build_node recursively
			   for each son.
***********************************************************************/
FUNC void build_node(U64 *format_masks,
					 Inst_id_list_t emdb_lines, unsigned int cur_node)
{
	U64 emdb_values[MAX_EMDB_LINES];
	unsigned int i, j;
	U64 intersect, delete_bits;
	U64 intersect_mask = IEL_CONST64(0xffffffff, 0xffffffff);
	int pos, size, number_of_sons;
	unsigned int line_count;
	Format_t format;
	U64 new_format_masks[EM_FORMAT_LAST];
	Inst_id_list_t new_emdb_lines;

	/*** empty node - ILLOP ***/
	if (emdb_lines.num_of_lines == 0)
	{
		tree[cur_node].pos = tree[cur_node].size = -1;
		tree[cur_node].next_node = EM_ILLOP;
		return;
	}
	/*** one line in node - a single emdb entry ***/
	if (emdb_lines.num_of_lines == 1)
	{
		format = dec_ign_EMDB_info[emdb_lines.inst_ids[0]].format;
		if (IEL_ISZERO(format_masks[format]))
		{
			/* all extensions are cheked */
			tree[cur_node].pos = tree[cur_node].size = -1;
			tree[cur_node].next_node = dec_ign_EMDB_info[emdb_lines.inst_ids[0]].inst_id;
			cover_emdb_lines[tree[cur_node].next_node]++;
			return;
		}
		intersect_mask =   format_masks[format];
	}
	else
	{
		/*** this line is reached when there are more than one emdb lines
		  which participate in this node ***/
		/*** calculate intersecting extensions ***/
		for (i = 0; i < (unsigned int)emdb_lines.num_of_lines; i++)
		{
			format = dec_ign_EMDB_info[emdb_lines.inst_ids[i]].format;
			IEL_AND(intersect_mask, intersect_mask, format_masks[format]);
		}
	}

	find_largest_intersection(intersect_mask, &pos, &size);
	if (pos == -1)  /*** no intersection found ***/
	{
		fprintf(stderr, "no intersection in node %d\n", cur_node);
		exit(1);
	}

	/*** delete intersect mask bits from participating formats ***/
	for (i = EM_FORMAT_NONE; i < EM_FORMAT_LAST; i++)
	{
		IEL_ASSIGNU(new_format_masks[i], format_masks[i]);
	}

	/*** intersect = ((1 << size) -1) << pos; ***/
	IEL_SHL(intersect, ONE64, size);
	IEL_DECU(intersect);
	IEL_SHL(intersect, intersect, pos);
	
	IEL_NOT(delete_bits, intersect);
	for (i = 0; i < (unsigned int)emdb_lines.num_of_lines; i++)
	{
		format = dec_ign_EMDB_info[emdb_lines.inst_ids[i]].format;
		IEL_AND(new_format_masks[format], delete_bits, format_masks[format]);
	}

	/*** calculate values of participating emdb lines in intersection bits ***/
	build_emdb_values(emdb_values, emdb_lines, intersect, pos, size);
	
	/*** update current node ***/
	tree[cur_node].next_node = next_free_node;
	tree[cur_node].pos = pos;
	tree[cur_node].size = size;

	cur_node = next_free_node;
	if (next_free_node >= MAX_NODES)
	{
		fprintf (stderr, "tree is larger than %d\n", MAX_NODES);
		exit(1);
	}
	number_of_sons = (int)pow((double)2, (double)size);
	next_free_node += number_of_sons;

	/*** loop on each of the node's sons, build the tree recursively ***/
	for (i = 0; i < (unsigned int)number_of_sons; i++)
	{
		line_count = 0;
		new_emdb_lines.num_of_lines = 0;
		for (j = 0; j < (unsigned int)emdb_lines.num_of_lines; j++)
		{
			if (IEL_GETDW0(emdb_values[j]) == i && (!IEL_GETDW1(emdb_values[j])))
			            /*** emdb line has the value i ***/
			{
				new_emdb_lines.num_of_lines++;
				new_emdb_lines.inst_ids[line_count++] = emdb_lines.inst_ids[j];
			}
		}
		build_node(new_format_masks, new_emdb_lines, cur_node);
		cur_node++;
	}
}

/***********************************************************************
  build_emdb_values - input: - pointer to an array into which
                               calculated values of extensions
							   will be written.
							 - emdb lines list
							 - bit pattern in which to calculate values
							 - pos - start bit of pattern
				      calculates values of emdb lines in all bits which
					  are set in pattern
***********************************************************************/
FUNC void build_emdb_values(U64 *emdb_values,
							Inst_id_list_t emdb_lines,
							U64 pattern,
							int pos, int size)
{
	int i;
	U64 value;
/*	Format_t format;
	int j;
	char match;
	int new_pos, new_size;
*/
	for (i = 0; i < emdb_lines.num_of_lines; i++)
	{
		IEL_ASSIGNU(value, emdb_ext_values[emdb_lines.inst_ids[i]]);
		
		/*** emdb_values[i] = (value & pattern) >> pos; ***/
		IEL_AND(emdb_values[i], value, pattern);
		IEL_SHR(emdb_values[i], emdb_values[i], pos);
		

/*		format = dec_ign_EMDB_info[emdb_lines.inst_ids[i]].format;
		new_pos = pos+START_BIT;
		new_size = size;
		match = 0;
		for (j = MAX_NUM_OF_EXT-1; j >= 0; j--)
		{
			if (format_extensions[format][j].pos == new_pos)
			{
				if (format_extensions[format][j].size == new_size)
				{
					match = 1;
				}
				else if (format_extensions[format][j].size > new_size)
				{
					fprintf(stderr,
							"the intersection of emdb line %d is not full\n",
							emdb_lines.inst_ids[i]);
					exit(1);
				}
				else
				{
					new_pos += format_extensions[format][j].size;
					new_size -= format_extensions[format][j].size;
				}
			}
		}
		if (!match)
		{
			fprintf(stderr,
					"the intersection of emdb line %d is not full\n",
					emdb_lines.inst_ids[i]);
			exit(1);
		}
		*/
	}
}

/***********************************************************************
  find_largest_intersection - fast algorithm for finding largest group of
                              consecutive set bits in pattern.
							  (Yigal's algorithm)
***********************************************************************/
FUNC void find_largest_intersection(U64 pattern, int *pos, int *size)
{
	U64 x;
	U64 y, z, u;

	IEL_ASSIGNU(x, pattern);
	*size = 0;     /* largest intersection counter */
	IEL_SHR(y, x, 1);
	IEL_NOT(z, x); /* negation of the input pattern */
	IEL_OR(y, y, z); /* y - mask */

	while (!IEL_ISZERO(x))
	{
		IEL_ASSIGNU(u, x); /* for saving the last bit pattern */
		IEL_AND(x, x, y);
		IEL_SHR(y, y, 1);  /* shift right mask */
		(*size)++;
	}

	/* inspect the high word for left most 1 */
	if (IEL_GETDW1(u) & 0xffe00000)  /* something in bits 21-31 */
	{
		*pos = 21 + LOG2[IEL_GETDW1(u) >> 21] + 32;
	}
	else if (IEL_GETDW1(u) & 0x1ffc00)  /* something in bits 10-20 */
	{
		*pos = 10 + LOG2[IEL_GETDW1(u) >> 10] + 32;
	}
	else if (IEL_GETDW1(u))
	{
		*pos = LOG2[IEL_GETDW1(u)] + 32;
	}
	/* inspect the low word for left most 1 */
	else if (IEL_GETDW0(u) & 0xffe00000)  /* something in bits 21-31 */
	{
		*pos = 21 + LOG2[IEL_GETDW0(u) >> 21];
	}
	else if (IEL_GETDW0(u) & 0x1ffc00)  /* something in bits 10-20 */
	{
		*pos = 10 + LOG2[IEL_GETDW0(u) >> 10];
	}
	else
	{
		*pos = LOG2[IEL_GETDW0(u)];
	}
}	

	

/***********************************************************************
  check_coverage - check coverage of emdb lines in the tree
***********************************************************************/
FUNC void check_coverage()
{
	Inst_id_t emdb_entry;

	for (emdb_entry = EM_INST_NONE+1; emdb_entry < DECCPU_NUM_INST; emdb_entry++)
	{
		if (cover_emdb_lines[emdb_entry] < 1)
		{
			fprintf(stderr, "%d doesn't appear in the tree\n",
					emdb_entry);
		}
	}
}

/***********************************************************************
  print_tree - prints the initialized em_decision_tree in decision_tree.c
***********************************************************************/
FUNC void print_tree(char* file)
{
	FILE *fd;
	int i;

	if ((fd = fopen(file, "w")) == NULL)
	{
		fprintf(stderr, "Couldn't open decision_tree.c\n");
		exit(1);
	}

	fprintf(fd, "/*** decision_tree.c ***/\n\n#include \"decision_tree.h\"\n\n");

	fprintf(fd, "Node_t em_decision_tree[] = {\n");

	/*** traverse the tree ***/
	for (i = 0; i < (int)next_free_node; i++)
	{
		fprintf(fd, "/*%05d*/     {%d, %d, %d}", i, tree[i].next_node,
				tree[i].pos, tree[i].size);
		if (i != (int)next_free_node-1)
		{
			fprintf(fd, ",");
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "};\n");
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\iel\iel_ver.c ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


void IEL_VER (void); 
void IEL_VER () {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\include\emdb_types.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef EMDB_TYPES_H
#define EMDB_TYPES_H

/* Flags */
#define EM_FLAG_PRED   0x1
#define EM_FLAG_PRIVILEGED   0x2
#define EM_FLAG_LMEM   0x4
#define EM_FLAG_SMEM   0x8
#define EM_FLAG_CHECK_BASE_EQ_DST  0x10
#define EM_FLAG_FIRST_IN_INSTRUCTION_GROUP 0x20
#define EM_FLAG_LAST_IN_INSTRUCTION_GROUP 0x40
#define EM_FLAG_CHECK_SAME_DSTS 0x80
#define EM_FLAG_SLOT2_ONLY 0x100
#define EM_FLAG_TWO_SLOT 0x200
#define EM_FLAG_OK_IN_MLX 0x400
#define EM_FLAG_CHECK_EVEN_ODD_FREGS 0x800
#define EM_FLAG_CTYPE_UNC 0x1000            /* designates all cmp.unc like instructions */
#define EM_FLAG_UNUSED_HINT_ALIAS 0x02000
#define EM_FLAG_ILLEGAL_OP 0x04000
#define EM_FLAG_IGNORED_OP 0x08000
#define EM_FLAG_ENDS_INSTRUCTION_GROUP 0x10000
#define EMDB_LAST_FLAG EM_FLAG_ENDS_INSTRUCTION_GROUP


/* Implementations */

#define ArchRev0      0
#define Impl_Brl      0x100
#define Impl_Ipref    0x200
#define Impl_Itanium  0x400
#define Impl_McKinley 0x800


#define MAX_EXTENSION 8

typedef enum {
    EM_OPROLE_NONE = 0,
    EM_OPROLE_SRC,
    EM_OPROLE_DST,
    EM_OPROLE_SRC_DST,
    EM_OPROLE_DST_SRC,
    EM_OPROLE_LAST
} Operand_role_t;

typedef enum {
    EM_OPTYPE_NONE = 0,
    EM_OPTYPE_REG_FIRST,      /* The following types are registers */
    EM_OPTYPE_IREG,           /* Integer register */
    EM_OPTYPE_IREG_R0_3,      /* r0-r3 */
    EM_OPTYPE_IREG_R0,        /* Integer register R0 */
    EM_OPTYPE_IREG_R1_127,    /* r1-r127 */
    EM_OPTYPE_FREG,           /* FP register */
	EM_OPTYPE_FREG_F2_127,    /* f2-f127 */
    EM_OPTYPE_BR,             /* branch register */
    EM_OPTYPE_IP,             /* instruction pointer, not encoded */
    EM_OPTYPE_PREG,           /* predicate */
    EM_OPTYPE_PREGS_ALL,      /* the predicate register */
    EM_OPTYPE_PREGS_ROT,      /* rotating predicates */
    EM_OPTYPE_APP_REG_GRP_LOW,         /* application registers 0-63*/
    EM_OPTYPE_APP_REG_GRP_HIGH,        /* application registers 64-127*/
    EM_OPTYPE_APP_CCV,        /* ar.ccv */
    EM_OPTYPE_APP_PFS,        /* ar.pfs */
    EM_OPTYPE_CR,             /* control registers */
    EM_OPTYPE_PSR_L,          /* psr.l */
    EM_OPTYPE_PSR_UM,         /* psr.um */
    EM_OPTYPE_FPSR,           /* decoder operand types */
    EM_OPTYPE_CFM,
    EM_OPTYPE_PSR,
    EM_OPTYPE_IFM,
    EM_OPTYPE_REG_LAST,       /* End of register - types */
    EM_OPTYPE_REGFILE_FIRST,  /* The following types are register-files */
    EM_OPTYPE_PMC,
    EM_OPTYPE_PMD,
    EM_OPTYPE_PKR,
    EM_OPTYPE_RR,
    EM_OPTYPE_IBR,
    EM_OPTYPE_DBR,
    EM_OPTYPE_ITR,
    EM_OPTYPE_DTR,
    EM_OPTYPE_MSR,
    EM_OPTYPE_CPUID,
    EM_OPTYPE_REGFILE_LAST,   /* End of register-file types */
    EM_OPTYPE_IMM_FIRST,      /* The following types are immediates */
    EM_OPTYPE_UIMM,           /* unsigned immediate */
    EM_OPTYPE_SIMM,           /* signed immediate */
    EM_OPTYPE_IREG_NUM,       /* ireg in syntax and imm7 in encodings */
    EM_OPTYPE_FREG_NUM,       /* freg in syntax and imm7 in encodings */
    EM_OPTYPE_SSHIFT_REL,     /* pc relative signed immediate
                                 which is shifted by 4 */
    EM_OPTYPE_SSHIFT_1,       /* unsigned immediate which has to be
                                 shifted 1 bit */
    EM_OPTYPE_SSHIFT_16,      /* unsigned immediate which has to be
                                 shifted 16 bits */
    EM_OPTYPE_COUNT_123,      /* immediate which can have the values of
                                 1, 2, 3 only */
    EM_OPTYPE_COUNT_PACK,     /* immediate which can have the values of
                                        0, 7, 15, 16 only */
    EM_OPTYPE_UDEC,           /* unsigned immediate which has to be
                                 decremented by 1 by the assembler */
    EM_OPTYPE_SDEC,           /* signed immediate which has to be
                                 decremented by 1 by the assembler */
    EM_OPTYPE_CCOUNT,         /* in pshl[24] - uimm5 in syntax, but encoded
                                 as its 2's complement */
    EM_OPTYPE_CPOS,           /* in dep fixed form - uimm6 in syntax, but encoded
                                 as its 2's complement */
    EM_OPTYPE_SEMAPHORE_INC,  /* immediate which is a semaphore increment amount
                                 can have the values of -16,-8,-4,-1,
                                 1,4,8,16 */
    EM_OPTYPE_ONE,            /* the number 1 */
    EM_OPTYPE_FCLASS,         /* immediate of the fclass instruction */
    EM_OPTYPE_CMP_UIMM,       /* unsigned immediate of cmp geu and ltu */
    EM_OPTYPE_CMP_UIMM_DEC,   /* unsigned immediate of cmp gtu and leu */
    EM_OPTYPE_CMP4_UIMM,      /* unsigned immediate of cmp4 geu and ltu */
    EM_OPTYPE_CMP4_UIMM_DEC,  /* unsigned immediate of cmp4 gtu and leu */
    EM_OPTYPE_ALLOC_IOL,      /* for alloc : input, local, and output
                                 can be 0-96 */
    EM_OPTYPE_ALLOC_ROT,      /* for alloc : rotating, can be 0-96 */
    EM_OPTYPE_MUX1,           /* immediate of the mux1 instruction */
    EM_OPTYPE_EIGHT,          /* immediate for ldfps base update form can have value 8 */
    EM_OPTYPE_SIXTEEN,        /* immediate for ldfp8 and ldfpd base update form can have value 16 */
    EM_OPTYPE_IMM_LAST,       /* End of immediate types */
    EM_OPTYPE_MEM,            /* memory address */
    EM_OPTYPE_LAST
} Operand_type_t;

typedef enum {
      EM_FORMAT_NONE = 0,
      EM_FORMAT_A1,
      EM_FORMAT_A2,
      EM_FORMAT_A3,
      EM_FORMAT_A4,
      EM_FORMAT_A4_1,
      EM_FORMAT_A5,
      EM_FORMAT_A6,
      EM_FORMAT_A6_1,
      EM_FORMAT_A6_2,
      EM_FORMAT_A6_3,
      EM_FORMAT_A6_4,
      EM_FORMAT_A6_5,
      EM_FORMAT_A6_6,
      EM_FORMAT_A6_7,
      EM_FORMAT_A7,
      EM_FORMAT_A7_1,
      EM_FORMAT_A7_2,
      EM_FORMAT_A7_3,
      EM_FORMAT_A7_4,
      EM_FORMAT_A7_5,
      EM_FORMAT_A7_6,
      EM_FORMAT_A7_7,
      EM_FORMAT_A8,
      EM_FORMAT_A8_1,
      EM_FORMAT_A8_2,
      EM_FORMAT_A8_3,
      EM_FORMAT_A9,
      EM_FORMAT_A10,
      EM_FORMAT_I1,
      EM_FORMAT_I2,
      EM_FORMAT_I3,
      EM_FORMAT_I4,
      EM_FORMAT_I5,
      EM_FORMAT_I6,
      EM_FORMAT_I7,
      EM_FORMAT_I8,
      EM_FORMAT_I9,
      EM_FORMAT_I10,
      EM_FORMAT_I11,
      EM_FORMAT_I12,
      EM_FORMAT_I13,
      EM_FORMAT_I14,
      EM_FORMAT_I15,
      EM_FORMAT_I16,
      EM_FORMAT_I16_1,
      EM_FORMAT_I16_2,
      EM_FORMAT_I16_3,
      EM_FORMAT_I17,
      EM_FORMAT_I17_1,
      EM_FORMAT_I17_2,
      EM_FORMAT_I17_3,
      EM_FORMAT_I19,
      EM_FORMAT_I20,
      EM_FORMAT_I21,
      EM_FORMAT_I22,
      EM_FORMAT_I23,
      EM_FORMAT_I24,
      EM_FORMAT_I25,
      EM_FORMAT_I26,
      EM_FORMAT_I27,
      EM_FORMAT_I28,
      EM_FORMAT_I29,
      EM_FORMAT_M1,
      EM_FORMAT_M2,
      EM_FORMAT_M3,
      EM_FORMAT_M4,
      EM_FORMAT_M5,
      EM_FORMAT_M6,
      EM_FORMAT_M7,
      EM_FORMAT_M8,
      EM_FORMAT_M9,
      EM_FORMAT_M10,
      EM_FORMAT_M11,
      EM_FORMAT_M12,
      EM_FORMAT_M13,
      EM_FORMAT_M14,
      EM_FORMAT_M15,
      EM_FORMAT_M16,
      EM_FORMAT_M17,
      EM_FORMAT_M18,
      EM_FORMAT_M19,
      EM_FORMAT_M20,
      EM_FORMAT_M21,
      EM_FORMAT_M22,
      EM_FORMAT_M23,
      EM_FORMAT_M24,
      EM_FORMAT_M25,
      EM_FORMAT_M26,
      EM_FORMAT_M27,
      EM_FORMAT_M28,
      EM_FORMAT_M29,
      EM_FORMAT_M30,
      EM_FORMAT_M31,
      EM_FORMAT_M32,
      EM_FORMAT_M33,
      EM_FORMAT_M34,
      EM_FORMAT_M34_1,
      EM_FORMAT_M35,
      EM_FORMAT_M36,
      EM_FORMAT_M37,
      EM_FORMAT_M38,
      EM_FORMAT_M39,
      EM_FORMAT_M40,
      EM_FORMAT_M41,
      EM_FORMAT_M42,
      EM_FORMAT_M43,
      EM_FORMAT_M44,
      EM_FORMAT_M45,
      EM_FORMAT_M46,
      EM_FORMAT_M1001,
      EM_FORMAT_B1,
      EM_FORMAT_B2,
      EM_FORMAT_B3,
      EM_FORMAT_B4,
      EM_FORMAT_B5,
      EM_FORMAT_B6,
      EM_FORMAT_B7,
      EM_FORMAT_B8,
      EM_FORMAT_B9,
      EM_FORMAT_F1,
      EM_FORMAT_F1_1,
      EM_FORMAT_F2,
      EM_FORMAT_F3,
      EM_FORMAT_F4,
      EM_FORMAT_F4_1,
      EM_FORMAT_F4_2,
      EM_FORMAT_F4_3,
      EM_FORMAT_F4_4,
      EM_FORMAT_F4_5,
      EM_FORMAT_F4_6,
      EM_FORMAT_F4_7,
      EM_FORMAT_F5,
      EM_FORMAT_F5_1,
      EM_FORMAT_F5_2,
      EM_FORMAT_F5_3,
      EM_FORMAT_F6,
      EM_FORMAT_F7,
      EM_FORMAT_F8,
      EM_FORMAT_F8_4,
      EM_FORMAT_F9,
      EM_FORMAT_F9_1,
      EM_FORMAT_F10,
      EM_FORMAT_F11,
      EM_FORMAT_F12,
      EM_FORMAT_F13,
      EM_FORMAT_F14,
      EM_FORMAT_F15,
      EM_FORMAT_X1,
      EM_FORMAT_X2,
      EM_FORMAT_X3,
      EM_FORMAT_X4,
      EM_FORMAT_X41,
      EM_FORMAT_LAST
} Format_t;

typedef enum {
    EM_TROLE_NONE = 0,
    EM_TROLE_ALU,
    EM_TROLE_BR,
    EM_TROLE_FP,
    EM_TROLE_INT,
    EM_TROLE_LONG,
    EM_TROLE_MEM,
    EM_TROLE_MIBF,
    EM_TROLE_LAST
} Template_role_t;

typedef char *Mnemonic_t;
typedef char Major_opcode_t;
typedef short Extension_t[MAX_EXTENSION];
typedef struct {
    Operand_role_t operand_role;
    Operand_type_t operand_type;
} Operand_t;
typedef unsigned long Flags_t;
typedef unsigned long Implementation_t;


#endif /*** EMDB_TYPES_H ***/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\include\em.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef EM_H
#define EM_H

/*** UPDATED TO 2.6 draft ***/

#include "iel.h"
#include "EM_hints.h"

/*****************************************************************************/
/***                                                                       ***/
/***       Enhanced mode architecture constants and macros                 ***/
/***                                                                       ***/
/***  NOTE: this header files assumes that the following typedef's exist:  ***/
/***        U8, U16, U32, U64. iel.h contains these typedefs, but one      ***/
/***        may want to define them differently.                           ***/
/***                                                                       ***/
/*****************************************************************************/

#define EM_BUNDLE_SIZE              16
#define EM_SYLLABLE_BITS            41
#define EM_DISPERSAL_POS            0
#define EM_DISPERSAL_BITS           5
#define EM_SBIT_POS                 0
#define EM_TEMPLATE_POS             1
#define EM_TEMPLATE_BITS            4
#define EM_NUM_OF_TEMPLATES         (1<<EM_TEMPLATE_BITS) 
                                        /*** including the reserved!!! ***/
#define EM_SYL2_POS                 (EM_DISPERSAL_POS+EM_DISPERSAL_BITS)

#define EM_MAJOR_OPCODE_POS         37
#define EM_MAJOR_OPCODE_BITS        4
#define EM_PREDICATE_POS            0
#define EM_PREDICATE_BITS           6

#define EM_IL_SLOT_BITS             4
#define EM_IL_SLOTS_MASK32      ((1<<EM_IL_SLOT_BITS)-1)

typedef enum
{
    EM_SLOT_0=0,
    EM_SLOT_1=1,
    EM_SLOT_2=2,
    EM_SLOT_LAST=3
} EM_slot_num_t;

/****************************************************************************/
/*** the following macros needs iel. Bundle assumed to be in U128         ***/

/*** Bring syllable binary to bits 0-40 of Syl; DO NOT mask off bits 41   ***/
/*** and on (for movl, can use Slot=2 but then Maj.Op. is in bits 79-82!) ***/

#define EM_GET_SYLLABLE(syl,bundle,slot) \
        IEL_SHR((syl), (bundle), EM_SYL2_POS+(slot)*EM_SYLLABLE_BITS)

#define EM_GET_TEMPLATE(bundle) \
        ((IEL_GETDW0(bundle) >> EM_TEMPLATE_POS) & ((1<<EM_TEMPLATE_BITS)-1))

#define EM_TEMPLATE_IS_RESERVED(templt) \
(((templt)==3)||((templt)==10)||((templt)==13)||((templt)==15))

#define EM_IL_GET_BUNDLE_ADDRESS(il,addr) \
        IEL_CONVERT2((addr),IEL_GETDW0(il) & \
                            (unsigned int)(~EM_IL_SLOTS_MASK32), \
                     IEL_GETDW1(il))

#define EM_IL_GET_SLOT_NO(il)  (IEL_GETDW0(il) & EM_IL_SLOTS_MASK32)

#define EM_IL_SET(il,addr,slot) \
        IEL_CONVERT2((il), IEL_GETDW0(addr) | (slot), IEL_GETDW1(addr))

#define EM_IS_IGNORED_SQUARE(template_role, major_opcode)       \
        (((template_role) == EM_TROLE_BR) &&                    \
         (major_opcode == 3 || major_opcode == 6) ? 1 : 0)

#define EM_IS_GENERIC_INST(impls_flag) \
		((impls_flag == ArchRev0) || (impls_flag & Impl_Brl))

#define EM_IS_ITANIUM_INST(impls_flag) \
		(EM_IS_GENERIC_INST(impls_flag) || (impls_flag & Impl_Ipref) || (impls_flag & Impl_Itanium))


/*****************************************************************************/

typedef U64     EM_IL;     /* Instruction (syllable) Location */

typedef enum em_branch_type_s
{
    EM_branch_type_none          = 0x0,
    EM_branch_type_direct_cond   = 0x1,
    EM_branch_type_direct_wexit  = 0x2,
    EM_branch_type_direct_wtop   = 0x3,   
    EM_branch_type_direct_cloop  = 0x4,   
    EM_branch_type_direct_cexit  = 0x5,   
    EM_branch_type_direct_ctop   = 0x6,   
    EM_branch_type_direct_call   = 0x7,   
    EM_branch_type_direct_last   = 0x8,   
    EM_branch_type_indirect_cond = 0x9,
    EM_branch_type_indirect_ia   = 0xa,
    EM_branch_type_indirect_ret  = 0xb,
    EM_branch_type_indirect_call = 0xc,
    EM_branch_type_last
} EM_branch_type_t;

typedef enum em_cmp_type_s
{
    EM_cmp_type_none     = 0,  /* none (dstT=REL, dstF=!REL)        */
    EM_cmp_type_and      = 1,  /* and (dstT&=REL, dstF&=REL)        */
    EM_cmp_type_or       = 2,  /* or (dstT|=REL, dstF|=REL)         */
    EM_cmp_type_unc      = 3,  /* uncond (dstT=P&REL, dstF=P&!REL)  */
    EM_cmp_type_or_andcm = 4,  /* or.andcm (dstT|=REL, dstF&=!REL)  */
    EM_cmp_type_last
} EM_cmp_type_t;

typedef enum EM_template_e
{
    EM_template_mii   = 0,
    EM_template_mi_i  = 1,
    EM_template_mlx   = 2,
    /*** 3  reserved ***/
    EM_template_mmi   = 4,
    EM_template_m_mi  = 5,
    EM_template_mfi   = 6,
    EM_template_mmf   = 7,
    EM_template_mib   = 8,
    EM_template_mbb   = 9,
    /*** 10 reserved ***/
    EM_template_bbb   = 11,
    EM_template_mmb   = 12,
    /*** 13 reserved ***/
    EM_template_mfb   = 14,
    /*** 15 reserved ***/
    EM_template_last 
} EM_template_t;


/***** Misc operands values: fclass, sync (stype), mux *****/

typedef enum em_fclass_bit
{
    EM_fclass_bit_pos    = 0 ,
    EM_fclass_bit_neg    = 1 ,
    EM_fclass_bit_zero   = 2 ,
    EM_fclass_bit_unorm  = 3 ,
    EM_fclass_bit_norm   = 4 ,
    EM_fclass_bit_inf    = 5 ,
    EM_fclass_bit_signan = 6 ,
    EM_fclass_bit_qnan   = 7 ,
    EM_fclass_bit_nat    = 8
} EM_fclass_bit_t;
    
#define EM_FCLASS_POS           (1<<EM_fclass_bit_pos   )  /*** 0x001 ***/
#define EM_FCLASS_NEG           (1<<EM_fclass_bit_neg   )  /*** 0x002 ***/
#define EM_FCLASS_ZERO          (1<<EM_fclass_bit_zero  )  /*** 0x004 ***/
#define EM_FCLASS_UNORM         (1<<EM_fclass_bit_unorm )  /*** 0x008 ***/
#define EM_FCLASS_NORM          (1<<EM_fclass_bit_norm  )  /*** 0x010 ***/
#define EM_FCLASS_INF           (1<<EM_fclass_bit_inf   )  /*** 0x020 ***/
#define EM_FCLASS_SIGNAN        (1<<EM_fclass_bit_signan)  /*** 0x040 ***/
#define EM_FCLASS_QNAN          (1<<EM_fclass_bit_qnan  )  /*** 0x080 ***/
#define EM_FCLASS_NAT           (1<<EM_fclass_bit_nat   )  /*** 0x100 ***/

#define EM_MUX_BRCST              0x0
#define EM_MUX_MIX                0x8
#define EM_MUX_SHUF               0x9
#define EM_MUX_ALT                0xA
#define EM_MUX_REV                0xB

/*** sync-stype: arbitrary! need fix!!! <flags> ***/ /* !!!!!??? */
#define EM_STYPE_LOAD             0x0
#define EM_STYPE_STORE            0x1
#define EM_STYPE_EXT              0x2
#define EM_STYPE_PURGE            0x4

#define EM_MAX_MEM_OPERAND_SIZE     32

#define EM_NUM_OF_PRIVILEGE_LEVELS  4

/*** shift of branch/chk (target21 <--> target25) ***/
#define EM_IPREL_TARGET_SHIFT_AMOUNT    4

/*****************************************************/
/***** register-related constants and structures *****/
/*****************************************************/



/* branch register structure definition */

typedef U64 EM_branch_reg_t;

typedef struct EM_FPSR_s
{
    U4byte trap:6,sf0:13,sf1:13;
    U4byte sf2:13,sf3:13,reserved:6;
} EM_FPSR_t;

#define EM_FPSR_S0_ABSOLUTE_MASK           0x7f
#define EM_FPSR_SFX_TD_MASK                0x40
#define EM_FPSR_SFX_PC_MASK                0x0c
#define EM_FPSR_SFX_RESERVED_PC_VALUE      0x04

typedef struct EM_RSC_s
{
    U4byte mode:2, pl:2, be:1, reserved1:11, loadrs:14, reserved2:2;
    U4byte reserved3;
} EM_RSC_t;

typedef struct EM_BSP_s
{
    U4byte ignored:3,pointer_low:29;
    U4byte pointer_high;
} EM_BSP_t;

typedef EM_BSP_t EM_BSPSTORE_t;

typedef struct EM_EC_s
{
    U4byte count:6, ignored1:26;
    U4byte ignored2;
} EM_EC_t;

typedef struct EM_RNAT_s
{
    U4byte rse_nats_low;
    U4byte rse_nats_high:31, ignored:1;
} EM_RNAT_t;

#define EM_FRAME_RRB_MASK_LOW   0x3ffff
#define EM_FRAME_RRB_MASK_HIGH  0xffffffc0
#define EM_FRAME_FP_RRB_MASK 0xfe000000
#define EM_FRAME_FP_RRB_BIT_POS 25
#define EM_FRAME_RRB_FR_LOW_BIT_MASK 0x2000000
#define EM_FRAME_SOL_POS 7
#define EM_FRAME_SOL_MASK 0x3f80
#define EM_FRAME_SOR_POS 14
#define EM_FRAME_SOR_MASK 0x3c000
#define EM_FRAME_SOR_ZERO_BITS_NUM 3
#define EM_FRAME_SOF_MASK 0x7f

typedef struct EM_frame_marker_s
{
    U4byte sof:7, sol:7, sor:4, rrb_int:7, rrb_fp:7;
    U4byte rrb_pred:6, reserved:26;
} EM_frame_marker_t;

#define EM_PFS_CPL_BIT_POS 30
#define EM_PFS_HIGH_EC_BIT_POS 20
#define EM_PFS_CPL_MASK 0xc0000000
#define EM_PFS_EC_MASK 0x03f00000

typedef struct EM_PFS_s
{
    U4byte pfm_l;
    U4byte pfm_h:6, reserved1:14, pec:6, reserved2:4, ppl:2;
} EM_PFS_t;

#define EM_PSR_CPL_MASK      0x3
#define EM_PSR_CPL_BIT_POS   0
#define EM_PSR_H_ED_MASK     0x800
#define EM_PSR_H_ED_BIT_POS  0xb
#define EM_PSR_H_MC_MASK     0x8
#define EM_PSR_H_IT_MASK     0x10

/*** PSR ***/
typedef struct EM_PSR_s
{
    U4byte
    reserved1:1, /*  0 */
    be:1, /*  1 */
    up:1, /*  2 */
    ac:1, /*  3 */
    mfl:1,/*  4 */
    mfh:1,/*  5 */
    reserved2:7,/* 6-12 */
    ic:1, /* 13 */
    i:1,  /* 14 */
    pk:1, /* 15 */
    reserved3:1, /* 16 */ 
    dt:1, /* 17 */
    dfl:1,/* 18 */ 
    dfh:1,/* 19 */
    sp:1, /* 20 */
    pp:1, /* 21 */
    di:1, /* 22 */
    si:1, /* 23 */
    db:1, /* 24 */
    lp:1, /* 25 */
    tb:1, /* 26 */
    rt:1, /* 27 */
    reserved4:4; /* 28-31 */
    U4byte
    cpl:2, /* 32,33 */
    is:1,  /* 34 */
    mc:1,  /* 35 */
    it:1,  /* 36 */
    id:1,  /* 37 */
    da:1,  /* 38 */
    dd:1,  /* 39 */
    ss:1,  /* 40 */
    ri:2,  /* 41,42 */
    ed:1,  /* 43 */
    bn:1,  /* 44 */
    ia:1,  /* 45 */
  reserved5:18; /* 46-63 */
} EM_PSR_t;

/*** DCR ***/
typedef struct EM_DCR_s
{
    U4byte
    pp:1, /*  0 */
    be:1, /*  1 */
    lc:1, /*  2 */
    reserved1:5, /* 3-7 */ 
    dm:1, /*  8 */
    dp:1, /*  9 */
    dk:1, /* 10 */
    dx:1, /* 11 */
    dr:1, /* 12 */
    da:1, /* 13 */
    dd:1, /* 14 */
    reserved4:1,  /* 15 , - was 'du' before eas24 and became reserved */
    reserved2:16; /* 16-31 */
    U4byte reserved3; /* 32-63 */
} EM_DCR_t;

/**** ITM ****/
typedef U64 EM_ITM_t;

/**** IVA ****/
typedef struct EM_IVA_s
{
    U4byte
    ignored:15,
    iva_low:17;
    U4byte iva_high;
} EM_IVA_t;

/**** PTA ****/
typedef struct EM_pta_s
{
    U4byte
    ve:1,        /*  0    */
    reserved1:1, /*  1    */ 
    size:6,      /* 2-7   */ 
    vf:1,        /*  8    */
    reserved2:6, /* 9-14  */  
    base_low:17; /* 15-31 */
    U4byte
    base_high:32;/* 32-63 */
} EM_PTA_t;

/**** IPSR ****/
typedef EM_PSR_t EM_IPSR_t;

/**** ISR ****/
typedef struct EM_ISR_s
{
    U4byte
    code:16,     /*  0-15 */ 
    iA_vector:8, /* 16-23 */  
    reserved1:8; /* 24-31 */
    U4byte
    x:1,         /* 32 */
    w:1,         /* 33 */
    r:1,         /* 34 */
    na:1,        /* 35 */
    sp:1,        /* 36 */
    rs:1,        /* 37 */
    ir:1,        /* 38 */
    ni:1,        /* 39 */
    so:1,        /* 40 */
    ei:2,        /* 41-42 */
    ed:1,        /* 43 */
    reserved2:20;/* 44-63 */
} EM_ISR_t;

/* Low 12 bits of low word of IFA is defined as 
   ignored according to the TLB insertion format */

typedef struct EM_IFA_s
{
    U4byte
    ignored:12,
    vpn_low:20;
    U4byte
    vpn_high;
} EM_IFA_t;

typedef struct EM_IIP_s
{
    U4byte
    vpn_low;
    U4byte
    vpn_high;
} EM_IIP_t;

typedef EM_IIP_t EM_vaddr_t;

/* Unimplemented virtual and physical addresses */
#define   EM_MAX_IMPL_VA_MSB 60  
#define   EM_MIN_IMPL_VA_MSB 50  
#define   EM_MAX_IMPL_PA_MSB 62  
#define   EM_MIN_IMPL_PA_MSB 31

/**** ITIR ***/
typedef struct EM_itir_s
{
    U4byte
    reserved1:2, /* 0-1 */
    ps:6,        /* 2-7 */
    key:24;      /* 8-31 */ 
    U4byte
    reserved2:16, /* 32-47 */
    reserved4:15, /* 48-62 - was ppn */
    reserved3:1;  /* 63 */
} EM_ITIR_t;

#define EM_ITR_PPN_HIGH_OFFSET 24

/**** IIPA ****/
typedef U64 EM_IIPA_t;

/**** IFS ****/
typedef struct
{
    U4byte
    ifm_low;       /* 0-31 */
    U4byte
    ifm_high:6,    /* 32-37 */
    reserved:25,   /* 38-62 */
    v:1;           /* 63    */
} EM_IFS_t;

/**** IIM ****/
typedef struct
{
    U4byte
    imm21:21,    /*  0-20 */
    ignored1:11; /* 21-31 */  
    U4byte ignored2; /* 32-63 */
} EM_IIM_t;

typedef struct EM_IHA_s
{
    U4byte ignored:3,iha_low:29;
    U4byte iha_high;
} EM_IHA_t;

/**** LID ****/
typedef struct
{
    U4byte
    reserved:16,
    eid:8,
    id:8;
    U4byte ignored;
} EM_LID_t;

/**** IVR ****/
typedef struct
{
    U4byte
    vec:8,       /* not "vector" due to IAS issues */
    reserved:8,
    ignored1:16;
    U4byte ignored2;
} EM_IVR_t;

/**** TPR ****/
typedef struct
{
    U4byte
    ignored1:4,
    mic:4,
    reserved:8,
    mmi:1,
    ignored2:15;
    U4byte ignored3;
} EM_TPR_t;

/**** EOI ****/
typedef struct
{
    U4byte ignored1;
    U4byte ignored2;
} EM_EOI_t;

/**** IRR ****/
typedef U64 EM_IRR_t;

/**** ITV ****/
typedef struct
{
    U4byte
    vec:8,         /* not "vector" due to IAS issues */
    reserved1:4,
    zero:1,
    reserved2:3,
    m:1,
    ignored1:15;
    U4byte ignored2;
} EM_ITV_t;

/**** PMV ****/
typedef EM_ITV_t EM_PMV_t;

/**** LRR ****/
typedef struct
{
    U4byte
    vec:8,         /* not "vector" due to IAS issues */
    dm:3,
    reserved1:1,
    ignored3:1,
    ipp:1,
    reserved2:1,
    tm:1,
    m:1,
    ignored1:15;
    U4byte ignored2;
} EM_LRR_t;

/**** BHB ****/
typedef struct
{
    U4byte
    max:10,
    ignored:2,
    base_low:20;
    U4byte 
    base_high;
} EM_BHB_t;

/**** THA ****/
typedef struct
{
    U4byte
    ptr:10,
    bh:1,
    ignored1:1,
    vaddr:20;
    U4byte 
    ignored2;
} EM_THA_t;

/**** CMCV ****/
typedef EM_ITV_t EM_CMCV_t;


/**** RR ****/
typedef struct EM_region_register_s
{
    U4byte
    ve:1,          /*  0 */
    reserved1:1,   /*  1 */
    ps:6,          /*  2-7 */
    rid:24;        /*  8-31 */ 
    U4byte  reserved2; /* 32-63 */
} EM_RR_t;

/**** PKR ****/
typedef struct EM_key_register_s
{
    U4byte
    v:1,   /* 0 */
    wd:1,  /* 1 */
    rd:1,  /* 2 */
    xd:1,  /* 3 */
    reserved1:4,  /* 4-7  */
    key:24;       /* 8-31 */
    U4byte reserved2; /* 32-63 */
} EM_PKR_t;      

typedef U64 EM_DBR_EVEN_t;
typedef U64 EM_IBR_EVEN_t;

typedef struct EM_DBR_ODD_s
{
    U4byte mask_low;           /* 0 - 31  */
    U4byte mask_high:24,       /* 32 - 55 */
           plm:4,              /* 56 - 59 */
           ignored:2,          /* 60 - 61 */
           w:1,                /* 62      */
           r:1;                /* 63      */
} EM_DBR_ODD_t;

typedef struct EM_IBR_ODD_s
{
    U4byte mask_low;           /* 0 - 31  */
    U4byte mask_high:24,       /* 32 - 55 */
           plm:4,              /* 56 - 59 */
           ignored:3,          /* 60 - 62 */
           x:1;                /* 63      */
} EM_IBR_ODD_t;

/**** PMC Registers ****/
/**** PMC0 ****/

typedef struct EM_PMC0_register_s
{
    U4byte 
    fr:1,                      /*   0     */    
    ignored1:3,                /* 1 - 3   */
    overflow:4,                /* 4 - 7   */
    ignored2:24;               /* 8 - 31  */
    U4byte ignored3;           /* 32 - 63 */
} EM_PMC0_t;

/**** PMC1 -  PMC3 ****/

typedef U64 EM_PMC1_3_t;

/**** PMC4 - ****/

typedef struct EM_PMC_register_s
{
    U4byte
    plm:4,                     /* 0 - 3   */
    ev:1,                      /* 4       */
    oi:1,                      /* 5       */
    pm:1,                      /* 6       */
    ignored1:1,                /* 7       */
    es:8,                      /* 8 - 15  */
    umask:4,                   /* 16 - 19 */
    ignored2:12;               /* 20 - 31 */
    U4byte ignored3;           /* 32 - 63 */
} EM_PMC_t;

typedef struct EM_PMD_register_s
{
    U4byte count;             /* 0 - 31  */
    U4byte sxt;               /* 32 - 63 */
} EM_PMD_t;

/* Number of implementet count bits in PMD */
#define EM_PMD_COUNT_SIZE     32

typedef U64 EM_MSR_t;

typedef struct EM_tlb_insert_reg_s
{
    U4byte
    p:1,        /* 0     */
    mx:1,       /* 1     */
    ma:3,       /* 2-4   */
    a:1,        /* 5     */
    d:1,        /* 6     */
    pl:2,       /* 7-8   */
    ar:3,       /* 9-11  */
    ppn_low:20; /* 12-31 */
    U4byte
    ppn_high:12, /* 32-43 */
    reserved2:4, /* 44-47 - was ppn_high */        
    reserved1:4, /* 48-51 */
    ed:1,        /* 52    */
    ignored:11;  /* 63-63 */
} EM_tlb_insert_reg_t;

typedef enum
{
    EM_TLB_ar_r_r_r,         /* 000 */
    EM_TLB_ar_rx_rx_rx,      /* 001 */
    EM_TLB_ar_rw_rw_rw,      /* 010 */
    EM_TLB_ar_rwx_rwx_rwx,   /* 011 */
    EM_TLB_ar_r_rw_rw,       /* 100 */     
    EM_TLB_ar_rx_rx_rwx,     /* 101 */
    EM_TLB_ar_rwx_rw_rw,     /* 110 */
    EM_TLB_ar_x_x_rx,        /* 111 */
    EM_TLB_ar_last
} EM_page_access_right_t;

typedef enum
{                                /* ma  mx */
    EM_VA_MA_WB      = 0x0,      /* 000 0  */
    EM_VA_MA_WT      = 0x4,      /* 010 0 */
    EM_VA_MA_WP      = 0x6,      /* 011 0 */
    EM_VA_MA_UC      = 0x8,      /* 100 0 */
    EM_VA_MA_UCC     = 0x9,      /* 100 1 */
    EM_VA_MA_UCE     = 0xa,      /* 101 0 */
    EM_VA_MA_WC      = 0xc,      /* 110 0 */
    EM_VA_MA_NATPAGE = 0xe       /* 111 0 */
} EM_vaddr_mem_attribute_t;

/* encodings of guest memory attributes */
typedef enum
{
    EM_IA_GVA_MA_UC        = 0x0,      /* 000 */
    EM_IA_GVA_MA_WC        = 0x1,      /* 001 */
    EM_IA_GVA_MA_WT        = 0x4,      /* 100 */
    EM_IA_GVA_MA_WP        = 0x5,      /* 101 */
    EM_IA_GVA_MA_WB        = 0x6,      /* 110 */
    EM_IA_GVA_MA_UC_MINUS  = 0x7       /* 111 */    
} EM_IA_vaddr_gmem_attribute_t;

/* In eas24: attr = ma + mx */
#define EM_VA_IS_MA_ATTRIBUTE_RESERVED(attr)                  \
    (((attr) == 0x2) || ((attr) == 0x4) || ((attr) == 0x6) ||    \
     ((attr) & 0x1))

#define EM_GVA_IS_MA_ATTRIBUTE_RESERVED(attr)                    \
    (((attr) == 0x1) || ((attr) == 0x2) || ((attr) == 0x3) ||    \
     ((attr) == 0x5) || ((attr) == 0x7) || ((attr) == 0xb) ||    \
     ((attr) == 0xd) || ((attr) == 0xf)) 
     
typedef EM_tlb_insert_reg_t EM_vhpt_short_format_t;

typedef struct EM_vhpt_long_format_s
{
    U4byte
    p:1,         /* 0     */
    mx:1,        /* 1     */
    ma:3,        /* 2-4   */
    a:1,         /* 5     */
    d:1,         /* 6     */
    pl:2,        /* 7-8   */
    ar:3,        /* 9-11  */
    ppn_low:20;  /* 12-31 */
    
    U4byte
    ppn_mid:12,  /* 32-43 */
    reserved5:4, /* 44-47 - was ppn_mid*/
    reserved1:4, /* 48-51 */
    ed:1,        /* 52    */ 
    ignored:11;  /* 53-63 */
    
    U4byte
    reserved2:2, /* 0-1   */
    ps:6,        /* 2-7   */
    key:24;      /* 8-31  */
    
    U4byte
    reserved3:16,/* 32-47 */
    reserved6:15, /* 48-62 - was ppn_high */
    reserved4:1; /* 63    */
    
    U64 tag;
    U64 avl3;
} EM_vhpt_long_format_t;

typedef struct EM_gvhpt_short_format_s
{
    U4byte
    p:1,         /* 0     */
    w:1,         /* 1     */
    u:1,         /* 2     */
    pa10:2,      /* 3-4   */
    a:1,         /* 5     */
    d:1,         /* 6     */
    pa2:1,       /* 7     */
    g:1,         /* 8     */
    ignored:3,   /* 9-11  */
    ppn:20;      /* 12 - 31 */     
}EM_gvhpt_short_format_t;

typedef struct EM_gvhpt_long_format_s
{
    U4byte
    p:1,         /* 0     */
    w:1,         /* 1     */
    u:1,         /* 2     */
    pa10:2,      /* 3-4   */
    a:1,         /* 5     */
    d:1,         /* 6     */
    pa2:1,       /* 7     */
    g:1,         /* 8     */
    ignored:3,   /* 9-11  */
    ppn_low:20;  /* 12 - 31 */ 
    U4byte
    ppn_high:16, /* 32-47 */
    reserved:16; /* 48-63 */
}EM_gvhpt_long_format_t;

/* the minimum VHPT size is 2^14 = 16K */
#define EM_MIN_VHPT_SIZE_POWER      14

/* define the number of registers */
#define EM_NUM_OF_GREGS            128
#define EM_NUM_OF_ADD22_GREGS        4
#define EM_NUM_OF_FPREGS           128
#define EM_NUM_OF_PREGS             64
#define EM_NUM_OF_BREGS              8
#define EM_NUM_OF_AREGS            128
#define EM_NUM_OF_CREGS            128
#define EM_NUM_OF_RREGS              8
#define EM_NUM_OF_PKREGS            16
#define EM_NUM_OF_DBREGS            32 /* guess for max value*/
#define EM_NUM_OF_IBREGS            32 /* guess for max value*/
#define EM_NUM_OF_PMCREGS           32 /* guess for max value*/
#define EM_NUM_OF_PMDREGS           32 /* guess for max value*/
#define EM_NUM_OF_MSREGS          2048 /* guess for max value*/
#define EM_NUM_OF_KREGS              8 /* kernel registers are AREGS */
#define EM_NUM_OF_CPUID_REGS         5 /* implementation independent part */
#define EM_NUM_OF_IRREGS             4
#define EM_NUM_OF_BANKED_REGS       16
#define EM_FIRST_BANKED_REG         16
#define EM_FIRST_IN_FP_LOW_REG_SET   0
#define EM_FIRST_IN_FP_HIGH_REG_SET 32

#define EM_PREDICATE_WIRED_TRUE      0
#define EM_STACK_BASE_REGISTER      32
#define EM_REGISTER_STACK_SIZE      96
#define EM_GREG_ROTATING_BASE       32
#define EM_PREG_ROTATING_BASE       16
#define EM_NUM_OF_ROTATING_PREGS    (EM_NUM_OF_PREGS - EM_PREG_ROTATING_BASE)
#define EM_FPREG_ROTATING_BASE      32
#define EM_NUM_OF_ROTATING_FPREGS   (EM_NUM_OF_FPREGS - EM_FPREG_ROTATING_BASE)
#define EM_GREGS_ROTATING_GROUPS    8    

/* kernel registers macros */
#define EM_IS_AREG_A_KREG(n)     (((n) >= EM_AR_KR0) && ((n) <= EM_AR_KR7))
#define EM_AREG_NUM_TO_KREG(n)   ((n) - EM_AR_KR0)
#define EM_KREG_NUM_TO_AREG(n)   ((n) + EM_AR_KR0)
#define EM_IS_KREG_A_AREG(n)     ((n) < 7)

/* PSR user and system mask */
#define EM_PSR_UM_MASK              0x3f
#define EM_PSR_SM_MASK              0xffffff
#define EM_PSR_MFL_MASK             0x10
#define EM_PSR_MFH_MASK             0x20


/* instruction and data TLB translation registers information */
#define EM_TLB_MIN_DATA_TR_NUM         8
#define EM_TLB_MIN_INST_TR_NUM         8
#define EM_TLB_MAX_DATA_TR_NUM       256
#define EM_TLB_MAX_INST_TR_NUM       256
#define EM_TLB_MIN_TLB_TC_NUM          8
#define EM_TLB_MAX_TLB_TC_NUM        256
#define EM_TLB_DATA_TR_NUM_MASK     0xff
#define EM_TLB_INST_TR_NUM_MASK     0xff

/* define the special purpose application registers */
typedef enum
{
    EM_AR_KR0  = 0,
    EM_AR_KR1  = 1,
    EM_AR_KR2  = 2,
    EM_AR_KR3  = 3,
    EM_AR_KR4  = 4,
    EM_AR_KR5  = 5,
    EM_AR_KR6  = 6,
    EM_AR_KR7  = 7,
    /* ar8-15 reserved */
    EM_AR_RSC  = 16,
    EM_AR_BSP  = 17,
    EM_AR_BSPSTORE = 18,
    EM_AR_RNAT = 19,
    /* ar20 reserved */
    EM_AR_FCR  = 21, 
    /* ar22-23 reserved */
    EM_AR_EFLAG  = 24,
    EM_AR_CSD    = 25,
    EM_AR_SSD    = 26,
    EM_AR_CFLG   = 27,
    EM_AR_FSR    = 28,
    EM_AR_FIR    = 29,
    EM_AR_FDR    = 30,
    /* ar31 reserved */
    EM_AR_CCV    = 32,
    /* ar33-35 reserved */
    EM_AR_UNAT = 36,
    /* ar37-39 reserved */
    EM_AR_FPSR = 40,
    /* ar41-43 reserved */
    EM_AR_ITC  = 44,
    /* ar45-47 reserved */
    /* ar48-63 ignored */
    EM_AR_PFS  = 64,
    EM_AR_LC   = 65,
    EM_AR_EC   = 66,
    /* ar67-111 reserved */
    /* ar112-128 ignored */
    EM_AR_LAST = 128
} EM_areg_num_t;

/*****************************/
/*** Control     Registers ***/
/*****************************/
typedef enum
{
    EM_CR_DCR  = 0,
    EM_CR_ITM  = 1,
    EM_CR_IVA  = 2,
    /*** 3-7 reserved ***/
    EM_CR_PTA  = 8,
    EM_CR_GPTA = 9,
    /*** 10-15 reserved ***/
    EM_CR_IPSR = 16,
    EM_CR_ISR  = 17,
    /*** 18 reserved ***/
    EM_CR_IIP  = 19,
    EM_CR_IFA  = 20,
    EM_CR_ITIR = 21,
    EM_CR_IIPA = 22,
    EM_CR_IFS  = 23,
    EM_CR_IIM  = 24,
    EM_CR_IHA  = 25,
    /*** 25-63 reserved ***/
    /*** SAPIC registers ***/
    EM_CR_LID  = 64,
    EM_CR_IVR  = 65,
    EM_CR_TPR  = 66,
    EM_CR_EOI  = 67,
    EM_CR_IRR0 = 68,
    EM_CR_IRR1 = 69,
    EM_CR_IRR2 = 70,
    EM_CR_IRR3 = 71,
    EM_CR_ITV  = 72,
    EM_CR_PMV  = 73,
    EM_CR_CMCV = 74,
    /*** 75-79 reserved  ***/
    EM_CR_LRR0 = 80,
    EM_CR_LRR1 = 81,
    /*** 82-127 reserved ***/
    EM_CR_LAST = 128
} EM_creg_num_t;

typedef enum
{
    EM_CPUID_VENDOR0    = 0,
    EM_CPUID_VENDOR1    = 1,
    EM_CPUID_SERIAL_NUM = 2,
    EM_CPUID_VERSION    = 3,
    EM_CPUID_FEATURES   = 4,
    EM_CPUID_LAST
} EM_cpuid_num_t;

typedef enum
{
    EM_GR_BHB = 6,
    EM_GR_THA = 7
} EM_greg_num_t;

typedef struct EM_CPUID_version_s
{
    U4byte
        number:8,
        revision:8,
        model:8,
        family:8;
    U4byte
        archrev:8,
        reserved1:24;
} EM_CPUID_version_t;

#define EM_NUM_OF_M_ROLE_APP_REGS               64
#define EM_NUM_OF_I_ROLE_APP_REGS       (EM_NUM_OF_AREGS - \
                                         EM_NUM_OF_M_ROLE_APP_REGS)

#define EM_APP_REG_IS_I_ROLE(ar_no)     ((ar_no) >= EM_NUM_OF_M_ROLE_APP_REGS)

#define EM_APP_REG_IS_RESERVED(ar_no)   ((((ar_no) > 7)  && ((ar_no) < 16)) ||\
                                         (((ar_no) > 19) && ((ar_no) < 21)) ||\
                                         (((ar_no) > 21) && ((ar_no) < 24)) ||\
                                         (((ar_no) > 30) && ((ar_no) < 32)) ||\
                                         (((ar_no) > 32) && ((ar_no) < 36)) ||\
                                         (((ar_no) > 36) && ((ar_no) < 40)) ||\
                                         (((ar_no) > 40) && ((ar_no) < 44)) ||\
                                         (((ar_no) > 44) && ((ar_no) < 48)) ||\
                                         (((ar_no) > 66) && ((ar_no) < 112)))

#define EM_APP_REG_IS_IGNORED(ar_no)    ((((ar_no) > 47)  && ((ar_no) < 64))||\
                                         ((ar_no) > 111))

#define EM_CREG_IS_I_ROLE(cr_no)        0
#define EM_CREG_IS_RESERVED(cr_no)      ((((cr_no) > 2)  && ((cr_no) < 8))  ||\
                                         (((cr_no) > 9)  && ((cr_no) < 16)) ||\
                                         ((cr_no) == 18)                    ||\
                                         (((cr_no) > 25) && ((cr_no) < 64)) ||\
                                         (((cr_no) > 74) && ((cr_no) < 80)) ||\
                                         ((cr_no) > 81))

#define EM_PMD_IS_IMPLEMENTED(pmd_no)    ((pmd_no) > 3 && (pmd_no) < 8)
#define EM_PMC_IS_IMPLEMENTED(pmc_no)    ((pmc_no) < 8)

/* Interruption Priorities, taken from Table 10-5 in EAS2.4. */
typedef enum EM_interruption_e
{
    EM_INTR_NONE                                  = 0,
    /* Aborts: IA32, IA64 */
    EM_INTR_MACHINE_RESET                         = 1,
    EM_INTR_MACHINE_CHECK_ABORT                   = 2,
    /* Interrupts: IA32, IA64 */
    EM_INTR_PLATFORM_MANAGEMENT_INTERRUPT         = 3,
    EM_INTR_EXTERNAL_INTERRUPT                    = 4,
    /* Faults: IA64 */
    EM_INTR_IR_UNIMPLEMENTED_DATA_ADDRESS_FAULT   = 5,
    EM_INTR_IR_DATA_NESTED_TLB_FAULT              = 6,
    EM_INTR_IR_ALT_DATA_TLB_FAULT                 = 7,
    EM_INTR_IR_VHPT_DATA_FAULT                    = 8,
    EM_INTR_IR_DATA_TLB_FAULT                     = 9,
    EM_INTR_IR_DATA_PAGE_NOT_PRESENT_FAULT        = 10,
    EM_INTR_IR_DATA_NAT_PAGE_CONSUMPTION_FAULT    = 11,
    EM_INTR_IR_DATA_KEY_MISS_FAULT                = 12,
    EM_INTR_IR_DATA_KEY_PERMISSION_FAULT          = 13,
    EM_INTR_IR_DATA_ACCESS_RIGHT_FAULT            = 14,
    EM_INTR_IR_DATA_ACCESS_BIT_FAULT              = 15,
    EM_INTR_IR_DATA_DEBUG_FAULT                   = 16,
    /* Faults: IA32 */
    EM_INTR_IA_INST_BREAKPOINT_FAULT              = 17,
    EM_INTR_IA_CODE_FETCH_FAULT                   = 18,
    /* Faults: IA32, IA64 */
    EM_INTR_INST_ALT_TLB_FAULT                    = 19,
    EM_INTR_INST_VHPT_FAULT                       = 20,
    EM_INTR_INST_TLB_FAULT                        = 21,
    EM_INTR_INST_PAGE_NOT_PRESENT_FAULT           = 22,
    EM_INTR_INST_NAT_PAGE_CONSUMPTION_FAULT       = 23,
    EM_INTR_INST_KEY_MISS_FAULT                   = 24,
    EM_INTR_INST_KEY_PERMISSION_FAULT             = 25,
    EM_INTR_INST_ACCESS_RIGHT_FAULT               = 26,
    EM_INTR_INST_ACCESS_BIT_FAULT                 = 27,
    /* Faults: IA64 */
    EM_INTR_INST_DEBUG_FAULT                      = 28,
    /* Faults: IA32 */
    EM_INTR_IA_INST_LENGTH_FAULT                  = 29,
    EM_INTR_IA_INVALID_OPCODE_FAULT               = 30,
    EM_INTR_IA_INST_INTERCEPT_FAULT               = 31,
    /* Faults: IA64 */
    EM_INTR_ILLEGAL_OPERATION_FAULT               = 32,
    EM_INTR_BREAK_INSTRUCTION_FAULT               = 33,
    EM_INTR_PRIVILEGED_OPERATION_FAULT            = 34,
    /* Faults: IA32, IA64 */
    EM_INTR_DISABLED_FP_REGISTER_FAULT            = 35,
    EM_INTR_DISABLED_ISA_TRANSITION_FAULT         = 36,
    /* Faults: IA32 */
    EM_INTR_IA_COPROCESSOR_NOT_AVAILABLE_FAULT    = 37,
    EM_INTR_IA_FP_ERROR_FAULT                     = 38,
    /* Faults: IA32, IA64 */
    EM_INTR_REGISTER_NAT_CONSUMPTION_FAULT        = 39,
    /* Faults: IA64 */
    EM_INTR_RESERVED_REGISTER_FIELD_FAULT         = 40,
    EM_INTR_PRIVILEGED_REGISTER_FAULT             = 41,
    EM_INTR_SPECULATIVE_OPERATION_FAULT           = 42,
    /* Faults: IA32 */
    EM_INTR_IA_STACK_EXCEPTION_FAULT              = 43,
    EM_INTR_IA_GENERAL_PROTECTION_FAULT           = 44,
    /* Faults: IA32, IA64 */
    EM_INTR_DATA_NESTED_TLB_FAULT                 = 45, 
    EM_INTR_DATA_ALT_TLB_FAULT                    = 46,
    EM_INTR_DATA_VHPT_FAULT                       = 47,
    EM_INTR_DATA_TLB_FAULT                        = 48,
    EM_INTR_DATA_PAGE_NOT_PRESENT_FAULT           = 49,
    EM_INTR_DATA_NAT_PAGE_CONSUMPTION_FAULT       = 50,
    EM_INTR_DATA_KEY_MISS_FAULT                   = 51,
    EM_INTR_DATA_KEY_PERMISSION_FAULT             = 52,
    EM_INTR_DATA_ACCESS_RIGHT_FAULT               = 53,
    EM_INTR_DATA_DIRTY_BIT_FAULT                  = 54,
    EM_INTR_DATA_ACCESS_BIT_FAULT                 = 55,
    /* Faults: IA64 */
    EM_INTR_DATA_DEBUG_FAULT                      = 56,
    EM_INTR_UNALIGNED_DATA_REFERENCE_FAULT        = 57,
    /* Faults: IA32 */
    EM_INTR_IA_UNALIGNED_DATA_REFERENCE_FAULT     = 58,
    EM_INTR_IA_LOCKED_DATA_REFERENCE_FAULT        = 59,
    EM_INTR_IA_SEGMENT_NOT_PRESENT_FAULT          = 60,
    EM_INTR_IA_DIVIDE_BY_ZERO_FAULT               = 61,
    EM_INTR_IA_BOUND_FAULT                        = 62,
    EM_INTR_IA_KNI_NUMERIC_ERROR_FAULT            = 63,
    /* Faults: IA64 */
    EM_INTR_LOCKED_DATA_REFERENCE_FAULT           = 64,
    EM_INTR_FP_EXCEPTION_FAULT                    = 65,
    /* Traps: IA64 */
    EM_INTR_UNIMPLEMENTED_INST_ADDRESS_TRAP       = 66,
    EM_INTR_FP_TRAP                               = 67,
    EM_INTR_LOWER_PRIVILEGE_TARNSFER_TRAP         = 68,
    EM_INTR_TAKEN_BRANCH_TRAP                     = 69,
    EM_INTR_SINGLE_STEP_TRAP                      = 70,
    /* Traps: IA32 */
    EM_INTR_IA_SYSTEM_FLAG_INTERCEPT_TRAP         = 71,
    EM_INTR_IA_GATE_INTERCEPT_TRAP                = 72,
    EM_INTR_IA_INTO_TRAP                          = 73,
    EM_INTR_IA_BREAKPOINT_TRAP                    = 74,
    EM_INTR_IA_SOFTWARE_INTERRUPT_TRAP            = 75,
    EM_INTR_IA_DATA_DEBUG_TRAP                    = 76,
    EM_INTR_IA_TAKEN_BRANCH_TRAP                  = 77,
    EM_INTR_IA_SINGLE_STEP_TRAP                   = 78,

    EM_INTR_LAST                                  = 79
} EM_interruption_t;


/* Interruption Vectors, taken from Table 10-6 in EAS2.4. */
typedef enum
{
    EM_VECTOR_VHPT_TRANSLATION         = 0x0000,
    EM_VECTOR_INST_TLB                 = 0x0400,
    EM_VECTOR_DATA_TLB                 = 0x0800,
    EM_VECTOR_INST_ALT_TLB             = 0x0c00,
    EM_VECTOR_DATA_ALT_TLB             = 0x1000,
    EM_VECTOR_DATA_NESTED_TLB          = 0x1400,
    EM_VECTOR_INST_KEY_MISS            = 0x1800,
    EM_VECTOR_DATA_KEY_MISS            = 0x1C00,
    EM_VECTOR_DIRTY_BIT                = 0x2000,
    EM_VECTOR_INST_ACCESS_BIT          = 0x2400,
    EM_VECTOR_DATA_ACCESS_BIT          = 0x2800,
    EM_VECTOR_BREAK_INSTRUCTION        = 0x2C00,
    EM_VECTOR_EXTERNAL_INTERRUPT       = 0x3000,
    /*** reserved: 0x3400 through 0x4c00 ***/
    EM_VECTOR_PAGE_NOT_PRESENT         = 0x5000,
    EM_VECTOR_KEY_PERMISSION           = 0x5100,
    EM_VECTOR_INST_ACCESS_RIGHT        = 0x5200,
    EM_VECTOR_DATA_ACCESS_RIGHT        = 0x5300,
    EM_VECTOR_GENERAL_EXCEPTION        = 0x5400,
    EM_VECTOR_DISABLED_FP_REGISTER     = 0x5500,
    EM_VECTOR_NAT_CONSUMPTION          = 0x5600,
    EM_VECTOR_SPECULATION              = 0x5700,
    /*** reserved: 0x5800 ***/
    EM_VECTOR_DEBUG                    = 0x5900,
    EM_VECTOR_UNALIGNED_REFERENCE      = 0x5A00,
    EM_VECTOR_LOCKED_DATA_REFERENCE    = 0x5B00,
    EM_VECTOR_FP_EXCEPTION             = 0x5C00,
    EM_VECTOR_FP_TRAP                  = 0x5D00,
    EM_VECTOR_LOWER_PRIVILEGE_TRANSFER = 0x5E00,
    EM_VECTOR_TAKEN_BRANCH             = 0x5F00,
    EM_VECTOR_SINGLE_STEP              = 0x6000,
    /*** reserved: 0x6100 through 0x6800 ***/
    EM_VECTOR_IA_EXCEPTIONS            = 0x6900,
    EM_VECTOR_IA_INTERCEPTIONS         = 0x6A00,
    EM_VECTOR_IA_INTERRUPTIONS         = 0x6B00
    /*** reserved: 0x6c00 through 0x7f00 ***/
} EM_vector_t;

#define EM_INTR_ISR_CODE_TPA               0
#define EM_INTR_ISR_CODE_FC                1
#define EM_INTR_ISR_CODE_PROBE             2
#define EM_INTR_ISR_CODE_TAK               3
#define EM_INTR_ISR_CODE_LFETCH            4
#define EM_INTR_ISR_CODE_PROBE_FAULT       5



#define EM_ISR_CODE_ILLEGAL_OPERATION            0x0
#define EM_ISR_CODE_PRIVILEGED_OPERATION         0x10
#define EM_ISR_CODE_PRIVILEGED_REGISTER          0x20
#define EM_ISR_CODE_RESERVED_REGISTER_FIELD      0x30
#define EM_ISR_CODE_ILLEGAL_ISA_TRANSITION       0x40

#define EM_ISR_CODE_F0_F15        0
#define EM_ISR_CODE_F16_F127      1

#define EM_ISR_CODE_NAT_REGISTER_CONSUMPTION  0x10
#define EM_ISR_CODE_NAT_PAGE_CONSUMPTION      0x20

#define EM_ISR_CODE_INST_DEBUG        0
#define EM_ISR_CODE_DATA_DEBUG        1

#define EM_ISR_CODE_FP_IEEE_V          0x0001
#define EM_ISR_CODE_FP_IA_DENORMAL     0x0002
#define EM_ISR_CODE_FP_IEEE_Z          0x0004
#define EM_ISR_CODE_FP_SOFT_ASSIST     0x0008
#define EM_ISR_CODE_FP_IEEE_O          0x0800
#define EM_ISR_CODE_FP_IEEE_U          0x1000
#define EM_ISR_CODE_FP_IEEE_I          0x2000
#define EM_ISR_CODE_FP_EXPONENT        0x4000
#define EM_ISR_CODE_FP_ROUNDING_ADD_1  0x8000

#define EM_ISR_CODE_MASK_IA_TRAP            0x02
#define EM_ISR_CODE_MASK_IA_DATA_DEBUG_TRAP 0x00
#define EM_ISR_CODE_MASK_FP_TRAP            0x01
#define EM_ISR_CODE_MASK_LOWER_PRIV         0x02
#define EM_ISR_CODE_MASK_TAKEN_BRANCH       0x04
#define EM_ISR_CODE_MASK_SINGLE_STEP        0x08
#define EM_ISR_CODE_MASK_UNIMPLEMENTED_INST 0x10

#define EM_ISR_VECTOR_MASK_IA_TRAP          0x1
#define EM_ISR_VECTOR_MASK_EM_TRAP          0x0

#define EM_ISR_CODE_CHK_A_GR          0
#define EM_ISR_CODE_CHK_S_GR          1
#define EM_ISR_CODE_CHK_A_FP          2
#define EM_ISR_CODE_CHK_S_FP          3
#define EM_ISR_CODE_CHK_FCHK          4

/*** SAPIC definitions ***/
#define EM_SAPIC_SPURIOUS_VECTOR_NUM        0x0f
#define EM_SAPIC_SIZE_OF_INTERRUPT_GROUP      16
#define EM_SAPIC_NUM_OF_INTERRUPT_GROUPS      16
#define EM_SAPIC_GROUPS_IN_IRR                 4
#define EM_SAPIC_GROUP(vec) \
        ((vec) / EM_SAPIC_NUM_OF_INTERRUPT_GROUPS)
#define EM_SAPIC_IRR(vec) \
        ((vec) / (EM_SAPIC_NUM_OF_INTERRUPT_GROUPS*EM_SAPIC_GROUPS_IN_IRR))
#define EM_SAPIC_IRR_BIT_POS(vec) \
        ((vec) % (EM_SAPIC_NUM_OF_INTERRUPT_GROUPS*EM_SAPIC_GROUPS_IN_IRR))

/***  version strings at the .comment section ***/
#define EM_IAS_OBJECT_FILE_NAME "!!!!Object file name: "
#define EM_IAS_VER_NUMBER       "!!!!Major Version "
#define EM_IAS_VERSION_COMMENT  "!!!!EM_EAS2.6"
      
/***  architecture and API versions ***/
#define EM_EAS_MAJOR_VERSION   2
#define EM_EAS_MINOR_VERSION   6

#define EM_API_MAJOR_VERSION   9
#define EM_API_MINOR_VERSION   6

/*** END OF EM_H Enhanced Mode ARCHITECTURE ***/

#endif /*** EM_H ***/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\iel\iel.c ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "ctype.h"
#include "iel.h"

typedef struct
{
    unsigned short  w[8];
} MUL128;


U32 digits_value[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};


IEL_Err IEL_mul(U128 *xr, U128 *y, U128 *z)
{
	MUL128 	y1, z1;
	U128   	temp[16], x;
	char   	ovfl=0;
	unsigned long 	 i, j, ui, uj, tmin, tmax;
	unsigned long    meanterm;

	for (i=0; i<16; i++)
	  IEL_ZERO (temp[i]);

    y1 = *(MUL128*)(y);
	z1 = *(MUL128*)(z);

	#ifndef BIG_ENDIAN
		for (ui=8; ((ui>0) && (!y1.w[ui-1])); ui--);
		for (uj=8; ((uj>0) && (!z1.w[uj-1])); uj--);
		if ((ui+uj)<8)
		{
			tmin = ui+uj;
			tmax = 0;
		} else
		{
			tmin = 8;
			tmax = ui+uj-8;
		}
	#else
		ui=8;
		uj=8;
		tmin = 8;
		tmax = 8;
	#endif
	

	for (i=0; i<ui; i++)
	  for (j=0; j<uj; j++)
	  {
	   	#ifndef BIG_ENDIAN
		      meanterm = y1.w[i] * z1.w[j];
		#else
			  meanterm = y1.w[7-i] * z1.w[7-j];
		#endif	  
		IEL_ADDU (temp[i+j], temp[i+j], IEL32(meanterm));
	  }
	for (i=1; i<tmin; i++)
	  ovfl = IEL_SHL128 (temp[i], temp[i], 16*i) || ovfl;
	
	for (i=0; i<tmax; i++)
	  ovfl = !(IEL_ISZERO (temp[i+8])) || ovfl;
	
	IEL_ZERO (x);

	for (i=0; i<tmin; i++)
	  ovfl = IEL_ADDU (x, x, temp[i]) || ovfl;
	IEL_ASSIGNU (IEL128(*xr), x);
	return (ovfl);
}


/* char find_hi_bit(U128 x) 
{
	char place;
	long num, k;
	char parts[4];
	char j,part;

	
	if ((num = DW3(x))) place=96; else
	  if ((num = DW2(x))) place=64; else
		if ((num = DW1(x))) place=32; else
		  if ((num = DW0(x))) place=0; else
			return(0);
		  
	*(long *)(parts) = num;

	if ((part = parts[0])) place+=24; else
	  if ((part = parts[1])) place+=16; else
		if ((part = parts[2])) place+=8; else
		  part = parts[3];

	j = 8;
	k = 128;

	for (j=8, k=128; !(part & k); j--, k=k>>1);

	part+=j;
}
*/

	


	


IEL_Err IEL_rem(U128 *x, U128 *y, U128 *z)
{
	U128 	x1, y1, z1, t1, z2;
	long 	carry, i,j;
	
	
	if (IEL_ISZERO(*z)) 
	{
        IEL_ASSIGNU(*x, *y);
		return (IEL_OVFL);
	}

	IEL_ASSIGNU(y1, *y);
	IEL_ZERO(x1);

    while (IEL_CMPGEU(y1, *z))
	{
		IEL_CONVERT(t1, 1, 0, 0, 0);
		IEL_ASSIGNU(z1, *z);
		IEL_ASSIGNU(z2, z1);

		j = 0;
		for (i=64; i>0; i=i>>1)
		{
			carry = IEL_SHL(z2, z2, i);
			if (IEL_CMPGEU(y1, z2) && (!carry))
			{
				j+=i;
				IEL_ASSIGNU(z1, z2);
			} else
			{
				IEL_ASSIGNU(z2, z1);
			}
		}


		IEL_SHL(t1, t1, j);
		IEL_SUBU(y1, y1, z2);
		IEL_ADDU(x1, x1, t1);
	}
	IEL_ASSIGNU(IEL128(*x), y1);
	return (IEL_OK);
}

		

IEL_Err IEL_div(U128 *x, U128 *y, U128 *z)
{
	U128 	x1, y1, z1, t1, z2;
	long 	carry, i, j;
	
	IEL_ASSIGNU(y1, *y);
	IEL_ZERO(x1);
	

	if (IEL_ISZERO(*z)) 
	{
		(*x).dw3_128 = 0;
		return (IEL_OVFL);
	}

	while (IEL_CMPGEU (y1, *z))
	{
		IEL_CONVERT(t1, 1, 0, 0, 0);
		IEL_ASSIGNU(z1, *z);
		IEL_ASSIGNU(z2, z1);

		j = 0;
		for (i=64; i>0; i=i>>1)
		{
			carry = IEL_SHL(z2, z2, i);
			if (IEL_CMPGEU(y1, z2) && (!carry))
			{
				j+=i;
				IEL_ASSIGNU(z1, z2);
			} else
			{
				IEL_ASSIGNU(z2, z1);
			}
		}

		IEL_SHL(t1, t1, j);
		IEL_SUBU(y1, y1, z2);
		IEL_ADDU(x1, x1, t1);
	}
	IEL_ASSIGNU(IEL128(*x), x1);
	return (IEL_OK);
}


static void transpose(char *st)
{
	unsigned long i;
	char c;
	unsigned long len;

	len = strlen(st);
	for (i=0; i<(strlen(st)/2); i++)
	{
		c = st[i];
		st[i]=st[len-i-1];
		st[len-i-1]=c;
	}
}

static long leadzero(char *st)
{
	long j=0, i=0;
	while (st[i++]=='0') j++;
    return(j);
}

static void backzero(char *st)
{
	unsigned long i;
	i = strlen(st);
	while (st[--i]=='0');
	st[++i]='\0';
}



IEL_Err IEL_U128tostr(const U128 *x, char *strptr, int base, const unsigned int length)
{
	char	digit[17] = "0123456789abcdef";
	U128	x1, y1, z1, t1;
	unsigned long 	i, j = 0, k, len, lead;
	char    tempplace[1100];
	char	*tempstr = tempplace, negative = IEL_FALSE;
	unsigned long	dwtemp=0, bit;

		  
	IEL_ASSIGNU (t1, IEL128(*x));
	tempstr[0]='\0';

	if (base == 100)
	{
		if (IEL_ISNEG(t1))
		{
			IEL_COMPLEMENTS(t1, t1);
			negative = IEL_TRUE;
		}
		base = 10;
	}


	if IEL_ISZERO(t1) 
	{
		tempstr[0]='0';
		tempstr[1]='\0';
	} else

	if ((base==16) || (base == 116))
	{
		if (base ==16)
		{
			sprintf(tempstr,"%lx%08lx%08lx%08lx",DW3(t1),DW2(t1),DW1(t1),DW0(t1));
		} else
		{
			sprintf(tempstr,"%lX%08lX%08lX%08lX",DW3(t1),DW2(t1),DW1(t1),DW0(t1));
		}
		
		lead = leadzero(tempstr);
		for(i=lead; i<=strlen(tempstr); i++)
		{
			tempstr[i-lead]=tempstr[i];
		}
	} else
	  if (base==2)
	  {
		 len = 0;
		 for (j=0; j<4; j++)	
		 {
			 switch(j)
			 {
			   case 0:
				 dwtemp = DW0(t1);
				 break;
			   case 1:
				 dwtemp = DW1(t1);
				 break;
			   case 2:
				 dwtemp = DW2(t1);
				 break;
			   case 3:
				 dwtemp = DW3(t1);
				 break;
			 }
			 bit = 1;
			 for (i=0; i<32; i++)
			 {
				 if (bit & dwtemp)
				 {
					 tempstr[len]='1';
				 } else
				 {
					 tempstr[len]='0';
				 }
				 bit<<=1;
				 len++;
			 }
		 }
	 
		 tempstr[len]='\0';
		 transpose(tempstr);
		 lead = leadzero(tempstr);
		 for(i=lead; i<=strlen(tempstr); i++)
		 {
			 tempstr[i-lead]=tempstr[i];
		 }
	  } else
		if (base==10)
		{
			len=0;
			IEL_ASSIGNU(y1, t1);
			IEL_CONVERT(z1, 1000000000, 0, 0, 0);
			while (!IEL_ISZERO(y1))
			{
				IEL_rem (&x1, &y1, &z1);
				IEL_ASSIGNU (IEL32(i), x1);
				for (k=0; k<9; k++)
				{
					j=i%10;
					tempstr[len+1]='\0';
					tempstr[len]=digit[j];
					i=i/10;
					len++;
				}
				IEL_div(&y1, &y1, &z1);
			}
			if (negative)
			{
				backzero(tempstr);
				tempstr[strlen(tempstr)+1]='\0';
				tempstr[strlen(tempstr)]='-';
				transpose(tempstr);
			} else
			{
				transpose(tempstr);
				lead = leadzero(tempstr);
				for(i=lead; i<=strlen(tempstr); i++)
				{
					tempstr[i-lead]=tempstr[i];
				}
			}
		} else
		  if (base==8)
		  {
			  len=0;
			  IEL_ASSIGNU(y1, t1);
			  IEL_CONVERT(z1, 010000000000, 0, 0, 0);
			  while (!IEL_ISZERO(y1))
			  {
				IEL_rem (&x1, &y1, &z1);
				IEL_ASSIGNU (IEL32(i), x1);
				for (k=0; k<10; k++)
				{
					j=i%8;
					tempstr[len+1]='\0';
					tempstr[len]=digit[j];
					i=i/8;
					len++;
				}
				IEL_div(&y1, &y1, &z1);
			}
			  if (negative)
			  {
				  backzero(tempstr);
				  tempstr[strlen(tempstr)+1]='\0';
				  tempstr[strlen(tempstr)]='-';
				  transpose(tempstr);
			  } else
			  {
				  transpose(tempstr);
				  lead = leadzero(tempstr);
				  for(i=lead; i<=strlen(tempstr); i++)
				  {
					  tempstr[i-lead]=tempstr[i];
				  }
			  }
		  } else
		  {
			  IEL_ASSIGNU (z1, IEL32(base));
			  IEL_ASSIGNU (y1, t1);
			  while (!IEL_ISZERO(y1))
			  {
				  IEL_rem (&x1, &y1, &z1);
				  IEL_ASSIGNU (IEL32(i), x1);
				  tempstr[strlen(tempstr)+1]='\0';
				  tempstr[strlen(tempstr)]=digit[i];
				  IEL_div (&y1, &y1, &z1);
			  }
			  transpose(tempstr);
	  }

	if (length < strlen (tempstr)+1)
	{
		return (IEL_OVFL);
	} else
	{
		for (i=0; i<=strlen(tempstr); i++)
		  strptr[i]=tempstr[i];
		return (IEL_OK);
	}
}

IEL_Err IEL_U64tostr(const U64 *x, char *strptr, int  base, const unsigned int  length)
{
	U128 y;    

	IEL_ASSIGNU(y, (*x));
	return (IEL_U128tostr (&y, strptr, base, length));
}



IEL_Err IEL_S128tostr(const S128 *x, char *strptr, int  base, const unsigned int  length)
{
	U128 y;
	IEL_ASSIGNU(y, (*x));
	return(IEL_U128tostr( &y, strptr, base, length));
}

IEL_Err IEL_S64tostr(const S64 *x, char *strptr, int  base, const unsigned int  length)
{
	U128 y;

	IEL_SEXT(y, (*x));
	return(IEL_U128tostr( &y, strptr, base, length));
}	   	


	
IEL_Err IEL_strtoU128( char *str1, char **endptr, int base, U128 *x)
{
	U128	sum;
	unsigned long	i, j=0;
	int     negative=IEL_FALSE;
	unsigned long 	inbase, insum;
	IEL_Err ovfl = IEL_OK;
	

	if (str1[0]=='-')
	{
		negative = IEL_TRUE;
		str1++;
	}
	
	if (base == 0) 
	{
		if (str1[0]=='0')
		{
			if (strlen(str1)==1) 
			{
				IEL_ZERO((*x));
				return (IEL_OK);
			} else
			if (strchr("01234567",str1[1])) 
			{
				base = 8;
				str1++;
			} else
			{
				switch (str1[1])
				{
				  case 'B':
				  case 'b': base=2;
							str1+=2;
							break;
				  case 'X':
				  case 'x':
				  case 'H':
				  case 'h': base=16;
							str1+=2;
							break;
				  default:	return (IEL_OVFL);
				}
			}
		} else 
		{
			base = 10;
		}
	}
   
	switch(base)
	{
	  case 10:
		for (j=0; str1[j]>='0' && str1[j]<='9';)
		{
			insum = str1[j++]-'0';
			inbase = 10;
			i=1;
			while ((i<9) && str1[j]>='0' && str1[j]<='9')
			{
				i++;
				inbase = inbase * 10;
				insum *= 10;
				insum += str1[j++]-'0';
			}
			if (j<10)
			{
				IEL_ASSIGNU (sum, IEL32(insum));
			} else
			{
				ovfl = IEL_MULU(sum, sum, IEL32(inbase)) || ovfl;
				ovfl = IEL_ADDU(sum, sum, IEL32(insum)) || ovfl;
			}
		}
		break;
	  case 2:
		for (j=0; str1[j]>='0' && str1[j]<='1';)
		{
			insum = str1[j++]-'0';
			inbase = 1;
			i=1;
			while ((i<32) && str1[j]>='0' && str1[j]<='9')
			{
				i++;
				inbase++;
				insum *= 2;
				insum += str1[j++]-'0';
			}
			if (j<33)
			{
				IEL_ASSIGNU (sum, IEL32(insum));
			} else
			{
				ovfl = IEL_SHL128(sum, sum, inbase) || ovfl;
				ovfl = IEL_ADDU(sum, sum, IEL32(insum)) || ovfl;
			}
		}
		break;
	  case 8:
		for (j=0; str1[j]>='0' && str1[j]<='7';)
		{
			insum = str1[j++]-'0';
			inbase = 3;
			i=1;
			while ((i<10) && str1[j]>='0' && str1[j]<='7')
			{
				i++;
				inbase+=3;
				insum *= 8;
				insum += str1[j++]-'0';
			}
			if (j<11)
			{
				IEL_ASSIGNU (sum, IEL32(insum));
			} else
			{
				ovfl = IEL_SHL128(sum, sum, inbase) || ovfl;
				ovfl = IEL_ADDU(sum, sum, IEL32(insum)) || ovfl;
			}
		}
		break;
	  case 16:
		for (j=0; ((str1[j]>='0' && str1[j]<='9') ||
				   (tolower(str1[j])>='a' && tolower(str1[j]<='f'))); )
		{
			if (str1[j]<='9')
			{
				insum = str1[j++]-'0';
			} else
			{
				insum = tolower(str1[j++])-'a'+10;
			}
			inbase = 4;
			i=1;
			while ((i<8) && ((str1[j]>='0' && str1[j]<='9') ||
				   (tolower(str1[j])>='a' && tolower(str1[j]<='f'))))
			{
				i++;
				inbase += 4;
				insum *= 16;
				if (str1[j]<='9')
				{
					insum += (str1[j++]-'0');
				} else
				{
					insum += (tolower(str1[j++])-'a'+10);
				}
			}
			if (j<9)
			{
				IEL_ASSIGNU (sum, IEL32(insum));
			} else
			{
				ovfl = IEL_SHL128(sum, sum, inbase) || ovfl;
				ovfl = IEL_ADDU(sum, sum, IEL32(insum)) || ovfl;
			}
		}
		break;

	}


	IEL_ASSIGNU(IEL128(*x), sum);	
	if (negative)
	{
		ovfl = ovfl || (IEL_ISNEG(*x) && !IEL_ISNINF(*x));
		IEL_COMPLEMENTS(IEL128(*x), IEL128(*x));
	}
	*endptr = str1+j;
	if (ovfl)
	{
		IEL_CONVERT4((*x), 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);
	}
	return (ovfl);
}

IEL_Err IEL_strtoU64(char *str1, char **endptr, int base, U64 *x)
{
	U128	y1;

	IEL_Err ovfl = IEL_strtoU128(str1, endptr, base, &y1);
	ovfl = IEL_ASSIGNU((*x), y1) || ovfl;
	if (ovfl)
	{
		IEL_CONVERT2(*x, 0xFFFFFFFF, 0xFFFFFFFF);
	}
	return (ovfl);
	
}

IEL_Err IEL_strtoS128(char *str1, char **endptr, int base, S128 *x)
{
	U128	y1;

	IEL_Err ovfl = IEL_strtoU128(str1, endptr, base, &y1);
	if (str1[0] == '-')
	{
		IEL_ASSIGNU((*x), y1);
		if (ovfl)
		{
			IEL_CONVERT4(*x, 0, 0, 0, 0x80000000);
		}
	} else
	{
		IEL_ASSIGNU((*x), y1);
		ovfl = (IEL_ISNEG(y1)) || ovfl;
		if (ovfl)
		{
			IEL_CONVERT4(*x, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x7fffffff);
		}
	}

	return (ovfl);
	
}

IEL_Err IEL_strtoS64(char *str1, char **endptr, int base, S64 *x)
{
	U128	y1;

	IEL_Err ovfl = IEL_strtoU128(str1, endptr, base, &y1);
	if (str1[0] == '-')
	{
		ovfl = IEL_ASSIGNS((*x), y1) || ovfl;
		if (ovfl)
		{
			IEL_CONVERT2(*x, 0, 0x80000000);
		}
	} else
	{
		ovfl = IEL_ASSIGNU((*x), y1) || ovfl;
		ovfl = IEL_ISNEG(*x) || ovfl;
		if (ovfl)
		{
			IEL_CONVERT2(*x, 0xFFFFFFFF, 0x7fffffff);
		}
	}
	return (ovfl);
	
}

#ifndef LP64
int IEL_c0(void *x, int sx)
{

	U64 u64x;
	U128 u128x;

	/* sx can be only 64 or 128 bits */

	
    if (sx == sizeof(U64))
	{
		IEL_ASSIGNU(u64x,*((U64 *)(x)));
		return(IEL_R_C0(u64x));
	} else
	{
		IEL_ASSIGNU(u128x, *((U128 *)(x)));
		return(IEL_R_C0(u128x));
	}
}

int IEL_c1(void *x, int sx)
{

	U64 u64x;
	U128 u128x;

	/* sx can be only 64 or 128 bits */

	
    if (sx == sizeof(U64))
	{
		IEL_ASSIGNU(u64x,*((U64 *)(x)));
		return(IEL_R_C1(u64x));
	} else
	{
		IEL_ASSIGNU(u128x, *((U128 *)(x)));
		return(IEL_R_C1(u128x));
	}
}

int IEL_c2(void *x, int sx)
{

	U64 u64x;
	U128 u128x;

	/* sx can be only 64 or 128 bits */

	
    if (sx == sizeof(U64))
	{
		IEL_ASSIGNU(u64x,*((U64 *)(x)));
		return(IEL_R_C2(u64x));
	} else
	{
		IEL_ASSIGNU(u128x, *((U128 *)(x)));
		return(IEL_R_C2(u128x));
	}
}

int IEL_c3(void *x, int sx)
{

	U64 u64x;
	U128 u128x;

	/* sx can be only 64 or 128 bits */

	
    if (sx == sizeof(U64))
	{
		IEL_ASSIGNU(u64x,*((U64 *)(x)));
		return(IEL_R_C3(u64x));
	} else
	{
		IEL_ASSIGNU(u128x, *((U128 *)(x)));
		return(IEL_R_C3(u128x));
	}
}



int IEL_au(void *x, void *y, int sx, int sy)
{
        U128 tmp, zero;

		if (x==y)
		  return (IEL_OK);
		
        IEL_ZERO(zero);
        if (sx>=sy)
        {
                memset(x, 0, (size_t)sx);
                memcpy(x, y, (size_t)sy);
        } else
        {
                memset(&tmp, 0, sizeof(U128));
                memcpy(x, y, (size_t)sx);
                memcpy(&tmp, y, (size_t)sy);
                memset(&tmp, 0, (size_t)sx);
                if (memcmp(&zero, &tmp, sizeof(U128)))
                {
                        return(IEL_OVFL);
                }
        }
        return (IEL_OK);
}


IEL_Err IEL_as(void *x, void *y, int sx, int sy)
{
	S32		s32y;
	S64		s64y;
	S128	s128y;
	S32		s32x;
	S64		s64x;
	S128	s128x;
	IEL_Err	ov=IEL_OK;

	switch (sy)
	{
		case sizeof(S32): s32y = *(S32 *)y; IEL_SEXT(s128y, s32y); break;
		case sizeof(S64): s64y = *(S64 *)y; IEL_SEXT(s128y, s64y); break;
		case sizeof(S128): s128y = *(S128 *)y; break;
	}

	switch (sx)
	{
		case sizeof(S32):
			ov = IEL_REAL_ASSIGNS(s32x, s128y);
			memcpy((char *)x, (char *)&s32x, (size_t)sx);
			break;

		case sizeof(S64):
			ov = IEL_REAL_ASSIGNS(s64x, s128y);
			memcpy((char *)x, (char *)&s64x, (size_t)sx);
			break;

		case sizeof(S128):
			ov = IEL_REAL_ASSIGNS(s128x, s128y);
			memcpy((char *)x, (char *)&s128x, (size_t)sx);
			break;
	}
	return(ov);
}

#endif /* LP64 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\iel\iel_glob.c ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "iel.h"

#ifdef LP64
Ulong64         IEL_temp64;
#endif

unsigned int IEL_t1, IEL_t2, IEL_t3, IEL_t4;
U32  IEL_tempc;
U64  IEL_et1, IEL_et2;
U128 IEL_ext1, IEL_ext2, IEL_ext3, IEL_ext4, IEL_ext5;
S128 IEL_ts1, IEL_ts2;

U128 IEL_POSINF = IEL_CONST128(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x7fffffff);
U128 IEL_NEGINF = IEL_CONST128( 0,  0,  0, 0x80000000);
U128 IEL_MINUS1 = IEL_CONST128(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); /* added by myself, since there are
                                                                                   references to the variable in
                                                                                   iel.h (iel.h.base).              */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\include\em_perl.h ===
##
## Copyright (c) 2000, Intel Corporation
## All rights reserved.
##
## WARRANTY DISCLAIMER
##
## THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
## A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
## PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
## OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
## NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
## MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##
## Intel Corporation is the author of the Materials, and requests that all
## problem reports or change requests be submitted to it directly at
## http://developer.intel.com/opensource.
##

### Perl scripts header file

### EMDB flags (emdb_types.h) ###

$EM_FLAG_PRED                       = 0x1;
$EM_FLAG_PRIVILEGED                 = 0x2;
$EM_FLAG_LMEM                       = 0x4;
$EM_FLAG_SMEM                       = 0x8;
$EM_FLAG_CHECK_BASE_EQ_DST          = 0x10;
$EM_FLAG_FIRST_IN_INSTRUCTION_GROUP = 0x20;
$EM_FLAG_LAST_IN_INSTRUCTION_GROUP  = 0x40;
$EM_FLAG_CHECK_SAME_DSTS            = 0x80;
$EM_FLAG_SLOT2_ONLY                 = 0x100;
$EM_FLAG_TWO_SLOT                   = 0x200;
$EM_FLAG_OK_IN_MLX                  = 0x400;
$EM_FLAG_CHECK_EVEN_ODD_FREGS       = 0x800;
$EM_FLAG_CTYPE_UNC                  = 0x1000;
$EM_FLAG_UNUSED_HINT_ALIAS          = 0x02000;
$EM_FLAG_ILLEGAL_OP                 = 0x04000;
$EM_FLAG_IGNORED_OP                 = 0x08000;
$EM_FLAG_ENDS_INSTRUCTION_GROUP     = 0x10000;
$EMDB_LAST_FLAG                     = $EM_FLAG_ENDS_INSTRUCTION_GROUP;
$EMDB_MAX_FLAG                      = 17;


$MAX_EXTENSION = 8;
$MAX_OPERAND   = 6;

### EM flags (EM.h) ###

$EM_BUNDLE_SIZE       = 16;
$EM_SYLLABLE_BITS     = 41;
$EM_DISPERSAL_POS     = 0;
$EM_DISPERSAL_BITS    = 5;
$EM_SBIT_POS          = 0;
$EM_TEMPLATE_POS      = 1;
$EM_TEMPLATE_BITS     = 4;
$EM_NUM_OF_TEMPLATES  = (1<<$EM_TEMPLATE_BITS);

$EM_MAJOR_OPCODE_POS     = 37;
$EM_MAJOR_OPCODE_BITS    = 4;
$EM_NUM_OF_MAJOR_OPCODES = (1<<$EM_MAJOR_OPCODE_BITS);
$EM_PREDICATE_POS        = 0;
$EM_PREDICATE_BITS       = 6;


### Templates ###

$EM_template_mii   = 0;
$EM_template_mi_i  = 1;
$EM_template_mlx   = 2;
# 3  reserved
$EM_template_mmi   = 4;
$EM_template_m_mi  = 5;
$EM_template_mfi   = 6;
$EM_template_mmf   = 7;
$EM_template_mib   = 8;
$EM_template_mbb   = 9;
# 10 reserved
$EM_template_bbb   = 11;
$EM_template_mmb   = 12;
# 13 reserved
$EM_template_mfb   = 14;
# 15 reserved
$EM_template_last  = 15;


### Template roles ###

$EM_TROLE_NONE  = 0;
$EM_TROLE_ALU   = 1;
$EM_TROLE_BR    = 2;
$EM_TROLE_FP    = 3;
$EM_TROLE_INT   = 4;
$EM_TROLE_LONG  = 5;
$EM_TROLE_MEM   = 6;
$EM_TROLE_MIBF  = 7;
$EM_TROLE_LAST  = 8;

$EM_NUM_OF_TROLES = $EM_TROLE_LAST;

### number of registers ###

$EM_NUM_OF_KREGS  = 8; #kernel registers are AREGS


1; ### Return value

### application registers ###
%EM_AR_NAMES =
(
  AR_KR0 ,0,
  AR_KR1 ,1,
  AR_KR2 ,2,
  AR_KR3 ,3,
  AR_KR4 ,4,
  AR_KR5 ,5,
  AR_KR6 ,6,
  AR_KR7 ,7,
  ### ar8-15 reserved ###
  AR_RSC ,16,
  AR_BSP ,17,
  AR_BSPSTORE,18,
  AR_RNAT,19,
  ### ar20 reserved ###
  AR_FCR ,21,
  ### ar22-23 reserved ###
  AR_EFLAG ,24,
  AR_CSD   ,25,
  AR_SSD   ,26,
  AR_CFLG  ,27,
  AR_FSR   ,28,
  AR_FIR   ,29,
  AR_FDR   ,30,
  ### ar31 reserved ###
  AR_CCV   ,32,
  ### ar33-35 reserved ###
  AR_UNAT,36,
  ### ar37-39 reserved ###
  AR_FPSR,40,
  ### ar41-43 reserved ###
  AR_ITC ,44,
  ### ar45-47 reserved ###
  ### ar48-63 ignored ###
  AR_PFS ,64,
  AR_LC  ,65,
  AR_EC  ,66,
  ### ar67-111 reserved ###
  ### ar112-128 ignored ###
 );

%EM_CR_NAMES =
(
  CR_DCR ,0,
  CR_ITM ,1,
  CR_IVA ,2,
  ### 3-7 reserved ###
  CR_PTA ,8,
  CR_GPTA,9,
  ### 10-15 reserved ###
  CR_IPSR,16,
  CR_ISR ,17,
  ### 18 reserved ###
  CR_IIP ,19,
  CR_IFA ,20,
  CR_ITIR,21,
  CR_IIPA,22,
  CR_IFS ,23,
  CR_IIM ,24,
  CR_IHA ,25,
  ### 25-63 reserved ###
  ### SAPIC registers ###
  CR_LID ,64,
  CR_IVR ,65,
  CR_TPR ,66,
  CR_EOI ,67,
  CR_IRR0,68,
  CR_IRR1,69,
  CR_IRR2,70,
  CR_IRR3,71,
  CR_ITV ,72,
  CR_PMV ,73,
  CR_CMCV,74,
  ### 75-79 reserved  ###
  CR_LRR0,80,
  CR_LRR1,81,
  ### 82-127 reserved ###
 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\include\em_tools.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef _EM_TOOLS_H
#define _EM_TOOLS_H

typedef struct EM_version_s
{
	int      major;
	int      minor;
} EM_version_t;

typedef struct EM_library_version_s
{
	EM_version_t   xversion;
	EM_version_t   api;
	EM_version_t   emdb;
    char           date[12];
    char           time[9];
} EM_library_version_t;

#endif /* _EM_TOOLS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\certify.cxx ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    certify.cxx

Abstract:

    This is the command line tool to manipulate certificates on an executable image.

Author:

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#include <private.h>

#if 1
#define TEST 1
#else
#define TEST 0
#endif

void
PrintUsage(
    VOID)
{
    fputs("usage: CERTIFY [switches] image-names... \n"
          "            [-?] display this message\n"
          "            [-l] list the certificates in an image\n"
          "            [-a:<Filename>] add a certificate file to an image\n"
          "            [-r:<index>]    remove certificate <index> from an image\n"
          "            [-g:<Filename>] update any associated .DBG file\n"
          "            [-s:<Filename>] used with -r to save the removed certificate\n",
          stderr
         );
    exit(-1);
}

#if TEST
// Test routine
BOOL  fAllDataReturned;
PVOID pvDataRefTest;
DWORD FileSize;
DWORD DataRead;

BOOL
WINAPI
DigestRoutine (
    DIGEST_HANDLE   DataReference,
    PBYTE           pData,
    DWORD           dwLength
    )
{
    if (DataReference != pvDataRefTest) {
        return(FALSE);
    }

    // Attempt to read the range

    if (IsBadReadPtr(pData, dwLength)) {
        return(FALSE);
    }

    DataRead += dwLength;
    if (DataRead > FileSize) {
        return(FALSE);
    }

    return(TRUE);
}

#endif


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *p;

    if (argc < 2) {
        PrintUsage();
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
                case '?':
                    PrintUsage();
                    break;

                case 'A':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {

                        // Add a certificate file to an image.
#if TEST
                        // Test code

                        WIN_CERTIFICATE wc;
                        HANDLE  Handle;
                        DWORD   Index;

                        wc.dwLength = sizeof(WIN_CERTIFICATE);
                        wc.wCertificateType = WIN_CERT_TYPE_X509;

                        if ((Handle = CreateFile(TEXT("test.exe"),
                                    GENERIC_WRITE | GENERIC_READ,
                                    0,
                                    0,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
                        {
                            fputs("Unable to open test.exe", stderr);
                            exit(1);
                        }

                        printf("ImageAddCertificate on test.exe returned: %d\n",
                                ImageAddCertificate(Handle, &wc, &Index));

                        printf("Index #: %d\n", Index);

                        CloseHandle(Handle);

                        exit(0);
#else
                    // The real code
#endif
                    }
                    break;

                case 'L':
                    // List the certificates in an image.
#if TEST
                    // Test code
                    WIN_CERTIFICATE wc;
                    HANDLE  Handle;
                    DWORD   Index;

                    if ((Handle = CreateFileA("test.exe",
                                GENERIC_READ,
                                0,
                                0,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) == INVALID_HANDLE_VALUE)
                    {
                        fputs("Unable to open test.exe", stderr);
                        exit(1);
                    }

                    ImageEnumerateCertificates(Handle, CERT_SECTION_TYPE_ANY, &Index, NULL, 0);

                    printf("Enumerate lists: %d\n", Index);

                    Index--;

                    while (ImageGetCertificateHeader(Handle, Index, &wc)) {
                        printf("Index: %d\n", Index);
                        Index--;
                    }

                    CloseHandle(Handle);

                    exit(0);

#else
                    // The real code
#endif
                    break;

                case 'R':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Remove a specific certificate from an image.
#if TEST
                        // Test code

                        HANDLE  Handle;

                        if ((Handle = CreateFile(TEXT("test.exe"),
                                    GENERIC_WRITE | GENERIC_READ,
                                    0,
                                    0,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
                        {
                            fputs("Unable to open test.exe", stderr);
                            exit(1);
                        }

                        printf("ImageRemoveCertificate(0) on test.exe returned: %d\n",
                            ImageRemoveCertificate(Handle, 0));
                        exit(0);
#else
                        // The real code
#endif
                    }
                    break;

                case 'G':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        p++;
                        // Generate a certificate from an image.
#if TEST
                        // Test code

                        HANDLE  Handle;
                        LPSTR FileName=p;

                        if ((Handle = CreateFileA(FileName,
                                    GENERIC_READ,
                                    0,
                                    0,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
                        {
                            fprintf(stderr, "Unable to open %s", FileName);
                            exit(1);
                        }

                        FileSize = GetFileSize(Handle, NULL);
                        DataRead = 0;

                        pvDataRefTest = (PVOID) 1;
                        printf("ImageGetDigestStream debug w/o resources on %s returned: %s\tGetLastError(): %d\n",
                               FileName,
                            ImageGetDigestStream(Handle,
                                                 CERT_PE_IMAGE_DIGEST_DEBUG_INFO,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        DataRead = 0;
                        pvDataRefTest = (PVOID) 2;
                        printf("ImageGetDigestStream debug w/ resources %s returned: %s\tGetLastError(): %d\n",
                               FileName,
                            ImageGetDigestStream(Handle,
                                                 CERT_PE_IMAGE_DIGEST_DEBUG_INFO | CERT_PE_IMAGE_DIGEST_RESOURCES,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        DataRead = 0;
                        pvDataRefTest = (PVOID) 3;
                        printf("ImageGetDigestStream w/o debug w/o resources on %s returned: %s\tGetLastError(): %d\n",
                               FileName,
                            ImageGetDigestStream(Handle,
                                                 0,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        DataRead = 0;
                        pvDataRefTest = (PVOID) 4;
                        printf("ImageGetDigestStream w/o debug w/ resources %s returned: %s\tGetLastError(): %d\n",
                               FileName,
                            ImageGetDigestStream(Handle,
                                                 CERT_PE_IMAGE_DIGEST_RESOURCES,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        exit(0);

#else
                        // Real code
#endif
                    }
                    break;

                case 'S':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Save the certificate in some file.
                    }
                    break;

                default:
                    fprintf( stderr, "CERTIFY: Invalid switch - /%c\n", c );
                    PrintUsage();
                    break;
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\bindi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    bindi.c

Abstract:
    Implementation for the BindImage API

Author:

Revision History:

--*/

#ifndef _STRSAFE_H_INCLUDED_
#include <strsafe.h>
#endif

typedef struct _BOUND_FORWARDER_REFS {
    struct _BOUND_FORWARDER_REFS *Next;
    ULONG TimeDateStamp;
    LPSTR ModuleName;
} BOUND_FORWARDER_REFS, *PBOUND_FORWARDER_REFS;

typedef struct _IMPORT_DESCRIPTOR {
    struct _IMPORT_DESCRIPTOR *Next;
    LPSTR ModuleName;
    ULONG TimeDateStamp;
    USHORT NumberOfModuleForwarderRefs;
    PBOUND_FORWARDER_REFS Forwarders;
} IMPORT_DESCRIPTOR, *PIMPORT_DESCRIPTOR;

typedef struct _BINDP_PARAMETERS {
    DWORD Flags;
    BOOLEAN fNoUpdate;
    BOOLEAN fNewImports;
    LPSTR ImageName;
    LPSTR DllPath;
    LPSTR SymbolPath;
    PIMAGEHLP_STATUS_ROUTINE StatusRoutine;
} BINDP_PARAMETERS, *PBINDP_PARAMETERS;

BOOL
BindpLookupThunk(
    PBINDP_PARAMETERS Parms,
    PIMAGE_THUNK_DATA ThunkName,
    PLOADED_IMAGE Image,
    PIMAGE_THUNK_DATA SnappedThunks,
    PIMAGE_THUNK_DATA FunctionAddress,
    PLOADED_IMAGE Dll,
    PIMAGE_EXPORT_DIRECTORY Exports,
    PIMPORT_DESCRIPTOR NewImport,
    LPSTR DllPath,
    PULONG *ForwarderChain
    );

PVOID
BindpRvaToVa(
    PBINDP_PARAMETERS Parms,
    ULONG Rva,
    PLOADED_IMAGE Image
    );

ULONG64
BindpRvaToTargetVa64(
    PBINDP_PARAMETERS Parms,
    ULONG Rva,
    PLOADED_IMAGE Image
    );

ULONG
BindpRvaToTargetVa32(
    PBINDP_PARAMETERS Parms,
    ULONG Rva,
    PLOADED_IMAGE Image
    );

VOID
BindpWalkAndProcessImports(
    PBINDP_PARAMETERS Parms,
    PLOADED_IMAGE Image,
    LPSTR DllPath,
    PBOOL ImageModified
    );

BOOL
BindImage(
    IN LPSTR ImageName,
    IN LPSTR DllPath,
    IN LPSTR SymbolPath
    )
{
    return BindImageEx( 0,
                        ImageName,
                        DllPath,
                        SymbolPath,
                        NULL
                      );
}

UCHAR BindpCapturedModuleNames[4096];
LPSTR BindpEndCapturedModuleNames;

LPSTR
BindpCaptureImportModuleName(
    LPSTR DllName
    )
{
    LPSTR s;

    s = (LPSTR) BindpCapturedModuleNames;
    if (BindpEndCapturedModuleNames == NULL) {
        *s = '\0';
        BindpEndCapturedModuleNames = s;
        }

    while (*s) {
        if (!_stricmp(s, DllName)) {
            return s;
            }

        s += strlen(s)+1;
        }

    StringCchCopy(s, 4095 - (s - (LPSTR)BindpCapturedModuleNames), DllName);
    BindpEndCapturedModuleNames = s + strlen(s) + 1;
    *BindpEndCapturedModuleNames = '\0';
    return s;
}

PIMPORT_DESCRIPTOR
BindpAddImportDescriptor(
    PBINDP_PARAMETERS Parms,
    PIMPORT_DESCRIPTOR *NewImportDescriptor,
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor,
    LPSTR ModuleName,
    PLOADED_IMAGE Dll
    )
{
    PIMPORT_DESCRIPTOR p, *pp;

    if (!Parms->fNewImports) {
        return NULL;
        }

    pp = NewImportDescriptor;
    while (p = *pp) {
        if (!_stricmp( p->ModuleName, ModuleName )) {
            return p;
            }

        pp = &p->Next;
        }
#ifdef STANDALONE_BIND
    p = (PIMPORT_DESCRIPTOR) calloc( sizeof( *p ), 1);
#else
    p = (PIMPORT_DESCRIPTOR) MemAlloc( sizeof( *p ) );
#endif
    if (p != NULL) {
        if (Dll != NULL) {
            p->TimeDateStamp = ((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader.TimeDateStamp;
            }
        p->ModuleName = BindpCaptureImportModuleName( ModuleName );
        *pp = p;
        }
    else
    if (Parms->StatusRoutine != NULL) {
        if (Parms->Flags & BIND_REPORT_64BIT_VA)
             ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindOutOfMemory, NULL, NULL, 0, sizeof( *p ) );
        else 
             (Parms->StatusRoutine)( BindOutOfMemory, NULL, NULL, 0, sizeof( *p ) );
        }

    return p;
}


ULONG64
BindpAddForwarderReference(
    PBINDP_PARAMETERS Parms,
    LPSTR ImageName,
    LPSTR ImportName,
    PIMPORT_DESCRIPTOR NewImportDescriptor,
    LPSTR DllPath,
    PUCHAR ForwarderString,
    PBOOL BoundForwarder
    )
{
    CHAR DllName[ MAX_PATH + 1 ];
    PUCHAR s;
    PLOADED_IMAGE Dll;
    ULONG cb;
    USHORT OrdinalNumber;
    USHORT HintIndex;
    ULONG ExportSize;
    PIMAGE_EXPORT_DIRECTORY Exports;
    ULONG64 ExportBase;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    LPSTR NameTableName;
    ULONG64 ForwardedAddress;
    PBOUND_FORWARDER_REFS p, *pp;

    *BoundForwarder = FALSE;
BindAnotherForwarder:

    //
    // A forwarder string looks like "dllname.apiname".  See what we've got.
    // 

    s = ForwarderString;
    while (*s && *s != '.') {
        s++;
    }
    if (*s != '.') {
        // Missing period - malformed.
        return (ULONG64)ForwarderString;
    }
    cb = (ULONG) (s - ForwarderString);
    if (cb >= MAX_PATH) {
        // Name of dll is too long - malformed.
        return (ULONG64)ForwarderString;
    }
    strncpy( DllName, (LPSTR) ForwarderString, cb );
    DllName[ cb ] = '\0';
    StringCchCat( DllName, MAX_PATH, ".DLL" );

    //
    // Got the dll name - try loading.
    //

    Dll = ImageLoad( DllName, DllPath );
    if (!Dll) {
        // No luck - exit.
        return (ULONG64)ForwarderString;
    }

    //
    // Look for exports in the loaded image.
    // 

    Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData( Dll->MappedAddress, FALSE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportSize );
    if (!Exports) {
        // No luck - exit.
        return (ULONG64)ForwarderString;
    }

    //
    // Advance past the '.' and let's see what the api name is.
    //

    s += 1;

    if ( *s == '#' ) {
        // Binding for ordinal forwarders

        OrdinalNumber = (atoi((PCHAR)s + 1)) - (USHORT)Exports->Base;

        if (OrdinalNumber >= Exports->NumberOfFunctions) {
            return (ULONG64)ForwarderString;
        }
    } else {
        // Regular binding for named forwarders

        OrdinalNumber = 0xFFFF;
    }

    NameTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfNames, Dll );
    NameOrdinalTableBase = (PUSHORT) BindpRvaToVa( Parms, Exports->AddressOfNameOrdinals, Dll );
    FunctionTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfFunctions, Dll );

    if (OrdinalNumber == 0xFFFF) {
        for ( HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++){
            NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
            if ( NameTableName ) {
                OrdinalNumber = NameOrdinalTableBase[HintIndex];

                if (!strcmp((PCHAR)s, NameTableName)) {
                    break;
                }
            }
        }

        if (HintIndex >= Exports->NumberOfNames) {
            return (ULONG64)ForwarderString;
        }
    }

    do {
        pp = &NewImportDescriptor->Forwarders;

        // See if we've already added this dll to the list of forwarder dll's

        while (p = *pp) {
            if (!_stricmp(DllName, p->ModuleName)) {
                break;
            }

            pp = &p->Next;
        }

        if (!p) {

            // Nope - allocate a new record and add it to the list.

#ifdef STANDALONE_BIND
            p = (PBOUND_FORWARDER_REFS) calloc( sizeof( *p ), 1 );
#else
            p = (PBOUND_FORWARDER_REFS) MemAlloc( sizeof( *p ) );
#endif
            if (!p) {

                // Unable to allocate a new import descriptor - can't bind this one.

                if (Parms->StatusRoutine) {
                    if (Parms->Flags & BIND_REPORT_64BIT_VA)
                        ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindOutOfMemory, NULL, NULL, 0, sizeof( *p ) );
                    else
                       (Parms->StatusRoutine)( BindOutOfMemory, NULL, NULL, 0, sizeof( *p ) );
                }

                return (ULONG64)ForwarderString;

            } else {

                // Save the timestamp and module name
    
                p->ModuleName = BindpCaptureImportModuleName( DllName );
                p->TimeDateStamp = Dll->FileHeader->FileHeader.TimeDateStamp;
                *pp = p;
                NewImportDescriptor->NumberOfModuleForwarderRefs += 1;
            }
        }

        // Convert to real address.
        
        ForwardedAddress = FunctionTableBase[OrdinalNumber];
        if (Dll->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            ForwardedAddress += ((PIMAGE_NT_HEADERS64)Dll->FileHeader)->OptionalHeader.ImageBase; 
        } else {
            ForwardedAddress += ((PIMAGE_NT_HEADERS32)Dll->FileHeader)->OptionalHeader.ImageBase; 
        }

        if (Parms->StatusRoutine) {
            if (Parms->Flags & BIND_REPORT_64BIT_VA)
                 ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) (BindForwarder64,
                                                                       ImageName,
                                                                       ImportName,
                                                                       ForwardedAddress,
                                                                       (ULONG_PTR)ForwarderString
                                                                       );
            else
                 (Parms->StatusRoutine)( BindForwarder,
                                         ImageName,
                                         ImportName,
                                         (ULONG_PTR)ForwardedAddress,
                                         (ULONG_PTR)ForwarderString
                                       );
        }

        //
        // Calculate the inmemory export table for this dll to see if the forwarded
        // address we have is inside the new export table.  TRUE is passed for MappedAsImage
        // parm to ImageDirectoryEntryToData so we can get a real VA.
        //

        ExportBase = (ULONG64)ImageDirectoryEntryToData(Dll->MappedAddress, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportSize);

        //
        // Convert mapped virtual address to real virtual address.
        //

        ExportBase -= (ULONG64) Dll->MappedAddress;

        if (Dll->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            ExportBase += ((PIMAGE_NT_HEADERS64)Dll->FileHeader)->OptionalHeader.ImageBase;
        } else {
            ExportBase += ((PIMAGE_NT_HEADERS32)Dll->FileHeader)->OptionalHeader.ImageBase;
        }

        if ((ForwardedAddress >= ExportBase) && (ForwardedAddress < (ExportBase + ExportSize))) {

            // Address is inside the export table - convert to string and try again.

            ForwarderString = (PUCHAR) BindpRvaToVa(Parms, FunctionTableBase[OrdinalNumber],Dll);
            goto BindAnotherForwarder;
        } else {
            *BoundForwarder = TRUE;
            break;
        }
    }
    while (0);

    return ForwardedAddress;
}


PIMAGE_BOUND_IMPORT_DESCRIPTOR
BindpCreateNewImportSection(
    PBINDP_PARAMETERS Parms,
    PIMPORT_DESCRIPTOR *NewImportDescriptor,
    PULONG NewImportsSize
    )
{
    ULONG cbString, cbStruct;
    PIMPORT_DESCRIPTOR p, *pp;
    PBOUND_FORWARDER_REFS p1, *pp1;
    LPSTR CapturedStrings;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImports, NewImport;
    PIMAGE_BOUND_FORWARDER_REF NewForwarder;


    *NewImportsSize = 0;
    cbString = 0;
    cbStruct = 0;
    pp = NewImportDescriptor;
    while (p = *pp) {
        cbStruct += sizeof( IMAGE_BOUND_IMPORT_DESCRIPTOR );
        pp1 = &p->Forwarders;
        while (p1 = *pp1) {
            cbStruct += sizeof( IMAGE_BOUND_FORWARDER_REF );
            pp1 = &p1->Next;
            }

        pp = &p->Next;
        }
    if (cbStruct == 0) {
        BindpEndCapturedModuleNames = NULL;
        return NULL;
        }
    cbStruct += sizeof(IMAGE_BOUND_IMPORT_DESCRIPTOR);    // Room for terminating zero entry
    cbString = (ULONG) (BindpEndCapturedModuleNames - (LPSTR) BindpCapturedModuleNames);
    BindpEndCapturedModuleNames = NULL;
    *NewImportsSize = cbStruct+((cbString + sizeof(ULONG) - 1) & ~(sizeof(ULONG)-1));
#ifdef STANDALONE_BIND
    NewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR) calloc( *NewImportsSize, 1 );
#else
    NewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR) MemAlloc( *NewImportsSize );
#endif
    if (NewImports != NULL) {
        CapturedStrings = (LPSTR)NewImports + cbStruct;
        memcpy(CapturedStrings, BindpCapturedModuleNames, cbString);

        NewImport = NewImports;
        pp = NewImportDescriptor;
        while (p = *pp) {
            NewImport->TimeDateStamp = p->TimeDateStamp;
            NewImport->OffsetModuleName = (USHORT)(cbStruct + (p->ModuleName - (LPSTR) BindpCapturedModuleNames));
            NewImport->NumberOfModuleForwarderRefs = p->NumberOfModuleForwarderRefs;

            NewForwarder = (PIMAGE_BOUND_FORWARDER_REF)(NewImport+1);
            pp1 = &p->Forwarders;
            while (p1 = *pp1) {
                NewForwarder->TimeDateStamp = p1->TimeDateStamp;
                NewForwarder->OffsetModuleName = (USHORT)(cbStruct + (p1->ModuleName - (LPSTR) BindpCapturedModuleNames));
                NewForwarder += 1;
                pp1 = &p1->Next;
                }
            NewImport = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)NewForwarder;

            pp = &p->Next;
            }
        }
    else
    if (Parms->StatusRoutine != NULL) {
        if (Parms->Flags & BIND_REPORT_64BIT_VA)
             ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindOutOfMemory, NULL, NULL, 0, *NewImportsSize );
        else 
            (Parms->StatusRoutine)( BindOutOfMemory, NULL, NULL, 0, *NewImportsSize );
        }

    pp = NewImportDescriptor;
    while ((p = *pp) != NULL) {
        *pp = p->Next;
        pp1 = &p->Forwarders;
        while ((p1 = *pp1) != NULL) {
            *pp1 = p1->Next;
#ifdef STANDALONE_BIND
            free(p1);
#else
            MemFree(p1);
#endif
            }

#ifdef STANDALONE_BIND
        free(p);
#else
        MemFree(p);
#endif
        }

    return NewImports;
}

BOOL
BindpExpandImageFileHeaders(
    PBINDP_PARAMETERS Parms,
    PLOADED_IMAGE Dll,
    ULONG NewSizeOfHeaders
    )
{
    HANDLE hMappedFile;
    LPVOID lpMappedAddress;
    DWORD dwFileSizeLow, dwOldFileSize;
    DWORD dwFileSizeHigh;
    DWORD dwSizeDelta;
    PIMAGE_SECTION_HEADER Section;
    ULONG SectionNumber;
    PIMAGE_DEBUG_DIRECTORY DebugDirectories;
    ULONG DebugDirectoriesSize;
    ULONG OldSizeOfHeaders;
    PIMAGE_FILE_HEADER FileHeader;

    dwFileSizeLow = GetFileSize( Dll->hFile, &dwFileSizeHigh );
    if (dwFileSizeLow == 0xFFFFFFFF || dwFileSizeHigh != 0) {
        return FALSE;
    }

    FileHeader = &((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader;

    OldSizeOfHeaders = Dll->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC ?
        ((PIMAGE_NT_HEADERS64)Dll->FileHeader)->OptionalHeader.SizeOfHeaders :
        ((PIMAGE_NT_HEADERS32)Dll->FileHeader)->OptionalHeader.SizeOfHeaders;
    dwOldFileSize = dwFileSizeLow;
    dwSizeDelta = NewSizeOfHeaders - OldSizeOfHeaders;
    dwFileSizeLow += dwSizeDelta;

    hMappedFile = CreateFileMapping(Dll->hFile,
                                    NULL,
                                    PAGE_READWRITE,
                                    dwFileSizeHigh,
                                    dwFileSizeLow,
                                    NULL
                                   );
    if (!hMappedFile) {
        return FALSE;
    }


    FlushViewOfFile(Dll->MappedAddress, Dll->SizeOfImage);
    UnmapViewOfFile(Dll->MappedAddress);
    lpMappedAddress = MapViewOfFileEx(hMappedFile,
                                      FILE_MAP_WRITE,
                                      0,
                                      0,
                                      0,
                                      Dll->MappedAddress
                                     );
    if (!lpMappedAddress) {
        lpMappedAddress = MapViewOfFileEx(hMappedFile,
                                          FILE_MAP_WRITE,
                                          0,
                                          0,
                                          0,
                                          0
                                         );
    }

    CloseHandle(hMappedFile);

    if (lpMappedAddress != Dll->MappedAddress) {
        Dll->MappedAddress = (PUCHAR) lpMappedAddress;
        CalculateImagePtrs(Dll);
        FileHeader = &((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader;
    }

    if (Dll->SizeOfImage != dwFileSizeLow) {
        Dll->SizeOfImage = dwFileSizeLow;
    }

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(
                                            (PVOID)Dll->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_DEBUG,
                                            &DebugDirectoriesSize
                                            );

    if (DebugDirectoryIsUseful(DebugDirectories, DebugDirectoriesSize)) {
        while (DebugDirectoriesSize != 0) {
            DebugDirectories->PointerToRawData += dwSizeDelta;
            DebugDirectories += 1;
            DebugDirectoriesSize -= sizeof( *DebugDirectories );
        }
    }

    if (Dll->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        ((PIMAGE_NT_HEADERS64)Dll->FileHeader)->OptionalHeader.SizeOfHeaders = NewSizeOfHeaders;
    } else {
        ((PIMAGE_NT_HEADERS32)Dll->FileHeader)->OptionalHeader.SizeOfHeaders = NewSizeOfHeaders;
    }
    if (FileHeader->PointerToSymbolTable != 0) {
        // Only adjust if it's already set

        FileHeader->PointerToSymbolTable += dwSizeDelta;
    }
    Section = Dll->Sections;
    for (SectionNumber=0; SectionNumber<FileHeader->NumberOfSections; SectionNumber++) {
        if (Section->PointerToRawData != 0) {
            Section->PointerToRawData += dwSizeDelta;
        }
        if (Section->PointerToRelocations != 0) {
            Section->PointerToRelocations += dwSizeDelta;
        }
        if (Section->PointerToLinenumbers != 0) {
            Section->PointerToLinenumbers += dwSizeDelta;
        }
        Section += 1;
    }

    memmove((LPSTR)lpMappedAddress + NewSizeOfHeaders,
            (LPSTR)lpMappedAddress + OldSizeOfHeaders,
            dwOldFileSize - OldSizeOfHeaders
           );

    if (Parms->StatusRoutine != NULL) {
        if (Parms->Flags & BIND_REPORT_64BIT_VA)
             ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindExpandFileHeaders, Dll->ModuleName, NULL, 0, NewSizeOfHeaders);
        else
            (Parms->StatusRoutine)( BindExpandFileHeaders, Dll->ModuleName, NULL, 0, NewSizeOfHeaders );
    }

    return TRUE;
}

BOOL
BindImageEx(
    IN DWORD Flags,
    IN LPSTR ImageName,
    IN LPSTR DllPath,
    IN LPSTR SymbolPath,
    IN PIMAGEHLP_STATUS_ROUTINE StatusRoutine
    )
{
    BINDP_PARAMETERS Parms;
    LOADED_IMAGE LoadedImageBuffer;
    PLOADED_IMAGE LoadedImage;
    ULONG CheckSum;
    ULONG HeaderSum;
    BOOL fSymbolsAlreadySplit, fRC;
    SYSTEMTIME SystemTime;
    FILETIME LastWriteTime;
    BOOL ImageModified;
    DWORD OldChecksum;
    CHAR DebugFileName[ MAX_PATH + 1 ];
    CHAR DebugFilePath[ MAX_PATH ];
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    Parms.Flags         = Flags;
    if (Flags & BIND_NO_BOUND_IMPORTS) {
        Parms.fNewImports = FALSE;
    } else {
        Parms.fNewImports = TRUE;
    }
    if (Flags & BIND_NO_UPDATE) {
        Parms.fNoUpdate = TRUE;
    } else {
        Parms.fNoUpdate = FALSE;
    }
    Parms.ImageName     = ImageName;
    Parms.DllPath       = DllPath;
    Parms.SymbolPath    = SymbolPath;
    Parms.StatusRoutine = StatusRoutine;

    fRC = FALSE;            // Assume we'll fail to bind

    __try {

        // Map and load the image

        LoadedImage = &LoadedImageBuffer;
        memset( LoadedImage, 0, sizeof( *LoadedImage ) );
        if (MapAndLoad( ImageName, DllPath, LoadedImage, TRUE, Parms.fNoUpdate )) {
            LoadedImage->ModuleName = ImageName;

            //
            // Now locate and walk through and process the images imports
            //
            if (LoadedImage->FileHeader != NULL &&
                ((Flags & BIND_ALL_IMAGES) || (!LoadedImage->fSystemImage)) ) {

                FileHeader = &((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader)->FileHeader;
                OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader,
                                             &OptionalHeader32,
                                             &OptionalHeader64);

                if (OPTIONALHEADER(DllCharacteristics) & IMAGE_DLLCHARACTERISTICS_NO_BIND) {
                    goto NoBind;
                }

                {
                    DWORD dwDataSize;
                    PVOID pData = ImageDirectoryEntryToData(
                                                        LoadedImage->MappedAddress,
                                                        FALSE,
                                                        IMAGE_DIRECTORY_ENTRY_SECURITY,
                                                        &dwDataSize
                                                        );

                    if (pData || dwDataSize) {
                        // Signed - can't bind it.
                        goto NoBind;
                    }

                    pData = ImageDirectoryEntryToData(
                                                      LoadedImage->MappedAddress,
                                                      FALSE,
                                                      IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                                      &dwDataSize
                                                      );
            
                    if (pData || dwDataSize) {
                        // COR header found - see if it's strong signed or contains IL only
                        if ((((IMAGE_COR20_HEADER *)pData)->Flags & COMIMAGE_FLAGS_STRONGNAMESIGNED) ||
                            (((IMAGE_COR20_HEADER *)pData)->Flags & COMIMAGE_FLAGS_ILONLY))
                        {
                            goto NoBind;
                        }
                    }
                }


                BindpWalkAndProcessImports(
                                &Parms,
                                LoadedImage,
                                DllPath,
                                &ImageModified
                                );

                //
                // If the file is being updated, then recompute the checksum.
                // and update image and possibly stripped symbol file.
                //

                if (!Parms.fNoUpdate && ImageModified &&
                    (LoadedImage->hFile != INVALID_HANDLE_VALUE)) {
                    // The image may have been moved as part of the growing it to add space for the
                    // bound imports.  Recalculate the file and optional headers.
                    FileHeader = &((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader)->FileHeader;
                    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader,
                                                 &OptionalHeader32,
                                                 &OptionalHeader64);
    
                    if ( (FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) &&
                         (SymbolPath != NULL) ) {
                        PIMAGE_DEBUG_DIRECTORY DebugDirectories;
                        ULONG DebugDirectoriesSize;
                        PIMAGE_DEBUG_MISC MiscDebug;

                        fSymbolsAlreadySplit = TRUE;
                        StringCchCopy( DebugFileName, MAX_PATH, ImageName );
                        DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(
                                                                LoadedImage->MappedAddress,
                                                                FALSE,
                                                                IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                                &DebugDirectoriesSize
                                                                );
                        if (DebugDirectoryIsUseful(DebugDirectories, DebugDirectoriesSize)) {
                            while (DebugDirectoriesSize != 0) {
                                if (DebugDirectories->Type == IMAGE_DEBUG_TYPE_MISC) {
                                    MiscDebug = (PIMAGE_DEBUG_MISC)
                                        ((PCHAR)LoadedImage->MappedAddress +
                                         DebugDirectories->PointerToRawData
                                        );
                                    StringCchCopy( DebugFileName, MAX_PATH, (PCHAR) MiscDebug->Data );
                                    break;
                                } else {
                                    DebugDirectories += 1;
                                    DebugDirectoriesSize -= sizeof( *DebugDirectories );
                                }
                            }
                        }
                    } else {
                        fSymbolsAlreadySplit = FALSE;
                    }

                    OldChecksum = OPTIONALHEADER(CheckSum);
                    CheckSumMappedFile(
                                (PVOID)LoadedImage->MappedAddress,
                                GetFileSize(LoadedImage->hFile, NULL),
                                &HeaderSum,
                                &CheckSum
                                );

                    OPTIONALHEADER_LV(CheckSum) = CheckSum;
                    FlushViewOfFile(LoadedImage->MappedAddress, LoadedImage->SizeOfImage);

                    if (fSymbolsAlreadySplit) {
                        if ( UpdateDebugInfoFileEx(ImageName,
                                                   SymbolPath,
                                                   DebugFilePath,
                                                   (PIMAGE_NT_HEADERS32)(LoadedImage->FileHeader),
                                                   OldChecksum)) {
                            if (GetLastError() == ERROR_INVALID_DATA) {
                                if (Parms.StatusRoutine != NULL) {
                                    if (Parms.Flags & BIND_REPORT_64BIT_VA)
                                         ((PIMAGEHLP_STATUS_ROUTINE64)(Parms.StatusRoutine)) ( BindMismatchedSymbols,
                                                           LoadedImage->ModuleName,
                                                           NULL,
                                                           0,
                                                           (ULONG_PTR)DebugFileName
                                                         );
                                    else 
                                        (Parms.StatusRoutine)( BindMismatchedSymbols,
                                                           LoadedImage->ModuleName,
                                                           NULL,
                                                           0,
                                                           (ULONG_PTR)DebugFileName
                                                         );
                                }
                            }
                        } else {
                            if (Parms.StatusRoutine != NULL) {
                                if (Parms.Flags & BIND_REPORT_64BIT_VA)
                                    ((PIMAGEHLP_STATUS_ROUTINE64)(Parms.StatusRoutine)) ( BindSymbolsNotUpdated,
                                                       LoadedImage->ModuleName,
                                                       NULL,
                                                       0,
                                                       (ULONG_PTR)DebugFileName
                                                     );
                                else
                                    (Parms.StatusRoutine)( BindSymbolsNotUpdated,
                                                       LoadedImage->ModuleName,
                                                       NULL,
                                                       0,
                                                       (ULONG_PTR)DebugFileName
                                                     );
                            }
                        }
                    }

                    GetSystemTime(&SystemTime);
                    if (SystemTimeToFileTime( &SystemTime, &LastWriteTime )) {
                        SetFileTime( LoadedImage->hFile, NULL, NULL, &LastWriteTime );
                    }
                }
            }

NoBind:
            fRC = TRUE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // Nothing to do...
    }

    if (LoadedImage->MappedAddress) {
        UnmapViewOfFile( LoadedImage->MappedAddress );
    }    
    if (LoadedImage->hFile != INVALID_HANDLE_VALUE) {
        CloseHandle( LoadedImage->hFile );
    }

    if (!(Flags & BIND_CACHE_IMPORT_DLLS)) {
        UnloadAllImages();
    }

    return (fRC);
}



BOOL
BindpLookupThunk64(
    PBINDP_PARAMETERS Parms,
    PIMAGE_THUNK_DATA64 ThunkName,
    PLOADED_IMAGE Image,
    PIMAGE_THUNK_DATA64 SnappedThunks,
    PIMAGE_THUNK_DATA64 FunctionAddress,
    PLOADED_IMAGE Dll,
    PIMAGE_EXPORT_DIRECTORY Exports,
    PIMPORT_DESCRIPTOR NewImport,
    LPSTR DllPath,
    PULONG *ForwarderChain
    )
{
    BOOL Ordinal;
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    PIMAGE_IMPORT_BY_NAME ImportName;
    USHORT HintIndex;
    LPSTR NameTableName;
    ULONG64 ExportsBase;
    ULONG ExportSize;
    UCHAR NameBuffer[ 32 ];
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader = NULL;
    PIMAGE_OPTIONAL_HEADER64 DllOptionalHeader = NULL;

    NameTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfNames, Dll );
    NameOrdinalTableBase = (PUSHORT) BindpRvaToVa( Parms, Exports->AddressOfNameOrdinals, Dll );
    FunctionTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfFunctions, Dll );

    if (!FunctionTableBase) {
        return FALSE;
    }

    OptionalHeader = &((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader;

    DllOptionalHeader = &((PIMAGE_NT_HEADERS64)Dll->FileHeader)->OptionalHeader;

    //
    // Determine if snap is by name, or by ordinal
    //

    Ordinal = (BOOL)IMAGE_SNAP_BY_ORDINAL64(ThunkName->u1.Ordinal);

    if (Ordinal) {
        UCHAR szOrdinal[8];
        OrdinalNumber = (USHORT)(IMAGE_ORDINAL64(ThunkName->u1.Ordinal) - Exports->Base);
        if ( (ULONG)OrdinalNumber >= Exports->NumberOfFunctions ) {
            return FALSE;
        }
        ImportName = (PIMAGE_IMPORT_BY_NAME)NameBuffer;
        StringCchCopy((PCHAR) ImportName->Name, 31, "Ordinal");
        StringCchCat((PCHAR) ImportName->Name, 31, _ultoa((ULONG) OrdinalNumber, (LPSTR) szOrdinal, 16));
    } else {
        ImportName = (PIMAGE_IMPORT_BY_NAME)BindpRvaToVa(
                                                Parms,
                                                (ULONG)(ULONG64)(ThunkName->u1.AddressOfData),
                                                Image
                                                );
        if (!ImportName || !NameTableBase) {
            return FALSE;
        }
        
        //
        // now check to see if the hint index is in range. If it
        // is, then check to see if it matches the function at
        // the hint. If all of this is true, then we can snap
        // by hint. Otherwise need to scan the name ordinal table
        //

        OrdinalNumber = (USHORT)(Exports->NumberOfFunctions+1);
        HintIndex = ImportName->Hint;
        if ((ULONG)HintIndex < Exports->NumberOfNames ) {
            NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
            if ( NameTableName ) {
                if ( !strcmp((PCHAR)ImportName->Name, NameTableName) ) {
                    OrdinalNumber = NameOrdinalTableBase[HintIndex];
                }
            }
        }

        if ((ULONG)OrdinalNumber >= Exports->NumberOfFunctions) {
            for (HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++) {
                NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
                if (NameTableName) {
                    if (!strcmp( (PCHAR)ImportName->Name, NameTableName )) {
                        OrdinalNumber = NameOrdinalTableBase[HintIndex];
                        break;
                    }
                }
            }

            if ((ULONG)OrdinalNumber >= Exports->NumberOfFunctions) {
                return FALSE;
            }
        }
    }

    FunctionAddress->u1.Function = (ULONGLONG)(FunctionTableBase[OrdinalNumber] + DllOptionalHeader->ImageBase);

    ExportsBase = (ULONG64)((ULONG_PTR)ImageDirectoryEntryToData(Dll->MappedAddress, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportSize)
                             - 
                            (ULONG_PTR)Dll->MappedAddress);

    ExportsBase += DllOptionalHeader->ImageBase;

    if ((FunctionAddress->u1.Function > ExportsBase) && (FunctionAddress->u1.Function < (ExportsBase + ExportSize))) {
        BOOL BoundForwarder;

        BoundForwarder = FALSE;
        if (NewImport != NULL) {
            FunctionAddress->u1.ForwarderString = BindpAddForwarderReference(Parms,
                                           Image->ModuleName,
                                           (LPSTR) ImportName->Name,
                                           NewImport,
                                           DllPath,
                                           (PUCHAR) BindpRvaToVa( Parms, FunctionTableBase[OrdinalNumber], Dll ),
                                           &BoundForwarder
                                          );
        }

        if (!BoundForwarder) {
            **ForwarderChain = (ULONG) (FunctionAddress - SnappedThunks);
            *ForwarderChain = (ULONG *)&FunctionAddress->u1.Ordinal;

            if (Parms->StatusRoutine != NULL) {
                if (Parms->Flags & BIND_REPORT_64BIT_VA)
                     ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindForwarderNOT64,
                                        Image->ModuleName,
                                        Dll->ModuleName,
                                        (ULONG64)FunctionAddress->u1.Function,
                                        (ULONG_PTR)(ImportName->Name));
                else
                    (Parms->StatusRoutine)( BindForwarderNOT,
                                        Image->ModuleName,
                                        Dll->ModuleName,
                                        (ULONG_PTR)FunctionAddress->u1.Function,
                                        (ULONG_PTR)(ImportName->Name)
                                      );
            }
        }
    } else {
        if (Parms->StatusRoutine != NULL) {
            if (Parms->Flags & BIND_REPORT_64BIT_VA)
                 ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindImportProcedure64,
                                    Image->ModuleName,
                                    Dll->ModuleName,
                                    (ULONG64)FunctionAddress->u1.Function,
                                    (ULONG_PTR)(ImportName->Name)
                                  );
            else
                (Parms->StatusRoutine)( BindImportProcedure,
                                    Image->ModuleName,
                                    Dll->ModuleName,
                                    (ULONG_PTR)FunctionAddress->u1.Function,
                                    (ULONG_PTR)(ImportName->Name)
                                  );
        }
    }

    return TRUE;
}   // BindpLookupThunk64

BOOL
BindpLookupThunk32(
    PBINDP_PARAMETERS Parms,
    PIMAGE_THUNK_DATA32 ThunkName,
    PLOADED_IMAGE Image,
    PIMAGE_THUNK_DATA32 SnappedThunks,
    PIMAGE_THUNK_DATA32 FunctionAddress,
    PLOADED_IMAGE Dll,
    PIMAGE_EXPORT_DIRECTORY Exports,
    PIMPORT_DESCRIPTOR NewImport,
    LPSTR DllPath,
    PULONG *ForwarderChain
    )
{
    BOOL Ordinal;
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    PIMAGE_IMPORT_BY_NAME ImportName;
    USHORT HintIndex;
    LPSTR NameTableName;
    ULONG ExportsBase;
    ULONG ExportSize;
    UCHAR NameBuffer[ 32 ];
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader = NULL;
    PIMAGE_OPTIONAL_HEADER32 DllOptionalHeader = NULL;

    NameTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfNames, Dll );
    NameOrdinalTableBase = (PUSHORT) BindpRvaToVa( Parms, Exports->AddressOfNameOrdinals, Dll );
    FunctionTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfFunctions, Dll );

    if (!FunctionTableBase) {
        return FALSE;
    }
    
    OptionalHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader;

    DllOptionalHeader = &((PIMAGE_NT_HEADERS32)Dll->FileHeader)->OptionalHeader;

    //
    // Determine if snap is by name, or by ordinal
    //

    Ordinal = (BOOL)IMAGE_SNAP_BY_ORDINAL32(ThunkName->u1.Ordinal);

    if (Ordinal) {
        UCHAR szOrdinal[8];
        OrdinalNumber = (USHORT)(IMAGE_ORDINAL32(ThunkName->u1.Ordinal) - Exports->Base);
        if ( (ULONG)OrdinalNumber >= Exports->NumberOfFunctions ) {
            return FALSE;
        }
        ImportName = (PIMAGE_IMPORT_BY_NAME)NameBuffer;
        StringCchCopy((PCHAR) ImportName->Name, 31, "Ordinal");
        StringCchCat((PCHAR) ImportName->Name, 31, _ultoa((ULONG) OrdinalNumber, (LPSTR) szOrdinal, 16));
    } else {
        ImportName = (PIMAGE_IMPORT_BY_NAME)BindpRvaToVa( Parms, ThunkName->u1.AddressOfData, Image );
        if (!ImportName || !NameTableBase) {
            return FALSE;
        }

        //
        // now check to see if the hint index is in range. If it
        // is, then check to see if it matches the function at
        // the hint. If all of this is true, then we can snap
        // by hint. Otherwise need to scan the name ordinal table
        //

        OrdinalNumber = (USHORT)(Exports->NumberOfFunctions+1);
        HintIndex = ImportName->Hint;
        if ((ULONG)HintIndex < Exports->NumberOfNames ) {
            NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
            if ( NameTableName ) {
                if ( !strcmp((PCHAR)ImportName->Name, NameTableName) ) {
                    OrdinalNumber = NameOrdinalTableBase[HintIndex];
                }
            }
        }

        if ((ULONG)OrdinalNumber >= Exports->NumberOfFunctions) {
            for (HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++) {
                NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
                if (NameTableName) {
                    if (!strcmp( (PCHAR)ImportName->Name, NameTableName )) {
                        OrdinalNumber = NameOrdinalTableBase[HintIndex];
                        break;
                    }
                }
            }

            if ((ULONG)OrdinalNumber >= Exports->NumberOfFunctions) {
                return FALSE;
            }
        }
    }

    FunctionAddress->u1.Function = FunctionTableBase[OrdinalNumber] + DllOptionalHeader->ImageBase;

    ExportsBase = (ULONG)((ULONG_PTR)ImageDirectoryEntryToData(Dll->MappedAddress, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportSize) 
                           - 
                          (ULONG_PTR)Dll->MappedAddress);

    ExportsBase += DllOptionalHeader->ImageBase;

    if ((FunctionAddress->u1.Function > ExportsBase) && (FunctionAddress->u1.Function < (ExportsBase + ExportSize))) {
        BOOL BoundForwarder;

        BoundForwarder = FALSE;
        if (NewImport != NULL) {
            FunctionAddress->u1.ForwarderString = (ULONG)BindpAddForwarderReference(Parms,
                                           Image->ModuleName,
                                           (LPSTR) ImportName->Name,
                                           NewImport,
                                           DllPath,
                                           (PUCHAR) BindpRvaToVa( Parms, FunctionTableBase[OrdinalNumber], Dll ),
                                           &BoundForwarder
                                          );
        }

        if (!BoundForwarder) {
            **ForwarderChain = (ULONG) (FunctionAddress - SnappedThunks);
            *ForwarderChain = (ULONG *)&FunctionAddress->u1.Ordinal;

            if (Parms->StatusRoutine != NULL) {
                if (Parms->Flags & BIND_REPORT_64BIT_VA)
                     ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindForwarderNOT64,
                                        Image->ModuleName,
                                        Dll->ModuleName,
                                        (ULONG64)FunctionAddress->u1.Function,
                                        (ULONG_PTR)(ImportName->Name));
                else
                    (Parms->StatusRoutine)( BindForwarderNOT,
                                        Image->ModuleName,
                                        Dll->ModuleName,
                                        (ULONG_PTR)FunctionAddress->u1.Function,
                                        (ULONG_PTR)(ImportName->Name)
                                      );
            }
        }
    } else {
        if (Parms->StatusRoutine != NULL) {
            if (Parms->Flags & BIND_REPORT_64BIT_VA)
                 ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindImportProcedure64,
                                    Image->ModuleName,
                                    Dll->ModuleName,
                                    (ULONG64)FunctionAddress->u1.Function,
                                    (ULONG_PTR)(ImportName->Name)
                                  );
            else
                (Parms->StatusRoutine)( BindImportProcedure,
                                    Image->ModuleName,
                                    Dll->ModuleName,
                                    (ULONG_PTR)FunctionAddress->u1.Function,
                                    (ULONG_PTR)(ImportName->Name)
                                  );
        }
    }

    return TRUE;
}   // BindpLookupThunk32

PVOID
BindpRvaToVa(
    PBINDP_PARAMETERS Parms,
    ULONG Rva,
    PLOADED_IMAGE Image
    )
{
    PVOID Va;

    Va = ImageRvaToVa( Image->FileHeader,
                       Image->MappedAddress,
                       Rva,
                       &Image->LastRvaSection
                     );
    if (!Va && Parms->StatusRoutine != NULL) {
        if (Parms->Flags & BIND_REPORT_64BIT_VA)
             ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindRvaToVaFailed,
                                Image->ModuleName,
                                NULL,
                                (ULONG64)Rva,
                                0
                              );
        else 
            (Parms->StatusRoutine)( BindRvaToVaFailed,
                                Image->ModuleName,
                                NULL,
                                (ULONG)Rva,
                                0
                              );
    }

    return Va;
}

VOID
SetIdataToRo(
    PLOADED_IMAGE Image
    )
{
    PIMAGE_SECTION_HEADER Section;
    ULONG i;

    for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
        if (!_stricmp((PCHAR) Section->Name, ".idata")) {
            if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) {
                Section->Characteristics &= ~IMAGE_SCN_MEM_WRITE;
                Section->Characteristics |= IMAGE_SCN_MEM_READ;
                }

            break;
            }
        }
}

VOID
BindpWalkAndProcessImports(
    PBINDP_PARAMETERS Parms,
    PLOADED_IMAGE Image,
    LPSTR DllPath,
    PBOOL ImageModified
    )
{
    ULONG  ForwarderChainHead;
    PULONG ForwarderChain;
    ULONG ImportSize;
    ULONG ExportSize;
    PIMPORT_DESCRIPTOR NewImportDescriptorHead, NewImportDescriptor;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR PrevNewImports, NewImports;
    ULONG PrevNewImportsSize, NewImportsSize;
    PIMAGE_IMPORT_DESCRIPTOR Imports;
    PIMAGE_EXPORT_DIRECTORY Exports;
    LPSTR ImportModule;
    PLOADED_IMAGE Dll;
    PIMAGE_THUNK_DATA32 tname32,tsnap32;
    PIMAGE_THUNK_DATA64 tname64,tsnap64;
    PIMAGE_THUNK_DATA32 ThunkNames32;
    PIMAGE_THUNK_DATA64 ThunkNames64;
    PIMAGE_THUNK_DATA32 SnappedThunks32;
    PIMAGE_THUNK_DATA64 SnappedThunks64;
    PIMAGE_IMPORT_BY_NAME ImportName;
    ULONG NumberOfThunks;
    ULONG i, cb;
    BOOL Ordinal, BindThunkFailed, NoErrors;
    USHORT OrdinalNumber;
    UCHAR NameBuffer[ 32 ];
    BOOL fWin64Image = FALSE;
    PIMAGE_FILE_HEADER FileHeader;
                                   
    NoErrors = FALSE;
    *ImageModified = FALSE;

    //
    // Locate the import array for this image/dll
    //

    NewImportDescriptorHead = NULL;
    Imports = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(Image->MappedAddress, FALSE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportSize);
    if (Imports == NULL) {
        //
        // Nothing to bind if no imports
        //

        return;
    }

    FileHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->FileHeader;
    fWin64Image = Image->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;

    PrevNewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(Image->MappedAddress, FALSE, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT, &PrevNewImportsSize);

    // If the user asked for an old style bind and there are new style bind records
    // already in the image, zero them out first.  This is the fix the problem where
    // you bind on NT (creating new import descriptors), boot Win95 and bind there
    // (creating old bind format), and then reboot to NT (the loader will only check
    // the BOUND_IMPORT array.

    if (PrevNewImports && (Parms->fNewImports == FALSE) && (Parms->fNoUpdate == FALSE )) {
        if (fWin64Image) {
            ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = 0;
            ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size = 0;
        } else {
            ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = 0;
            ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size = 0;
        }
        PrevNewImports = 0;
        PrevNewImportsSize = 0;
        *ImageModified = TRUE;
    }

    //
    // For each import record
    //

    for(;Imports;Imports++) {
        if ( !Imports->Name ) {
            break;
        }

        //
        // Locate the module being imported and load the dll
        //

        ImportModule = (LPSTR)BindpRvaToVa( Parms, Imports->Name, Image );

        if (ImportModule) {
            Dll = ImageLoad( ImportModule, DllPath );
            if (!Dll) {
                if (Parms->StatusRoutine != NULL) {
                    if (Parms->Flags & BIND_REPORT_64BIT_VA)
                         ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) (BindImportModuleFailed, Image->ModuleName, ImportModule, 0, 0 );
                    else
                        (Parms->StatusRoutine)( BindImportModuleFailed, Image->ModuleName, ImportModule, 0, 0 );
                }
                //
                // Unless specifically told not to, generate the new style
                // import descriptor.
                //

                BindpAddImportDescriptor(Parms, &NewImportDescriptorHead, Imports, ImportModule, Dll );
                continue;
            }

            if (Parms->StatusRoutine != NULL) {
                if (Parms->Flags & BIND_REPORT_64BIT_VA)
                     ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindImportModule, Image->ModuleName, ImportModule, 0, 0 );
                else
                    (Parms->StatusRoutine)( BindImportModule, Image->ModuleName, ImportModule, 0, 0 );
            }
            //
            // If we can load the DLL, locate the export section and
            // start snapping the thunks
            //

            Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData(Dll->MappedAddress, FALSE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportSize);
            if ( !Exports ) {
                continue;
            }

            //
            // For old style bind, bypass the bind if it's already bound.
            // New style binds s/b looked up in PrevNewImport.
            //

            if ( (Parms->fNewImports == FALSE) && Imports->TimeDateStamp && (Imports->TimeDateStamp == FileHeader->TimeDateStamp)) {
                continue;
            }

            //
            // Now we need to size our thunk table and
            // allocate a buffer to hold snapped thunks. This is
            // done instead of writting to the mapped view so that
            // thunks are only updated if we find all the entry points
            //

            ThunkNames32 = (PIMAGE_THUNK_DATA32) BindpRvaToVa( Parms, Imports->OriginalFirstThunk, Image );
            ThunkNames64 = (PIMAGE_THUNK_DATA64) ThunkNames32;

            if (!ThunkNames32) {
                //
                // Skip this one if no thunks
                //
                continue;
            }

            if (fWin64Image ? !ThunkNames64->u1.Function : !ThunkNames32->u1.Function) {
                continue;
            }

            //
            // Unless specifically told not to, generate the new style
            // import descriptor.
            //

            NewImportDescriptor = BindpAddImportDescriptor(Parms, &NewImportDescriptorHead, Imports, ImportModule, Dll );

            NumberOfThunks = 0;
            if (fWin64Image) {
                tname64 = ThunkNames64;
                while (tname64->u1.AddressOfData) {
                    NumberOfThunks++;
                    tname64++;
                }
#ifdef STANDALONE_BIND
                SnappedThunks64 = (PIMAGE_THUNK_DATA64) calloc( NumberOfThunks*sizeof(*SnappedThunks64), 1 );
#else
                SnappedThunks64 = (PIMAGE_THUNK_DATA64) MemAlloc( NumberOfThunks*sizeof(*SnappedThunks64) );
#endif
                if ( !SnappedThunks64 ) {
                    continue;
                }

                tname64 = ThunkNames64;
                tsnap64 = SnappedThunks64;
            } else {
                tname32 = ThunkNames32;
                while (tname32->u1.AddressOfData) {
                    NumberOfThunks++;
                    tname32++;
                }
#ifdef STANDALONE_BIND
                SnappedThunks32 = (PIMAGE_THUNK_DATA32) calloc( NumberOfThunks*sizeof(*SnappedThunks32), 1 );
#else
                SnappedThunks32 = (PIMAGE_THUNK_DATA32) MemAlloc( NumberOfThunks*sizeof(*SnappedThunks32) );
#endif
                if ( !SnappedThunks32 ) {
                    continue;
                }

                tname32 = ThunkNames32;
                tsnap32 = SnappedThunks32;
            }

            NoErrors = TRUE;
            ForwarderChainHead = (ULONG)-1;
            ForwarderChain = &ForwarderChainHead;
            for(i=0;i<NumberOfThunks;i++) {
                BindThunkFailed = FALSE;
                __try {
                    if (fWin64Image) {
                        if (!BindpLookupThunk64( Parms, tname64, Image, SnappedThunks64, tsnap64, Dll,
                                                 Exports, NewImportDescriptor, DllPath, &ForwarderChain )) {
                            BindThunkFailed = TRUE;
                        }
                    } else {
                        if (!BindpLookupThunk32( Parms, tname32, Image, SnappedThunks32, tsnap32, Dll,
                                                 Exports, NewImportDescriptor, DllPath, &ForwarderChain )) {
                            BindThunkFailed = TRUE;
                        }
                    }
                } __except ( EXCEPTION_EXECUTE_HANDLER ) {
                    BindThunkFailed = TRUE;
                }

                if (BindThunkFailed) {
                    if (NewImportDescriptor != NULL) {
                        NewImportDescriptor->TimeDateStamp = 0;
                    }

                    if (Parms->StatusRoutine != NULL) {
                        Ordinal = fWin64Image ? 
                                    (BOOL)IMAGE_SNAP_BY_ORDINAL64(tname64->u1.Ordinal) :
                                    (BOOL)IMAGE_SNAP_BY_ORDINAL32(tname32->u1.Ordinal);
                        if (Ordinal) {
                            UCHAR szOrdinal[8];

                            OrdinalNumber = (USHORT)(IMAGE_ORDINAL(fWin64Image ? 
                                                                     tname64->u1.Ordinal : 
                                                                     tname32->u1.Ordinal) 
                                                     - Exports->Base);

                            ImportName = (PIMAGE_IMPORT_BY_NAME)NameBuffer;
                            // Can't use sprintf w/o dragging in more CRT support than we want...  Must run on Win95.
                            StringCchCopy((PCHAR) ImportName->Name, 31, "Ordinal");
                            StringCchCat((PCHAR) ImportName->Name, 31, _ultoa((ULONG) OrdinalNumber, (LPSTR)szOrdinal, 16));
                        }
                        else {
                            ImportName = (PIMAGE_IMPORT_BY_NAME)BindpRvaToVa(
                                                                    Parms,
                                                                    (ULONG)(ULONG_PTR)( fWin64Image ?
                                                                               (tname64->u1.AddressOfData) :
                                                                               (tname32->u1.AddressOfData)),
                                                                    Image
                                                                    );
                        }

                        if (Parms->Flags & BIND_REPORT_64BIT_VA)
                             ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindImportProcedureFailed,
                                                Image->ModuleName,
                                                Dll->ModuleName,
                                                (ULONG64) fWin64Image ? 
                                                            tsnap64->u1.Function :
                                                            tsnap32->u1.Function,
                                                (ULONG_PTR)(ImportName->Name)
                                              );
                        else
                            (Parms->StatusRoutine)( BindImportProcedureFailed, Image->ModuleName, Dll->ModuleName,
                                                (ULONG_PTR) (fWin64Image ? tsnap64->u1.Function : tsnap32->u1.Function),
                                                (ULONG_PTR)(ImportName->Name)
                                              );
                    }

                    break;
                }

                if (fWin64Image) {
                    tname64++;
                    tsnap64++;
                } else {
                    tname32++;
                    tsnap32++;
                }
            }

            tname32 = (PIMAGE_THUNK_DATA32) BindpRvaToVa( Parms, Imports->FirstThunk, Image );
            tname64 = (PIMAGE_THUNK_DATA64) tname32;

            if ( !tname32 ) {
                NoErrors = FALSE;
            }

            //
            // If we were able to locate all of the entrypoints in the
            // target dll, then copy the snapped thunks into the image,
            // update the time and date stamp, and flush the image to
            // disk
            //

            if ( NoErrors && Parms->fNoUpdate == FALSE ) {
                if (ForwarderChainHead != -1) {
                    *ImageModified = TRUE;
                    *ForwarderChain = -1;
                }
                if (Imports->ForwarderChain != ForwarderChainHead) {
                    Imports->ForwarderChain = ForwarderChainHead;
                    *ImageModified = TRUE;
                }
                if (fWin64Image) {
                    cb = NumberOfThunks*sizeof(*SnappedThunks64);
                    if (memcmp(tname64,SnappedThunks64,cb)) {
                        MoveMemory(tname64,SnappedThunks64,cb);
                        *ImageModified = TRUE;
                    }
                } else {
                    cb = NumberOfThunks*sizeof(*SnappedThunks32);
                    if (memcmp(tname32,SnappedThunks32,cb)) {
                        MoveMemory(tname32,SnappedThunks32,cb);
                        *ImageModified = TRUE;
                    }
                }
                if (NewImportDescriptorHead == NULL) {
                    if (Imports->TimeDateStamp != FileHeader->TimeDateStamp) {
                        Imports->TimeDateStamp = FileHeader->TimeDateStamp;
                        *ImageModified = TRUE;
                    }
                }
                else
                if (Imports->TimeDateStamp != 0xFFFFFFFF) {
                    Imports->TimeDateStamp = 0xFFFFFFFF;
                    *ImageModified = TRUE;
                }
            }

#ifdef STANDALONE_BIND
            fWin64Image ? free(SnappedThunks64) : free(SnappedThunks32);
#else
            fWin64Image ? MemFree(SnappedThunks64) : MemFree(SnappedThunks32);
#endif
        }
    }

    NewImports = BindpCreateNewImportSection(Parms, &NewImportDescriptorHead, &NewImportsSize);
    if ((PrevNewImportsSize != NewImportsSize) || memcmp( PrevNewImports, NewImports, NewImportsSize)) 
    {
        *ImageModified = TRUE;
    }

    if (!*ImageModified) {
        return;
    }

    if (Parms->StatusRoutine != NULL) {
        if (Parms->Flags & BIND_REPORT_64BIT_VA)
             ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindImageModified, Image->ModuleName, NULL, 0, 0 );
        else
            (Parms->StatusRoutine)( BindImageModified, Image->ModuleName, NULL, 0, 0 );
    }

    if (NewImports != NULL) {
        ULONG cbFreeFile, cbFreeHeaders, OffsetHeaderFreeSpace, cbFreeSpaceOnDisk;

        if (NoErrors && Parms->fNoUpdate == FALSE) {
            if (fWin64Image) {
                ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = 0;
                ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size = 0;
            } else {
                ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = 0;
                ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size = 0;
            }
        }
        OffsetHeaderFreeSpace = GetImageUnusedHeaderBytes( Image, &cbFreeFile );
        cbFreeHeaders = Image->Sections->VirtualAddress
                          -
                        (fWin64Image ? 
                         ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.SizeOfHeaders :
                         ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.SizeOfHeaders) 
                          +
                        cbFreeFile;

        // FreeSpace on Disk may be larger that FreeHeaders in the headers (the linker
        // can start the first section on a page boundary already)

        cbFreeSpaceOnDisk = Image->Sections->PointerToRawData 
                              -
                            (fWin64Image ? 
                             ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.SizeOfHeaders :
                             ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.SizeOfHeaders)
                              +
                            cbFreeFile;

        if (NewImportsSize > cbFreeFile) {
            if (NewImportsSize > cbFreeHeaders) {
                if (Parms->StatusRoutine != NULL) {
                    if (Parms->Flags & BIND_REPORT_64BIT_VA)
                         ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindNoRoomInImage, Image->ModuleName, NULL, 0, 0 );
                    else
                        (Parms->StatusRoutine)( BindNoRoomInImage, Image->ModuleName, NULL, 0, 0 );
                }
                NoErrors = FALSE;
            }
            else
            if (NoErrors && (Parms->fNoUpdate == FALSE)) {
                if (NewImportsSize <= cbFreeSpaceOnDisk) {

                    // There's already space on disk.  Just adjust the header size.
                    if (fWin64Image) {
                        ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.SizeOfHeaders = 
                            (((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.SizeOfHeaders 
                               -
                             cbFreeFile 
                               + 
                             NewImportsSize 
                               + 
                             ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.FileAlignment - 1)
                             & ~(((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.FileAlignment - 1);
                    } else {
                        ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.SizeOfHeaders = 
                            (((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.SizeOfHeaders 
                               -
                             cbFreeFile 
                               + 
                             NewImportsSize 
                               + 
                             ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.FileAlignment - 1)
                             & ~(((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.FileAlignment - 1);
                    }

                } else  {

                    NoErrors = BindpExpandImageFileHeaders( Parms,
                                                            Image,
                                                            ((fWin64Image ? 
                                                              ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.SizeOfHeaders :
                                                              ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.SizeOfHeaders)
                                                               -
                                                              cbFreeFile 
                                                               +
                                                              NewImportsSize 
                                                               +
                                                              (fWin64Image ? 
                                                               ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.FileAlignment - 1 :
                                                               ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.FileAlignment - 1)
                                                            ) & ~(
                                                              fWin64Image ? 
                                                              ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.FileAlignment - 1 :
                                                              ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.FileAlignment - 1
                                                            )
                                                          );
                    // Expand may have remapped the image.  Recalc the header ptrs.
                    FileHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->FileHeader;
                }
            }
        }

        if (Parms->StatusRoutine != NULL) {
            if (Parms->Flags & BIND_REPORT_64BIT_VA)
                 ((PIMAGEHLP_STATUS_ROUTINE64)(Parms->StatusRoutine)) ( BindImageComplete,
                                    Image->ModuleName,
                                    NULL,
                                    (ULONG64)NewImports,
                                    NoErrors
                                  );
            else
                (Parms->StatusRoutine)( BindImageComplete, Image->ModuleName, NULL, (ULONG_PTR)NewImports, NoErrors );
        }

        if (NoErrors && Parms->fNoUpdate == FALSE) {
            if (fWin64Image) {
                ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = OffsetHeaderFreeSpace;
                ((PIMAGE_NT_HEADERS64)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size = NewImportsSize;
            } else {
                ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = OffsetHeaderFreeSpace;
                ((PIMAGE_NT_HEADERS32)Image->FileHeader)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size = NewImportsSize;
            }
            memcpy( (LPSTR)(Image->MappedAddress) + OffsetHeaderFreeSpace, NewImports, NewImportsSize );
        }

#ifdef STANDALONE_BIND
        free(NewImports);
#else
        MemFree(NewImports);
#endif
    }

    if (NoErrors && Parms->fNoUpdate == FALSE) {
        SetIdataToRo( Image );
    }
}


DWORD
GetImageUnusedHeaderBytes(
    PLOADED_IMAGE LoadedImage,
    LPDWORD SizeUnusedHeaderBytes
    )
{
    DWORD OffsetFirstUnusedHeaderByte;
    DWORD i;
    DWORD OffsetHeader;
    PIMAGE_NT_HEADERS NtHeaders = LoadedImage->FileHeader;

    //
    // this calculates an offset, not an address, so DWORD is correct
    //
    OffsetFirstUnusedHeaderByte = (DWORD)
       (((LPSTR)NtHeaders - (LPSTR)LoadedImage->MappedAddress) +
        (FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +
         NtHeaders->FileHeader.SizeOfOptionalHeader +
         (NtHeaders->FileHeader.NumberOfSections *
          sizeof(IMAGE_SECTION_HEADER)
         )
        )
       );

    if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        PIMAGE_OPTIONAL_HEADER64 OptionalHeader = (PIMAGE_OPTIONAL_HEADER64)&LoadedImage->FileHeader->OptionalHeader;
        for ( i=0; i < OptionalHeader->NumberOfRvaAndSizes; i++ ) {
            OffsetHeader = OptionalHeader->DataDirectory[i].VirtualAddress;
            if (OffsetHeader < OptionalHeader->SizeOfHeaders) {
                if (OffsetHeader >= OffsetFirstUnusedHeaderByte) {
                    if (i == IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG) {
                        PIMAGE_LOAD_CONFIG_DIRECTORY pd = (PIMAGE_LOAD_CONFIG_DIRECTORY)((ULONG_PTR)LoadedImage->FileHeader + OffsetHeader);
                        if (pd->Size) {
                            OffsetFirstUnusedHeaderByte = OffsetHeader + pd->Size;
                        } else {
                            OffsetFirstUnusedHeaderByte = OffsetHeader + OptionalHeader->DataDirectory[i].Size;
                        }
                    } else {
                        OffsetFirstUnusedHeaderByte = OffsetHeader + OptionalHeader->DataDirectory[i].Size;
                    }
                }
            }
        }
        *SizeUnusedHeaderBytes = OptionalHeader->SizeOfHeaders - OffsetFirstUnusedHeaderByte;
    } else {
        PIMAGE_OPTIONAL_HEADER32 OptionalHeader = (PIMAGE_OPTIONAL_HEADER32)&LoadedImage->FileHeader->OptionalHeader;
        for ( i=0; i < OptionalHeader->NumberOfRvaAndSizes; i++ ) {
            OffsetHeader = OptionalHeader->DataDirectory[i].VirtualAddress;
            if (OffsetHeader < OptionalHeader->SizeOfHeaders) {
                if (OffsetHeader >= OffsetFirstUnusedHeaderByte) {
                    if (i == IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG) {
                        PIMAGE_LOAD_CONFIG_DIRECTORY pd = (PIMAGE_LOAD_CONFIG_DIRECTORY)((ULONG_PTR)LoadedImage->FileHeader + OffsetHeader);
                        if (pd->Size) {
                            OffsetFirstUnusedHeaderByte = OffsetHeader + pd->Size;
                        } else {
                            OffsetFirstUnusedHeaderByte = OffsetHeader + OptionalHeader->DataDirectory[i].Size;
                        }
                    } else {
                        OffsetFirstUnusedHeaderByte = OffsetHeader + OptionalHeader->DataDirectory[i].Size;
                    }
                }
            }
        }
        *SizeUnusedHeaderBytes = OptionalHeader->SizeOfHeaders - OffsetFirstUnusedHeaderByte;
    }

    return OffsetFirstUnusedHeaderByte;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\include\makefile.inc ===
##
## Copyright (c) 2000, Intel Corporation
## All rights reserved.
##
## WARRANTY DISCLAIMER
##
## THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
## A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
## PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
## OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
## NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
## MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##
## Intel Corporation is the author of the Materials, and requests that all
## problem reports or change requests be submitted to it directly at
## http://developer.intel.com/opensource.
##


########################################################################
#
# Tools common Makefile.inc
#


# NOTES FOR Windows/NT environment
# 1. In WINNT, absolute path must BEGIN with back-slash (\) in order
#    to find the RCS file for an absolute file-name on the server.
# 2. The substitution of /topg_drive is done only by the ToolBuster tools.
#    It souldn't be used for other tools, e.g. cl.exe -I/topg_drive... won't work
#    This variable should be substituted before the command issuing.
# 3. Absolute path with leading back-slash is not recognized as expected by MS tools.
#    Either use absolute path with leading slash, or qoute the name with Double-Qoutes (").
#    Different set of variables (macros) can contain Absolute path with leading slash,
#    and with leading back-slash


# add the server drive to VAPTH to find RCS files for absolute file-names
VPATH += /topg_drive

ifeq ($(HOSTTYPE), WINNT)
   # ???????
   WINNT = winnt
endif # of WINNT



ifndef LOCALBASEDIR
   ifeq ($(HOSTTYPE), PARISC)
      LOCALBASEDIR = $(WORK_AREA)
      LOCALDIR   = $(LOCALBASEDIR)
   else # of PARISC
      ifeq ($(HOSTTYPE), WINNT)
         # For absolute path name in NT, use leading back-slash
         LOCALDIR = \x86sw
      else # of WINNT
         LOCALBASEDIR = $(HOME)
         ifndef WORK_AREA
            LOCALDIR   = $(LOCALBASEDIR)/x86sw
         else # of WORK_AREA
            LOCALDIR = $(WORK_AREA)
         endif # of WORK_AREA
      endif # of WINNT
   endif # of PARISC
else # of LOCALBASEDIR
   ifndef LOCALDIR
      LOCALDIR   = $(LOCALBASEDIR)/x86sw
   endif # of LOCALDIR
endif # of LOCALBASEDIR

ifndef SERVER_AREA
   ifeq ($(HOSTTYPE), WINNT)
      # This variable cann't be use in dependencies, the : are the problem
      SERVER_AREA = j:/x86sw
   else # of WINNT
      ifeq ($(HOSTTYPE), PARISC)
         SERVER_AREA = /gambit/src/official
      else # of PARISC
         SERVER_AREA = /home/x86sw
      endif # of PARISC
   endif # of WINNT
endif # of SERVER_AREA


ifndef STT_LOCAL_BIN
    STT_LOCAL_BIN = /usr/local/bin
endif

CI      = $(STT_LOCAL_BIN)/ci
CO      = $(STT_LOCAL_BIN)/co

ifdef REMOTE
   INSTALLDIR = $(LOCALDIR)
   ifeq ($(REMOTE), SC)
      RELEASEDIR = /md7/arch/tools/current/tools
   else # of SC
      ifeq ($(REMOTE), OR)
         RELEASEDIR = /home2/tools64/current/tools
      else # of OR
		@echo check your REMOTE environment variable, should be one of
		@echo SC, OR
		@exit 1
      endif # of OR
   endif # of SC
else # of REMOTE
   ifeq ($(HOSTTYPE), PARISC)
      INSTALLDIR = $(WORK_AREA)
      PINSTALLDIR = $(WORK_AREA)/prereleases
   else # of PARISC
      INSTALLDIR = $(SERVER_AREA)
      PINSTALLDIR = $(INSTALLDIR)/preleases
   endif
   RELEASEDIR = /export/iswp_02/tools64/current/tools
endif # of REMOTE

ifneq ($(HOSTTYPE), WINNT)
   DATE  := $(shell date "+%d-%m-%y, %H:%M")
   UNAME := $(shell uname)
endif # of WINNT


#ifeq ($(HOSTTYPE), PARISC)
#   SERVER_DIR = $(WORK_AREA)
#else # of PARISC
#   ifdef SERVER_AREA
#      SERVER_DIR = $(SERVER_AREA)
#   else # of SERVER_AREA
#      ifeq ($(HOSTTYPE), WINNT)
#         SERVER_DIR = j:/x86sw
#      else # of WINNT
#         SERVER_DIR = /home/x86sw
#   endif # of SERVER_AREA
#endif # of PARISC

ifeq ($(HOSTTYPE), i386)
    HOSTTYPE := UNIX386
endif

ifeq ($(HOSTTYPE), i486)
    HOSTTYPE := UNIX386
endif

ifeq ($(HOSTTYPE), iAPX386)
ifeq ($(UNAME), SunOS)
    HOSTTYPE := x86Solaris
else
    HOSTTYPE := UNIX386
endif
endif

ifeq ($(HOSTTYPE), UNIX)
    HOSTTYPE := UNIX386
endif
ifeq ($(UNAME), OSF1)
    HOSTTYPE := MACH386
endif



ifneq ($(HOSTTYPE), PARISC)
RCSDIFF = rcsdiff -q
else
RCSDIFF = rcsdiff
endif



ifeq ($(HOSTTYPE), UNIX386)
ifeq ($(OSTYPE), svr5)
	OS_DIR    = svr5
    SYS       = -DSVR4 -DSVR5 -DUNIX
    GCC_BIN       = /usr/ccs/bin/cc
    CC_BIN    = /usr/ccs/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN       = /usr/bin/nawk
    AS_BIN    = /usr/ccs/bin/as
    LD_BIN    = /usr/ccs/bin/ld
    YACC_BIN  = /usr/ccs/bin/yacc
    GCC_WARN  = -Xc
    GCC_FLAGS =
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O $(GCC_WARN)
    CC_FLAGS  = -Xc -Xt
    CC_DEBUG  = -g $(PROF_FLAGS)
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/ccs/bin/ar
    CP_BIN    = /usr/bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/ccs/bin/strip
    AWK       = gawk
    PERL      = /usr/intel/bin/perl -I /usr/gnu/lib/perl5/
    AS_FLAGS = -n
else
    OS_DIR    = svr4
    SYS       = -DSVR4 -DUNIX
    GCC_BIN       = /usr/local/bin/gcc
    CC_BIN    = /usr/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN       = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2 -DNDEBUG $(GCC_WARN)
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g $(PROF_FLAGS)
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /usr/bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/bin/strip
    AWK       = gawk
    AS_FLAGS = -n
#    GCC_O_WS = -Wmissing-prototypes
endif
else
ifeq ($(HOSTTYPE), i386-linux)
    OS_DIR    = linux
    SYS       = -DSVR4 -DUNIX
    GCC_BIN   = /usr/cygnus/redhat-980810/H-i386-pc-linux-gnu/bin/gcc
    GCC_BIN   = /usr/bin/gcc
    CC_BIN    = /usr/cygnus/redhat-980810/H-i386-pc-linux-gnu/bin/gcc
    CC_BIN    = /usr/bin/gcc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN   = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2 -DNDEBUG $(GCC_WARN)
    CC_FLAGS  = $(GCC_FLAGS)
    CC_DEBUG  = $(GCC_DEBUG)
    CC_OPT    = $(GCC_OPT)
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /usr/bin/strip
    AWK       = gawk
    AS_FLAGS  = -n
    CO	      = /usr/bin/co
    CI	      = /usr/bin/ci
else
ifeq ($(HOSTTYPE), i486-linux)
    OS_DIR    = linux
    PERL      = /usr/bin/perl
    SYS       = -DSVR4 -DUNIX
    GCC_BIN   = /usr/bin/gcc
    CC_BIN    = /usr/bin/gcc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN   = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2 -DNDEBUG $(GCC_WARN)
    CC_FLAGS  = $(GCC_FLAGS)
    CC_DEBUG  = $(GCC_DEBUG)
    CC_OPT    = $(GCC_OPT)
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /usr/bin/strip
    AWK       = gawk
    AS_FLAGS  = -n
    CO	      = /usr/intel/bin/co
    CI	      = /usr/intel/bin/ci
else
ifeq ($(HOSTTYPE), PARISC)
    OS_DIR    = $(MACHINE)
    SYS       =  -DHPUX -DSVR4 -DUNIX -DPY -DSTRICT_ALIGN
    GCC_BIN	  = /usr/local/bin/gcc
    CC_BIN    = /usr/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN	  = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS =
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g $(PROF_FLAGS)
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    GCC_DEBUG = -g $(GCC_WARN)
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
#
# Changed for HPUX, from /usr/bin/ar for SVR4.
#
    AR_BIN    = /bin/ar
    CP_BIN    = /usr/bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/bin/strip
    AWK       = gawk
    AS_FLAGS = -n
#    GCC_O = -ansi -Wall -Wshadow -Wpointer-arith -Wcast-align \
#            -Wconversion -Wmissing-prototypes \
#            -Wnested-externs
else
ifeq ($(HOSTTYPE), UNIX386_TEST)
    OS_DIR    = svr4
    SYS       = -DSVR4 -DUNIX
    GCC_BIN       = /usr/local/bin/gcc -Wa,-t386 -Wa,-Nwa
    CC_BIN    = /usr/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN       = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    GCC_DEBUG = -g $(GCC_WARN)
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /usr/bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/bin/strip
else
ifeq ($(HOSTTYPE), WINNT)
#   ToolBusterDir should be defined in the environment
    PERL      = perl -I$(ToolBusterDir)/lib/perl
    EXEXT     = .exe
    OS_DIR    = win32
    PWD       =
    SYS       = -DWINNT
    GCC_BIN   = cl.exe
    CXX       = cl.exe
    CC_BIN    = cl.exe
    AS_BIN    = $(ToolBusterDir)/lib/gcc-lib/winnt386/2_4_5/as
    LD_BIN    = $(ToolBusterDir)/lib/gcc-lib/winnt386/2_4_5/ld
    LD_BIN    = lib
    CAT_BIN   = cat.exe
    AR_BIN    = lib.exe
    CP_BIN    = cp.exe
    MV_BIN    = mv.exe
    RM_BIN    = rm.exe
    CHMOD_BIN = chmod.exe
    AWK_BIN   = gawk
	CO        = co.exe
	CI        = ci.exe
    LIBMOFL   = libmofl.lib
    ELF_H     = elf.h
    GCC_OPT   = -O2 -DNDEBUG
    CFLAGS_D_DEXE32 = /nologo /Za /W3 /YX /D "_X86_" /D "_DEBUG"  \
		      /D "_CONSOLE" /D "__WINNT__" /D "EX86stuff"  \
		      /FR /ML /Fd"ILD.PDB" /Fp"ILD.PCH"
else
ifeq ($(HOSTTYPE), x86Solaris)
    OS_DIR    = solaris
    SYS       = -DSVR4 -DUNIX
    GCC_BIN       = /usr/local/bin/gcc
    CC_BIN    = /usr/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN       = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/ccs/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/ccs/bin/strip
else
ifeq ($(HOSTTYPE), MACH386)
    OS_DIR    = osf
    SYS       = -DOSF1 -DUNIX
    GCC_BIN       = /usr/local/bin/ngcc
    CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  =
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), rs6000)
	OS_DIR    = aix
    SYS       = -DRS6000 -DAIX -DUNIX -DBIG_ENDIAN -DSTRICT_ALIGN
    GCC_BIN       = /usr/intel/bin/gcc
    CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS =
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  =
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), sun4)
    OS_DIR    = sparc
    SYS       = -DSPARC -DSUNOS -DUNIX -DBIG_ENDIAN -DEWS -DSTRICT_ALIGN
    GCC_BIN   = /usr/local/bin/gcc
    CC_BIN    = /bin/cc
    AWK_BIN   = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS =
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  =
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), HP)
    OS_DIR    = hp
    SYS       = -DUNIX -DHPUX -DBIG_ENDIAN -DSTRICT_ALIGN
    GCC_BIN   = /usr/local/gnu/cygnus/progressive-95q2/H-hppa1.1-hp-hpux9.05/bin/gcc
    CC_BIN    = /bin/cc
    AWK_BIN   = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS =
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_OPT   = -O2
    CC_FLAGS  =
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE),hp9000s700)
    OS_DIR    = hp
    SYS       = -DUNIX -DHPUX -DBIG_ENDIAN -DSTRICT_ALIGN
    GCC_BIN   = /usr/intel/bin/gcc -fPIC
    CC_BIN    = /bin/cc
    AWK_BIN   = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS =
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2 -DNDEBUG
    CC_FLAGS  =
    CC_DEBUG  =
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), SCO)
    OS_DIR    = sco
    SYS       = -DSCO -DUNIX
    GCC_BIN       = /usr/local/bin/gcc
    CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = /usr/local/bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), UNIX64)
    OS_DIR    =
    SYS       = -DSVR4 -DUNIX
    GCC_BIN       = gcc64
#   CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = ias
    LD_BIN    = ild
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS = -milp32
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
#   CC_FLAGS  = -Xa -Di386
#   CC_DEBUG  = -g
#   CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = iar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), UNIX64E) #Electron, 32 bit, EM
    OS_DIR    = eas
    SYS       = -DSVR4 -DUNIX
    GCC_BIN   = ecc.eas -32 -noannotate -D__PTR32__
#   CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = ias.eas
    LD_BIN    = ild.eas
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS =
    GCC_DEBUG =  $(GCC_WARN)
    GCC_OPT   =
#   CC_FLAGS  = -Xa -Di386
#   CC_DEBUG  = -g
#   CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = iar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), WINNT64E) #Electron, 32 bit, EM
#   ToolBusterDir should be defined in the environment
    PERL      = perl -I$(ToolBusterDir)/lib/perl
    EXEXT     = .exe
    OS_DIR    = win32em
    PWD       =
    SYS       = -DWINNT
    GCC_BIN   = icl.exe
    CXX       = icl.exe
    CC_BIN    = icl.exe
    AS_BIN    = ias.exe
    LD_BIN    = ilib ### ??
    CAT_BIN   = cat.exe
    AR_BIN    = ilib.exe
    CP_BIN    = cp.exe
    MV_BIN    = mv.exe
    RM_BIN    = rm.exe
    CHMOD_BIN = chmod.exe
    AWK_BIN   = gawk
	CO        = co.exe
	CI        = ci.exe
    LIBMOFL   = libmofl.lib
    ELF_H     = elf.h
    GCC_OPT   = -DNDEBUG
    CFLAGS_D_DEXE32 = /nologo /Za /W3 /YX /D "_X86_" /D "_DEBUG"  \
		      /D "_CONSOLE" /D "__WINNT__" /D "EX86stuff"  \
		      /FR /ML /Fd"ILD.PDB" /Fp"ILD.PCH" ### ??
else
    GCC_BIN       = @echo HOSTTYPE undefined
    CC_BIN    = $(GCC_BIN)

hosttype_error:
	@echo check your HOSTTYPE environment variable, should be one of
	@echo i386, i486 iAPX386, UNIX386, UNIX, MACH386, rs6000, sun4, HP
	@exit 1

endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif

ifeq ($(HOSTTYPE), WINNT)
	AR_OPT = /out:
	OEXT   = obj
	LEXT   = lib
	LDEXT  = dll
	EEXT   = .exe
	DOPT   = /D
	IOPT   = /I
ifdef STAT_LIB
	COPT   = /c
else
	COPT   = /c /MD
endif
	FOPT   =
	TC_FLAG = /Tc
	FE_FLAG = /Fe
	FO_FLAG = /Fo
	R_FLAG  =
	O_FLAG  =
	OUT_FLAG  = /out:
    DEBUG_FLAG = /Zi
    NT_O_FLAG  = /Fo
	DLL_LINK_FLAG  = /link /DLL
	NAME_FLAG  = /name:
	DLL       = dll
	ECHO      = $(ToolBusterDir)/bin/echo
	DELPARA = $(PERL) $(ToolBusterDir)/perlScripts/delpara
	SEPR   = &
	LINK_CC = link /SUBSYSTEM:console /MACHINE:i386
	LINK_DEBUG_FLAG = /DEBUG /FORCE:MULTIPLE
else
	AR_OPT = cr 
	OEXT   = o
	LEXT   = a
	LDEXT  = so
	EEXT   =
	DOPT   = -D
	IOPT   = -I
    COPT   = -c
	FOPT   = -f
	TC_FLAG =
	FE_FLAG =
	FO_FLAG =
	R_FLAG  = -r
	O_FLAG  = -o
	OUT_FLAG  =
    DEBUG_FLAG = -g
	NAME_FLAG =
	DLL_LINK_FLAG = -G
	DLL       = so
	LIB       = a
	ECHO      = echo
	DELPARA = $(PERL) $(SERVER_AREA)/scripts/delpara
	SEPR   = ;
	LINK_CC = $(CC)
	LINK_DEBUG_FLAG = $(DEBUG_FLAG)
endif


ifdef USE_LPROF
	PROF_FLAGS = -ql
	USECC = 1
	CC_OPT =
endif

# ToolBusterDir should be defined in the environment
# $$$ Default should be supplied
ifeq ($(HOSTTYPE), WINNT)
	MHDR =  $(PERL) $(ToolBusterDir)/perlScripts/mhdr -c
else
	MHDR =  $(PERL) $(SERVER_AREA)/scripts/mhdr -c
endif

LOCALBIN    = $(LOCALDIR)/bin.$(OS_DIR)
LOCALLIB    = $(LOCALDIR)/lib.$(OS_DIR)
INSTALLBIN  = $(INSTALLDIR)/bin.$(OS_DIR)
INSTALLLIB  = $(INSTALLDIR)/lib.$(OS_DIR)
PINSTALLBIN  = $(PINSTALLDIR)/bin.$(OS_DIR)
PINSTALLLIB  = $(PINSTALLDIR)/lib.$(OS_DIR)
ifndef INSTALLINC
   ifeq ($(HOSTTYPE), WINNT)
      INSTALLINC  = /topg_drive/x86sw/include
   else
      INSTALLINC  = $(INSTALLDIR)/include
   endif
endif
RELEASEBIN  = $(RELEASEDIR)/bin.$(OS_DIR)
RELEASELIB  = $(RELEASEDIR)/lib.$(OS_DIR)
RELEASEINC  = $(RELEASEDIR)/include
RELEASEMAN  = $(RELEASEDIR)/man/man1
RELEASEDEMO = $(RELEASEDIR)/demo

EAS_EXT = .eas

ifneq ($(HOSTTYPE), WINNT)
CUR_DIR  = $(shell pwd)
MAKE_DIR = $(PWD)
endif

BINDIR   = $(LOCALBIN)
SRCDIR   = $(LOCALDIR)/src
INCDIR   = $(INSTALLINC)
CTLDIR   = $(SRCDIR)/CTL64
DECDIR   = $(SRCDIR)/idecoder
DISDIR   = $(SRCDIR)/idasm
EMDBDIR   = $(SRCDIR)/emdb
DEC_TST_DIR   = $(LOCALDIR)/tst/idecoder
DIS_TST_DIR   = $(LOCALDIR)/tst/idasm

SIGNON   = $(INCDIR)/signon.h

USER_CFLAGS =
CFLAGS   = $(COPT) $(TOOL_FLAG) $(VFLAG) $(SYS) $(USER_CFLAGS)
CXXFLAGS = $(CFLAGS)

# additional suffixes
.SUFFIXES: .spec .dir .s .c .o .l .a

ifdef OPTIMIZE # default is using debug info
CC_COM  = $(CC_BIN) $(CC_FLAGS) $(CC_OPT)
GCC_COM = $(GCC_BIN) $(GCC_FLAGS) $(GCC_OPT)
RGCC_COM = $(RGCC_BIN) $(RGCC_FLAGS) $(RGCC_OPT)
else
CC_COM  = $(CC_BIN) $(CC_FLAGS) $(CC_DEBUG)
GCC_COM = $(GCC_BIN) $(GCC_FLAGS) $(GCC_DEBUG)
RGCC_COM = $(RGCC_BIN) $(RGCC_FLAGS) $(RGCC_DEBUG)
endif

ifdef USECC
	CC = $(CC_COM)
else
ifdef USERGCC
	CC = $(RGCC_COM)
else                                    # default is using gcc !
    USEGCC = 1                  # allow user to condition his flags upon this one
    CC = $(GCC_COM)
endif
endif

AWK     = $(AWK_BIN)
AS      = $(AS_BIN) $(AS_FLAGS)
LD      = $(LD_BIN) $(LD_FLAGS)
LD2     = $(CC)
AR      = $(AR_BIN)
CP      = $(CP_BIN)
LN      = $(LN_BIN)
MV      = $(MV_BIN) $(FOPT)
RM      = $(RM_BIN) $(FOPT)
CHMOD   = $(CHMOD_BIN)
STRIP   = $(STRIP_BIN)
YACC    = $(YACC_BIN) $(YC_FLAGS)


ifdef RCS_NO_UPDATE # default is update RCS
ifneq ($(HOSTTYPE),WINNT)
%:: RCS/%,v
	@test ! -f $@ || $(RCSDIFF) $@ > /dev/null || echo $@ need to be checked out 1>&2
	@test -f $@ || $(CO) $(COFLAGS) $< $@
else # of WINNT
%:: RCS/%,v
	@test ! -f "$@" || $(RCSDIFF) "$@" > NUL: || echo $@ need to be checked out 1>&2
	@test -f "$@" || $(CO) $(COFLAGS) "$@"
endif # of WINNT
else # of RCS_NO_UPDATE
ifneq ($(HOSTTYPE),WINNT)
%:: RCS/%,v
	@echo updating $@ 1>&2
	$(CO) $(COFLAGS) $@
else # of WINNT
%:: RCS/%,v
	@echo updating "$@" 1>&2
	$(CO) $(COFLAGS)   "$@"
endif # of WINNT
endif # of RCS_NO_UPDATE

ifeq ($(HOSTTYPE),WINNT)
%.obj: %.c
	$(CC) $(CFLAGS) /Fo$@ /Tc$<
endif

.c.o:
ifneq ($(HOSTTYPE),WINNT)
ifdef USECC
	$(CC) $(CFLAGS) ${CUR_DIR}/$<
# Do the move only if not in place
	$(patsubst $@-noexist,$(MV) $(@F) $@, $(filter-out $(filter $(@F), $@),$(firstword $(filter $(@F), $@) $@-noexist)))
else
	$(CC) $(CFLAGS) -o ${CUR_DIR}/$@ ${CUR_DIR}/$<
endif
else
	$(CC) $(CFLAGS) /Fo$@ /Tc$<
endif

.PHONY: force

include $(INCDIR)/Make_Arch.inc


ifeq ($(HOSTTYPE), WINNT)
    CUTPERL = $(PERL) cut.perl
else
    CUTPERL = cut.perl
endif


# Hook for Makefile debug purpose
echo_%:
	+@echo variable $* is "$($*)" its origin is "$(origin $*)"

# Every file of this type is not erased if it was an intermediate target
.PRECIOUS: %.c %.s %.h

# to avoid infinite loop, don't retry if.
# in case no other rule apply, try to build the target in that directory
ifndef TRIED_THIS_TRICK
.DEFAULT: %
	@echo !!!! Trying last resort default
	$(MAKE) -C $(@D) TRIED_THIS_TRICK=1 $(@F)
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\include\make_arch.inc ===
##
## Copyright (c) 2000, Intel Corporation
## All rights reserved.
##
## WARRANTY DISCLAIMER
##
## THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
## A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
## PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
## OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
## NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
## MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##
## Intel Corporation is the author of the Materials, and requests that all
## problem reports or change requests be submitted to it directly at
## http://developer.intel.com/opensource.
##



######################################################################## 
#
# Tools common Make_isa.inc
#

# Common isa defenitions 

ifeq ($(TOOL_ARCH), P6V)
    TOOL_ARCH := P62
endif

ifeq ($(TOOL_ARCH), P6_SIMD)
    TOOL_ARCH := P62
endif

ifeq ($(TOOL_ARCH), P5_SIMD)
    TOOL_ARCH := P5V
endif

ifeq ($(TOOL_ARCH), EX86)
    TOOL_ARCH := PAX
endif

ifeq ($(TOOL_ARCH), P5)
    IA5_TOOLS = 1
    SUFFIX = p5
else
ifeq ($(TOOL_ARCH), P6)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SUFFIX = p6
else
ifeq ($(TOOL_ARCH), P5V)
    IA5_TOOLS = 1
    SIMD_TOOLS = 1
    SUFFIX = p5v
else
ifeq ($(TOOL_ARCH), P62)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SIMD_TOOLS = 1
    SUFFIX = p62
    
else
ifeq ($(TOOL_ARCH), P6_VX)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SIMD_TOOLS = 1
	VX_TOOLS = 1
    SUFFIX = p62x
    
else
ifeq ($(TOOL_ARCH), P68)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SIMD_TOOLS = 1
    VX_TOOLS = 1
    WMT_TOOLS =1	
    SUFFIX = p68
    
else
ifeq ($(TOOL_ARCH), P62_EM)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SIMD_TOOLS = 1
    VX_TOOLS =1
    EMA_TOOLS = 1
    SUFFIX = eia
    
else
ifeq ($(TOOL_ARCH), P7)
	IAX1K_TOOLS = 1
    IAX_TOOLS = 1
    SUFFIX = p7
else
ifeq ($(TOOL_ARCH), PAX)
    IAX_TOOLS = 1
    SUFFIX = ex86
else
ifeq ($(TOOL_ARCH), P1K)
    IAX1K_TOOLS = 1
    SUFFIX = p1k
else
ifeq ($(TOOL_ARCH), EAS)
    TAHOE_TOOLS = 1
    IAX1K_TOOLS = 1  
    SUFFIX = eas
else
ifeq ($(TOOL_ARCH), TAHOE)
    TAHOE_TOOLS = 1
    IAX1K_TOOLS = 1  
    SUFFIX = eas
else
ifeq ($(TOOL_ARCH), EMA)
    EMA_TOOLS = 1
    SUFFIX = em
else
ifeq ($(TOOL_ARCH), ALL)
    IA5_TOOLS = 1
    SIMD_TOOLS= 1
    IA6_TOOLS = 1
    IAX_TOOLS = 1
    IAX1K_TOOLS = 1
    TAHOE_TOOLS = 1
    EMA_TOOLS = 1
    VX_TOOLS = 1
    WMT_TOOLS = 1
    SUFFIX = all
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif

ifndef TOOL_ARCH
ifndef IAX_TOOLS
ifndef IAX1K_TOOLS
IA5_TOOLS = 1
endif
endif
endif

DECODER_LIB = dec$(SUFFIX)
DECODER_INC = dec$(SUFFIX).h
INSTID_INC  = insid$(SUFFIX).h

ENCODER_LIB = enc$(SUFFIX)
ENCODER_INC = enc$(SUFFIX).h

DISASM_LIB = dis$(SUFFIX)
DISASM_INC = dis$(SUFFIX).h

# Each makefile should recognize the following set of flag
# and translate them to private USER_CFLAGS for the compiler:

# IA5_TOOLS    - handle P5 isa
# IA6_TOOLS    - handle P6 isa
# SIMD_TOOLS   - handle SIMD/DSP IA-extention isa
# IAX_TOOLS    - handle iAX ("old") isa
# IAX1K_TOOLS  - handle 1K (STRAWMAN) isa
# TAHOE_TOOLS  - handle TAHOE (EAS 1.0) isa.
# EMA_TOOLS    - handle EM (EAS 2.0-, true encoding) isa.
# VX_TOOLS     - handle Katmai isa
# WMT_TOOLS    - handle Willamette isa
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\bind.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bind.c

Abstract:

Author:

Revision History:

--*/

#include <private.h>

#define STANDALONE_BIND

BOOL
Match(
    char *Pattern,
    char *Text
    )
{
    switch (*Pattern) {
       case '\0':
            return *Text == '\0';

        case '?':
            return *Text != '\0' && Match( Pattern + 1, Text + 1 );

        case '*':
            do {
                if (Match( Pattern + 1, Text ))
                    return TRUE;
                    }
            while (*Text++);
            return FALSE;

        default:
            return toupper( *Text ) == toupper( *Pattern ) && Match( Pattern + 1, Text + 1 );
        }
}


BOOL
AnyMatches(
    char *Name,
    int  *NumList,
    int  Length,
    char **StringList
    )
{
    if (Length == 0) {
        return FALSE;
        }

    return (Match( StringList[ NumList[ 0 ] ], Name ) ||
            AnyMatches( Name, NumList + 1, Length - 1, StringList )
           );
}

BOOL
BindStatusRoutine(
    IMAGEHLP_STATUS_REASON Reason,
    LPSTR ImageName,
    LPSTR DllName,
    ULONG64 Va,
    ULONG_PTR Parameter
    );

#define BIND_ERR 99
#define BIND_OK  0

PCHAR SymbolPath;

BOOL fVerbose;
BOOL fNoUpdate = TRUE;
BOOL fDisableNewImports;
BOOL fNoCacheImportDlls;
BOOL fBindSysImages;
DWORD BindFlags;

#ifndef _WIN64
BOOL
BindStatusRoutine32(
    IMAGEHLP_STATUS_REASON Reason,
    LPSTR ImageName,
    LPSTR DllName,
    ULONG Va,
    ULONG Parameter
    )
{
    return BindStatusRoutine(Reason, ImageName, DllName, Va, Parameter);
}
#endif

int ExcludeList[256];
int ExcludeListLength = 0;

LPSTR DllPath;
LPSTR CurrentImageName;
char **ArgList;
DWORD dwVersion;

void DoBind(char *p);

int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    char c, *p;

    BOOL fUsage = FALSE;

    int ArgNumber = argc;

    ArgList = argv;

    DllPath = NULL;
    CurrentImageName = NULL;

    if (argc < 2) {
        goto usage;
    }

    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
                case '?':
                    fUsage = TRUE;
                    break;

                case 'C':
                    fNoCacheImportDlls = TRUE;
                    break;

                case 'O':
                    fDisableNewImports = TRUE;
                    break;

                case 'P':
                    if (--argc) {
                        DllPath = *++argv;
                    } else {
                        fprintf( stderr, "BIND: Parameter missing for /%c\n", c );
                        fUsage = TRUE;
                    }
                    break;

                case 'S':
                    if (--argc) {
                        SymbolPath = *++argv;
                    } else {
                        fprintf( stderr, "BIND: Parameter missing for /%c\n", c );
                        fUsage = TRUE;
                    }
                    break;

                case 'U':
                    fNoUpdate = FALSE;
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'X' :
                    if (--argc) {
                        ++argv;
                        ExcludeList[ExcludeListLength] = ArgNumber - argc;
                        ExcludeListLength++;
                    } else {
                        fprintf( stderr, "BIND: Parameter missing for /%c\n", c );
                        fUsage = TRUE;
                    }
                    break;

                case 'Y':
                    fBindSysImages = TRUE;
                    break;

                default:
                    fprintf( stderr, "BIND: Invalid switch - /%c\n", c );
                    fUsage = TRUE;
                    break;
                }
            if (fUsage) {
usage:
                fputs("usage: BIND [switches] image-names... \n"
                      "            [-?] display this message\n"
                      "            [-c] no caching of import dlls\n"
                      "            [-o] disable new import descriptors\n"
                      "            [-p dll search path]\n"
                      "            [-s Symbol directory] update any associated .DBG file\n"
                      "            [-u] update the image\n"
                      "            [-v] verbose output\n"
                      "            [-x image name] exclude this image from binding\n"
                      "            [-y] allow binding on images located above 2G",
                      stderr
                     );
                return BIND_ERR;
            }
        } else {
            BindFlags = 0;

            if (!fNoCacheImportDlls) {
                // Always cache across calls unless the user indicates otherwise.
                BindFlags |= BIND_CACHE_IMPORT_DLLS;
            }
            if (fNoUpdate) {
                BindFlags |= BIND_NO_UPDATE;
            }
            if (fDisableNewImports) {
                BindFlags |= BIND_NO_BOUND_IMPORTS;
            }
            if (fBindSysImages) {
                BindFlags |= BIND_ALL_IMAGES;
            }

            dwVersion = GetVersion();
#if !defined(_WIN64) && !defined(STANDALONE_BIND)
            if ((HIWORD(dwVersion) & 0x3fff) > 3600) {
                // NT build > 3600 - supports 64-bit VA's on X86
                    BindFlags |= BIND_REPORT_64BIT_VA;
            }
#endif

            if (*p == '@') {
                FILE *hFiles;
                int ScanRet;
                CHAR pchFileName[_MAX_PATH];

                p++;

                hFiles=fopen(p, "rt");
                if (hFiles == NULL) {
                    fprintf( stderr, "BIND: fopen %s failed %d\n", p, errno );
                    ExitProcess( BIND_ERR );
                }

                ScanRet = fscanf( hFiles, "%s", pchFileName);
                while (ScanRet && ScanRet != EOF) {
                    DoBind(pchFileName);
                    ScanRet = fscanf( hFiles, "%s", pchFileName );
                }
            } else {
                DoBind(p);
            }
        }
    }

    return BIND_OK;
}

void
DoBind(char *p)
{
    CurrentImageName = p;
    if (fVerbose) {
        fprintf( stdout,
                 "BIND: binding %s using DllPath %s\n",
                 CurrentImageName,
                 DllPath ? DllPath : "Default"
               );
    }

    if (AnyMatches( CurrentImageName, ExcludeList, ExcludeListLength, ArgList )) {
        if (fVerbose) {
            fprintf( stdout, "BIND: skipping %s\n", CurrentImageName );
        }
    } else {
#if !defined(_WIN64) && !defined(STANDALONE_BIND)
        {
            if ((HIWORD(dwVersion) & 0x3fff) > 3600) {
                // NT build > 3600 - supports 64-bit VA's on X86

                    BindImageEx( BindFlags,
                                 CurrentImageName,
                                 DllPath,
                                 SymbolPath,
                                 (PIMAGEHLP_STATUS_ROUTINE)BindStatusRoutine
                               );
            } else {
                BindImageEx( BindFlags,
                             CurrentImageName,
                             DllPath,
                             SymbolPath,
                             (PIMAGEHLP_STATUS_ROUTINE)BindStatusRoutine32
                           );
            }
        }
#else
        BindFlags |= BIND_REPORT_64BIT_VA;

        BindImageEx( BindFlags,
                     CurrentImageName,
                     DllPath,
                     SymbolPath,
                     (PIMAGEHLP_STATUS_ROUTINE)BindStatusRoutine
                   );
#endif
    }
}

BOOL
BindStatusRoutine(
    IMAGEHLP_STATUS_REASON Reason,
    LPSTR ImageName,
    LPSTR DllName,
    ULONG64 Va,
    ULONG_PTR Parameter
    )
{
    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImports, NewImport;
    PIMAGE_BOUND_FORWARDER_REF NewForwarder;
    UINT i;

    switch( Reason ) {
        case BindOutOfMemory:
            fprintf( stderr, "BIND: Out of memory - needed %u bytes.\n", Parameter );
            ExitProcess( 1 );

        case BindRvaToVaFailed:
            fprintf( stderr, "BIND: %s contains invalid Rva - %08.8X\n", ImageName, (ULONG)Va );
            break;

        case BindNoRoomInImage:
            fprintf( stderr,
                     "BIND: Not enough room for new format import table.  Defaulting to unbound image.\n"
                   );
            break;

        case BindImportModuleFailed:
            fprintf( stderr,"BIND: %s - Unable to find %s\n", ImageName, DllName );
            break;

        case BindImportProcedureFailed:
            fprintf( stderr,
                     "BIND: %s - %s entry point not found in %s\n",
                     ImageName,
                     (char *)Parameter,
                     DllName
                   );
            break;

        case BindImportModule:
            if (fVerbose) {
                fprintf( stderr,"BIND: %s - Imports from %s\n", ImageName, DllName );
                }
            break;

        case BindImportProcedure64:
#ifdef _WIN64
        case BindImportProcedure:
#endif
            if (fVerbose) {
                fprintf( stderr,
                         "BIND: %s - %s Bound to %16.16I64X\n",
                         ImageName,
                         (char *)Parameter,
                         Va
                       );
                }
            break;

        case BindImportProcedure32:
#ifndef _WIN64
        case BindImportProcedure:
#endif
            if (fVerbose) {
                fprintf( stderr,
                         "BIND: %s - %s Bound to %08.8X\n",
                         ImageName,
                         (char *)Parameter,
                         (ULONG)Va
                       );
                }
            break;

        case BindForwarder64:
#ifdef _WIN64
        case BindForwarder:
#endif
            if (fVerbose) {
                fprintf( stderr, "BIND: %s - %s forwarded to %s [%16.16I64X]\n",
                         ImageName,
                         DllName,
                         (char *)Parameter,
                         Va
                       );
            }
            break;

        case BindForwarder32:
#ifndef _WIN64
        case BindForwarder:
#endif
            if (fVerbose) {
                fprintf( stderr, "BIND: %s - %s forwarded to %s [%08.8X]\n",
                         ImageName,
                         DllName,
                         (char *)Parameter,
                         Va
                       );
            }
            break;

        case BindForwarderNOT64:
#ifdef _WIN64
        case BindForwarderNOT:
#endif
            if (fVerbose) {
                fprintf( stderr,
                         "BIND: %s - Forwarder %s not snapped [%16.16I64X]\n",
                         ImageName,
                         (char *)Parameter,
                         Va
                       );
                }
            break;

        case BindForwarderNOT32:
#ifndef _WIN64
        case BindForwarderNOT:
#endif
            if (fVerbose) {
                fprintf( stderr,
                         "BIND: %s - Forwarder %s not snapped [%08.8X]\n",
                         ImageName,
                         (char *)Parameter,
                         Va
                       );
                }
            break;

        case BindImageModified:
            fprintf( stdout, "BIND: binding %s\n", ImageName );
            break;


        case BindExpandFileHeaders:
            if (fVerbose) {
                fprintf( stderr,
                         "    Expanded %s file headers to %x\n",
                         ImageName,
                         Parameter
                       );
                }
            break;

        case BindMismatchedSymbols:
            fprintf(stderr, "BIND: Warning: %s checksum did not match %s\n",
                            ImageName,
                            (LPSTR)Parameter);
            break;

        case BindSymbolsNotUpdated:
            fprintf(stderr, "BIND: Warning: symbol file %s not updated.\n",
                            (LPSTR)Parameter);
            break;

        case BindImageComplete:
            if (fVerbose) {
                fprintf(stderr, "BIND: Details of binding of %s\n", ImageName );
                NewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)Va;
                NewImport = NewImports;
                while (NewImport->OffsetModuleName) {
                    fprintf( stderr, "    Import from %s [%x]",
                             (LPSTR)NewImports + NewImport->OffsetModuleName,
                             NewImport->TimeDateStamp
                           );
                    if (NewImport->NumberOfModuleForwarderRefs != 0) {
                        fprintf( stderr, " with %u forwarders", NewImport->NumberOfModuleForwarderRefs );
                    }
                    fprintf( stderr, "\n" );
                    NewForwarder = (PIMAGE_BOUND_FORWARDER_REF)(NewImport+1);
                    for ( i=0; i<NewImport->NumberOfModuleForwarderRefs; i++ ) {
                        fprintf( stderr, "        Forward to %s [%x]\n",
                                 (LPSTR)NewImports + NewForwarder->OffsetModuleName,
                                 NewForwarder->TimeDateStamp
                               );
                        NewForwarder += 1;
                    }
                    NewImport = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)NewForwarder;
                }
            }
            break;

        default:
            break;
    }

    return TRUE;
}

#include <bindi.c>

#define STANDALONE_MAP
#include <mapi.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ia64tools\include\iel.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef IEL_H
#define IEL_H

#if defined(BIG_ENDIAN) && defined(BYTE_ORDER)
#if BYTE_ORDER != BIG_ENDIAN
#undef BIG_ENDIAN
#endif
#endif


typedef char  S1byte;
typedef short S2byte;
typedef int   S4byte;

typedef unsigned char  U1byte;
typedef unsigned short U2byte;
typedef unsigned int   U4byte;

typedef unsigned short U16;
typedef unsigned char  U8;


/*---------
         IEL types declarations
                              ------------*/


#ifdef  LP64

#ifdef WINNT
typedef unsigned __int64 Ulong64;
typedef __int64 Slong64;
#else
typedef unsigned long Ulong64;
typedef long Slong64;
#endif

extern  Ulong64         IEL_temp64;

typedef union
{
    U4byte dw[1];
    U4byte qw[1];
}U32, S32;

typedef union
{
    Ulong64 qw[1];
    unsigned int dw[2];
} U64,S64;

typedef union
{
    Ulong64   qw[2];
    unsigned int dw[4];
} U128, S128;

#else /* LP32 */
      
typedef struct
{
    U4byte dw[1];
}U32, S32;

typedef struct
{
    U4byte   dw[2];
} U64, S64;

typedef struct
{
    U4byte   dw[4];
} U128,S128;

#endif /* end of LP32 */

/*---------
         IEL temporary variables
                              ------------*/

#ifdef __cplusplus
extern "C" {
#endif

extern  unsigned int    IEL_t1, IEL_t2, IEL_t3, IEL_t4;
extern  U32             IEL_tempc;
extern  U64             IEL_et1, IEL_et2;
extern  U128            IEL_ext1, IEL_ext2, IEL_ext3, IEL_ext4, IEL_ext5;
extern  U128            IEL_POSINF, IEL_NEGINF, IEL_MINUS1;
extern  S128            IEL_ts1, IEL_ts2;

#ifdef __cplusplus
}
#endif

/*---------
         IEL constants
                    ------------*/
#define IEL_MAX32 ((U4byte) (0xFFFFFFFF))
#define IEL_UMAX32 ((U4byte) (0xFFFFFFFF))
#define IEL_SMAX32 ((U4byte) (0x7FFFFFFF))

#define IEL_UMAX64  0xffffffffffffffff
#define IEL_SMAX64  0x7fffffffffffffff

#define IEL128(x) (*(U128*)(&(x)))
#define IEL64(x)  (*(U64*)(&(x)))
#define IEL32(x)  (*(U32*)(&(x)))



#define IEL_FALSE 0
#define IEL_TRUE  1

#ifdef __cplusplus

#define IEL_OK 0
#define IEL_OVFL 1

typedef unsigned int IEL_Err;

#else

typedef enum
{
    IEL_OK = 0,
    IEL_OVFL
} IEL_Err;
#endif

typedef enum
{
    IEL_BIN = 2,
    IEL_OCT = 8,
    IEL_DEC = 10,
    IEL_SDEC = 100,
    IEL_HEX = 16,
    IEL_UHEX = 116
} IEL_Base;

/*----------
         IEL structure elements
                         ---------*/

#   ifdef   BIG_ENDIAN

#       define  qw0_64 qw[0]
#       define  qw0_128 qw[1]
#       define  qw1_128 qw[0]
#       define  dw0_32  dw[0]
#       define  dw0_64  dw[1]
#       define  dw1_64  dw[0]
#       define  dw0_128 dw[3]
#       define  dw1_128 dw[2]
#       define  dw2_128 dw[1]
#       define  dw3_128 dw[0]

#   else  /*** BIG_ENDIAN ***/

#       define  qw0_64 qw[0]
#       define  qw0_128 qw[0]
#       define  qw1_128 qw[1]
#       define  dw0_32  dw[0]
#       define  dw0_64  dw[0]
#       define  dw1_64  dw[1]
#       define  dw0_128 dw[0]
#       define  dw1_128 dw[1]
#       define  dw2_128 dw[2]
#       define  dw3_128 dw[3]

#   endif /*** BIG_ENDIAN ***/


#define DW0(x)          ((sizeof((x))==4)?((x).dw0_32):\
                         (sizeof((x))==8)?((x).dw0_64):\
                         (sizeof((x))==16)?((x).dw0_128):0)
#define DW1(x)          ((sizeof((x))==8)?((x).dw1_64):\
                         (sizeof((x))==16)?((x).dw1_128):0)
#define DW2(x)          ((sizeof((x))==16)?((x).dw2_128):0)
#define DW3(x)          ((sizeof((x))==16)?((x).dw3_128):0)

#define IEL_GETDW0(x) DW0(x) 
#define IEL_GETDW1(x) DW1(x)
#define IEL_GETDW2(x) DW2(x)
#define IEL_GETDW3(x) DW3(x)

#ifdef  LP64

#define IEL_CONST32(x)      {(U4byte )(x)}
#define IEL_CONST(x)        IEL_CONST32(x)
#define IEL_CONST64L(x)     {(Ulong64 )(x)}

#ifdef BIG_ENDIAN

#define IEL_CONST64(x0, x1)             {((Ulong64)x0<<32)|x1}
#define IEL_CONST128(x0, x1, x2, x3)    {{((Ulong64)x2<<32)|x3, ((Ulong64)x0<<32)|x1}}
#define IEL_CONST128L(x0, x1)           {{(Ulong64 )x1, (Ulong64 )x0}}

#else /* BIG_ENDIAN */

#define IEL_CONST64(x0, x1)             {((Ulong64)x1<<32)|x0}
#define IEL_CONST128(x0, x1, x2, x3)    {{((Ulong64)x1<<32)|x0, ((Ulong64)x3<<32)|x2}}
#define IEL_CONST128L(x0, x1)           {{(Ulong64 )x0, (Ulong64 )x1}}

#endif /* BIG_ENDIAN */

#define IEL_GETQW0(x)    ((sizeof(x)==4) ? (Ulong64)((x).dw0_32) : \
                         ((sizeof(x)==8) ?  (x).qw0_64 : \
                         ((sizeof(x)==16) ? (x).qw0_128 : 0)))

#define IEL_GETQW1(x)   ((sizeof(x)==sizeof (U128)) ? ((x).qw1_128) : (0))

#define QW0(x) IEL_GETQW0(x)
#define QW1(x) IEL_GETQW1(x)

#define SQW0(x)     ((sizeof(x)==4)? (((x).dw0_32 & 0x80000000)? \
                     (((Ulong64)(-1)<<32) | (Ulong64)(x).dw0_32) : (Ulong64)(x).dw0_32) : \
                     (sizeof(x)==8)?((x).qw0_64):\
                     (sizeof(x)==16)?((x).qw0_128):0)

#define SQW1(x)    ((sizeof(x)==4)? (((x).dw0_32 & 0x80000000)? (Ulong64)(-1):0) :\
                    (sizeof(x)==8)?((x).qw0_64 & 0x8000000000000000)?(Ulong64)(-1):0 :\
                    (sizeof(x)==16)?((x).qw1_128):0)

#define IEL_INCU(x)      ((sizeof(x) == sizeof(U32)) ? \
                            ((x).dw0_32++,((x).dw0_32==0)) :\
                         (sizeof(x) == sizeof(U64)) ? \
                            ((x).qw0_64++,((x).qw0_64==0)) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            ((x).qw0_128++,(!(x).qw0_128) ? \
                             ((x).qw1_128++, ((x).qw1_128==0)) : \
                             IEL_OK) : IEL_OVFL)

#define IEL_INCS(x)     ((sizeof(x) == sizeof(U32)) ? \
                          (((x).dw0_32++),(((x).dw0_32==0x80000000)||((x).dw0_32==0))) : \
						(sizeof(x) == sizeof(U64)) ? \
                         (((x).qw0_64++),(((x).qw0_64==0x8000000000000000)||((x).qw0_64==0))) : \
                           (sizeof(x) == sizeof(U128)) ? \
                          ((x).qw0_128++, !(x).qw0_128? ((x).qw0_128=0, (x).qw1_128++, \
                             (((x).qw1_128==0)||((x).qw1_128==0x8000000000000000))) : IEL_OK): \
                           IEL_OVFL)
                             

#define IEL_DECU(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32--),((x).dw0_32==IEL_MAX32)) : \
                         (sizeof(x) == sizeof(U64)) ? \
                            ((x).qw0_64--,((x).qw0_64==IEL_UMAX64)) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            ((x).qw0_128--,((x).qw0_128==IEL_UMAX64) ? \
                             ((x).qw1_128--, ((x).qw1_128==IEL_UMAX64)) : \
                             IEL_OK) : IEL_OVFL)

#define IEL_DECS(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32--),((x).dw0_32==IEL_UMAX32) || \
                             (x).dw0_32==IEL_SMAX32) : \
                         (sizeof(x) == sizeof(U64)) ? \
                            (((x).qw0_64--),(((x).qw0_64==IEL_UMAX64))||((x).qw0_64==IEL_SMAX64)) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            ((x).qw0_128--,((x).qw0_128==IEL_UMAX64) ? \
                             ((x).qw1_128--, ((x).qw1_128==IEL_UMAX64)|| \
                             ((x).qw1_128==IEL_SMAX64)): \
                             IEL_OK) : IEL_OVFL)

#define IEL_AND(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) & DW0(z), \
                                  ((DW1(y) & DW1(z)) || (QW1(y) & QW1(z)))) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).qw0_64 = QW0(y) & QW0(z)), \
                                 ((QW1(y) & QW1(z)) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y) & QW0(z), \
                                 (x).qw1_128 = QW1(y) & QW1(z),IEL_OK) : \
                                 IEL_OVFL)

#define IEL_OR(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) | DW0(z), \
                                 (((DW1(y) | DW1(z)) ||(QW1(y) | QW1(z))))) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).qw0_64 = QW0(y) | QW0(z)), \
                                 ((QW1(y) | QW1(z)) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y) | QW0(z), \
                                 (x).qw1_128 = QW1(y) | QW1(z),IEL_OK) : \
                                 IEL_OVFL)

#define IEL_XOR(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) ^ DW0(z), \
                                 (((DW1(y) ^ DW1(z))||(QW1(y) ^ QW1(z))))) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).qw0_64 = QW0(y) ^ QW0(z)), \
                                 ((QW1(y) ^ QW1(z)) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y) ^ QW0(z), \
                                 (x).qw1_128 = QW1(y) ^ QW1(z),IEL_OK) : \
                                 IEL_OVFL)

#define IEL_ANDNOT(x, y, z)  ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) & ~DW0(z), \
                                 (((DW1(y) & ~DW1(z))||(QW1(y) & ~QW1(z))))) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).qw0_64 = QW0(y) & (~QW0(z))), \
                                 ((QW1(y) & (~QW1(z))) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y) & (~QW0(z)), \
                                 (x).qw1_128 = QW1(y) & (~QW1(z)),IEL_OK) : \
                                 IEL_OVFL)


#define IEL_ASSIGNU(x, y)   	((sizeof(x) == sizeof(U32)) ?\
                                ((x).dw0_32 = (y).dw0_32, (DW1(y) || QW1(y))):\
								(sizeof(x) == sizeof (U64)) ? \
                                ((x).qw0_64 = QW0(y), (QW1(y)!=0)) : \
                                (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y), (x).qw1_128 = QW1(y), \
                                 IEL_OK) : IEL_OVFL)

#define IEL_ASSIGNS(x, y)   (IEL_ext1.qw0_128 = SQW0(y), \
                             IEL_ext1.qw1_128 = SQW1(y), \
                             (sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = IEL_ext1.dw0_128, \
                                 ((x).dw0_32 & 0x80000000) ? \
                                 (~IEL_ext1.dw1_128||~IEL_ext1.qw1_128) : \
                                 (IEL_ext1.dw1_128 || IEL_ext1.qw1_128)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                              ((x).qw0_64 = IEL_ext1.qw0_128,\
                               ((x).qw0_64 & 0x8000000000000000)?\
                               (~IEL_ext1.qw1_128 !=0): (IEL_ext1.qw1_128!=0)):\
                              (sizeof(x) == sizeof (U128)) ? \
                               ((x).qw0_128 = IEL_ext1.qw0_128,\
                                (x).qw1_128 = IEL_ext1.qw1_128, IEL_OK):\
                               IEL_OVFL)
                             
#define IEL_NOT(x, y)       ((sizeof(x )== sizeof(U32)) ? \
                                ((x).dw0_32 = (~DW0(y)), \
                                 ((~DW1(y))|| (~QW1(y)))): \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).qw0_64 = (~QW0(y)), \
                                 ((~QW1(y)) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = (~QW0(y)),\
                                 (x).qw1_128 = (~QW1(y)), \
                                 IEL_OK) : IEL_OVFL)

#define IEL_ZERO(x)         ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = 0) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).qw0_64 = 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = 0, (x).qw1_128 = 0, IEL_OK): \
                                IEL_OVFL)
                            

#define QW1_1(x)    ((sizeof(x)==16)? ((x).qw1_128):1)

#define IEL_C0(x) (QW0(x) < QW0(IEL_ext1))
/*#define IEL_C1(x) ((QW1(x)-IEL_C0(x)) < QW1(IEL_ext1))*/

#define IEL_C1(x) (IEL_C0(x) ? (QW1_1(x)<=QW1(IEL_ext1)) : (QW1(x)<QW1(IEL_ext1)))


#define IEL_ADDU(x, y, z)   ((sizeof(x)==sizeof(U32))?\
                                (IEL_t1=DW0(y),(x).dw0_32=DW0(y)+DW0(z),\
                                 ((IEL_t1>DW0(x))||(DW1(y))||(QW1(y)) ||\
                                (DW1(z))||(QW1(z)))):\
                             (sizeof(x)==sizeof(U64))?\
                                (IEL_temp64 = QW0(y),(x).qw0_64=QW0(y)+QW0(z),\
                                 ((IEL_temp64 > QW0(x))||(QW1(y))||(QW1(z)))):\
                             (sizeof(x)==sizeof(U128))?\
                                (IEL_ASSIGNU(IEL_ext1, y),\
                                 (x).qw0_128=QW0(y)+QW0(z),\
                                 (x).qw1_128=QW1(y)+QW1(z)+IEL_C0(x),\
                                 IEL_C1(x)) : IEL_OVFL)

#define IEL_EQU(x, y)       (((Ulong64)QW0(x)==(Ulong64)QW0(y)) && \
                             ((Ulong64)QW1(x)==(Ulong64)QW1(y)))

#define IEL_ISZERO(x)       ((QW0(x)==0) && (QW1(x)==0))

#define IEL_CMPGU(x, y)     ((QW1(x)>QW1(y)) || \
                             ((QW1(x)==QW1(y)) && (QW0(x)>QW0(y))))

#define IEL_CMPGEU(x, y)        ((QW1(x)>QW1(y)) || \
                             ((QW1(x)==QW1(y)) && (QW0(x)>=QW0(y))))

#define IEL_SHL(x, y, n)    ((((n) <=0) || ((n) >= (sizeof(x) << 3)))? \
                                 ((IEL_ISZERO(y)||(!(n)))? \
                                  (IEL_ASSIGNU(x,y),IEL_OK) : \
                                   (IEL_ZERO(x), IEL_OVFL)) : \
                             ((sizeof(x) == sizeof (U32)) ? \
                                (IEL_t1 = (DW1(y) || DW2(y) || DW3(y) \
                                 || (DW0(y)>= (U4byte)1<<(32-(n)))), \
                                 (x).dw0_32 = DW0(y) << (n), (IEL_t1)) : \
                              (sizeof(x) == sizeof (U64)) ? \
                              (IEL_t1 = QW1(y)||(QW0(y) >= (Ulong64)1<<(64-(n))), \
                              (x).qw0_64= QW0(y)<<(n),IEL_t1): \
                               ((sizeof(x) == sizeof(U128)) ? \
                              ((n)==64)? \
                               (IEL_t1=(QW1(y)>0),(x).qw1_128=QW0(y),\
                                (x).qw0_128=0,IEL_t1) : \
                               ((n)<64)? \
                               (IEL_t1 = (QW1(y) >= (Ulong64)1<<(64-(n))),\
                                (x).qw1_128 = (QW1(y)<<(n))|\
                                QW0(y)>>(64-(n)),\
                                (x).qw0_128 = QW0(y) << (n), IEL_t1) :\
                                /* n > 64 */\
                               (IEL_t1 = (QW1(y))||\
                                          (QW0(y) >= (Ulong64)1<<(128-(n))),\
                                 (x).qw1_128 = QW0(y) << ((n)-64),(x).qw0_128 = 0,\
                                 IEL_t1):IEL_OVFL)))

#define IEL_SHL128(x, y, n)   (((n)==64)? \
                               (IEL_t1=(QW1(y)>0),(x).qw1_128=QW0(y),\
                                (x).qw0_128=0,IEL_t1) : \
                               ((n)<64)? \
                               (IEL_t1 = (QW1(y) >= (Ulong64)1<<(64-(n))),\
                                (x).qw1_128 = (QW1(y)<<(n))|\
                                QW0(y)>>(64-(n)),\
                                (x).qw0_128 = QW0(y) << (n), IEL_t1) :\
                                /* n > 64 */\
                               (IEL_t1 = QW1(y)||\
                                          (QW0(y) >= (Ulong64)1<<(128-(n))),\
                                (x).qw1_128 = QW0(y) << ((n)-64),(x).qw0_128 = 0,\
                                 IEL_t1))



#define IEL_ISNEG(x)        ((sizeof(x) == sizeof(U32)) ? \
                                ((DW0(x) & 0x80000000)!=0) : \
                             (sizeof(x) == sizeof(U64)) ? \
                                ((QW0(x) & 0x8000000000000000)!=0) : \
                             (sizeof(x) == sizeof(U128)) ? \
                                ((QW1(x) & 0x8000000000000000)!=0) : IEL_FALSE)

#define IEL_ISNINF(x)        ((sizeof(x) == sizeof(U32)) ? \
                                (DW0(x)==0x80000000) : \
                             (sizeof(x) == sizeof(U64)) ? \
                                (QW0(x)==0x8000000000000000) : \
                             (sizeof(x) == sizeof(U128)) ? \
                                (QW1(x)==0x8000000000000000 && QW0(x)==0) : \
                                (IEL_OVFL))




#define IEL_INL(x, n)       (((((Ulong64)1<<n)-1) & x))
#define IEL_INH(x, n)       (x>>n)

#define IEL_SHR(x, y, n)  \
(((n) <=0)?  ((IEL_ISZERO(y)||(!n)) \
              ?  (IEL_ASSIGNU(x,y),IEL_OK)\
              :  (IEL_ZERO(x), IEL_OVFL))\
          : \
         ((sizeof(x) == sizeof (U32)) ? \
        ((n)==64) ?  \
                  ((x).dw0_32 = (U4byte)QW1(y), (DW3(y)!=0)) : \
        ((n)>64) ? \
             ((x).dw0_32 = (U4byte)(QW1(y)>>((n)-64)),\
             ((QW1(y)>>((n)-64))> QW0(x))) : \
        /* n < 64 */  \
             (IEL_temp64 = (QW0(y)>>(n))|(QW1(y)<<(64-(n))),\
			 (x).dw0_32 = (U4byte)IEL_temp64, \
             ((QW1(y)>>(n))> 0) || (IEL_temp64 > QW0(x))) : \
       (sizeof(x) == sizeof (U64)) \
   ? (((n)==64)?  ((x).qw0_64=QW1(y),IEL_OK)\
               :(((n) < 64)?  ((x).qw0_64 = (QW0(y)>>(n))|(QW1(y)<<(64-(n))),\
                              (QW1(y)>>(n)!=0))\
                /* n > 64 */  :  ((x).qw0_64 = QW1(y)>>((n)-64), IEL_OK)))\
   :(sizeof(x) == sizeof(U128)) \
     ?  (((n)==64)?  ((x).qw0_128=QW1(y),(x).qw1_128=0,IEL_OK) \
                  : (((n)<64)?  ((x).qw0_128 = (QW0(y)>>(n))|(QW1(y)<<(64-(n))),\
                                 (x).qw1_128 = QW1(y)>>(n),\
                                 IEL_OK)\
                   /* n>64 */:  ((x).qw0_128=QW1(y)>>((n)-64),(x).qw1_128=0,\
                                 IEL_OK)))\
     : IEL_OVFL))


#define IEL_SHR128(x, y, n) (((n) <=0) ? \
                             ((IEL_ISZERO(y)||!(n)) ? \
                              (IEL_ASSIGNU(x, y), IEL_OK) :\
                              (IEL_ZERO(x), IEL_OVFL)): \
                               (sizeof(x) == sizeof (U128)) ? \
                       (n==64) ?  \
                                ((x).qw0_128 = QW1(y), \
                                (x).qw1_128 = 0, (IEL_OK)) : \
                       (((n)<64)?  ((x).qw0_128 = (QW0(y)>>(n))|(QW1(y)<<(64-(n))),\
                                 (x).qw1_128 = QW1(y)>>(n),IEL_OK)\
                   /* n>64 */:  ((x).qw0_128=QW1(y)>>((n)-64),(x).qw1_128=0,\
                                 IEL_OK)): IEL_OVFL)

#define IEL_SEXT(x, y)      (IEL_ASSIGNU(x,y),\
                             ((!IEL_ISNEG(y)) || (sizeof(x)==sizeof(y))) ? \
                             (IEL_OK) : \
                            ((sizeof(x) == sizeof(U64)) ? \
                                ((sizeof(y) == sizeof(U32)) ? \
                                    ((x).dw1_64=IEL_MAX32,IEL_OK):(IEL_OVFL)): \
                            ((sizeof(x) == sizeof(U128)) ? \
                                ((sizeof(y) == sizeof(U32)) ? \
                                    ((x).dw1_128 = IEL_MAX32, \
                                     (x).dw2_128 = IEL_MAX32, \
                                     (x).dw3_128 = IEL_MAX32, IEL_OK) : \
                                (sizeof(y) == sizeof (U64)) ? \
                                    ((x).dw2_128 = IEL_MAX32, \
                                    (x).dw3_128 = IEL_MAX32, IEL_OK):IEL_OVFL):\
                                (IEL_OVFL))))


#define IEL_ISNEG128(x)      (((x).qw1_128 & 0x8000000000000000)!=0)


#define IEL_ADDU128(x, y, z) (IEL_ASSIGNU(IEL_ext1, y),\
                                (x).qw0_128=(y).qw0_128 + (z).qw0_128,\
                                 (x).qw1_128=(y).qw1_128+(z).qw1_128+ IEL_C0(x),\
                                 IEL_C1(x))

#define iel_check_result_sign(addend1, addend2, res)\
   ((((addend1.qw1_128 ^ addend2.qw1_128) & 0x8000000000000000) == 0) && \
    (((addend1.qw1_128 ^ res.qw1_128) & 0x8000000000000000) != 0))

#define IEL_ADDS(x, y, z)   (IEL_ASSIGNS(IEL_ext4, y), \
                             IEL_ASSIGNS(IEL_ext2, z), \
                             IEL_ADDU128(IEL_ext3, IEL_ext4, IEL_ext2), \
                             IEL_ASSIGNS(x, IEL_ext3)||\
                             iel_check_result_sign(IEL_ext4, IEL_ext2, IEL_ext3))

#define IEL_SUBU(x, y, z) (IEL_ISZERO(z) ? IEL_ASSIGNU(x, y) : \
                           (IEL_COMP(IEL_ext2 ,z), \
                           (!(IEL_ADDU(x, y,IEL_ext2)))))

#define IEL_CONVERT4L(x, y0, y1) \
                             ((sizeof(x) == sizeof(U64)) ? \
                                ((x).qw0_64 = y0, y1):\
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).qw0_128 = y0, \
                                 (x).qw1_128 = y1, \
                                 IEL_OK) : IEL_OVFL)

#define IEL_CONVERT2L(x,y0) IEL_CONVERT4L(x,y0,0)

#define IEL128(x) (*(U128*)(&(x)))

#else /* not LP64 */

#define IEL_CONST32(x)      {(U4byte )(x)}
#define IEL_CONST(x)        IEL_CONST32(x)

#ifdef BIG_ENDIAN

#define IEL_CONST64(x0, x1)         {{(U4byte )(x1),(U4byte )(x0)}}
#define IEL_CONST128(x0, x1, x2, x3)    {{x3, x2, x1, x0}}

#else /* BIG_ENDIAN */

#define IEL_CONST64(x0, x1)         {{(U4byte )(x0), (U4byte )(x1)}}
#define IEL_CONST128(x0, x1, x2, x3)    {{x0, x1, x2, x3}}

#endif /* BIG_ENDIAN */

/* DWn_1(x) macros return 1 (instead of 0) in order to  prevent warnings */
/* This does not affect the produced code since the 1 can appear only in */
/* a "dead portion of code" derived by preprocessor */

#define DW1_1(x)    ((sizeof((x))==8)?((x).dw1_64):\
                         (sizeof((x))==16)?((x).dw1_128):1)
#define DW2_1(x)    ((sizeof((x))==16)?((x).dw2_128):1)
#define DW3_1(x)    ((sizeof((x))==16)?((x).dw3_128):1)





#define SDW0(x)         ((sizeof((x))==4)?((x).dw0_32):\
                         (sizeof((x))==8)?((x).dw0_64):\
                         (sizeof((x))==16)?((x).dw0_128):0)
#define SDW1(x)         ((sizeof((x))==4)?((x).dw0_32 & 0x80000000) ? -1 : 0 : \
                         (sizeof((x))==8)?((x).dw1_64): \
                         (sizeof((x))==16)?((x).dw1_128):0)
#define SDW2(x)         ((sizeof((x))==4)?((x).dw0_32 & 0x80000000) ? -1 : 0 :\
                         (sizeof((x))==8)?((x).dw1_64 & 0x80000000) ? -1 : 0 :\
                         (sizeof((x))==16)?((x).dw2_128):0)
#define SDW3(x)         ((sizeof((x))==4)?((x).dw0_32 & 0x80000000) ? -1 : 0 :\
                         (sizeof((x))==8)?((x).dw1_64 & 0x80000000) ? -1 : 0 :\
                         (sizeof((x))==16)?((x).dw3_128):0)



#define IEL_INCU(x)     ((sizeof(x)==4) ? \
                            (((x).dw0_32++),((x).dw0_32==0)) : \
                         (sizeof(x)==8) ? \
                            (((x).dw0_64++),!((x).dw0_64) ? \
                             ((x).dw1_64++, ((x).dw1_64==0)) : IEL_OK) : \
                         (sizeof(x)==16) ? \
                            (((x).dw0_128++),!((x).dw0_128) ? \
                            (((x).dw1_128++),!((x).dw1_128) ? \
                            (((x).dw2_128++),!((x).dw2_128) ? \
                            (((x).dw3_128++),((x).dw3_128==0)) : \
                             (IEL_OK)) : (IEL_OK)) : (IEL_OK)) : IEL_OVFL)

#define IEL_INCS(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32++),(((x).dw0_32==0)) || \
                             (x).dw0_32==0x80000000): \
                         (sizeof(x) == sizeof(U64)) ? \
                            (((x).dw0_64++),!((x).dw0_64) ? \
                             ((x).dw1_64++, ((x).dw1_64==0) || \
                              (x).dw1_64==0x80000000) : IEL_OK) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            (((x).dw0_128++),!((x).dw0_128) ? \
                            (((x).dw1_128++),!((x).dw1_128) ? \
                            (((x).dw2_128++),!((x).dw2_128) ? \
                            (((x).dw3_128++),((x).dw3_128==0) || \
                            (x).dw3_128==0x80000000) : \
                             (IEL_OK)) : (IEL_OK)) : (IEL_OK)) : IEL_OVFL)

#define IEL_DECU(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32--),((x).dw0_32==IEL_MAX32)) : \
                         (sizeof(x) == sizeof(U64)) ? \
                            (((x).dw0_64--),((x).dw0_64==IEL_MAX32) ? \
                             ((x).dw1_64--, ((x).dw1_64==IEL_MAX32)) : IEL_OK):\
                         (sizeof(x) == sizeof(U128)) ? \
                            (((x).dw0_128--),((x).dw0_128==IEL_MAX32) ? \
                            (((x).dw1_128--),((x).dw1_128==IEL_MAX32) ? \
                            (((x).dw2_128--),((x).dw2_128==IEL_MAX32) ? \
                            (((x).dw3_128--),((x).dw3_128==IEL_MAX32)) : \
                             (IEL_OK)) : (IEL_OK)) : (IEL_OK)) : IEL_OVFL)


#define IEL_DECS(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32--),((x).dw0_32==IEL_MAX32) || \
                             (x).dw0_32==0x7fffffff) : \
                         (sizeof(x) == sizeof(U64)) ? \
                            (((x).dw0_64--),((x).dw0_64==IEL_MAX32) ? \
                             ((x).dw1_64--, ((x).dw1_64==IEL_MAX32) || \
                             (x).dw1_64==0x7fffffff) : IEL_OK) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            (((x).dw0_128--),((x).dw0_128==IEL_MAX32) ? \
                            (((x).dw1_128--),((x).dw1_128==IEL_MAX32) ? \
                            (((x).dw2_128--),((x).dw2_128==IEL_MAX32) ? \
                            (((x).dw3_128--),((x).dw3_128==IEL_MAX32) || \
                             (x).dw3_128==0x7fffffff) : \
                             (IEL_OK)) : (IEL_OK)) : (IEL_OK)) : IEL_OVFL)

#define IEL_AND(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) & DW0(z), \
                                 (((DW1(y) & DW1(z)) | (DW2(y) & DW2(z)) |\
                                   (DW3(y) & DW3(z))) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).dw0_64 = DW0(y) & DW0(z), \
                                 ((x).dw1_64 = DW1(y) & DW1(z))), \
                                 ((DW2(y) & DW2(z)) | \
                                  (DW3(y) & DW3(z))) != 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                (((x).dw0_128 = DW0(y) & DW0(z)),  \
                                 ((x).dw1_128 = DW1(y) & DW1(z)),  \
                                 ((x).dw2_128 = DW2(y) & DW2(z)),  \
                                 ((x).dw3_128 = DW3(y) & DW3(z)), \
                                 IEL_OK) : IEL_OVFL) 

#define IEL_OR(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) | DW0(z), \
                                 (((DW1(y) | DW1(z)) | (DW2(y) | DW2(z)) |\
                                   (DW3(y) | DW3(z))) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).dw0_64 = DW0(y) | DW0(z), \
                                 ((x).dw1_64 = DW1(y) | DW1(z))), \
                                 ((DW2(y) | DW2(z)) | \
                                  (DW3(y) | DW3(z))) != 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                (((x).dw0_128 = DW0(y) | DW0(z)),  \
                                 ((x).dw1_128 = DW1(y) | DW1(z)),  \
                                 ((x).dw2_128 = DW2(y) | DW2(z)),  \
                                 ((x).dw3_128 = DW3(y) | DW3(z)),  \
                                 IEL_OK) : IEL_OVFL) 

#define IEL_XOR(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) ^ DW0(z), \
                                 (((DW1(y) ^ DW1(z)) | (DW2(y) ^ DW2(z)) |\
                                   (DW3(y) ^ DW3(z))) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).dw0_64 = DW0(y) ^ DW0(z), \
                                 ((x).dw1_64 = DW1(y) ^ DW1(z))), \
                                 ((DW2(y) ^ DW2(z)) | \
                                  (DW3(y) ^ DW3(z))) != 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                (((x).dw0_128 = DW0(y) ^ DW0(z)),  \
                                 ((x).dw1_128 = DW1(y) ^ DW1(z)),  \
                                 ((x).dw2_128 = DW2(y) ^ DW2(z)),  \
                                 ((x).dw3_128 = DW3(y) ^ DW3(z)),  \
                                 IEL_OK) : IEL_OVFL)

#define IEL_ANDNOT(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) & (~DW0(z)), \
                                 (((DW1(y) & (~DW1(z))) | (DW2(y)&(~DW2(z)))\
                                   | (DW3(y) & (~DW3(z)))) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).dw0_64 = DW0(y) & (~DW0(z)), \
                                 ((x).dw1_64 = DW1(y) & (~DW1(z)))), \
                                 ((DW2(y) & (~DW2(z))) | \
                                  (DW3(y) & (~DW3(z)))) != 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                (((x).dw0_128 = DW0(y) & (~DW0(z))),  \
                                 ((x).dw1_128 = DW1(y) & (~DW1(z))),  \
                                 ((x).dw2_128 = DW2(y) & (~DW2(z))),  \
                                 ((x).dw3_128 = DW3(y) & (~DW3(z))),  \
                                 IEL_OK) : IEL_OVFL) 
 
#define IEL_ASSIGNU(x, y)   ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y), \
                                 ((DW1(y) | DW2(y) | DW3(y)) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).dw0_64 = DW0(y), (x).dw1_64 = DW1(y), \
                                 ((DW2(y) | DW3(y)) != 0)) : \
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).dw0_128 = DW0(y), (x).dw1_128 = DW1(y),\
                                 (x).dw2_128 = DW2(y), (x).dw3_128 = DW3(y),\
                                 IEL_OK) : IEL_OVFL)

#define IEL_ASSIGNS(x, y)   (IEL_ext1.dw0_128 = SDW0(y), \
                             IEL_ext1.dw1_128 = SDW1(y), \
                             IEL_ext1.dw2_128 = SDW2(y), \
                             IEL_ext1.dw3_128 = SDW3(y), \
                             (sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = IEL_ext1.dw0_128, \
                                 ((x).dw0_32 & 0x80000000) ? \
                                 ((~IEL_ext1.dw1_128||~IEL_ext1.dw2_128||\
                                   ~IEL_ext1.dw3_128)) : \
                                 ((IEL_ext1.dw1_128 || IEL_ext1.dw2_128||\
                                   IEL_ext1.dw3_128) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).dw0_64 = IEL_ext1.dw0_128, \
                                 (x).dw1_64 = IEL_ext1.dw1_128, \
                                 ((x).dw1_64 & 0x80000000) ? \
                                 (~IEL_ext1.dw2_128||~IEL_ext1.dw3_128):\
                                 (IEL_ext1.dw2_128|| IEL_ext1.dw3_128)):\
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).dw0_128 = IEL_ext1.dw0_128,\
                                 (x).dw1_128 = IEL_ext1.dw1_128,\
                                 (x).dw2_128 = IEL_ext1.dw2_128,\
                                 (x).dw3_128 = IEL_ext1.dw3_128,\
                                 IEL_OK) : IEL_OVFL)

/* Duplicate IEL_ASSIGNS for macro-->function transform */

#define IEL_REAL_ASSIGNS(x, y)  (IEL_ext1.dw0_128 = SDW0(y), \
                             IEL_ext1.dw1_128 = SDW1(y), \
                             IEL_ext1.dw2_128 = SDW2(y), \
                             IEL_ext1.dw3_128 = SDW3(y), \
                             (sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = IEL_ext1.dw0_128, \
                                 ((x).dw0_32 & 0x80000000) ? \
                                 ((~IEL_ext1.dw1_128||~IEL_ext1.dw2_128||\
                                   ~IEL_ext1.dw3_128)) : \
                                 ((IEL_ext1.dw1_128 || IEL_ext1.dw2_128||\
                                   IEL_ext1.dw3_128) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).dw0_64 = IEL_ext1.dw0_128, \
                                 (x).dw1_64 = IEL_ext1.dw1_128, \
                                 ((x).dw1_64 & 0x80000000) ? \
                                 (~IEL_ext1.dw2_128||~IEL_ext1.dw3_128):\
                                 (IEL_ext1.dw2_128|| IEL_ext1.dw3_128)):\
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).dw0_128 = IEL_ext1.dw0_128,\
                                 (x).dw1_128 = IEL_ext1.dw1_128,\
                                 (x).dw2_128 = IEL_ext1.dw2_128,\
                                 (x).dw3_128 = IEL_ext1.dw3_128,\
                                 IEL_OK) : IEL_OVFL)



#define IEL_NOT(x, y)       ((sizeof(x)==4) ? \
                                ((x).dw0_32 = (~DW0(y)), \
                                 (((~DW1(y))|(~DW2(y)) | (~DW3(y))) != 0)): \
                             (sizeof(x)==8) ? \
                                ((x).dw0_64=(~DW0(y)), (x).dw1_64=(~DW1(y)),\
                                 (((~DW2(y)) | (~DW3(y))) != 0)) : \
                             (sizeof(x)==16) ? \
                                ((x).dw0_128=(~DW0(y)), \
                                 (x).dw1_128=(~DW1(y)), \
                                 (x).dw2_128 = (~DW2(y)), \
                                 (x).dw3_128 = (~DW3(y)), \
                                 IEL_OK) : IEL_OVFL)

#define IEL_ZERO(x)         ((sizeof(x) == sizeof(U32)) ? \
                                ((x).dw0_32 = 0) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).dw0_64 = 0, (x).dw1_64 = 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).dw0_128 = 0, (x).dw1_128 = 0, \
                                 (x).dw2_128 = 0, (x).dw3_128 = 0, IEL_OK) :\
                                IEL_OVFL)


#define IEL_C1_1(x) (IEL_C0(x) ? (DW1_1(x)<=DW1(IEL_ext1)) : \
                               (DW1(x)<DW1(IEL_ext1)))
#define IEL_C2_1(x) (IEL_C1_1(x) ? (DW2_1(x)<=DW2(IEL_ext1)) : \
                               (DW2(x)<DW2(IEL_ext1)))
#define IEL_C3_1(x) (IEL_C2_1(x) ? (DW3_1(x)<=DW3(IEL_ext1)) : \
                               (DW3(x)<DW3(IEL_ext1)))


#define IEL_C0(x) (DW0(x) < DW0(IEL_ext1))
#define IEL_C1(x) (IEL_C0(x) ? (DW1(x)<=DW1(IEL_ext1)) : \
                               (DW1(x)<DW1(IEL_ext1)))
#define IEL_C2(x) (IEL_C1(x) ? (DW2(x)<=DW2(IEL_ext1)) : \
                               (DW2(x)<DW2(IEL_ext1)))
#define IEL_C3(x) (IEL_C2(x) ? (DW3(x)<=DW3(IEL_ext1)) : \
                               (DW3(x)<DW3(IEL_ext1)))


#define IEL_R_C0(x) (DW0(x) < DW0(IEL_ext1))
#define IEL_R_C1(x) (IEL_R_C0(x) ? (DW1(x)<=DW1(IEL_ext1)) : \
                               (DW1(x)<DW1(IEL_ext1)))
#define IEL_R_C2(x) (IEL_R_C1(x) ? ((sizeof(x) == sizeof(U128)) ? \
                                   (DW2_1(x)<=DW2(IEL_ext1)) : 1) : \
                               (DW2(x)<DW2(IEL_ext1)))
#define IEL_R_C3(x) (IEL_R_C2(x) ? ((sizeof(x) == sizeof(U128)) ? \
                                   (DW3_1(x)<=DW3(IEL_ext1)) : 1) : \
                               (DW3(x)<DW3(IEL_ext1)))


#define IEL_ADDU(x, y, z)   ((sizeof(x)==4)?\
                                (IEL_t1=DW0(y),(x).dw0_32=DW0(y)+DW0(z),\
                                 ((IEL_t1>DW0(x))||(DW1(y))||(DW2(y)) ||\
                                (DW3(y))||(DW1(z))||(DW2(z))||(DW3(z)))):\
                             (sizeof(x)==8)?\
                                (IEL_ASSIGNU(IEL_ext1, y),\
                                 (x).dw0_64=DW0(y)+DW0(z),\
                                 (x).dw1_64=DW1(y)+DW1(z)+IEL_C0(x),\
                                 (IEL_C1_1(x)||(DW2(y))||(DW3(y))||\
                                  (DW2(z))||(DW3(z)))):\
                             (sizeof(x)==16)?\
                                (IEL_ASSIGNU(IEL_ext1, y),\
                                 (x).dw0_128=DW0(y)+DW0(z),\
                                 (x).dw1_128=DW1(y)+DW1(z)+IEL_C0(x),\
                                 (x).dw2_128=DW2(y)+DW2(z)+IEL_C1_1(x),\
                                 (x).dw3_128=DW3(y)+DW3(z)+IEL_C2_1(x),\
                                 (IEL_C3_1(x))): IEL_OVFL)


#define IEL_EQU(x, y)       ((DW0(x)==DW0(y)) && (DW1(x)==DW1(y)) && \
                             (DW2(x)==DW2(y)) && (DW3(x)==DW3(y)))
#define IEL_ISZERO(x)       ((DW0(x)==0) && (DW1(x)==0) && (DW2(x)==0) && \
                             (DW3(x)==0))

#define IEL_ISNEG(x)         ((sizeof(x)==4)?\
                                ((DW0(x)&0x80000000)!=0) : \
                             (sizeof(x)==8)?\
                                ((DW1(x) & 0x80000000)!=0) : \
                             (sizeof(x)==16)?\
                                ((DW3(x)&0x80000000)!=0) : IEL_FALSE)

#define IEL_ISNINF(x)        ((sizeof(x) == sizeof(U32)) ? \
                                (DW0(x)==0x80000000) : \
                             (sizeof(x) == sizeof(U64)) ? \
                                (DW1(x)==0x80000000 && DW0(x)==0) : \
                             (sizeof(x) == sizeof(U128)) ? \
                                (DW3(x)==0x80000000 && DW2(x)==0 && \
                                  DW1(x)==0 && DW0(x)==0) : IEL_FALSE)


#define IEL_SEXT(x, y)      (IEL_ASSIGNU(x,y),\
                             ((!IEL_ISNEG(y)) || (sizeof(x)==sizeof(y))) ? \
                             (IEL_OK) : \
                            ((sizeof(x) == sizeof(U64)) ? \
                                ((sizeof(y) == sizeof(U32)) ? \
                                    ((x).dw1_64=IEL_MAX32,IEL_OK):(IEL_OVFL)): \
                            ((sizeof(x) == sizeof(U128)) ? \
                                ((sizeof(y) == sizeof(U32)) ? \
                                    ((x).dw1_128 = IEL_MAX32, \
                                     (x).dw2_128 = IEL_MAX32, \
                                     (x).dw3_128 = IEL_MAX32, IEL_OK) : \
                                (sizeof(y) == sizeof (U64)) ? \
                                    ((x).dw2_128 = IEL_MAX32, \
                                    (x).dw3_128 = IEL_MAX32, IEL_OK):IEL_OVFL):\
                                (IEL_OVFL))))



#define IEL_CMPGU(x, y)     ((sizeof(x) == sizeof(U128)) ? \
                               ((DW3_1(x)>DW3(y)) || \
                               ((DW3(x)==DW3(y)) && (DW2_1(x)>DW2(y))) || \
                               ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1_1(x)>DW1(y))) || \
                               ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1(x)==DW1(y)) && (DW0(x)>DW0(y)))) : \
                             (sizeof(x) == sizeof(U64)) ? \
                               (((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1_1(x)>DW1(y))) || \
                               ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1(x)==DW1(y)) && (DW0(x)>DW0(y)))) : \
                         /*  (sizeof(x) == sizeof(U32)) */ \
                               (((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1(x)==DW1(y)) && (DW0(x)>DW0(y)))))

#define IEL_CMPGEU(x, y)  ((sizeof(x) == sizeof(U128)) ? \
                              ((DW3_1(x)>DW3(y)) || \
                             ((DW3(x)==DW3(y)) && (DW2_1(x)>DW2(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1_1(x)>DW1(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>=DW0(y)))) : \
                           (sizeof(x) == sizeof(U64)) ? \
                              (((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1_1(x)>DW1(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>=DW0(y)))) : \
                        /* (sizeof(x) == sizeof(U32)) */  \
                             (((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>=DW0(y)))))


/*
#define IEL_CMPGU(x, y)     ((DW3(x)>DW3(y)) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)>DW2(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)>DW1(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>DW0(y))))

#define IEL_CMPGEU(x, y)     ((DW3(x)>DW3(y)) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)>DW2(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)>DW1(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>=DW0(y))))

*/

#define IEL_SHL(x, y, n)        (IEL_t2=n, \
                                 ((n) <=0 || (n) >= (sizeof(x)<<3)) ? \
                                 ((IEL_ISZERO(y)||!(n)) ? \
                                        (IEL_ASSIGNU(x, y), IEL_OK) :\
                                        (IEL_ZERO(x), IEL_OVFL)):\
                             ((sizeof(x) == sizeof (U32)) ? \
                                (IEL_t1 = (DW1(y) || DW2(y) || DW3(y) \
                                 || (DW0(y)>= ((U4byte)1<<(32-IEL_t2)))), \
                                 (x).dw0_32 = DW0(y) << IEL_t2, (IEL_t1)) : \
                              (sizeof(x) == sizeof (U64)) ? \
                                ((n) == 32) ? ((IEL_t1 = DW3(y) || DW2(y)\
                                                 || DW1(y)), \
                                    (x).dw1_64 = DW0(y), \
                                    (x).dw0_64 = 0, \
                                    (IEL_t1)) : \
                                ((n) < 32) ? \
                                    (IEL_t1 = (DW2(y) || DW3(y) || \
                                               (DW1(y)>=((U4byte)1<<(32-IEL_t2)))), \
                                     (x).dw1_64 = DW1(y)<<IEL_t2 | \
                                                DW0(y)>>(32-IEL_t2), \
                                     (x).dw0_64 = DW0(y)<<IEL_t2,(IEL_t1)) :\
                                    (IEL_t1 = (DW1(y) || DW2(y) || DW3(y) ||\
                                             ((DW0(y)>=((U4byte)1<<(64-IEL_t2))))),\
                                     (x).dw1_64 = DW0(y)<<(IEL_t2-32), \
                                     (x).dw0_64 = 0, (IEL_t1)) : \
                               (sizeof(x) == sizeof (U128)) ? \
                                ((n)==32) ? (IEL_t1 = (DW3(y)), \
                                          (x).dw3_128 = DW2(y), \
                                          (x).dw2_128 = DW1(y), \
                                          (x).dw1_128 = DW0(y), \
                                          (x).dw0_128 = 0, (IEL_t1!=0)) : \
                                ((n)==64) ? (IEL_t1 = (DW3(y) || DW2(y)),\
                                          (x).dw3_128 = DW1(y), \
                                          (x).dw2_128 = DW0(y), \
                                          (x).dw1_128 = 0, \
                                          (x).dw0_128 = 0, (IEL_t1)) : \
                                ((n)==96) ? (IEL_t1 = (DW3(y) || DW2(y)  \
                                                    || DW1(y)), \
                                          (x).dw3_128 = DW0(y), \
                                          (x).dw2_128 = 0, \
                                          (x).dw1_128 = 0, \
                                          (x).dw0_128 = 0, (IEL_t1)) : \
                                ((n)>96) ? \
                                    (IEL_t1 = (DW1(y) || DW2(y) || DW3(y) ||\
                                       ((DW0(y)>=((U4byte)1<<(128-IEL_t2))))), \
                                     (x).dw3_128 = DW0(y)<<(IEL_t2-96), \
                                     (x).dw2_128 = 0, \
                                     (x).dw1_128 = 0, \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                ((n)>64) ? \
                                    (IEL_t1 = (DW2(y) || DW3(y) || \
                                              ((DW1(y)>=(U4byte)1<<(96-IEL_t2)))),\
                                     (x).dw3_128 = DW1(y)<<(IEL_t2-64) | \
                                                    DW0(y)>>(96-IEL_t2),\
                                     (x).dw2_128 = DW0(y)<<(IEL_t2-64), \
                                     (x).dw1_128 = 0, \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                ((n)>32) ?  \
                                    (IEL_t1 = (DW3(y) || ((IEL_t2!=32) & \
                                                 (DW2(y)>=(U4byte)1<<(64-IEL_t2)))),\
                                     (x).dw3_128 = DW2(y)<<(IEL_t2-32) | \
                                                    DW1(y)>>(64-IEL_t2),\
                                     (x).dw2_128 = DW1(y)<<(IEL_t2-32) | \
                                                    DW0(y)>>(64-IEL_t2),\
                                     (x).dw1_128 = DW0(y)<<(IEL_t2-32), \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                    (IEL_t1 = (DW3(y)>=(U4byte)1<<(32-IEL_t2)), \
                                     (x).dw3_128 = DW3(y)<<(IEL_t2) | \
                                                    DW2(y)>>(32-IEL_t2),\
                                     (x).dw2_128 = DW2(y)<<(IEL_t2) | \
                                                    DW1(y)>>(32-IEL_t2),\
                                     (x).dw1_128 = DW1(y)<<(IEL_t2) | \
                                                    DW0(y)>>(32-IEL_t2),\
                                     (x).dw0_128 = DW0(y)<<IEL_t2, \
                                     (IEL_t1)) : (IEL_OVFL)))

#define IEL_SHL128(x, y, n)     (IEL_t2=(n), \
                               (sizeof(x) == sizeof (U128)) ? \
                                ((n)==32) ? (IEL_t1 = (U4byte)(DW3(y)), \
                                          (x).dw3_128 = (U4byte)DW2(y), \
                                          (x).dw2_128 = (U4byte)DW1(y), \
                                          (x).dw1_128 = (U4byte)DW0(y), \
                                          (x).dw0_128 = 0, (IEL_t1!=0)) : \
                                ((n)==64) ? (IEL_t1 = (U4byte)(DW3(y) || DW2(y)),\
                                          (x).dw3_128 = (U4byte)DW1(y), \
                                          (x).dw2_128 = (U4byte)DW0(y), \
                                          (x).dw1_128 = 0, \
                                          (x).dw0_128 = 0, (IEL_t1)) : \
                                ((n)==96) ? (IEL_t1 = (U4byte)(DW3(y) || DW2(y)  \
                                                    || DW1(y)), \
                                          (x).dw3_128 = (U4byte)DW0(y), \
                                          (x).dw2_128 = 0, \
                                          (x).dw1_128 = 0, \
                                          (x).dw0_128 = 0, (IEL_t1)) : \
                                ((n)>96) ? \
                                    (IEL_t1 = (U4byte)(DW1(y) || DW2(y) || DW3(y) ||\
                                       ((DW0(y)>=((U4byte)1<<(128-IEL_t2))))), \
                                     (x).dw3_128 = (U4byte)DW0(y)<<(IEL_t2-96), \
                                     (x).dw2_128 = 0, \
                                     (x).dw1_128 = 0, \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                ((n)>64) ? \
                                    (IEL_t1 = (U4byte)(DW2(y) || DW3(y) || \
                                              ((DW1(y)>=(U4byte)1<<(96-IEL_t2)))),\
                                     (x).dw3_128 = (U4byte)DW1(y)<<(IEL_t2-64) | \
                                                    DW0(y)>>(96-IEL_t2),\
                                     (x).dw2_128 = (U4byte)DW0(y)<<(IEL_t2-64), \
                                     (x).dw1_128 = 0, \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                ((n)>32) ?  \
                                    (IEL_t1 = (U4byte)(DW3(y) || ((IEL_t2!=32) & \
                                                 (DW2(y)>=(U4byte)1<<(64-IEL_t2)))),\
                                     (x).dw3_128 = (U4byte)DW2(y)<<(IEL_t2-32) | \
                                                    DW1(y)>>(64-IEL_t2),\
                                     (x).dw2_128 = (U4byte)DW1(y)<<(IEL_t2-32) | \
                                                    DW0(y)>>(64-IEL_t2),\
                                     (x).dw1_128 = (U4byte)DW0(y)<<(IEL_t2-32), \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                    (IEL_t1 = (U4byte)(DW3(y)>=(U4byte)1<<(32-IEL_t2)), \
                                     (x).dw3_128 = (U4byte)DW3(y)<<(IEL_t2) | \
                                                    DW2(y)>>(32-IEL_t2),\
                                     (x).dw2_128 = (U4byte)DW2(y)<<(IEL_t2) | \
                                                    DW1(y)>>(32-IEL_t2),\
                                     (x).dw1_128 = (U4byte)DW1(y)<<(IEL_t2) | \
                                                    DW0(y)>>(32-IEL_t2),\
                                     (x).dw0_128 = (U4byte)DW0(y)<<IEL_t2, \
                                     (IEL_t1)) : (IEL_OVFL))


#define IEL_INL(x, n)           (((((U4byte)1<<n)-1) & x))
#define IEL_INH(x, n)       (x>>n)
#define IEL_SHR(x, y, n)    (IEL_t2=n,                              \
                                ((n) <=0) ? \
                                 ((IEL_ISZERO(y)||!(n)) ? \
                                        (IEL_ASSIGNU(x, y), IEL_OK) :\
                                        (IEL_ZERO(x), IEL_OVFL)): \
                               ((sizeof(x) == sizeof (U32)) ? \
                                ((n)==32) ? \
                                          ((x).dw0_32 = DW1(y), \
                                           (DW3(y) || DW2(y))) : \
                                ((n)==64) ?  \
                                          ((x).dw0_32 = DW2(y), \
                                           (DW3(y)!=0)) : \
                                ((n)==96) ? \
                                          ((x).dw0_32 = DW3(y), \
                                           (IEL_OK)) : \
                                ((n)>96) ? \
                                     ((x).dw0_32 = DW3(y)>>(IEL_t2-96), \
                                      (IEL_OK)) : \
                                ((n)>64) ? \
                                     ((x).dw0_32 = ((DW2(y)>>(IEL_t2-64))| \
                                                  (DW3(y)<<(96-IEL_t2))),\
                                      ((DW3(y)>>(IEL_t2-64))!=0)) : \
                                ((n)>32) ?  \
                                     ((x).dw0_32 = ((DW1(y)>>(IEL_t2-32))| \
                                                   (DW2(y)<<(64-IEL_t2))), \
                                      ((DW2(y)>>(IEL_t2-32)) || DW3(y))) :  \
                                    ((x).dw0_32 = DW0(y)>>(IEL_t2) | \
                                                    DW1(y)<<(32-IEL_t2),\
                                     (DW3(y) || DW2(y) ||DW1(y)>>(IEL_t2))) : \
                               (sizeof(x) == sizeof (U64)) ? \
                                ((n)==32) ? \
                                          ((x).dw0_64 = DW1(y), \
                                           (x).dw1_64 = DW2(y), \
                                           (DW3(y)!=0)) : \
                                ((n)==64) ?  \
                                          ((x).dw0_64 = DW2(y), \
                                           (x).dw1_64 = DW3(y), \
                                           (IEL_OK)) : \
                                ((n)==96) ? \
                                          ((x).dw0_64 = DW3(y), \
                                           (x).dw1_64 = 0, \
                                           (IEL_OK)) : \
                                ((n)>96) ? \
                                     ((x).dw0_64 = DW3(y)>>(IEL_t2-96), \
                                      (x).dw1_64 = 0, \
                                      (IEL_OK)) : \
                                ((n)>64) ? \
                                     ((x).dw0_64 = ((DW2(y)>>(IEL_t2-64))| \
                                                  (DW3(y)<<(96-IEL_t2))),\
                                      (x).dw1_64 = DW3(y)>>(IEL_t2-64), \
                                      (IEL_OK)) : \
                                ((n)>32) ?  \
                                     ((x).dw0_64 = ((DW1(y)>>(IEL_t2-32))| \
                                                   (DW2(y)<<(64-IEL_t2))), \
                                      (x).dw1_64 = ((DW2(y)>>(IEL_t2-32))| \
                                                   (DW3(y)<<(64-IEL_t2))),\
                                      (DW3(y)>>(IEL_t2-32) != 0)) :  \
                                    ((x).dw0_64 = DW0(y)>>(IEL_t2) | \
                                                    DW1(y)<<(32-IEL_t2),\
                                     (x).dw1_64 = DW1(y)>>(IEL_t2) | \
                                                    DW2(y)<<(32-IEL_t2),\
                                     (DW3(y) || DW2(y)>>(IEL_t2))) : \
                               (sizeof(x) == sizeof (U128)) ? \
                                ((n)==32) ? \
                                          ((x).dw0_128 = DW1(y), \
                                           (x).dw1_128 = DW2(y), \
                                           (x).dw2_128 = DW3(y), \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)==64) ?  \
                                          ((x).dw0_128 = DW2(y), \
                                           (x).dw1_128 = DW3(y), \
                                           (x).dw2_128 = 0, \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)==96) ? \
                                          ((x).dw0_128 = DW3(y), \
                                           (x).dw1_128 = 0, \
                                           (x).dw2_128 = 0, \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)>96) ? \
                                     ((x).dw0_128 = DW3(y)>>(IEL_t2-96), \
                                      (x).dw1_128 = 0, \
                                      (x).dw2_128 = 0, \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                ((n)>64) ? \
                                     ((x).dw0_128 = ((DW2(y)>>(IEL_t2-64))| \
                                                  (DW3(y)<<(96-IEL_t2))),\
                                      (x).dw1_128 = DW3(y)>>(IEL_t2-64), \
                                      (x).dw2_128 = 0, \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                ((n)>32) ?  \
                                     ((x).dw0_128 = ((DW1(y)>>(IEL_t2-32))| \
                                                   (DW2(y)<<(64-IEL_t2))), \
                                      (x).dw1_128 = ((DW2(y)>>(IEL_t2-32))| \
                                                   (DW3(y)<<(64-IEL_t2))),\
                                      (x).dw2_128 = DW3(y)>>(IEL_t2-32), \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                    ((x).dw0_128 = DW0(y)>>(IEL_t2) | \
                                                    DW1(y)<<(32-IEL_t2),\
                                     (x).dw1_128 = DW1(y)>>(IEL_t2) | \
                                                    DW2(y)<<(32-IEL_t2),\
                                     (x).dw2_128 = DW2(y)>>(IEL_t2) | \
                                                    DW3(y)<<(32-IEL_t2),\
                                     (x).dw3_128 = DW3(y)>>IEL_t2, \
                                     (IEL_OK)) : (IEL_OVFL)))

#define IEL_SHR128(x, y, n) (IEL_t2=n,                              \
                                ((n) <=0) ? \
                                 ((IEL_ISZERO(y)||!(n)) ? \
                                        (IEL_ASSIGNU(x, y), IEL_OK) :\
                                        (IEL_ZERO(x), IEL_OVFL)): \
                               (sizeof(x) == sizeof (U128)) ? \
                                ((n)==32) ? \
                                          ((x).dw0_128 = DW1(y), \
                                           (x).dw1_128 = DW2(y), \
                                           (x).dw2_128 = DW3(y), \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)==64) ?  \
                                          ((x).dw0_128 = DW2(y), \
                                           (x).dw1_128 = DW3(y), \
                                           (x).dw2_128 = 0, \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)==96) ? \
                                          ((x).dw0_128 = DW3(y), \
                                           (x).dw1_128 = 0, \
                                           (x).dw2_128 = 0, \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)>96) ? \
                                     ((x).dw0_128 = DW3(y)>>(IEL_t2-96), \
                                      (x).dw1_128 = 0, \
                                      (x).dw2_128 = 0, \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                ((n)>64) ? \
                                     ((x).dw0_128 = ((DW2(y)>>(IEL_t2-64))| \
                                                  (DW3(y)<<(96-IEL_t2))),\
                                      (x).dw1_128 = DW3(y)>>(IEL_t2-64), \
                                      (x).dw2_128 = 0, \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                ((n)>32) ?  \
                                     ((x).dw0_128 = ((DW1(y)>>(IEL_t2-32))| \
                                                   (DW2(y)<<(64-IEL_t2))), \
                                      (x).dw1_128 = ((DW2(y)>>(IEL_t2-32))| \
                                                   (DW3(y)<<(64-IEL_t2))),\
                                      (x).dw2_128 = DW3(y)>>(IEL_t2-32), \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                    ((x).dw0_128 = DW0(y)>>(IEL_t2) | \
                                                    DW1(y)<<(32-IEL_t2),\
                                     (x).dw1_128 = DW1(y)>>(IEL_t2) | \
                                                    DW2(y)<<(32-IEL_t2),\
                                     (x).dw2_128 = DW2(y)>>(IEL_t2) | \
                                                    DW3(y)<<(32-IEL_t2),\
                                     (x).dw3_128 = DW3(y)>>IEL_t2, \
                                     (IEL_OK)) : (IEL_OVFL))




#ifndef IEL_USE_FUNCTIONS
#define IEL_ADDS(x, y, z)   (IEL_ASSIGNS(IEL_ext4, y), \
                             IEL_ASSIGNS(IEL_ext2, z), \
                             IEL_ADDU (IEL_ext3, IEL_ext4, IEL_ext2), \
                             ((IEL_ISNEG(IEL_ext4) && IEL_ISNEG(IEL_ext2) && \
                               (!(IEL_ISNEG(IEL_ext3)))) | \
                              ((!(IEL_ISNEG(IEL_ext4))) && \
                               (!(IEL_ISNEG(IEL_ext2))) && \
                               IEL_ISNEG(IEL_ext3))  | \
                              (IEL_ASSIGNS(x, IEL_ext3))))
#else

#define IEL_ADDU128(x, y, z) (IEL_ASSIGNU(IEL_ext1, y),\
                                (x).dw0_128=DW0(y)+DW0(z),\
                                 (x).dw1_128=DW1(y)+DW1(z)+IEL_C0(x),\
                                 (x).dw2_128=DW2(y)+DW2(z)+IEL_C1(x),\
                                 (x).dw3_128=DW3(y)+DW3(z)+IEL_C2(x),\
                                 (IEL_C3(x)))
#define IEL_ISNEG128(x)      ((DW3(x)&0x80000000)!=0)

#define IEL_ADDS(x, y, z)   (IEL_ASSIGNS(IEL_ext4, y), \
                             IEL_ASSIGNS(IEL_ext2, z), \
                             IEL_ADDU128 (IEL_ext3, IEL_ext4, IEL_ext2), \
                             ((IEL_ISNEG128(IEL_ext4) && \
                               IEL_ISNEG128(IEL_ext2) && \
                               (!(IEL_ISNEG128(IEL_ext3)))) | \
                              ((!(IEL_ISNEG128(IEL_ext4))) && \
                               (!(IEL_ISNEG128(IEL_ext2))) && \
                               IEL_ISNEG128(IEL_ext3))  | \
                              (IEL_ASSIGNS(x, IEL_ext3))))

#endif 

#endif /*** not LP64 ***/

#define IEL_SEXT64(x)   ((x).dw1_64 = ((x).dw0_64 & 0x80000000) ? -1 : 0)
/* common for lp32 and lp64 */
#define IEL_CONVERT4(x, y0, y1, y2, y3) \
                            ((sizeof(x) == sizeof(U32)) ? \
                                ((x).dw0_32 = y0, y1 || y2 || y3) : \
                             (sizeof(x) == sizeof(U64)) ? \
                                ((x).dw0_64 = y0, \
                                 (x).dw1_64 = y1, \
                                 y2 || y3) :\
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).dw0_128 = y0, \
                                 (x).dw1_128 = y1, \
                                 (x).dw2_128 = y2, \
                                 (x).dw3_128 = y3, \
                                 IEL_OK) : IEL_OVFL)

#define IEL_CONVERT2(x, y0, y1) IEL_CONVERT4(x, y0, y1, 0, 0)
#define IEL_CONVERT1(x, y0)     IEL_CONVERT4(x, y0, 0, 0, 0)
#define IEL_CONVERT IEL_CONVERT4

#define IEL_COMP(x, y) (IEL_NOT(x, y), IEL_INCU(x), IEL_OK)
#define IEL_COMPLEMENTS(x, y) (IEL_ASSIGNS(IEL_ts1, y), \
                              IEL_COMP(IEL_ts1, IEL_ts1), \
                              IEL_ASSIGNS(x, IEL_ts1))

#define IEL_CMPEU(x, y)  IEL_EQU(x, y)
#define IEL_CMPNEU(x, y) (!(IEL_EQU(x, y)))
#define IEL_CMPLU(x, y) IEL_CMPGU(y, x)
#define IEL_CMPLEU(x, y) IEL_CMPGEU(y, x)
#define IEL_CMPU(x, y)  (IEL_CMPGU(x, y)-IEL_CMPLU(x, y))
#define IEL_SUBU(x, y, z) (IEL_ISZERO(z) ? IEL_ASSIGNU(x, y) : \
                           (IEL_COMP(IEL_ext2 ,z), \
                           (!(IEL_ADDU(x, y,IEL_ext2)))))


#define IEL_SUBS(x, y, z)   (IEL_ISZERO(z) ? IEL_ASSIGNS(x, y) : \
                             (IEL_ASSIGNS(IEL_ext5, z), \
                             IEL_COMP(IEL_ext5,IEL_ext5),\
                             IEL_ADDS(x, y, IEL_ext5)||IEL_ISNINF(IEL_ext5)))

#define IEL_CMPES(x, y)     (IEL_ASSIGNS(IEL_ts1, x), \
                             IEL_ASSIGNS(IEL_ts2, y), \
                             IEL_CMPEU(IEL_ts1, IEL_ts2))

#define IEL_CMPNES(x, y)    (!(IEL_CMPES(x, y)))

#define IEL_CMPGS(x, y)     (((IEL_ISNEG(x)) && (!(IEL_ISNEG(y)))) ? (0) : \
                             ((!(IEL_ISNEG(x))) && (IEL_ISNEG(y))) ? (1) : \
                             (IEL_ASSIGNS(IEL_ext3, x), \
                             IEL_ASSIGNS(IEL_ext4, y), \
                             IEL_CMPGU(IEL_ext3, IEL_ext4)))

#define IEL_CMPGES(x, y)    (IEL_CMPGS(x, y) || IEL_CMPES(x, y))
#define IEL_CMPLES(x, y)    IEL_CMPGES(y, x)
#define IEL_CMPLS(x, y)     IEL_CMPGS(y, x)
#define IEL_CMPS(x, y)      (IEL_CMPGS(x, y)-IEL_CMPLS(x, y))
#define IEL_CHECKU(x, n)    (!IEL_SHL128(IEL_ext1, x, 128-(n)))
#define IEL_CHECKS(x, n)    ((IEL_ISNEG(x)) ? \
                                (IEL_ASSIGNS(IEL_ts1, x), \
                                IEL_COMP(IEL_ts1, IEL_ts1), \
                                !((IEL_SHL128(IEL_ts1, IEL_ts1, 128-(n))) || \
                                (IEL_ISNEG(IEL_ts1)&&(!IEL_ISNINF(IEL_ts1))))):\
                                (!(IEL_SHL128(IEL_ts1, x, 128-(n)) || \
                                IEL_ISNEG(IEL_ts1))))

#define IEL_SAR(x, y, n)  (IEL_ISNEG(y) ? \
                           (IEL_SEXT(IEL_ext4, y), (IEL_SHR(x, IEL_ext4, n),  \
                            IEL_SHL(IEL_ext5, IEL_MINUS1, 128-n),  \
                            IEL_OR(IEL_ext5, x, IEL_ext5) , \
                            ((IEL_ASSIGNS(x,IEL_ext5))||(n>=(sizeof(x)<<3))))) \
                            : IEL_SHR(x, y, n))

#define IEL_MULU(x, y, z)   (IEL_ASSIGNU (IEL_ext2, y), \
                             IEL_ASSIGNU (IEL_ext3, z), \
                             (IEL_t4=IEL_mul(&IEL_ext1,&IEL_ext2,&IEL_ext3),\
                              IEL_ASSIGNU (x, IEL_ext1) || IEL_t4))
#define IEL_MULS(x, y, z)    (IEL_ASSIGNS (IEL_ext2, y), \
                             IEL_ASSIGNS (IEL_ext3, z), \
                             IEL_t3 = IEL_ISNEG(y)^IEL_ISNEG(z), \
                             (IEL_ISNEG(IEL_ext2)) ? \
                                IEL_COMP(IEL_ext2, IEL_ext2) : (0),\
                             (IEL_ISNEG(IEL_ext3)) ? \
                                IEL_COMP(IEL_ext3, IEL_ext3) : (0),\
                             IEL_t2 = \
                                (IEL_mul(&IEL_ext1, &IEL_ext2, &IEL_ext3) ||\
                                 (IEL_ISNEG(IEL_ext1) && \
                                  (!IEL_ISNINF(IEL_ext1)))), \
                             IEL_t3 ? IEL_COMP(IEL_ext1,IEL_ext1):(0),\
                             (IEL_ASSIGNS(x,IEL_ext1) || IEL_t2))
#define IEL_DIVU(x, y, z)   (IEL_ISZERO(z) ? (IEL_ASSIGNU(x,IEL_POSINF), \
                                              IEL_OVFL):\
                            (IEL_ASSIGNU (IEL_ext2, y), \
                             IEL_ASSIGNU (IEL_ext3, z), \
                             (IEL_t4=IEL_div(&IEL_ext1,&IEL_ext2,&IEL_ext3),\
                              IEL_ASSIGNU (x, IEL_ext1) || IEL_t4)))
#define IEL_DIVS(x, y, z)   (IEL_ISZERO(z) ? ((IEL_ISNEG(y)) ? \
                            IEL_ASSIGNU(IEL_ext2, IEL_NEGINF): \
                            IEL_ASSIGNU(IEL_ext2, IEL_POSINF)\
                            , IEL_ASSIGNU(x, IEL_ext2), IEL_OVFL) :\
                             (IEL_ASSIGNS (IEL_ext2, y), \
                             IEL_ASSIGNS (IEL_ext3, z), \
                             IEL_t3 = IEL_ISNEG(y)^IEL_ISNEG(z), \
                             (IEL_ISNEG(IEL_ext2)) ? \
                                IEL_COMP(IEL_ext2, IEL_ext2) : (0),\
                             (IEL_ISNEG(IEL_ext3)) ? \
                                IEL_COMP(IEL_ext3, IEL_ext3) : (0),\
                             IEL_t2 = \
                                (IEL_div(&IEL_ext1, &IEL_ext2, &IEL_ext3) ||\
                                 (IEL_ISNEG(IEL_ext1) && (!IEL_t3))), \
                             IEL_t3 ? IEL_COMP(IEL_ext1,IEL_ext1):(0),\
                             (IEL_ASSIGNS(x,IEL_ext1) || IEL_t2)))

#define IEL_REMU(x, y, z)   (IEL_ASSIGNU (IEL_ext2, y), \
                             IEL_ASSIGNU (IEL_ext3, z), \
                             (IEL_t1 = IEL_rem(&IEL_ext1, &IEL_ext2, &IEL_ext3), \
                              IEL_t2 = IEL_ASSIGNU (x, IEL_ext1), IEL_t1||IEL_t2))
#define IEL_REMS(x, y, z)    (IEL_ASSIGNS (IEL_ext2, y), \
                             IEL_ASSIGNS (IEL_ext3, z), \
                             IEL_t3 = IEL_ISNEG(y), \
                             (IEL_ISNEG(IEL_ext2)) ? \
                                IEL_COMP(IEL_ext2, IEL_ext2) : (0),\
                             (IEL_ISNEG(IEL_ext3)) ? \
                                IEL_COMP(IEL_ext3, IEL_ext3) : (0),\
                             IEL_t2 = \
                                (IEL_rem(&IEL_ext1, &IEL_ext2, &IEL_ext3)|| \
                                 IEL_ISNEG(IEL_ext1)), \
                             IEL_t3 ? IEL_COMP(IEL_ext1,IEL_ext1):(0),\
                             (IEL_ASSIGNS(x,IEL_ext1) || IEL_t2))




/**** INT64.H MACROS ****/

#ifdef IEL_INT64

#define INCU64(x)           (IEL_INCU(IEL64(x)), (x))
#define DECU64(x)           (IEL_DECU(IEL64(x)), (x))
#define ADDU64(x, y, t)     (IEL_ADDU(IEL64(x), IEL64(x), IEL64(y)), (x))
#define SUBU64(x, y, t)     (IEL_SUBU(IEL64(x), IEL64(x), IEL64(y)), (x))
#define ANDNOT64(x, y)      (IEL_ANDNOT(IEL64(x), IEL64(x), IEL64(y)),(x))
#define AND64NOT32(x, y)    (IEL_ANDNOT(IEL64(x), IEL64(x), IEL32(y)),(x))
#define ANDU64(x, y)        (IEL_AND(IEL64(x), IEL64(x), IEL64(y)), (x))
#define ORU64(x, y)         (IEL_OR(IEL64(x), IEL64(x), IEL64(y)), (x))
#define NOTU64(x)           (IEL_NOT(IEL64(x), IEL64(x)), (x))
#define ZU64(x)             (IEL_ZERO(IEL64(x)), (x))
#define INIT64(x, y)        (IEL_CONVERT1(x, y), (x))
#define CONST64(x)          IEL_CONST64(x, 0)
#define SCONST64(x)         IEL_CONST64(x, x>>31)
#define CONST64_64(x, y)    IEL_CONST64(y, x)
#define ISZERO64(x)         (IEL_ISZERO(IEL64(x)))
#define EQU64(x, y)         (IEL_EQU(IEL64(x), IEL64(y)))
#define LEU64(x, y)         (IEL_CMPLEU(IEL64(x), IEL64(y)))
#define LU64(x, y)          (IEL_CMPLU(IEL64(x), IEL64(y)))
#define LSU64(x, y)         (IEL_CMPLS(IEL64(x), IEL64(y)))
#define GEU64(x, y)         (IEL_CMPGEU(IEL64(x), IEL64(y)))
#define GU64(x, y)          (IEL_CMPGU(IEL64(x), IEL64(y)))
#define CMP64(x, y, t)      (IEL_CMPU(IEL64(x), IEL64(y)))
#define SHL64(x, y)         (IEL_SHL(IEL64(x), IEL64(x), y), (x))
#define ISNEG(x)            (IEL_ISNEG(IEL64(x)))
#define SEXT64(x)           ((x).dw1_64 = ((x).dw0_64 & 0x80000000) ? -1 : 0)
#define CMP128(x, y, t)     (IEL_CMPU(IEL128(x), IEL128(y)))
#define EQU128(x, y)        (IEL_EQU(IEL128(x), IEL128(y)))
#define LU64TU32(a, b)      (IEL_CMPLU(IEL64(a), IEL32(b)))
#define LU64EU32(a,b)       (IEL_CMPLEU(IEL64(a), IEL32(b)))
#define GU64TU32(a,b)       (IEL_CMPGU(IEL64(a), IEL32(b)))
#define GU64EU32(a,b)       (IEL_CMPGEU(IEL64(a), IEL32(b)))
#define GU64_32(a,b)        (GU64TU32(a, b))
#define INITL64(x, y, z)    (IEL_CONVERT2(x, z, y), (IEL64(x)))
 
#ifdef LP64
#   define ADD2U64(x, y)    ADDU64(x, y, 0)
#   define SUB2U64(x, y)    SUBU64(x, y, 0)
#   define LOWER32(x)   (*(int*)(&x) & 0x00000000ffffffff)
#   define HIGHER32(x)  (*(int*)(&x)>>32)
#else /*** LP64 ***/
#   define ADD2U64(x, y) ((x).low+=(y), (x).high += ((x).low < (y)), (x))
#   define SUB2U64(x, y) ( (x).high -= ((x).low < (y)),(x).low-=(y), (x))
#   define LOWER32(x)           (IEL_GETDW0(IEL64(x)))
#   define HIGHER32(x)          (IEL_GETDW1(IEL64(x)))
#endif /*** LP64 ***/
#endif /*** IEL_INT64 ***/


#ifndef LP64
/* In order to decrease the macro expansion space */

#ifdef IEL_USE_FUNCTIONS 

#ifdef __cplusplus
extern "C" {
#endif

int IEL_au(void *x, void *y, int sx, int sy);
int IEL_c0(void *x, int sx);
int IEL_c1(void *x, int sx);
int IEL_c2(void *x, int sx);
int IEL_c3(void *x, int sx);
IEL_Err IEL_as(void *x, void *y, int sx, int sy);

#ifdef __cplusplus
}
#endif

#undef IEL_ASSIGNU
#undef IEL_ASSIGNS
#undef IEL_C0
#undef IEL_C1
#undef IEL_C2
#undef IEL_C3

#define IEL_ASSIGNU(x, y)   IEL_au((void *)&(x),(void *)&(y),sizeof(x),sizeof(y))
#define IEL_ASSIGNS(x, y)   IEL_as((void *)&(x),(void *)&(y),sizeof(x),sizeof(y))

#define IEL_C0(x) IEL_c0((void *)&(x),sizeof(x))
#define IEL_C1(x) IEL_c1((void *)&(x),sizeof(x))
#define IEL_C2(x) IEL_c2((void *)&(x),sizeof(x))
#define IEL_C3(x) IEL_c3((void *)&(x),sizeof(x))


#endif /* IEL_USE_FUNCTIONS */


#endif /* LP64 */
/* Prototypes */

#ifdef __cplusplus
extern "C" {
#endif

IEL_Err IEL_mul(U128 *xr, U128 *y, U128 *z);
IEL_Err IEL_rem(U128 *x, U128 *y, U128 *z);
IEL_Err IEL_div(U128 *x, U128 *y, U128 *z);
IEL_Err IEL_U128tostr(const U128 *x, char *strptr, int  base, const unsigned int  length);
IEL_Err IEL_U64tostr(const U64 *x, char *strptr, int  base, const unsigned int  length);
IEL_Err IEL_S128tostr(const S128 *x, char *strptr, int  base,const unsigned int  length);
IEL_Err IEL_S64tostr(const S64 *x, char *strptr, int  base,const unsigned int  length);
IEL_Err  IEL_strtoU128( char *str1, char **endptr, int  base, U128 *x);
IEL_Err  IEL_strtoU64(char *str1, char **endptr, int  base, U64 *x);
IEL_Err  IEL_strtoS128(char *str1, char **endptr, int  base, S128 *x);
IEL_Err  IEL_strtoS64(char *str1, char **endptr, int  base, S64 *x);

#ifdef __cplusplus
}
#endif


/* INT64, inside varibales redefinition */

#ifdef IEL_INT64

#undef low
#define low dw0_64
#undef high
#define high dw1_64
#undef b1st
#undef b2st
#undef b3st
#undef b4st
#define b1st dw0_128
#define b2st dw1_128
#define b3st dw3_128
#define b4st dw4_128

#endif

#endif /**** IEL_H ****/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\checkfix.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checkfix.c

Abstract:

    This module recomputes the checksum for an image file.

Author:

    Steven R. Wood (stevewo) 4-May-1993

Revision History:

--*/

#include <private.h>


void Usage()
{
    fprintf( stderr, "usage: CHECKFIX [-?] [-v] [-q] image-names...\n" );
    fprintf( stderr, "              [-?] display this message\n" );
    fprintf( stderr, "              [-v] verbose output\n" );
    fprintf( stderr, "              [-q] quiet on failure\n" );
    exit( 1 );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;
    ULONG CheckSum;
    ULONG FileLength;
    ULONG HeaderSum;
    ULONG OldCheckSum;
    LPSTR ImageName;
    BOOLEAN fVerbose = FALSE;
    BOOLEAN fQuiet = FALSE;
    LPSTR s;
    UCHAR c;

    if (argc <= 1) {
        Usage();
        }

    while (--argc) {
        s = *++argv;
        if ( *s == '-' ) {
            while (c=*++s) {
                switch (c) {
                    case 'q':
                    case 'Q':
                        fQuiet = TRUE;
                        break;

                    case 'v':
                    case 'V':
                        fVerbose=TRUE;
                        break;

                    case 'h':
                    case 'H':
                    case '?':
                        Usage();

                    default:
                        fprintf( stderr, "VERFIX: illegal option /%c\n", c );
                        Usage();
                    }
                }
            }
        else {
            ImageName = s;
            FileHandle = CreateFile( ImageName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL
                                   );
            if (FileHandle == INVALID_HANDLE_VALUE) {
                if (!fQuiet) {
                    fprintf( stderr, "VERFIX: Unable to open %s (%u) - skipping\n", ImageName, GetLastError() );
                    }
                }
            else {
                }

        MappingHandle = CreateFileMapping( FileHandle,
                                           NULL,
                                           PAGE_READWRITE,
                                           0,
                                           0,
                                           NULL
                                         );
        if (MappingHandle == NULL) {
            CloseHandle( FileHandle );
            if (!fQuiet) {
                fprintf( stderr, "VERFIX: Unable to create mapping object for file %s (%u) - skipping\n", ImageName, GetLastError() );
                }
            }
        else {
            BaseAddress = MapViewOfFile( MappingHandle,
                                         FILE_MAP_READ | FILE_MAP_WRITE,
                                         0,
                                         0,
                                         0
                                       );
            CloseHandle( MappingHandle );
            if (BaseAddress == NULL) {
                CloseHandle( FileHandle );
                if (!fQuiet ) {
                    fprintf( stderr, "VERFIX: Unable to map view of file %s (%u) - skipping\n", ImageName, GetLastError() );
                    }
                }
            else {
                //
                // Get the length of the file in bytes and compute the checksum.
                //

                FileLength = GetFileSize( FileHandle, NULL );

                //
                // Obtain a pointer to the header information.
                //

                NtHeaders = ImageNtHeader( BaseAddress );
                if (NtHeaders == NULL) {
                    CloseHandle( FileHandle );
                    UnmapViewOfFile( BaseAddress );
                    if (!fQuiet) {
                        fprintf( stderr, "VERFIX: %s is not a valid image file - skipping\n", ImageName, GetLastError() );
                        }
                    }
                else {
                    //
                    // Recompute and reset the checksum of the modified file.
                    //

                    OldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                    (VOID) CheckSumMappedFile( BaseAddress,
                                               FileLength,
                                               &HeaderSum,
                                               &CheckSum
                                             );

                    NtHeaders->OptionalHeader.CheckSum = CheckSum;

                    if (!FlushViewOfFile( BaseAddress, FileLength )) {
                        if (!fQuiet) {
                            fprintf( stderr,
                                     "VERFIX: Flush of %s failed (%u)\n",
                                     ImageName,
                                     GetLastError()
                                   );
                            }
                        }

                    if (NtHeaders->OptionalHeader.CheckSum != OldCheckSum) {
                        if (!TouchFileTimes( FileHandle, NULL )) {
                            if (!fQuiet) {
                                fprintf( stderr, "VERFIX: Unable to touch file %s (%u)\n", ImageName, GetLastError() );
                                }
                            }
                        else
                        if (fVerbose) {
                            printf( "%s - Old Checksum: %x", ImageName, OldCheckSum );
                            printf( "  New Checksum: %x\n", NtHeaders->OptionalHeader.CheckSum );
                            }
                        }

                    UnmapViewOfFile( BaseAddress );
                    CloseHandle( FileHandle );
                    }
                }
            }
        }
    }

    exit( 0 );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\checksum.h ===
#define CHECKSUM_OPEN_FAILURE       1
#define CHECKSUM_MAP_FAILURE        2
#define CHECKSUM_MAPVIEW_FAILURE    3

ULONG CheckSum(FILE *, PUCHAR, BOOLEAN, PULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\copypdbx.c ===
#define use_CopyPdbX 1

#include <copypdb.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\copystr.cpp ===
#define COPYSTR_MOD
#include <copystr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\dbgexts.c ===
#include "private.h"

#include <ntsdexts.h>


#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

#ifdef IMAGEHLP_HEAP_DEBUG
DECLARE_API( allocs )
{
    PLIST_ENTRY                 Next;
    HEAP_BLOCK                  HeapBlock;
    ULONG                       Address;
    ULONG                       r;
    ULONG                       cb;

    LIST_ENTRY                  LocalHeapHeader;
    ULONG                       LocalTotalAllocs;
    ULONG                       LocalTotalMemory;
    HANDLE                      LocalhHeap;


    INIT_API();

    Address = GetExpression("imagehlp!TotalAllocs");
    r = ReadMemory(Address,
                   &LocalTotalAllocs,
                   sizeof(LocalTotalAllocs),
                   &cb
                   );
    if (!r || cb != sizeof(LocalTotalAllocs)) {
        dprintf("*** TotalAllocs unreadable\n");
        return;
    }

    Address = GetExpression("imagehlp!TotalMemory");
    r = ReadMemory(Address,
                   &LocalTotalMemory,
                   sizeof(LocalTotalMemory),
                   &cb
                   );
    if (!r || cb != sizeof(LocalTotalMemory)) {
        dprintf("*** TotalMemory unreadable\n");
        return;
    }

    Address = GetExpression("imagehlp!hHeap");
    r = ReadMemory(Address,
                   &LocalhHeap,
                   sizeof(LocalhHeap),
                   &cb
                   );
    if (!r || cb != sizeof(LocalhHeap)) {
        dprintf("*** hHeap unreadable\n");
        return;
    }


    Address = GetExpression("imagehlp!HeapHeader");
    r = ReadMemory(Address,
                   &LocalHeapHeader,
                   sizeof(LocalHeapHeader),
                   &cb
                   );
    if (!r || cb != sizeof(LocalHeapHeader)) {
        dprintf("*** HeapHeader unreadable\n");
        return;
    }
    Next = LocalHeapHeader.Flink;
    if (!Next) {
        return;
    }

    dprintf( "-----------------------------------------------------------------------------\n" );
    dprintf( "Memory Allocations for Heap 0x%08x, Allocs=%d, TotalMem=%d\n",
                     LocalhHeap, LocalTotalAllocs, LocalTotalMemory );
    dprintf( "-----------------------------------------------------------------------------\n" );
    dprintf( "*\n" );

    while ((ULONG)Next != Address) {
        r = ReadMemory( CONTAINING_RECORD( Next, HEAP_BLOCK, ListEntry ),
                        &HeapBlock,
                        sizeof(HeapBlock),
                        &cb
                        );
        if (!r || cb != sizeof(HeapBlock)) {
            dprintf("*** list broken\n");
            return;
        }
        Next = HeapBlock.ListEntry.Flink;
        dprintf( "%8d %16s @ %5d\n", HeapBlock.Size, HeapBlock.File, HeapBlock.Line );
    }

    return;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\copypdb.c ===
#if defined (use_CopyPdbX)

#include "private.h"
#include "splitsymx.h"

typedef BOOL ( __cdecl *PPDBCOPYTO ) (
    PDB* ppdb,
    const char* szTargetPdb,
    DWORD dwCopyFilter,
    DWORD dwReserved
    );

typedef BOOL ( __cdecl *PPDBOPEN )(
    LNGNM_CONST char *,
    LNGNM_CONST char *,
    SIG,
    EC *,
    char [cbErrMax],
    PDB **
    );

typedef BOOL ( __cdecl *PPDBCLOSE ) (
    PDB* ppdb
    );


static PPDBCOPYTO pPDBCopyTo = NULL;
static PPDBOPEN   pPDBOpen = NULL;
static PPDBCLOSE  pPDBClose = NULL;

// If you call CopyPdbX with a NB10, or NB* pdb, then
// set szRSDSDllToLoad and it will use the statically
// linked in PDBCopyTo in msdbi60l.lib

BOOL
CopyPdbX(
    CHAR const * szSrcPdb,
    CHAR const * szDestPdb,
    BOOL StripPrivate,
    CHAR const * szRSDSDllToLoad
    )
#else

BOOL
CopyPdb(
    CHAR const * szSrcPdb,
    CHAR const * szDestPdb,
    BOOL StripPrivate
    )

#endif 

{
    LONG ErrorCode;
    ULONG Sig = 0;
    char ErrorString[1024];
    BOOL rc;
    PDB * pSrcPdb;
    HINSTANCE hMsPdb;

    static BOOL RSDSLibLoaded = FALSE;

    // Add a short circut.  PdbCopy fails miserably if the source and destination are the same.
    // If StripPrivate isn't set, check for this case and just return.  If StripPrivate is set,
    // bummer.

    if (!StripPrivate) {
        if (!_stricmp(szSrcPdb, szDestPdb)) {
            rc = TRUE;
        } else {
            rc = CopyFile(szSrcPdb, szDestPdb, FALSE);
        }

    } else {

#if defined ( use_CopyPdbX )

        if ( szRSDSDllToLoad != NULL ) {
            // Load the dll with PDBCopyTo
            HMODULE hDll;

            if ( !RSDSLibLoaded ) {
                hDll = LoadLibrary( szRSDSDllToLoad );
                if (hDll != NULL) {
                    RSDSLibLoaded = TRUE;
                    pPDBCopyTo = ( PPDBCOPYTO ) GetProcAddress( hDll, "PDBCopyTo" );
                    if (pPDBCopyTo == NULL ) {
                        return (FALSE);
                    }
                    pPDBOpen = ( PPDBOPEN ) GetProcAddress( hDll, "PDBOpen" );
                    if (pPDBOpen == NULL ) {
                        return (FALSE);
                    }
                    pPDBClose = ( PPDBCLOSE ) GetProcAddress( hDll, "PDBClose" );
                    if (pPDBClose == NULL ) {
                        return (FALSE);
                    }
                } else {
                    return (FALSE);
                }
            }
            __try
            {
                rc = pPDBOpen((char *)szSrcPdb, "r", Sig, &ErrorCode, ErrorString, &pSrcPdb);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                rc=FALSE;
            }
        } else {
            __try
            {
                rc = PDBOpen((char *)szSrcPdb, "r", Sig, &ErrorCode, ErrorString, &pSrcPdb);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                rc=FALSE;
            }
        }
#else
        __try
        {
            rc = PDBOpen((char *)szSrcPdb, "r", Sig, &ErrorCode, ErrorString, &pSrcPdb);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            rc=FALSE;
        }
#endif
        if (rc) {
            rc = DeleteFile(szDestPdb);
            if (rc || (GetLastError() == ERROR_FILE_NOT_FOUND)) {

#if defined ( use_CopyPdbX )
            if ( szRSDSDllToLoad != NULL ) {
                rc = pPDBCopyTo(pSrcPdb, szDestPdb, StripPrivate ? 0x00000001 : 0x0000000, 0);
            } else {
                rc = PDBCopyTo(pSrcPdb, szDestPdb, StripPrivate ? 0x00000001 : 0x0000000, 0);
            }
#else
                rc = PDBCopyTo(pSrcPdb, szDestPdb, StripPrivate ? 0x00000001 : 0x0000000, 0);
#endif
            }
            if (!rc) {
                // PdbCopyTo doesn't cleanup on failure.  Do it here.
                DeleteFile(szDestPdb);
            }
#if defined ( use_CopyPdbX )
            if ( szRSDSDllToLoad != NULL ) {
                pPDBClose(pSrcPdb);
            } else {
                PDBClose(pSrcPdb);
            }
#else
            PDBClose(pSrcPdb);
#endif
        }
    }
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\dice.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dice.cxx

Abstract:

    This file implements the Image Integrity API's.

Author:

    Bryan Tuttle (bryant) 7-Dec-1995

Environment:

    User Mode

--*/

#include <private.h>

BOOL
FindCertificate(
    IN PLOADED_IMAGE    LoadedImage,
    IN DWORD            Index,
    LPWIN_CERTIFICATE * Certificate
    )
{
    PIMAGE_DATA_DIRECTORY pDataDir;
    DWORD_PTR CurrentCert;
    BOOL rc;

    if (LoadedImage->fDOSImage) {
        // No way this could have a certificate;
        return(FALSE);
    }

    rc = FALSE;

    __try {
        if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;     // Not an interesting file type.
        }

        // Check if the cert pointer is reasonable.
        if (!pDataDir->VirtualAddress ||
            !pDataDir->Size ||
            (pDataDir->VirtualAddress + pDataDir->Size > LoadedImage->SizeOfImage) ||
            (pDataDir->VirtualAddress + pDataDir->Size < pDataDir->VirtualAddress))
        {
            __leave;
        }

        // The data should not be part of any in-memory data.

        {
            DWORD_PTR CertStart = pDataDir->VirtualAddress;
            DWORD_PTR CertEnd = CertStart + pDataDir->Size;
            ULONG i;
            for (i = 0; i < LoadedImage->NumberOfSections; i++) {
                DWORD_PTR SectionStart = LoadedImage->Sections[i].PointerToRawData;
                DWORD_PTR SectionEnd = SectionStart + LoadedImage->Sections[i].SizeOfRawData;

                if (SectionStart && (CertStart < SectionEnd || CertEnd < SectionEnd)) {
                    __leave;    // The cert preceeds this section's data must be bogus
                }
            }
        }

        // We're not looking at an empty security slot or an invalid (past the image boundary) value.
        // Let's see if we can find it.

        DWORD CurrentIdx = 0;
        DWORD_PTR LastCert;

        CurrentCert = (DWORD_PTR)(LoadedImage->MappedAddress) + pDataDir->VirtualAddress;
        LastCert = CurrentCert + pDataDir->Size;

        while (CurrentCert < LastCert ) {
            if (CurrentIdx == Index) {
                rc = TRUE;
                __leave;
            }
            CurrentIdx++;
            CurrentCert += ((LPWIN_CERTIFICATE)CurrentCert)->dwLength;
            CurrentCert = (CurrentCert + 7) & ~7;   // align it.
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (rc == TRUE) {
        *Certificate = (LPWIN_CERTIFICATE)CurrentCert;
    }

    return(rc);
}

typedef struct _EXCLUDE_RANGE {
    PBYTE Offset;
    DWORD Size;
    struct _EXCLUDE_RANGE *Next;
} EXCLUDE_RANGE;

typedef enum {
    Raw,
    Virtual
} ADDRTYPE;

class EXCLUDE_LIST
{
    public:
        EXCLUDE_LIST() {
            m_Image = NULL;
            m_ExRange = (EXCLUDE_RANGE *)MemAlloc(sizeof(EXCLUDE_RANGE));
        }

        ~EXCLUDE_LIST() {
            EXCLUDE_RANGE *pTmp;
            pTmp = m_ExRange->Next;
            while (pTmp) {
                MemFree(m_ExRange);
                m_ExRange = pTmp;
                pTmp = m_ExRange->Next;
            }
            MemFree(m_ExRange);
        }

        void Init(LOADED_IMAGE * Image, DIGEST_FUNCTION pFunc, DIGEST_HANDLE dh) {
            m_Image = Image;
            m_ExRange->Offset = NULL;
            m_ExRange->Size = 0;
            m_pFunc = pFunc;
            m_dh = dh;
            return;
        }

        void Add(DWORD_PTR Offset, DWORD Size, ADDRTYPE AddrType);

        BOOL Emit(PBYTE Offset, DWORD Size);

    private:
        LOADED_IMAGE  * m_Image;
        EXCLUDE_RANGE * m_ExRange;
        DIGEST_FUNCTION m_pFunc;
        DIGEST_HANDLE m_dh;
};

void
EXCLUDE_LIST::Add(
    DWORD_PTR Offset,
    DWORD Size,
    ADDRTYPE AddrType
    )
{
    if (AddrType == Virtual) {
        // Always save raw offsets
        DWORD_PTR RawOffset;

        // Note: it's O.K. to cast down to a dword here.  Offset is really a Rva from the start
        // of the image (always limited to 4G).

        RawOffset = (DWORD_PTR)ImageRvaToVa((PIMAGE_NT_HEADERS)m_Image->FileHeader, m_Image->MappedAddress, (DWORD)Offset, NULL);
        Offset = RawOffset;
    }

    EXCLUDE_RANGE *pTmp, *pExRange;

    pExRange = m_ExRange;

    while (pExRange->Next && (pExRange->Next->Offset < (PBYTE)Offset)) {
        pExRange = pExRange->Next;
    }

    pTmp = (EXCLUDE_RANGE *) MemAlloc(sizeof(EXCLUDE_RANGE));
    pTmp->Next = pExRange->Next;
    pTmp->Offset = (PBYTE)Offset;
    pTmp->Size = Size;
    pExRange->Next = pTmp;

    return;
}


BOOL
EXCLUDE_LIST::Emit(
    PBYTE Offset,
    DWORD Size
    )
{
    BOOL rc;

    EXCLUDE_RANGE *pExRange;
    DWORD EmitSize, ExcludeSize;

    pExRange = m_ExRange->Next;
    rc = TRUE;

    while (pExRange && (Size > 0)) {
        if (pExRange->Offset >= Offset) {
            // Emit what's before the exclude list.
            EmitSize = __min((DWORD)(pExRange->Offset - Offset), Size);
            if (EmitSize) {
                rc = (*m_pFunc)(m_dh, Offset, EmitSize);
                if (rc == FALSE) {
                    return rc;
                }
                Size -= EmitSize;
                Offset += EmitSize;
            }
        }

        if (Size) {
            if (pExRange->Offset + pExRange->Size >= Offset) {
                // Skip over what's in the exclude list.
                ExcludeSize = __min(Size, (DWORD)(pExRange->Offset + pExRange->Size - Offset));
                Size -= ExcludeSize;
                Offset += ExcludeSize;
            }
        }

        pExRange = pExRange->Next;
    }

    // Emit what's left.
    if (Size) {
        rc = (*m_pFunc)(m_dh, Offset, Size);
    }
    return rc;
}


BOOL
IMAGEAPI
ImageGetDigestStream(
    IN HANDLE           FileHandle,
    IN DWORD            DigestLevel,
    IN DIGEST_FUNCTION  DigestFunction,
    IN DIGEST_HANDLE    DigestHandle
    )

/*++

Routine Description:

    Given an image, return the bytes necessary to construct a certificate.
    Only PE images are supported at this time.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_READ access.

    DigestLevel -   Indicates what data will be included in the returned buffer.
                    Valid values are:

                        CERT_PE_IMAGE_DIGEST_DEBUG_INFO - Include Debug symbolic (if mapped)
                        CERT_PE_IMAGE_DIGEST_RESOURCES  - Include Resource info
                        CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO - Include ALL the import information

                    By default, neither Debug Symbolic, Resources, nor import information affected
                    by binding are returned.

    DigestFunction - User supplied routine that will process the data.

    DigestHandle -  User supplied handle to identify the digest.  Passed as the first
                    argument to the DigestFunction.

Return Value:

    TRUE         - Success.

    FALSE        - There was some error.  Call GetLastError for more information.  Possible
                   values are ERROR_INVALID_PARAMETER or ERROR_OPERATION_ABORTED.

--*/

{
    LOADED_IMAGE    LoadedImage;
    BOOL            rc, fAddThisSection, fDebugAdded;
    DWORD           i;
    EXCLUDE_LIST    ExList;
    PIMAGE_SECTION_HEADER SectionHeaders;
    ULONG ResourceOffset, ResourceSize, DebugOffset, DebugSize, RelocOffset, RelocSize, SectionHeaderSize;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_DATA_DIRECTORY pDataDir;
    INT RelocHdr;
    union {
        IMAGE_NT_HEADERS32 PE32;
        IMAGE_NT_HEADERS64 PE64;
    }Hdr;
    BOOL f32;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;

    __try {

        if (LoadedImage.fDOSImage) {
            __leave;
        }

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            f32 = TRUE;
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            f32 = FALSE;
        } else {
            __leave;
        }

        ExList.Init(&LoadedImage, DigestFunction, DigestHandle);

        // Return all the interesting stuff from the image.  First, the common stuff.

        // 1. Add the DOS stub (if it exists).

        if ((ULONG_PTR)LoadedImage.FileHeader - (ULONG_PTR) LoadedImage.MappedAddress) {
            if (!ExList.Emit((PBYTE) LoadedImage.MappedAddress,
                             (DWORD)((ULONG_PTR) LoadedImage.FileHeader - (ULONG_PTR) LoadedImage.MappedAddress)))
            {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        }

        // Add the headers, but not the checksum and not the security Data directory entry.

        if (f32) {
            Hdr.PE32 = *((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader);
            pDataDir = &Hdr.PE32.OptionalHeader.DataDirectory[0];
            Hdr.PE32.OptionalHeader.CheckSum = 0;
        } else {
            Hdr.PE64 = *((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader);
            pDataDir = &Hdr.PE64.OptionalHeader.DataDirectory[0];
            Hdr.PE64.OptionalHeader.CheckSum = 0;
        }

        pDataDir[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
        pDataDir[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;

        SectionHeaderSize = sizeof(IMAGE_SECTION_HEADER) * LoadedImage.NumberOfSections;
        SectionHeaders = (PIMAGE_SECTION_HEADER) MemAlloc(SectionHeaderSize);
        if (SectionHeaders == NULL)
        {
            rc = ERROR_OPERATION_ABORTED;
            __leave;
        }
        ResourceOffset = pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
        ResourceSize = pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
        RelocOffset = pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
        RelocSize = pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

        fDebugAdded = TRUE;
        DebugOffset = 0xFFFFFFFF;
        RelocHdr = -1;

        for (i = 0; i < LoadedImage.NumberOfSections; i++) {
            SectionHeaders[i] = LoadedImage.Sections[i];

            // Keep track of the reloc section header.  We may need to adjust it later.

            if (RelocSize &&
                ((LoadedImage.Sections[i].VirtualAddress <= RelocOffset) &&
                 (LoadedImage.Sections[i].VirtualAddress +
                    LoadedImage.Sections[i].Misc.VirtualSize >= RelocOffset + RelocSize))
                )
            {
                RelocHdr = i;
            }

            // If resources aren't in the digest, we need to clear the resource section header

            if (ResourceSize && !(DigestLevel & CERT_PE_IMAGE_DIGEST_RESOURCES)) {

                if (((LoadedImage.Sections[i].VirtualAddress <= ResourceOffset) &&
                     (LoadedImage.Sections[i].VirtualAddress +
                        LoadedImage.Sections[i].Misc.VirtualSize >= ResourceOffset + ResourceSize))
                    )
                {
                    // Found the resource section header.  Zero it out.
                    SectionHeaders[i].Misc.VirtualSize = 0;
                    SectionHeaders[i].VirtualAddress = 0;
                    SectionHeaders[i].SizeOfRawData = 0;
                    SectionHeaders[i].PointerToRawData = 0;
                }
            }

            if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_DEBUG_INFO)) {
                // Same with mapped debug info.
                if (!strncmp((char *)LoadedImage.Sections[i].Name, ".debug", sizeof(".debug"))) {

                    DebugOffset = SectionHeaders[i].VirtualAddress;
                    DebugSize = SectionHeaders[i].SizeOfRawData;
                    ExList.Add(SectionHeaders[i].PointerToRawData + (DWORD_PTR) LoadedImage.MappedAddress, DebugSize, Raw);

                    SectionHeaders[i].Misc.VirtualSize = 0;
                    SectionHeaders[i].VirtualAddress = 0;
                    SectionHeaders[i].SizeOfRawData = 0;
                    SectionHeaders[i].PointerToRawData = 0;
                    fDebugAdded = FALSE;
                }
            }
        }

        // The first pass on the section headers is finished.  See it we need to adjust the
        // reloc dir or the image headers.

        if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_RESOURCES)) {
            // If the resources aren't in the digest, don't add the base reloc address or the
            // resource address/size to the digest.  This allows subsequent tools to add/subtract
            // resource info w/o effecting the digest.

            if ((ResourceOffset < RelocOffset) && (RelocHdr != -1))
            {
                pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
                SectionHeaders[RelocHdr].PointerToRawData = 0;
                SectionHeaders[RelocHdr].VirtualAddress = 0;
            }
            pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = 0;
            pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = 0;
            if (f32) {
                Hdr.PE32.OptionalHeader.SizeOfImage = 0;
                Hdr.PE32.OptionalHeader.SizeOfInitializedData = 0;
            } else {
                Hdr.PE64.OptionalHeader.SizeOfImage = 0;
                Hdr.PE64.OptionalHeader.SizeOfInitializedData = 0;
            }
            ExList.Add(ResourceOffset, ResourceSize, Virtual);
        }

        if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_DEBUG_INFO) &&
            (fDebugAdded == FALSE))
        {
            // Debug wasn't added to the image and IS mapped in.  Allow these to grow also.
            if (f32) {
                Hdr.PE32.OptionalHeader.SizeOfImage = 0;
                Hdr.PE32.OptionalHeader.SizeOfInitializedData = 0;
            } else {
                Hdr.PE64.OptionalHeader.SizeOfImage = 0;
                Hdr.PE64.OptionalHeader.SizeOfInitializedData = 0;
            }
            if ((DebugOffset < RelocOffset) && (RelocHdr != -1))
            {
                pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
                SectionHeaders[RelocHdr].PointerToRawData = 0;
                SectionHeaders[RelocHdr].VirtualAddress = 0;
            }
        }

        // Looks good.  Send the headers to the digest function.

        if (f32) {
            if (!ExList.Emit((PBYTE) &Hdr.PE32, sizeof(Hdr.PE32))) {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        } else {
            if (!ExList.Emit((PBYTE) &Hdr.PE64, sizeof(Hdr.PE64))) {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        }

        // Then the section headers.

        if (!ExList.Emit((PBYTE) SectionHeaders, SectionHeaderSize)) {
            rc = ERROR_OPERATION_ABORTED;
            __leave;
        }

        MemFree(SectionHeaders);

        // The headers are done.  Now let's see what we need to do with the import information.

        if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO)) {
            // The user didn't explicitly ask for all import info.
            // Add the info modified by bind to the exclude list.

            PIMAGE_IMPORT_DESCRIPTOR ImportDesc;
            DWORD ImportDescSize, IATSize;
            PVOID IAT;

            ImportDesc = (PIMAGE_IMPORT_DESCRIPTOR) ImageDirectoryEntryToData(
                                LoadedImage.MappedAddress,
                                FALSE,
                                IMAGE_DIRECTORY_ENTRY_IMPORT,
                                &ImportDescSize);
            if (ImportDescSize) {

                IAT = ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                                FALSE,
                                                IMAGE_DIRECTORY_ENTRY_IAT,
                                                &IATSize);

                if (IAT) {
                    // Easy case.  All the IATs are grouped together.
                    ExList.Add((DWORD_PTR) IAT, IATSize, Raw);

                    // Add the TimeDateStamp and ForwarderChain fields in the Import Descriptors

                    while (ImportDesc->Characteristics) {
                        ExList.Add((DWORD_PTR) &ImportDesc->TimeDateStamp, 8, Raw);
                        ImportDesc++;
                    }

                } else {
                    // Not so easy.  Need to walk each Import descriptor to find the bounds of the IAT
                    //  (note, there's no requirement that all the IAT's for all descriptors be contiguous).


                    while (ImportDesc->Characteristics) {
                        PIMAGE_THUNK_DATA ThunkStart;
                        ExList.Add((DWORD_PTR)&ImportDesc->TimeDateStamp, 8, Raw);
                        ThunkStart = (PIMAGE_THUNK_DATA) ImageRvaToVa((PIMAGE_NT_HEADERS)LoadedImage.FileHeader,
                                                                      LoadedImage.MappedAddress,
                                                                      (ULONG) ImportDesc->OriginalFirstThunk,
                                                                      NULL);
                        if (f32) {
                            PIMAGE_THUNK_DATA32 Thunk = (PIMAGE_THUNK_DATA32)ThunkStart;
                            while (Thunk->u1.AddressOfData) {
                                Thunk++;
                            }
                            ExList.Add( (DWORD)ImportDesc->FirstThunk,
                                        (DWORD)((DWORD_PTR)Thunk - (DWORD_PTR) ThunkStart + sizeof(IMAGE_THUNK_DATA32)), Virtual);
                        } else {
                            PIMAGE_THUNK_DATA64 Thunk = (PIMAGE_THUNK_DATA64)ThunkStart;
                            while (Thunk->u1.AddressOfData) {
                                Thunk++;
                            }
                            ExList.Add( (DWORD)ImportDesc->FirstThunk,
                                        (DWORD)((DWORD_PTR)Thunk - (DWORD_PTR) ThunkStart + sizeof(IMAGE_THUNK_DATA64)), Virtual);
                        }
                        ImportDesc++;
                    }
                }
            }
        }

        // Add each section header followed by the data from that section.

        for (i = 0; i < LoadedImage.NumberOfSections; i++) {
            if (!ExList.Emit((PBYTE) (LoadedImage.MappedAddress + LoadedImage.Sections[i].PointerToRawData),
                             LoadedImage.Sections[i].SizeOfRawData))
            {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        }
        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}



BOOL
IMAGEAPI
ImageAddCertificate(
    IN HANDLE               FileHandle,
    IN LPWIN_CERTIFICATE    Certificate,
    OUT PDWORD              Index
    )

/*++

Routine Description:
    Add a certificate to the image.  There is no checking to ensure there are no
    duplicate types.

Arguments:

    FileHandle      -   Handle to the file in question.  The file should be opened
                        with at least GENERIC_WRITE access.

    Certificate     -   Pointer to a WIN_CERTIFICATE structure.

    Index           -   After adding the Certificate to the image, this is the index
                        you can use for later references to that certificate.

Return Value:

    TRUE    - Success
    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE        LoadedImage;
    DWORD               rc;
    LPWIN_CERTIFICATE   pCert;
    DWORD               OnDiskCertLength;
    DWORD_PTR           NewCertLocation;
    DWORD               OriginalImageSize;
    PIMAGE_DATA_DIRECTORY  pDataDir;
    BOOL                f32, fSkipUnMap;

    if (MapIt(FileHandle, &LoadedImage, MAP_READWRITE) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;
    fSkipUnMap = FALSE;

    __try {

        if (LoadedImage.fDOSImage) {
            __leave;
        }

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            f32 = TRUE;
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            f32 = FALSE;
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;
        }

        pCert = (LPWIN_CERTIFICATE) Certificate;

        // Test the output parameter and the the cert.

        *Index = (DWORD) -1;
        OnDiskCertLength = pCert->dwLength;
        OnDiskCertLength = (OnDiskCertLength + 7) & ~7;        // Round the size of cert.

        // Grow the image.

        OriginalImageSize = LoadedImage.SizeOfImage;
        OriginalImageSize = (OriginalImageSize + 7) & ~7;      // Round the size of Image.

        // Check if the cert pointer is at least reasonable.
        if (pDataDir->VirtualAddress &&
            (pDataDir->VirtualAddress + pDataDir->Size) > LoadedImage.SizeOfImage)
        {
            __leave;
        }

        // Looks good now.

        *Index = 0;
        if (pDataDir->VirtualAddress == 0) {
            pDataDir->VirtualAddress = OriginalImageSize;
            pDataDir->Size = 0;
            NewCertLocation = OriginalImageSize;
        } else {
            LPWIN_CERTIFICATE CurrentCert;

            NewCertLocation = pDataDir->VirtualAddress + pDataDir->Size + (DWORD_PTR) LoadedImage.MappedAddress;
            CurrentCert = (LPWIN_CERTIFICATE) (LoadedImage.MappedAddress + pDataDir->VirtualAddress);
            while (((DWORD_PTR)CurrentCert) < NewCertLocation) {
                if (CurrentCert->dwLength == 0) {
                    __leave;
                }
                CurrentCert = (LPWIN_CERTIFICATE)(((DWORD_PTR)CurrentCert + CurrentCert->dwLength + 7) & ~7);
                (*Index)++;
            }
            NewCertLocation -= (DWORD_PTR) LoadedImage.MappedAddress;
        }

        if (!GrowMap (&LoadedImage, OnDiskCertLength + (OriginalImageSize - LoadedImage.SizeOfImage))) {
            fSkipUnMap = TRUE;
            __leave;
        }

        if (NewCertLocation < OriginalImageSize) {
            // There's data after the current security data.  Move it down.
            memmove(LoadedImage.MappedAddress + NewCertLocation + pCert->dwLength,
                    LoadedImage.MappedAddress + NewCertLocation,
                    (unsigned) (OriginalImageSize - NewCertLocation));
        }

        memmove(LoadedImage.MappedAddress + NewCertLocation,
                pCert,
                pCert->dwLength);

        // GrowMap may have moved the dirs.
        if (f32) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        }

        pDataDir->Size += OnDiskCertLength;
        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (!fSkipUnMap)
        UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}


BOOL
IMAGEAPI
ImageRemoveCertificate(
    IN HANDLE       FileHandle,
    IN DWORD        Index
    )

/*++

Routine Description:

    Remove a certificate from an image.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_WRITE access.

    Index       -   The index to remove from the image.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE    LoadedImage;
    LPWIN_CERTIFICATE CurrentCert;
    DWORD           rc;
    DWORD           OldCertLength;

    if (MapIt(FileHandle, &LoadedImage, MAP_READWRITE) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;

    __try {

        if (FindCertificate(&LoadedImage, Index, &CurrentCert) == FALSE) {
            __leave;
        }

        OldCertLength = CurrentCert->dwLength;
        OldCertLength = (OldCertLength + 7) & ~7;           // The disk size is actually a multiple of 8

        memmove(CurrentCert,
                ((PCHAR)CurrentCert) + OldCertLength,
                (size_t)(LoadedImage.SizeOfImage - (((DWORD_PTR)CurrentCert) - (DWORD_PTR)LoadedImage.MappedAddress) - OldCertLength));

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            ((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size -= OldCertLength;
            if (!((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size) {
                // Last one removed.  Clear the pointer
                ((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
            }
        } else {
            ((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size -= OldCertLength;
            if (!((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size) {
                // Last one removed.  Clear the pointer
                ((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
            }
        }

        LoadedImage.SizeOfImage -= OldCertLength;

        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}


BOOL
IMAGEAPI
ImageEnumerateCertificates(
    IN  HANDLE      FileHandle,
    IN  WORD        TypeFilter,
    OUT PDWORD      CertificateCount,
    IN OUT PDWORD   Indices OPTIONAL,
    IN  DWORD       IndexCount  OPTIONAL
    )

/*++

Routine Description:

    Enumerate the certificates in an image.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    TypeFilter          -   The filter to apply when enumertating the certificates.
                            Valid values are:

                                CERT_SECTION_TYPE_ANY - Enumerate all certificate types
                                                        in the image.

    CertificateCount    -   How many certificates are in the image.

    Indices             -   An array of indexes that match the filter type.

    IndexCount          -   The number of indexes in the indices array.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    BOOL    rc;
    PIMAGE_DATA_DIRECTORY pDataDir;
    LPWIN_CERTIFICATE CurrentCert, LastCert;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;
    __try {
        if (LoadedImage.fDOSImage) {
            __leave;
        }

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;
        }

        if ((pDataDir->VirtualAddress + pDataDir->Size) > LoadedImage.SizeOfImage) {
            *CertificateCount = 0;
            __leave;
        }

        if (!pDataDir->VirtualAddress || !pDataDir->Size) {
            *CertificateCount = 0;
        } else {

            DWORD MatchedIndex = 0;
            DWORD ActualIndex = 0;

            CurrentCert = (LPWIN_CERTIFICATE)((DWORD_PTR)LoadedImage.MappedAddress + pDataDir->VirtualAddress);
            LastCert = (LPWIN_CERTIFICATE)((DWORD_PTR)CurrentCert + pDataDir->Size);

            while (CurrentCert < LastCert ) {
                if ((TypeFilter == CERT_SECTION_TYPE_ANY) || (TypeFilter == CurrentCert->wCertificateType)) {
                    if (Indices && (MatchedIndex < IndexCount)) {
                        Indices[MatchedIndex] = ActualIndex;
                    }
                    MatchedIndex++;
                }

                ActualIndex++;
                CurrentCert = (LPWIN_CERTIFICATE)((((DWORD_PTR)CurrentCert + CurrentCert->dwLength) +7) & ~7);
            }

            *CertificateCount = MatchedIndex;
        }

        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}


BOOL
IMAGEAPI
ImageGetCertificateData(
    IN  HANDLE              FileHandle,
    IN  DWORD               CertificateIndex,
    OUT LPWIN_CERTIFICATE   Certificate,
    IN OUT PDWORD           RequiredLength
    )

/*++

Routine Description:

    Given a specific certificate index, retrieve the certificate data.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    CertificateIndex    -   Index to retrieve

    Certificate         -   Output buffer where the certificate is to be stored.

    RequiredLength      -   Size of the certificate buffer (input).  On return, is
                            set to the actual certificate length.  NULL can be used
                            to determine the size of a certificate.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    DWORD   ErrorCode;

    LPWIN_CERTIFICATE ImageCert;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ErrorCode = ERROR_INVALID_PARAMETER;
    __try {
        if (FindCertificate(&LoadedImage, CertificateIndex, &ImageCert) == FALSE) {
            __leave;
        }

        if (*RequiredLength < ImageCert->dwLength) {
            *RequiredLength = ImageCert->dwLength;
            ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        } else {
            memcpy(Certificate, (PUCHAR)ImageCert, ImageCert->dwLength);
            ErrorCode = ERROR_SUCCESS;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(ErrorCode);
    return(ErrorCode == ERROR_SUCCESS ? TRUE: FALSE);
}


BOOL
IMAGEAPI
ImageGetCertificateHeader(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    IN OUT  LPWIN_CERTIFICATE   CertificateHeader
    )

/*++

Routine Description:

    Given a specific certificate index, retrieve the certificate data.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    CertificateIndex    -   Index to retrieve.

    CertificateHeader   -   Pointer to a WIN_CERTIFICATE to fill in.

Return Value:

    TRUE    - Success

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    LPWIN_CERTIFICATE ImageCert;
    BOOL    rc;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (FindCertificate(&LoadedImage, CertificateIndex, &ImageCert) == FALSE) {
        rc = FALSE;
        goto Exit;
    }

    __try {
        memcpy(CertificateHeader, ImageCert, sizeof(WIN_CERTIFICATE));
        rc = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        rc = FALSE;
    }
Exit:

    UnMapIt(&LoadedImage);

    if (rc == FALSE) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\dia.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dia.c

Abstract:

    These routines call VC's new DIA symbol handler.

Author:

    Pat Styles (patst) 26-May-2000

Environment:

    User Mode

--*/
#define DIA_LIBRARY 1

#include "private.h"
#include "symbols.h"
#include "globals.h"
#include "dia2.h"
#include "diacreate_int.h"
#include "pdb.h"
#include <atlbase.h>

typedef struct {
    CComPtr<IDiaDataSource>    source;
    CComPtr<IDiaSession>       session;
    CComPtr<IDiaSymbol>        scope;
    CComPtr<IDiaSourceFile>    srcfile;
    CComPtr<IDiaEnumFrameData> framedata;
#ifdef BBTFIX
    CComPtr<IDiaAddressMap> addrmap;
#endif
} DIA, *PDIA;

extern HRESULT STDMETHODCALLTYPE DiaCoCreate(
                        REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);

extern HRESULT STDMETHODCALLTYPE NoOleCoCreate(REFCLSID   rclsid,
                                               REFIID     riid,
                                               void     **ppv);

#define freeString LocalFree

// used by diaLocatePdb

enum {
    ipNone = 0,
    ipFirst,
    ipLast
};


BOOL diaInit()
{
#ifdef COMDIA
    HRESULT hr;

    if (!g.fCoInit)
        hr = CoInitialize(NULL);
    if (hr != S_OK)
        return false;

    g.fCoInit = true;
#endif
    return true;
}


void diaCleanup()
{
#ifdef COMDIA
    HRESULT hr;
          
    if (!g.cProcessList && g.fCoInit)
        CoUninitialize();
    g.fCoInit = false;
#endif
}


__inline
HRESULT
SetDiaError(
    HRESULT ccode,
    HRESULT ncode
    )
{
    if (ncode == EC_OK)
        return ncode;

    if (ccode != (HRESULT)EC_NOT_FOUND)
        return ccode;

    return ncode;
}


__inline
BOOL
ValidSig(
    DWORD sig,
    GUID *guid
    )
{
    if (ValidGuid(guid))
        return true;

    if (sig)
        return true;

    return false;
}


typedef struct _DIAERROR {
    HRESULT  hr;
    char    *text;
} DIAERROR, *PDIAERROR;


char *
diaErrorText(
    HRESULT hr
    )
{
    #define ERROR_MAX 24

    static const DIAERROR error[ERROR_MAX] =
    {
        {E_PDB_OK, "OK"},
        {E_PDB_USAGE, "invalid parameters"},
        {E_PDB_OUT_OF_MEMORY, "out of memory"},
        {E_PDB_FILE_SYSTEM, "drive not ready"},
        {E_PDB_NOT_FOUND,   "file not found"},
        {E_PDB_INVALID_SIG, "mismatched pdb"},
        {E_PDB_INVALID_AGE, "mismatched pdb"},
        {E_PDB_PRECOMP_REQUIRED, "E_PDB_PRECOMP_REQUIRED"},
        {E_PDB_OUT_OF_TI, "E_PDB_OUT_OF_TI"},
        {E_PDB_NOT_IMPLEMENTED, "E_PDB_NOT_IMPLEMENTED"},
        {E_PDB_V1_PDB, "E_PDB_V1_PDB"},
        {E_PDB_FORMAT, "file system or network error reading pdb"},
        {E_PDB_LIMIT, "E_PDB_LIMIT"},
        {E_PDB_CORRUPT, "E_PDB_CORRUPT"},
        {E_PDB_TI16, "E_PDB_TI16"},
        {E_PDB_ACCESS_DENIED, "E_PDB_ACCESS_DENIED"},
        {E_PDB_ILLEGAL_TYPE_EDIT, "E_PDB_ILLEGAL_TYPE_EDIT"},
        {E_PDB_INVALID_EXECUTABLE, "invalid executable image"},
        {E_PDB_DBG_NOT_FOUND, "dbg file not found"},
        {E_PDB_NO_DEBUG_INFO, "pdb is stripped of cv info"},
        {E_PDB_INVALID_EXE_TIMESTAMP, "image has invalid timestamp"},
        {E_PDB_RESERVED, "E_PDB_RESERVED"},
        {E_PDB_DEBUG_INFO_NOT_IN_PDB, "pdb has no symbols"},
        {E_PDB_MAX, "pdb error 0x%x"}
    };

    static char sz[50];

    DWORD i;

    for (i = 0; i < ERROR_MAX; i++) {
        if (hr == error[i].hr)
            return error[i].text;
    }

    PrintString(sz, DIMA(sz), "dia error 0x%x", hr);
    return sz;
}


void
FreeDiaVariant(
    VARIANT *var
    )
{
    if (!var || !var->bstrVal)
        return;

#ifdef COMDIA
    SysFreeString(var->bstrVal);
#else
    LocalFree(var->bstrVal);
#endif
    var->vt = VT_EMPTY;
}

extern DWORD DIA_VERSION;

DWORD
diaVersion(
    VOID
    )
{
    return DIA_VERSION;
}


BOOL
diaGetPdbInfo(
    PIMGHLP_DEBUG_DATA idd
    )
{
    PDIA    pdia;
    HRESULT hr;
    DWORD   celt;
    int     i;
    enum SymTagEnum   symtag[2] = {SymTagData, SymTagFunction};
    enum SymTagEnum   typetag[2] = {SymTagTypedef, SymTagUDT};

    assert(idd);

    // get interface

    pdia = (PDIA)idd->dia;
    if (!pdia)
        return false;

    CComPtr<IDiaSymbol> idiaGlobals;

    hr = pdia->session->get_globalScope(&idiaGlobals);
    if (hr != S_OK) 
        return false;

    // get the pdb age and sig

    hr = idiaGlobals->get_guid(&idd->pdbdataGuid);
    if (hr != S_OK)
        return false;
    if (GuidIsDword(&idd->pdbdataGuid)) {
        idd->pdbdataSig = idd->pdbdataGuid.Data1;
        idd->pdbdataGuid.Data1 = 0;
    }
    hr = idiaGlobals->get_age(&idd->pdbdataAge);
    if (hr != S_OK)
        return false;
    
    // any line numbers?

    CComPtr<IDiaEnumSourceFiles> idiaSrcFiles;
    CComPtr<IDiaSourceFile> idiaSrcFile;

    hr = pdia->session->findFile(NULL, NULL, 0, &idiaSrcFiles);
    if (hr == S_OK) {
        hr = idiaSrcFiles->Next(1, &idiaSrcFile, &celt);
        if (hr == S_OK && celt > 0)
            idd->fLines = true;
    }

    // any symbols ?

    CComPtr<IDiaSymbol>        idiaSymbol;
    CComPtr< IDiaEnumSymbols > idiaSymbols;
    
    for (i = 0; i < 2; i++) {
        hr = idiaGlobals->findChildren(symtag[i], NULL, 0, &idiaSymbols);
        if (hr == S_OK) {
            hr = idiaSymbols->Next(1, &idiaSymbol, &celt);
            if (hr == S_OK && celt > 0) {
                idd->fSymbols = true;
                break;
            }
        }
        idiaSymbols = NULL;
        idiaSymbol = NULL;
    }

    // any type info?

    idiaSymbols = NULL;
    idiaSymbol = NULL;

    for (i = 0; i < 2; i++) {
        hr = idiaGlobals->findChildren(typetag[i], NULL, 0, &idiaSymbols);
        if (hr == S_OK) {
            hr = idiaSymbols->Next(1, &idiaSymbol, &celt);
            if (hr == S_OK && celt > 0) {
                idd->fTypes = true;
                break;
            }
        }
        idiaSymbols = NULL;
        idiaSymbol = NULL;
    }

    return true;
}


HRESULT
diaOpenPdb(
    PIMGHLP_DEBUG_DATA idd,
    PSTR  szPDB,
    GUID *PdbGUID,
    DWORD PdbSignature,
    DWORD PdbAge,
    BOOL  MatchAnything
    )
{
    HRESULT hr;
    EC      hrcode = E_PDB_NOT_FOUND;
    PDIA    pdia;
    WCHAR   wszPDB[_MAX_PATH + 1];

    pdia = (PDIA)idd->dia;
    if (!pdia)
        return EC_NO_DEBUG_INFO;

    ansi2wcs(szPDB, wszPDB, DIMA(wszPDB));
    if (!ValidSig(PdbSignature, PdbGUID))
        hr = pdia->source->loadDataFromPdb(wszPDB);
    else
       hr = pdia->source->loadAndValidateDataFromPdb(wszPDB,
                                                     ValidGuid(PdbGUID) ? PdbGUID : NULL,
                                                     PdbSignature,
                                                     PdbAge);
    hrcode = SetDiaError(hrcode, hr);
    if (hr == S_OK) {
        if (!PdbSignature && !ValidGuid(PdbGUID))
            idd->fPdbUnmatched = true;
    } else {
        pprint(idd->pe, "%s - %s\n", szPDB, diaErrorText(hr));
        if (hr == E_PDB_INVALID_SIG || hr == E_PDB_INVALID_AGE) {
            if (!ValidSig(PdbSignature, PdbGUID)) {
                hr = pdia->source->loadDataFromPdb(wszPDB);
            } else if (!*idd->FoundPdb) 
                CopyStrArray(idd->FoundPdb, szPDB);
        } else if (hr == E_PDB_NOT_FOUND) {
            if (!(g.LastSymLoadError & SYMLOAD_PDBERRORMASK)) {
                g.LastSymLoadError = SYMLOAD_PDBNOTFOUND;
            }
        } else {
            g.LastSymLoadError = (hr << 8) & SYMLOAD_PDBERRORMASK;
        }
    }

    return hr;
}


HRESULT
CheckDirForPdbs(
    PIMGHLP_DEBUG_DATA idd,
    PSTR  path,
    GUID *PdbGUID,
    DWORD PdbSignature,
    DWORD PdbAge
    )
{
    WIN32_FIND_DATA fd;
    HANDLE hf;
    HRESULT hr;
    char drive[_MAX_DRIVE + 1];
    char dir[_MAX_DIR + 1];
    char fname[_MAX_FNAME + 1];
    char sfname[_MAX_FNAME + 1];
    char ext[_MAX_EXT + 1];
    char spath[MAX_PATH + 1];

    if (!*path)
        return E_PDB_NOT_FOUND;

    _splitpath(path, drive, dir, fname, ext);
    ShortNodeName(fname, sfname, DIMA(sfname));

    // now search the tree

    PrintString(spath, DIMA(spath), "%s%s%s%s\\*", drive, dir, sfname, ext);
  
    ZeroMemory(&fd, sizeof(fd));
    hf = FindFirstFile(spath, &fd);
    if (hf == INVALID_HANDLE_VALUE)
        return E_PDB_NOT_FOUND;

    do {
        if (!strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, ".."))
            continue;
        PrintString(spath, DIMA(spath), "%s%s%s%s\\%s", drive, dir, sfname, ext, fd.cFileName);
        if (isdir(spath)) {
            EnsureTrailingBackslash(spath);
            CatStrArray(spath, sfname);
            CatStrArray(spath, ext);
        } else if (!IsPdb(spath))
            continue;
        hr = diaOpenPdb(idd, spath, PdbGUID, PdbSignature, PdbAge, false);
        if (hr == S_OK) {
            CopyString(path, spath, MAX_PATH + 1);
            return hr;
        }
    } while (FindNextFile(hf, &fd));

    // If there is no match, but a file exists in the symbol subdir with 
    // a matching name, make sure that is what will be picked.

    PrintString(spath, DIMA(spath), "%s%s%s%s\\%s%s", drive, dir, sfname, ext, sfname, ext);
    if (fileexists(spath))
        CopyStrArray(idd->FoundPdb, spath);
    
    return E_PDB_NOT_FOUND;
}


HRESULT
diaLocatePdb(
    PIMGHLP_DEBUG_DATA idd,
    PSTR  szPDB,
    GUID *PdbGUID,
    DWORD PdbSignature,
    DWORD PdbAge,
    char *szImageExt
    )
{
    DWORD pass;
    EC    hrcode = E_PDB_NOT_FOUND;
    GUID  guid;
    HRESULT hr = E_PDB_NOT_FOUND;

    char  pdb[MAX_PATH + 1];
    char  drive[6];
    char  path[MAX_PATH + 1];
    char  module[MAX_PATH + 1];
    char  modbuf[MAX_PATH + 1];
    char  name[MAX_PATH + 1];
    char  ext[_MAX_EXT + 1];
    char *next;
    DWORD attrib;
    DWORD err;
    BOOL  ssrv = true;

#ifdef DEBUG
    if (traceSubName(szPDB)) // for setting debug breakpoints from DBGHELP_TOKEN
        dtrace("diaLocatePdb(%s)\n", szPDB);
#endif

    if (!PdbSignature
        && !IsPdb(idd->ImageFilePath)
        && !ValidGuid(PdbGUID)
        && option(SYMOPT_EXACT_SYMBOLS))
    {
        g.LastSymLoadError = SYMLOAD_PDBUNMATCHED;
        return E_PDB_INVALID_SIG;
    }

    if (!idd->dia)
        return EC_NO_DEBUG_INFO;

    // If the image file name is a pdb, then just try to open it.
    // Don't attempt any searching.

    if (IsPdb(idd->ImageFilePath)) {
        CopyStrArray(pdb, idd->ImageFilePath);
        hr = diaOpenPdb(idd, pdb, PdbGUID, PdbSignature, PdbAge, false);
        if (hr == S_OK) {
            idd->PdbSrc = srcImagePath;
            goto done;
        }
        return E_PDB_NOT_FOUND;
    }

    // Set up indexes for symbol server

    ZeroMemory(&guid, sizeof(GUID));
    if (PdbSignature)
        guid.Data1 = PdbSignature;
    else if (PdbGUID)
        memcpy(&guid, PdbGUID, sizeof(GUID));

    // get name of pdb

    _splitpath(szPDB, NULL, NULL, module, ext);
    PrintString(name, DIMA(name), "%s%s", module, ".pdb");

    // SymbolPath is a semicolon delimited path (reference path first)

    next = TokenFromSymbolPath(idd->SymbolPath, path, MAX_PATH + 1);
    while (*path) {

        for (pass = 0; pass < 3; pass++) {
            
            if (symsrvPath(path)) {
                if (pass || !ssrv)
                    break;
                *pdb = 0;
                idd->PdbSrc = srcSymSrv;
                err = symsrvGetFile(idd->pe,
                                    path,
                                    name,
                                    &guid,
                                    PdbAge,
                                    0,
                                    pdb);
                if (err == ERROR_NO_DATA)
                    ssrv = false;
            
            } else {
                if (pass && !*szImageExt)
                    break;
                idd->PdbSrc = srcSearchPath;
                if (!CreateSymbolPath(pass, path, szImageExt, module, ext, pdb, DIMA(pdb))) {
                    hr = E_PDB_NOT_FOUND;
                    goto done;
                }
                if (!pass) {
                    hr = CheckDirForPdbs(idd, pdb, PdbGUID, PdbSignature, PdbAge);
                    if (hr == S_OK)
                        goto done;
                }
            }

            if (*pdb) {
                hr = diaOpenPdb(idd, pdb, PdbGUID, PdbSignature, PdbAge, false);
                hrcode = SetDiaError(hrcode, hr);
                if (hr == S_OK) 
                    goto done;
            }
        }

        next = TokenFromSymbolPath(next, path, MAX_PATH + 1);
    }

    // try the same path as the image

    if (idd->ImageFileHandle && *idd->ImageFilePath) {
        _splitpath(idd->ImageFilePath, drive, path, NULL, NULL);
        PrintString(pdb, DIMA(pdb), "%s%s%s", drive, path, name);
        hr = diaOpenPdb(idd, pdb, PdbGUID, PdbSignature, PdbAge, false);
        if (hr == S_OK)
            idd->PdbSrc = srcImagePath;
    }

    // try the CV Record

    if (hr != S_OK && strcmp(pdb, szPDB) && !option(SYMOPT_IGNORE_CVREC)) {
        CopyStrArray(pdb, szPDB);
        hr = diaOpenPdb(idd, pdb, PdbGUID, PdbSignature, PdbAge, false);
        if (hr == S_OK)
            idd->PdbSrc = srcCVRec;
    }

    // try mismatches

    if (hr != S_OK && *idd->FoundPdb) {
        if (option(SYMOPT_LOAD_ANYTHING)) {
            CopyStrArray(pdb, idd->FoundPdb);
            hr = diaOpenPdb(idd, pdb, NULL, 0, 0, true);
            if (hr == S_OK)
                idd->PdbSrc = srcSearchPath;
        } 
        idd->LoadInfo &= DSLFLAG_MISMATCHED_PDB;
        pprint(idd->pe, "%s mismatched pdb for %s\n",
               hr == S_OK ? "Loaded" : "Couldn't load",
              *idd->ImageFilePath ? idd->ImageFilePath : name);
    }

done:

    if (hr == S_OK) {
        // Store the name of the PDB we actually opened for later reference.
        strcpy(szPDB, pdb);    // SECURITY: Don't know size of target buffer.
        SetLastError(NO_ERROR);
        g.LastSymLoadError = SYMLOAD_OK;
    }

    return hr;
}


BOOL
diaReadStream(
    PMODULE_ENTRY mi,
    char  *stream,
    PBYTE *buf,
    DWORD *size
    )
{
    PDIA    pdia;
    PDB    *pdb;
    HRESULT hr;
    BOOL    rc;
    LONG    cb;
    Stream *pstream;
    LONG    count = 0;

    assert (mi && stream && *stream && buf && size);
    *size = 0;
    *buf = 0;

    pdia = (PDIA)mi->dia;
    if (!pdia)
        return false;

    hr = GetRawPdbPtrForDataSource(pdia->source, &pdb);
    if (hr != S_OK)
        return false;

    rc = PDBOpenStream(pdb, stream, &pstream);
    if (!rc)
        return false;

    *size = StreamQueryCb(pstream);
    if (!*size)
        return false;

    *buf = (PBYTE)MemAlloc(*size + 1);
    if (!*buf)
        return false;

    cb = *size;
    rc = StreamRead(pstream, 0, *buf, &cb);
    if (!rc)
        goto error;
    if (cb != *size)
        goto error;

    return true;

error:
    MemFree(*buf);
    *buf = 0;

    return 0;
}


DWORD
diaReadDebugStream(
    PVOID   dia,
    char  *stream,
    PBYTE *buf,
    DWORD *size
    )
{
    DWORD   celt;
    LONG    count;
    DWORD   cb;
    HRESULT hr;
    VARIANT var;
    PDIA    pdia;
    WCHAR   wstream[1000];

    CComPtr< IDiaEnumDebugStreams > idiaStreams;
    CComPtr< IDiaEnumDebugStreamData > idiaStream;

    assert (dia && stream && *stream && buf);

    pdia = (PDIA)dia;
    hr = pdia->session->getEnumDebugStreams(&idiaStreams);
    if (hr != S_OK)
        return 0;

    if (!ansi2wcs(stream, wstream, 1000))
        return 0;

    var.vt = VT_BSTR;
    var.bstrVal = wstream;
    hr = idiaStreams->Item(var, &idiaStream);
    if (hr != S_OK)
        return 0;

    hr = idiaStream->get_Count(&count);
    if (hr != S_OK)
        return 0;
    if (count < 1)
        return 0;

    hr = idiaStream->Next(count, 0, &cb, NULL, &celt);
    if (hr != S_OK)
        return 0;
    if (cb < 1)
        return 0;

    *buf = (PBYTE)MemAlloc(cb);
    if (!*buf)
        return 0;

    hr = idiaStream->Next(count, cb, &cb, *buf, &celt);
    if (hr != S_OK) {
        MemFree(*buf);
        *buf = NULL;
        return 0;
    }

    *size = cb;

    return count;
}


BOOL
diaGetOmaps(
    PIMGHLP_DEBUG_DATA idd
    )
{
    DWORD   celt;
    LONG    count;
    DWORD   cb;
    PBYTE   tbuf = NULL;
    PBYTE   fbuf = NULL;
    HRESULT hr;
    VARIANT var;

    count = diaReadDebugStream(idd->dia, "OMAPTO", &tbuf, &cb);
    if (count < 1)
        return false;

    idd->cOmapTo = count;
    idd->pOmapTo = (POMAP)tbuf;
    idd->fOmapToMapped = false;

    count = diaReadDebugStream(idd->dia, "OMAPFROM", &fbuf, &cb);
    if (count < 1)
        return false;

    idd->cOmapFrom = count;
    idd->pOmapFrom = (POMAP)fbuf;
    idd->fOmapFromMapped = false;

    return true;
}


BOOL
diaGetFPOTable(
    PIMGHLP_DEBUG_DATA idd
    )
{
    LONG    count;
    PBYTE   buf;
    DWORD   cb;

    count = diaReadDebugStream(idd->dia, "FPO", &buf, &cb);
    if (count < 1)
        return false;

    idd->cFpo = count;
    idd->pFpo = buf;

    return true;
}


BOOL
diaGetPData(
    PMODULE_ENTRY mi
    )
{
    LONG    count;
    PBYTE   buf;
    DWORD   cb;

    count = diaReadDebugStream(mi->dia, "PDATA", &buf, &cb);
    if (count < 1)
        return false;

    mi->dsExceptions = dsDia;
    mi->cPData  = count;
    mi->cbPData = cb;
    mi->pPData  = buf;

    return true;
}


BOOL
diaGetXData(
    PMODULE_ENTRY mi
    )
{
    DWORD   celt;
    LONG    count;
    DWORD   cb;
    PBYTE   buf;
    HRESULT hr;
    PDIA    pdia;
    VARIANT var;

    CComPtr< IDiaEnumDebugStreams > idiaStreams;
    CComPtr< IDiaEnumDebugStreamData > idiaStream;

    assert (mi && mi->dia);

    pdia = (PDIA)mi->dia;
    if (!pdia)
        return false;

    hr = pdia->session->getEnumDebugStreams(&idiaStreams);
    if (hr != S_OK)
        return false;

    var.vt = VT_BSTR;
    var.bstrVal = L"XDATA";
    hr = idiaStreams->Item(var, &idiaStream);
    if (hr != S_OK)
        return false;

    hr = idiaStream->get_Count(&count);
    if (hr != S_OK)
        return false;
    if (count < 1)
        return true;

    hr = idiaStream->Next(count, 0, &cb, NULL, &celt);
    if (hr != S_OK)
        return false;
    if (cb < 1)
        return true;

    CComQIPtr< IDiaImageData, &IID_IDiaImageData > idiaXDataHdr(idiaStream);
    if (!idiaXDataHdr.p)
        return false;

    DWORD relativeVirtualAddress;
    if (FAILED(hr = idiaXDataHdr->get_relativeVirtualAddress(&relativeVirtualAddress)))
        return false;

    buf = (PBYTE)MemAlloc(cb + sizeof(DWORD));
    if (!buf)
        return false;

    memcpy(buf, &relativeVirtualAddress, sizeof(relativeVirtualAddress));

    hr = idiaStream->Next(count, cb, &cb, buf + sizeof(DWORD), &celt);
    if (hr != S_OK) {
        MemFree(buf);
        return false;
    }

    mi->dsExceptions = dsDia;
    mi->cXData  = count;
    mi->cbXData = cb;
    mi->pXData  = buf;

    return true;
}


void
diaRelease(
    PVOID dia
    )
{
    PDIA pdia = (PDIA)dia;
    if (pdia)
        delete pdia;
}


#if 1
LONG
diaCountGlobals(
    PMODULE_ENTRY  mi
    )
{
    PDIA    pdia;
    HRESULT hr;
    LONG    count;
    LONG    rc = 0;

    CComPtr< IDiaSymbol >      idiaGlobals;
    CComPtr< IDiaEnumSymbols > idiaSymbols;

    if (mi->cGlobals != -1)
        return mi->cGlobals;

    pdia = (PDIA)mi->dia;
    if (!pdia)
        return mi->cGlobals;

    hr = pdia->session->get_globalScope(&idiaGlobals);
    if (hr != S_OK)
        goto exit;

    // see if there are any globals at all

    hr = idiaGlobals->findChildren(SymTagData, NULL, 0, &idiaSymbols);
    if (hr != S_OK)
        goto exit;
    hr = idiaSymbols->get_Count(&count);
    if (hr != S_OK)
        goto exit;
    rc = count;

    idiaSymbols = NULL;
    hr = idiaGlobals->findChildren(SymTagFunction, NULL, 0, &idiaSymbols);
    if (hr != S_OK)
        goto exit;
    hr = idiaSymbols->get_Count(&count);
    if (hr != S_OK)
        goto exit;
    rc += count;

exit:
    mi->cGlobals = rc;

    return rc;
}
#endif


BOOL
diaGetPdb(
    PIMGHLP_DEBUG_DATA idd
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   cpathlen = 0;
    DWORD   len;
    CHAR    szExt[_MAX_EXT + 1] = {0};

    if (idd->dia) {
        pprint(idd->pe, "redundant pdb call!\n");
        return true;
    }

    if (*idd->ImageFilePath) {
        _splitpath(idd->ImageFilePath, NULL, NULL, NULL, szExt);
    } else if (*idd->ImageName) {
        _splitpath(idd->ImageName, NULL, NULL, NULL, szExt);
    }

    // if we have no valid filename, then this must be an executable

    if (!*szExt)
        CopyStrArray(szExt, ".exe");

    // get interface to dia

    pdia = new DIA;
    if (!pdia) {
        hr = E_PDB_OUT_OF_MEMORY;
        goto error;
    }
    idd->dia = pdia;

    pdia->source = NULL;
#ifdef COMDIA
    hr = CoCreateInstance(CLSID_DiaSourceAlt, NULL, CLSCTX_INPROC_SERVER, IID_IDiaDataSource, (void **)&pdia->source);
#else
    hr = DiaCoCreate(CLSID_DiaSourceAlt, IID_IDiaDataSource, (void **)&pdia->source);
#endif    
    if (hr != S_OK)
        goto error;

    // go ahead and get pdb

    SetCriticalErrorMode();

    hr = diaLocatePdb(idd,
                      idd->PdbFileName,
                      &idd->PdbGUID,
                      idd->PdbSignature,
                      idd->PdbAge,
                      &szExt[1]);

    ResetCriticalErrorMode();

    if (hr != S_OK) {
        hr = S_OK;  // error was already handled by diaLocatePdb()
        goto error;
    }

    // open the session on the pdb

    pdia->session = NULL;
    hr = pdia->source->openSession(&pdia->session);
    if (hr != S_OK)
        goto error;

    // Set the module load address so we can use VAs.
    hr = pdia->session->put_loadAddress(idd->InProcImageBase);
    if (hr != S_OK)
        goto error;

    // fixup the address map so that we can translate rva to full addresses

    hr = pdia->session->QueryInterface(IID_IDiaAddressMap, (void**)&pdia->addrmap);
    if (hr != S_OK)
        goto error;

    if (idd->pCurrentSections) {
        hr = pdia->addrmap->set_imageHeaders(idd->cCurrentSections * sizeof(IMAGE_SECTION_HEADER),
                                             (BYTE *)idd->pCurrentSections,
                                             false);
        if (hr != S_OK)
            goto error;
    }

    // this hack is to fix a problem with v7 pdbs not storing the original image alignment

    if (idd->ImageAlign) {
        hr = pdia->addrmap->put_imageAlign(idd->ImageAlign);
        if (hr != S_OK)
            goto error;
    }

    // pass in the omap information and setup the proper image alignment to the original

    if (idd->cOmapFrom && idd->pOmapFrom) {
        hr = pdia->addrmap->put_imageAlign(idd->ImageAlign);
        if (hr != S_OK)
            goto error;
        hr = pdia->addrmap->set_addressMap(idd->cOmapTo, (DiaAddressMapEntry *)idd->pOmapTo, true);
        if (hr != S_OK)
            goto error;
        hr = pdia->addrmap->set_addressMap(idd->cOmapFrom, (DiaAddressMapEntry *)idd->pOmapFrom, false);
        if (hr != S_OK)
            goto error;
        hr = pdia->addrmap->put_addressMapEnabled(true);
        if (hr != S_OK)
            goto error;
    }

    hr = pdia->addrmap->put_relativeVirtualAddressEnabled(true);
    if (hr != S_OK)
        goto error;

    diaGetFPOTable(idd);
    diaGetOmaps(idd);
    diaGetPdbInfo(idd);

    return true;

error:
    if (hr != S_OK)
        pprint(idd->pe, "%s %s\n", idd->PdbFileName, diaErrorText(hr));

    diaRelease(pdia);
    idd->dia = NULL;

    return false;
}


DWORD64
GetAddressFromRva(
    PMODULE_ENTRY mi,
    DWORD         rva
    )
{
    DWORD64 addr;

    assert(mi);
    addr = rva ? mi->BaseOfDll + rva : 0;
    return addr;
}

DWORD64
GetLineAddressFromRva(
    PMODULE_ENTRY mi,
    DWORD         rva
    )
{
    DWORD64 addr;

    assert(mi);
    addr = rva ? mi->BaseOfDll + rva : 0;

    // Line symbol information names the IA64 bundle
    // syllables with 0,1,2 whereas the debugger expects
    // 0,4,8.  Convert.
    if (mi->MachineType == IMAGE_FILE_MACHINE_IA64 && (addr & 3)) {
        addr = (addr & ~3) | ((addr & 3) << 2);
    }

    return addr;
}


BOOL
diaFillSymbolInfo(
    PSYMBOL_INFO   si,
    PMODULE_ENTRY  mi,
    IDiaSymbol    *idiaSymbol
    )
{
    HRESULT  hr;
    BSTR     wname=NULL;
    char     name[MAX_SYM_NAME + 1];
    char    *p;
    DWORD    dw;
    ULONG64  size;
    ULONG64  va;
    BOOL     rc;
    VARIANT  value;

    CComPtr< IDiaEnumSymbols > idiaValues;
    CComPtr<IDiaSymbol>        idiaValue;

    if (!idiaSymbol)
        return false;

    rc = true;

    dw = si->MaxNameLen;
    ZeroMemory(si, sizeof(SYMBOL_INFO));
    si->MaxNameLen = dw;

    // si->SizeOfStruct = IGNORED;

    // si->TypeIndex = NYI;

    // si->Reserved = IGNORED;

    si->ModBase = mi->BaseOfDll;

    hr = idiaSymbol->get_symTag(&si->Tag);
    if (hr != S_OK)
        return false;

    switch (si->Tag)
    {
    case SymTagData:
        hr = idiaSymbol->get_locationType(&dw);
        if (hr != S_OK)
            return false;
        switch(dw)
        {
        case LocIsTLS:
            // TLS variables have an offset into the TLS data area.
            si->Flags = SYMFLAG_TLSREL;
            hr = idiaSymbol->get_addressOffset(&dw);
            if (hr != S_OK)
                return false;
            si->Address = (ULONG64) (LONG64) (LONG) dw;
            break;

        case LocIsStatic:
            hr = idiaSymbol->get_relativeVirtualAddress(&dw);
            si->Address = GetAddressFromRva(mi, dw);
            if (!si->Address)
                rc = false;
            break;

        case LocIsEnregistered:
            hr = idiaSymbol->get_registerId(&si->Register);
            si->Flags = SYMFLAG_REGISTER;
            break;

        case LocIsRegRel:
            si->Flags = SYMFLAG_REGREL;
            hr = idiaSymbol->get_registerId(&si->Register);
            if (hr != S_OK)
                return false;
            hr = idiaSymbol->get_offset((PLONG)&dw);
            si->Address = (ULONG64) (LONG64) (LONG) dw;
            break;

        case LocIsThisRel:
        // struct members - get_Offset
        default:
            si->Flags |= 0;
            break;
        }
        break;

    case SymTagThunk:
        hr = idiaSymbol->get_targetRelativeVirtualAddress(&dw);
        if (hr == S_OK) {
            si->Value = GetAddressFromRva(mi, dw);
            si->Flags |= SYMFLAG_THUNK;
        }
        // pass through
    case SymTagFunction:
    case SymTagPublicSymbol:
        hr = idiaSymbol->get_relativeVirtualAddress(&dw);
        si->Address = GetAddressFromRva(mi, dw);
        if (si->Address)
            break;
        if (option(SYMOPT_ALLOW_ABSOLUTE_SYMBOLS)) {
            hr = idiaSymbol->get_virtualAddress(&va);
            si->Address = va;
        }
        if (!si->Address)
            rc = false;
        break;

    case SymTagBlock:
        hr = idiaSymbol->get_relativeVirtualAddress(&dw);
        si->Address = GetAddressFromRva(mi, dw);
        if (!si->Address)
            rc = false;
        return rc;

    case SymTagAnnotation:
        // Local data search
        hr = idiaSymbol->findChildren(SymTagNull, NULL, nsNone, &idiaValues);
        if (hr != S_OK || !idiaValues) 
            break;
        p = si->Name;
        *p = 0;
        while (SUCCEEDED(idiaValues->Next(1, &idiaValue, &dw)) && dw == 1) {
            hr = idiaValue->get_value(&value);
            if (hr != S_OK) 
                break;
            wcs2ansi(value.bstrVal, p, si->MaxNameLen - (ULONG)(p - si->Name));
            p += strlen(p) + 1;
            FreeDiaVariant(&value);
            idiaValue = NULL;  
        }
        *(p + 1) = 0;
        hr = idiaSymbol->get_relativeVirtualAddress(&dw);
        si->Address = GetAddressFromRva(mi, dw);
        if (!si->Address)
            rc = false;
        // There's no name processing for annotations.  We're done.
        return rc;

    default:
        break;
    }

    if (hr != S_OK)
        return false;

    // check for flags and types

    hr = idiaSymbol->get_dataKind(&dw);
    if (hr == S_OK) {
        if (dw == DataIsParam)
            si->Flags |= SYMFLAG_PARAMETER;
        else if (dw == DataIsConstant)
            si->Flags = SYMFLAG_CONSTANT;
    }

    hr = idiaSymbol->get_typeId(&dw);
    if (hr == S_OK)
        si->TypeIndex = dw;

    // get the name

    hr = idiaSymbol->get_name(&wname);
    if (hr != S_OK || !wname) {
        if (si->Tag != SymTagThunk)
            return false;
        PrintString(name, DIMA(name), "thunk@%I64x", si->Address);
        CopyString(si->Name, name, si->MaxNameLen);
    } else if (!wname[0]) {
        rc = false;
    } else {
        wcs2ansi(wname, name, MAX_SYM_NAME);
        if ((si->Tag != SymTagPublicSymbol)
            && !option(SYMOPT_NO_PUBLICS)
            && strchr(name, '@')) {
            rc = false;
        }
        if (option(SYMOPT_NO_CPP)) {
            while (p = strstr(name, "::")) {
                p[0] = '_';
                p[1] = '_';
            }
        }
        if (*name == '.')
            si->Flags = SYMFLAG_FUNCTION;
        if (option(SYMOPT_UNDNAME) 
            && ((si->Tag == SymTagPublicSymbol) || (si->Tag == SymTagThunk))) 
        {
            SymUnDNameInternal(si->Name,
                               si->MaxNameLen,
                               name,
                               strlen(name),
                               mi->MachineType,
                               true);
            if (si->MaxNameLen > 0) {
                CopyStrArray(name, si->Name);
            } else {
                name[0] = 0;
            }
        } else {
            CopyString(si->Name, name, si->MaxNameLen);
        }
        // let the caller know this is a $$$XXXAA style symbol
        if (strlen(name) == 8 && !strncmp(name, "$$$",3) &&
            isxdigit(name[5]) && isxdigit(name[6]) && isxdigit(name[7]) ) {
            rc = false;
        }
    }
#ifdef DEBUG
    CopyStrArray(name, mi->si.Name);
    if (traceSubName(name)) // for setting debug breakpoints from DBGHELP_TOKEN
        dtrace("debug(%s)\n", name);
#endif

    if (wname)
        LocalFree (wname);

    // get_length is very expensive on public symbols

    if (si->Tag == SymTagPublicSymbol)
        return rc;

    // okay.  Get the length.

    hr = idiaSymbol->get_length(&size);
    if (hr == S_OK)
        si->Size = (ULONG)size;
    else {
        CComPtr <IDiaSymbol> pType;
        if ((hr = idiaSymbol->get_type(&pType)) == S_OK){
            hr = pType->get_length(&size);
            if (hr == S_OK)
                si->Size = (ULONG)size;
        }
        pType = NULL;
    }

    return rc;
}


BOOL
diaSetModFromIP(
    PPROCESS_ENTRY pe
    )
{
    HRESULT       hr;
    DWORD64       ip;
    DWORD         rva;
    PDIA          pdia;

    // get the current IP

    ip = GetIP(pe);
    if (!ip) {
        pprint(pe, "IP not set!\n");
        return false;
    }

    // find and load symbols for the module that matches the IP

    pe->ipmi = GetModFromAddr(pe, ip);

    if (!pe->ipmi)
        return false;

    if (!pe->ipmi->dia)
        return false;

    pdia = (PDIA)pe->ipmi->dia;
    rva = (DWORD)(ip - pe->ipmi->BaseOfDll);

    CComPtr< IDiaSymbol > idiaScope;
    hr = pdia->session->findSymbolByRVA(rva, SymTagNull, &idiaScope);
    if (hr != S_OK)
        return false;

    hr = pdia->session->symsAreEquiv(idiaScope, pdia->scope);
    if (hr == S_OK)
        return false;

    pdia->scope = idiaScope;

    return true;
}


PWCHAR
ConvertNameForDia(
    LPSTR  name,
    PWCHAR wname
    )
{
    assert (name && wname);
    if (!name || !*name)
        return NULL;

    ansi2wcs(name, wname, MAX_SYM_NAME);

    return wname;
}


VOID
MakeEmbeddedREStr(
    PCHAR out,
    PCHAR in
    )
{
    if (*in != '*')
        *out++ = '*';

    for (; *in; in++, out++)
        *out = *in;

    if (*(in - 1) != '*')
        *out++ = '*';

    *out = 0;
}


BOOL
diaGetLocals(
    PPROCESS_ENTRY pe,
    LPCSTR         name,
    PROC           callback,
    PVOID          context,
    BOOL           use64,
    BOOL           unicode
    )
{
    PMODULE_ENTRY     mi;
    DWORD64           ip;
    DWORD             rva;
    PDIA              pdia;
    HRESULT           hr;
    DWORD             rc;
    DWORD             tag;
    DWORD             scope;
    DWORD             celt;
    DWORD             opt;
    CHAR              symname[MAX_SYM_NAME + 1];
    WCHAR             wbuf[MAX_SYM_NAME + 1];
    PWCHAR            wname;

    assert(pe);

    CComPtr< IDiaSymbol > idiaSymbols;

    opt = option(SYMOPT_CASE_INSENSITIVE) ? nsCaseInRegularExpression : nsRegularExpression;

    if (option(SYMOPT_PUBLICS_ONLY))
        return true;

    // get the current scope

    mi = pe->ipmi;
    if (!mi)
        return false;
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return false;

    idiaSymbols = pdia->scope;
    diaFillSymbolInfo(&mi->si, mi, idiaSymbols);

    PrepRE4Srch(name, symname);
    wname = ConvertNameForDia(symname, wbuf);

    // loop through all symbols

    for ( ; idiaSymbols != NULL; ) {

        CComPtr< IDiaEnumSymbols > idiaEnum;
        // local data search
        hr = idiaSymbols->findChildren(SymTagNull, wname, opt, &idiaEnum);
        if (hr != S_OK)
            return false;

        idiaSymbols->get_symTag(&scope);
        if (hr != S_OK)
            return false;

        if (scope == SymTagExe) { // sanity check, never enumerate all exe's symbols
            break;
        }
        // this walks the local symbol list for the loaded enumeration

        CComPtr< IDiaSymbol > idiaSymbol;

        for (;
             SUCCEEDED(hr = idiaEnum->Next( 1, &idiaSymbol, &celt)) && celt == 1;
             idiaSymbol = NULL)
        {
                ULONG DataKind;
            idiaSymbol->get_symTag(&tag);
            switch (tag)
            {
            case SymTagData:
            case SymTagFunction:
                if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol))
                    continue;
                if (!strcmp(mi->si.Name, "`string'"))
                    continue;
                mi->si.Scope = scope;
                mi->si.Flags |= SYMFLAG_LOCAL;
                if (!callback)
                    return true;
                if (mi->si.Flags & SYMFLAG_CONSTANT)
                    continue;
                rc = DoEnumCallback(pe, &mi->si, mi->si.Size, callback, context, use64, unicode);
                if (!rc) {
                    mi->code = ERROR_CANCELLED;
                    return rc;
                }
                break;
            default:
                break;
            }
        }

        if (callback && scope == SymTagFunction)    // stop when at function scope
            break;

        // move to lexical parent

        CComPtr< IDiaSymbol > idiaParent;
        hr = idiaSymbols->get_lexicalParent(&idiaParent);
        if (hr != S_OK || !idiaParent)
            return false;

        idiaSymbols = idiaParent;
    }

    // We reached the end.  If we enumerating (I.E. callback != NULL)
    // then return true.  If we are searching for a single match,
    // we have failed and should return false;

    if (callback)
        return true;
    return false;
}


int __cdecl
CompareAddrs(
    const void *addr1,
    const void *addr2
    )
{
    LONGLONG Diff = *(DWORD64 *)addr1 - *(DWORD64 *)addr2;

    if (Diff < 0) {
        return -1;
    } else if (Diff > 0) {
        return 1;
    } else {
        return 0;
    }
}


PDWORD64
FindAddr(
    PDWORD64 pAddrs,
    ULONG cAddrs,
    DWORD64  addr
    )
{
    LONG high;
    LONG low;
    LONG i;
    LONG  rc;

    low = 0;
    high = ((LONG)cAddrs) - 1;

    while (high >= low) {
        i = (low + high) >> 1;
        rc = CompareAddrs(&addr, &pAddrs[i]);

        if (rc < 0)
            high = i - 1;
        else if (rc > 0)
            low = i + 1;
        else
            return &pAddrs[i];
    }

    return NULL;
}


typedef BOOL
(CALLBACK *PSYM_LOCALENUMSYMBOL_CALLBACK)(
    PSYMBOL_INFO  si,
    ULONG         size,
    IDiaSymbol   *idiaObj,
    PVOID         context
    );


char* dispsymtag(
    ULONG symtag
    )
{
    static char* names[] =
    {
        "SymTagNull",
        "SymTagExe",
        "SymTagCompiland",
        "SymTagCompilandDetails",
        "SymTagCompilandEnv",
        "SymTagFunction",
        "SymTagBlock",
        "SymTagData",
        "SymTagAnnotation",
        "SymTagLabel",
        "SymTagPublicSymbol",
        "SymTagUDT",
        "SymTagEnum",
        "SymTagFunctionType",
        "SymTagPointerType",
        "SymTagArrayType",
        "SymTagBaseType",
        "SymTagTypedef",
        "SymTagBaseClass",
        "SymTagFriend",
        "SymTagFunctionArgType",
        "SymTagFuncDebugStart",
        "SymTagFuncDebugEnd",
        "SymTagUsingNamespace",
        "SymTagVTableShape",
        "SymTagVTable",
        "SymTagCustom",
        "SymTagThunk",
        "SymTagCustomType",
        "SymTagManagedType",
        "SymTagDimension",
    };
    
    if (symtag >= SymTagMax) 
        return "<Invalid>";
    else 
        return names[symtag];
}


BOOL
diaEnumScope(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    DWORD           tag,
    char           *mask,
    PROC            callback,
    PVOID           context,
    BOOL            use64,
    BOOL            unicode,
    DWORD           flags,
    IDiaSymbol     *idiaScope,
    int             depth
    )
{
    HRESULT hr;
    DWORD   celt;
    DWORD   stg;
    BOOL    disp;
    char    pad[300];

    CComPtr< IDiaEnumSymbols > idiaSymbols;
    CComPtr<IDiaSymbol>        idiaSymbol;
    
    ZeroMemory(pad, 300);
    memset(pad, ' ', depth * 3);

    hr = idiaScope->get_symTag(&stg);
    if (hr != S_OK)
        return false;

    // display all objects within this scope

    hr = idiaScope->findChildren(SymTagNull, NULL, 0, &idiaSymbols);
    if (hr != S_OK) 
        return true;

    while (SUCCEEDED(hr = idiaSymbols->Next( 1, &idiaSymbol, &celt)) && celt == 1) {
        disp = true;
        if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol))
            continue;
        if (mi->si.Tag == SymTagBlock)
            CopyString(mi->si.Name, "BLOCK", mi->si.NameLen);
        if (tag && mi->si.Tag != tag)
            disp = false;
        if (strcmpre(mi->si.Name, mask, !option(SYMOPT_CASE_INSENSITIVE)))
            disp = false;
        if (disp)
            peprint(pe, "%s%s: %s\n", pad, dispsymtag(mi->si.Tag), mi->si.Name);
        diaEnumScope(pe,
                     mi,
                     tag,
                     mask,
                     callback,
                     context,
                     use64,                           
                     unicode,
                     flags,
                     idiaSymbol,
                     depth + 1);
    }

    return true;
}

BOOL
diaGetItems(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi,
    PCSTR          name,
    DWORD64        addr,
    DWORD          tag,
    PROC           callback,
    PVOID          context,
    BOOL           use64,
    BOOL           unicode,
    DWORD          flags
    )
{
    PDIA    pdia;
    HRESULT hr;
    CHAR    symname[MAX_SYM_NAME + 1];

    CComPtr< IDiaSymbol >      idiaGlobals;

    // check parameters

    assert(pe && mi);

    if (!callback)
        return false;

    if (!name)
        name = "*";
    PrepRE4Srch(name, symname);

    // get a session ...

    pdia = (PDIA)mi->dia;
    if (!pdia)
        return false;

    hr = pdia->session->get_globalScope(&idiaGlobals);
    if (hr != S_OK)
        return false;

    // ... and enumerate the global scope

    return diaEnumScope(pe, 
                        mi, 
                        tag, 
                        symname,
                        callback, 
                        context, 
                        use64, 
                        unicode, 
                        flags, 
                        idiaGlobals,
                        1);
}


BOOL
diaGetSymbolsByTag(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi,
    PCSTR          name,
    DWORD64        addr,
    DWORD          tag,
    PROC           callback,
    PVOID          context,
    BOOL           use64,
    BOOL           unicode,
    DWORD          flags
    )
{
    BOOL    rc;
    DWORD   opt;
    BOOL    fCase;
    PWCHAR  wname;
    WCHAR   wbuf[MAX_SYM_NAME + 1];
    CHAR    symname[MAX_SYM_NAME + 1];
    PDIA    pdia;
    HRESULT hr;
    DWORD   celt;

    CComPtr<IDiaSymbol>        idiaSymbol;
    CComPtr< IDiaSymbol >      idiaGlobals;
    CComPtr< IDiaEnumSymbols > idiaSymbols;

    if (flags & SYMENUMFLAG_FULLSRCH)
        return diaGetItems(pe, mi, name, addr, tag, callback, context, use64, unicode, flags);

    // check parameters

    if (!name)
        name = "*";

    assert(pe && mi);

    if (!callback && !name)
        return false;

    if (option(SYMOPT_CASE_INSENSITIVE)) {
        opt = nsCaseInsensitive;
        fCase = false;
    } else {
        opt = nsCaseSensitive;
        fCase = true;
    };

    if (PrepRE4Srch(name, symname))
        opt |= nsfRegularExpression;

    wname = ConvertNameForDia(symname, wbuf);

    // get a session

    pdia = (PDIA)mi->dia;
    if (!pdia)
        return false;

    hr = pdia->session->get_globalScope(&idiaGlobals);
    if (hr != S_OK)
        return false;

    // presume we find nothing

    rc = false;

    hr = idiaGlobals->findChildren((enum SymTagEnum)tag, wname, opt, &idiaSymbols);
    if (hr != S_OK)
        return false;

    for (;
         SUCCEEDED(hr = idiaSymbols->Next( 1, &idiaSymbol, &celt)) && celt == 1;
         idiaSymbol = NULL)
    {
        if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol))
            continue;
        mi->si.Scope = SymTagExe;
        if (!callback)
            return true;
        if (addr && (mi->si.Address != addr))
            continue;
        if (flags & SYMENUMFLAG_SPEEDSRCH) {
            PSYM_LOCALENUMSYMBOL_CALLBACK cb = (PSYM_LOCALENUMSYMBOL_CALLBACK)callback;
            rc = cb(&mi->si, mi->si.Size, idiaSymbol, context);
        } else
            rc = DoEnumCallback(pe, &mi->si, mi->si.Size, callback, context, use64, unicode);
        if (!rc) {
            mi->code = ERROR_CANCELLED;
            break;
        }
    }
    
    return rc;
}


PSYMBOL_INFO
diaGetSymFromToken(
    PMODULE_ENTRY  mi,
    DWORD          token
    )
{
    PDIA    pdia;
    HRESULT hr;

    CComPtr<IDiaSymbol>        idiaSymbol;

    // check parameters

    assert(mi);

    // get a session

    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    hr = pdia->session->findSymbolByToken(token, SymTagFunction, &idiaSymbol);
    if (hr != S_OK)
        return NULL;

    if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol))
        return NULL;

    return  &mi->si;
}


BOOL
diaGetGlobals(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi,
    LPCSTR         name,
    DWORD64        addr,
    PROC           callback,
    PVOID          context,
    BOOL           use64,
    BOOL           unicode
    )
{
    PDIA              pdia;
    HRESULT           hr;
    DWORD             tag;
    DWORD             celt;
    DWORD             rc;
    LONG              cFuncs;
    LONG              cGlobals = 0;
    enum SymTagEnum   SearchTag;
    PDWORD64          pGlobals = NULL;
    PDWORD64          pg       = NULL;
    PWCHAR            wname;
    DWORD             opt;
    WCHAR             wbuf[MAX_SYM_NAME + 1];
    CHAR              symname[MAX_SYM_NAME + 1];
    CHAR              pname[MAX_SYM_NAME + 1];
    BOOL              fCase;

    CComPtr<IDiaSymbol>        idiaSymbol;
    CComPtr< IDiaSymbol >      idiaGlobals;
    CComPtr< IDiaEnumSymbols > idiaSymbols;

    // check parameters

    assert(pe && mi && name);

    if (!callback && !name)
        return false;

    if (option(SYMOPT_CASE_INSENSITIVE)) {
        opt = nsCaseInsensitive;
        fCase = false;
    } else {
        opt = nsCaseSensitive;
        fCase = true;
    };

    if (PrepRE4Srch(name, symname))
        opt |= nsfRegularExpression;

    wname = ConvertNameForDia(symname, wbuf);

    // get a session

    pdia = (PDIA)mi->dia;
    if (!pdia)
        return false;

    hr = pdia->session->get_globalScope(&idiaGlobals);
    if (hr != S_OK)
        return false;

    // presume we find nothing

    rc = false;

    // see if there are any globals at all
    // skip normal symbols, if so required

    if (option(SYMOPT_PUBLICS_ONLY))
        goto publics;

    // if this is an enumeration, we will have to store a list of the addresses
    // of all the symbols we found in the global scope.  Later we will compare
    // this to the publics so as to eliminate doubles.

    if (callback) {
        hr = idiaGlobals->findChildren(SymTagData, wname, opt, &idiaSymbols);
        if (hr != S_OK)
            return false;
        hr = idiaSymbols->get_Count(&cGlobals);
        if (hr != S_OK)
            return false;
        idiaSymbols = NULL;

        hr = idiaGlobals->findChildren(SymTagFunction, wname, opt, &idiaSymbols);
        if (hr != S_OK)
            return false;
        hr = idiaSymbols->get_Count(&cFuncs);
        if (hr != S_OK)
            return false;
        idiaSymbols = NULL;
        cGlobals += cFuncs;

        pGlobals = (PDWORD64)MemAlloc(cGlobals * sizeof(DWORD64));
    }

    if (callback && (!cGlobals || !pGlobals))
        goto publics;

    ZeroMemory(pGlobals, cGlobals * sizeof(DWORD64));

    // First search for data
    SearchTag = SymTagData;
    hr = idiaGlobals->findChildren(SearchTag, wname, opt, &idiaSymbols);
    if (hr != S_OK)
        goto publics;

    for (pg = pGlobals;
         (SUCCEEDED(hr = idiaSymbols->Next( 1, &idiaSymbol, &celt)) && celt == 1) || (SearchTag == SymTagData);
         idiaSymbol = NULL)
    {
        ULONG DataKind;

        if ((SearchTag == SymTagData) && (FAILED(hr) || celt != 1)) {
            // Now search for functions
            SearchTag = SymTagFunction;
            idiaSymbols = NULL;
            hr = idiaGlobals->findChildren(SearchTag, wname, opt, &idiaSymbols);
            if (hr == S_OK)
                continue;
        }

        idiaSymbol->get_symTag(&tag);
        switch (tag)
        {
        case SymTagData:
        case SymTagFunction:
            assert(!callback || ((LONG)(pg - pGlobals) < cGlobals));
            if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol))
                continue;
            if (!strcmp(mi->si.Name, "`string'"))
                continue;
            mi->si.Scope = SymTagExe;
            if (!callback)
                return true;
            if (mi->si.Flags & SYMFLAG_CONSTANT)
                continue;
            if (addr && (mi->si.Address != addr))
                continue;
            if (pg) 
                *pg++ = mi->si.Address;
            rc = DoEnumCallback(pe, &mi->si, mi->si.Size, callback, context, use64, unicode);
            if (!rc) {
                mi->code = ERROR_CANCELLED;
                goto exit;
            }
            break;
        default:
            break;
        }
    }

    qsort(pGlobals, cGlobals, sizeof(DWORD64), CompareAddrs);

publics:
    if (option(SYMOPT_NO_PUBLICS))
        goto exit;
    if (option(SYMOPT_AUTO_PUBLICS) && cGlobals && !IsRegularExpression(name))
        goto exit;

    // now check out the publics table

    if (wname) {
        PrintString(pname, DIMA(pname), "*%s*", symname);
        MakeEmbeddedREStr(pname, symname);
        wname = ConvertNameForDia(pname, wbuf);
    }

    idiaSymbols = NULL;

    opt |= nsfUndecoratedName | nsfRegularExpression;

    hr = idiaGlobals->findChildren(SymTagPublicSymbol, wname, opt, &idiaSymbols);
    if (hr != S_OK)
        goto exit;

    for (;
         SUCCEEDED(hr = idiaSymbols->Next( 1, &idiaSymbol, &celt)) && celt == 1;
         idiaSymbol = NULL)
    {
        if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol))
            continue;
        mi->si.Scope = SymTagPublicSymbol;
        if (!strcmp(mi->si.Name, "`string'"))
            continue;
        // publics names are mangled: this tests the undecorated name against the mask
        if (*name && strcmpre(mi->si.Name, name, fCase))
            continue;
        if (!callback)
            return true;
        if (FindAddr(pGlobals, cGlobals, mi->si.Address))
            continue;
        if (addr && (mi->si.Address != addr))
            continue;
        rc = DoEnumCallback(pe, &mi->si, mi->si.Size, callback, context, use64, unicode);
        if (!rc) {
            mi->code = ERROR_CANCELLED;
            goto exit;
        }
    }

    // We reached the end.  If we are not enumerating (I.E. callback == NULL)
    // then return the result of the last call to the callback.  If we are
    // searching for a single match, we have failed and should return false;

exit:
    MemFree(pGlobals);
    if (!callback)
        return false;
    return rc;
}


BOOL
diaGetSymbols(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi,
    PCSTR          name,
    PROC           callback,
    PVOID          context,
    BOOL           use64,
    BOOL           unicode
    )
{
    // ENUMFIX:
    LPCSTR pname = (name) ? name : "";

    if (mi) {
        return diaGetGlobals(pe, mi, pname, 0, callback, context, use64, unicode);
    } else {
        return diaGetLocals(pe, pname, callback, context, use64, unicode);
    }
}


PSYMBOL_INFO
diaFindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    )
{
    if (!diaGetSymbols(pe, mi, SymName, NULL, NULL, 0, 0))
        return NULL;

    if (!mi)
        mi = pe->ipmi;

    return &mi->si;
}


BOOL
diaEnumerateSymbols(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN PCSTR          mask,
    IN PROC           callback,
    IN PVOID          context,
    IN BOOL           use64,
    IN BOOL           unicode
    )
{
    return diaGetSymbols(pe, mi, mask, callback, context, use64, unicode);
}


BOOL
diaEnumSymForAddr(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN DWORD64        addr,
    IN PROC           callback,
    IN PVOID          context,
    IN BOOL           use64,
    IN BOOL           unicode
    )
{
    return diaGetGlobals(pe, mi, "", addr, callback, context, use64, unicode);
}


PSYMBOL_INFO
diaGetSymFromAddr(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    PDWORD64        disp
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;
    DWORD   tag;
    LONG    omapadj;
    BOOL    fHitBlock;

    // simple sanity check

    if (!addr)
        return NULL;

    assert (mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

#ifdef DEBUG
    if (traceAddr(addr))   // for debug breakpoints ...
        dtrace("found 0x%I64x\n", addr);
#endif

    rva = (DWORD)(addr - mi->BaseOfDll);

    // get the symbol

    CComPtr< IDiaSymbol > idiaSymbol = NULL;

    fHitBlock = false;
    if (!option(SYMOPT_PUBLICS_ONLY)) {

        hr = pdia->session->findSymbolByRVAEx(rva, SymTagNull, &idiaSymbol, &omapadj);
        if (hr != S_OK)
            return NULL;

        // if the symbol is a block, keep grabbing the parent
        // until we get a function...

        idiaSymbol->get_symTag(&tag);
        while (tag == SymTagBlock) {       // SymTagLabel as well?
            CComPtr< IDiaSymbol > idiaParent;
            fHitBlock = true;
            hr = idiaSymbol->get_lexicalParent(&idiaParent);
            if (hr != S_OK || !idiaParent)
                return NULL;
            idiaSymbol = idiaParent;
            idiaSymbol->get_symTag(&tag);
        }

    }

    if (option(SYMOPT_NO_PUBLICS))
        return NULL;

    if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol)) {
        // return a public symbol
        idiaSymbol = NULL;
        hr = pdia->session->findSymbolByRVAEx(rva, SymTagPublicSymbol, &idiaSymbol, &omapadj);
        if (hr == S_OK)
            diaFillSymbolInfo(&mi->si, mi, idiaSymbol);
    }

    if (disp)
        *disp = (fHitBlock) ? addr - mi->si.Address : omapadj;

    return &mi->si;
}


PSYMBOL_INFO
diaGetSymFromAddrByTag(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    DWORD           tag,
    PDWORD64        disp
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;
    LONG    omapadj;

    // simple sanity check

    if (!addr)
        return NULL;

    assert (mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    rva = (DWORD)(addr - mi->BaseOfDll);

    // get the symbol

    CComPtr< IDiaSymbol > idiaSymbol = NULL;

    hr = pdia->session->findSymbolByRVAEx(rva, (enum SymTagEnum)tag, &idiaSymbol, &omapadj);
    if (hr != S_OK)
        return NULL;

    diaFillSymbolInfo(&mi->si, mi, idiaSymbol);
    if (disp)
        *disp = addr - mi->si.Address;

    return &mi->si;
}


typedef struct _ENUMOBJS {
    PPROCESS_ENTRY          pe;
    PMODULE_ENTRY           mi;
    PSYM_ENUMLINES_CALLBACK cb;
    PCSTR                   file;
    PVOID                   context;
} ENUMOBJS, *PENUMOBJS;

BOOL
cbEnumObjs(
    PSYMBOL_INFO  si,
    ULONG         size,
    IDiaSymbol   *idiaObj,
    PVOID         context
    )
{
    WCHAR   wbuf[MAX_PATH + 1];
    BSTR    wfname = NULL;
    HRESULT hr;
    PDIA    pdia;
    PMODULE_ENTRY           mi;
    PENUMOBJS eno = (PENUMOBJS)context;
    PSYM_ENUMLINES_CALLBACK cb;

    WCHAR   wsz[_MAX_PATH + 1];
    char    file[MAX_PATH + 1];
    BSTR    bstr;
    DWORD   dw;
    BOOL    rc;
    
    CComPtr< IDiaEnumSourceFiles > idiaSrcFiles = NULL;
    CComPtr< IDiaSourceFile > idiaSrcFile = NULL;
    CComPtr< IDiaEnumLineNumbers > idiaLines = NULL;
    CComPtr< IDiaLineNumber > idiaLine = NULL;

    dtrace("%s\n", si->Name);

    // get initial data and store the obj name

    pdia = (PDIA)eno->mi->dia;
    if (!pdia)
        return false;
    cb = (PSYM_ENUMLINES_CALLBACK)eno->cb;
    mi = eno->mi;
    if (!mi)
        return false;
    if (!*si->Name)
        return false;
    CopyString(mi->sci.Obj, si->Name, MAX_PATH + 1);
    mi->sci.ModBase = mi->BaseOfDll;

    // prepare the source file name mask

    wfname = NULL;
    if (eno->file && *eno->file) {
        ansi2wcs(eno->file, wbuf, MAX_PATH);
        wfname = wbuf;
    }

    // get all the source files

    hr = pdia->session->findFile(idiaObj, wfname,  nsCaseInsensitive, &idiaSrcFiles);
    if (hr != S_OK)
        return false;

    while (idiaSrcFiles->Next(1, &idiaSrcFile, &dw) == S_OK) {

        hr = idiaSrcFile->get_fileName(&bstr);
        if (hr != S_OK)
            break;

        rc = wcs2ansi(bstr, mi->sci.FileName, MAX_PATH + 1);
        LocalFree(bstr);
        if (!rc || !*mi->sci.FileName)
            break;

        hr = pdia->session->findLines(idiaObj, idiaSrcFile, &idiaLines);
        if (hr != S_OK)
            break;

        while (idiaLines->Next(1, &idiaLine, &dw) == S_OK) {
            hr = idiaLine->get_lineNumber(&mi->sci.LineNumber);
            if (hr != S_OK)
                return false;
            hr = idiaLine->get_relativeVirtualAddress(&dw);
            if (hr != S_OK)
                return false;
            mi->sci.Address = dw + mi->BaseOfDll;   
            idiaLine = NULL;
            if (cb)
                rc = cb(&mi->sci, context);
        }

        idiaLines = NULL;
        idiaSrcFile = NULL;
    }


    return true;
}


BOOL
diaEnumLines(
    IN  PPROCESS_ENTRY          pe,
    IN  PMODULE_ENTRY           mi,
    IN  PCSTR                   obj,
    IN  PCSTR                   file,
    IN  PSYM_ENUMLINES_CALLBACK cb,
    IN  PVOID                   context
    )
{
    ENUMOBJS eno;

    eno.pe      = pe;
    eno.mi      = mi;
    eno.cb      = cb;
    eno.file    = file;
    eno.context = context;

    return diaGetSymbolsByTag(pe,
                              mi,
                              obj,
                              0,
                              SymTagCompiland,
                              (PROC)cbEnumObjs,
                              &eno,
                              false,
                              false,
                              SYMENUMFLAG_SPEEDSRCH);
}


BOOL
diaGetLineFromAddr(
    PMODULE_ENTRY    mi,
    DWORD64          addr,
    PDWORD           displacement,
    PSRCCODEINFO     sci
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;
    DWORD   celt;
    BSTR    bstr;
    DWORD   dw;
    BOOL    rc;

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    rva = (DWORD)(addr - mi->BaseOfDll);

    // On IA64 the slots in a bundle don't have byte addresses.
    // The debugger calls them 0,4,8 by default whereas line
    // symbols have them as 0,1,2.  Convert to line style
    // before querying.
    if (mi->MachineType == IMAGE_FILE_MACHINE_IA64 && (rva & 0xf)) {
        switch(rva & 0xf) {
        case 4:
            rva -= 3;
            break;
        case 8:
            rva -= 6;
            break;
        default:
            // Invalid slot address.
            return false;
        }
    }

    CComPtr< IDiaEnumLineNumbers > idiaLines = NULL;
    hr = pdia->session->findLinesByRVA(rva, 1, &idiaLines);
    if (hr != S_OK)
        return false;

    CComPtr< IDiaLineNumber > idiaLine = NULL;
    hr = idiaLines->Next(1, &idiaLine, &celt);
    if (hr != S_OK || !idiaLine)
        return false;

    hr = idiaLine->get_lineNumber(&dw);
    if (hr != S_OK)
        return false;

    sci->LineNumber = dw;

    pdia->srcfile = NULL;
    hr = idiaLine->get_sourceFile(&pdia->srcfile);
    if (hr != S_OK)
        return false;

    hr = pdia->srcfile->get_fileName(&bstr);
    if (hr != S_OK)
        return false;

    *sci->FileName = 0;
    rc = wcs2ansi(bstr, sci->FileName, DIMA(sci->FileName));
    LocalFree(bstr);
    if (!rc || !*sci->FileName)
        return false;

    hr = idiaLine->get_relativeVirtualAddress(&dw);
    if (hr != S_OK)
        return false;

    sci->Address = dw + mi->BaseOfDll;
    *displacement = rva - dw;

    return true;
}


BOOL
diaGetNextLineFromEnum(
    IDiaEnumLineNumbers *idiaLines,
    DWORD               *line,
    DWORD               *rva
    )
{
    HRESULT hr;
    ULONG   ul;

    CComPtr< IDiaLineNumber > idiaLine = NULL;

    hr = idiaLines->Next(1, &idiaLine, &ul);
    if (hr != S_OK)
        return false;

    hr = idiaLine->get_lineNumber(line);
    if (hr != S_OK)
        return false;

    hr = idiaLine->get_relativeVirtualAddress(rva);
    if (hr != S_OK)
        return false;

    return true;
}

BOOL
diaGetLineNextPrev(
    PMODULE_ENTRY    mi,
    PIMAGEHLP_LINE64 line,
    DWORD            direction
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;
    DWORD   celt;
    WCHAR   wbuf[MAX_PATH + 1];
    BSTR    wfname = NULL;
    DWORD64 bAddr;
    DWORD   trgnum;
    DWORD   num;
    DWORD   dw;
    DWORD   num1 = 0;
    DWORD   num2 = 0;
    DWORD   rva1 = 0;
    DWORD   rva2 = 0;
    LONG    numlines;

    // simple sanity checks

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return false;

    assert(direction == NP_NEXT || direction == NP_PREV);

    if (line->SizeOfStruct != sizeof(IMAGEHLP_LINE64))
        return false;

    // convert file name for DIA

    if (!*line->FileName)
        return false;

    ansi2wcs(line->FileName, wbuf, MAX_PATH);
    wfname = wbuf;

    // save the last found line

    bAddr   = line->Address;

    // all source files in the module  that match the 'wfname'

    CComPtr< IDiaEnumSourceFiles > idiaSrcFiles = NULL;
    hr = pdia->session->findFile(NULL, wfname, nsCaseInsensitive, &idiaSrcFiles);
    if (hr != S_OK)
        return false;

    // the first such file in the list, since we don't use wildcards

    CComPtr< IDiaSourceFile > idiaSrcFile = NULL;
    hr = idiaSrcFiles->Next(1, &idiaSrcFile, &dw);
    if (hr != S_OK)
        return false;

    // all objs that use this source file

    CComPtr< IDiaEnumSymbols > idiaObjs = NULL;
    hr = idiaSrcFile->get_compilands(&idiaObjs);
    if (hr != S_OK)
        return false;

    // LOOP THROUGH ALL THE OBJS! AND STORE THE CLOSEST!

    num = 0;
    rva = 0;

    // grab the first obj, since we don't care

    CComPtr< IDiaSymbol > idiaObj = NULL;
    CComPtr< IDiaEnumLineNumbers > idiaLines = NULL;

    hr = idiaObjs->Next(1, &idiaObj, &celt);
    if (hr != S_OK)
        return false;

    // get the line for starting with

    trgnum = line->LineNumber + direction;
    hr = pdia->session->findLinesByLinenum(idiaObj, idiaSrcFile, trgnum, 0, &idiaLines);
    if (hr != S_OK)
        return false;

    hr = idiaLines->get_Count(&numlines);
    diaGetNextLineFromEnum(idiaLines, &num1, &rva1);
    if (numlines > 1)
        diaGetNextLineFromEnum(idiaLines, &num2, &rva2);
    
    if (direction == NP_PREV) {
        num = num1;
        rva = rva1;
    } else if (num1 == trgnum) {
        num = num1;
        rva = rva1;
    } else {
        num = num2;
        rva = rva2;
    }
    
    if (!num)
        return false;

    if (bAddr == GetLineAddressFromRva(mi, rva))
        return false;

    line->LineNumber = num;
    line->Address = GetLineAddressFromRva(mi, rva);

    return true;
}


#if 0
#define DBG_DIA_LINE 1
#endif

BOOL
diaGetLineFromName(
    PMODULE_ENTRY    mi,
    LPSTR            filename,
    DWORD            linenumber,
    PLONG            displacement,
    PSRCCODEINFO     sci,
    DWORD            method
    )
{
    HRESULT hr;
    WCHAR   wsz[_MAX_PATH + 1];
    char    sz[MAX_PATH + 1];
    PDIA    pdia;
    DWORD   celt;
    BSTR    bstr;
    DWORD   addr;
    DWORD   num;
    BOOL    rc;
    DWORD   flags;
    LONG    cFiles;
    int     i;

    CComPtr<IDiaEnumSourceFiles> idiaSrcFiles;
    CComPtr<IDiaSourceFile> idiaSrcFile;
    CComPtr<IDiaEnumSymbols> idiaEnum;
    CComPtr<IDiaSymbol> idiaSymbol;
    CComPtr<IDiaEnumLineNumbers> idiaLineNumbers;
    CComPtr<IDiaLineNumber> idiaLineNumber;

    assert(mi && mi->dia && filename);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    sciInit(sci);

    if (!ansi2wcs(filename, wsz, DIMA(wsz)))
        return false;
    if (!*wsz)
        return false;

    flags = (method == mFullPath) ? nsfCaseInsensitive : nsFNameExt;

    // get list of matching files and the count of the list

    hr = pdia->session->findFile(NULL, wsz, flags, &idiaSrcFiles);
    if (hr != S_OK)
        return false;
    hr = idiaSrcFiles->get_Count(&cFiles);
    if (hr != S_OK)
        return false;

    *sci->FileName = 0;
    for (i = 0; i < cFiles; i++) {
        hr = idiaSrcFiles->Next(1, &idiaSrcFile, &celt);
        if (hr != S_OK)
            continue;

        hr = idiaSrcFile->get_fileName(&bstr);
        if (hr != S_OK)
            continue;

        rc = wcs2ansi(bstr, sz, DIMA(sz));
        LocalFree(bstr);
        if (!rc || !*sz)
            continue;

        UpdateBestSrc(filename, sci->FileName, sz);
    }

    if (!*sci->FileName)
        return false;

    // this gives us a list of every .obj that uses this source file

    hr = idiaSrcFile->get_compilands(&idiaEnum);
    if (hr != S_OK)
        return false;

    // we don't support multiple objs, so lets take the first one

    hr = idiaEnum->Next(1, &idiaSymbol, &celt);
    if (hr != S_OK)
        return false;

    // This gets a list of all code items that were created from this source line.
    // If we want to fully support inlines and the like, we need to loop all of these

    hr = pdia->session->findLinesByLinenum(idiaSymbol, idiaSrcFile, linenumber, 0, &idiaLineNumbers);
    if (hr != S_OK)
        return false;

    idiaLineNumber = NULL;
    hr  = idiaLineNumbers->Next(1, &idiaLineNumber, &celt);
    if (hr != S_OK)
        return false;
    hr  = idiaLineNumber->get_lineNumber(&num);
    if (hr != S_OK)
        return false;
    sci->LineNumber = num;
    hr = idiaLineNumber->get_relativeVirtualAddress(&addr);
    if (hr != S_OK)
        return false;
    if (!addr)
        return false;

    sci->Address = GetLineAddressFromRva(mi, addr);
    *displacement = linenumber - num;

    return true;
}


BOOL
MatchSourceFile(
    PCHAR filename,
    PCHAR mask
    )
{
    PCHAR p;

    if (!mask || !*mask)
        return true;

    if (!*filename)
        return false;

    for (p = filename + strlen(filename); p >= filename; p--) {
        if (*p == '\\' || *p == '/') {
            p++;
            break;
        }
    }

    if (!strcmpre(p, mask, false))
        return true;

    return false;
}

BOOL
diaEnumSourceFiles(
    IN PMODULE_ENTRY mi,
    IN PCHAR         mask,
    IN PSYM_ENUMSOURCFILES_CALLBACK cbSrcFiles,
    IN PVOID         context
    )
{
    HRESULT hr;
    BSTR    wname=NULL;
    char    name[_MAX_PATH + 1];
    SOURCEFILE sf;

    assert(mi && cbSrcFiles);

    PDIA    pdia;
    pdia = (PDIA)mi->dia;

    sf.ModBase = mi->BaseOfDll  ;
    sf.FileName = name;

    CComPtr< IDiaEnumSourceFiles > idiaEnumFiles;
    hr = pdia->session->findFile(NULL, NULL, nsNone, &idiaEnumFiles);
    if (hr != S_OK)
        return false;

    ULONG celt;
    CComPtr <IDiaSourceFile> idiaSource;
    for (;SUCCEEDED(idiaEnumFiles->Next(1, &idiaSource, &celt)) && (celt == 1);) {
        hr = idiaSource->get_fileName(&wname);
        if (hr == S_OK && wname) {
            wcs2ansi(wname, name, _MAX_PATH);
            LocalFree (wname);
            if (MatchSourceFile(name, mask)) {
                if (!cbSrcFiles(&sf, context)) {
                    mi->code = ERROR_CANCELLED;
                    return false;
                }
            }
        }
        idiaSource = NULL;
    }

    return true;
}


PSYMBOL_INFO
diaGetSymNextPrev(
    PMODULE_ENTRY mi,
    DWORD64       addr,
    int           direction
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;
    DWORD   celt;

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    CComPtr<IDiaEnumSymbolsByAddr> idiaSymbols;
    hr = pdia->session->getSymbolsByAddr(&idiaSymbols);
    if (hr != S_OK)
        return NULL;

    rva = addr ? (DWORD)(addr - mi->BaseOfDll) : 0;

    CComPtr<IDiaSymbol> idiaSymbol;
    hr = idiaSymbols->symbolByRVA(rva, &idiaSymbol);
    if (hr != S_OK)
        return NULL;

findsymbol:
    if (addr) {
        if (direction < 0) {
            idiaSymbol = NULL;
            hr = idiaSymbols->Prev(1, &idiaSymbol, &celt);
        } else {
            idiaSymbol = NULL;
            hr = idiaSymbols->Next(1, &idiaSymbol, &celt);
        }
        if (hr != S_OK)
            return NULL;
        if (celt != 1)
            return NULL;
    }

    diaFillSymbolInfo(&mi->si, mi, idiaSymbol);
    if (!*mi->si.Name) {
        rva = (DWORD)(mi->si.Address - mi->BaseOfDll);
        goto findsymbol;
    }

    return &mi->si;
}


HRESULT
diaGetSymTag(IDiaSymbol *pType, PULONG pTag)
{
    return pType->get_symTag(pTag);
}

HRESULT
diaGetSymIndexId(IDiaSymbol *pType, PULONG pIndex)
{
    return pType->get_symIndexId(pIndex);
}

HRESULT
diaGetLexicalParentId(IDiaSymbol *pType, PULONG pIndex)
{
    return pType->get_lexicalParentId(pIndex);
}

HRESULT
diaGetDataKind(IDiaSymbol *pType, PULONG pKind)
{
    return pType->get_dataKind(pKind);
}

HRESULT
diaGetSymName(IDiaSymbol *pType, BSTR *pname)
{
    return pType->get_name(pname);
}


HRESULT
diaGetLength(IDiaSymbol *pType, PULONGLONG pLength)
{
    return pType->get_length(pLength);
}

HRESULT
diaGetType(IDiaSymbol *pType, IDiaSymbol ** pSymbol)
{
    return pType->get_type(pSymbol);
}

HRESULT
diaGetBaseType(IDiaSymbol *pType, PULONG pBase)
{
    return pType->get_baseType(pBase);
}

HRESULT
diaGetArrayIndexTypeId(IDiaSymbol *pType, PULONG pSymbol)
{
    return pType->get_arrayIndexTypeId(pSymbol);
}

HRESULT
diaGetTypeId(IDiaSymbol *pType, PULONG pTypeId)
{
    return pType->get_typeId(pTypeId);
}

HRESULT
diaGetCallingConvention(IDiaSymbol *pType, PULONG pConvention)
{
    HRESULT hr;

    hr = pType->get_callingConvention(pConvention);
    if (hr != S_OK)
        *pConvention = CV_CALL_RESERVED;

    return hr;
}

HRESULT
diaGetChildrenCount(IDiaSymbol *pType, LONG *pCount)
{
    CComPtr <IDiaEnumSymbols> pEnum;
    HRESULT          hr;
    ULONG            index;
    CComPtr <IDiaSymbol>      pSym;
    ULONG            Count;

    if ((hr = pType->findChildren(SymTagNull, NULL, nsNone, &pEnum)) != S_OK) {
        return hr;
    }
    return pEnum->get_Count(pCount);
}

HRESULT
diaFindChildren(IDiaSymbol *pType, TI_FINDCHILDREN_PARAMS *Params)
{
    CComPtr <IDiaEnumSymbols> pEnum;
    HRESULT          hr;
    ULONG            index;
    CComPtr <IDiaSymbol>      pSym;
    ULONG            Count;

    if ((hr = pType->findChildren(SymTagNull, NULL, nsNone, &pEnum)) != S_OK) {
        return hr;
    }

    VARIANT var;

    pEnum->Skip(Params->Start);
    for (Count = Params->Count, index = Params->Start; Count > 0; Count--, index++) {
        ULONG celt;
        pSym = NULL;
        if ((hr = pEnum->Next(1, &pSym, &celt)) != S_OK) {
            return hr;
        }

        if ((hr = pSym->get_symIndexId(&Params->ChildId[index])) != S_OK) {
            return hr;
        }
    }
    return S_OK;
}

HRESULT
diaGetAddressOffset(IDiaSymbol *pType, ULONG *pOff)
{
    return pType->get_addressOffset(pOff);
}

HRESULT
diaGetOffset(IDiaSymbol *pType, LONG *pOff)
{
    return pType->get_offset(pOff);
}

HRESULT
diaGetValue(IDiaSymbol *pType, VARIANT *pVar)
{
    return pType->get_value(pVar);
}

HRESULT
diaGetCount(IDiaSymbol *pType, ULONG *pCount)
{
    return pType->get_count(pCount);
}

HRESULT
diaGetBitPosition(IDiaSymbol *pType, ULONG *pPos)
{
    return pType->get_bitPosition(pPos);
}

HRESULT
diaGetVirtualBaseClass(IDiaSymbol *pType, BOOL *pBase)
{
    return pType->get_virtualBaseClass(pBase);
}

HRESULT
diaGetVirtualTableShapeId(IDiaSymbol *pType, PULONG pShape)
{
    return pType->get_virtualTableShapeId(pShape);
}

HRESULT
diaGetVirtualBasePointerOffset(IDiaSymbol *pType, LONG *pOff)
{
    return pType->get_virtualBasePointerOffset(pOff);
}

HRESULT
diaGetClassParentId(IDiaSymbol *pType, ULONG *pCid)
{
    return pType->get_classParentId(pCid);
}

HRESULT
diaGetNested(IDiaSymbol *pType, BOOL *pNested)
{
    return pType->get_nested(pNested);
}

HRESULT
diaGetSymAddress(IDiaSymbol *pType, ULONG64 ModBase, PULONG64 pAddr)
{
    ULONG rva;
    HRESULT Hr;

    Hr = pType->get_relativeVirtualAddress(&rva);
    if (Hr == S_OK) *pAddr = ModBase + rva;
    return Hr;
}

HRESULT
diaGetThisAdjust(IDiaSymbol *pType, LONG *pThisAdjust)
{
    return pType->get_thisAdjust(pThisAdjust);
}

HRESULT
diaGetUdtKind(IDiaSymbol *pType, DWORD *pUdtKind)
{
    return pType->get_udtKind(pUdtKind);
}

BOOL
diaCompareTypeSym(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  IDiaSymbol     *pType1,
    IN OUT PULONG       TypeId2
    )
{
    PPROCESS_ENTRY ProcessEntry;
    PDIA          pdia;
    PMODULE_ENTRY mi;
    CComPtr<IDiaSymbol> pType2;

    ProcessEntry = FindProcessEntry( hProcess );
    if (!ProcessEntry || !(mi = GetModFromAddr(ProcessEntry, ModBase))) {
        return false;
    }

    pdia = (PDIA)mi->dia;
    if (!pdia) {
        return false;
    }
    if (pdia->session->symbolById(*TypeId2, &pType2) != S_OK) {
        return false;
    }
    if (pdia->session->symsAreEquiv(pType1, pType2) != S_OK) {
        *TypeId2 = 0;
    }
    return true;
}

BOOL
diaFindTypeSym(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    OUT IDiaSymbol    **pType
    )
{
    PPROCESS_ENTRY ProcessEntry;
    PDIA          pdia;
    PMODULE_ENTRY mi;

    ProcessEntry = FindProcessEntry( hProcess );
    if (!ProcessEntry || !(mi = GetModFromAddr(ProcessEntry, ModBase))) {
        return false;
    }

    pdia = (PDIA)mi->dia;
    if (!pdia) {
        return false;
    }
    return pdia->session->symbolById(TypeId, pType) == S_OK;
}

#ifdef USE_CACHE

ULONG gHits=0, gLook=0;

void
diaInsertInCache(
    PDIA_CACHE_ENTRY pCache,
    PDIA_LARGE_DATA plVals,
    ULONGLONG Module,
    ULONG TypeId,
    IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    PVOID pInfo
    )
{
    if (GetType == TI_IS_EQUIV_TO) {
        // Not cached.
        return;
    }

    int start = CACHE_BLOCK * (TypeId % CACHE_BLOCK);
    int i, found;
    ULONG len,age;
    PDIA_LARGE_DATA pLargeVal=NULL;

    if (GetType == TI_FINDCHILDREN || GetType == TI_GET_SYMNAME) {
        for (pLargeVal = plVals, found=i=0, age=0; i<2*CACHE_BLOCK; i++) {
            if (!plVals[i].Used) {
                pLargeVal = &plVals[i];
                break;
            } else if (pCache[plVals[i].Index].Age > age) {
                pLargeVal = &plVals[i];
                age = pCache[plVals[i].Index].Age;
                assert(DIACH_PLVAL == pCache[pLargeVal->Index].Data.type);
                assert(pLargeVal == pCache[pLargeVal->Index].Data.plVal);
            }
        }
//    } else {
//      return;
    }
//    if (!(gLook % 200)) {
//      if (GetType == TI_FINDCHILDREN || GetType == TI_GET_SYMNAME) {
//          printf("Index   \tUsed\tBy\t\tfound %lx\n", pLargeVal);
//          for (found=i=0, age=0; i<2*CACHE_BLOCK; i++) {
//              printf("%08lx \t%lx\t%lx\n",
//                     &plVals[i], plVals[i].Used, plVals[i].Index);
//          }
//      }
//    }

    for (i=found=start, age=0; i<(start+CACHE_BLOCK); i++) {
        if (++pCache[i].Age > age) {
            age = pCache[i].Age; found = i;
        }
    }
    i=found;
    if (pCache[i].Data.type == DIACH_PLVAL) {
        assert(pCache[i].Data.plVal->Index == (ULONG) i);
        pCache[i].Data.plVal->Index = 0;
        pCache[i].Data.plVal->Used = 0;
        pCache[i].Data.type = 0;
        pCache[i].Data.ullVal = 0;
    }
    pCache[i].Age        = 0;
    pCache[i].s.DataType = GetType;
    pCache[i].s.TypeId   = TypeId;
    pCache[i].Module     = Module;

    switch (GetType) {
    case TI_GET_SYMTAG:
    case TI_GET_COUNT:
    case TI_GET_CHILDRENCOUNT:
    case TI_GET_BITPOSITION:
    case TI_GET_VIRTUALBASECLASS:
    case TI_GET_VIRTUALTABLESHAPEID:
    case TI_GET_VIRTUALBASEPOINTEROFFSET:
    case TI_GET_CLASSPARENTID:
    case TI_GET_TYPEID:
    case TI_GET_BASETYPE:
    case TI_GET_ARRAYINDEXTYPEID:
    case TI_GET_DATAKIND:
    case TI_GET_ADDRESSOFFSET:
    case TI_GET_OFFSET:
    case TI_GET_NESTED:
    case TI_GET_THISADJUST:
    case TI_GET_UDTKIND:
        pCache[i].Data.type = DIACH_ULVAL;
        pCache[i].Data.ulVal = *((PULONG) pInfo);
        break;

    case TI_GET_LENGTH:
    case TI_GET_ADDRESS:
        pCache[i].Data.type = DIACH_ULLVAL;
        pCache[i].Data.ullVal = *((PULONGLONG) pInfo);
        break;

    case TI_GET_SYMNAME: {
        len = 2*(1+wcslen(*((BSTR *) pInfo)));

        if (pLargeVal &&
            len < sizeof(pLargeVal->Bytes)) {
//            dtrace("Ins name  %08lx %s had %3lx name %ws\n",
//                  pLargeVal, pLargeVal->Used ? "used" : "free",
//              pLargeVal->Index, &pLargeVal->Bytes[0]);
            memcpy(&pLargeVal->Bytes[0], *((BSTR *) pInfo), len);
            pLargeVal->LengthUsed = len;

            if (pLargeVal->Used) {
                pCache[pLargeVal->Index].Data.type = 0;
                pCache[pLargeVal->Index].Data.ullVal = 0;
                pCache[pLargeVal->Index].SearchId = 0;
            }
            pCache[i].Data.type = DIACH_PLVAL;
            pCache[i].Data.plVal = pLargeVal;
            pLargeVal->Index = i;
            pLargeVal->Used = true;
//          dtrace(Ins %9I64lx ch %3lx lch %08lx name %ws\n",
//                  pCache[i].SearchId,  i,  pLargeVal,  &pLargeVal->Bytes[0]);
        } else {
            pCache[i].SearchId = 0;
        }
        break;
    }
    case TI_FINDCHILDREN: {
        TI_FINDCHILDREN_PARAMS *pChild = (TI_FINDCHILDREN_PARAMS *) pInfo;

        len = sizeof(TI_FINDCHILDREN_PARAMS) + pChild->Count*sizeof(pChild->ChildId[0]) - sizeof(pChild->ChildId);

        if (pLargeVal &&
            len < sizeof(pLargeVal->Bytes)) {
//            dtrace("Ins child %08lx %s had %3lx name %ws\n",
//                  pLargeVal, pLargeVal->Used ? "used" : "free",
//              pLargeVal->Index, &pLargeVal->Bytes[0]);
            memcpy(&pLargeVal->Bytes[0], pChild, len);
            pLargeVal->LengthUsed = len;
            if (pLargeVal->Used) {
                pCache[pLargeVal->Index].Data.type = 0;
                pCache[pLargeVal->Index].Data.ullVal = 0;
                pCache[pLargeVal->Index].SearchId = 0;
            }
            pCache[i].Data.type = DIACH_PLVAL;
            pCache[i].Data.plVal = pLargeVal;
            pLargeVal->Index = i;
            pLargeVal->Used = true;
        } else {
            pCache[i].SearchId = 0;
        }
        break;
    }
    case TI_GET_VALUE:
    default:
        pCache[i].Data.type = 0;
        pCache[i].SearchId = 0;
        return ;
    }


}

BOOL
diaLookupCache(
    PDIA_CACHE_ENTRY pCache,
    ULONG64 Module,
    ULONG TypeId,
    IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    PVOID pInfo
    )
{
    if (GetType == TI_IS_EQUIV_TO) {
        // Not cached.
        return false;
    }

    int start = CACHE_BLOCK * (TypeId % CACHE_BLOCK);
    int i, found;
    ULONGLONG Search = ((ULONGLONG) GetType << 32) + TypeId;

    ++gLook;

    for (i=start,found=-1; i<(start+CACHE_BLOCK); i++) {
        if (pCache[i].SearchId == Search &&
            pCache[i].Module == Module) {
            found = i;
            break;
        }
    }
    if (found == -1) {
        return false;
    }

    i=found;
    pCache[i].Age = 0;
    switch (pCache[i].Data.type) {
    case DIACH_ULVAL:
        *((PULONG) pInfo) = pCache[i].Data.ulVal;
        break;

    case DIACH_ULLVAL:
         *((PULONGLONG) pInfo) = pCache[i].Data.ullVal;
         break;

    case DIACH_PLVAL:
        if (GetType == TI_GET_SYMNAME) {

            *((BSTR *) pInfo) = (BSTR) LocalAlloc(0, pCache[i].Data.plVal->LengthUsed);

            if (*((BSTR *) pInfo)) {
                memcpy(*((BSTR *) pInfo), &pCache[i].Data.plVal->Bytes[0],pCache[i].Data.plVal->LengthUsed);
//              dtrace(Lok %9I64lx ch %3lx lch %08lx name %ws\n",
//                      pCache[i].SearchId,
//                      i,
//                      pCache[i].Data.plVal,
//                      &pCache[i].Data.plVal->Bytes[0]);
            }
        } else if (GetType == TI_FINDCHILDREN) {
            TI_FINDCHILDREN_PARAMS *pChild = (TI_FINDCHILDREN_PARAMS *) pInfo;
            TI_FINDCHILDREN_PARAMS *pStored = (TI_FINDCHILDREN_PARAMS *) &pCache[i].Data.plVal->Bytes[0];
//          dtrace(Lok %9I64lx ch %3lx lch %08lx child %lx\n",
//                  pCache[i].SearchId,
//                  i,
//                  pCache[i].Data.plVal,
//                  pStored->Count);

            if (pChild->Count == pStored->Count &&
                pChild->Start == pStored->Start) {
                memcpy(pChild, pStored, pCache[i].Data.plVal->LengthUsed);
            }
        }
        break;
    default:
        assert(false);
        return false;
    }
    if (!(++gHits%50)) {
//        dtrace("%ld %% Hits\n", (gHits * 100) / gLook);
    }
    return true;
}

#endif // USE_CACHE

HRESULT
#ifdef USE_CACHE
diaGetSymbolInfoEx(
#else
diaGetSymbolInfo(
#endif // USE_CACHE
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    )
{
    assert(pInfo);
    CComPtr <IDiaSymbol> pTypeSym;
    if (!diaFindTypeSym(hProcess, ModBase, TypeId, &pTypeSym)) {
        return E_INVALIDARG;
    }

    switch (GetType) {
    case TI_GET_SYMTAG:
        return diaGetSymTag(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_SYMNAME:
        return diaGetSymName(pTypeSym, (BSTR *) pInfo);
        break;
    case TI_GET_LENGTH:
        return diaGetLength(pTypeSym, (PULONGLONG) pInfo);
        break;
    case TI_GET_TYPE:
    case TI_GET_TYPEID:
        return diaGetTypeId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_BASETYPE:
        return diaGetBaseType(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_ARRAYINDEXTYPEID:
        return diaGetArrayIndexTypeId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_FINDCHILDREN:
        return diaFindChildren(pTypeSym, (TI_FINDCHILDREN_PARAMS *) pInfo);
    case TI_GET_DATAKIND:
        return diaGetDataKind(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_ADDRESSOFFSET:
        return diaGetAddressOffset(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_OFFSET:
        return diaGetOffset(pTypeSym, (PLONG) pInfo);
        break;
    case TI_GET_VALUE:
        return diaGetValue(pTypeSym, (VARIANT *) pInfo);
        break;
    case TI_GET_COUNT:
        return diaGetCount(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_CHILDRENCOUNT:
        return diaGetChildrenCount(pTypeSym, (PLONG) pInfo);
        break;
    case TI_GET_BITPOSITION:
        return diaGetBitPosition(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_VIRTUALBASECLASS:
        return diaGetVirtualBaseClass(pTypeSym, (BOOL *) pInfo);
        break;
    case TI_GET_VIRTUALTABLESHAPEID:
        return diaGetVirtualTableShapeId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_VIRTUALBASEPOINTEROFFSET:
        return diaGetVirtualBasePointerOffset(pTypeSym, (PLONG) pInfo);
        break;
    case TI_GET_CLASSPARENTID:
        return diaGetClassParentId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_NESTED:
        return diaGetNested(pTypeSym, (PBOOL) pInfo);
        break;
    case TI_GET_SYMINDEX:
        return diaGetSymIndexId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_LEXICALPARENT:
        return diaGetLexicalParentId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_ADDRESS:
        return diaGetSymAddress(pTypeSym, ModBase, (PULONG64) pInfo);
    case TI_GET_THISADJUST:
        return diaGetThisAdjust(pTypeSym, (PLONG) pInfo);
    case TI_GET_UDTKIND:
        return diaGetUdtKind(pTypeSym, (PDWORD) pInfo);
    case TI_IS_EQUIV_TO:
        if (!diaCompareTypeSym(hProcess, ModBase, pTypeSym, (PULONG)pInfo)) {
            return E_INVALIDARG;
        }
        return *(PULONG)pInfo != 0 ? S_OK : S_FALSE;
    case TI_GET_CALLING_CONVENTION:
        return diaGetCallingConvention(pTypeSym, (PULONG)pInfo);
        break;

    default:
        return E_INVALIDARG;
    }
}

#ifdef USE_CACHE
HRESULT
diaGetSymbolInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    )
{
    PPROCESS_ENTRY ProcessEntry;

    ProcessEntry = FindProcessEntry( hProcess );

    if (!ProcessEntry) {
        return E_INVALIDARG;
    }
    if (!diaLookupCache(ProcessEntry->DiaCache, ModBase, TypeId, GetType, pInfo)) {
        HRESULT hr = diaGetSymbolInfoEx(hProcess, ModBase, TypeId, GetType, pInfo);
        if (hr == S_OK) {
            diaInsertInCache(ProcessEntry->DiaCache, ProcessEntry->DiaLargeData,
                             ModBase, TypeId, GetType, pInfo);
        }
        return hr;
    }
    return S_OK;
}
#endif // USE_CACHE

BOOL
diaGetTiForUDT(
    PMODULE_ENTRY ModuleEntry,
    LPSTR         name,
    PSYMBOL_INFO  psi
    )
{
    BSTR    wname=NULL;
    PDIA    pdia;
    HRESULT hr;
    ULONG   celt;

    if (!ModuleEntry) {
        return false;
    }

    pdia = (PDIA)ModuleEntry->dia;
    if (!pdia)
        return false;


    CComPtr< IDiaSymbol > idiaSymbols;
    hr = pdia->session->get_globalScope(&idiaSymbols);

    if (hr != S_OK)
        return false;

    if (name) {
        wname = AnsiToUnicode(name);
    }

    CComPtr< IDiaEnumSymbols > idiaEnum;

    hr = idiaSymbols->findChildren(SymTagNull, wname, nsCaseSensitive, &idiaEnum);
    if (hr == S_OK) {

        CComPtr< IDiaSymbol > idiaSymbol;

        if ((hr = idiaEnum->Next( 1, &idiaSymbol, &celt)) == S_OK && celt == 1) {
            diaFillSymbolInfo(psi, ModuleEntry, idiaSymbol);
            idiaSymbol->get_symIndexId(&psi->TypeIndex);
            idiaSymbol = NULL;
        }
    }

    MemFree(wname);

    return hr == S_OK;
}

BOOL
diaEnumUDT(
    PMODULE_ENTRY ModuleEntry,
    LPSTR         name,
    PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    PVOID         context
    )
{
    BSTR    wname=NULL;
    PDIA    pdia;
    HRESULT hr;
    ULONG   celt;
    CHAR    buff[MAX_SYM_NAME + sizeof(SYMBOL_INFO)];
    PSYMBOL_INFO  psi=(PSYMBOL_INFO)buff;
    BOOL rc;

    psi->MaxNameLen = MAX_SYM_NAME;

    if (!ModuleEntry) {
        return false;
    }

    pdia = (PDIA)ModuleEntry->dia;
    if (!pdia)
        return false;


    CComPtr< IDiaSymbol > idiaSymbols;
    hr = pdia->session->get_globalScope(&idiaSymbols);

    if (hr != S_OK)
        return false;

    if (name && *name) {
        wname = AnsiToUnicode(name);
    }

    CComPtr< IDiaEnumSymbols > idiaEnum;

    hr = idiaSymbols->findChildren(SymTagNull, wname, nsCaseSensitive, &idiaEnum);
    if (hr == S_OK) {

        CComPtr< IDiaSymbol > idiaSymbol;

        while (SUCCEEDED(idiaEnum->Next( 1, &idiaSymbol, &celt)) && celt == 1) {
            ULONG tag;
            idiaSymbol->get_symTag(&tag);
            switch (tag)
            {
            case SymTagEnum:
            case SymTagTypedef:
            case SymTagUDT:
                if (EnumSymbolsCallback) {
                    diaFillSymbolInfo(psi, ModuleEntry, idiaSymbol);
                    idiaSymbol->get_symIndexId(&psi->TypeIndex);
                    rc = EnumSymbolsCallback(psi, 0, context);
                    if (!rc)
                        return true;
                }
                break;
            default:
                break;
            }
            idiaSymbol = NULL;
        }
    }

    MemFree(wname);

    return hr == S_OK;
}

BOOL
ldiaGetFrameData(
    IN HANDLE Process,
    IN ULONGLONG Offset,
    OUT IDiaFrameData** FrameData
    )
{
    PPROCESS_ENTRY ProcessEntry;
    PDIA Dia;
    PMODULE_ENTRY Mod;

    ProcessEntry = FindProcessEntry(Process);
    if (!ProcessEntry ||
        !(Mod = GetModFromAddr(ProcessEntry, Offset)) ||
        !(Dia = (PDIA)Mod->dia)) {
        return false;
    }

    if (Dia->framedata == NULL) {

        CComPtr<IDiaEnumTables> EnumTables;
        CComPtr<IDiaTable> FdTable;
        VARIANT FdVar;

        FdVar.vt = VT_BSTR;
        FdVar.bstrVal = DiaTable_FrameData;

        if (Dia->session->getEnumTables(&EnumTables) != S_OK ||
            EnumTables->Item(FdVar, &FdTable) != S_OK ||
            FdTable->QueryInterface(IID_IDiaEnumFrameData,
                                    (void**)&Dia->framedata) != S_OK) {
            return false;
        }
    }

    return Dia->framedata->frameByVA(Offset, FrameData) == S_OK;
}


BOOL
diaGetFrameData(
    IN HANDLE Process,
    IN ULONGLONG Offset,
    OUT IDiaFrameData** FrameData
    )
{
    BOOL rc = false;

    __try {

        EnterCriticalSection(&g.threadlock);
        rc = ldiaGetFrameData(Process, Offset,FrameData);

    } __finally  {

        LeaveCriticalSection(&g.threadlock);
    }

    return rc;
}





// ----------------------------------------------------------------
// for compatibility with GetFileLineOffsets.  DON'T CALL THIS CODE!

#if 1
HRESULT
diaAddLinesForSourceFile(
    PMODULE_ENTRY mi,
    IDiaSourceFile     *idiaSource,
    IDiaSymbol         *pComp
    )
{
    HRESULT hr;
    LPSTR   SrcFileName = NULL;
    BSTR    wfname = NULL;
    ULONG   SrcFileNameLen = 0;
    PSOURCE_ENTRY Src;
    PSOURCE_ENTRY Seg0Src;
    PSOURCE_LINE SrcLine;
    PDIA    pdia;
    ULONG   celt;
    LONG    LineNums;
    ULONG   CompId;
    CHAR    fname[MAX_PATH + 1];
    DWORD   rva;
    ULONG   Line;

    if (!idiaSource) {
        return E_INVALIDARG;
    }

    assert((mi != NULL) && (mi->dia));

    pdia = (PDIA)mi->dia;

    if (pComp->get_symIndexId(&CompId) == S_OK) {
    }

    CComPtr <IDiaEnumLineNumbers> idiaEnumLines;

    hr = pdia->session->findLines(pComp, idiaSource, &idiaEnumLines);
    if (hr != S_OK)
        return hr;

    hr = idiaEnumLines->get_Count(&LineNums);
    if (hr != S_OK)
        return hr;

    CComPtr <IDiaLineNumber> idiaLine;

    if (idiaSource->get_fileName(&wfname) == S_OK && wfname) {
        wcs2ansi(wfname, fname, MAX_PATH);
        LocalFree(wfname);
        SrcFileNameLen = strlen(fname);
    }

    Src = (PSOURCE_ENTRY)MemAlloc(sizeof(SOURCE_ENTRY)+
                              sizeof(SOURCE_LINE)*LineNums+
                              SrcFileNameLen + 1);

    if (!Src) {
        return E_OUTOFMEMORY;
    }

#ifdef DBG_DIA_LINE
    dtrace("diaAddLinesForSourceFile : source : %s\n", fname);
#endif

    // Retrieve line numbers and offsets from raw data and
    // process them into current pointers.

    SrcLine = (SOURCE_LINE *)(Src+1);
    Src->LineInfo = SrcLine;
    Src->ModuleId = CompId;
    Src->MaxAddr  = 0;
    Src->MinAddr  = -1;

    Src->Lines = 0;
    idiaLine = NULL;
    for (; (hr = idiaEnumLines->Next(1, &idiaLine, &celt)) == S_OK && (celt == 1); ) {
        hr = idiaLine->get_lineNumber(&Line);
        if (hr != S_OK)
            break;
        hr = idiaLine->get_relativeVirtualAddress(&rva);
        if (hr != S_OK)
            break;


        SrcLine->Line = Line;
        SrcLine->Addr = GetLineAddressFromRva(mi, rva);

        if (SrcLine->Addr > Src->MaxAddr) {
            Src->MaxAddr = SrcLine->Addr;
        }
        if (SrcLine->Addr < Src->MinAddr) {
            Src->MinAddr = SrcLine->Addr;
        }
#ifdef DBG_DIA_LINE
        dtrace("Add line %lx, Addr %I64lx\n", SrcLine->Line, SrcLine->Addr);
#endif

        Src->Lines++;
        SrcLine++;
        idiaLine = NULL;
    }

    // Stick file name at the very end of the data block so
    // it doesn't interfere with alignment.
    Src->File = (LPSTR)SrcLine;
    if (*fname) {
        memcpy(Src->File, fname, SrcFileNameLen);
    }
    Src->File[SrcFileNameLen] = 0;

    AddSourceEntry(mi, Src);
    return S_OK;
}


BOOL
diaAddLinesForMod(
    PMODULE_ENTRY mi,
    IDiaSymbol   *diaModule
    )
{
    LONG Size;
    BOOL Ret;
    PSOURCE_ENTRY Src;
    ULONG ModId;
    HRESULT Hr;

    if (diaModule->get_symIndexId(&ModId) != S_OK) {
        return false;
    }
#ifdef DBG_DIA_LINE
        dtrace("diaAddLinesForMod : ModId %lx\n", ModId);
#endif

    // Check and see if we've loaded this information already.
    for (Src = mi->SourceFiles; Src != NULL; Src = Src->Next) {
        // Check module index instead of pointer since there's
        // no guarantee the pointer would be the same for different
        // lookups.
        if (Src->ModuleId == ModId) {
            return true;
        }
    }

    PDIA    pdia;
    pdia = (PDIA)mi->dia;

    CComPtr< IDiaEnumSourceFiles > idiaEnumFiles;
    Hr = pdia->session->findFile(diaModule, NULL, nsNone, &idiaEnumFiles);
    if (Hr != S_OK) {
        return false;
    }

    ULONG celt;
    CComPtr <IDiaSourceFile> idiaSource;
    for (;SUCCEEDED(idiaEnumFiles->Next(1,&idiaSource, &celt)) && (celt == 1);) {
        diaAddLinesForSourceFile(mi, idiaSource, diaModule);
        idiaSource = NULL;
    }

    return true;
}


BOOL
diaAddLinesForModAtAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr
    )
{
    BOOL Ret;
    DWORD Bias;
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    rva = (DWORD)(Addr - mi->BaseOfDll);

    CComPtr < IDiaSymbol > pComp;
    hr = pdia->session->findSymbolByRVA(rva, SymTagCompiland, &pComp);
    if (hr != S_OK)
        return false;

    Ret = diaAddLinesForMod(mi, pComp);

    return Ret;
}

BOOL
diaAddLinesForAllMod(
    PMODULE_ENTRY mi
    )
{
    HRESULT hr;
    PDIA    pdia;
    ULONG   celt = 1;
    BOOL Ret;

    Ret = false;
#ifdef DBG_DIA_LINE
        dtrace("diaAddLinesForAllMod : Adding lines for all mods in %s\n", mi->ImageName);
#endif

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    CComPtr <IDiaSymbol> idiaSymbols;

    hr = pdia->session->get_globalScope(&idiaSymbols);
    if (hr != S_OK)
        return NULL;

    CComPtr< IDiaEnumSymbols > idiaMods;
    hr = pdia->session->findChildren(idiaSymbols,SymTagCompiland, NULL, nsNone, &idiaMods);
    if (FAILED(hr))
        return false;

    CComPtr< IDiaSymbol > idiaSymbol;

    while (SUCCEEDED(idiaMods->Next( 1, &idiaSymbol, &celt)) && celt == 1) {
        Ret = diaAddLinesForMod(mi, idiaSymbol);
        idiaSymbol = NULL;
        if (!Ret) {
            break;
        }
    }

    return Ret;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\checksum.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checksum.c

Abstract:

    This module implements a function for computing the checksum of an
    image file. It will also compute the checksum of other files as well.

Author:

    David N. Cutler (davec) 21-Mar-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>

//
// Define checksum routine prototype.
//
#ifdef __cplusplus
extern "C"
#endif
USHORT
ChkSum(
    DWORD PartialSum,
    PUSHORT Source,
    DWORD Length
    );

PIMAGE_NT_HEADERS
CheckSumMappedFile (
    LPVOID BaseAddress,
    DWORD FileLength,
    LPDWORD HeaderSum,
    LPDWORD CheckSum
    )

/*++

Routine Description:

    This functions computes the checksum of a mapped file.

Arguments:

    BaseAddress - Supplies a pointer to the base of the mapped file.

    FileLength - Supplies the length of the file in bytes.

    HeaderSum - Suppllies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    None.

--*/

{

    PUSHORT AdjustSum;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT PartialSum;
    PBYTE pbyte;

    //
    // Compute the checksum of the file and zero the header checksum value.
    //

    *CheckSum = 0;
    *HeaderSum = 0;
    PartialSum = ChkSum(0, (PUSHORT)BaseAddress, FileLength >> 1);

    //
    // If the file is an image file, then subtract the two checksum words
    // in the optional header from the computed checksum before adding
    // the file length, and set the value of the header checksum.
    //

    __try {
        NtHeaders = RtlpImageNtHeader(BaseAddress);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        NtHeaders = NULL;
    }

    if ((NtHeaders != NULL) && (NtHeaders != BaseAddress)) {
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            *HeaderSum = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum;
            AdjustSum = (PUSHORT)(&((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum);
        } else
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            *HeaderSum = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum;
            AdjustSum = (PUSHORT)(&((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum);
        } else {
            return(NULL);
        }
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
    }

    // add the last byte, if needed

    if (FileLength % 2) {
        pbyte = (PBYTE)BaseAddress + FileLength - 1;
        PartialSum += *pbyte;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xFFFF); 
    }

    //
    // Compute the final checksum value as the sum of the paritial checksum
    // and the file length.
    //

    *CheckSum = (DWORD)PartialSum + FileLength;
    return NtHeaders;
}

DWORD
MapFileAndCheckSumW(
    PWSTR Filename,
    LPDWORD HeaderSum,
    LPDWORD CheckSum
    )

/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/

{
#ifndef UNICODE_RULES
    CHAR   FileNameA[ MAX_PATH ];

    //  Convert the file name to Ansi and call the Ansi version
    //  of this function.

    if (WideCharToMultiByte(
                    CP_ACP,
                    0,
                    Filename,
                    -1,
                    FileNameA,
                    MAX_PATH,
                    NULL,
                    NULL ) ) {

        return MapFileAndCheckSumA(FileNameA, HeaderSum, CheckSum);
    }

    return CHECKSUM_UNICODE_FAILURE;

#else  // UNICODE_RULES

    HANDLE FileHandle, MappingHandle;
    LPVOID BaseAddress;
    DWORD FileLength;

    //
    // Open the file for read access
    //

    FileHandle = CreateFileW(
                        Filename,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return CHECKSUM_OPEN_FAILURE;
    }

    //
    //  Create a file mapping, map a view of the file into memory,
    //  and close the file mapping handle.
    //

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL);

    if (!MappingHandle) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAP_FAILURE;
    }

    //
    // Map a view of the file
    //

    BaseAddress = MapViewOfFile(MappingHandle, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(MappingHandle);
    if (BaseAddress == NULL) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAPVIEW_FAILURE;
    }

    //
    // Get the length of the file in bytes and compute the checksum.
    //
    FileLength = GetFileSize( FileHandle, NULL );
    CheckSumMappedFile(BaseAddress, FileLength, HeaderSum, CheckSum);

    //
    // Unmap the view of the file and close file handle.
    //

    UnmapViewOfFile(BaseAddress);
    CloseHandle( FileHandle );
    return CHECKSUM_SUCCESS;

#endif  // UNICODE_RULES
}


ULONG
MapFileAndCheckSumA (
    LPSTR Filename,
    LPDWORD HeaderSum,
    LPDWORD CheckSum
    )

/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/

{
#ifdef UNICODE_RULES
    WCHAR   FileNameW[ MAX_PATH ];

    //
    //  Convert the file name to unicode and call the unicode version
    //  of this function.
    //

    if (MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    Filename,
                    -1,
                    FileNameW,
                    MAX_PATH ) ) {

        return MapFileAndCheckSumW(FileNameW, HeaderSum, CheckSum);

    }

    return CHECKSUM_UNICODE_FAILURE;

#else   // UNICODE_RULES

    HANDLE FileHandle, MappingHandle;
    LPVOID BaseAddress;
    DWORD FileLength;

    //
    // Open the file for read access
    //

    FileHandle = CreateFileA(
                        Filename,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return CHECKSUM_OPEN_FAILURE;
    }

    //
    //  Create a file mapping, map a view of the file into memory,
    //  and close the file mapping handle.
    //

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL);

    if (!MappingHandle) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAP_FAILURE;
    }

    //
    // Map a view of the file
    //

    BaseAddress = MapViewOfFile(MappingHandle, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(MappingHandle);
    if (BaseAddress == NULL) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAPVIEW_FAILURE;
    }

    //
    // Get the length of the file in bytes and compute the checksum.
    //
    FileLength = GetFileSize( FileHandle, NULL );
    CheckSumMappedFile(BaseAddress, FileLength, HeaderSum, CheckSum);

    //
    // Unmap the view of the file and close file handle.
    //

    UnmapViewOfFile(BaseAddress);
    CloseHandle( FileHandle );
    return CHECKSUM_SUCCESS;

#endif   // UNICODE_RULES
}


BOOL
TouchFileTimes(
    HANDLE FileHandle,
    LPSYSTEMTIME lpSystemTime
    )
{
    SYSTEMTIME SystemTime;
    FILETIME SystemFileTime;

    if (lpSystemTime == NULL) {
        lpSystemTime = &SystemTime;
        GetSystemTime( lpSystemTime );
        }

    if (SystemTimeToFileTime( lpSystemTime, &SystemFileTime )) {
        return SetFileTime( FileHandle, NULL, NULL, &SystemFileTime );
        }
    else {
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\ext.h ===
/**************************************************************************88
   ext.h
   dbghelp extensions include file

******************************************************************************/
    
// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <private.h>
#include <symbols.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PAGE_ALIGN64(Va) ((ULONG64)((Va) & ~((ULONG64) (PAGE_SIZE - 1))))

#include <ntverp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\ext.c ===
#include "ext.h"
#include "globals.h"

#include <cmnutil.hpp>

// globals

EXT_API_VERSION         ExtApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

typedef struct {
    DWORD64 base;
    DWORD64 end;
    char    name[64];
} LMINFO, *PLMINFO;

typedef struct {
    CHAR    name[4098];
    DWORD64 addr;
    CHAR    image[4098];
    DWORD   machine;
    USHORT  HdrType;
    ULONG   DebugType;
    ULONG64 DebugDataVA;
    ULONG   nDebugDirs;
    ULONG   SymType;
    time_t  TimeDateStamp;
    ULONG   CheckSum;
    ULONG   SizeOfImage;
    ULONG   Characteristics;
    ULONG   SymLoadError;
    BOOL    omap;
    CHAR    PdbFileName[MAX_PATH + 1];
    ULONG   PdbSrc;
    CHAR    ImageFileName[MAX_PATH + 1];
    ULONG   ImageType;
    ULONG   ImageSrc;
    ULONG   numsyms;
    CVDD    cvrec;
} MODULE_INFO, *PMODULE_INFO, *PMODULE_INFOx;

typedef struct _MACHINE_TYPE {
    ULONG   MachineId;
    PCHAR   MachineName;
} MACHINE_TYPE;

typedef struct _ERROR_TYPE {
    ULONG ErrorVal;
    PCHAR Desc;
} ERROR_TYPE;

const ERROR_TYPE SymLoadErrorDesc[] = {
    {SYMLOAD_OK,              "Symbols loaded successfully"},
    {SYMLOAD_PDBUNMATCHED,    "Unmatched PDB"},
    {SYMLOAD_PDBNOTFOUND,     "PDB not found"},
    {SYMLOAD_DBGNOTFOUND,     "DBG not found"},
    {SYMLOAD_OTHERERROR,      "Error in load symbols"},
    {SYMLOAD_OUTOFMEMORY,     "DBGHELP Out of memory"},
    {SYMLOAD_HEADERPAGEDOUT,  "Image header paged out"},
    {(EC_FORMAT << 8),        "Unrecognized pdb format"},
    {(EC_CORRUPT << 8),       "Cvinfo is corrupt"},
    {(EC_ACCESS_DENIED << 8), "Pdb read access denied"},
    {SYMLOAD_DEFERRED,        "No error - symbol load deferred"},
};


MACHINE_TYPE Machines[] = {
{IMAGE_FILE_MACHINE_UNKNOWN,            "UNKNOWN"},
{IMAGE_FILE_MACHINE_I386,               "I386"},
{IMAGE_FILE_MACHINE_R3000,              "R3000"},
{IMAGE_FILE_MACHINE_R4000,              "R4000"},
{IMAGE_FILE_MACHINE_R10000,             "R10000"},
{IMAGE_FILE_MACHINE_WCEMIPSV2,          "WCEMIPSV2"},
{IMAGE_FILE_MACHINE_ALPHA,              "ALPHA"},
{IMAGE_FILE_MACHINE_POWERPC,            "POWERPC"},
{IMAGE_FILE_MACHINE_POWERPCFP,          "POWERPCFP"},
{IMAGE_FILE_MACHINE_SH3,                "SH3"},
{IMAGE_FILE_MACHINE_SH3DSP,             "SH3DSP"},
{IMAGE_FILE_MACHINE_SH3E,               "SH3E"},
{IMAGE_FILE_MACHINE_SH4,                "SH4"},
{IMAGE_FILE_MACHINE_SH5,                "SH5"},
{IMAGE_FILE_MACHINE_ARM,                "ARM"},
{IMAGE_FILE_MACHINE_AM33,               "AM33"},
{IMAGE_FILE_MACHINE_THUMB,              "THUMB"},
{IMAGE_FILE_MACHINE_IA64,               "IA64"},
{IMAGE_FILE_MACHINE_MIPS16,             "MIPS16"},
{IMAGE_FILE_MACHINE_MIPSFPU,            "MIPSFPU"},
{IMAGE_FILE_MACHINE_MIPSFPU16,          "MIPSFPU16"},
{IMAGE_FILE_MACHINE_ALPHA64,            "ALPHA64"},
{IMAGE_FILE_MACHINE_TRICORE,            "TRICORE"},
{IMAGE_FILE_MACHINE_CEF,                "CEF"},
{IMAGE_FILE_MACHINE_CEE,                "CEE"},
{IMAGE_FILE_MACHINE_AMD64,              "AMD X86-64"},
};

char *ImageDebugType[] = {
 "UNKNOWN",
 "COFF",
 "CODEVIEW",
 "FPO",
 "MISC",
 "EXCEPTION",
 "FIXUP",
 "OMAP TO SRC",
 "OMAP FROM SRC"
 "BORLAND",
 "RESERVED10",
 "CLSID",
};

char *gSymTypeLabel[NumSymTypes] = {
    "NONE", "COFF", "CV", "PDB", "EXPORT", "DEFERRED", "SYM16", "DIA PDB", "VIRTUAL"
};

char *gSrcLabel[] = {       
    "",                   // srcNone
    "symbol search path", // srcSearchPath
    "image path",         // srcImagePath
    "dbg file path",      // srcDbgPath
    "symbol server",      // srcSymSrv
    "image header",       // srcCVRec
    "debugger",           // srcHandle
    "loaded memory"       // srcMemory
};

char *gImageTypeLabel[] = {
    "DEFERRED", // dsNone,
    "MEMORY",   // dsInProc,
    "FILE",     // dsImage,
    "DBG",      // dsDbg,
    "PDB"       // dsPdb
};

void TruncateArgs(LPSTR args);
void lmiDumpModuleInfo(HANDLE hp,PMODULE_INFO mdi);
BOOL lmiGetModuleDumpInfo(HANDLE hp, PMODULE_ENTRY me, PMODULE_INFO mdi);

#ifdef __cplusplus
extern "C" {
#endif

typedef enum DFT
{
   dftUnknown,
   dftObject,
   dftPE,
   dftROM,
   dftDBG,
   dftPEF,
} DFT;

IMAGE_NT_HEADERS64 ImageNtHeaders;
PIMAGE_FILE_HEADER ImageFileHdr;
PIMAGE_OPTIONAL_HEADER64 ImageOptionalHdr;
PIMAGE_SECTION_HEADER SectionHdrs;
ULONG NumSections;
ULONG64 Base;
ULONG64 ImageNtHeadersAddr, SectionHdrsAddr;// , ImageFileHdrAddr, ImageOptionalHdrAddr,
DFT dft;

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG FilePointer,
    OUT PULONG VirtualAddress
    );


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ExtApiVersion;
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
}

#ifdef __cplusplus
}
#endif  


BOOL
ReadFilePtr(
    LPCSTR path,
    LPSTR contents
    )
{
    BOOL   rc;
    HANDLE hptr;
    DWORD  fsize;
    DWORD  cb;
    LPSTR  p;
    char   ptrfile[MAX_PATH + 1];
    char   file[MAX_PATH + 1];

    rc = false;

    if (!path || !*path)
        return rc;

    // check for existance of file pointer

    if (!CopyString(ptrfile, path, _MAX_PATH))
        return false;

    if (!fileexists(ptrfile))
        return false;

    hptr = CreateFile(ptrfile,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

    if (hptr == INVALID_HANDLE_VALUE)
        return false;

    // test validity of file pointer

    fsize = GetFileSize(hptr, NULL);
    if (!fsize || fsize > MAX_PATH)
        goto cleanup;

    // read it

    ZeroMemory(file, _MAX_PATH * sizeof(path[0]));
    if (!ReadFile(hptr, file, fsize, &cb, 0))
        goto cleanup;

    if (cb != fsize)
        goto cleanup;

    rc = true;

    // trim string down to the CR

    for (p = file; *p; p++) {
        if (*p == 10  || *p == 13)
        {
            *p = 0;
            break;
        }
    }
    CopyString(contents, file, MAX_PATH + 1);

cleanup:

    // done

    if (hptr)
        CloseHandle(hptr);

    return rc;
}


DECLARE_API(fptr)
{
    char contents[MAX_PATH + 1] = "";

    ReadFilePtr(args, contents);
    if (*contents)
        dprintf("%s\n", contents);
}


DECLARE_API(vc7fpo)
{
    g_vc7fpo = !g_vc7fpo;
    dprintf((g_vc7fpo) ? "VC7FPO - Enabled\n" : "VC7FPO - Disabled\n");
}

DECLARE_API(stackdbg)
{
    if (*args && *args != ';') {
        for (;;) {
            while (*args == ' ' || *args == '\t') {
                args++;
            }

            if (*args == '-' || *args == '/') {
                switch(*(args + 1)) {
                case 'c':
                    g_StackDebugIo = SDB_CALLBACK_OUT;
                    break;
                case 'd':
                    g_StackDebugIo = SDB_DEBUG_OUT;
                    break;
                default:
                    // Assume it's the beginning of an expression.
                    goto Expr;
                }

                args += 2;
            } else {
                break;
            }
        }

    Expr:
        g_StackDebugMask = (ULONG)GetExpression(args);
    }

    if (g_StackDebugMask == 0) {
        dprintf("Stack debugging is off\n");
    } else {
        dprintf("Stack debugging mask is 0x%08x, output via %s\n",
                g_StackDebugMask, g_StackDebugIo == SDB_DEBUG_OUT ?
                "debug output" : "callback");
    }
}


DECLARE_API(sym)
{
    if (strstr(args, "noisy")) {
        SymSetOptions(g.SymOptions | SYMOPT_DEBUG);
        symsrvSetCallback(true);
    } else if (strstr(args, "quiet")) {
        SymSetOptions(g.SymOptions & ~SYMOPT_DEBUG);
        if (!g.hLog)
            symsrvSetCallback(false);
    } else if (strstr(args, "prompts off")) {
        if (!option(SYMOPT_NO_PROMPTS)) {
            SymSetOptions(g.SymOptions | SYMOPT_NO_PROMPTS);
            symsrvSetPrompts();
        }
    } else if (strstr(args, "prompts")) {
        if (option(SYMOPT_NO_PROMPTS)) {
            SymSetOptions(g.SymOptions & ~SYMOPT_NO_PROMPTS);
            symsrvClose();
        }
    } else {
        dprintf("!sym <noisy/quiet - prompts/prompts off> - ");
    }

    dprintf(option(SYMOPT_DEBUG) ? "noisy mode" : "quiet mode");
    dprintf(option(SYMOPT_NO_PROMPTS) ? " - symbol prompts off\n" : " - symbol prompts on\n");
}


DECLARE_API(symsrv)
{
    if (strstr(args, "close")) {
        symsrvClose();
        dprintf("symbol server client has been closed\n");
    } else 
        dprintf("!symsrv close - closes the symbol server client so it can be updated\n");
}


int __cdecl
CompareBase(
    const void *e1,
    const void *e2
    )
{
    PLMINFO mod1 = (PLMINFO)e1;
    PLMINFO mod2 = (PLMINFO)e2;

    LONGLONG diff = mod1->base - mod2->base;

    if (diff < 0) 
        return -1;
    else if (diff > 0) 
        return 1;
    else 
        return 0;
}


#define MAX_FORMAT_STRINGS 8
LPSTR
FormatAddr64(
    ULONG64 addr,
    BOOL    format64
    )
{
    static CHAR strings[MAX_FORMAT_STRINGS][18];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS) 
        next = 0;
    if (format64) 
        PrintString(string, 18, "%08x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    else 
        PrintString(string, 18, "%08x", (ULONG)addr);
    return string;
}


int __cdecl
CompareNames(
    const void *e1,
    const void *e2
    )
{
    PLMINFO mod1 = (PLMINFO)e1;
    PLMINFO mod2 = (PLMINFO)e2;

    return strcmp( mod1->name, mod2->name );
}


DECLARE_API(lm)
{
    PPROCESS_ENTRY pe;
    HANDLE         hp;
    PLIST_ENTRY    next;
    PMODULE_ENTRY  mi;
    PLMINFO        mods;
    PLMINFO        mod;
    DWORD          count;
    BOOL           format64;

    GetCurrentProcessHandle (&hp);
    if (!hp) {
        dprintf("Couldn't get process handle\n");
        return;
    }

    pe = FindProcessEntry(hp);
    if (!pe) {
        dprintf("Couldn't find process 0x%x\n", hp);
        SetLastError(ERROR_INVALID_HANDLE);
        return;
    }

    next = pe->ModuleList.Flink;
    if (!next)
        return;

    for (count = 0; (PVOID)next != (PVOID)&pe->ModuleList; count++) {
        mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
        next = mi->ListEntry.Flink;
    }

    mods = (PLMINFO)MemAlloc(count * sizeof(LMINFO));
    if (!mods)
        return;

    ZeroMemory(mods, count * sizeof(LMINFO));

    format64 = false;
    next = pe->ModuleList.Flink;
    for (mod = mods; (PVOID)next != (PVOID)&pe->ModuleList; mod++) {
        mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
        mod->base = mi->BaseOfDll;
        mod->end  = mod->base + mi->DllSize;
        CopyStrArray(mod->name, mi->ModuleName);

        format64 = IsImageMachineType64(mi->MachineType);

        next = mi->ListEntry.Flink;
    }

    qsort(mods, count, sizeof(LMINFO), CompareBase);
    
    dprintf("%d loaded modules...\n", count);
    if (format64)
        dprintf("               base -                 end   name\n", mod->base, mod->end, mod->name);
    else
        dprintf("      base -        end   name\n", mod->base, mod->end, mod->name);
    
    for (mod = mods; count > 0; mod++, count--) {
        dprintf("0x%s - ", FormatAddr64(mod->base, format64));
        dprintf("0x%s   ", FormatAddr64(mod->end, format64));
        dprintf("%s\n", mod->name);
    }

    MemFree(mods);
}


DECLARE_API(lmi)
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY mi = NULL;
    MODULE_INFO mdi;
    DWORD64 addr;
    HANDLE hp = 0;
    char argstr[1024];
    char *pc;

    if (!args[0] || !CopyStrArray(argstr, args)) {
        dprintf("You must specify a module\n");
        return;
    }

    _strlwr(argstr);
    TruncateArgs(argstr);

    dprintf("Loaded Module Info: [%s] ", argstr);

    GetCurrentProcessHandle(&hp);
    if (!hp) {
        dprintf("couldn't get process handle\n");
        return;
    }

    pe = FindProcessEntry(hp);
    if (!pe) {
        dprintf("Couldn't find process 0x%x while looking for %s\n", hp, argstr);
        SetLastError(ERROR_INVALID_HANDLE);
        return;
    }

    dprintf("\n");

    if (mi = FindModule(hp, pe, argstr, false)) {
        if (lmiGetModuleDumpInfo(hp, mi, &mdi)) {
            lmiDumpModuleInfo(hp, &mdi);
        } else {
//          dprintf("Cannot get module info for %s\n", argstr);
        }
        if (SectionHdrs) {
            free(SectionHdrs);
            SectionHdrs = NULL;
        }
        dprintf("    Load Report: %s\n", SymbolStatus(mi, 17));
        return;
    }

    GetExpressionEx(args, &addr, NULL);
    if (!addr) {
        dprintf("%s not found\n", argstr);
        SetLastError(ERROR_MOD_NOT_FOUND);
        return;
    }

    mi = GetModuleForPC( pe, addr, false );
    if (!mi) {
        dprintf("%I64lx is not a valid address\n", addr);
        return;
    }
    if (lmiGetModuleDumpInfo(hp, mi, &mdi)) {
        lmiDumpModuleInfo(hp, &mdi);
    }
    if (SectionHdrs) {
        free(SectionHdrs);
        SectionHdrs = NULL;
    }
    dprintf("    Load Report: %s\n", SymbolStatus(mi, 17));
}


DECLARE_API(omap)
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY mi = NULL;
    HANDLE hp = 0;
    char argstr[1024];
    POMAP pomap;
    DWORD i;

    if (!CopyStrArray(argstr, args))
        return;
    _strlwr(argstr);
    TruncateArgs(argstr);

    dprintf("Dump OMAP: [%s] ", argstr);

    GetCurrentProcessHandle (&hp);
    if (!hp) {
        dprintf("couldn't get process handle\n");
        return;
    }

    pe = FindProcessEntry(hp);
    if (!pe) {
        dprintf("Couldn't find process 0x%x while looking for %s\n", hp, argstr);
        SetLastError(ERROR_INVALID_HANDLE);
        return;
    }

    dprintf("\n");

    mi = FindModule(hp, pe, argstr, false);
    if (!mi)
        return;

    i = sizeof(DWORD);

    if (!mi->pOmapFrom) 
        return;

    dprintf("\nOMAP FROM:\n");
    for(i = 0, pomap = mi->pOmapFrom;
        i < 100; // mi->cOmapFrom;
        i++, pomap++)
    {
        dprintf("%8x <-%8x\n", pomap->rva, pomap->rvaTo);
    }
    
    if (!mi->pOmapTo) 
        return;

    dprintf("\nOMAP TO:\n");
    for(i = 0, pomap = mi->pOmapTo;
        i < 100; // mi->cOmapTo;
        i++, pomap++)
    {
        dprintf("%8x ->%8x\n", pomap->rva, pomap->rvaTo);
    }
}


BOOL
cbSrcFiles(
    PSOURCEFILE pSourceFile,
    PVOID       UserContext
    )
{
    PMODULE_ENTRY mi;
    PCHAR mname;

    if (!pSourceFile)
        return false;

    mi = GetModFromAddr((PPROCESS_ENTRY)UserContext, pSourceFile->ModBase);
    if (!mi)
        return true;

    dprintf(" %s!%s\n", (*mi->AliasName) ? mi->AliasName : mi->ModuleName, pSourceFile->FileName);

    return true;
}


DECLARE_API(srcfiles)
{
    HANDLE hp = 0;
    char argstr[1024];
    BOOL rc;
    PPROCESS_ENTRY pe;

    if (!CopyStrArray(argstr, args))
        return;
    _strlwr(argstr);
    TruncateArgs(argstr);

    dprintf("Source Files: [%s]\n", argstr);

    GetCurrentProcessHandle (&hp);
    if (!hp) {
        dprintf("couldn't get process handle\n");
        return;
    }

    pe = FindProcessEntry(hp);
    if (!pe) {
        dprintf("Couldn't find process 0x%x while looking for %s\n", hp, argstr);
        SetLastError(ERROR_INVALID_HANDLE);
        return;
    }

    rc = SymEnumSourceFiles(hp, 0, argstr, cbSrcFiles, pe);
}

VOID
DumpSecHdr (
    IN DWORD i,
    IN PIMAGE_SECTION_HEADER Sh
    )
{
    dprintf("                 %2d %s\n", i, Sh->Name);
}

VOID
DumpSecs(
    BOOL fFullDump
    )
{
    IMAGE_SECTION_HEADER sh;
    const char *p;
    DWORD li;
    DWORD cb;
    BOOL Ok;
    int i, j;
    CHAR szName[IMAGE_SIZEOF_SHORT_NAME + 1];

    if (ImageFileHdr->NumberOfSections < 1)
        return;

    dprintf("       Sections:  # Name\n");

    for (i = 1; i <= ImageFileHdr->NumberOfSections; i++) {
        sh = SectionHdrs[i-1];
        CopyStrArray(szName, (char *) sh.Name);
        DumpSecHdr(i, &sh);
    }
}

BOOL
lmiGetModuleDumpInfo(
    HANDLE hp,
    PMODULE_ENTRY me,
    PMODULE_INFOx mdi)
{
    BOOL                        rc;
    DWORD                       cb;
    ULONG                       nDebugDirs;
    ULONG64                     ddva;
    IMAGE_SEPARATE_DEBUG_HEADER sdh;
    IMAGE_DOS_HEADER            DosHeader;
    IMAGE_NT_HEADERS32          NtHeader32;
    IMAGE_NT_HEADERS64          NtHeader64;
    PIMAGE_FILE_HEADER          FileHeader;
    PIMAGE_ROM_OPTIONAL_HEADER  rom;
    PIMAGE_DATA_DIRECTORY       datadir;
    DWORD64                     offset;
    BOOL                        b64;

    ZeroMemory(mdi, sizeof(MODULE_INFO));

    CopyStrArray(mdi->name, me->ModuleName);
    mdi->addr = me->BaseOfDll;
    CopyString(mdi->image, me->ImageName, DIMA(mdi->image));

    if (!mdi->addr) {
        dprintf("Module does not have base address\n");
        return false;
    }

    mdi->SymType = me->SymType;
    mdi->SymLoadError = me->SymLoadError;
    if (me->SymType == SymVirtual)
        return true;
    if (me->SymType == SymDeferred) {
        mdi->SymLoadError = SYMLOAD_DEFERRED;
    }
    rc = ReadMemory(mdi->addr, &DosHeader, sizeof(DosHeader), &cb);
    if (!rc || cb != sizeof(DosHeader)) {
        dprintf("Cannot read Image header @ %p\n", mdi->addr);
        return false;
    }

    mdi->HdrType = DosHeader.e_magic;

    mdi->omap = me->cOmapFrom ? true : false;

    mdi->PdbSrc = me->PdbSrc;
    if (me->LoadedPdbName)
        CopyStrArray(mdi->PdbFileName, me->LoadedPdbName);
    mdi->ImageSrc = me->ImageSrc;
    if (me->LoadedImageName)
        CopyStrArray(mdi->ImageFileName, me->LoadedImageName);
    mdi->ImageType = me->ImageType;

    if (DosHeader.e_magic == IMAGE_DOS_SIGNATURE) {
        rc = ReadMemory(mdi->addr + DosHeader.e_lfanew, &NtHeader32, sizeof(NtHeader32), &cb);
        if (!rc || cb != sizeof(NtHeader32)) {
            dprintf("Cannot read Image NT header @ %p\n", mdi->addr + DosHeader.e_lfanew);
            return false;
        }

        mdi->machine       = NtHeader32.FileHeader.Machine;
        mdi->TimeDateStamp = NtHeader32.FileHeader.TimeDateStamp;
        if (NtHeader32.Signature != IMAGE_NT_SIGNATURE) {

            // if header is not NT sig, this is a ROM image

            rom = (PIMAGE_ROM_OPTIONAL_HEADER)&NtHeader32.OptionalHeader;
            if (rom->Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
                ImageFileHdr = &NtHeader32.FileHeader;

                mdi->SizeOfImage = rom->SizeOfCode;
                mdi->CheckSum = 0;

                nDebugDirs = 0;
                if (!(ImageFileHdr->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {
                    // Get the debug dir VA
                }
            } else {
                dprintf("Unknown NT Image signature\n");
                return false;
            }

        } else {

            // otherwise, get info from appropriate header type for 32 or 64 bit
            if (IsImageMachineType64(NtHeader32.FileHeader.Machine)) {

                // Reread the header as a 64bit header.
                rc = ReadMemory(mdi->addr + DosHeader.e_lfanew, &NtHeader64, sizeof(NtHeader64), &cb);
                if (!rc || cb != sizeof(NtHeader64)) {
                    dprintf("Cannot read Image NT header @ %p\n", mdi->addr + DosHeader.e_lfanew);
                    return false;
                }

                ImageFileHdr = &NtHeader64.FileHeader;
                mdi->CheckSum = NtHeader64.OptionalHeader.CheckSum;
                mdi->SizeOfImage = NtHeader64.OptionalHeader.SizeOfImage;
                datadir = NtHeader64.OptionalHeader.DataDirectory;

            } else {
                ImageFileHdr = &NtHeader32.FileHeader;
                datadir = NtHeader32.OptionalHeader.DataDirectory;
                mdi->SizeOfImage = NtHeader32.OptionalHeader.SizeOfImage;
                mdi->CheckSum = NtHeader32.OptionalHeader.CheckSum;
            }

            mdi->DebugDataVA = mdi->addr + datadir[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
            mdi->nDebugDirs = datadir[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
        }

        // read the section headers

        mdi->Characteristics = ImageFileHdr->Characteristics;

        SectionHdrs = (PIMAGE_SECTION_HEADER) malloc((NumSections = ImageFileHdr->NumberOfSections)* 
                                             sizeof(IMAGE_SECTION_HEADER));

        if (!SectionHdrs) {
            dprintf("Cannot allocate memory for reading sections\n");
            return false;
        }

        offset = mdi->addr + DosHeader.e_lfanew;
        b64 = IsImageMachineType64(ImageFileHdr->Machine);
        SectionHdrsAddr = offset + (b64 ? sizeof(IMAGE_NT_HEADERS64) : sizeof(IMAGE_NT_HEADERS32)) +
            ImageFileHdr->SizeOfOptionalHeader - (b64 ? sizeof(IMAGE_OPTIONAL_HEADER64) : sizeof(IMAGE_OPTIONAL_HEADER32));
        rc = ReadMemory(SectionHdrsAddr,
                        SectionHdrs,
                        (NumSections) * sizeof(IMAGE_SECTION_HEADER),
                        &cb);

        if (!rc) {
            dprintf("Can't read section headers\n");
        } else {

            if (cb != NumSections * sizeof(IMAGE_SECTION_HEADER)) {
                dprintf("\n***\n*** Some section headers may be missing ***\n***\n\n");
                NumSections = (USHORT)(cb / sizeof(IMAGE_SECTION_HEADER));
            }
#if 0
           DumpSecs(false);
#endif
        }

    } else if (DosHeader.e_magic == IMAGE_SEPARATE_DEBUG_SIGNATURE) {
        rc = ReadMemory(mdi->addr, &sdh, sizeof(sdh), &cb);
        if (!rc || cb != sizeof(sdh)) {
            dprintf("Cannot read Image Debug header @ %p\n", mdi->addr);
            return false;
        }
        mdi->machine         = sdh.Machine;
        mdi->TimeDateStamp   = sdh.TimeDateStamp;
        mdi->CheckSum        = sdh.CheckSum;
        mdi->SizeOfImage     = sdh.SizeOfImage;
        mdi->Characteristics = sdh.Characteristics;

        if (sdh.DebugDirectorySize) {
            mdi->nDebugDirs = (int)(sdh.DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY));
            mdi->DebugDataVA = sizeof(IMAGE_SEPARATE_DEBUG_HEADER)
                      + (sdh.NumberOfSections * sizeof(IMAGE_SECTION_HEADER))
                      + sdh.ExportedNamesSize;
        }
    } else {
        dprintf("Unknown image\n");
        return false;
    }

    mdi->numsyms = me->numsyms;
    memcpy(&mdi->cvrec, &me->CVRec, min(sizeof(mdi->cvrec), sizeof(me->CVRec)));

    return true;
}

BOOL
DumpDbgDirectories(
    HANDLE hp,
    PMODULE_INFOx mdi
    )
{
    ULONG                       rc, cb;
    IMAGE_DEBUG_DIRECTORY       dd;
    IMAGE_DEBUG_MISC            md;
    ULONG64                     ddva;
    ULONG                       nDebugDirs;
    PCVDD                       pcv;
    ULONG64 cvAddr;
    ULONG   cvSize;
    PCHAR   pCV;
    CHAR    ImgData[MAX_PATH];
    IMAGE_COFF_SYMBOLS_HEADER CoffHdr;
    ULONG va;

    nDebugDirs = mdi->nDebugDirs;
    ddva = mdi->DebugDataVA;

    dprintf("Debug Data Dirs: Type  Size     VA  Pointer\n");
    for (;nDebugDirs; dprintf("\n"), nDebugDirs--) {

        rc = ReadMemory(ddva, &dd, sizeof(dd), &cb);
        if (!rc || cb != sizeof(dd))
            return false;
        if (dd.Type) {
            dprintf("%21s ", // dd.Type,
                    (dd.Type < sizeof (ImageDebugType) / sizeof(char *)) ? ImageDebugType[dd.Type] : "??");

            dprintf(
                "%5lx, %5lx, %7lx ",
                dd.SizeOfData,
                dd.AddressOfRawData,
                dd.PointerToRawData);

            if (!TranslateFilePointerToVirtualAddress(dd.PointerToRawData, &va)) {
                dprintf(" [Debug data not mapped]");
                if (dd.Type == IMAGE_DEBUG_TYPE_CODEVIEW)
                    dprintf(" - Can't validate symbols, if present.");
                goto nextDebugDir;
            }
            
            switch(dd.Type)
            {
            case IMAGE_DEBUG_TYPE_MISC:
                if (!dd.PointerToRawData) {
                    dprintf("[Data not mapped]");
                    break;
                }
                rc = ReadMemory(mdi->addr + dd.PointerToRawData, &md, sizeof(md), &cb);
                if (!rc || cb != sizeof(md) || md.DataType != IMAGE_DEBUG_MISC_EXENAME) {
                    dprintf("[Data not mapped]");
                    goto nextDebugDir;
                }

                rc = ReadMemory(mdi->addr + dd.PointerToRawData + FIELD_OFFSET(IMAGE_DEBUG_MISC, Data),
                                ImgData, MAX_PATH, &cb);

                if (rc && cb)
                    dprintf(" %s", ImgData);
                break;

            case IMAGE_DEBUG_TYPE_CODEVIEW:
                if (dd.AddressOfRawData) {
                    cvAddr = mdi->addr + dd.AddressOfRawData;
                } else if (dd.PointerToRawData) {
                    cvAddr = mdi->addr + dd.PointerToRawData;
                } else {
                    break;
                }
                cvSize = dd.SizeOfData;

                if (!(pCV = (PCHAR)MemAlloc(dd.SizeOfData + 1)))
                    break;

                pcv = (PCVDD)pCV;

                rc = ReadMemory(cvAddr,pCV, cvSize, &cb);

                if (rc && cb == cvSize) {
                    char *c = (char *)&pcv->dwSig;
                    dprintf("%c%c%c%c - ", *c, *(c + 1), *(c + 2), *(c + 3));
                } else {
                    pcv->dwSig = 0;
                }

                switch (pcv->dwSig) 
                {
                case 0:
                    dprintf("[Debug data not mapped] - can't validate symbols, if present.");
                    break;
                case '01BN':
                    pCV[cvSize] = 0;
                    dprintf("Sig: %lx, Age: %lx,%sPdb: %s",
                            pcv->nb10i.sig,
                            pcv->nb10i.age,
                            (strlen(pCV) > 14 ? "\n               " : " "),
                            pcv->nb10i.szPdb);
                    break;
                case 'SDSR':
                pCV[cvSize] = 0;
                    dprintf("GUID: (0x%8x, 0x%4x, 0x%4x, 0x%2x, 0x%2x, 0x%2x, 0x%2x, 0x%2x, 0x%2x, 0x%2x, 0x%2x)\n",
                            pcv->rsdsi.guidSig.Data1,
                            pcv->rsdsi.guidSig.Data2,
                            pcv->rsdsi.guidSig.Data3,
                            pcv->rsdsi.guidSig.Data4[0],
                            pcv->rsdsi.guidSig.Data4[1],
                            pcv->rsdsi.guidSig.Data4[2],
                            pcv->rsdsi.guidSig.Data4[3],
                            pcv->rsdsi.guidSig.Data4[4],
                            pcv->rsdsi.guidSig.Data4[5],
                            pcv->rsdsi.guidSig.Data4[6],
                            pcv->rsdsi.guidSig.Data4[7]);
                    dprintf("               Age: %lx, Pdb: %s",
                            pcv->rsdsi.age,
                            pcv->rsdsi.szPdb);
                    break;   
                case '80BN':
                case '90BN':
                case '11BN':
                    break;
                default:
                    dprintf("unrecognized symbol format ID");
                    break;
                }

                MemFree(pCV);
                break;

            case IMAGE_DEBUG_TYPE_COFF:
                if (!dd.PointerToRawData) {
                    dprintf("[Data paged out] - unable to load COFF info.");
                    break;
                }
                rc = ReadMemory(mdi->addr + dd.PointerToRawData, &CoffHdr, sizeof(CoffHdr), &cb);
                if (!rc || cb != sizeof(CoffHdr)) {
                    dprintf("[Data paged out] - unable to load COFF info.");
                    break;
                }
                dprintf("NumSyms %#lx, Numlines %#lx",
                        mdi->numsyms, // CoffHdr.NumberOfSymbols,
                        CoffHdr.NumberOfLinenumbers);
                break;

            case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                dprintf("BBT Optimized");
                break;

            default:
                dprintf("[Data not mapped]");
                break;

            }
        }
nextDebugDir:
        ddva += sizeof (dd);
    }

    return true;
}

void lmiDumpModuleInfo(
    HANDLE hp,
    PMODULE_INFO mdi
    )
{
    ULONG i;
    const char *time;

    dprintf("         Module: %s\n", mdi->name);
    dprintf("   Base Address: %p%s", mdi->addr, mdi->addr ? "\n" : " is INVALID\n");
    dprintf("     Image Name: %s\n", mdi->image);
    if (mdi->SymType == SymVirtual)
        goto symboltype;
    dprintf("   Machine Type: %d",   mdi->machine);
    for (i=0;i<sizeof(Machines)/sizeof(MACHINE_TYPE);i++) {
        if (mdi->machine == Machines[i].MachineId) {
            dprintf(" (%s)", Machines[i].MachineName);
            break;
        }
    }

    dprintf("\n     Time Stamp: %lx", mdi->TimeDateStamp);
    if ((time = ctime((time_t *) &mdi->TimeDateStamp)) != NULL) {
        dprintf( " %s", time);
    } else
        dprintf("\n");

    dprintf("           Size: %x\n", mdi->SizeOfImage);

    dprintf("       CheckSum: %lx\n", mdi->CheckSum);
    dprintf("Characteristics: %lx %s %s\n",
            mdi->Characteristics,
            ((mdi->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) ? "stripped":""),
            (mdi->omap ? "perf" : "")
            );
    if (mdi->nDebugDirs) {
        DumpDbgDirectories(hp, mdi);
    } else {
        dprintf("Debug Directories not present\n");
    }

    switch (mdi->ImageType)
    {
    case dsInProc:
    case dsImage:
        if (mdi->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
            break;
    case dsDbg:
    case dsPdb:
        dprintf("     Image Type: %-9s", gImageTypeLabel[mdi->ImageType]);
        dprintf("- Image read successfully from %s.", gSrcLabel[mdi->ImageSrc]);
        if (mdi->ImageSrc != srcNone && mdi->ImageSrc != srcMemory)
            dprintf("\n                 %s", mdi->ImageFileName);   
        dprintf("\n");
        break;
    case dsNone:
    default:
        break;
    }

symboltype:
    dprintf("    Symbol Type: %-9s", gSymTypeLabel[mdi->SymType]);
    for (i=0;i< sizeof(SymLoadErrorDesc) / sizeof (ERROR_TYPE); i++) {
        if (mdi->SymLoadError == SymLoadErrorDesc[i].ErrorVal) {
            dprintf("- %s", SymLoadErrorDesc[i].Desc);
            break;
        }
    }
    if (mdi->PdbSrc != srcNone) {
        dprintf(" from %s.", gSrcLabel[mdi->PdbSrc]);
        if (*mdi->PdbFileName)
            dprintf("\n                 %s", mdi->PdbFileName);
        dprintf("\n");
    } else {
        dprintf("\n");
    }
}

void TruncateArgs(
    LPSTR sz
    )
{
    PSTR p;

    for (p = sz; !isspace(*p); p++) {
        if (!*p)
            break;
    }
    *p = 0;
}

// STYP_ flags values for MIPS ROM images

#define STYP_REG      0x00000000
#define STYP_TEXT     0x00000020
#define STYP_INIT     0x80000000
#define STYP_RDATA    0x00000100
#define STYP_DATA     0x00000040
#define STYP_LIT8     0x08000000
#define STYP_LIT4     0x10000000
#define STYP_SDATA    0x00000200
#define STYP_SBSS     0x00000080
#define STYP_BSS      0x00000400
#define STYP_LIB      0x40000000
#define STYP_UCODE    0x00000800
#define S_NRELOC_OVFL 0x20000000

#define IMAGE_SCN_MEM_SYSHEAP       0x00010000  // Obsolete
#define IMAGE_SCN_MEM_PROTECTED     0x00004000  // Obsolete


const static char * const MachineName[] = {
    "Unknown",
    "i386",
    "Alpha AXP",
    "Alpha AXP64",
    "Intel IA64",
    "AMD X86-64",
    "ARM 32-bit",
};

const static char * const SubsystemName[] = {
    "Unknown",
    "Native",
    "Windows GUI",
    "Windows CUI",
    "Posix CUI",
};

const static char * const DirectoryEntryName[] = {
    "Export",
    "Import",
    "Resource",
    "Exception",
    "Security",
    "Base Relocation",
    "Debug",
    "Description",
    "Special",
    "Thread Storage",
    "Load Configuration",
    "Bound Import",
    "Import Address Table",
    "Reserved",
    "Reserved",
    "Reserved",
    0
};

VOID
dhDumpHeaders (
    VOID
    );


VOID
dhDumpSections(
    VOID
    );


VOID
dhDumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    );

VOID
dhdh(
    IN PSTR lpArgs
    )
{
    BOOL DoAll;
    BOOL DoSections;
    BOOL DoHeaders;
    CHAR c;
    PCHAR p;
    ULONG64 xBase;

    //
    // Evaluate the argument string to get the address of the
    // image to dump.
    //

    DoAll = true;
    DoHeaders = false;
    DoSections = false;

    xBase = 0;

    while (*lpArgs) {

        while (isspace(*lpArgs)) {
            lpArgs++;
        }

        if (*lpArgs == '/' || *lpArgs == '-') {

            // process switch

            switch (*++lpArgs) {

                case 'a':   // dump everything we can
                case 'A':
                    ++lpArgs;
                    DoAll = true;
                    break;

                default: // invalid switch

                case 'h':   // help
                case 'H':
                case '?':

                    dprintf("Usage: dh [options] address\n");
                    dprintf("\n");
                    dprintf("Dumps headers from an image based at address\n");
                    dprintf("\n");
                    dprintf("Options:\n");
                    dprintf("\n");
                    dprintf("   -a      Dump everything\n");
                    dprintf("   -f      Dump file headers\n");
                    dprintf("   -s      Dump section headers\n");
                    dprintf("\n");

                    return;

                case 'f':
                case 'F':
                    ++lpArgs;
                    DoAll = false;
                    DoHeaders = true;
                    break;

                case 's':
                case 'S':
                    ++lpArgs;
                    DoAll = false;
                    DoSections = true;
                    break;

            }

        } else if (*lpArgs) {

            if (xBase != 0) {
                dprintf("Invalid extra argument\n");
                return;
            }

            p = lpArgs;
            while (*p && !isspace(*p)) {
                p++;
            }
            c = *p;
            *p = 0;

            xBase = GetExpression(lpArgs);

            *p = c;
            lpArgs=p;

        }

    }

    if ( !xBase ) {
        return;
    }

    dhDumpImage(xBase, DoAll || DoHeaders, DoAll || DoSections);
}

DECLARE_API(dh)
{
    dhdh( (PSTR)args );
}

BOOL
dhReadNtHeader(
    ULONG64 Address,
    PIMAGE_NT_HEADERS64 pNtHdrs
    )
{
    ULONG cb;
    BOOL  Ok;

    Ok = ReadMemory(Address, pNtHdrs, sizeof(*pNtHdrs), &cb);

    if (IsImageMachineType64(pNtHdrs->FileHeader.Machine))
    {
        Ok = Ok && (cb == sizeof(*pNtHdrs));
    }
    else
    {
        IMAGE_NT_HEADERS32 nthdr32;
        Ok = ReadMemory(Address, &nthdr32, sizeof(nthdr32), &cb);
        Ok = Ok && (cb == sizeof(nthdr32));
        ImageNtHdr32To64(&nthdr32, pNtHdrs);
    }
    return Ok;
}

VOID
dhDumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    )
{
    IMAGE_DOS_HEADER DosHeader;
    ULONG cb;
    ULONG64 Offset;
    BOOL Ok;

    Base = xBase;

    Ok = ReadMemory(Base, &DosHeader, sizeof(DosHeader), &cb);

    if (!Ok) {
        dprintf("Can't read file header: error == %d\n", GetLastError());
        return;
    }

    if (cb != sizeof(DosHeader) || DosHeader.e_magic != IMAGE_DOS_SIGNATURE) {
        dprintf("No file header\n");
        return;
    }

    Offset = Base + DosHeader.e_lfanew;

    if (!dhReadNtHeader(ImageNtHeadersAddr=Offset, &ImageNtHeaders)) {
        dprintf("Bad file header\n");
        return;
    }

    ImageFileHdr = &ImageNtHeaders.FileHeader;
    ImageOptionalHdr = &ImageNtHeaders.OptionalHeader;


    if (ImageFileHdr->SizeOfOptionalHeader == sizeof(IMAGE_ROM_OPTIONAL_HEADER)) {
        dft = dftROM;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_DLL) {
        dft = dftPE;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {
        dft = dftPE;
    } else if (ImageFileHdr->SizeOfOptionalHeader == 0) {
        dft = dftObject;
    } else {
        dft = dftUnknown;
    }

    if (DoHeaders) {
        dhDumpHeaders();
    }

    if (DoSections) {
        SectionHdrs = (PIMAGE_SECTION_HEADER) malloc((NumSections = ImageFileHdr->NumberOfSections)* 
                                                     sizeof(IMAGE_SECTION_HEADER));
        if (!SectionHdrs) {
            dprintf("Cannot allocate memory for dumping sections\n");
            return;
        }
        __try {

            BOOL b64 = IsImageMachineType64(ImageFileHdr->Machine);
            SectionHdrsAddr = Offset + (b64 ? sizeof(IMAGE_NT_HEADERS64) : sizeof(IMAGE_NT_HEADERS32)) +
                ImageFileHdr->SizeOfOptionalHeader - (b64 ? sizeof(IMAGE_OPTIONAL_HEADER64) : sizeof(IMAGE_OPTIONAL_HEADER32));
            Ok = ReadMemory(
                            SectionHdrsAddr,
                            SectionHdrs,
                            (NumSections) * sizeof(IMAGE_SECTION_HEADER),
                            &cb);

            if (!Ok) {
                dprintf("Can't read section headers\n");
            } else {

                if (cb != NumSections * sizeof(IMAGE_SECTION_HEADER)) {
                    dprintf("\n***\n*** Some section headers may be missing ***\n***\n\n");
                    NumSections = (USHORT)(cb / sizeof(IMAGE_SECTION_HEADER));
                }

                dhDumpSections();

            }

        }
        __finally {

            if (SectionHdrs) {
                free(SectionHdrs);
                SectionHdrs = 0;
            }

        }

    }

}


VOID
dhDumpHeaders (
    VOID
    )

/*++

Routine Description:

    Formats the file header and optional header.

Arguments:

    None.

Return Value:

    None.

--*/

{
    int i, j;
    const char *time;
    const char *name;
    DWORD dw;

    // Print out file type

    switch (dft) {
        case dftObject :
            dprintf("\nFile Type: COFF OBJECT\n");
            break;

        case dftPE :
            if (ImageFileHdr->Characteristics & IMAGE_FILE_DLL) {
                dprintf("\nFile Type: DLL\n");
            } else {
                dprintf("\nFile Type: EXECUTABLE IMAGE\n");
            }
            break;

        case dftROM :
            dprintf("\nFile Type: ROM IMAGE\n");
            break;

        default :
            dprintf("\nFile Type: UNKNOWN\n");
            break;

    }

    switch (ImageFileHdr->Machine) {
        case IMAGE_FILE_MACHINE_I386     : i = 1; break;
        case IMAGE_FILE_MACHINE_ALPHA    : i = 2; break;
        case IMAGE_FILE_MACHINE_ALPHA64  : i = 3; break;
        case IMAGE_FILE_MACHINE_IA64     : i = 4; break;
        case IMAGE_FILE_MACHINE_AMD64    : i = 5; break;
        case IMAGE_FILE_MACHINE_ARM      : i = 6; break;
        default : i = 0;
    }

    dprintf(
           "FILE HEADER VALUES\n"
           "%8hX machine (%s)\n"
           "%8hX number of sections\n"
           "%8lX time date stamp",
           ImageFileHdr->Machine,
           MachineName[i],
           ImageFileHdr->NumberOfSections,
           ImageFileHdr->TimeDateStamp);

    if ((time = ctime((time_t *) &ImageFileHdr->TimeDateStamp)) != NULL) {
        dprintf( " %s", time);
    }
    dprintf("\n");

    dprintf(
           "%8lX file pointer to symbol table\n"
           "%8lX number of symbols\n"
           "%8hX size of optional header\n"
           "%8hX characteristics\n",
           ImageFileHdr->PointerToSymbolTable,
           ImageFileHdr->NumberOfSymbols,
           ImageFileHdr->SizeOfOptionalHeader,
           ImageFileHdr->Characteristics);

    for (dw = ImageFileHdr->Characteristics, j = 0; dw; dw >>= 1, j++) {
        if (dw & 1) {
            switch (1 << j) {
                case IMAGE_FILE_RELOCS_STRIPPED     : name = "Relocations stripped"; break;
                case IMAGE_FILE_EXECUTABLE_IMAGE    : name = "Executable"; break;
                case IMAGE_FILE_LINE_NUMS_STRIPPED  : name = "Line numbers stripped"; break;
                case IMAGE_FILE_LOCAL_SYMS_STRIPPED : name = "Symbols stripped"; break;
                case IMAGE_FILE_LARGE_ADDRESS_AWARE : name = "App can handle >2gb addresses"; break;
                case IMAGE_FILE_BYTES_REVERSED_LO   : name = "Bytes reversed"; break;
                case IMAGE_FILE_32BIT_MACHINE       : name = "32 bit word machine"; break;
                case IMAGE_FILE_DEBUG_STRIPPED      : name = "Debug information stripped"; break;
                case IMAGE_FILE_SYSTEM              : name = "System"; break;
                case IMAGE_FILE_DLL                 : name = "DLL"; break;
                case IMAGE_FILE_BYTES_REVERSED_HI   : name = ""; break;
                default : name = "RESERVED - UNKNOWN";
            }

            if (*name) {
                dprintf( "            %s\n", name);
            }
        }
    }

    if (ImageFileHdr->SizeOfOptionalHeader != 0) {
        char szLinkerVersion[30];

        PrintString(szLinkerVersion,
                    DIMA(szLinkerVersion),
                    "%u.%02u",
                    ImageOptionalHdr->MajorLinkerVersion,
                    ImageOptionalHdr->MinorLinkerVersion);

        dprintf(
                "\n"
                "OPTIONAL HEADER VALUES\n"
                "%8hX magic #\n"
                "%8s linker version\n"
                "%8lX size of code\n"
                "%8lX size of initialized data\n"
                "%8lX size of uninitialized data\n"
                "%8lX address of entry point\n"
                "%8lX base of code\n"
                ,
                ImageOptionalHdr->Magic,
                szLinkerVersion,
                ImageOptionalHdr->SizeOfCode,
                ImageOptionalHdr->SizeOfInitializedData,
                ImageOptionalHdr->SizeOfUninitializedData,
                ImageOptionalHdr->AddressOfEntryPoint,
                ImageOptionalHdr->BaseOfCode
                );
//        dprintf("%p base of image\n",
//                ImageOptionalHdr->ImageBase
//                );
    }

    if (dft == dftROM) {
        PIMAGE_ROM_OPTIONAL_HEADER romOptionalHdr;

        romOptionalHdr = (PIMAGE_ROM_OPTIONAL_HEADER) &ImageOptionalHdr;
        dprintf(
               "         ----- rom -----\n"
               "%8lX base of bss\n"
               "%8lX gpr mask\n"
               "         cpr mask\n"
               "         %08lX %08lX %08lX %08lX\n"
               "%8hX gp value\n",
               romOptionalHdr->BaseOfBss,
               romOptionalHdr->GprMask,
               romOptionalHdr->CprMask[0],
               romOptionalHdr->CprMask[1],
               romOptionalHdr->CprMask[2],
               romOptionalHdr->CprMask[3],
               romOptionalHdr->GpValue);
    }

    if ((ImageFileHdr->SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER32)) ||
        (ImageFileHdr->SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER64)))
    {
        char szOSVersion[30];
        char szImageVersion[30];
        char szSubsystemVersion[30];

        switch (ImageOptionalHdr->Subsystem) {
            case IMAGE_SUBSYSTEM_POSIX_CUI   : i = 4; break;
            case IMAGE_SUBSYSTEM_WINDOWS_CUI : i = 3; break;
            case IMAGE_SUBSYSTEM_WINDOWS_GUI : i = 2; break;
            case IMAGE_SUBSYSTEM_NATIVE      : i = 1; break;
            default : i = 0;
        }

        PrintString(szOSVersion,
                    DIMA(szOSVersion),
                    "%hu.%02hu",
                    ImageOptionalHdr->MajorOperatingSystemVersion,
                    ImageOptionalHdr->MinorOperatingSystemVersion);

        PrintString(szImageVersion,
                    DIMA(szImageVersion),
                    "%hu.%02hu",
                    ImageOptionalHdr->MajorImageVersion,
                    ImageOptionalHdr->MinorImageVersion);

        PrintString(szSubsystemVersion,
                    DIMA(szSubsystemVersion),
                    "%hu.%02hu",
                    ImageOptionalHdr->MajorSubsystemVersion,
                    ImageOptionalHdr->MinorSubsystemVersion);

        dprintf(
                "         ----- new -----\n"
                "%p image base\n"
                "%8lX section alignment\n"
                "%8lX file alignment\n"
                "%8hX subsystem (%s)\n"
                "%8s operating system version\n"
                "%8s image version\n"
                "%8s subsystem version\n"
                "%8lX size of image\n"
                "%8lX size of headers\n"
                "%8lX checksum\n",
                ImageOptionalHdr->ImageBase,
                ImageOptionalHdr->SectionAlignment,
                ImageOptionalHdr->FileAlignment,
                ImageOptionalHdr->Subsystem,
                SubsystemName[i],
                szOSVersion,
                szImageVersion,
                szSubsystemVersion,
                ImageOptionalHdr->SizeOfImage,
                ImageOptionalHdr->SizeOfHeaders,
                ImageOptionalHdr->CheckSum);

        dprintf(
                "%p size of stack reserve\n"
                "%p size of stack commit\n"
                "%p size of heap reserve\n"
                "%p size of heap commit\n",
                ImageOptionalHdr->SizeOfStackReserve,
                ImageOptionalHdr->SizeOfStackCommit,
                ImageOptionalHdr->SizeOfHeapReserve,
                ImageOptionalHdr->SizeOfHeapCommit);

        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++) {
            if (!DirectoryEntryName[i]) {
                break;
            }

            dprintf( "%8lX [%8lX] address [size] of %s Directory\n",
                     ImageOptionalHdr->DataDirectory[i].VirtualAddress,
                     ImageOptionalHdr->DataDirectory[i].Size,
                     DirectoryEntryName[i]
                     );
        }

        dprintf( "\n" );
    }
}



VOID
DumpSectionHeader (
    IN DWORD i,
    IN PIMAGE_SECTION_HEADER Sh
    )
{
    const char *name;
    char *szUnDName;
    DWORD li, lj;
    WORD memFlags;

    dprintf("\nSECTION HEADER #%hX\n%8.8s name", i, Sh->Name);

#if 0
    if (Sh->Name[0] == '/') {
        name = SzObjSectionName((char *) Sh->Name, (char *) DumpStringTable);

        dprintf(" (%s)", name);
    }
#endif
    dprintf( "\n");

    dprintf( "%8lX %s\n"
             "%8lX virtual address\n"
             "%8lX size of raw data\n"
             "%8lX file pointer to raw data\n"
             "%8lX file pointer to relocation table\n",
           Sh->Misc.PhysicalAddress,
           (dft == dftObject) ? "physical address" : "virtual size",
           Sh->VirtualAddress,
           Sh->SizeOfRawData,
           Sh->PointerToRawData,
           Sh->PointerToRelocations);

    dprintf( "%8lX file pointer to line numbers\n"
                        "%8hX number of relocations\n"
                        "%8hX number of line numbers\n"
                        "%8lX flags\n",
           Sh->PointerToLinenumbers,
           Sh->NumberOfRelocations,
           Sh->NumberOfLinenumbers,
           Sh->Characteristics);

    memFlags = 0;

    li = Sh->Characteristics;

    if (dft == dftROM) {
       for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case STYP_REG   : name = "Regular"; break;
                    case STYP_TEXT  : name = "Text"; memFlags = 1; break;
                    case STYP_INIT  : name = "Init Code"; memFlags = 1; break;
                    case STYP_RDATA : name = "Data"; memFlags = 2; break;
                    case STYP_DATA  : name = "Data"; memFlags = 6; break;
                    case STYP_LIT8  : name = "Literal 8"; break;
                    case STYP_LIT4  : name = "Literal 4"; break;
                    case STYP_SDATA : name = "GP Init Data"; memFlags = 6; break;
                    case STYP_SBSS  : name = "GP Uninit Data"; memFlags = 6; break;
                    case STYP_BSS   : name = "Uninit Data"; memFlags = 6; break;
                    case STYP_LIB   : name = "Library"; break;
                    case STYP_UCODE : name = "UCode"; break;
                    case S_NRELOC_OVFL : name = "Non-Relocatable overlay"; memFlags = 1; break;
                    default : name = "RESERVED - UNKNOWN";
                }

                dprintf( "         %s\n", name);
            }
        }
    } else {
        // Clear the padding bits

        li &= ~0x00700000;

        for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case IMAGE_SCN_TYPE_NO_PAD  : name = "No Pad"; break;

                    case IMAGE_SCN_CNT_CODE     : name = "Code"; break;
                    case IMAGE_SCN_CNT_INITIALIZED_DATA : name = "Initialized Data"; break;
                    case IMAGE_SCN_CNT_UNINITIALIZED_DATA : name = "Uninitialized Data"; break;

                    case IMAGE_SCN_LNK_OTHER    : name = "Other"; break;
                    case IMAGE_SCN_LNK_INFO     : name = "Info"; break;
                    case IMAGE_SCN_LNK_REMOVE   : name = "Remove"; break;
                    case IMAGE_SCN_LNK_COMDAT   : name = "Communal"; break;

                    case IMAGE_SCN_MEM_DISCARDABLE: name = "Discardable"; break;
                    case IMAGE_SCN_MEM_NOT_CACHED: name = "Not Cached"; break;
                    case IMAGE_SCN_MEM_NOT_PAGED: name = "Not Paged"; break;
                    case IMAGE_SCN_MEM_SHARED   : name = "Shared"; break;
                    case IMAGE_SCN_MEM_EXECUTE  : name = ""; memFlags |= 1; break;
                    case IMAGE_SCN_MEM_READ     : name = ""; memFlags |= 2; break;
                    case IMAGE_SCN_MEM_WRITE    : name = ""; memFlags |= 4; break;

                    case IMAGE_SCN_MEM_FARDATA  : name = "Far Data"; break;
                    case IMAGE_SCN_MEM_SYSHEAP  : name = "Sys Heap"; break;
                    case IMAGE_SCN_MEM_PURGEABLE: name = "Purgeable or 16-Bit"; break;
                    case IMAGE_SCN_MEM_LOCKED   : name = "Locked"; break;
                    case IMAGE_SCN_MEM_PRELOAD  : name = "Preload"; break;
                    case IMAGE_SCN_MEM_PROTECTED: name = "Protected"; break;

                    default : name = "RESERVED - UNKNOWN";
                }

                if (*name) {
                    dprintf( "         %s\n", name);
                }
            }
        }

        // print alignment

        switch (Sh->Characteristics & 0x00700000) {
            default:                      name = "(no align specified)"; break;
            case IMAGE_SCN_ALIGN_1BYTES:  name = "1 byte align";  break;
            case IMAGE_SCN_ALIGN_2BYTES:  name = "2 byte align";  break;
            case IMAGE_SCN_ALIGN_4BYTES:  name = "4 byte align";  break;
            case IMAGE_SCN_ALIGN_8BYTES:  name = "8 byte align";  break;
            case IMAGE_SCN_ALIGN_16BYTES: name = "16 byte align"; break;
            case IMAGE_SCN_ALIGN_32BYTES: name = "32 byte align"; break;
            case IMAGE_SCN_ALIGN_64BYTES: name = "64 byte align"; break;
        }

        dprintf( "         %s\n", name);
    }

    if (memFlags) {
        switch(memFlags) {
            case 1 : name = "Execute Only"; break;
            case 2 : name = "Read Only"; break;
            case 3 : name = "Execute Read"; break;
            case 4 : name = "Write Only"; break;
            case 5 : name = "Execute Write"; break;
            case 6 : name = "Read Write"; break;
            case 7 : name = "Execute Read Write"; break;
            default : name = "Unknown Memory Flags"; break;
        }
        dprintf( "         %s\n", name);
    }
}

VOID
DumpDebugDirectory (
    IN PIMAGE_DEBUG_DIRECTORY DebugDir
    )
{
    BOOL Ok;
    DWORD cb;
    CVDD cv;
    PIMAGE_DEBUG_MISC miscData;
    PIMAGE_DEBUG_MISC miscDataCur;
    ULONG VirtualAddress;
    DWORD len;

    switch (DebugDir->Type){
        case IMAGE_DEBUG_TYPE_COFF:
            dprintf( "\tcoff   ");
            break;
        case IMAGE_DEBUG_TYPE_CODEVIEW:
            dprintf( "\tcv     ");
            break;
        case IMAGE_DEBUG_TYPE_FPO:
            dprintf( "\tfpo    ");
            break;
        case IMAGE_DEBUG_TYPE_MISC:
            dprintf( "\tmisc   ");
            break;
        case IMAGE_DEBUG_TYPE_FIXUP:
            dprintf( "\tfixup  ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
            dprintf( "\t-> src ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
            dprintf( "\tsrc -> ");
            break;
        case IMAGE_DEBUG_TYPE_EXCEPTION:
            dprintf( "\tpdata  ");
            break;
        default:
            dprintf( "\t(%6lu)", DebugDir->Type);
            break;
    }
    dprintf( "%8x    %8x %8x",
                DebugDir->SizeOfData,
                DebugDir->AddressOfRawData,
                DebugDir->PointerToRawData);

    if (DebugDir->PointerToRawData &&
        DebugDir->Type == IMAGE_DEBUG_TYPE_MISC)
    {

        if (!TranslateFilePointerToVirtualAddress(DebugDir->PointerToRawData, &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = DebugDir->SizeOfData;
            miscData = (PIMAGE_DEBUG_MISC) malloc(len);
            if (!miscData) {
                goto DebugTypeCodeView;
            }
            __try {
                Ok = ReadMemory(Base + VirtualAddress, miscData, len, &cb);

                if (!Ok || cb != len) {
                    dprintf("Can't read debug data\n");
                } else {

                    miscDataCur = miscData;
                    do {
                        if (miscDataCur->DataType == IMAGE_DEBUG_MISC_EXENAME) {
                            if (ImageOptionalHdr->MajorLinkerVersion == 2 &&
                                ImageOptionalHdr->MinorLinkerVersion < 37) {
                                dprintf( "\tImage Name: %s", miscDataCur->Reserved);
                            } else {
                                dprintf( "\tImage Name: %s", miscDataCur->Data);
                            }
                            break;
                        }
                        len -= miscDataCur->Length;
                        miscDataCur = (PIMAGE_DEBUG_MISC) ((PCHAR) miscDataCur + miscData->Length);
                    } while (len > 0);

                }

            }
            __finally {
                if (miscData) {
                    free(miscData);
                }
            }
        }
    }
DebugTypeCodeView:
    if (DebugDir->PointerToRawData &&
        DebugDir->Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
        if (DebugDir->AddressOfRawData) {
            VirtualAddress = DebugDir->AddressOfRawData;
        }
        if (!DebugDir->AddressOfRawData &&
            !TranslateFilePointerToVirtualAddress(DebugDir->PointerToRawData, &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = DebugDir->SizeOfData;

            Ok = ReadMemory(Base + VirtualAddress, &cv, len, &cb);

            if (!Ok || cb != len) {
                dprintf("\tCan't read debug data cb=%lx\n", cb);
            } else {
                if (cv.dwSig == '01BN') {
                    dprintf( "\tFormat: NB10, %x, %x, %s", cv.nb10i.sig, cv.nb10i.age, cv.nb10i.szPdb);
                } else if (cv.dwSig == 'SDSR') {
                    dprintf( "\tFormat: RSDS, guid, %x, %s", cv.rsdsi.age, cv.rsdsi.szPdb);
                } else {
                    dprintf( "\tFormat: UNKNOWN");
                }
            }
        }

    }

    dprintf( "\n");
}



VOID
DumpDebugDirectories (
    PIMAGE_SECTION_HEADER sh
    )

/*++

Routine Description:

    Print out the contents of all debug directories

Arguments:

    sh - Section header for section that contains debug dirs

Return Value:

    None.

--*/
{
    int                numDebugDirs;
    IMAGE_DEBUG_DIRECTORY      debugDir;
    ULONG64            DebugDirAddr;
    ULONG64            pc;
    DWORD              cb;
    BOOL               Ok;

    if (dft == dftROM) {
        DebugDirAddr = (Base + sh->VirtualAddress);
        pc = DebugDirAddr;
        Ok = ReadMemory(pc, &debugDir, sizeof(IMAGE_DEBUG_DIRECTORY), &cb);

        if (!Ok || cb != sizeof(IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir\n");
            return;
        }

        numDebugDirs = 0;
        while (debugDir.Type != 0) {
            numDebugDirs++;
            pc += sizeof(IMAGE_DEBUG_DIRECTORY);
            Ok = ReadMemory(pc, &debugDir, sizeof(IMAGE_DEBUG_DIRECTORY), &cb);
            if (!Ok || cb != sizeof(IMAGE_DEBUG_DIRECTORY)) {
                break;
            }
        }
    } else {
        DebugDirAddr = (Base + ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress);
        numDebugDirs = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
    }

    dprintf("\n\nDebug Directories(%d)\n",numDebugDirs);
    dprintf("\tType       Size     Address  Pointer\n\n");
    pc = DebugDirAddr;
    while (numDebugDirs) {
        Ok = ReadMemory(pc, &debugDir, sizeof(IMAGE_DEBUG_DIRECTORY), &cb);
        if (!Ok || cb != sizeof(IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir\n");
            break;
        }
        pc += sizeof(IMAGE_DEBUG_DIRECTORY);
        DumpDebugDirectory(&debugDir);
        numDebugDirs--;
    }
}



VOID
dhDumpSections(
    )
{
    IMAGE_SECTION_HEADER sh;
    const char *p;
    DWORD li;
    DWORD cb;
    BOOL Ok;
    int i, j;
    CHAR szName[IMAGE_SIZEOF_SHORT_NAME + 1];


    for (i = 1; i <= ImageFileHdr->NumberOfSections; i++) {

        sh = SectionHdrs[i-1];

        //szName = SzObjSectionName((char *) sh.Name, (char *) DumpStringTable);
        CopyStrArray(szName, (char *) sh.Name);

        DumpSectionHeader(i, &sh);
        
        if (dft == dftROM) {

            if (!(ImageFileHdr->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {

                // If we're looking at the .rdata section and the symbols
                // aren't stripped, the debug directory must be here.

                if (!strcmp(szName, ".rdata")) {

                    DumpDebugDirectories(&sh);

                    //DumpDebugData(&sh);
                }
            }

        } else if (dft == dftPE) {

            if ((li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress) != 0) {
                if (li >= sh.VirtualAddress && li < sh.VirtualAddress+sh.SizeOfRawData) {
                    DumpDebugDirectories(&sh);

                    //DumpDebugData(&sh);
                }
            }


#if 0
            if (Switch.Dump.PData) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpFunctionTable(pimage, rgsym, (char *) DumpStringTable, &sh);
                }
            }

            if (Switch.Dump.Imports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpImports(&sh);
                }
            }

            if (Switch.Dump.Exports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    // UNDONE: Is this check really necessary?

                    if (ImageFileHdr->Machine != IMAGE_FILE_MACHINE_MPPC_601) {
                        DumpExports(&sh);
                    }
                }
            }

#endif

        }

    }
}

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG FilePointer,
    OUT PULONG VirtualAddress
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER sh;

    *VirtualAddress = 0;
    for (i = 1; i <= NumSections; i++) {
        sh = &SectionHdrs[i-1];

        if (sh->PointerToRawData <= FilePointer &&
            FilePointer < sh->PointerToRawData + sh->SizeOfRawData) {
            *VirtualAddress = FilePointer - sh->PointerToRawData + sh->VirtualAddress;
            return true;
        }
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\dumpsym.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dumpsym.cxx

Abstract:

    This is the command line tool to dump symbols from an image.

Author:

    David Fields - Feb 23, 2000
    Silviu Calinoiu - Feb 28, 2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <tchar.h>
#include <windows.h>
#include <imagehlp.h>
#include <common.ver>

//
// Section information
//
                                  
typedef struct {

    CHAR Name [9];
    DWORD64 Start;
    ULONG Size;

} IMG_SECTION_INFO, * PIMG_SECTION_INFO;

#define MAX_NUMBER_OF_SECTIONS 1024
IMG_SECTION_INFO Section [MAX_NUMBER_OF_SECTIONS];
ULONG SectionWriteIndex = 0;


typedef struct {

    HANDLE File;
    HANDLE Section;
    LPBYTE ImageBase;

    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;

    DWORD FileSignature;

    PIMAGE_DATA_DIRECTORY ImportDirectory;
    PIMAGE_SECTION_HEADER ImportSection;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    DWORD_PTR AddressCorrection;

} IMAGE_BROWSE_INFO, *PIMAGE_BROWSE_INFO;


BOOL 
ImgInitializeBrowseInfo (

    LPCTSTR FilePath,
    PIMAGE_BROWSE_INFO Info);


BOOL 
ImgDeleteBrowseInfo (

    PIMAGE_BROWSE_INFO Info);

PCHAR
ImgSearchSectionForAddress (
    DWORD64 Address
    );

BOOL
ShouldExcludeSymbol (
    LPSTR Name
    );

BOOL
OpenExcludeFile (
    LPSTR FilePath
    );

//
// Symbol information
//

typedef struct {

   LPSTR Name;
   DWORD64 Address;
   ULONG Size;
   BOOL Exclude;

} SYMBOL, *PSYMBOL;

PSYMBOL Symbols;
DWORD SymbolCount;
DWORD TotalNumberOfSymbols;

VOID 
DumpSymbols(
    char *, 
    BOOL All, 
    BOOL SortBySize);

VOID
PrintUsage(
    );

VOID
Error (
    char * Fmt,
    ...
    );

int __cdecl
SymbolCompareBySize(
    const void * Arg1,
    const void * Arg2
    );

int __cdecl
SymbolCompareByAddress(
    const void * Arg1,
    const void * Arg2
    );

BOOL
CALLBACK
SymbolEnumerationCallback(
           LPSTR SymbolName,
           DWORD64 SymbolAddress,
           ULONG SymbolSize,
           PVOID UserContext
           );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID 
Help (
    )
{
    printf("dumpsym BINARY-PATH [OPTIONS]                                   \n");
    printf("%s \n", VER_LEGALCOPYRIGHT_STR);                   
    printf("                                                                \n");
    printf("OPTIONS:                                                        \n");
    printf("/notpaged      Print all symbols that are not pageable          \n");
    printf("/all           Print all symbols (default)                      \n");
    printf("/address       Sort by address in increasing order              \n");
    printf("/size          Sort by size in decreasing order (default)       \n");
    printf("/exclude PATH  File with symbols that should be ignored         \n");
    printf("/symbols PATH  Symbols path. If not specified symbols must be   \n");
    printf("               in the directory containing the binary.          \n");
    printf("                                                                \n");
    printf("Ex. dumpsym c:\\binaries.x86fre\\ntoskrnl.exe                   \n");
    printf("            /symbols c:\\binaries.x86fre\\Symbols.pri\\retail   \n");
    printf("                                                                \n");
    printf("This tool can be used to determine what symbols are not paged         \n");
    printf("and then manually analyze if any of the functions or variables        \n");
    printf("can be moved into a PAGEXXXX section (become pageable). When          \n");
    printf("analyzing this data please take into account that the size for        \n");
    printf("some symbols includes padding/alignment zones and therefore           \n");
    printf("appears to be bigger than it really is.                               \n");
    printf("                                                                      \n");
    printf("Ex. dumpsym \\\\robsvbl1\\latest\\ntfs.sys                            \n");
    printf("            /symbols \\\\robsvbl1\\latest\\Symbols.pri\\retail        \n");
    printf("            /notpaged /size                                     \n");
    printf("                                                                \n");
    printf("                                                                \n");
    exit(-1);
}


VOID
Error (
    char * Fmt,
    ...
    )
{
    va_list Prms;

    va_start (Prms, Fmt);
    fprintf (stderr, "Dumpsym error: ");
    vfprintf (stderr, Fmt, Prms);
    fprintf (stderr, "\n");
    fflush (stderr);
    exit (1);
}

PCHAR *
SearchOption (
    PCHAR * Args,
    PCHAR Option
    )
{
    for ( ; Args && *Args; Args++) {
        if (_stricmp (*Args, Option) == 0) {
            return Args;
        }
    }

    return NULL;
}


//
// main
//

VOID __cdecl
main (
    int argc,
    char *argv[]
    )
{
    IMAGE_BROWSE_INFO Info;
    PCHAR ExeName;
    PCHAR LongName;
    BOOL OptionAll;
    BOOL OptionSortBySize;
    PCHAR * OptionString;

    if (argc == 1 || SearchOption (argv, "/?")) {
        Help ();
    }

    SymInitialize(GetCurrentProcess(), NULL, FALSE);
    SymSetOptions(SYMOPT_UNDNAME);

    //
    // /exclude EXCLUDE-FILE-PATH
    //

    if ((OptionString = SearchOption (argv, "/exclude"))) {
        OpenExcludeFile (*(OptionString + 1));
    }
    
    //
    // dumpsym PATH-TO-BINARY
    //

    if ((OptionString = SearchOption (argv, argv[0]))) {
        
        ImgInitializeBrowseInfo (*(OptionString + 1), &Info);
        LongName = *(OptionString + 1);
    }
    else {
        Help ();
    }
    
    //
    // /symbols SYMBOL-PATH
    //

    if ((OptionString = SearchOption (argv, "/symbols"))) {
        SetCurrentDirectory (*(OptionString + 1));
    }
    
    //
    // Dump options.
    //

    OptionAll = TRUE;
    OptionSortBySize = TRUE;

    if (SearchOption (argv, "/notpaged")) {
        OptionAll = FALSE;
    }
    
    if (SearchOption (argv, "/all")) {
        OptionAll = TRUE;
    }
    
    if (SearchOption (argv, "/address")) {
        OptionSortBySize = FALSE;
    }
    
    if (SearchOption (argv, "/size")) {
        OptionSortBySize = TRUE;
    }
    
    //
    // Dump stuff.
    //

    DumpSymbols (LongName, OptionAll, OptionSortBySize);
}

LPSTR
CopyStr (
    LPSTR Source
    )
{
    LPSTR Target;

    Target = (LPSTR) malloc (strlen(Source) + 1);

    if (Target) {
        strcpy (Target, Source);
    }

    return Target;
}


BOOL
CALLBACK
SymbolEnumerationCallback(
           LPSTR SymbolName,
           DWORD64 SymbolAddress,
           ULONG SymbolSize,
           PVOID UserContext
           )
{
    if (PtrToUlong(UserContext) == 1) {
        
        if (SymbolName == NULL) {
            Error ("Ooops");
        }

        if (SymbolCount >= TotalNumberOfSymbols) {
            Error ("enumerated more symbols on second pass");
        }

        Symbols[SymbolCount].Name = CopyStr (SymbolName);
        Symbols[SymbolCount].Address = SymbolAddress;
        Symbols[SymbolCount].Size = SymbolSize;

        if (Symbols[SymbolCount].Name == NULL) {
             Symbols[SymbolCount].Name = "*error*";
        }
    }

    SymbolCount += 1;
    return TRUE;
}


int __cdecl
SymbolCompareBySize(
    const void * Arg1,
    const void * Arg2
    )
{
    PSYMBOL Sym1 = (PSYMBOL) Arg1;
    PSYMBOL Sym2 = (PSYMBOL) Arg2;

    // decreasing order by size
    return (Sym2->Size - Sym1->Size);
}


int __cdecl
SymbolCompareByAddress(
    const void * Arg1,
    const void * Arg2
    )
{
    PSYMBOL Sym1 = (PSYMBOL) Arg1;
    PSYMBOL Sym2 = (PSYMBOL) Arg2;
    INT64 Delta;

    // increasing order by address
    Delta = (INT64)(Sym1->Address - Sym2->Address);

    if (Delta > 0) {
        return 1;
    }
    else if (Delta == 0) {
        return 0;
    }
    else {
        return -1;
    }
}


VOID
DumpSymbols(
    LPTSTR ImageName, 
    BOOL All,
    BOOL SortBySize)
{
    DWORD64 BaseOfDll;
    PCHAR SectionName;
    DWORD I, J;
    BOOL FoundOne;

    //
    // Load symbols
    //

    BaseOfDll = SymLoadModule64(
        GetCurrentProcess (), 
        NULL,
        ImageName, 
        NULL,
        0, 
        0);

    if (BaseOfDll == 0) {
        Error ("cannot load symbols for %s \n", ImageName);
    }

    //
    // Number the symbols
    //

    SymbolCount = 0;

    SymEnumerateSymbols64(
        GetCurrentProcess(), 
        BaseOfDll, 
        SymbolEnumerationCallback, 
        0); // Count them

    TotalNumberOfSymbols = SymbolCount;
    printf("Detected %u symbols in %s \n\n", TotalNumberOfSymbols, ImageName);

    //
    // Read all symbols.
    //

    SymbolCount = 0;
    Symbols = malloc(TotalNumberOfSymbols * sizeof(SYMBOL));

    if (Symbols == NULL) {
        Error ("out of memory (failed to allocate %u bytes)", TotalNumberOfSymbols * sizeof(SYMBOL));
    }

    SymEnumerateSymbols64(
        GetCurrentProcess(), 
        BaseOfDll, 
        SymbolEnumerationCallback, 
        (PVOID)1);

    //
    // Sort symbols
    //

    qsort(
        Symbols, 
        TotalNumberOfSymbols, 
        sizeof(SYMBOL), 
        (SortBySize ? SymbolCompareBySize : SymbolCompareByAddress));

    //
    // Figure out symbols that should not be printed.
    //

    for (J = 0; J < TotalNumberOfSymbols; J++) {

        if (ShouldExcludeSymbol (Symbols[J].Name)) {
            Symbols[J].Exclude = TRUE;
        }
        else {
            Symbols[J].Exclude = FALSE;
        }
    }

    //
    // Print symbols
    //

    printf("%-8s %-16s %-8s %s \n", "Section", "Address", "Size", "Symbol");
    printf("-------------------------------------------------------------\n");

    for (I = 0; I < SectionWriteIndex; I++) {

        for (J = 0, FoundOne = FALSE; J < TotalNumberOfSymbols; J++) {

            if (Symbols[J].Exclude) {
                continue;
            }

            SectionName = ImgSearchSectionForAddress (
                Symbols[J].Address - BaseOfDll);

            if (strcmp (SectionName, Section[I].Name) == 0) {
                if (All || strstr (SectionName,"PAGE") == NULL) {

                    if (Symbols[J].Name == NULL) {
                        printf(".\n");
                        continue;
                    }
                    printf("%-8s %016I64X %08X %s \n", 
                        SectionName,
                        Symbols[J].Address - BaseOfDll, 
                        Symbols[J].Size,
                        Symbols[J].Name); 

                    FoundOne = TRUE;
                }
            }
        }
    
        if (FoundOne) {
            printf("\n");
        }
    }

    //
    // Unload symbols
    //

    if (SymUnloadModule64(GetCurrentProcess(),  BaseOfDll) == FALSE) {
        Error ("cannot unload symbols");
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Section manipulation routines
/////////////////////////////////////////////////////////////////////

//
// Function:
//
//     ImgInitializeBrowseInfo
//
// Description:
//
//     This functions fills oout the `Info' structure with
//     various pointers to PE data from the mapped image file.
//
//     Note. Even if the function returned false the destructor
//     `ImgDeleteBrowseInfo' should be called because it does some
//     cleanup.
//
// Return:
//
//     True if all the PE data pointers have been obtained.
//

BOOL
ImgInitializeBrowseInfo (

    LPCTSTR FilePath,
    PIMAGE_BROWSE_INFO Info)
{
    DWORD Index, I;

    if (Info == NULL) {
        return FALSE;
    }

    ZeroMemory (Info, sizeof *Info);

    Info->File = CreateFile (

        FilePath,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (Info->File == INVALID_HANDLE_VALUE) {

      Error ("create file %s (error %u)", FilePath, GetLastError());
      return FALSE;
    }

    Info->Section = CreateFileMapping (

        Info->File,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL);

    if (Info->Section == NULL) {

      return FALSE;
    }

    Info->ImageBase = (LPBYTE) MapViewOfFile (

        Info->Section,
        FILE_MAP_READ,
        0,
        0,
        0);

    if (Info->ImageBase == NULL) {

      return FALSE;
    }

    //
    // Check the signature
    //

    Info->DosHeader = (PIMAGE_DOS_HEADER)Info->ImageBase;

    if (Info->DosHeader->e_magic != 'ZM') {

      return FALSE;
    }

    Info->FileHeader = (PIMAGE_FILE_HEADER)
        (Info->ImageBase + Info->DosHeader->e_lfanew + sizeof(DWORD));

    Info->FileSignature = *((DWORD *)Info->FileHeader - 1);

    if (Info->FileSignature != IMAGE_NT_SIGNATURE) {

      return FALSE;
    }


    Info->OptionalHeader = (PIMAGE_OPTIONAL_HEADER)(Info->FileHeader + 1);
    Info->ImportDirectory = & (Info->OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
    Info->SectionHeader = (PIMAGE_SECTION_HEADER)(Info->OptionalHeader + 1);
    Info->ImportSection = NULL;

    //
    // Find the section containing the import table
    //

    printf("Sections in %s \n\n", FilePath);

    for (Index = 0; Index < Info->FileHeader->NumberOfSections; Index++) {

        //
        // SilviuC: I wonder if there is a way to get a 64 bit value for VirtualAddress.
        // Apparently it is stored as a ULONG in PE format.
        //

        Section[SectionWriteIndex].Start = (DWORD64)((Info->SectionHeader + Index)->VirtualAddress);
        Section[SectionWriteIndex].Size = (Info->SectionHeader + Index)->SizeOfRawData;

        for (I = 0; I < 8; I++) {
            Section[SectionWriteIndex].Name[I] = ((Info->SectionHeader + Index)->Name)[I];
        }

        Section[SectionWriteIndex].Name[I] = 0;

        printf("%-8s %08X %08X \n", 
               Section[SectionWriteIndex].Name, 
               Section[SectionWriteIndex].Start, 
               Section[SectionWriteIndex].Size);
        
        SectionWriteIndex += 1;
    }
    
    printf("\n");

    //
    // Find the address of import data in the section body.
    //

#if 0
    Info->AddressCorrection = (DWORD_PTR)Info->ImageBase 
        + Info->ImportSection->PointerToRawData
        - Info->ImportSection->VirtualAddress;

    Info->ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(Info->AddressCorrection
         + Info->ImportDirectory->VirtualAddress);
#endif

    //
    // Finish
    //

    return TRUE;
}


//
// Function:
//
//     ImgDeleteBrowseInfo
//
// Description:
//
//     This function cleans up the `Info' structure, unmaps views, 
//     closes handles, etc.
//

BOOL
ImgDeleteBrowseInfo (

    PIMAGE_BROWSE_INFO Info)
{
    if (Info == NULL)
        return FALSE;

    UnmapViewOfFile (Info->ImageBase);
    CloseHandle (Info->Section);
    CloseHandle (Info->File);

    ZeroMemory (Info, sizeof *Info);

    return TRUE;
}

PCHAR
ImgSearchSectionForAddress (
    DWORD64 Address
    )
{
    DWORD I;

    for (I = 0; I < SectionWriteIndex; I++) {
        if (Section[I].Start <= Address && Address < Section[I].Start + Section[I].Size) {
            return Section[I].Name;
        }
    }

    return "unknown";
}

//
// Exclude file logic
//

PCHAR *ExcludeStrings;
DWORD NumberOfExcludeStrings;

BOOL
ShouldExcludeSymbol (
    LPSTR Name
    )
{
    DWORD I;

    if (ExcludeStrings == NULL) {
        return FALSE;
    }
    for (I = 0; I <NumberOfExcludeStrings; I += 1) {

        if (_stricmp (Name, ExcludeStrings[I]) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
OpenExcludeFile (
    LPSTR FilePath
    )
{
    FILE * File;
    CHAR String[1024];
    DWORD StringCount = 0;

    File = fopen (FilePath, "r");

    if (File == NULL) {
        Error ("cannot open exclude file %s", FilePath);
    }

    while (fgets (String, 1024, File)) {
        StringCount += 1;
    }

    fclose (File);

    ExcludeStrings = (PCHAR *)malloc (StringCount * sizeof(PVOID));

    if (ExcludeStrings == NULL) {
        Error ("cannot allocate exclude strings buffer");
    }

    NumberOfExcludeStrings = StringCount;

    printf("Excluding %u symbols from %s \n", 
           NumberOfExcludeStrings,
           FilePath);

    File = fopen (FilePath, "r");
    if (!File) {
        Error ("cannot open file");
    }

    StringCount = 0;

    while (fgets (String, 1024, File)) {
        
        PCHAR Start, Current;

        Current = String;

        while (*Current == ' ' || *Current == '\t') {
            Current += 1;
        }

        Start = Current;

        while (*Current && *Current != ' ' && *Current != '\t' && *Current != '\n') {
            Current += 1;
        }

        *Current = '\0';

        if (StringCount < NumberOfExcludeStrings) {
            ExcludeStrings[StringCount] = CopyStr (Start);

            // printf("Exclude %s \n", ExcludeStrings[StringCount]);
        }

        StringCount += 1;
    }

    fclose (File);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\dload.c ===
#include <private.h>
#include <globals.h>
#include <delayimp.h>
#include <copystr.h>

#ifdef BUILD_DBGHELP

BOOL
GetDllVersionInfo(
    HINSTANCE hinst,
    LPVOID *lpVersionInfo
    );

#define FreeLib(hDll)   \
    {if (hDll && hDll != INVALID_HANDLE_VALUE) FreeLibrary(hDll);}

#endif // #ifdef BUILD_DBGHELP

typedef struct
{
    PCHAR Name;
    FARPROC Function;
} FUNCPTRS;

#if DBG
void
OutputDBString(
    CHAR *text
    );
#endif

#ifdef BUILD_IMAGEHLP

BOOL  IMAGEAPI FailEnumerateLoadedModules(
    IN HANDLE                         hProcess,
    IN PENUMLOADED_MODULES_CALLBACK   EnumLoadedModulesCallback,
    IN PVOID                          UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailEnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    )
{ return FALSE; }

HANDLE IMAGEAPI FailFindDebugInfoFile (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath
    )
{return NULL;}

HANDLE IMAGEAPI FailFindDebugInfoFileEx (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    )
{ return NULL; }

HANDLE IMAGEAPI FailFindExecutableImage(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath
    )
{ return NULL; }

LPAPI_VERSION IMAGEAPI FailImagehlpApiVersion(
    VOID
    )
{ return NULL; }

LPAPI_VERSION IMAGEAPI FailImagehlpApiVersionEx(
    LPAPI_VERSION AppVersion
    )
{ return NULL; }

BOOL IMAGEAPI FailMakeSureDirectoryPathExists(
    PCSTR DirPath
    )
{ return FALSE; }

#ifndef _WIN64
PIMAGE_DEBUG_INFORMATION IMAGEAPI FailMapDebugInformation(
    HANDLE FileHandle,
    PSTR FileName,
    PSTR SymbolPath,
    DWORD ImageBase
    )
{ return NULL; }
#endif

BOOL IMAGEAPI FailSearchTreeForFile(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer
    )
{ return FALSE; }

BOOL IMAGEAPI FailStackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    )
{ return FALSE; }

BOOL IMAGEAPI FailStackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymCleanup(
    IN HANDLE hProcess
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateModules(
    IN HANDLE                     hProcess,
    IN PSYM_ENUMMODULES_CALLBACK  EnumModulesCallback,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateModules64(
    IN HANDLE                       hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64  EnumModulesCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbols(
    IN HANDLE                     hProcess,
    IN DWORD                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN DWORD                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

PVOID IMAGEAPI FailSymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    )
{ return NULL; }

PVOID IMAGEAPI FailSymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{ return NULL; }

BOOL IMAGEAPI FailSymGetLineFromAddr(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineFromName(
    IN     HANDLE             hProcess,
    IN     PSTR               ModuleName,
    IN     PSTR               FileName,
    IN     DWORD              dwLineNumber,
       OUT PLONG              plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     PSTR                 ModuleName,
    IN     PSTR                 FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineNext(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLinePrev(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    )
{ return 0; }

DWORD64 IMAGEAPI FailSymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr
    )
{ return 0; }

BOOL IMAGEAPI FailSymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE  ModuleInfo
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW  ModuleInfo
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetModuleInfo64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULE64      ModuleInfo
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetModuleInfoW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULEW64     ModuleInfo
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymGetOptions(
    VOID
    )
{ return 0; }

BOOL IMAGEAPI FailSymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT PSTR            SearchPath,
    IN  DWORD           SearchPathLength
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PDWORD64            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  PSTR                Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymNext(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymPrev(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL
IMAGEAPI
FailSymGetTypeInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    )
{ return FALSE; }

BOOL
IMAGEAPI
FailSymGetTypeFromName(
    IN  HANDLE              hProcess,
    IN  ULONG64             BaseOfDll,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    )
{ return FALSE; }

BOOL
IMAGEAPI
FailSymEnumTypes(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymInitialize(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    )
{ return 0; }

DWORD64 IMAGEAPI FailSymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll
    )
{ return 0; }

BOOL IMAGEAPI FailSymMatchFileName(
    IN  PSTR  FileName,
    IN  PSTR  Match,
    OUT PSTR *FileNameStop,
    OUT PSTR *MatchStop
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterCallback(
    IN HANDLE                      hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    IN PVOID                       UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymSetContext(
    HANDLE hProcess,
    PIMAGEHLP_STACK_FRAME StackFrame,
    PIMAGEHLP_CONTEXT Context
    ) 
{ return FALSE;}

DWORD IMAGEAPI FailSymSetOptions(
    IN DWORD   SymOptions
    )
{ return 0; }

BOOL IMAGEAPI FailSymSetSearchPath(
    IN HANDLE           hProcess,
    IN PSTR             SearchPath
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnDName(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT PSTR             UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnDName64(
    IN  PIMAGEHLP_SYMBOL64 sym,               // Symbol to undecorate
    OUT PSTR               UnDecName,         // Buffer to store undecorated name in
    IN  DWORD              UnDecNameLength    // Size of the buffer
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnloadModule(
    IN  HANDLE          hProcess,
    IN  DWORD           BaseOfDll
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnloadModule64(
    IN  HANDLE          hProcess,
    IN  DWORD64         BaseOfDll
    )
{ return FALSE; }

#ifndef _WIN64
BOOL IMAGEAPI FailUnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    )
{ return FALSE; }
#endif

BOOL IMAGEAPI FailSymEnumSym(
    IN HANDLE                     hProcess,
    IN DWORD64                    BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD64           dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PSYMBOL_INFO      Symbol
    )
{ return FALSE; }


BOOL IMAGEAPI FailSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PSYMBOL_INFO      Symbol
    )
{ return FALSE; }


FUNCPTRS DbgHelpFailPtrs[] = {
    {"EnumerateLoadedModules",       (FARPROC)FailEnumerateLoadedModules},
    {"EnumerateLoadedModules64",     (FARPROC)FailEnumerateLoadedModules64},
    {"FindDebugInfoFile",            (FARPROC)FailFindDebugInfoFile},
    {"FindDebugInfoFileEx",          (FARPROC)FailFindDebugInfoFileEx},
    {"FindExecutableImage",          (FARPROC)FailFindExecutableImage},
    {"ImagehlpApiVersion",           (FARPROC)FailImagehlpApiVersion},
    {"ImagehlpApiVersionEx",         (FARPROC)FailImagehlpApiVersionEx},
    {"MakeSureDirectoryPathExists",  (FARPROC)FailMakeSureDirectoryPathExists},
#ifndef _WIN64
    {"MapDebugInformation",          (FARPROC)FailMapDebugInformation},
#endif
    {"SearchTreeForFile",            (FARPROC)FailSearchTreeForFile},
    {"StackWalk",                    (FARPROC)FailStackWalk},
    {"StackWalk64",                  (FARPROC)FailStackWalk64},
    {"SymCleanup",                   (FARPROC)FailSymCleanup},
    {"SymEnumerateModules",          (FARPROC)FailSymEnumerateModules},
    {"SymEnumerateModules64",        (FARPROC)FailSymEnumerateModules64},
    {"SymEnumerateSymbols",          (FARPROC)FailSymEnumerateSymbols},
    {"SymEnumerateSymbols64",        (FARPROC)FailSymEnumerateSymbols64},
    {"SymEnumerateSymbolsW",         (FARPROC)FailSymEnumerateSymbolsW},
    {"SymEnumerateSymbolsW64",       (FARPROC)FailSymEnumerateSymbolsW64},
    {"SymEnumSym",                   (FARPROC)FailSymEnumSym},
    {"SymEnumTypes",                 (FARPROC)FailSymEnumTypes},
    {"SymFromAddr",                  (FARPROC)FailSymFromAddr},
    {"SymFromName",                  (FARPROC)FailSymFromName},
    {"SymFunctionTableAccess",       (FARPROC)FailSymFunctionTableAccess},
    {"SymFunctionTableAccess64",     (FARPROC)FailSymFunctionTableAccess64},
    {"SymGetLineFromAddr",           (FARPROC)FailSymGetLineFromAddr},
    {"SymGetLineFromAddr64",         (FARPROC)FailSymGetLineFromAddr64},
    {"SymGetLineFromName",           (FARPROC)FailSymGetLineFromName},
    {"SymGetLineFromName64",         (FARPROC)FailSymGetLineFromName64},
    {"SymGetLineNext",               (FARPROC)FailSymGetLineNext},
    {"SymGetLineNext64",             (FARPROC)FailSymGetLineNext64},
    {"SymGetLinePrev",               (FARPROC)FailSymGetLinePrev},
    {"SymGetLinePrev64",             (FARPROC)FailSymGetLinePrev64},
    {"SymGetModuleBase",             (FARPROC)FailSymGetModuleBase},
    {"SymGetModuleBase64",           (FARPROC)FailSymGetModuleBase64},
    {"SymGetModuleInfo",             (FARPROC)FailSymGetModuleInfo},
    {"SymGetModuleInfo64",           (FARPROC)FailSymGetModuleInfo64},
    {"SymGetModuleInfoW",            (FARPROC)FailSymGetModuleInfoW},
    {"SymGetModuleInfoW64",          (FARPROC)FailSymGetModuleInfoW64},
    {"SymGetOptions",                (FARPROC)FailSymGetOptions},
    {"SymGetSearchPath",             (FARPROC)FailSymGetSearchPath},
    {"SymGetSymFromAddr",            (FARPROC)FailSymGetSymFromAddr},
    {"SymGetSymFromAddr64",          (FARPROC)FailSymGetSymFromAddr64},
    {"SymGetSymFromName",            (FARPROC)FailSymGetSymFromName},
    {"SymGetSymFromName64",          (FARPROC)FailSymGetSymFromName64},
    {"SymGetSymNext",                (FARPROC)FailSymGetSymNext},
    {"SymGetSymNext64",              (FARPROC)FailSymGetSymNext64},
    {"SymGetSymPrev",                (FARPROC)FailSymGetSymPrev},
    {"SymGetSymPrev64",              (FARPROC)FailSymGetSymPrev64},
    {"SymGetTypeFromName",           (FARPROC)FailSymGetTypeFromName},
    {"SymGetTypeInfo",               (FARPROC)FailSymGetTypeInfo},
    {"SymInitialize",                (FARPROC)FailSymInitialize},
    {"SymLoadModule",                (FARPROC)FailSymLoadModule},
    {"SymLoadModule64",              (FARPROC)FailSymLoadModule64},
    {"SymMatchFileName",             (FARPROC)FailSymMatchFileName},
    {"SymRegisterCallback",          (FARPROC)FailSymRegisterCallback},
    {"SymRegisterCallback64",        (FARPROC)FailSymRegisterCallback64},
    {"SymRegisterFunctionEntryCallback",   (FARPROC)FailSymRegisterFunctionEntryCallback},
    {"SymRegisterFunctionEntryCallback64", (FARPROC)FailSymRegisterFunctionEntryCallback64},
    {"SymSetContext",                (FARPROC)FailSymSetContext},
    {"SymSetOptions",                (FARPROC)FailSymSetOptions},
    {"SymSetSearchPath",             (FARPROC)FailSymSetSearchPath},
    {"SymUnDName",                   (FARPROC)FailSymUnDName},
    {"SymUnDName64",                 (FARPROC)FailSymUnDName64},
    {"SymUnloadModule",              (FARPROC)FailSymUnloadModule},
    {"SymUnloadModule64",            (FARPROC)FailSymUnloadModule64},
#ifndef _WIN64
    {"UnmapDebugInformation",        (FARPROC)FailUnmapDebugInformation},
#endif
    {NULL, NULL}
};

#endif      // BUILD_IMAGEHLP

#ifdef BUILD_IMAGEHLP
FUNCPTRS *FailFunctions[2] = {NULL, DbgHelpFailPtrs}; // {MsDbiFailPtrs, DbgHelpFailPtrs};
HINSTANCE hDelayLoadDll[2];
#else
FUNCPTRS *FailFunctions[1] = {MsDbiFailPtrs};
HINSTANCE hDelayLoadDll[1];
#endif

FARPROC
FindFailureProc(
                UINT Index,
                const char *szProcName
                )
{
    FUNCPTRS *fp = FailFunctions[Index];
    UINT x = 0;

    while (fp[x].Name) {
        if (!lstrcmpi(fp[x].Name, szProcName)) {
            return fp[x].Function;
        }
        x++;
    }
    return NULL;
}

/*
 * this function exists to prevent us from calling msvcrt!splitpath
 */

VOID
ParsePath(
    CHAR *fullpath,
    CHAR *path,
    DWORD cbPath,
    CHAR *file,
    DWORD cbFile
    )
{
    CHAR *c;
    CHAR sz[MAX_PATH + 1];

    assert(fullpath);

    if (path)
        *path = 0;
    if (file)
        *file = 0;

    CopyStrArray(sz, fullpath);
    for (c = sz + lstrlen(sz); c > sz; c--) {
        if (*c == '\\') {
            c++;
            if (file)
                CopyString(file, c, cbFile);
            *c = 0;
            if (path)
                CopyString(path, sz, cbPath);
            return;
        }
    }

    if (file)
        CopyString(file, fullpath, cbFile);
}

FARPROC
WINAPI
ImagehlpDelayLoadHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    )
{
    FARPROC ReturnValue = NULL;

    if (dliStartProcessing == unReason)
    {
        DWORD iDll = 0;
#ifdef BUILD_IMAGEHLP
        if (!lstrcmpi(pDelayInfo->szDll, "dbghelp.dll")) {
            iDll = 2;
        }
#endif

        if (iDll) {

            iDll--;

            // If the dll isn't loaded and isn't inproc already, attempt to load
            // from the same dir as imagehlp lives...

            if (!hDelayLoadDll[iDll] &&
                !(hDelayLoadDll[iDll] = GetModuleHandle(pDelayInfo->szDll)) &&
                g.hinst)
            {
                CHAR szImageName[MAX_PATH + 1];
                CHAR szPath[_MAX_DIR];
                CHAR szDll[MAX_PATH + 1];

                // Only load if dbghelp/msdbi are in the same dir as imagehlp

                GetModuleFileName(g.hinst, szImageName, DIMA(szImageName));
                ParsePath(szImageName, szPath, DIMA(szPath), szDll, DIMA(szDll));
                CopyStrArray(szImageName, szPath);
                CatStrArray(szImageName, pDelayInfo->szDll);
                hDelayLoadDll[iDll] = LoadLibrary(szImageName);
                if (!hDelayLoadDll[iDll]) {
                    hDelayLoadDll[iDll] = (HINSTANCE)INVALID_HANDLE_VALUE;
                }
            }

            if (INVALID_HANDLE_VALUE != hDelayLoadDll[iDll] && g.hinst) {
                ReturnValue = GetProcAddress(hDelayLoadDll[iDll], pDelayInfo->dlp.szProcName);
            }

            if (!ReturnValue) {
                ReturnValue = FindFailureProc(iDll, pDelayInfo->dlp.szProcName);
            }
#if DBG
            if (!ReturnValue) {
                OutputDBString("BogusDelayLoad function encountered...\n");
            }
        } else {
            OutputDBString("BogusDelayLoad function encountered...\n");
#endif
        }
    }

    if (ReturnValue && g.hinst) {
        *pDelayInfo->ppfn = ReturnValue;
    }
    return ReturnValue;
}


#ifdef BUILD_DBGHELP

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


BOOL
GetDllVersionInfo(
    HINSTANCE hinst,
    LPVOID *lpVersionInfo
    )
{
    VS_FIXEDFILEINFO  *pvsFFI = NULL;
    HRSRC             hVerRes;
    VERHEAD           *pVerHead;
    BOOL              rc = FALSE;

    assert(lpVersionInfo && hinst);

    *lpVersionInfo = NULL;

    hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
    if (hVerRes == NULL)
        goto Cleanup;

    pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
    if (pVerHead == NULL)
        goto Cleanup;

    *lpVersionInfo = MemAlloc(pVerHead->wTotLen + pVerHead->wTotLen/2);
    if (*lpVersionInfo == NULL)
        goto Cleanup;

    memcpy(*lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
    rc = TRUE;

Cleanup:
    if (*lpVersionInfo && rc == FALSE)
        MemFree(*lpVersionInfo);

    return rc;
}

#endif // #ifdef BUILD_DBGHELP


PfnDliHook __pfnDliNotifyHook = ImagehlpDelayLoadHook;
PfnDliHook __pfnDliFailureHook = NULL;


#if DBG

void
OutputDBString(
    CHAR *text
    )
{
    CHAR sz[256];

    CopyStrArray(sz, MOD_FILENAME);
    CatStrArray(sz, ": ");
    CatStrArray(sz, text);
    OutputDebugString(sz);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\globals.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    globals.c

Abstract:

    This module implements all global variables used in dbghelp.dll

Author:

    Pat Styles (patst) 14-July-2000

Revision History:

--*/

#include <private.h>
#include <symbols.h>
#include <globals.h>

GLOBALS g = 
{
    // HANDLE hinst
    // initialized in DllMain

    0,

    // HANDLE hHeap

    0,

    // DWORD tlsIndex

    (DWORD)-1, 

#ifdef IMAGEHLP_HEAP_DEBUG
    
    // LIST_ENTRY HeapHeader

    {NULL, NULL},

    // ULONG TotalMemory

    0,

    // ULONG TotalAllocs

    0,

#endif

    // OSVERSIONINFO OSVerInfo
    // initialized in DllMain

    {0, 0, 0, 0, 0, ""},

    // API_VERSION ApiVersion

    {
        (VER_PRODUCTVERSION_W >> 8), 
        (VER_PRODUCTVERSION_W & 0xff), 
        API_VERSION_NUMBER, 
        0 
    },           
    
    // API_VERSION AppVersion

    // DON'T UPDATE THE FOLLOWING VERSION NUMBER!!!!
    //
    // If the app does not call ImagehlpApiVersionEx, always assume
    // that it is for NT 4.0.
    
    {4, 0, 5, 0}, 

    // ULONG   MachineType;

    0,

    // CRITICAL_SECTION threadlock;

    {
        (PRTL_CRITICAL_SECTION_DEBUG)0,
        (LONG)0,
        (LONG)0,
        (HANDLE)0,
        (HANDLE)0,
        (ULONG_PTR)0
    },

#ifdef BUILD_DBGHELP

    // HINSTANCE hSymSrv
    
    0,

    // PSYMBOLSERVERPROC fnSymbolServer
        
    NULL,

    // PSYMBOLSERVERCLOSEPROC fnSymbolServerClose
    
    NULL,

    // PSYMBOLSERVERSETOPTIONSPROC fnSymbolServerSetOptions
    
    NULL,

    // PSYMBOLSERVERPINGPROC fnSymbolServerPing
    
    NULL,

    // HINSTANCE hSrcSrv

    NULL,

    // PSRCSRVINITPROC fnSrcSrvInit

    NULL,

    // PSRCSRVCLEANUPPROC fnSrcSrvCleanup

    NULL,

    // PSRCSRVSETTARGETPATHPROC fnSrcSrvSetTargetPath

    NULL,

    // PSRCSRVSETOPTIONSPROC fnSrcSrvSetOptions

    NULL,

    // PSRCSRVGETOPTIONSPROC fnSrcSrvGetOptions

    NULL,

    // PSRCSRVLOADMODULEPROC fnSrcSrvLoadModule

    NULL,

    // PSRCSRVUNLOADMODULEPROC fnSrcSrvUnloadModule

    NULL,

    // PSRCSRVREGISTERCALLBACKPROC fnSrcSrvRegisterCallback

    NULL,

    // PSRCSRVGETFILEPROC fnSrcSrvGetFile

    NULL,

    // DWORD cProcessList

    0,
    
    // LIST_ENTRY ProcessList

    {NULL, NULL},

    // BOOL SymInitialized

    FALSE,

    // DWORD SymOptions
         
    SYMOPT_UNDNAME,

    // ULONG LastSymLoadError

    0,

    // char DebugModule[MAX_SYM_NAME + 1];

    "",

    // PREAD_PROCESS_MEMORY_ROUTINE ImagepUserReadMemory32

    NULL,

    // PFUNCTION_TABLE_ACCESS_ROUTINE ImagepUserFunctionTableAccess32

    NULL,

    // PGET_MODULE_BASE_ROUTINE ImagepUserGetModuleBase32

    NULL,

    // PTRANSLATE_ADDRESS_ROUTINE ImagepUserTranslateAddress32
    
    NULL,

    // HWND hwndParent;

    0,

    // int hLog;

    0,

    // BOOL fdbgout;

    false,

    // BOOL fbp;

    false,   // set this to true and dbghelp internal debugging breakpoints will fire

    // BOOL fCoInit

    false,

    // char HomeDir[MAX_PATH + 1]

    "",

    // char SymDir[MAX_PATH + 1]

    "",

    // char SrcDir[MAX_PATH + 1]

    "",

#endif
};

#ifdef BUILD_DBGHELP

void 
tlsInit(PTLS ptls)
{
    ZeroMemory(ptls, sizeof(TLS));
}

PTLS 
GetTlsPtr(void)
{
    PTLS ptls = (PTLS)TlsGetValue(g.tlsIndex);
    if (!ptls) {
        ptls = (PTLS)MemAlloc(sizeof(TLS));
        if (ptls) {
            TlsSetValue(g.tlsIndex, ptls); 
            tlsInit(ptls);
        }
    }
    
    assert(ptls);

    if (!ptls) {
        static TLS sos_tls;
        ptls = &sos_tls;
    }  

    return ptls;
}

#endif // #ifdef BUILD_DBGHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\globals.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This module implements all global variables used in dbghelp.dll

Author:

    Pat Styles (patst) 14-July-2000

Revision History:

--*/

#ifdef GLOBALS
#include <private.h>
#include <symbols.h>
#endif

typedef struct {
    HINSTANCE                       hinst;
    HANDLE                          hHeap;
    DWORD                           tlsIndex;
#ifdef IMAGEHLP_HEAP_DEBUG
    LIST_ENTRY                      HeapHeader;
    ULONG_PTR                       TotalMemory;
    ULONG                           TotalAllocs;
#endif
    OSVERSIONINFO                   OSVerInfo;
    API_VERSION                     ApiVersion;
    API_VERSION                     AppVersion;
    ULONG                           MachineType;
    CRITICAL_SECTION                threadlock;
#ifdef BUILD_DBGHELP
    HINSTANCE                       hSymSrv;
    PSYMBOLSERVERPROC               fnSymbolServer;
    PSYMBOLSERVERCLOSEPROC          fnSymbolServerClose;
    PSYMBOLSERVERSETOPTIONSPROC     fnSymbolServerSetOptions;
    PSYMBOLSERVERPINGPROC           fnSymbolServerPing;
    HINSTANCE                       hSrcSrv;
    PSRCSRVINITPROC                 fnSrcSrvInit;
    PSRCSRVCLEANUPPROC              fnSrcSrvCleanup;
    PSRCSRVSETTARGETPATHPROC        fnSrcSrvSetTargetPath;
    PSRCSRVSETOPTIONSPROC           fnSrcSrvSetOptions;
    PSRCSRVGETOPTIONSPROC           fnSrcSrvGetOptions;
    PSRCSRVLOADMODULEPROC           fnSrcSrvLoadModule;
    PSRCSRVUNLOADMODULEPROC         fnSrcSrvUnloadModule;
    PSRCSRVREGISTERCALLBACKPROC     fnSrcSrvRegisterCallback;
    PSRCSRVGETFILEPROC              fnSrcSrvGetFile;
    DWORD                           cProcessList;
    LIST_ENTRY                      ProcessList;
    BOOL                            SymInitialized;
    DWORD                           SymOptions;
    ULONG                           LastSymLoadError;
    char                            DebugToken[MAX_SYM_NAME + 1];
    PREAD_PROCESS_MEMORY_ROUTINE    ImagepUserReadMemory32;
    PFUNCTION_TABLE_ACCESS_ROUTINE  ImagepUserFunctionTableAccess32;
    PGET_MODULE_BASE_ROUTINE        ImagepUserGetModuleBase32;
    PTRANSLATE_ADDRESS_ROUTINE      ImagepUserTranslateAddress32;
    HWND                            hwndParent;
    int                             hLog;
    BOOL                            fdbgout;
    BOOL                            fbp;    // set this to true and dbghelp internal debugging breakpoints will fire
    BOOL                            fCoInit; // set to true if CoInitialize was called.
    char                            HomeDir[MAX_PATH + 1];
    char                            SymDir[MAX_PATH + 1];
    char                            SrcDir[MAX_PATH + 1];
#endif
} GLOBALS, *PGLOBALS;

typedef struct {
    DWORD                           tid;
#ifdef BUILD_DBGHELP
    PREAD_PROCESS_MEMORY_ROUTINE    ImagepUserReadMemory32;
    PFUNCTION_TABLE_ACCESS_ROUTINE  ImagepUserFunctionTableAccess32;
    PGET_MODULE_BASE_ROUTINE        ImagepUserGetModuleBase32;
    PTRANSLATE_ADDRESS_ROUTINE      ImagepUserTranslateAddress32;
    IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY AlphaFunctionEntry64;
    BOOL                            DebugFunctionEntries;
    class Ia64FunctionEntryCache*   Ia64FunctionEntries;
    class Amd64FunctionEntryCache*  Amd64FunctionEntries;
    class Axp32FunctionEntryCache*  Axp32FunctionEntries;
    class Axp64FunctionEntryCache*  Axp64FunctionEntries;
    class ArmFunctionEntryCache*    ArmFunctionEntries;
    IMAGE_IA64_RUNTIME_FUNCTION_ENTRY Ia64FunctionEntry;
    _IMAGE_RUNTIME_FUNCTION_ENTRY   Amd64FunctionEntry;
    IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Axp64FunctionEntry;
    IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY ArmFunctionEntry;
    IMAGE_FUNCTION_ENTRY            FunctionEntry32;
    IMAGE_FUNCTION_ENTRY64          FunctionEntry64;
    VWNDIA64_UNWIND_CONTEXT         UnwindContext[VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE];
    UINT                            UnwindContextNew;
#endif
} TLS, *PTLS;


extern GLOBALS g;

extern PTLS GetTlsPtr(void);
#define tlsvar(a) (GetTlsPtr()->a)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\fecache.c ===
//----------------------------------------------------------------------------
//
// Function entry cache.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntimage.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#include "private.h"
#include "symbols.h"
#include "globals.h"

#include "fecache.hpp"

//----------------------------------------------------------------------------
//
// FunctionEntryCache.
//
//----------------------------------------------------------------------------

FunctionEntryCache::FunctionEntryCache(ULONG ImageDataSize,
                                       ULONG CacheDataSize,
                                       ULONG Machine)
{
    m_ImageDataSize = ImageDataSize;
    m_CacheDataSize = CacheDataSize;
    m_Machine = Machine;

    m_Entries = NULL;
}

FunctionEntryCache::~FunctionEntryCache(void)
{
    if (m_Entries != NULL)
    {
        MemFree(m_Entries);
    }
}

BOOL
FunctionEntryCache::Initialize(ULONG MaxEntries, ULONG ReplaceAt)
{
    // Already initialized.
    if (m_Entries != NULL) {
        return TRUE;
    }
    
    m_Entries = (FeCacheEntry*)MemAlloc(sizeof(FeCacheEntry) * MaxEntries);
    if (m_Entries == NULL) {
        return FALSE;
    }

    m_MaxEntries = MaxEntries;
    m_ReplaceAt = ReplaceAt;

    m_Used = 0;
    m_Next = 0;

    return TRUE;
}

FeCacheEntry*
FunctionEntryCache::Find(
    HANDLE                           Process,
    ULONG64                          CodeOffset,
    PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
    PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
    )
{
    FeCacheEntry* FunctionEntry;

    FE_DEBUG(("\nFunctionEntryCache::Find(ControlPc=%.8I64x, Machine=%X)\n",
              CodeOffset, m_Machine));

    // Look for a static or dynamic function entry.
    FunctionEntry = FindDirect( Process, CodeOffset, ReadMemory,
                                GetModuleBase, GetFunctionEntry );
    if (FunctionEntry == NULL) {
        return NULL;
    }

    //
    // The capability exists for more than one function entry
    // to map to the same function. This permits a function to
    // have discontiguous code segments described by separate
    // function table entries. If the ending prologue address
    // is not within the limits of the begining and ending
    // address of the function table entry, then the prologue
    // ending address is the address of the primary function
    // table entry that accurately describes the ending prologue
    // address.
    //

    FunctionEntry = SearchForPrimaryEntry(FunctionEntry, Process, ReadMemory,
                                          GetModuleBase, GetFunctionEntry);

#if DBG
    if (tlsvar(DebugFunctionEntries)) {
        if (FunctionEntry == NULL) {
            dbPrint("FunctionEntryCache::Find returning NULL\n");
        } else {
            if (FunctionEntry->Address) {
                dbPrint("FunctionEntryCache::Find returning "
                        "FunctionEntry=%.8I64x %s\n",
                        FunctionEntry->Address,
                        FunctionEntry->Description);
            } else {
                dbPrint("FunctionEntryCache::Find returning "
                        "FunctionEntry=%.8I64x %s\n",
                        (ULONG64)(LONG64)(LONG_PTR)FunctionEntry,
                        FunctionEntry->Description);
            }
        }
    }
#endif

    return FunctionEntry;
}

FeCacheEntry*
FunctionEntryCache::FindDirect(
    HANDLE                           Process,
    ULONG64                          CodeOffset,
    PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
    PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
    )
{
    FeCacheEntry* FunctionEntry;
    ULONG64 ModuleBase;

    //
    // Look for function entry in static function tables.
    //

    FunctionEntry = FindStatic( Process, CodeOffset, ReadMemory,
                                GetModuleBase, GetFunctionEntry,
                                &ModuleBase );

    FE_DEBUG(("  FindDirect: ControlPc=0x%I64x functionEntry=0x%p\n"
              "  FindStatic  %s\n", CodeOffset, FunctionEntry, 
              FunctionEntry != NULL ? "succeeded" : "FAILED"));

    if (FunctionEntry != NULL) {
        return FunctionEntry;
    }

    //
    // If not in static image range and no static function entry
    // found use FunctionEntryCallback routine (if present) for
    // dynamic function entry or some other source of pdata (e.g.
    // saved pdata information for ROM images).
    //

    PPROCESS_ENTRY ProcessEntry = FindProcessEntry( Process );
    if (ProcessEntry == NULL) {
        return NULL;
    }

    PVOID RawEntry;
    
    if (!ModuleBase) {
        if (!IsImageMachineType64(m_Machine) &&
            ProcessEntry->pFunctionEntryCallback32) {
            RawEntry = ProcessEntry->pFunctionEntryCallback32
                (Process, (ULONG)CodeOffset,
                 (PVOID)ProcessEntry->FunctionEntryUserContext);
        } else if (ProcessEntry->pFunctionEntryCallback64) {
            RawEntry = ProcessEntry->pFunctionEntryCallback64
                (Process, CodeOffset, ProcessEntry->FunctionEntryUserContext);
            if (RawEntry != NULL) {
                FunctionEntry = FillTemporary(Process, RawEntry);
                FE_SET_DESC(FunctionEntry, "from FunctionEntryCallback64");
            }
        }

        if (FunctionEntry != NULL) {
            FE_DEBUG(("  FindDirect: got dynamic entry\n"));
        } else if (GetFunctionEntry != NULL) {
                
            // VC 6 didn't supply a GetModuleBase callback so this code is
            // to make stack walking backward compatible.
            //
            // If we don't have a function by now, use the old-style function
            // entry callback and let VC give it to us. Note that MSDN
            // documentation indicates that this callback should return
            // a 3-field IMAGE_FUNCTION_ENTRY structure, but VC 6 actually
            // returns the 5-field IMAGE_RUNTIME_FUNCTION_ENTRY. Since
            // the purpose of this hack is to make VC 6 work just go with the
            // way VC 6 does it rather than what MSDN says.

            RawEntry = GetFunctionEntry(Process, CodeOffset);
            if (RawEntry != NULL) {
                FunctionEntry = FillTemporary(Process, RawEntry);
                FE_SET_DESC(FunctionEntry, "from GetFunctionEntry");
                FE_DEBUG(("  FindDirect: got user entry\n"));
            }
        }
    } else {

        // Nothing has turned up a function entry but we do have a
        // module base address. One possibility is that this is the
        // kernel debugger and the pdata section is not paged in.
        // The last ditch attempt for a function entry will be an
        // internal dbghelp call to get the pdata entry from the
        // debug info. This is not great because the data in the debug
        // section is incomplete and potentially out of date, but in
        // most cases it works and makes it possible to get user-mode
        // stack traces in the kernel debugger.

        PIMGHLP_RVA_FUNCTION_DATA RvaEntry =
            GetFunctionEntryFromDebugInfo( ProcessEntry, CodeOffset );
        if (RvaEntry != NULL) {
            FeCacheData Data;

            TranslateRvaDataToRawData(RvaEntry, ModuleBase, &Data);
            FunctionEntry = FillTemporary(Process, &Data);
            FE_SET_DESC(FunctionEntry, "from GetFunctionEntryFromDebugInfo");
            FE_DEBUG(("  FindDirect: got debug info entry\n"));
        }
    }

    return FunctionEntry;
}

FeCacheEntry*
FunctionEntryCache::FindStatic(
    HANDLE                           Process,
    ULONG64                          CodeOffset,
    PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
    PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry,
    PULONG64                         ModuleBase
    )
{
    ULONG RelCodeOffset;

    *ModuleBase = GetModuleBase( Process, CodeOffset );
    if (CodeOffset - *ModuleBase > 0xffffffff) {
        return NULL;
    }

    RelCodeOffset = (ULONG)(CodeOffset - *ModuleBase);
    
    FE_DEBUG(("  FindStatic: ControlPc=0x%I64x ImageBase=0x%I64x\n"
              "              biasedControlPc=0x%lx\n", 
              CodeOffset, *ModuleBase, RelCodeOffset));

    FeCacheEntry* FunctionEntry;
    ULONG Index;

    //
    // Check the array of recently fetched function entries
    //

    FunctionEntry = m_Entries;
    for (Index = 0; Index < m_Used; Index++) {
        
        if (FunctionEntry->Process == Process &&
            FunctionEntry->ModuleBase == *ModuleBase &&
            RelCodeOffset >= FunctionEntry->RelBegin &&
            RelCodeOffset <  FunctionEntry->RelEnd) {

            FE_DEBUG(("  FindStatic: cache hit - index=%ld\n", Index));
            return FunctionEntry;
        }

        FunctionEntry++;
    }

    //
    // If an image was found that included the specified code, then locate the
    // function table for the image.
    //

    if (*ModuleBase == 0) {
        return NULL;
    }
    
    ULONG64 FunctionTable;
    ULONG SizeOfFunctionTable;
    
    FunctionTable = FunctionTableBase( Process, ReadMemory, *ModuleBase,
                                       &SizeOfFunctionTable );
    if (FunctionTable == NULL) {
        return NULL;
    }

    FE_DEBUG(("  FindStatic: functionTable=0x%I64x "
              "sizeOfFunctionTable=%ld count:%ld\n", 
              FunctionTable, SizeOfFunctionTable,
              SizeOfFunctionTable / m_ImageDataSize));

    LONG High;
    LONG Low;
    LONG Middle;

    //
    // If a function table is located, then search the function table
    // for a function table entry for the specified code offset.
    //

    Low = 0;
    High = (SizeOfFunctionTable / m_ImageDataSize) - 1;

    //
    // Perform binary search on the function table for a function table
    // entry that subsumes the specified code offset.
    //

    while (High >= Low) {

        //
        // Compute next probe index and test entry. If the specified PC
        // is greater than of equal to the beginning address and less
        // than the ending address of the function table entry, then
        // return the address of the function table entry. Otherwise,
        // continue the search.
        //

        Middle = (Low + High) >> 1;

        ULONG64 NextFunctionTableEntry = FunctionTable +
            Middle * m_ImageDataSize;

        //
        // Fetch the function entry and bail if there is an error reading it
        //

        FunctionEntry = ReadImage( Process, NextFunctionTableEntry,
                                   ReadMemory, GetModuleBase );
        if (FunctionEntry == NULL) {
            FE_DEBUG(("  FindStatic: ReadImage "
                      "functionEntryAddress=0x%I64x FAILED\n",
                      NextFunctionTableEntry));
            return NULL;
        }

        if (RelCodeOffset < FunctionEntry->RelBegin) {
            High = Middle - 1;
        } else if (RelCodeOffset >= FunctionEntry->RelEnd) {
            Low = Middle + 1;
        } else {
            return Promote( FunctionEntry );
        }
    }

    return NULL;
}

FeCacheEntry*
FunctionEntryCache::ReadImage(
    HANDLE                         Process,
    ULONG64                        Address,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    PGET_MODULE_BASE_ROUTINE64     GetModuleBase
    )
{
    FeCacheEntry* FunctionEntry;
    ULONG Index;

    // Check the array of recently fetched function entries.

    FunctionEntry = m_Entries;
    for (Index = 0; Index < m_Used; Index++) {
        
        if (FunctionEntry->Process == Process &&
            FunctionEntry->Address == Address ) {
            
            return FunctionEntry;
        }

        FunctionEntry++;
    }

    FeCacheData Data;
    DWORD Done;

    if (!ReadMemory(Process, Address, &Data, m_ImageDataSize, &Done) ||
        Done != m_ImageDataSize) {
        return NULL;
    }
    
    // If not in the cache, replace the entry that m_Next
    // points to. m_Next cycles through the last part of the
    // table and function entries we want to keep are promoted to the first
    // part of the table so they don't get overwritten by new ones being read
    // as part of the binary search through function entry tables.

    if (m_Used < m_MaxEntries) {
        m_Used++;
        m_Next = m_Used;
    } else {
        m_Next++;
        if (m_Next >= m_MaxEntries) {
            m_Next = m_ReplaceAt + 1;
        }
    }

    FunctionEntry = m_Entries + (m_Next - 1);

    FunctionEntry->Data = Data;
    FunctionEntry->Address = Address;
    FunctionEntry->Process = Process;
    FunctionEntry->ModuleBase = GetModuleBase(Process, Address);
    FE_SET_DESC(FunctionEntry, "from target process");

    // Translate after all other information is filled in so
    // the translation routine can use it.
    TranslateRawData(FunctionEntry);

    return FunctionEntry;
}

void
FunctionEntryCache::InvalidateProcessOrModule(HANDLE Process, ULONG64 Base)
{
    FeCacheEntry* FunctionEntry;
    ULONG Index;

    FunctionEntry = m_Entries;
    Index = 0;
    while (Index < m_Used) {
        
        if (FunctionEntry->Process == Process &&
            (Base == 0 || FunctionEntry->ModuleBase == Base)) {

            // Pull the last entry down into this slot
            // to keep things packed.  There's no need
            // to update m_Next as this will open a
            // new slot for use and m_Next will be reset
            // when it is used.
            *FunctionEntry = m_Entries[--m_Used];
        } else {
            Index++;
            FunctionEntry++;
        }
    }
}

FeCacheEntry*
FunctionEntryCache::Promote(FeCacheEntry* Entry)
{
    ULONG Index;
    ULONG Move;

    Index = (ULONG)(Entry - m_Entries);

    // Make sure it's promoted out of the temporary area.
    if (Index >= m_ReplaceAt) {
        Move = Index - (m_ReplaceAt - 3);
    } else {
        Move = ( Index >= 3 ) ? 3 : 1;
    }

    if (Index > Move) {
        FeCacheEntry Temp = *Entry;
        *Entry = m_Entries[Index - Move];
        m_Entries[Index - Move] = Temp;
        Index -= Move;
    }

    return m_Entries + Index;
}

ULONG64
FunctionEntryCache::FunctionTableBase(
    HANDLE                         Process,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    ULONG64                        Base,
    PULONG                         Size
    )
{
    ULONG64 NtHeaders;
    ULONG64 ExceptionDirectoryEntryAddress;
    IMAGE_DATA_DIRECTORY ExceptionData;
    IMAGE_DOS_HEADER DosHeaderData;
    DWORD Done;

    // Read DOS header to calculate the address of the NT header.

    if (!ReadMemory( Process, Base, &DosHeaderData, sizeof(DosHeaderData),
                     &Done ) ||
        Done != sizeof(DosHeaderData)) {
        return 0;
    }
    if (DosHeaderData.e_magic != IMAGE_DOS_SIGNATURE) {
        return 0;
    }

    NtHeaders = Base + DosHeaderData.e_lfanew;

    if (IsImageMachineType64(m_Machine)) {
        ExceptionDirectoryEntryAddress = NtHeaders +
            FIELD_OFFSET(IMAGE_NT_HEADERS64,OptionalHeader) +
            FIELD_OFFSET(IMAGE_OPTIONAL_HEADER64,DataDirectory) +
            IMAGE_DIRECTORY_ENTRY_EXCEPTION * sizeof(IMAGE_DATA_DIRECTORY);
    } else {
        ExceptionDirectoryEntryAddress = NtHeaders +
            FIELD_OFFSET(IMAGE_NT_HEADERS32,OptionalHeader) +
            FIELD_OFFSET(IMAGE_OPTIONAL_HEADER32,DataDirectory) +
            IMAGE_DIRECTORY_ENTRY_EXCEPTION * sizeof(IMAGE_DATA_DIRECTORY);
    }

    // Read NT header to get the image data directory.

    if (!ReadMemory( Process, ExceptionDirectoryEntryAddress, &ExceptionData,
                     sizeof(IMAGE_DATA_DIRECTORY), &Done ) ||
        Done != sizeof(IMAGE_DATA_DIRECTORY)) {
        return 0;
    }

    *Size = ExceptionData.Size;
    return Base + ExceptionData.VirtualAddress;

}

FeCacheEntry*
FunctionEntryCache::SearchForPrimaryEntry(
    FeCacheEntry* CacheEntry,
    HANDLE Process,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    PGET_MODULE_BASE_ROUTINE64 GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
    )
{
    // Assume all entries are primary.
    return CacheEntry;
}

//----------------------------------------------------------------------------
//
// Ia64FunctionEntryCache.
//
//----------------------------------------------------------------------------

void
Ia64FunctionEntryCache::TranslateRawData(FeCacheEntry* Entry)
{
    Entry->RelBegin = Entry->Data.Ia64.BeginAddress & ~15;
    Entry->RelEnd = (Entry->Data.Ia64.EndAddress + 15) & ~15;
}

void
Ia64FunctionEntryCache::TranslateRvaDataToRawData
    (PIMGHLP_RVA_FUNCTION_DATA RvaData, ULONG64 ModuleBase,
     FeCacheData* Data)
{
    Data->Ia64.BeginAddress = RvaData->rvaBeginAddress;
    Data->Ia64.EndAddress = RvaData->rvaEndAddress;
    Data->Ia64.UnwindInfoAddress = RvaData->rvaPrologEndAddress;
}

#if DBG

void
ShowRuntimeFunctionIa64(
    FeCacheEntry* FunctionEntry,
    PSTR Label
    )
{
    if (!tlsvar(DebugFunctionEntries)) {
        return;
    }
    
    if ( FunctionEntry ) {
        if (FunctionEntry->Address) {
            dbPrint("    0x%I64x: %s\n", FunctionEntry->Address,
                    Label ? Label : "" );
        } 
        else {
            dbPrint("    %s\n", Label ? Label : "" );
        }
        dbPrint("    BeginAddress      = 0x%x\n"
                "    EndAddress        = 0x%x\n"
                "    UnwindInfoAddress = 0x%x\n",
                FunctionEntry->Data.Ia64.BeginAddress,
                FunctionEntry->Data.Ia64.EndAddress,
                FunctionEntry->Data.Ia64.UnwindInfoAddress );    
    }
    else {
        dbPrint("   FunctionEntry NULL: %s\n", Label ? Label : "" );
    }
}

#endif // #if DBG

//----------------------------------------------------------------------------
//
// Amd64FunctionEntryCache.
//
//----------------------------------------------------------------------------

void
Amd64FunctionEntryCache::TranslateRawData(FeCacheEntry* Entry)
{
    Entry->RelBegin = Entry->Data.Amd64.BeginAddress;
    Entry->RelEnd = Entry->Data.Amd64.EndAddress;
}

void
Amd64FunctionEntryCache::TranslateRvaDataToRawData
    (PIMGHLP_RVA_FUNCTION_DATA RvaData, ULONG64 ModuleBase,
     FeCacheData* Data)
{
    Data->Amd64.BeginAddress = RvaData->rvaBeginAddress;
    Data->Amd64.EndAddress = RvaData->rvaEndAddress;
    Data->Amd64.UnwindInfoAddress = RvaData->rvaPrologEndAddress;
}

//----------------------------------------------------------------------------
//
// ArmFunctionEntryCache.
//
//----------------------------------------------------------------------------

void
ArmFunctionEntryCache::TranslateRawData(FeCacheEntry* Entry)
{
    Entry->RelBegin = (ULONG)
        ((Entry->Data.Arm.BeginAddress & ~1) - Entry->ModuleBase);
    Entry->RelEnd = (ULONG)
        ((Entry->Data.Arm.EndAddress & ~1) - Entry->ModuleBase);
}

void
ArmFunctionEntryCache::TranslateRvaDataToRawData
    (PIMGHLP_RVA_FUNCTION_DATA RvaData, ULONG64 ModuleBase,
     FeCacheData* Data)
{
    Data->Arm.BeginAddress = (ULONG)(ModuleBase + RvaData->rvaBeginAddress);
    Data->Arm.EndAddress = (ULONG)(ModuleBase + RvaData->rvaEndAddress);
    Data->Arm.ExceptionHandler = 0;
    Data->Arm.HandlerData = 0;
    Data->Arm.PrologEndAddress =
        (ULONG)(ModuleBase + RvaData->rvaPrologEndAddress);
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

FunctionEntryCache*
GetFeCache(ULONG Machine, BOOL Create)
{
    FunctionEntryCache* Cache;
    
    switch(Machine) {
    case IMAGE_FILE_MACHINE_AMD64:
        if (tlsvar(Amd64FunctionEntries) == NULL && Create) {
            tlsvar(Amd64FunctionEntries) = new Amd64FunctionEntryCache;
            if (tlsvar(Amd64FunctionEntries) == NULL) {
                return NULL;
            }
        }
        Cache = tlsvar(Amd64FunctionEntries);
        break;
    case IMAGE_FILE_MACHINE_IA64:
        if (tlsvar(Ia64FunctionEntries) == NULL && Create) {
            tlsvar(Ia64FunctionEntries) = new Ia64FunctionEntryCache;
            if (tlsvar(Ia64FunctionEntries) == NULL) {
                return NULL;
            }
        }
        Cache = tlsvar(Ia64FunctionEntries);
        break;
    case IMAGE_FILE_MACHINE_ARM:
        if (tlsvar(ArmFunctionEntries) == NULL && Create) {
            tlsvar(ArmFunctionEntries) = new ArmFunctionEntryCache;
            if (tlsvar(ArmFunctionEntries) == NULL) {
                return NULL;
            }
        }
        Cache = tlsvar(ArmFunctionEntries);
        break;
    default:
        return NULL;
    }

    if (Cache && !Cache->Initialize(60, 40)) {
        return NULL;
    }

    return Cache;
}

void
ClearFeCaches(void)
{
    if (tlsvar(Ia64FunctionEntries)) {
        delete (Ia64FunctionEntryCache*)tlsvar(Ia64FunctionEntries);
        tlsvar(Ia64FunctionEntries) = NULL;
    }
    if (tlsvar(Amd64FunctionEntries)) {
        delete (Amd64FunctionEntryCache*)tlsvar(Amd64FunctionEntries);
        tlsvar(Amd64FunctionEntries) = NULL;
    }
    if (tlsvar(ArmFunctionEntries)) {
        delete (ArmFunctionEntryCache*)tlsvar(ArmFunctionEntries);
        tlsvar(ArmFunctionEntries) = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\imagecfg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    imagecfg.c

Abstract:

    This function change the image loader configuration information in an image file.

Author:

    Steve Wood (stevewo)   8-Nov-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>

struct {
    DWORD Flag;
    LPSTR ClearPrefix;
    LPSTR SetPrefix;
    LPSTR Description;
} NtGlobalFlagNames[] = {
    {FLG_STOP_ON_EXCEPTION,             "Don't ", "", "Stop on exception"},
    {FLG_SHOW_LDR_SNAPS,                "Don't ", "", "Show Loader Debugging Information"},
    {FLG_DEBUG_INITIAL_COMMAND,         "Don't ", "", "Debug Initial Command (WINLOGON)"},
    {FLG_STOP_ON_HUNG_GUI,              "Don't ", "", "Stop on Hung GUI"},
    {FLG_HEAP_ENABLE_TAIL_CHECK,        "Disable", "Enable", " Heap Tail Checking"},
    {FLG_HEAP_ENABLE_FREE_CHECK,        "Disable", "Enable", " Heap Free Checking"},
    {FLG_HEAP_VALIDATE_PARAMETERS,      "Disable", "Enable", " Heap Parameter Validation"},
    {FLG_HEAP_VALIDATE_ALL,             "Disable", "Enable", " Heap Validate on Call"},
    {FLG_POOL_ENABLE_TAGGING,           "Disable", "Enable", " Pool Tagging"},
    {FLG_HEAP_ENABLE_TAGGING,           "Disable", "Enable", " Heap Tagging"},
    {FLG_USER_STACK_TRACE_DB,           "Disable", "Enable", " User Mode Stack Backtrace DB (x86 checked only)"},
    {FLG_KERNEL_STACK_TRACE_DB,         "Disable", "Enable", " Kernel Mode Stack Backtrace DB (x86 checked only)"},
    {FLG_MAINTAIN_OBJECT_TYPELIST,      "Don't ", "", "Maintain list of kernel mode objects by type"},
    {FLG_HEAP_ENABLE_TAG_BY_DLL,        "Disable", "Enable", " Heap DLL Tagging"},
    {FLG_ENABLE_CSRDEBUG,               "Disable", "Enable", " Debugging of CSRSS"},
    {FLG_ENABLE_KDEBUG_SYMBOL_LOAD,     "Disable", "Enable", " Kernel Debugger Symbol load"},
    {FLG_DISABLE_PAGE_KERNEL_STACKS,    "Enable", "Disable", " Paging of Kernel Stacks"},
    {FLG_HEAP_DISABLE_COALESCING,       "Enable", "Disable", " Heap Coalescing on Free"},
    {FLG_ENABLE_CLOSE_EXCEPTIONS,       "Disable", "Enable", " Close Exceptions"},
    {FLG_ENABLE_EXCEPTION_LOGGING,      "Disable", "Enable", " Exception Logging"},
    {FLG_ENABLE_HANDLE_TYPE_TAGGING,    "Disable", "Enable", " Handle type tagging"},
    {FLG_HEAP_PAGE_ALLOCS,              "Disable", "Enable", " Heap page allocs"},
    {FLG_DEBUG_INITIAL_COMMAND_EX,      "Disable", "Enable", " Extended debug initial command"},
    {FLG_DISABLE_DBGPRINT,              "Enable",  "Disable"," DbgPrint to debugger"},
    {0, NULL}
};

void
DisplayGlobalFlags(
    LPSTR IndentString,
    DWORD NtGlobalFlags,
    BOOLEAN Set
    )
{
    ULONG i;

    for (i=0; NtGlobalFlagNames[i].Description; i++) {
        if (NtGlobalFlagNames[i].Flag & NtGlobalFlags) {
            printf( "%s%s%s\n",
                    IndentString,
                    Set ? NtGlobalFlagNames[i].SetPrefix :
                    NtGlobalFlagNames[i].ClearPrefix,
                    NtGlobalFlagNames[i].Description
                  );
        }
    }

    return;
}

BOOL fVerbose;
BOOL fUsage;

BOOL fConfigInfoChanged;
BOOL fImageHasConfigInfo;
BOOL fImageHeaderChanged;

LPSTR CurrentImageName;
BOOL f64bitImage;
LOADED_IMAGE CurrentImage;
PIMAGE_LOAD_CONFIG_DIRECTORY pConfigInfo;
CHAR DebugFilePath[_MAX_PATH];
LPSTR SymbolPath;
ULONG GlobalFlagsClear;
ULONG GlobalFlagsSet;
ULONG CriticalSectionDefaultTimeout;
ULONG ProcessHeapFlags;
ULONG MajorSubsystemVersion;
ULONG MinorSubsystemVersion;
ULONG Win32VersionValue;
ULONG Win32CSDVerValue;
BOOLEAN fUniprocessorOnly;
BOOLEAN fRestrictedWorkingSet;
BOOLEAN fEnableLargeAddresses;
BOOLEAN fNoBind;
BOOLEAN fEnableTerminalServerAware;
BOOLEAN fDisableTerminalServerAware;
BOOLEAN fSwapRunNet;
BOOLEAN fSwapRunCD;
BOOLEAN fQuiet;

ULONGLONG DeCommitFreeBlockThreshold;
ULONGLONG DeCommitTotalFreeThreshold;
ULONGLONG MaximumAllocationSize;
ULONGLONG VirtualMemoryThreshold;
ULONGLONG ImageProcessAffinityMask;  
ULONGLONG SizeOfStackReserve;
ULONGLONG SizeOfStackCommit;

VOID
DisplayImageInfo(
                BOOL HasConfigInfo
                );

PVOID
GetAddressOfExportedData(
                        PLOADED_IMAGE Dll,
                        LPSTR ExportedName
                        );

ULONGLONG
ConvertNum(
    char *s
    )
{
    ULONGLONG result;
    int n;
    if (!_strnicmp( s, "0x", 2 )) {
        s += 2;
        n = sscanf( s, "%I64x", &result );
    }
    else  {
        n = sscanf( s, "%I64d", &result );
    }
    return( ( n != 1 )  ? 0 : result );

} // ConvertNum()

__inline PVOID
GetVaForRva(
           PLOADED_IMAGE Image,
           ULONG Rva
           )
{
    PVOID Va;

    Va = ImageRvaToVa( Image->FileHeader,
                       Image->MappedAddress,
                       Rva,
                       &Image->LastRvaSection
                     );
    return Va;
}


PVOID
GetAddressOfExportedData(
                        PLOADED_IMAGE Dll,
                        LPSTR ExportedName
                        )
{
    PIMAGE_EXPORT_DIRECTORY Exports;
    ULONG ExportSize;
    USHORT HintIndex;
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    LPSTR NameTableName;

    Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData( (PVOID)Dll->MappedAddress,
                                                                  FALSE,
                                                                  IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                                  &ExportSize
                                                                );
    if (Exports) {
        NameTableBase = (PULONG)GetVaForRva( Dll, Exports->AddressOfNames );
        NameOrdinalTableBase = (PUSHORT)GetVaForRva( Dll, Exports->AddressOfNameOrdinals );
        FunctionTableBase = (PULONG)GetVaForRva( Dll, Exports->AddressOfFunctions );
        if (NameTableBase != NULL &&
            NameOrdinalTableBase != NULL &&
            FunctionTableBase != NULL
           ) {
            for (HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++) {
                NameTableName = (LPSTR)GetVaForRva( Dll, NameTableBase[ HintIndex ] );
                if (NameTableName) {
                    if (!strcmp( ExportedName, NameTableName )) {
                        OrdinalNumber = NameOrdinalTableBase[ HintIndex ];
                        return FunctionTableBase[ OrdinalNumber ] + Dll->MappedAddress;
                    }
                }
            }
        }
    }

    return NULL;
}


VOID
DisplayConfigInfo32(PIMAGE_LOAD_CONFIG_DIRECTORY32 LoadConfig) 
{
    if (LoadConfig->GlobalFlagsClear) {
        printf( "    NtGlobalFlags to clear: %08x\n", LoadConfig->GlobalFlagsClear);
        DisplayGlobalFlags( "        ", LoadConfig->GlobalFlagsClear, FALSE );
    }

    if (LoadConfig->GlobalFlagsSet) {
        printf( "    NtGlobalFlags to set:   %08x\n", LoadConfig->GlobalFlagsSet);
        DisplayGlobalFlags( "        ", LoadConfig->GlobalFlagsSet, TRUE );
    }

    if (LoadConfig->CriticalSectionDefaultTimeout) {
        printf( "    Default Critical Section Timeout: %u milliseconds\n", LoadConfig->CriticalSectionDefaultTimeout);
    }

    if (LoadConfig->DeCommitFreeBlockThreshold) {
        printf( "    Process Heap DeCommit Free Block threshold: %08x\n", (DWORD)LoadConfig->DeCommitFreeBlockThreshold);
    }

    if (LoadConfig->DeCommitTotalFreeThreshold) {
        printf( "    Process Heap DeCommit Total Free threshold: %08x\n", (DWORD)LoadConfig->DeCommitTotalFreeThreshold);
    }

    if (LoadConfig->LockPrefixTable) {
        printf( "    Lock Prefix Table: %x\n", LoadConfig->LockPrefixTable);
    }

    if (LoadConfig->MaximumAllocationSize) {
        printf( "    Process Heap Maximum Allocation Size: %08x\n", LoadConfig->MaximumAllocationSize);
    }

    if (LoadConfig->VirtualMemoryThreshold) {
        printf( "    Process Heap VirtualAlloc Threshold: %08x\n", LoadConfig->VirtualMemoryThreshold);
    }

    if (LoadConfig->ProcessHeapFlags) {
        printf( "    Process Heap Flags: %08x\n", LoadConfig->ProcessHeapFlags);
    }

    if (LoadConfig->ProcessAffinityMask) {
        printf( "    Process Affinity Mask: %08x\n", LoadConfig->ProcessAffinityMask);
    }

    if (LoadConfig->CSDVersion) {
        printf( "    CSD version: %d\n", LoadConfig->CSDVersion);
    }

    if (LoadConfig->Size >= FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerCount)) {
        if (LoadConfig->SecurityCookie) {
            printf( "    Security Cookie offset: %x\n", LoadConfig->SecurityCookie);
        }

        if (LoadConfig->SEHandlerTable) {
            printf( "    SEH handler table: %x\n", LoadConfig->SEHandlerTable);
        }

        if (LoadConfig->SEHandlerCount) {
            printf( "    SEH Handler count: %d\n", LoadConfig->SEHandlerCount);
        }
    }
}

VOID
DisplayConfigInfo64(PIMAGE_LOAD_CONFIG_DIRECTORY64 LoadConfig) 
{
    if (LoadConfig->GlobalFlagsClear) {
        printf( "    NtGlobalFlags to clear: %08x\n", LoadConfig->GlobalFlagsClear);
        DisplayGlobalFlags( "        ", LoadConfig->GlobalFlagsClear, FALSE );
    }

    if (LoadConfig->GlobalFlagsSet) {
        printf( "    NtGlobalFlags to set:   %08x\n", LoadConfig->GlobalFlagsSet);
        DisplayGlobalFlags( "        ", LoadConfig->GlobalFlagsSet, TRUE );
    }

    if (LoadConfig->CriticalSectionDefaultTimeout) {
        printf( "    Default Critical Section Timeout: %u milliseconds\n", LoadConfig->CriticalSectionDefaultTimeout);
    }

    if (LoadConfig->DeCommitFreeBlockThreshold) {
        printf( "    Process Heap DeCommit Free Block threshold: %I64x\n", LoadConfig->DeCommitFreeBlockThreshold);
    }

    if (LoadConfig->DeCommitTotalFreeThreshold) {
        printf( "    Process Heap DeCommit Total Free threshold: %I64x\n", LoadConfig->DeCommitTotalFreeThreshold);
    }

    if (LoadConfig->LockPrefixTable) {
        printf( "    Lock Prefix Table: %I64x\n", LoadConfig->LockPrefixTable);
    }

    if (LoadConfig->MaximumAllocationSize) {
        printf( "    Process Heap Maximum Allocation Size: %I64x\n", LoadConfig->MaximumAllocationSize);
    }

    if (LoadConfig->VirtualMemoryThreshold) {
        printf( "    Process Heap VirtualAlloc Threshold: %I64x\n", LoadConfig->VirtualMemoryThreshold);
    }

    if (LoadConfig->ProcessHeapFlags) {
        printf( "    Process Heap Flags: %08x\n", LoadConfig->ProcessHeapFlags);
    }

    if (LoadConfig->ProcessAffinityMask) {
        printf( "    Process Affinity Mask: %I64x\n", LoadConfig->ProcessAffinityMask);
    }

    if (LoadConfig->CSDVersion) {
        printf( "    CSD version: %d\n", LoadConfig->CSDVersion);
    }

    if (LoadConfig->Size >= FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerCount)) {
        if (LoadConfig->SecurityCookie) {
            printf( "    Security Cookie offset: %I64x\n", LoadConfig->SecurityCookie);
        }

        if (LoadConfig->SEHandlerTable) {
            printf( "    SEH handler table: %I64x\n", LoadConfig->SEHandlerTable);
        }

        if (LoadConfig->SEHandlerCount) {
            printf( "    SEH Handler count: %d\n", LoadConfig->SEHandlerCount);
        }
    }
}

VOID
DisplayHeaderInfo32(PIMAGE_NT_HEADERS32 NtHeader)
{
    printf( "    Subsystem Version of %u.%u\n", NtHeader->OptionalHeader.MajorSubsystemVersion, NtHeader->OptionalHeader.MinorSubsystemVersion);

    if (NtHeader->OptionalHeader.Win32VersionValue) {
        printf( "    Win32 GetVersion return value: %08x\n", NtHeader->OptionalHeader.Win32VersionValue);
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE) {
        printf( "    Image can handle large (>2GB) addresses\n" );
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_NET_RUN_FROM_SWAP) {
        printf( "    Image will run from swapfile if located on net\n" );
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP) {
        printf( "    Image will run from swapfile if located on removable media\n" );
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_UP_SYSTEM_ONLY) {
        printf( "    Image can only run in uni-processor mode on multi-processor systems\n" );
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_AGGRESIVE_WS_TRIM) {
        printf( "    Image working set trimmed aggressively on small memory systems\n" );
    }

    if (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE) {
        printf( "    Image is Terminal Server aware\n" );
    }

    if (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_BIND) {
        printf( "    Image does not support binding\n" );
    }

    if (NtHeader->OptionalHeader.SizeOfStackReserve) {
        printf( "    Stack Reserve Size: 0x%x\n", NtHeader->OptionalHeader.SizeOfStackReserve );
    }

    if (NtHeader->OptionalHeader.SizeOfStackCommit) {
        printf( "    Stack Commit Size: 0x%x\n", NtHeader->OptionalHeader.SizeOfStackCommit );
    }
}

VOID
DisplayHeaderInfo64(PIMAGE_NT_HEADERS64 NtHeader)
{
    printf( "    Subsystem Version of %u.%u\n", NtHeader->OptionalHeader.MajorSubsystemVersion, NtHeader->OptionalHeader.MinorSubsystemVersion);

    if (NtHeader->OptionalHeader.Win32VersionValue) {
        printf( "    Win32 GetVersion return value: %08x\n", NtHeader->OptionalHeader.Win32VersionValue);
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE) {
        printf( "    Image can handle large (>2GB) addresses\n" );
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_NET_RUN_FROM_SWAP) {
        printf( "    Image will run from swapfile if located on net\n" );
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP) {
        printf( "    Image will run from swapfile if located on removable media\n" );
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_UP_SYSTEM_ONLY) {
        printf( "    Image can only run in uni-processor mode on multi-processor systems\n" );
    }

    if (NtHeader->FileHeader.Characteristics & IMAGE_FILE_AGGRESIVE_WS_TRIM) {
        printf( "    Image working set trimmed aggressively on small memory systems\n" );
    }

    if (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE) {
        printf( "    Image is Terminal Server aware\n" );
    }

    if (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_BIND) {
        printf( "    Image does not support binding\n" );
    }

    if (NtHeader->OptionalHeader.SizeOfStackReserve) {
        printf( "    Stack Reserve Size: 0x%I64x\n", NtHeader->OptionalHeader.SizeOfStackReserve );
    }

    if (NtHeader->OptionalHeader.SizeOfStackCommit) {
        printf( "    Stack Commit Size: 0x%I64x\n", NtHeader->OptionalHeader.SizeOfStackCommit );
    }
}


BOOL
CheckIfConfigInfoChanged64(PIMAGE_LOAD_CONFIG_DIRECTORY64 LoadConfig)
{
    if ((GlobalFlagsClear && (LoadConfig->GlobalFlagsClear != GlobalFlagsClear)) ||
        (GlobalFlagsSet && (LoadConfig->GlobalFlagsSet != GlobalFlagsSet)) ||
        (CriticalSectionDefaultTimeout && (LoadConfig->CriticalSectionDefaultTimeout != CriticalSectionDefaultTimeout)) ||
        (ProcessHeapFlags && (LoadConfig->ProcessHeapFlags != ProcessHeapFlags)) ||
        (DeCommitFreeBlockThreshold && (LoadConfig->DeCommitFreeBlockThreshold != DeCommitFreeBlockThreshold)) ||
        (DeCommitTotalFreeThreshold && (LoadConfig->DeCommitTotalFreeThreshold != DeCommitTotalFreeThreshold)) ||
        (MaximumAllocationSize && (LoadConfig->MaximumAllocationSize != MaximumAllocationSize)) ||
        (VirtualMemoryThreshold && (LoadConfig->VirtualMemoryThreshold != VirtualMemoryThreshold)) ||
        (ImageProcessAffinityMask && (LoadConfig->ProcessAffinityMask != ImageProcessAffinityMask)))
    {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CheckIfConfigInfoChanged32(PIMAGE_LOAD_CONFIG_DIRECTORY32 LoadConfig)
{
    if ((GlobalFlagsClear && (LoadConfig->GlobalFlagsClear != GlobalFlagsClear)) ||
        (GlobalFlagsSet && (LoadConfig->GlobalFlagsSet != GlobalFlagsSet)) ||
        (CriticalSectionDefaultTimeout && (LoadConfig->CriticalSectionDefaultTimeout != CriticalSectionDefaultTimeout)) ||
        (ProcessHeapFlags && (LoadConfig->ProcessHeapFlags != ProcessHeapFlags)) ||
        (DeCommitFreeBlockThreshold && (LoadConfig->DeCommitFreeBlockThreshold != (DWORD)DeCommitFreeBlockThreshold)) ||
        (DeCommitTotalFreeThreshold && (LoadConfig->DeCommitTotalFreeThreshold != (DWORD)DeCommitTotalFreeThreshold)) ||
        (MaximumAllocationSize && (LoadConfig->MaximumAllocationSize != (DWORD)MaximumAllocationSize)) ||
        (VirtualMemoryThreshold && (LoadConfig->VirtualMemoryThreshold != (DWORD)VirtualMemoryThreshold)) ||
        (ImageProcessAffinityMask && (LoadConfig->ProcessAffinityMask != (DWORD)ImageProcessAffinityMask)))
    {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CheckIfImageHeaderChanged32(PIMAGE_NT_HEADERS32 NtHeader)
{
    if ((MajorSubsystemVersion && 
         NtHeader->OptionalHeader.MajorSubsystemVersion != (USHORT)MajorSubsystemVersion ||
         NtHeader->OptionalHeader.MinorSubsystemVersion != (USHORT)MinorSubsystemVersion) 
            ||
        (Win32VersionValue && (NtHeader->OptionalHeader.Win32VersionValue != Win32VersionValue)) 
            ||
        (fEnableLargeAddresses && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE))
            ||
        (fNoBind && !(NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_BIND))
            ||
        (fEnableTerminalServerAware && !(NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE))
            ||
        (fDisableTerminalServerAware && (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE))
            ||
        (fSwapRunNet && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_NET_RUN_FROM_SWAP))
            ||
        (fSwapRunCD && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP))
            ||
        (fUniprocessorOnly && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_UP_SYSTEM_ONLY))
            ||
        (fRestrictedWorkingSet && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_AGGRESIVE_WS_TRIM))
            ||
        (SizeOfStackReserve && (NtHeader->OptionalHeader.SizeOfStackReserve != (DWORD)SizeOfStackReserve))
            ||
        (SizeOfStackCommit && (NtHeader->OptionalHeader.SizeOfStackCommit != (DWORD)SizeOfStackCommit)) )
    {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CheckIfImageHeaderChanged64(PIMAGE_NT_HEADERS64 NtHeader)
{
    if ((MajorSubsystemVersion && 
         NtHeader->OptionalHeader.MajorSubsystemVersion != (USHORT)MajorSubsystemVersion ||
         NtHeader->OptionalHeader.MinorSubsystemVersion != (USHORT)MinorSubsystemVersion) 
            ||
        (Win32VersionValue && (NtHeader->OptionalHeader.Win32VersionValue != Win32VersionValue)) 
            ||
        (fEnableLargeAddresses && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE))
            ||
        (fNoBind && !(NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_BIND))
            ||
        (fEnableTerminalServerAware && !(NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE))
            ||
        (fDisableTerminalServerAware && (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE))
            ||
        (fSwapRunNet && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_NET_RUN_FROM_SWAP))
            ||
        (fSwapRunCD && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP))
            ||
        (fUniprocessorOnly && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_UP_SYSTEM_ONLY))
            ||
        (fRestrictedWorkingSet && !(NtHeader->FileHeader.Characteristics & IMAGE_FILE_AGGRESIVE_WS_TRIM))
            ||
        (SizeOfStackReserve && (NtHeader->OptionalHeader.SizeOfStackReserve != SizeOfStackReserve))
            ||
        (SizeOfStackCommit && (NtHeader->OptionalHeader.SizeOfStackCommit != SizeOfStackCommit)) )
    {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
SetImageConfigInformation32(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY32 ImageConfigInformation
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY32 ImageConfigData;
    ULONG i;
    ULONG DirectoryAddress;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_DATA_DIRECTORY pLoadCfgDataDir;
    // We can only write native loadcfg struct
    ULONG V1LoadCfgLength = FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerTable);
    ULONG NewDataSize;

    if (LoadedImage->hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY32) ImageDirectoryEntryToData( LoadedImage->MappedAddress,
                                                 FALSE,
                                                 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                 &i
                                               );
    if (ImageConfigData && (i == V1LoadCfgLength)) {
        if (ImageConfigInformation->Size) {
            // Incoming size specified?
            if (ImageConfigData->Size == ImageConfigInformation->Size) {
                // Current size same as new size?  Do the copy
                memcpy( ImageConfigData, ImageConfigInformation, ImageConfigInformation->Size);
                return TRUE;
            }
            if (ImageConfigData->Size > ImageConfigInformation->Size) {
                // New size < old size - can't allow that
                return FALSE;
            }
            // Last case is new size > old size - fall through and find room for new data.
        } else {
            // Incoming size not set - must be an V1 user.
            if (ImageConfigData->Size) {
                // Existing size set?  Can't overwrite new data with old data
                return FALSE;
            }
            // New and old are both V1 structs.
            memcpy( ImageConfigData, ImageConfigInformation, V1LoadCfgLength);
            return TRUE;
        }
    }

    NewDataSize = ImageConfigInformation->Size ? ImageConfigInformation->Size : V1LoadCfgLength;

    DirectoryAddress = GetImageUnusedHeaderBytes( LoadedImage, &i );
    if (i < NewDataSize) {
        return FALSE;
    }

    NtHeaders = LoadedImage->FileHeader;

    pLoadCfgDataDir = &((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];
    pLoadCfgDataDir->VirtualAddress = DirectoryAddress;
    pLoadCfgDataDir->Size = V1LoadCfgLength;
    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY32) ((PCHAR)LoadedImage->MappedAddress + DirectoryAddress);
    memcpy( ImageConfigData, ImageConfigInformation, sizeof( *ImageConfigData ) );
    return TRUE;
}

BOOL
SetImageConfigInformation64(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY64 ImageConfigInformation
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY64 ImageConfigData;
    ULONG i;
    ULONG DirectoryAddress;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_DATA_DIRECTORY pLoadCfgDataDir;
    // We can only write native loadcfg struct
    ULONG V1LoadCfgLength = FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, SEHandlerTable);
    ULONG NewDataSize;

    if (LoadedImage->hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY64) ImageDirectoryEntryToData( LoadedImage->MappedAddress,
                                                 FALSE,
                                                 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                 &i
                                               );
    if (ImageConfigData && (i == V1LoadCfgLength)) {
        if (ImageConfigInformation->Size) {
            // Incoming size specified?
            if (ImageConfigData->Size == ImageConfigInformation->Size) {
                // Current size same as new size?  Do the copy
                memcpy( ImageConfigData, ImageConfigInformation, ImageConfigInformation->Size);
                return TRUE;
            }
            if (ImageConfigData->Size > ImageConfigInformation->Size) {
                // New size < old size - can't allow that
                return FALSE;
            }
            // Last case is new size > old size - fall through and find room for new data.
        } else {
            // Incoming size not set - must be an V1 user.
            if (ImageConfigData->Size) {
                // Existing size set?  Can't overwrite new data with old data
                return FALSE;
            }
            // New and old are both V1 structs.
            memcpy( ImageConfigData, ImageConfigInformation, V1LoadCfgLength);
            return TRUE;
        }
    }

    NewDataSize = ImageConfigInformation->Size ? ImageConfigInformation->Size : V1LoadCfgLength;

    DirectoryAddress = GetImageUnusedHeaderBytes( LoadedImage, &i );
    if (i < NewDataSize) {
        return FALSE;
    }

    NtHeaders = LoadedImage->FileHeader;

    pLoadCfgDataDir = &((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];
    pLoadCfgDataDir->VirtualAddress = DirectoryAddress;
    pLoadCfgDataDir->Size = V1LoadCfgLength;
    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY64) ((PCHAR)LoadedImage->MappedAddress + DirectoryAddress);
    memcpy( ImageConfigData, ImageConfigInformation, sizeof( *ImageConfigData ) );
    return TRUE;
}



int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    UCHAR c;
    LPSTR p, sMajor, sMinor, sReserve, sCommit;
    ULONG HeaderSum;
    SYSTEMTIME SystemTime;
    FILETIME LastWriteTime;
    DWORD OldChecksum;
    PVOID pNewConfigData, pOldConfigData;
    DWORD ImageConfigSize;
    
    fUsage = FALSE;
    fVerbose = FALSE;

    _tzset();

    if (argc <= 1) {
        goto showUsage;
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
                switch (toupper( c )) {
                    case '?':
                        fUsage = TRUE;
                        break;

                    case 'A':
                        if (--argc) {
                            ImageProcessAffinityMask = ConvertNum( *++argv );
                            if (ImageProcessAffinityMask == 0) {
                                fprintf( stderr, "IMAGECFG: invalid affinity mask specified to /a switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /a switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'C':
                        if (--argc) {
                            if (sscanf( *++argv, "%x", &Win32CSDVerValue ) != 1) {
                                fprintf( stderr, "IMAGECFG: invalid version string specified to /c switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /c switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'D':
                        if (argc >= 2) {
                            argc -= 2;
                            DeCommitFreeBlockThreshold = ConvertNum( *++argv );
                            DeCommitTotalFreeThreshold = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /d switch missing arguments.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'G':
                        if (argc >= 2) {
                            argc -= 2;
                            GlobalFlagsClear = (ULONG) ConvertNum( *++argv );
                            GlobalFlagsSet = (ULONG) ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /g switch missing arguments.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'H':
                        if (argc > 2) {

                            INT flag = -1;

                            if (sscanf( *++argv, "%d", &flag ) != 1) {
                                fprintf( stderr, "IMAGECFG: invalid option string specified to /h switch.\n" );
                                fUsage = TRUE;
                            } else {

                                --argc;

                                if (flag == 0) {
                                    fDisableTerminalServerAware = TRUE;
                                } else if (flag == 1) {
                                    fEnableTerminalServerAware = TRUE;
                                } else {
                                    fprintf( stderr, "IMAGECFG: /h switch invalid argument.\n" );
                                    fUsage = TRUE;
                                }

                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /h switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'K':
                        if (--argc) {
                            sReserve = *++argv;
                            sCommit = strchr( sReserve, '.' );
                            if (sCommit != NULL) {
                                *sCommit++ = '\0';
                                SizeOfStackCommit = ConvertNum( sCommit );
                                SizeOfStackCommit = ((SizeOfStackCommit + 0x00000FFFui64) & ~0x00000FFFui64);
                                if (SizeOfStackCommit == 0) {
                                    fprintf( stderr, "IMAGECFG: invalid stack commit size specified to /k switch.\n" );
                                    fUsage = TRUE;
                                }
                            }

                            SizeOfStackReserve = ConvertNum( sReserve );
                            SizeOfStackReserve = ((SizeOfStackReserve + 0x0000FFFFui64) & ~0x0000FFFFui64);
                            if (SizeOfStackReserve == 0) {
                                fprintf( stderr, "IMAGECFG: invalid stack reserve size specified to /k switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /w switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'L':
                        fEnableLargeAddresses = TRUE;
                        break;

                    case 'M':
                        if (--argc) {
                            MaximumAllocationSize = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /m switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'N':
                        fNoBind = TRUE;
                        break;

                    case 'O':
                        if (--argc) {
                            CriticalSectionDefaultTimeout = (ULONG) ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /o switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'P':
                        if (--argc) {
                            ProcessHeapFlags = (ULONG) ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /p switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'Q':
                        fQuiet = TRUE;
                        break;

                    case 'R':
                        fRestrictedWorkingSet = TRUE;
                        break;

                    case 'S':
                        if (--argc) {
                            SymbolPath = *++argv;
                        } else {
                            fprintf( stderr, "IMAGECFG: /s switch missing path argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'T':
                        if (--argc) {
                            VirtualMemoryThreshold = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /t switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'U':
                        fUniprocessorOnly = TRUE;
                        break;

                    case 'V':
                        if (--argc) {
                            sMajor = *++argv;
                            sMinor = strchr( sMajor, '.' );
                            if (sMinor != NULL) {
                                *sMinor++ = '\0';
                                MinorSubsystemVersion = (ULONG) ConvertNum( sMinor );
                            }
                            MajorSubsystemVersion = (ULONG) ConvertNum( sMajor );

                            if (MajorSubsystemVersion == 0) {
                                fprintf( stderr, "IMAGECFG: invalid version string specified to /v switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /v switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'W':
                        if (--argc) {
                            if (sscanf( *++argv, "%x", &Win32VersionValue ) != 1) {
                                fprintf( stderr, "IMAGECFG: invalid version string specified to /w switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /w switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'X':
                        fSwapRunNet = TRUE;
                        break;

                    case 'Y':
                        fSwapRunCD = TRUE;
                        break;

                    default:
                        fprintf( stderr, "IMAGECFG: Invalid switch - /%c\n", c );
                        fUsage = TRUE;
                        break;
                }

            if ( fUsage ) {
                showUsage:
                fprintf( stderr,
                         "usage: IMAGECFG [switches] image-names... \n"
                         "              [-?] display this message\n"
                         "              [-a Process Affinity mask value in hex]\n"
                         "              [-c Win32 GetVersionEx Service Pack return value in hex]\n"
                         "              [-d decommit thresholds]\n"
                         "              [-g bitsToClear bitsToSet]\n"
                         "              [-h 1|0 (Enable/Disable Terminal Server Compatible bit)\n"
                         "              [-k StackReserve[.StackCommit]\n"
                         "              [-l enable large (>2GB) addresses\n"
                         "              [-m maximum allocation size]\n"
                         "              [-n bind no longer allowed on this image\n"
                         "              [-o default critical section timeout\n"
                         "              [-p process heap flags]\n"
                         "              [-q only print config info if changed\n"
                         "              [-r run with restricted working set]\n"
                         "              [-s path to symbol files]\n"
                         "              [-t VirtualAlloc threshold]\n"
                         "              [-u Marks image as uniprocessor only]\n"
                         "              [-v MajorVersion.MinorVersion]\n"
                         "              [-w Win32 GetVersion return value in hex]\n"
                         "              [-x Mark image as Net - Run From Swapfile\n"
                         "              [-y Mark image as Removable - Run From Swapfile\n"
                       );
                exit( 1 );
            }
        } else {
            //
            // Map and load the current image
            //

            CurrentImageName = p;
            if (MapAndLoad( CurrentImageName,
                            NULL,
                            &CurrentImage,
                            FALSE,
                            TRUE            // Read only
                          ) ) 
            {
                if (CurrentImage.FileHeader->OptionalHeader.Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
                    // Don't muck with ROM images.
                    UnMapAndLoad( &CurrentImage );
                    continue;
                }

                if (CurrentImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                    f64bitImage = TRUE;
                }

                pNewConfigData = malloc(f64bitImage ? sizeof(IMAGE_LOAD_CONFIG_DIRECTORY64) : sizeof(IMAGE_LOAD_CONFIG_DIRECTORY32));
                if (!pNewConfigData) {
                    printf("Out of memory\n");
                    exit(-1);
                }

                pOldConfigData = ImageDirectoryEntryToData(CurrentImage.MappedAddress, 
                                                           FALSE, 
                                                           IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, 
                                                           &ImageConfigSize);
                if (pOldConfigData) {
                    if (!fQuiet) {
                        if (f64bitImage) {
                            DisplayConfigInfo64(pOldConfigData);
                        } else {
                            DisplayConfigInfo32(pOldConfigData);
                        }
                    }
    
                    if (((PIMAGE_LOAD_CONFIG_DIRECTORY)pOldConfigData)->Size) {
                        // New format - Size is the real size.
                        ImageConfigSize = ((PIMAGE_LOAD_CONFIG_DIRECTORY)pOldConfigData)->Size;
                    }

                    memcpy(pNewConfigData, pOldConfigData, ImageConfigSize);
                } else {
                    ZeroMemory(pNewConfigData, f64bitImage ? sizeof(IMAGE_LOAD_CONFIG_DIRECTORY64) : sizeof(IMAGE_LOAD_CONFIG_DIRECTORY32));
                    ((PIMAGE_LOAD_CONFIG_DIRECTORY)pNewConfigData)->Size = f64bitImage ? sizeof(IMAGE_LOAD_CONFIG_DIRECTORY64) : sizeof(IMAGE_LOAD_CONFIG_DIRECTORY32);
                }

                fConfigInfoChanged = f64bitImage ? CheckIfConfigInfoChanged64(pNewConfigData) : CheckIfConfigInfoChanged32(pNewConfigData);

                fImageHeaderChanged = f64bitImage ? 
                                  CheckIfImageHeaderChanged64((PIMAGE_NT_HEADERS64)&CurrentImage.FileHeader) : 
                                     CheckIfImageHeaderChanged32((PIMAGE_NT_HEADERS32)&CurrentImage.FileHeader);

                UnMapAndLoad( &CurrentImage );

                if (fConfigInfoChanged || fImageHeaderChanged) {
                    if (MapAndLoad( CurrentImageName, NULL, &CurrentImage, FALSE, FALSE )) {

                        // Set Load Config data

                        if (GlobalFlagsClear) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->GlobalFlagsClear = GlobalFlagsClear;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->GlobalFlagsClear = GlobalFlagsClear;
                            }
                        }

                        if (GlobalFlagsSet) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->GlobalFlagsSet = GlobalFlagsSet;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->GlobalFlagsSet = GlobalFlagsSet;
                            }
                        }

                        if (CriticalSectionDefaultTimeout) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->CriticalSectionDefaultTimeout = CriticalSectionDefaultTimeout;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->CriticalSectionDefaultTimeout = CriticalSectionDefaultTimeout;
                            }
                        }

                        if (ProcessHeapFlags) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->ProcessHeapFlags = ProcessHeapFlags;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->ProcessHeapFlags = ProcessHeapFlags;
                            }
                        }

                        if (DeCommitFreeBlockThreshold) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->DeCommitFreeBlockThreshold = DeCommitFreeBlockThreshold;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->DeCommitFreeBlockThreshold = (DWORD)DeCommitFreeBlockThreshold;
                            }
                        }

                        if (DeCommitTotalFreeThreshold) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->DeCommitTotalFreeThreshold = DeCommitTotalFreeThreshold;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->DeCommitTotalFreeThreshold = (DWORD)DeCommitTotalFreeThreshold;
                            }
                        }

                        if (MaximumAllocationSize) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->MaximumAllocationSize = MaximumAllocationSize;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->MaximumAllocationSize = (DWORD)MaximumAllocationSize;
                            }
                        }

                        if (VirtualMemoryThreshold) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->VirtualMemoryThreshold = VirtualMemoryThreshold;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->VirtualMemoryThreshold = (DWORD)VirtualMemoryThreshold;
                            }
                        }

                        if (ImageProcessAffinityMask) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->ProcessAffinityMask = ImageProcessAffinityMask;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->ProcessAffinityMask = (DWORD)ImageProcessAffinityMask;
                            }
                        }

                        if (Win32CSDVerValue != 0) {
                            if (f64bitImage) {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY64)pNewConfigData)->CSDVersion = (USHORT)Win32CSDVerValue;
                            } else {
                                ((PIMAGE_LOAD_CONFIG_DIRECTORY32)pNewConfigData)->CSDVersion = (USHORT)Win32CSDVerValue;
                            }
                        }

                        // Set File header values

                        if (fEnableLargeAddresses) {
                            CurrentImage.FileHeader->FileHeader.Characteristics |= IMAGE_FILE_LARGE_ADDRESS_AWARE;
                        }

                        if (fSwapRunNet) {
                            CurrentImage.FileHeader->FileHeader.Characteristics |= IMAGE_FILE_NET_RUN_FROM_SWAP;
                        }

                        if (fSwapRunCD) {
                            CurrentImage.FileHeader->FileHeader.Characteristics |= IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP;
                        }

                        if (fUniprocessorOnly) {
                            CurrentImage.FileHeader->FileHeader.Characteristics |= IMAGE_FILE_UP_SYSTEM_ONLY;
                        }

                        if (fRestrictedWorkingSet) {
                            CurrentImage.FileHeader->FileHeader.Characteristics |= IMAGE_FILE_AGGRESIVE_WS_TRIM;
                        }

                        // Set Optional header values

                        if (fNoBind) {
                            if (f64bitImage) {
                                ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.DllCharacteristics |= IMAGE_DLLCHARACTERISTICS_NO_BIND;
                            } else {
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.DllCharacteristics |= IMAGE_DLLCHARACTERISTICS_NO_BIND;
                            }
                        }

                        if (fEnableTerminalServerAware) {
                            if (f64bitImage) {
                                ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.DllCharacteristics |= IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE;
                            } else {
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.DllCharacteristics |= IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE;
                            }
                        }

                        if (fDisableTerminalServerAware) {
                            if (f64bitImage) {
                                ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.DllCharacteristics |= IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE;
                            } else {
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.DllCharacteristics |= IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE;
                            }
                        }

                        if (MajorSubsystemVersion != 0) {
                            if (f64bitImage) {
                                ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.MajorSubsystemVersion = (USHORT)MajorSubsystemVersion;
                                ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.MinorSubsystemVersion = (USHORT)MinorSubsystemVersion;
                            } else {
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.MajorSubsystemVersion = (USHORT)MajorSubsystemVersion;
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.MinorSubsystemVersion = (USHORT)MinorSubsystemVersion;
                            }
                        }

                        if (Win32VersionValue != 0) {
                            if (f64bitImage) {
                                ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.Win32VersionValue = Win32VersionValue;
                            } else {
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.Win32VersionValue = Win32VersionValue;
                            }
                        }

                        if (SizeOfStackReserve) {
                            if (f64bitImage) {
                                ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.SizeOfStackReserve = SizeOfStackReserve;
                            } else {
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.SizeOfStackReserve = (DWORD)SizeOfStackReserve;
                            }
                        }

                        if (SizeOfStackCommit) {
                            if (f64bitImage) {
                                ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.SizeOfStackCommit = SizeOfStackCommit;
                            } else {
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.SizeOfStackCommit = (DWORD)SizeOfStackCommit;
                            }
                        }

                        if (fConfigInfoChanged) {
                            if (f64bitImage) {
                                if (SetImageConfigInformation64( &CurrentImage, pNewConfigData )) {
                                    if (!fQuiet) {
                                        printf( "%s updated with the following configuration information:\n", CurrentImageName );
                                        DisplayConfigInfo64(pNewConfigData);
                                    }
                                } else {
                                    fprintf( stderr, "IMAGECFG: Unable to update configuration information in image.\n" );
                                }
                            } else {
                                if (SetImageConfigInformation32( &CurrentImage, pNewConfigData )) {
                                    if (!fQuiet) {
                                        printf( "%s updated with the following configuration information:\n", CurrentImageName );
                                        DisplayConfigInfo32(pNewConfigData);
                                    }
                                } else {
                                    fprintf( stderr, "IMAGECFG: Unable to update configuration information in image.\n" );
                                }
                            }
                        }

                        //
                        // recompute the checksum.
                        //

                        if (f64bitImage) {
                            OldChecksum = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.CheckSum;
    
                            ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.CheckSum = 0;
                            CheckSumMappedFile(
                                              (PVOID)CurrentImage.MappedAddress,
                                              CurrentImage.SizeOfImage,
                                              &HeaderSum,
                                              &((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.CheckSum
                                              );
                        } else {
                            OldChecksum = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum;
    
                            ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum = 0;
                            CheckSumMappedFile(
                                              (PVOID)CurrentImage.MappedAddress,
                                              CurrentImage.SizeOfImage,
                                              &HeaderSum,
                                              &((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum
                                              );
                        }

                        // And update the .dbg file (if requested)
                        if (SymbolPath &&
                            CurrentImage.FileHeader->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                            if (UpdateDebugInfoFileEx( CurrentImageName,
                                                       SymbolPath,
                                                       DebugFilePath,
                                                       (PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                                       OldChecksum
                                                     )
                               ) {
                                if (GetLastError() == ERROR_INVALID_DATA) {
                                    printf( "Warning: Old checksum did not match for %s\n", DebugFilePath);
                                }
                                printf( "Updated symbols for %s\n", DebugFilePath );
                            } else {
                                printf( "Unable to update symbols: %s\n", DebugFilePath );
                            }
                        }

                        GetSystemTime( &SystemTime );
                        if (SystemTimeToFileTime( &SystemTime, &LastWriteTime )) {
                            SetFileTime( CurrentImage.hFile, NULL, NULL, &LastWriteTime );
                        }

                        UnMapAndLoad( &CurrentImage );
                    }
                }
            } else
                if (!CurrentImage.fDOSImage) {
                fprintf( stderr, "IMAGECFG: unable to map and load %s  GetLastError= %d\n", CurrentImageName, GetLastError() );

            } else {
                fprintf( stderr,
                         "IMAGECFG: unable to modify DOS or Windows image file - %s\n",
                         CurrentImageName
                       );
            }
        }
    }

    exit( 1 );
    return 1;
}

#define STANDALONE_MAP
#include <mapi.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\imagedir.c ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    imagedir.c

Abstract:

    The module contains the code to translate an image directory type to
    the address of the data for that entry.

Environment:

    User Mode or Kernel Mode

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>

PVOID
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_NT_HEADERS
ImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
    return RtlpImageNtHeader( Base );
}


PVOID
ImageDirectoryEntryToDataRom (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_ROM_OPTIONAL_HEADER OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    //
    // There's not much we can get from ROM images.  See if the info requested
    // is one of the known ones (debug/exception data)
    //

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                      FileHeader->SizeOfOptionalHeader);

    for (i = 0; i < FileHeader->NumberOfSections; i++, NtSection++) {

        if ( DirectoryEntry == IMAGE_DIRECTORY_ENTRY_DEBUG ) {
            if (!_stricmp((char *)NtSection->Name, ".rdata")) {
                PIMAGE_DEBUG_DIRECTORY DebugDirectory;
                *Size = 0;
                DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)((ULONG_PTR)NtSection->PointerToRawData + (ULONG_PTR)Base);
                while (DebugDirectory->Type != 0) {
                    *Size += sizeof(IMAGE_DEBUG_DIRECTORY);
                    DebugDirectory++;
                }
                if (FoundSection) {
                    *FoundSection = NtSection;
                }
                return (PVOID)((ULONG_PTR)NtSection->PointerToRawData + (ULONG_PTR)Base);
            }
        } else
        if ( DirectoryEntry == IMAGE_DIRECTORY_ENTRY_EXCEPTION ) {
            if (!_stricmp((char *)NtSection->Name, ".pdata")) {
                if (FoundSection) {
                    *FoundSection = NtSection;
                }
                return (PVOID)((ULONG_PTR)NtSection->PointerToRawData + (ULONG_PTR)Base);
            }
        }
    }
    // Not one of the known sections.  Return error.
    *Size = 0;
    return( NULL );
}

PVOID
ImageDirectoryEntryToData64 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_OPTIONAL_HEADER64 OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG DirectoryAddress;

    if (DirectoryEntry >= OptionalHeader->NumberOfRvaAndSizes) {
        *Size = 0;
        return( NULL );
    }

    if (!(DirectoryAddress = OptionalHeader->DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        *Size = 0;
        return( NULL );
    }
    *Size = OptionalHeader->DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < OptionalHeader->SizeOfHeaders) {
        if (FoundSection) {
            *FoundSection = NULL;
        }
        return( (PVOID)((ULONG_PTR)Base + DirectoryAddress) );
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                        FileHeader->SizeOfOptionalHeader);

    for (i=0; i<FileHeader->NumberOfSections; i++) {
        if (DirectoryAddress >= NtSection->VirtualAddress &&
           DirectoryAddress < NtSection->VirtualAddress + NtSection->SizeOfRawData) {
            if (FoundSection) {
                *FoundSection = NtSection;
            }
            return( (PVOID)((ULONG_PTR)Base + (DirectoryAddress - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
        ++NtSection;
    }
    return( NULL );
}

PVOID
ImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_OPTIONAL_HEADER32 OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG DirectoryAddress;

    if (DirectoryEntry >= OptionalHeader->NumberOfRvaAndSizes) {
        *Size = 0;
        return( NULL );
    }

    if (!(DirectoryAddress = OptionalHeader->DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        *Size = 0;
        return( NULL );
    }
    *Size = OptionalHeader->DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < OptionalHeader->SizeOfHeaders) {
        if (FoundSection) {
            *FoundSection = NULL;
        }
        return( (PVOID)((ULONG_PTR)Base + DirectoryAddress) );
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                        FileHeader->SizeOfOptionalHeader);

    for (i=0; i<FileHeader->NumberOfSections; i++) {
        if (DirectoryAddress >= NtSection->VirtualAddress &&
           DirectoryAddress < NtSection->VirtualAddress + NtSection->SizeOfRawData) {
            if (FoundSection) {
                *FoundSection = NtSection;
            }
            return( (PVOID)((ULONG_PTR)Base + (DirectoryAddress - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
        ++NtSection;
    }
    return( NULL );
}

PVOID
ImageDirectoryEntryToDataEx (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.  It may optionally return the
    section header, if any, for the found data.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

    FoundSection - Returns the section header, if any, for the data

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;

    if ((ULONG_PTR)Base & 0x00000001) {
        Base = (PVOID)((ULONG_PTR)Base & ~0x1);
        MappedAsImage = FALSE;
        }

    NtHeader = ImageNtHeader(Base);

    if (NtHeader) {
        FileHeader = &NtHeader->FileHeader;
        OptionalHeader = &NtHeader->OptionalHeader;
    } else {
        // Handle case where Image passed in doesn't have a dos stub (ROM images for instance);
        FileHeader = (PIMAGE_FILE_HEADER)Base;
        OptionalHeader = (PIMAGE_OPTIONAL_HEADER) ((ULONG_PTR)Base + IMAGE_SIZEOF_FILE_HEADER);
    }

    if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return (ImageDirectoryEntryToData32 ( Base,
                                              MappedAsImage,
                                              DirectoryEntry,
                                              Size,
                                              FoundSection,
                                              FileHeader,
                                              (PIMAGE_OPTIONAL_HEADER32)OptionalHeader));
    } else if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return (ImageDirectoryEntryToData64 ( Base,
                                               MappedAsImage,
                                               DirectoryEntry,
                                               Size,
                                               FoundSection,
                                               FileHeader,
                                               (PIMAGE_OPTIONAL_HEADER64)OptionalHeader));
    } else if (OptionalHeader->Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
        return (ImageDirectoryEntryToDataRom ( Base,
                                               MappedAsImage,
                                               DirectoryEntry,
                                               Size,
                                               FoundSection,
                                               FileHeader,
                                               (PIMAGE_ROM_OPTIONAL_HEADER)OptionalHeader));
    } else {

        *Size = 0;
        return NULL;
    }
}


PVOID
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.

    This just calls ImageDirectoryToDataEx without a FoundSection arg.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    return ImageDirectoryEntryToDataEx(Base, MappedAsImage, DirectoryEntry, Size, NULL);
}


PIMAGE_SECTION_HEADER
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file
    that is mapped as a file and returns a pointer to the section
    table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the pointer of the section entry containing the data.

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}


PVOID
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file that
    is mapped as a file and returns the virtual addrees of the
    corresponding byte in the file.


Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

    LastRvaSection - Optional parameter that if specified, points
        to a variable that contains the last section value used for
        the specified image to translate and RVA to a VA.

Return Value:

    NULL - The file does not contain the specified RVA

    NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    if (LastRvaSection == NULL ||
        (NtSection = *LastRvaSection) == NULL ||
        NtSection == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
       ) {
        NtSection = ImageRvaToSection( NtHeaders,
                                       Base,
                                       Rva
                                     );
        }

    if (NtSection != NULL) {
        if (LastRvaSection != NULL) {
            *LastRvaSection = NtSection;
            }

        return (PVOID)((ULONG_PTR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData
                      );
        }
    else {
        return NULL;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\fecache.hpp ===
//----------------------------------------------------------------------------
//
// Function entry cache.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __FECACHE_HPP__
#define __FECACHE_HPP__

typedef IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
typedef IMAGE_ARM_RUNTIME_FUNCTION_ENTRY *PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY;

union FeCacheData
{
    // 32-bit Alpha entry is only temporary storage;
    // cache entries are always converted to 64-bit
    // to allow common code.
    IMAGE_IA64_RUNTIME_FUNCTION_ENTRY    Ia64;
    _IMAGE_RUNTIME_FUNCTION_ENTRY        Amd64;
    IMAGE_ARM_RUNTIME_FUNCTION_ENTRY     Arm;
    UCHAR                                Data[1];
};

struct FeCacheEntry
{
    FeCacheData Data;
    // Generic values translated from the raw data.
    ULONG RelBegin;
    ULONG RelEnd;
    
    ULONG64 Address;
    HANDLE  Process;
    ULONG64 ModuleBase;
#if DBG
    PSTR    Description;
#endif
};

#if DBG

#define FE_DEBUG(x) if (tlsvar(DebugFunctionEntries)) dbPrint##x
#define FE_ShowRuntimeFunctionIa64(x) ShowRuntimeFunctionIa64##x
#define FE_SET_DESC(Ent, Desc) ((Ent)->Description = (Desc))

void
ShowRuntimeFunctionEntryIa64(
    FeCacheEntry* FunctionEntry,
    PSTR Label
    );
#else

#define FE_DEBUG(x)
#define FE_ShowRuntimeFunctionIa64(x)
#define FE_SET_DESC(Ent, Desc)

#endif // #if DBG

//----------------------------------------------------------------------------
//
// FunctionEntryCache.
//
//----------------------------------------------------------------------------

class FunctionEntryCache
{
public:
    FunctionEntryCache(ULONG ImageDataSize, ULONG CacheDataSize,
                       ULONG Machine);
    ~FunctionEntryCache(void);

    BOOL Initialize(ULONG MaxEntries, ULONG ReplaceAt);
    
    FeCacheEntry* Find(
        HANDLE                           Process,
        ULONG64                          CodeOffset,
        PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
        PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
        );
    FeCacheEntry* FindDirect(
        HANDLE                           Process,
        ULONG64                          CodeOffset,
        PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
        PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
        );
    FeCacheEntry* ReadImage(
        HANDLE                         Process,
        ULONG64                        Address,
        PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
        PGET_MODULE_BASE_ROUTINE64     GetModuleBase
        );

    void InvalidateProcessOrModule(HANDLE Process, ULONG64 Base);
    
protected:
    // Total number of entries to store.
    ULONG m_MaxEntries;
    // When the cache is full entries are overwritten starting
    // at the replacement point.  Cache hits are moved up
    // prior to the replacement point so frequently used
    // entries stay unmodified in the front of the cache
    // and other entries are stored temporarily at the end.
    ULONG m_ReplaceAt;
    // Size of raw function entry data in the image.
    ULONG m_ImageDataSize;
    // Size of raw function entry data in the cache.
    // This may be different from the image data size if
    // the image data is translated into a different form,
    // such as Axp32 keeping cache entries in Axp64 form.
    ULONG m_CacheDataSize;
    // Machine type.
    ULONG m_Machine;

    FeCacheEntry* m_Entries;
    // Number of entries currently used.
    ULONG m_Used;
    // Index of next slot to fill.
    ULONG m_Next;
    // Temporary data area for callback-filled data.
    FeCacheEntry m_Temporary;

    FeCacheEntry* FillTemporary(HANDLE Process, PVOID RawEntry)
    {
        // No need to translate as this entry is not part of
        // the cache that will be searched.
        ZeroMemory(&m_Temporary, sizeof(m_Temporary));
        memcpy(&m_Temporary.Data, RawEntry, m_CacheDataSize);
        m_Temporary.Process = Process;
        return &m_Temporary;
    }
    
    virtual void TranslateRawData(FeCacheEntry* Entry) = 0;
    virtual void TranslateRvaDataToRawData(PIMGHLP_RVA_FUNCTION_DATA RvaData,
                                           ULONG64 ModuleBase,
                                           FeCacheData* Data) = 0;
    // Base implementation just returns the given entry.
    virtual FeCacheEntry* SearchForPrimaryEntry(
        FeCacheEntry* CacheEntry,
        HANDLE Process,
        PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
        PGET_MODULE_BASE_ROUTINE64 GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
        );
    
    FeCacheEntry* FindStatic(
        HANDLE                           Process,
        ULONG64                          CodeOffset,
        PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
        PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry,
        PULONG64                         ModuleBase
        );
    FeCacheEntry* Promote(FeCacheEntry* Entry);
    
    ULONG64 FunctionTableBase(
        HANDLE                         Process,
        PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
        ULONG64                        Base,
        PULONG                         Size
        );
};

//----------------------------------------------------------------------------
//
// Ia64FunctionEntryCache.
//
//----------------------------------------------------------------------------

class Ia64FunctionEntryCache : public FunctionEntryCache
{
public:
    Ia64FunctionEntryCache(void) :
        FunctionEntryCache(sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY),
                           sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY),
                           IMAGE_FILE_MACHINE_IA64)
    {
    }

protected:
    virtual void TranslateRawData(FeCacheEntry* Entry);
    virtual void TranslateRvaDataToRawData(PIMGHLP_RVA_FUNCTION_DATA RvaData,
                                           ULONG64 ModuleBase,
                                           FeCacheData* Data);
};

//----------------------------------------------------------------------------
//
// Amd64FunctionEntryCache.
//
//----------------------------------------------------------------------------

class Amd64FunctionEntryCache : public FunctionEntryCache
{
public:
    Amd64FunctionEntryCache(void) :
        FunctionEntryCache(sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY),
                           sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY),
                           IMAGE_FILE_MACHINE_AMD64)
    {
    }

protected:
    virtual void TranslateRawData(FeCacheEntry* Entry);
    virtual void TranslateRvaDataToRawData(PIMGHLP_RVA_FUNCTION_DATA RvaData,
                                           ULONG64 ModuleBase,
                                           FeCacheData* Data);
};

//----------------------------------------------------------------------------
//
// AlphaFunctionEntryCache.
//
//----------------------------------------------------------------------------

class AlphaFunctionEntryCache : public FunctionEntryCache
{
public:
    AlphaFunctionEntryCache(ULONG ImageDataSize, ULONG CacheDataSize,
                            ULONG Machine) :
        FunctionEntryCache(ImageDataSize, CacheDataSize, Machine)
    {
    }

protected:
    virtual void TranslateRvaDataToRawData(PIMGHLP_RVA_FUNCTION_DATA RvaData,
                                           ULONG64 ModuleBase,
                                           FeCacheData* Data);
    virtual FeCacheEntry* SearchForPrimaryEntry(
        FeCacheEntry* CacheEntry,
        HANDLE Process,
        PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
        PGET_MODULE_BASE_ROUTINE64 GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
        );
};

//----------------------------------------------------------------------------
//
// ArmFunctionEntryCache.
//
//----------------------------------------------------------------------------

class ArmFunctionEntryCache : public FunctionEntryCache
{
public:
    ArmFunctionEntryCache(void) :
        FunctionEntryCache(sizeof(IMAGE_ARM_RUNTIME_FUNCTION_ENTRY),
                           sizeof(IMAGE_ARM_RUNTIME_FUNCTION_ENTRY),
                           IMAGE_FILE_MACHINE_ARM)
    {
    }

protected:
    virtual void TranslateRawData(FeCacheEntry* Entry);
    virtual void TranslateRvaDataToRawData(PIMGHLP_RVA_FUNCTION_DATA RvaData,
                                           ULONG64 ModuleBase,
                                           FeCacheData* Data);
};

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

FunctionEntryCache* GetFeCache(ULONG Machine, BOOL Create);
void ClearFeCaches(void);

#endif // #ifndef __FECACHE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\imagechk.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    imagechk.c

Abstract:

    this module implements a sanity check of certain image characteristics

Author:

    NT Base

Revision History:


Notes:


--*/

#ifdef __cplusplus
extern "C" {
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
#define RTL_SIZEOF_THROUGH_FIELD(type, field) \
    (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))


#include <errno.h>
#include <direct.h>
#include <cvinfo.h>
#include <private.h>

typedef struct _SYMMODLIST{
    char *ModName;
    void *ModBase;
    struct _SYMMODLIST *Next;
} SYMMODLIST, *PSYMMODLIST;

typedef struct List {
    char            Name[40];
    unsigned long   Attributes;
} List, *pList;

typedef struct _LogListItem {
    char *LogLine;
    struct _LogListItem *Next;
} LogListItem, *pLogListItem;

//
// decarations
//

VOID
FindFiles();

VOID
Imagechk(
    List *rgpList,
    TCHAR *szDirectory
    );

VOID
ParseArgs(
    int *pargc,
    char **argv
    );

int
__cdecl
CompFileAndDir(
    const void *elem1,
    const void *elem2
    );

int
__cdecl
CompName(
    const void *elem1,
    const void *elem2
    );

VOID
Usage(
    VOID
    );

int
_cdecl
_cwild(
    VOID
    );

PSYMMODLIST
MakeModList(
    HANDLE
    );

void
FreeModList(
    PSYMMODLIST
    );

BOOL
CALLBACK
SymEnumerateModulesCallback(
    LPSTR,
    ULONG64,
    PVOID
    );

void *
GetModAddrFromName(
    PSYMMODLIST,
    char *
    );

BOOL
VerifyVersionResource(
    PCHAR FileName,
    BOOL fSelfRegister
    );

BOOL
ValidatePdata(
    PIMAGE_DOS_HEADER DosHeader
    );

BOOL
ImageNeedsOleSelfRegister(
    PIMAGE_DOS_HEADER DosHeader
    );

NTSTATUS
MiVerifyImageHeader (
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PIMAGE_DOS_HEADER DosHeader,
    IN DWORD NtHeaderSize
    );

pLogListItem
LogAppend(
    char *,
    pLogListItem
    );

void
LogOutAndClean(
    BOOL
    );

void
__cdecl
LogPrintf(
    const char *format,
    ...
    );

#define X64K (64*1024)

#define MM_SIZE_OF_LARGEST_IMAGE ((ULONG)0x10000000)

#define MM_MAXIMUM_IMAGE_HEADER (2 * PageSize)

#define MM_MAXIMUM_IMAGE_SECTIONS                       \
     ((MM_MAXIMUM_IMAGE_HEADER - (4096 + sizeof(IMAGE_NT_HEADERS))) /  \
            sizeof(IMAGE_SECTION_HEADER))

#define MMSECTOR_SHIFT 9  //MUST BE LESS THAN OR EQUAL TO PageShift

#define MMSECTOR_MASK 0x1ff

#define MI_ROUND_TO_SIZE(LENGTH,ALIGNMENT)     \
                    (((ULONG)LENGTH + ALIGNMENT - 1) & ~(ALIGNMENT - 1))

#define BYTES_TO_PAGES(Size)  (((ULONG)(Size) >> PageShift) + \
                               (((ULONG)(Size) & (PageSize - 1)) != 0))

#define ArgFlag_OK      1
#define ArgFlag_CKMZ    2
#define ArgFlag_SymCK   4
#define ArgFlag_OLESelf 8
#define ArgFlag_CKBase  16

//
// file global data
//

BOOL fRecurse;
BOOL fFileOut;
BOOL fNotCurrent;
BOOL fPattern;
BOOL fSingleFile;
BOOL fPathOverride;
BOOL fSingleSlash;
BOOL fDebugMapped;
FILE* fout;
CHAR *szFileName = {"*.*"};
CHAR *pszRootDir;
CHAR *pszFileOut;
CHAR szDirectory[MAX_PATH] = {"."};
CHAR szSympath[MAX_PATH] = {0};
CHAR *szPattern;
int endpath, DirNum=1, ProcessedFiles;
ULONG PageSize;
ULONG PageShift;
PVOID HighestUserAddress;
USHORT ValidMachineIDMin;
USHORT ValidMachineIDMax;
DWORD ArgFlag;

//
// logging support
//

pLogListItem pLogList = NULL;
pLogListItem pLogListTmp = NULL;

typedef
NTSTATUS
(NTAPI *LPLDRVERIFYIMAGECHKSUM)(
    IN HANDLE ImageFileHandle
    );

LPLDRVERIFYIMAGECHKSUM lpOldLdrVerifyImageMatchesChecksum;

typedef
NTSTATUS
(NTAPI *LPLDRVERIFYIMAGEMATCHESCHECKSUM) (
    IN HANDLE ImageFileHandle,
    IN PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine OPTIONAL,
    IN PVOID ImportCallbackParameter,
    OUT PUSHORT ImageCharacteristics OPTIONAL
    );

LPLDRVERIFYIMAGEMATCHESCHECKSUM lpNewLdrVerifyImageMatchesChecksum;

typedef
NTSTATUS
(NTAPI *LPNTQUERYSYSTEMINFORMATION) (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

LPNTQUERYSYSTEMINFORMATION lpNtQuerySystemInformation;


OSVERSIONINFO VersionInformation;

//
// function definitions
//

VOID __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
/*++

Routine Description:

    program entry

Arguments:

    int     argc,
    char    *argv[]
    char    *envp[]

Return Value:

    none

Notes:


--*/
{
    TCHAR CWD[MAX_PATH];
    int dirlen=0;

    if (argc < 2) {
        Usage();
    }

    ParseArgs(&argc, argv);

    GetCurrentDirectory(MAX_PATH, CWD);

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        fprintf(stderr, "Unable to detect OS version.  Terminating.\n" );
        exit(1);
    }
    if ((VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
        (VersionInformation.dwBuildNumber < 1230))
    {
        lpOldLdrVerifyImageMatchesChecksum = (LPLDRVERIFYIMAGECHKSUM)
            GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), TEXT("LdrVerifyImageMatchesChecksum"));
        if (lpOldLdrVerifyImageMatchesChecksum == NULL) {
            fprintf(stderr, "Incorrect operating system version.\n" );
            exit(1);
        }
    } else {
        lpOldLdrVerifyImageMatchesChecksum = NULL;
        if ((VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (VersionInformation.dwBuildNumber >= 1230))
        {
            lpNewLdrVerifyImageMatchesChecksum = (LPLDRVERIFYIMAGEMATCHESCHECKSUM)
                GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), TEXT("LdrVerifyImageMatchesChecksum"));
            if (lpNewLdrVerifyImageMatchesChecksum == NULL) {
                fprintf(stderr, "OS is screwed up.  NTDLL doesn't export LdrVerifyImageMatchesChecksum.\n" );
                exit(1);
            }
        }
    }

    if (VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        SYSTEM_BASIC_INFORMATION SystemInformation;

        if (VersionInformation.dwBuildNumber <= 1465) {
            goto UseWin9x;
        }

        ValidMachineIDMin = USER_SHARED_DATA->ImageNumberLow;
        ValidMachineIDMax = USER_SHARED_DATA->ImageNumberHigh;
        lpNtQuerySystemInformation = (LPNTQUERYSYSTEMINFORMATION)
            GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), TEXT("NtQuerySystemInformation"));
        if (!lpNtQuerySystemInformation) {
            fprintf(stderr, "Incorrect operation system version.\n");
            exit(1);
        }
        if (!NT_SUCCESS((*lpNtQuerySystemInformation)(SystemBasicInformation,
                                                     &SystemInformation,
                                                     sizeof(SystemInformation),
                                                     NULL))) {
            fprintf(stderr, "OS is screwed up.  NtQuerySystemInformation failed.\n");
            exit(1);
        }
        HighestUserAddress = (PVOID)SystemInformation.MaximumUserModeAddress;
    } else {
UseWin9x:
        HighestUserAddress = (PVOID) 0x7FFE0000;
#ifdef _M_IX86
        ValidMachineIDMin = IMAGE_FILE_MACHINE_I386;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_I386;
#elif defined(_M_AMD64)
        ValidMachineIDMin = IMAGE_FILE_MACHINE_AMD64;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_AMD64;
#elif defined(_M_IA64)
        ValidMachineIDMin = IMAGE_FILE_MACHINE_IA64;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_IA64;
#else
#error("Unknown machine type")
#endif
    }

    if (fPathOverride) {
        if (_chdir(szDirectory) == -1){   // cd to dir
            fprintf(stderr, "Path not found: %s\n", szDirectory);
            Usage();
        }
    }
    // remove trailing '\' needed only for above chdir, not for output formatting
    if (fSingleSlash) {
        dirlen = strlen(szDirectory);
        szDirectory[dirlen-1] = '\0';
    }

    FindFiles();

    fprintf(stdout, "%d files processed in %d directories\n", ProcessedFiles, DirNum);
}

VOID
FindFiles()
/*++

Routine Description:

    make list of files to check, then check them

Arguments:

    none

Return Value:

    none

Notes:


--*/
{

    HANDLE fh;
    TCHAR CWD[MAX_PATH];
    char *q;
    WIN32_FIND_DATA *pfdata;
    BOOL fFilesInDir=FALSE;
    BOOL fDirsFound=FALSE;
    int dnCounter=0, cNumDir=0, i=0, Length=0, NameSize=0, total=0, cNumFiles=0;

    pList rgpList[5000];

    pfdata = (WIN32_FIND_DATA*)malloc(sizeof(WIN32_FIND_DATA));
    if (!pfdata) {
        fprintf(stderr, "Not enough memory.\n");
        return;
    }

    if (!fRecurse) {
        fh = FindFirstFile(szFileName, pfdata);  // find only filename (pattern) if not recursive
    } else {
        fh = FindFirstFile("*.*", pfdata);       // find all if recursive in order to determine subdirectory names
    }

    if (fh == INVALID_HANDLE_VALUE) {
        fprintf(fout==NULL? stderr : fout , "File not found: %s\n", szFileName);
        return;
    }

    // loop to find all files and directories in current directory
    // and copy pertinent data to individual List structures.
    do {
        if (strcmp(pfdata->cFileName, ".") && strcmp(pfdata->cFileName, "..")) {  // skip . and ..
            rgpList[dnCounter] = (pList)malloc(sizeof(List));  // allocate the memory
            if (!rgpList[dnCounter]) {
                fprintf(stderr, "Not enough memory.\n");
                return;
            }

            if (!(pfdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {   // if file

                fFilesInDir=TRUE;

                // see if given pattern wildcard extension matches pfdata->cFileName extension
                if (fPattern) {
                    q = strchr(pfdata->cFileName, '.');    // find first instance of "." in filename
                    if (q == NULL) goto blah;             // "." not found
                    _strlwr(q);                            // lowercase before compare
                    if (strcmp(q, szPattern)) goto blah;  // if pattern and name doesn't match goto
                }                                        // OK, I used a goto, get over it.

                if (fSingleFile) {
                    _strlwr(pfdata->cFileName);
                    _strlwr(szFileName);
                    if (strcmp(pfdata->cFileName, szFileName)) goto blah;
                }

                // if pattern && match || no pattern
                strcpy(rgpList[dnCounter]->Name, pfdata->cFileName);
                _strlwr(rgpList[dnCounter]->Name);  // all lowercase for strcmp in CompName

                memcpy(&(rgpList[dnCounter]->Attributes), &pfdata->dwFileAttributes, 4);
                dnCounter++;
                cNumFiles++;
            } else {
                if (pfdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {   // if dir

                    fDirsFound=TRUE;
                    //cNumDir++;

                    if (fRecurse) {
                        strcpy(rgpList[dnCounter]->Name, pfdata->cFileName);
                        _strlwr(rgpList[dnCounter]->Name);  // all lowercase for strcmp in CompName
                        memcpy(&(rgpList[dnCounter]->Attributes), &pfdata->dwFileAttributes, 4);
                        cNumDir++;
                        dnCounter++;
                    }
                }
            }
        }
blah: ;

    } while (FindNextFile(fh, pfdata));

    FindClose(fh); // close the file handle

    // Sort Array arranging FILE entries at top
    qsort( (void *)rgpList, dnCounter, sizeof(List *), CompFileAndDir);

    // Sort Array alphabetizing only FILE names
    qsort( (void *)rgpList, dnCounter-cNumDir, sizeof(List *), CompName);

    // Sort Array alphabetizing only DIRectory names
    if (fRecurse) {
        qsort( (void *)&rgpList[dnCounter-cNumDir], cNumDir, sizeof(List *), CompName);
    }

    // Process newly sorted structures.
    for (i=0; i < dnCounter; ++i) {

        if (rgpList[i]->Attributes & FILE_ATTRIBUTE_DIRECTORY) {  // if Dir
            if (fRecurse) {

                if (_chdir(rgpList[i]->Name) == -1){   // cd into subdir and check for error
                    fprintf(stderr, "Unable to change directory: %s\n", rgpList[i]->Name);

                } else {

                    NameSize = strlen(rgpList[i]->Name);
                    strcat(szDirectory, "\\");
                    strcat(szDirectory, rgpList[i]->Name); //append name to directory path
                    total = strlen(szDirectory);
                    DirNum++;      // directory counter

                    // start another iteration of FindFiles
                    FindFiles();

                    // get back to previous directory when above iteration returns
                    _chdir("..");

                    // cut off previously appended directory name - for output only
                    szDirectory[total-(NameSize+1)]='\0';
                }
            }
        } else {
            if (!(rgpList[i]->Attributes & FILE_ATTRIBUTE_DIRECTORY))   // check image if not dir
                Imagechk(rgpList[i], szDirectory);
        }
    }
} // end FindFiles

VOID
Imagechk(
    List *rgpList,
    TCHAR *szDirectory
    )
/*++

Routine Description:

    check various things, including:
        image type, header alignment, image size, machine type
        alignment, some properties of various sections, checksum integrity
        symbol / image file checksum agreement, existence of symbols, etc

Arguments:

    List *  rgpList,
    TCHAR * szDirectory

Return Value:

    none

Notes:


--*/
{

    HANDLE File;
    HANDLE MemMap;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeader;
    NTSTATUS Status;
    BY_HANDLE_FILE_INFORMATION FileInfo;
    ULONG NumberOfPtes;
    ULONG SectionVirtualSize = 0;
    ULONG i;
    PIMAGE_SECTION_HEADER SectionTableEntry;
    ULONG NumberOfSubsections;
    PCHAR ExtendedHeader = NULL;
    ULONG_PTR PreferredImageBase;
    ULONG_PTR NextVa;
    ULONG ImageFileSize;
    ULONG OffsetToSectionTable;
    ULONG ImageAlignment;
    ULONG PtesInSubsection;
    ULONG StartingSector;
    ULONG EndingSector;
    LPSTR ImageName;
    LPSTR MachineType = "Unknown";
    BOOL MachineTypeMismatch;
    BOOL ImageOk;
    BOOL fHasPdata;
    OSVERSIONINFO OSVerInfo;

    ImageName = rgpList->Name;
    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSVerInfo);

    LogPrintf("ImageChk: %s\\%s \n", szDirectory, ImageName);

    ProcessedFiles++;

    DosHeader = NULL;
    ImageOk = TRUE;
    File = CreateFile (ImageName,
                        GENERIC_READ | FILE_EXECUTE,
                        OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_READ | FILE_SHARE_DELETE) : FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (File == INVALID_HANDLE_VALUE) {
        LogPrintf("Error, CreateFile() %d\n", GetLastError());
        ImageOk = FALSE;
        goto NextImage;
    }

    MemMap = CreateFileMapping (File,
                        NULL,           // default security.
                        PAGE_READONLY,  // file protection.
                        0,              // high-order file size.
                        0,
                        NULL);

    if (!GetFileInformationByHandle(File, &FileInfo)) {
        fprintf(stderr,"Error, GetFileInfo() %d\n", GetLastError());
        CloseHandle(File);
        ImageOk = FALSE; goto NextImage;
    }

    DosHeader = (PIMAGE_DOS_HEADER) MapViewOfFile(MemMap,
                              FILE_MAP_READ,
                              0,  // high
                              0,  // low
                              0   // whole file
                              );

    CloseHandle(MemMap);
    if (!DosHeader) {
        fprintf(stderr,"Error, MapViewOfFile() %d\n", GetLastError());
        ImageOk = FALSE; goto NextImage;
    }

    //
    // Check to determine if this is an NT image (PE format) or
    // a DOS image, Win-16 image, or OS/2 image.  If the image is
    // not NT format, return an error indicating which image it
    // appears to be.
    //

    if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE) {

        if (ArgFlag & ArgFlag_CKMZ) {
            LogPrintf("MZ header not found\n");
            ImageOk = FALSE;
        }
        goto NeImage;
    }


    if (((ULONG)DosHeader->e_lfanew & 3) != 0) {

        //
        // The image header is not aligned on a long boundary.
        // Report this as an invalid protect mode image.
        //

        LogPrintf("Image header not on Long boundary\n");
        ImageOk = FALSE;
        goto NeImage;
    }


    if ((ULONG)DosHeader->e_lfanew > FileInfo.nFileSizeLow) {
        LogPrintf("Image size bigger than size of file\n");
        ImageOk = FALSE;
        goto NeImage;
    }

    NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)DosHeader + (ULONG)DosHeader->e_lfanew);

    if (NtHeader->Signature != IMAGE_NT_SIGNATURE) { //if not PE image

        LogPrintf("Non 32-bit image");
        ImageOk = TRUE;
        goto NeImage;
    }

    //
    // Check to see if this is an NT image or a DOS or OS/2 image.
    //

    Status = MiVerifyImageHeader (NtHeader, DosHeader, 50000);
    if (Status != STATUS_SUCCESS) {
        ImageOk = FALSE;            //continue checking the image but don't print "OK"
    }

    //
    // Verify machine type.
    //

    fHasPdata = TRUE;       // Most do

    switch (NtHeader->FileHeader.Machine) {
        case IMAGE_FILE_MACHINE_I386:
            MachineType = "x86";
            PageSize = 4096;
            PageShift = 12;
            fHasPdata = FALSE;
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
            MachineType = "Alpha";
            PageSize = 8192;
            PageShift = 13;
            break;

        case IMAGE_FILE_MACHINE_IA64:
            MachineType = "Intel64";
            PageSize = 8192;
            PageShift = 13;
            break;

        case IMAGE_FILE_MACHINE_ALPHA64:
            MachineType = "Alpha64";
            PageSize = 8192;
            PageShift = 13;
            break;

        default:
            LogPrintf("Unrecognized machine type x%lx\n",
                NtHeader->FileHeader.Machine);
            ImageOk = FALSE;
            break;
        }

    if ((NtHeader->FileHeader.Machine < ValidMachineIDMin) ||
        (NtHeader->FileHeader.Machine > ValidMachineIDMax)) {
        MachineTypeMismatch = TRUE;
    } else {
        MachineTypeMismatch = FALSE;
    }

    ImageAlignment = NtHeader->OptionalHeader.SectionAlignment;

    NumberOfPtes = BYTES_TO_PAGES (NtHeader->OptionalHeader.SizeOfImage);

    NextVa = NtHeader->OptionalHeader.ImageBase;

    if ((NextVa & (X64K - 1)) != 0) {

        //
        // Image header is not aligned on a 64k boundary.
        //

        LogPrintf("image base not on 64k boundary %lx\n",NextVa);

        ImageOk = FALSE;
        goto BadPeImageSegment;
    }

    //BasedAddress = (PVOID)NextVa;
    PtesInSubsection = MI_ROUND_TO_SIZE (
                                       NtHeader->OptionalHeader.SizeOfHeaders,
                                       ImageAlignment
                                   ) >> PageShift;

    if (ImageAlignment >= PageSize) {

        //
        // Aligmment is PageSize of greater.
        //

        if (PtesInSubsection > NumberOfPtes) {

            //
            // Inconsistent image, size does not agree with header.
            //

            LogPrintf("Image size in header (%ld.) not consistent with sections (%ld.)\n",
                    NumberOfPtes, PtesInSubsection);
            ImageOk = FALSE;
            goto BadPeImageSegment;
        }

        NumberOfPtes -= PtesInSubsection;

        EndingSector = NtHeader->OptionalHeader.SizeOfHeaders >> MMSECTOR_SHIFT;

        for (i = 0; i < PtesInSubsection; i++) {

            NextVa += PageSize;
        }
    }

    //
    // Build the next subsections.
    //

    NumberOfSubsections = NtHeader->FileHeader.NumberOfSections;
    PreferredImageBase = NtHeader->OptionalHeader.ImageBase;

    //
    // At this point the object table is read in (if it was not
    // already read in) and may displace the image header.
    //

    OffsetToSectionTable = sizeof(ULONG) +
                              sizeof(IMAGE_FILE_HEADER) +
                              NtHeader->FileHeader.SizeOfOptionalHeader;

    SectionTableEntry = (PIMAGE_SECTION_HEADER)((PCHAR)NtHeader + OffsetToSectionTable);

    if (ImageAlignment < PageSize) {

        // The image header is no longer valid, TempPte is
        // used to indicate that this image alignment is
        // less than a PageSize.

        //
        // Loop through all sections and make sure there is no
        // unitialized data.
        //

        while (NumberOfSubsections > 0) {
            if (SectionTableEntry->Misc.VirtualSize == 0) {
                SectionVirtualSize = SectionTableEntry->SizeOfRawData;
            } else {
                SectionVirtualSize = SectionTableEntry->Misc.VirtualSize;
            }

            //
            // If the pointer to raw data is zero and the virtual size
            // is zero, OR, the section goes past the end of file, OR
            // the virtual size does not match the size of raw data, then
            // return an error.
            //

            if (((SectionTableEntry->PointerToRawData !=
                  SectionTableEntry->VirtualAddress))
                        ||
                ((SectionTableEntry->SizeOfRawData +
                        SectionTableEntry->PointerToRawData) >
                     FileInfo.nFileSizeLow)
                        ||
               (SectionVirtualSize > SectionTableEntry->SizeOfRawData)) {

                LogPrintf("invalid BSS/Trailingzero section/file size\n");

                ImageOk = FALSE;
                goto NeImage;
            }
            SectionTableEntry += 1;
            NumberOfSubsections -= 1;
        }
        goto PeReturnSuccess;
    }

    while (NumberOfSubsections > 0) {

        //
        // Handle case where virtual size is 0.
        //

        if (SectionTableEntry->Misc.VirtualSize == 0) {
            SectionVirtualSize = SectionTableEntry->SizeOfRawData;
        } else {
            SectionVirtualSize = SectionTableEntry->Misc.VirtualSize;
        }

        if (!strcmp(SectionTableEntry->Name, ".debug")) {
            fDebugMapped = TRUE;
        }

        if (SectionVirtualSize == 0) {
            //
            // The specified virtual address does not align
            // with the next prototype PTE.
            //

            LogPrintf("Section virtual size is 0, NextVa for section %lx %lx\n",
                    SectionTableEntry->VirtualAddress, NextVa);
            ImageOk = FALSE;
            goto BadPeImageSegment;
        }

        if (NextVa !=
                (PreferredImageBase + SectionTableEntry->VirtualAddress)) {

            //
            // The specified virtual address does not align
            // with the next prototype PTE.
            //

            LogPrintf("Section Va not set to alignment, NextVa for section %lx %lx\n",
                    SectionTableEntry->VirtualAddress, NextVa);
            ImageOk = FALSE;
            goto BadPeImageSegment;
        }

        PtesInSubsection =
            MI_ROUND_TO_SIZE (SectionVirtualSize, ImageAlignment) >> PageShift;

        if (PtesInSubsection > NumberOfPtes) {

            //
            // Inconsistent image, size does not agree with object tables.
            //
            LogPrintf("Image size in header not consistent with sections, needs %ld. pages\n",
                PtesInSubsection - NumberOfPtes);
            LogPrintf("va of bad section %lx\n",SectionTableEntry->VirtualAddress);

            ImageOk = FALSE;
            goto BadPeImageSegment;
        }
        NumberOfPtes -= PtesInSubsection;

        StartingSector = SectionTableEntry->PointerToRawData >> MMSECTOR_SHIFT;
        EndingSector =
                         (SectionTableEntry->PointerToRawData +
                                     SectionVirtualSize);
        EndingSector = EndingSector >> MMSECTOR_SHIFT;

        ImageFileSize = SectionTableEntry->PointerToRawData +
                                    SectionTableEntry->SizeOfRawData;

        for (i = 0; i < PtesInSubsection; i++) {

            //
            // Set all the prototype PTEs to refer to the control section.
            //

            NextVa += PageSize;
        }

        SectionTableEntry += 1;
        NumberOfSubsections -= 1;
    }

    //
    // If the file size is not as big as the image claimed to be,
    // return an error.
    //

    if (ImageFileSize > FileInfo.nFileSizeLow) {

        //
        // Invalid image size.
        //

        LogPrintf("invalid image size - file size %lx - image size %lx\n",
            FileInfo.nFileSizeLow, ImageFileSize);
        ImageOk = FALSE;
        goto BadPeImageSegment;
    }

    {
        // Validate the debug information (as much as we can).
        PVOID ImageBase;
        ULONG DebugDirectorySize, NumberOfDebugDirectories;
        PIMAGE_DEBUG_DIRECTORY DebugDirectory;

        ImageBase = (PVOID) DosHeader;

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
            ImageDirectoryEntryToData(
                ImageBase,
                FALSE,
                IMAGE_DIRECTORY_ENTRY_DEBUG,
                &DebugDirectorySize );

        if (!DebugDirectoryIsUseful(DebugDirectory, DebugDirectorySize)) {

            // Not useful.  Are they valid? (both s/b zero)

            if (DebugDirectory || DebugDirectorySize) {
                LogPrintf("Debug directory values [%x, %x] are invalid\n",
                        DebugDirectory,
                        DebugDirectorySize);
                ImageOk = FALSE;
            }

            goto DebugDirsDone;
        }

        NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

        for (i=0; i < NumberOfDebugDirectories; i++) {
            if (DebugDirectory->PointerToRawData > FileInfo.nFileSizeLow) {
                LogPrintf("Invalid debug directory entry[%d] - File Offset %x is beyond the end of the file\n",
                        i,
                        DebugDirectory->PointerToRawData
                       );
                ImageOk = FALSE;
                goto BadPeImageSegment;
            }

            if ((DebugDirectory->PointerToRawData + DebugDirectory->SizeOfData) > FileInfo.nFileSizeLow) {
                LogPrintf("Invalid debug directory entry[%d] - File Offset (%X) + Size (%X) is beyond the end of the file (filesize: %X)\n",
                        i,
                        DebugDirectory->PointerToRawData,
                        DebugDirectory->SizeOfData,
                        FileInfo.nFileSizeLow
                       );
                ImageOk = FALSE;
                goto BadPeImageSegment;
            }
#if 0
            if (DebugDirectory->AddressOfRawData != 0) {
                if (DebugDirectory->AddressOfRawData > ImageFileSize){
                    LogPrintf("Invalid debug directory entry[%d] - VA (%X) is beyond the end of the image VA (%X)\n",
                            i,
                            DebugDirectory->AddressOfRawData,
                            ImageFileSize);
                    ImageOk = FALSE;
                    goto BadPeImageSegment;
                }

                if ((DebugDirectory->AddressOfRawData + DebugDirectory->SizeOfData )> ImageFileSize){
                    LogPrintf("Invalid debug directory entry[%d] - VA (%X) + size (%X) is beyond the end of the image VA (%X)\n",
                            i,
                            DebugDirectory->AddressOfRawData,
                            DebugDirectory->SizeOfData,
                            ImageFileSize);
                    ImageOk = FALSE;
                    goto BadPeImageSegment;
                }
            }
#endif

            if (DebugDirectory->Type <= 0x7fffffff) {
                switch (DebugDirectory->Type) {
                    case IMAGE_DEBUG_TYPE_MISC:
                        {
                            PIMAGE_DEBUG_MISC pDebugMisc;
                            // MISC should point to an IMAGE_DEBUG_MISC structure
                            pDebugMisc = (PIMAGE_DEBUG_MISC)((PCHAR)ImageBase + DebugDirectory->PointerToRawData);
                            if (pDebugMisc->DataType != IMAGE_DEBUG_MISC_EXENAME) {
                                LogPrintf("MISC Debug has an invalid DataType\n");
                                ImageOk = FALSE;
                                goto BadPeImageSegment;
                            }
                            if (pDebugMisc->Length != DebugDirectory->SizeOfData) {
                                LogPrintf("MISC Debug has an invalid size.\n");
                                ImageOk = FALSE;
                                goto BadPeImageSegment;
                            }

                            if (!pDebugMisc->Unicode) {
                                i= 0;
                                while (i < pDebugMisc->Length - sizeof(IMAGE_DEBUG_MISC)) {
                                    if (!isprint(pDebugMisc->Data[i]) &&
                                        (pDebugMisc->Data[i] != '\0') )
                                    {
                                        LogPrintf("MISC Debug has unprintable characters... Possibly corrupt\n");
                                        ImageOk = FALSE;
                                        goto BadPeImageSegment;
                                    }
                                    i++;
                                }

                                // The data must be a null terminated string.
                                if (strlen(pDebugMisc->Data) > (pDebugMisc->Length - sizeof(IMAGE_DEBUG_MISC))) {
                                    LogPrintf("MISC Debug has invalid data... Possibly corrupt\n");
                                    ImageOk = FALSE;
                                    goto BadPeImageSegment;
                                }
                            }
                        }
                        break;

                    case IMAGE_DEBUG_TYPE_CODEVIEW:
                        // CV will point to either a NB09 or an NB10 signature.  Make sure it does.
                        {
                            OMFSignature * CVDebug;
                            CVDebug = (OMFSignature *)((PCHAR)ImageBase + DebugDirectory->PointerToRawData);
                            if (((*(PULONG)(CVDebug->Signature)) != '90BN') &&
                                ((*(PULONG)(CVDebug->Signature)) != '01BN') &&
                                ((*(PULONG)(CVDebug->Signature)) != 'SDSR'))
                            {
                                LogPrintf("CV Debug has an invalid signature\n");
                                ImageOk = FALSE;
                                goto BadPeImageSegment;
                            }
                        }
                        break;

                    case IMAGE_DEBUG_TYPE_COFF:
                    case IMAGE_DEBUG_TYPE_FPO:
                    case IMAGE_DEBUG_TYPE_EXCEPTION:
                    case IMAGE_DEBUG_TYPE_FIXUP:
                    case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                    case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                        // Not much we can do about these now.
                        break;

                    default:
                        LogPrintf("Invalid debug directory type: %d\n", DebugDirectory->Type);
                        ImageOk = FALSE;
                        goto BadPeImageSegment;
                        break;
                }
            }
        }

    }

DebugDirsDone:

    //
    // The total number of PTEs was decremented as sections were built,
    // make sure that there are less than 64ks worth at this point.
    //

    if (NumberOfPtes >= (ImageAlignment >> PageShift)) {

        //
        // Inconsistent image, size does not agree with object tables.
        //

        LogPrintf("invalid image - PTEs left %lx\n",
            NumberOfPtes);

        ImageOk = FALSE;
        goto BadPeImageSegment;
    }

    // Verify LoadConfig data (if available)

    {
        PIMAGE_LOAD_CONFIG_DIRECTORY LoadConfigDirectory;
        ULONG LoadConfigDirectorySize;
        LoadConfigDirectory = (PIMAGE_LOAD_CONFIG_DIRECTORY)
            ImageDirectoryEntryToData(
                (PVOID) DosHeader,
                FALSE,
                IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                &LoadConfigDirectorySize );
    
        if (LoadConfigDirectory) {
            if (!LoadConfigDirectorySize) {
                // LOAD_CONFIG directory size in the image header is not set (s/b 0x40 on X86)
                LogPrintf("LoadConfig pointer set, but size is not\n");
                ImageOk = FALSE;
                goto BadPeImageSegment;
            }
    
            if (LoadConfigDirectory->Size) {
                // Version 2 load config - check the SEH fields.
                if (LoadConfigDirectory->Size == RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, SEHandlerTable)) {
                    // SEH Handler table is on, but count isn't.  Bad.
                    LogPrintf("LoadConfig pointer set, but size is not\n");
                    ImageOk = FALSE;
                    goto BadPeImageSegment;
                }
                if (LoadConfigDirectory->Size >= RTL_SIZEOF_THROUGH_FIELD(IMAGE_LOAD_CONFIG_DIRECTORY, SEHandlerCount)) {
                    // Have both a count and table - check them
                    if (LoadConfigDirectory->SEHandlerTable) {
                        // Table exists.
                        if (!LoadConfigDirectory->SEHandlerCount) {
                            LogPrintf("Loadconfig structure invalid - SEH table pointer exists, but count is zero\n");
                            ImageOk = FALSE;
                            goto BadPeImageSegment;
                        }
                        if (LoadConfigDirectory->SEHandlerTable < NtHeader->OptionalHeader.ImageBase ||
                            (LoadConfigDirectory->SEHandlerTable > (NtHeader->OptionalHeader.ImageBase + NtHeader->OptionalHeader.SizeOfImage))){
                            // SEH handler table isn't within the image bounds
                            LogPrintf("Loadconfig structure invalid - SEH table pointer exists, but count is zero\n");
                            ImageOk = FALSE;
                            goto BadPeImageSegment;
                        }
                        if (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_SEH) {
                            LogPrintf("Image is marked as NO_SEH, yet SEH pointer is non-null\n");
                            ImageOk = FALSE;
                            goto BadPeImageSegment;
                        }
                    }
                    if (LoadConfigDirectory->SEHandlerCount) {
                        //  Count is non-zero
                        if (!LoadConfigDirectory->SEHandlerTable) {
                            LogPrintf("Loadconfig structure invalid - SEH count is non-zero but table pointer is null\n");
                            ImageOk = FALSE;
                            goto BadPeImageSegment;
                        }

                        if (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_SEH) {
                            LogPrintf("Image is marked as NO_SEH, yet SEH count is non-zero\n");
                            ImageOk = FALSE;
                            goto BadPeImageSegment;
                        }
                    }
                }
            }
        }
    }

    //
    // check checksum.
    //

PeReturnSuccess:
    if (NtHeader->OptionalHeader.CheckSum == 0) {
        LogPrintf("(checksum is zero)\n");
    } else {
        __try {
            if (lpOldLdrVerifyImageMatchesChecksum == NULL) {
                if (lpNewLdrVerifyImageMatchesChecksum == NULL) {
                    Status = STATUS_SUCCESS;
                    LogPrintf("Unable to validate checksum\n");
                } else {
                    Status = (*lpNewLdrVerifyImageMatchesChecksum)(File, NULL, NULL, NULL);
                }
            } else {
                Status = (*lpOldLdrVerifyImageMatchesChecksum)(File);
            }

            if (NT_ERROR(Status)) {
                DWORD HeaderSum, CheckSum;
                MapFileAndCheckSum(ImageName, &HeaderSum, &CheckSum);
                LogPrintf("checksum mismatch\tis: %x\ts/b: %x\n", NtHeader->OptionalHeader.CheckSum, CheckSum);
                ImageOk = FALSE;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            ImageOk = FALSE;
            LogPrintf("checksum mismatch\n");
            LogPrintf("LdrVerifyImageMatchesCheckSum AV'd\n");
        }
    }

    if (fHasPdata && ImageOk) {
        ImageOk = ValidatePdata(DosHeader);
    }

    if (ImageOk) {
        ImageOk = VerifyVersionResource(ImageName, ImageNeedsOleSelfRegister(DosHeader));
    }

    //
    // sanity test for symbols
    // basically : if this does not work, debugging probably will not either
    // these high-level debugging api's will also call a pdb validation routine
    //

    if(ArgFlag & ArgFlag_SymCK)
    {
        HANDLE hProcess = 0;
        char Target[MAX_PATH] = {0};
        char drive[_MAX_DRIVE];
        char dir[_MAX_DIR];
        char fname[_MAX_FNAME];
        char ext[_MAX_EXT];
        IMAGEHLP_MODULE64 ModuleInfo = {0};
        PSYMMODLIST ModList = 0;
        void *vpAddr;
        PLOADED_IMAGE pLImage = NULL;
        DWORD64 symLMflag;

        strcpy(Target, szDirectory);
        strcat(Target, "\\");
        strcat(Target, ImageName);

        //
        // set up for debugging
        //

        hProcess = GetCurrentProcess();

        if(!SymInitialize(hProcess, szSympath, FALSE))
        {
            LogPrintf("ERROR:SymInitialize failed!\n");
            hProcess = 0;
            goto symckend;
        }

        //
        // attempt to use symbols
        //

        _splitpath(Target, drive, dir, fname, ext );

        symLMflag = SymLoadModule64(hProcess, NULL, Target, fname, 0, 0);
        if(!symLMflag)
        {
            LogPrintf("ERROR:SymLoadModule failed! last error:0x%x\n", GetLastError());
            goto symckend;
        }

        //
        // identify module type
        // find module, symgetmoduleinfo, check dbg type
        //

        ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
        ModList = MakeModList(hProcess);
        vpAddr = GetModAddrFromName(ModList, fname);

        if(!SymGetModuleInfo64(hProcess, (DWORD64)vpAddr, &ModuleInfo))
        {
            LogPrintf("ERROR:SymGetModuleInfo failed! last error:0x%x\n", GetLastError());
            goto symckend;
        }

        if(ModuleInfo.SymType != SymPdb)
        {
            LogPrintf("WARNING: No pdb info for file!\n");
            switch(ModuleInfo.SymType){
                case SymNone:
                    LogPrintf("symtype: SymNone\n");
                    break;
                case SymCoff:
                    LogPrintf("symtype: SymCoff\n");
                    break;
                case SymCv:
                    LogPrintf("symtype: SymCv\n");
                    break;
                case SymPdb:
                    LogPrintf("symtype: SymPdb\n");
                    break;
                case SymExport:
                    LogPrintf("symtype: SymExport\n");
                    break;
                case SymDeferred:
                    LogPrintf("symtype: SymDeferred\n");
                    break;
                case SymSym:
                    LogPrintf("symtype: SymSym\n");
                    break;
            }
        }

        //
        // get image, symbol checksum, compare
        //

        pLImage = ImageLoad(Target, NULL);

        {
            CHAR szDbgPath[_MAX_PATH];
            HANDLE DbgFileHandle;

            DbgFileHandle = FindDebugInfoFile(Target, szSympath, szDbgPath);
            if (DbgFileHandle != INVALID_HANDLE_VALUE) {
                IMAGE_SEPARATE_DEBUG_HEADER DbgHeader;
                DWORD BytesRead;
                BOOL ReadSuccess;

                SetFilePointer(DbgFileHandle, 0, 0, FILE_BEGIN);
                ReadSuccess = ReadFile(DbgFileHandle, &DbgHeader, sizeof(DbgHeader), &BytesRead, NULL);

                if (ReadSuccess && (BytesRead == sizeof(DbgHeader))) {
                    // Got enough to check if it's a valid dbg file.
                    if(((PIMAGE_NT_HEADERS)pLImage->FileHeader)->OptionalHeader.CheckSum != DbgHeader.CheckSum) {
                        LogPrintf("ERROR! image / debug file checksum not equal\n");
                        ImageOk = FALSE;
                    }
                }
                CloseHandle(DbgFileHandle);
            }
        }

        //
        // cleanup
        //

symckend:
        if(ModList)
        {
            FreeModList(ModList);
        }
        if(pLImage)
        {
            ImageUnload(pLImage);
        }
        if(symLMflag)
        {
            SymUnloadModule64(hProcess, (DWORD)symLMflag);
        }
        if(hProcess)
        {
            SymCleanup(hProcess);
        }
    }

NextImage:
BadPeImageSegment:
NeImage:
    if ( ImageOk && (ArgFlag & ArgFlag_OK)) {
        if (MachineTypeMismatch) {
            LogPrintf(" OK [%s]\n", MachineType);
        } else {
            LogPrintf(" OK\n");
        }
    }

    //
    // print out results
    //

    if (ImageOk)
    {
        LogOutAndClean((ArgFlag & ArgFlag_OK) ? TRUE : FALSE);
    } else {
        LogOutAndClean(TRUE);
    }

    if ( File != INVALID_HANDLE_VALUE ) {
        CloseHandle(File);
    }
    if ( DosHeader ) {
        UnmapViewOfFile(DosHeader);
    }
}

NTSTATUS
MiVerifyImageHeader (
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PIMAGE_DOS_HEADER DosHeader,
    IN ULONG NtHeaderSize
    )
/*++

Routine Description:

    Checks image header for consistency.

Arguments:

    IN PIMAGE_NT_HEADERS    NtHeader
    IN PIMAGE_DOS_HEADER    DosHeader
    IN ULONG                NtHeaderSize

Return Value:

    Returns the status value.

    TBS

--*/
{

    if ((NtHeader->FileHeader.Machine == 0) &&
        (NtHeader->FileHeader.SizeOfOptionalHeader == 0)) {

        //
        // This is a bogus DOS app which has a 32-bit portion
        // mascarading as a PE image.
        //

        LogPrintf("Image machine type and size of optional header bad\n");
        return STATUS_INVALID_IMAGE_PROTECT;
    }

    if (!(NtHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)) {
        LogPrintf("Characteristics not image file executable\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

#ifdef i386

    //
    // Make sure the image header is aligned on a Long word boundary.
    //

    if (((ULONG)NtHeader & 3) != 0) {
        LogPrintf("NtHeader is not aligned on longword boundary\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }
#endif

    // Non-driver code must have file alignment set to a multiple of 512

    if (((NtHeader->OptionalHeader.FileAlignment & 511) != 0) &&
        (NtHeader->OptionalHeader.FileAlignment !=
         NtHeader->OptionalHeader.SectionAlignment)) {
        LogPrintf("file alignment is not multiple of 512 and power of 2\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // File aligment must be power of 2.
    //

    if ((((NtHeader->OptionalHeader.FileAlignment << 1) - 1) &
        NtHeader->OptionalHeader.FileAlignment) !=
        NtHeader->OptionalHeader.FileAlignment) {
        LogPrintf("file alignment not power of 2\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (NtHeader->OptionalHeader.SectionAlignment < NtHeader->OptionalHeader.FileAlignment) {
        LogPrintf("SectionAlignment < FileAlignment\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (NtHeader->OptionalHeader.SizeOfImage > MM_SIZE_OF_LARGEST_IMAGE) {
        LogPrintf("Image too big %lx\n",NtHeader->OptionalHeader.SizeOfImage);
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (NtHeader->FileHeader.NumberOfSections > MM_MAXIMUM_IMAGE_SECTIONS) {
        LogPrintf("Too many image sections %ld.\n",
                NtHeader->FileHeader.NumberOfSections);
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (ArgFlag & ArgFlag_CKBase) {
       if ((PVOID)NtHeader->OptionalHeader.ImageBase >= HighestUserAddress) {
          LogPrintf("Image base (%lx) is invalid on this machine\n",
                NtHeader->OptionalHeader.ImageBase);
          return STATUS_SUCCESS;
       }
    }

    return STATUS_SUCCESS;
}


VOID
ParseArgs(
    int *pargc,
    char **argv
    )
/*++

Routine Description:

    parse arguments to this program

Arguments:

    int *pargc
    char **argv

Return Value:

    none

Notes:

    command line args:
    (original)
    case '?': call usage and exit
    case 'b': check whether base address of image is in user space for this machine
    case 's': /s <sympath> check symbols
    case 'p': PE Errors only
    case 'r': recurse subdirectories
    (new)
    case 'v': verbose - output "OK"
    case 'o': output "OleSelfRegister not set"

--*/
{
    CHAR cswitch, c, *p;
    CHAR sztmp[MAX_PATH];
    int argnum = 1, i=0, len=0, count=0;
    BOOL fslashfound = FALSE;

    //
    // set default flags here
    //

    ArgFlag |= ArgFlag_CKBase;

    while ( argnum < *pargc ) {
        _strlwr(argv[argnum]);
        cswitch = *(argv[argnum]);
        if (cswitch == '/' || cswitch == '-') {
            c = *(argv[argnum]+1);

            switch (c) {
                case 'o':
                    ArgFlag |= ArgFlag_OLESelf;
                    break;

                case 'v':
                    ArgFlag |= ArgFlag_OK | ArgFlag_CKMZ | ArgFlag_OLESelf;
                    break;

                case '?':
                    Usage();
                    break;

                case 'b':
                    ArgFlag ^= ArgFlag_CKBase;
                    break;

                case 's':
                    if (argv[argnum+1]) {
                        strcpy(szSympath, (argv[argnum+1]));
                        ArgFlag |= ArgFlag_SymCK;
                        argnum++;
                    }
                    break;

                case 'p':
                    ArgFlag |= ArgFlag_CKMZ;
                    break;

                case 'r':
                    fRecurse = TRUE;
                    if (argv[argnum+1]) {
                        fPathOverride=TRUE;
                        strcpy(szDirectory, (argv[argnum+1]));
                        if (!(strcmp(szDirectory, "\\"))) {  // if just '\'
                            fSingleSlash=TRUE;
                        }
                        //LogPrintf("dir %s\n", szDirectory);
                        argnum++;
                    }

                    break;

                default:
                    fprintf(stderr, "Invalid argument.\n");
                    Usage();
            }
        } else {
            // Check for path\filename or wildcards

            // Search for '\' in string
            strcpy(sztmp, (argv[argnum]));
            len = strlen(sztmp);
            for (i=0; i < len; i++) {
                if (sztmp[i]=='\\') {
                    count++;
                    endpath=i;         // mark last '\' char found
                    fslashfound=TRUE;  // found backslash, so must be a path\filename combination
                }
            }

            if (fslashfound && !fRecurse) { // if backslash found and not a recursive operation
                                            // seperate the directory and filename into two strings
                fPathOverride=TRUE;
                strcpy(szDirectory, sztmp);

                if (!(strcmp(szDirectory, "\\"))) {
                    Usage();
                }

                szFileName = _strdup(&(sztmp[endpath+1]));


                if (count == 1) { //&& szDirectory[1] == ':') { // if only one '\' char and drive letter indicated
                    fSingleSlash=TRUE;
                    szDirectory[endpath+1]='\0';  // keep trailing '\' in order to chdir properly
                }  else {
                    szDirectory[endpath]='\0';
                }

                if (szFileName[0] == '*' && szFileName[1] == '.' && szFileName[2] != '*') {
                    _strlwr(szFileName);
                    szPattern = strchr(szFileName, '.'); //search for '.'
                    fPattern = TRUE;
                }
            } else {  // no backslash found, assume filename without preceeding path

                szFileName = _strdup(argv[argnum]);
                if (!szFileName) {
                    // drastic error, just bail
                    szFileName = "";
                    return;
                }
                //
                // filename or wildcard
                //
                if ( (*(argv[argnum]) == '*') && (*(argv[argnum]+1) == '.') && (*(argv[argnum]+2) != '*') ){
                    // *.xxx
                    _strlwr(szFileName);
                    szPattern = strchr(szFileName, '.'); //search for '.'
                    fPattern = TRUE;
                } else if ( (*(argv[argnum]) == '*') && (*(argv[argnum]+1) == '.') && (*(argv[argnum]+2) == '*') ) {
                    // *.*
                } else {
                    // probably a single filename
                    _strlwr(szFileName);
                    fSingleFile = TRUE;
                }

                if (fRecurse && strchr(szFileName, '\\') ) { // don't want path\filename when recursing
                    Usage();
                }

            }
            //fprintf(stdout, "dir %s\nfile %s\n", szDirectory, szFileName);
        }
        ++argnum;
    }
    if (szFileName[0] == '\0') {
        Usage();
    }
} // parseargs


int
__cdecl
CompFileAndDir(
    const void *elem1,
    const void *elem2
    )
/*++

Routine Description:

    Purpose: a comparision routine passed to QSort.  It compares elem1 and elem2
    based upon their attribute, i.e., is it a file or directory.

Arguments:

    const void *elem1,
    const void *elem2

Return Value:

    result of comparison function

Notes:


--*/
{
    pList p1, p2;
    // qsort passes a void universal pointer.  Use a typecast (List**)
    // so the compiler recognizes the data as a List structure.
    // Typecast pointer-to-pointer-to-List and dereference ONCE
    // leaving a pList.  I don't dereference the remaining pointer
    // in the p1 and p2 definitions to avoid copying the structure.

    p1 = (*(List**)elem1);
    p2 = (*(List**)elem2);

    if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return 0;
    //both dirs
    if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return 0;
    //both files
    if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return 1;
    // elem1 is dir and elem2 is file
    if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return -1;
    // elem1 is file and elem2 is dir

    return 0; // if none of the above
}

int
__cdecl
CompName(
    const void *elem1,
    const void *elem2
    )
/*++

Routine Description:

    another compare routine passed to QSort that compares the two Name strings

Arguments:

    const void *elem1,
    const void *elem2

Return Value:

    result of comparison function

Notes:

    this uses a noignore-case strcmp

--*/
{
   return strcmp( (*(List**)elem1)->Name, (*(List**)elem2)->Name );
}


VOID
Usage(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:


Notes:


--*/
{
   fputs("Usage: imagechk  [/?] displays this message\n"
         "                 [/r dir] recurse from directory dir\n"
         "                 [/b] don't check image base address\n"
         "                 [/v] verbose - output everything\n"
         "                 [/o] output \"OleSelfRegister not set\" warning\n"
         "                 [/p] output \"MZ header not found\"\n"
         "                 [/s <sympath>] check pdb symbols\n"
         "                 [filename] file to check\n"
         " Accepts wildcard extensions such as *.exe\n"
         " imagechk /r . \"*.exe\"   check all *.exe recursing on current directory\n"
         " imagechk /r \\ \"*.exe\"  check all *.exe recursing from root of current drive\n"
         " imagechk \"*.exe\"        check all *.exe in current directory\n"
         " imagechk c:\\bar.exe      check c:\\bar.exe only\n",
         stderr);
   exit(1);
}

int
__cdecl
_cwild()
/*++

Routine Description:


Arguments:


Return Value:


Notes:


--*/
{
   return(0);
}

typedef DWORD (WINAPI *PFNGVS)(LPSTR, LPDWORD);
typedef BOOL (WINAPI *PFNGVI)(LPTSTR, DWORD, DWORD, LPVOID);
typedef BOOL (WINAPI *PFNVQV)(const LPVOID, LPTSTR, LPVOID *, PUINT);

BOOL
VerifyVersionResource(
    PCHAR FileName,
    BOOL fSelfRegister
    )
/*++

Routine Description:

    validate the version resource in a file

Arguments:

    PCHAR FileName
    BOOL fSelfRegister

Return Value:

    TRUE    if: no version.dll found
    FALSE   if: version resource missing


Notes:


--*/
{
    static HINSTANCE hVersion = NULL;
    static PFNGVS pfnGetFileVersionInfoSize = NULL;
    static PFNGVI pfnGetFileVersionInfo = NULL;
    static PFNVQV pfnVerQueryValue = NULL;
    DWORD dwSize;
    DWORD lpInfoSize;
    LPVOID lpData = NULL, lpInfo;
    BOOL rc = FALSE;
    DWORD dwDefLang = 0x00000409;
    DWORD *pdwTranslation, uLen;
    CHAR buf[60];

    CHAR szVersionDll[_MAX_PATH];

    if (GetSystemDirectory(szVersionDll, sizeof(szVersionDll))) {
        strcat(szVersionDll, "\\version.dll");
    } else {
        strcpy(szVersionDll, "version.dll");
    }

    if (!hVersion) {
        hVersion = LoadLibraryA(szVersionDll);
        if (hVersion == NULL) {
            return TRUE;
        }

        pfnGetFileVersionInfoSize = (PFNGVS) GetProcAddress(hVersion, "GetFileVersionInfoSizeA");
        pfnGetFileVersionInfo = (PFNGVI) GetProcAddress(hVersion, "GetFileVersionInfoA");
        pfnVerQueryValue = (PFNVQV) GetProcAddress(hVersion, "VerQueryValueA");
    }

    if (!pfnGetFileVersionInfoSize || !pfnGetFileVersionInfo || !pfnVerQueryValue) {
        rc = TRUE;
        goto cleanup;
    }

    if ((dwSize = (*pfnGetFileVersionInfoSize)(FileName, &dwSize)) == 0){
        LogPrintf("No version resource detected\n");
        goto cleanup;
    }

    if (!fSelfRegister) {
        // All we need to do is see if the version resource exists.  Ole Self Register not necessary.
        rc = TRUE;
        goto cleanup;
    }

    if ((lpData = malloc(dwSize)) == NULL) {
        LogPrintf("Out of memory\n");
        goto cleanup;
    }

    if (!(*pfnGetFileVersionInfo)(FileName, 0, dwSize, lpData)) {
        LogPrintf("Unable to read version info\n - %d", GetLastError());
        goto cleanup;
    }

    if(!pfnVerQueryValue(lpData, "\\VarFileInfo\\Translation", &pdwTranslation, &uLen)) {
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    sprintf(buf, "\\StringFileInfo\\%04x%04x\\OleSelfRegister", LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));

    if (!pfnVerQueryValue(lpData, buf, &lpInfo, &lpInfoSize) && (ArgFlag & ArgFlag_OLESelf )) {
        LogPrintf("OleSelfRegister not set\n");
    } else {
        rc = TRUE;
    }

cleanup:
    if (lpData) {
        free(lpData);
    }

    // No need to free the hVersion
    return(rc);
}

BOOL
ValidatePdata(
    PIMAGE_DOS_HEADER DosHeader
    )
/*++

Routine Description:

    validates the PIMAGE_RUNTIME_FUNCTION_ENTRY in the executable

Arguments:

    PIMAGE_DOS_HEADER   DosHeader

Return Value:

    TRUE    if:
    FALSE   if: no exception data
                exception table size incorrect
                exception table corrupt

Notes:


--*/
{
    // The machine type indicates this image should have pdata (an exception table).
    // Ensure it looks reasonable.

    // Todo: Add a range check for exception handler and data

    PIMAGE_RUNTIME_FUNCTION_ENTRY ExceptionTable;
    DWORD ExceptionTableSize, i;
    DWORD_PTR LastEnd;
    BOOL fRc;
    PIMAGE_NT_HEADERS NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)DosHeader + (ULONG)DosHeader->e_lfanew);
    ULONG_PTR ImageBase = NtHeader->OptionalHeader.ImageBase;
    DWORD PDataStart = NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
    DWORD PDataSize = NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;


    ExceptionTable = (PIMAGE_RUNTIME_FUNCTION_ENTRY)
        ImageDirectoryEntryToData(
            DosHeader,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_EXCEPTION,
            &ExceptionTableSize );

    if (!ExceptionTable ||
        (ExceptionTable && (ExceptionTableSize == 0)))
    {
        // No Exception table.
        return(TRUE);
    }

    if (ExceptionTableSize % sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) {
        // The size isn't an even multiple.
        LogPrintf("exception table size is not correct\n");
        return(FALSE);
    }

    LastEnd = 0;
    fRc = TRUE;
    for (i=0; i < (ExceptionTableSize / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)); i++) {

        if (!ExceptionTable[i].BeginAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for BeginAddress\n",
                    i);
            fRc = FALSE;
        }
        if (!ExceptionTable[i].EndAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for EndAddress\n",
                    i);
            fRc = FALSE;
        }
#if defined(_IA64_)
        if (!ExceptionTable[i].UnwindInfoAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for UnwindInfoAddress\n",
                    i);
            fRc = FALSE;
        }
#elif defined(_ALPHA_) || defined(_AXP64_)
        if (!ExceptionTable[i].PrologEndAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for PrologEndAddress\n",
                    i);
            fRc = FALSE;
        }

#endif // defined(_IA64_)

        if (ExceptionTable[i].BeginAddress < LastEnd) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: the begin address [%8.8x] is out of sequence.  Prior end was [%8.8x]\n",
                    i,
                    ExceptionTable[i].BeginAddress,
                    LastEnd);
            fRc = FALSE;
        }

        if (ExceptionTable[i].EndAddress < ExceptionTable[i].BeginAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: the end address [%8.8x] is before the begin address[%8.8X]\n",
                    i,
                    ExceptionTable[i].EndAddress,
                    ExceptionTable[i].BeginAddress);
            fRc = FALSE;
        }

#if defined(_ALPHA_) || defined(_AXP64_)
        if (!((ExceptionTable[i].PrologEndAddress >= ExceptionTable[i].BeginAddress) &&
              (ExceptionTable[i].PrologEndAddress <= ExceptionTable[i].EndAddress)))
        {
            if (NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA) {
                // Change this test.  On Alpha, the PrologEndAddress is allowed to be
                // outside the Function Start/End range.  If this is true, the PrologEnd
                // - ImageBase - pdata section VA s/b divisible by sizeof IMAGE_RUNTIME_FUNCTION_ENTRY
                // AND within the bounds of the PdataSize.  It's supposed to be an index into the
                // pdata data that descibes the real scoping function.

                LONG PrologAddress;
                PrologAddress = (LONG) (ExceptionTable[i].PrologEndAddress - ImageBase - PDataStart);
                if (PrologAddress % sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) {
                    if (fRc != FALSE) {
                        LogPrintf("exception table is corrupt.\n");
                    }
                    LogPrintf("PDATA Entry[%d]: the secondary prolog end address[%8.8x] does not evenly index into the exception table.\n",
                            i,
                            ExceptionTable[i].PrologEndAddress,
                            ExceptionTable[i].BeginAddress,
                            ExceptionTable[i].EndAddress
                            );
                    fRc = FALSE;
                } else {
                    if ((PrologAddress < 0) || (PrologAddress > (LONG)(PDataStart - sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)))) {
                        if (fRc != FALSE) {
                            LogPrintf("exception table is corrupt.\n");
                        }
                        LogPrintf("PDATA Entry[%d]: the secondary prolog end address[%8.8x] does not index into the exception table.\n",
                                i,
                                ExceptionTable[i].PrologEndAddress,
                                ExceptionTable[i].BeginAddress,
                                ExceptionTable[i].EndAddress
                                );
                        fRc = FALSE;
                    }
                }
            } else {
                if (fRc != FALSE) {
                    LogPrintf("exception table is corrupt.\n");
                }
                LogPrintf("PDATA Entry[%d]: the prolog end address[%8.8x] is not within the bounds of the frame [%8.8X] - [%8.8X]\n",
                        i,
                        ExceptionTable[i].PrologEndAddress,
                        ExceptionTable[i].BeginAddress,
                        ExceptionTable[i].EndAddress
                        );
                fRc = FALSE;
            }
        }
#endif // !defined(_IA64_)

        LastEnd = ExceptionTable[i].EndAddress;
    }

    return(fRc);
}

BOOL
ImageNeedsOleSelfRegister(
    PIMAGE_DOS_HEADER DosHeader
    )
/*++

Routine Description:


Arguments:

    PIMAGE_DOS_HEADER   DosHeader

Return Value:

    TRUE if DllRegisterServer or DllUnRegisterServer is exported

--*/
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    DWORD ExportDirectorySize, i;
    USHORT x;
    PCHAR  rvaDelta;
    PULONG NameTable;

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
        ImageDirectoryEntryToData(
            DosHeader,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_EXPORT,
            &ExportDirectorySize );

    if (!ExportDirectory ||
        !ExportDirectorySize ||
        !ExportDirectory->NumberOfNames)
    {
        // No exports (no directory, no size, or no names).
        return(FALSE);
    }

    // Walk the section headers and find the va/raw offsets.

    NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)DosHeader + (ULONG)DosHeader->e_lfanew);
    SectionHeader = IMAGE_FIRST_SECTION(NtHeader);

    for (x = 0; x < NtHeader->FileHeader.NumberOfSections; x++) {
        if (((ULONG)((PCHAR)ExportDirectory - (PCHAR)DosHeader) >= SectionHeader->PointerToRawData) &&
            ((ULONG)((PCHAR)ExportDirectory - (PCHAR)DosHeader) <
                   (SectionHeader->PointerToRawData + SectionHeader->SizeOfRawData))) {
            break;
        } else {
            SectionHeader++;
        }
    }

    if (x == NtHeader->FileHeader.NumberOfSections) {
        // We didn't find the section that contained the export table.  Assume it's not there.
        return(FALSE);
    }

    rvaDelta = (PCHAR)DosHeader + SectionHeader->PointerToRawData - SectionHeader->VirtualAddress;

    NameTable = (PULONG)(rvaDelta + ExportDirectory->AddressOfNames);

    for (i = 0; i < ExportDirectory->NumberOfNames; i++) {
        if (!strcmp("DllRegisterServer", rvaDelta + NameTable[i]) ||
            !strcmp("DllUnRegisterServer", rvaDelta + NameTable[i]))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

//
// support routines for symbol checker - could all
// be done without this using lower-level internal api's
//

PSYMMODLIST
MakeModList(
    HANDLE hProcess
    )
/*++

Routine Description:

    build a list of loaded symbol modules and addresses

Arguments:

    HANDLE hProcess

Return Value:

    PSYMMODLIST

Notes:


--*/
{
    PSYMMODLIST ModList;

    ModList = (PSYMMODLIST)calloc(1, sizeof(SYMMODLIST));
    SymEnumerateModules64(hProcess, SymEnumerateModulesCallback, ModList);

    return(ModList);
}

BOOL
CALLBACK
SymEnumerateModulesCallback(
    LPSTR ModuleName,
    ULONG64 BaseOfDll,
    PVOID UserContext
    )
/*++

Routine Description:

    callback routine for SymEnumerateModules
    in this case, UserContext is a pointer to a head of a _SYMMODLIST struct
    that will have a new item appended
    We are avoiding global state for these lists so we can use several at once,
    they will be short, so we will find the end each time we want to add
    runs slower, simpler to maintain

Arguments:

    LPSTR   ModuleName
    ULONG64 BaseOfDll
    PVOID   UserContext

Return Value:

    TRUE

Notes:


--*/
{
    PSYMMODLIST pSymModList;

    //
    // find end of list, key on pSymModList->ModBase
    //

    pSymModList = (PSYMMODLIST)UserContext;
    while (pSymModList->ModBase)
    {
        pSymModList = pSymModList->Next;
    }

    //
    // append entry
    //

    pSymModList->ModName = malloc(strlen(ModuleName) + 1);
    if (!pSymModList->ModName)
        return FALSE;
    strcpy(pSymModList->ModName, ModuleName);
    pSymModList->ModBase = (void *)BaseOfDll;
    pSymModList->Next = (PSYMMODLIST)calloc(1, sizeof(SYMMODLIST));

    return(TRUE);
}

void *
GetModAddrFromName(
    PSYMMODLIST ModList,
    char *ModName
    )
/*++

Routine Description:

    gets module address from a SYMMODLIST given module base name

Arguments:

    PSYMMODLIST ModList
    char *      ModName

Return Value:

    module address

--*/
{
    while (ModList->Next != 0)
    {
        if (strcmp(ModList->ModName, ModName) == 0)
        {
            break;
        }
        ModList = ModList->Next;
    }

    return(ModList->ModBase);
}

void
FreeModList(
    PSYMMODLIST ModList
    )
/*++

Routine Description:

    free a list of loaded symbol modules and addresses

Arguments:

    PSYMMODLIST ModList

Return Value:

    none

--*/
{
    PSYMMODLIST ModListNext;

    while (ModList)
    {
        if(ModList->ModName)
        {
            free(ModList->ModName);
        }
        ModListNext = ModList->Next;
        free(ModList);
        ModList = ModListNext;
    }
}

pLogListItem LogAppend(
    char *logitem,
    pLogListItem plog
    )
/*++

Routine Description:

    add a log line to the linked list of log lines

Arguments:

    char *  logitem     - a formatted line of text to be logged
    pLogListItem plog   - pointer to LogListItem

Return Value:

    a pointer to the LogListItem allocated
    the first call to this function should save this pointer and use
    it for the head of the list, and it should be used when calling
    LogOutAndClean() to print the list and free all the memory

    you can call this with plog == head of list, or == to last item
    if plog == 0, this means that the item being allocated is the head
    of the list.
    If plog == head of list, search for end of list
    if plog == last item allocated, then the search is much faster

--*/
{
    pLogListItem ptemp;

    ptemp = plog;
    if(plog)
    {
        while(ptemp->Next)
        {
            ptemp = ptemp->Next;
        }
    }

    if(!ptemp)
    {
        ptemp = (pLogListItem)calloc(sizeof(LogListItem), 1);
        if (!ptemp)
            return NULL;
    } else {
        ptemp->Next = (pLogListItem)calloc(sizeof(LogListItem), 1);
        if (!ptemp->Next)
            return NULL;
        ptemp = ptemp->Next;
    }

    ptemp->LogLine = (char *)malloc(strlen(logitem) + 1);
    if (!ptemp->LogLine)
        return NULL;
    strcpy(ptemp->LogLine, logitem);
    return (ptemp);
}

void LogOutAndClean(
    BOOL print
    )
/*++

Routine Description:

    output the log output, and free all the items in the list

Arguments:

    none

Return Value:

    none

--*/
{
    pLogListItem ptemp;
    pLogListItem plog = pLogList;

    while(plog)
    {
        ptemp = plog;
        if(print)
        {
            fputs(plog->LogLine, stderr);
        }
        plog = plog->Next;
        free(ptemp->LogLine);
        free(ptemp);
    }
    if(print)
    {
        fprintf(stderr, "\n");
    }

    pLogListTmp = pLogList = NULL;

}

void
__cdecl
LogPrintf(
    const char *format,
    ...
    )
/*++

Routine Description:

    logging wrapper for fprintf

Arguments:

    none

Return Value:

    none

--*/
{
    va_list arglist;
    char LogStr[1024];

    va_start(arglist, format);
    vsprintf(LogStr, format, arglist);

    if(pLogList == NULL)
    {
        //
        // initialize log
        //

        pLogListTmp = pLogList = LogAppend(LogStr, NULL);

    } else {

        //
        // append to log
        //

        pLogListTmp = LogAppend(LogStr, pLogListTmp);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\imhlptst.c ===
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>

void __cdecl main(void);
void foo (void);
void foo1(void);
void foo2(void);
void foo3(void);
void WalkTheStack(void);

void TestFindExecutableImage( void );

void __cdecl
main(void)
{
    puts("Entering main");
    foo();

    TestFindExecutableImage();

    puts("Ending main");
}

void
TestFindExecutableImage(
    void
    )
{
    HANDLE Handle;
    CHAR szCorrectName[MAX_PATH];
    CHAR szActualName [MAX_PATH];
    CHAR szTestPath[MAX_PATH];
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR *FilePart;
    DWORD ErrorCount = 0;

    _splitpath(_pgmptr, szDrive, szDir, NULL, NULL);

    strcpy(szTestPath, szDrive);
    strcat(szTestPath, szDir);

    GetFullPathName(_pgmptr, MAX_PATH, szCorrectName, &FilePart);

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 1);
        ErrorCount++;
    }

    if (Handle == NULL) {
        printf("ERROR: FindExecutableImage (test %d) failed\n", 1);
        ErrorCount++;
    } else {
        CloseHandle(Handle);
        if (strcmp(szCorrectName, szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) found wrong image.\nExpected: %s\nFound: %s\n", 1, szCorrectName, szActualName);
            ErrorCount++;
        }
    }

    // Test long paths to ExpandPath()
    strcat(szTestPath, ";%path%;%path%;%path%;%path%;%path%;%path%;%path%;%path%");

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 2);
        ErrorCount++;
    }

    if (Handle == NULL) {
        printf("ERROR: FindExecutableImage (test %d) failed\n", 2);
        ErrorCount++;
    } else {
        CloseHandle(Handle);
        if (strcmp(szCorrectName, szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) found wrong image.\nExpected: %s\nFound: %s\n", 2, szCorrectName, szActualName);
            ErrorCount++;
        }
    }

    // Test invalid paths (should return failure)
    szTestPath[0] = '\0';

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 3);
        ErrorCount++;
    }

    if (Handle != NULL) {
        CloseHandle(Handle);
        printf("ERROR: FindExecutableImage (test %d) failed - Expected: <nothing>\nFound: %s\n", 3, szActualName);
        ErrorCount++;
    } else {
        if (strlen(szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) failed to clear ImageName on failure\n", 3);
            ErrorCount++;
        }
    }

    // Test NULL name (should return failure)

    __try {
        Handle = FindExecutableImage(NULL, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 4);
        ErrorCount++;
    }

    if (Handle != NULL) {
        CloseHandle(Handle);
        printf("ERROR: FindExecutableImage (test %d) failed - Expected: <nothing>\nFound: %s\n", 4, szActualName);
        ErrorCount++;
    } else {
        if (strlen(szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) failed to clear ImageName on failure\n", 4);
            ErrorCount++;
        }
    }

    // Valid name and path, invalid end result.

    strcpy(szTestPath, szDrive);
    strcat(szTestPath, szDir);

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 5);
        ErrorCount++;
    }

    if (Handle != NULL) {
        CloseHandle(Handle);
        printf("ERROR: FindExecutableImage (test %d) failed - Supposed to fail if filepath is invalid\n", 5);
        ErrorCount++;
    }

    printf("FindExecutableImage - %s\n", ErrorCount ? "Failed" : "Passed");

    return;
}


void foo(void) {
    puts("Entering foo");
    foo1();
    puts("Ending foo");
}

void foo1(void) {
    puts("Entering foo1");
    foo2();
    puts("Ending foo1");
}

void foo2(void) {
    puts("Entering foo2");
    foo3();
    puts("Ending foo2");
}

void foo3(void) {
    puts("Entering foo3");
    WalkTheStack();
    puts("Ending foo2");
}

void
WalkTheStack(){

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\imagehlp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    imagehlp.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/
#ifdef __cplusplus
extern "C" {
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include "private.h"
#include <globals.h>


 #define HEAP_SIZE 0x100000

 __inline BOOL tlsSetup(HMODULE hmod)
 {
     return TRUE;
 }

 __inline BOOL tlsAlloc()
 {
     g.tlsIndex = TlsAlloc();
     return (g.tlsIndex == (DWORD)-1) ? FALSE : TRUE;
 }

 __inline void tlsFree()
 {
     if (g.tlsIndex != (DWORD)-1)
         TlsFree(g.tlsIndex);
 }

 __inline void tlsMemFree()
 {
     PVOID ptls;

     ptls = TlsGetValue(g.tlsIndex);
     MemFree(ptls);
 }


DWORD
DllMain(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    __try {

        switch (Reason)
        {
        case DLL_PROCESS_ATTACH:
            g.hinst = hInstance;
            g.OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx(&g.OSVerInfo);
            InitializeCriticalSection(&g.threadlock);
            tlsSetup(hInstance);
            HeapInitList(&g.HeapHeader);
            g.hHeap = HeapCreate(0, HEAP_SIZE, 0);
            if (tlsAlloc() && g.hHeap) 
                return TRUE;
            DeleteCriticalSection(&g.threadlock);
            return FALSE;
    
        case DLL_PROCESS_DETACH:
            tlsFree();
            HeapDump("DLL_PROCESS_DETACH\n");
            // If this is a process shutdown, don't bother to
            // kill the heap.  The OS will do it for us.  This
            // allows us to be called from other DLLs' DLLMain
            // DLL_PROCESS_DETACH handler.               
            if ( !Context && g.hHeap ) 
                HeapDestroy( g.hHeap );
            DeleteCriticalSection(&g.threadlock);
            break;
    
        case DLL_THREAD_DETACH:
            tlsMemFree();
            break;
        }
    
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    return TRUE;
}


#ifdef IMAGEHLP_HEAP_DEBUG
BOOL
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    )
{
    CHAR buf[256];
    CHAR ext[4];

    if (!HeapValidate( g.hHeap, 0, MemPtr )) {
        PrintString( buf, DIMA(buf), "IMAGEHLP: heap corruption - " );
        _splitpath( File, NULL, NULL, &buf[strlen(buf)], ext );
        CatStrArray( buf, ext );
        PrintString( &buf[strlen(buf)], DIMA(buf) - (&buf[strlen(buf)] - buf), " @ %d\n", Line );
        OutputDebugString( buf );
        PrintAllocations();
        DebugBreak();
        return FALSE;
    }

    return TRUE;
}


BOOL
pHeapDump(
    LPSTR sz,
    ULONG line,
    LPSTR file
    )
{
    BOOL rc;

    if (sz && *sz)
        OutputDebugString(sz);
    rc = CheckHeap(NULL);
    if (rc)
        PrintAllocations();

    return rc;
}
#endif
    

PVOID
pMemReAlloc(
    PVOID OldAlloc,
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef IMAGEHLP_HEAP_DEBUG
    PVOID NewAlloc;
    PHEAP_BLOCK hb;
    if (!OldAlloc) {
        return NULL;
    }
    hb = (PHEAP_BLOCK) ((PUCHAR)OldAlloc - sizeof(HEAP_BLOCK));
    if (hb->Signature != HEAP_SIG) {
        OutputDebugString( "IMAGEHLP: Corrupt heap block\n" );
        DebugBreak();
    }
    NewAlloc = pMemAlloc(AllocSize, Line, File);
    if (!NewAlloc)
        return NULL;
    memcpy(NewAlloc, OldAlloc, min(hb->Size, AllocSize));
    RemoveEntryList( &hb->ListEntry );
    g.TotalMemory -= hb->Size;
    g.TotalAllocs -= 1;
    HeapFree( g.hHeap, 0, (PVOID) hb );
    return NewAlloc;
#else
    return(HeapReAlloc(g.hHeap, HEAP_ZERO_MEMORY, OldAlloc, AllocSize));
#endif
}

PVOID
pMemAlloc(
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef IMAGEHLP_HEAP_DEBUG
    PHEAP_BLOCK hb;
    CHAR ext[4];
    hb = (PHEAP_BLOCK) HeapAlloc( g.hHeap, HEAP_ZERO_MEMORY, AllocSize + sizeof(HEAP_BLOCK) );
    if (hb) {
        g.TotalMemory += AllocSize;
        g.TotalAllocs += 1;
        InsertTailList( &g.HeapHeader, &hb->ListEntry );
        hb->Signature = HEAP_SIG;
        hb->Size = AllocSize;
        hb->Line = Line;
        _splitpath( File, NULL, NULL, hb->File, ext );
        CatStrArray( hb->File, ext );
        return (PVOID) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
    }
    return NULL;
#else
    return HeapAlloc( g.hHeap, HEAP_ZERO_MEMORY, AllocSize );
#endif
}

VOID
pMemFree(
    PVOID MemPtr
#ifdef IMAGEHLP_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef IMAGEHLP_HEAP_DEBUG
    PHEAP_BLOCK hb;
    if (!MemPtr) {
        return;
    }
    pCheckHeap(NULL, Line, File);
    hb = (PHEAP_BLOCK) ((PUCHAR)MemPtr - sizeof(HEAP_BLOCK));
    if (hb->Signature != HEAP_SIG) {
        OutputDebugString( "IMAGEHLP: Corrupt heap block\n" );
        DebugBreak();
    }
    RemoveEntryList( &hb->ListEntry );
    g.TotalMemory -= hb->Size;
    g.TotalAllocs -= 1;
    HeapFree( g.hHeap, 0, (PVOID) hb );
#else
    if (!MemPtr) {
        return;
    }
    HeapFree( g.hHeap, 0, MemPtr );
#endif
}

ULONG_PTR
pMemSize(
    PVOID MemPtr
    )
{
    return HeapSize(g.hHeap, 0, MemPtr);
}


#ifdef IMAGEHLP_HEAP_DEBUG
VOID
PrintAllocations(
    VOID
    )
{
    PLIST_ENTRY                 Next;
    PHEAP_BLOCK                 hb;
    CHAR                        buf[256];
    LARGE_INTEGER               PerfFreq;


    Next = g.HeapHeader.Flink;
    if (!Next) {
        return;
    }

    OutputDebugString( "-----------------------------------------------------------------------------\n" );
    PrintString( buf, DIMA(buf), "Memory Allocations for Heap 0x%08x, Allocs=%d, TotalMem=%I64d\n", (ULONG_PTR)g.hHeap, g.TotalAllocs, g.TotalMemory );
    OutputDebugString( buf );
    OutputDebugString( "-----------------------------------------------------------------------------\n" );
    OutputDebugString( "*\n" );

    while ((ULONG_PTR)Next != (ULONG_PTR)&g.HeapHeader) {
        hb = CONTAINING_RECORD( Next, HEAP_BLOCK, ListEntry );
        Next = hb->ListEntry.Flink;
        PrintString( buf, DIMA(buf), "%8d %16s @ %5d\n", hb->Size, hb->File, hb->Line );
        OutputDebugString( buf );
    }

    OutputDebugString( "*\n" );

    return;
}
#endif

DWORD
ImagepSetLastErrorFromStatus(
    IN DWORD Status
    )
{
    DWORD dwErrorCode;

//    dwErrorCode = RtlNtStatusToDosError( Status );
    dwErrorCode =  Status;
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


/////////////////////////////////////////////////////////////////////////////
/*
******************************************************************************
On a Hydra System, we don't want imaghlp.dll to load user32.dll since it
prevents CSRSS from exiting when running a under a debugger.
The following two functions have been copied from user32.dll so that we don't
link to user32.dll.
******************************************************************************
*/
////////////////////////////////////////////////////////////////////////////


LPSTR CharNext(
    LPCSTR lpCurrentChar)
{
    if (IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point string-terminaler.
     */

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}

LPSTR CharPrev(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar)
{
    if (lpCurrentChar > lpStart) {
        LPCSTR lpChar;
        BOOL bDBC = FALSE;

        for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
            if (!IsDBCSLeadByte(*lpChar))
                break;
            bDBC = !bDBC;
        }

        if (bDBC)
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
}


void * __cdecl AllocIt(unsigned int cb)
{
    return (MemAlloc(cb));
}

void __cdecl FreeIt(void * p)
{
    MemFree(p);
}

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    LPCSTR name,
    LPSTR outputString,
    DWORD maxStringLength,
    DWORD flags
    )
{
    static HMODULE hMsvcrt = 0;
    static BOOL fLoadMsvcrtDLL = FALSE;
    static PUNDNAME pfUnDname = NULL;
    DWORD rc;

    // this prevents an AV in __unDName

    if (!name) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    //
    // can't undecorate into a zero length buffer
    //
    if (maxStringLength < 2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!fLoadMsvcrtDLL) {
        // The first time we run, see if we can find the system undname.  Use
        // GetModuleHandle to avoid any additionally overhead.

        hMsvcrt = GetModuleHandle("msvcrt.dll");

        if (hMsvcrt) {
            pfUnDname = (PUNDNAME) GetProcAddress(hMsvcrt, "__unDName");
        }
        fLoadMsvcrtDLL = TRUE;
    }

    rc = 0;     // Assume failure

    __try {
        if (pfUnDname) {
            if (flags & UNDNAME_NO_ARGUMENTS) {
                flags |= UNDNAME_NAME_ONLY;
                flags &= ~UNDNAME_NO_ARGUMENTS;
            }

            if (flags & UNDNAME_NO_SPECIAL_SYMS) {
                flags &= ~UNDNAME_NO_SPECIAL_SYMS;
            }
            if (pfUnDname(outputString, name, maxStringLength-1, AllocIt, FreeIt, (USHORT)flags)) {
                rc = strlen(outputString);
            }
        } else {
            *outputString = 0;
            strncpy(outputString, "Unable to load msvcrt!__unDName", maxStringLength);  // SECURITY: Don't know size of output buffer.
            rc = strlen(outputString);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (!rc) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return rc;
}

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    HMODULE Module
    )
{
    PIMAGE_DOS_HEADER DosHdr;
    DWORD dwTimeStamp;

    __try {
        DosHdr = (PIMAGE_DOS_HEADER) Module;
        if (DosHdr->e_magic == IMAGE_DOS_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) ((LPBYTE)Module + DosHdr->e_lfanew))->FileHeader.TimeDateStamp;
        } else if (DosHdr->e_magic == IMAGE_NT_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) DosHdr)->FileHeader.TimeDateStamp;
        } else {
            dwTimeStamp = 0;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwTimeStamp = 0;
    }

    return dwTimeStamp;
}


VOID
EnsureTrailingBackslash(
    LPSTR sz
    )
{
    int i;

    assert(sz);

    i = lstrlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == '\\')
        return;

    sz[i] = '\\';
    sz[i + 1] = '\0';
}


#if DBG

VOID
__cdecl
dbPrint(
    LPCSTR fmt,
    ...
    )

/*++

    This function replaces ntdll!DbgPrint().  We need this to keep from linking to
    ntdll so that this library will run on Windows.

--*/

{
    CHAR  text[_MAX_PATH];

    va_list vaList;

    assert(fmt);

    va_start(vaList, fmt);
    vsprintf(text, fmt, vaList);
    va_end(vaList);

    OutputDebugString(text);
}

#endif


#ifdef BUILD_IMAGEHLP
#include <bindi.c>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\map.c ===
/*++

Copyright (c) 1994-96  Microsoft Corporation

Module Name:

    map.c

Abstract:
    Implementation for the MapAndLoad API

Author:

Revision History:

--*/

#include <private.h>
#include <globals.h>

#include <mapi.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\linesym.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    linesym.c

Abstract:

    Source file and line support.

Author:

    Drew Bliss (drewb) 07-07-1997

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>

#include "private.h"
#include "symbols.h"
#include "globals.h"

// private version of qsort used to avoid compat problems on NT4 and win2k.
// code is published from base\crts
extern
void __cdecl dbg_qsort(void *, size_t, size_t,
                       int (__cdecl *) (const void *, const void *));

// #define DBG_LINES
// #define DBG_COFF_LINES
// #define DBG_ADDR_SEARCH
BOOL
diaAddLinesForAllMod(
    PMODULE_ENTRY mi
    );


#if defined(DBG_LINES) || defined(DBG_COFF_LINES) || defined(DBG_ADDR_SEARCH)
void __cdecl
DbgOut(PCSTR Format, ...)
{
    char Buf[512];
    va_list Args;

    va_start(Args, Format);
    _vsnprintf(Buf, sizeof(Buf), Format, Args);
    va_end(Args);
    OutputDebugStringA(Buf);
}
#endif


BOOL
sci2lline(
    PMODULE_ENTRY    mi,
    PSRCCODEINFO     sci,
    PIMAGEHLP_LINE64 line64)
{
    assert(mi && line64 && sci);

    line64->Address    = sci->Address;
    line64->Key        = sci->Key;
    line64->LineNumber = sci->LineNumber;
    line64->FileName   = mi->SrcFile;
    strcpy(line64->FileName, sci->FileName);   // SECURITY: Don't know size of target buffer.

    return true;
}


void sciInit(PSRCCODEINFO sci)
{
    ZeroMemory(sci, sizeof(SRCCODEINFO));
    sci->SizeOfStruct = sizeof(SRCCODEINFO);
}


int
__cdecl
CompareLineAddresses(
    const void *v1,
    const void *v2
    )
{
    PSOURCE_LINE Line1 = (PSOURCE_LINE)v1;
    PSOURCE_LINE Line2 = (PSOURCE_LINE)v2;

    if (Line1->Addr < Line2->Addr) {
        return -1;
    } else if (Line1->Addr > Line2->Addr) {
        return 1;
    } else {
        return 0;
    }
}


#ifdef DEBUG
void
DumpHintList(
    PPROCESS_ENTRY pe
    )
{
    PSOURCE_HINT sh;

    for (sh = pe->SourceHints; sh; sh = sh->next)
        dtrace("%s - %s\n", sh->filename, sh->mi->ModuleName);
}
#define Debug_DumpHintList DumpHintList
#else
#define Debug_DumpHintList
#endif


PSOURCE_HINT
FindSourceFileInHintList(
    PPROCESS_ENTRY  pe,
    char           *filename
    )
{
    PSOURCE_HINT sh;

    assert(pe && filename && *filename);

    for (sh = pe->SourceHints; sh; sh = sh->next) {
        if (!strcmp(sh->filename, filename))
            return sh;
    }

    return NULL;
}


BOOL
AddSourceFileToHintList(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi,
    LPSTR          filename
    )
{
    PSOURCE_HINT sh;
    PSOURCE_HINT psh;

    assert(pe && mi && filename && *filename);

    sh = FindSourceFileInHintList(pe,filename);
    if (sh) {
        sh->mi = mi;
        return true;
    }

    sh = (PSOURCE_HINT)MemAlloc(sizeof(SOURCE_HINT));
    if (!sh)
        return false;

    sh->next     = NULL;
    sh->filename = (LPSTR)MemAlloc(strlen(filename) + 1);
    if (!sh->filename) {
        MemFree(sh);
        return false;
    }
    strcpy(sh->filename, filename);   // SECURITY: Don't know size of target buffer.
    sh->mi       = mi;

    for (psh = pe->SourceHints; psh; psh = psh->next) {
        if (!psh->next)
            break;
    }

    if (psh)
        psh->next = sh;
    else
        pe->SourceHints = sh;

    Debug_DumpHintList(pe);

    return true;
}


void
RemoveSourceForModuleFromHintList(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi
    )
{
    PSOURCE_HINT sh;
    PSOURCE_HINT psh;

    assert(pe && mi);

    psh = pe->SourceHints;
    for (sh = pe->SourceHints; sh; sh = sh->next) {
        if (sh->mi == mi) {
            if (psh == sh)
                psh = pe->SourceHints = sh->next;
            else
                psh->next = sh->next;
            MemFree(sh->filename);
            MemFree(sh);
            sh = psh;
        }
        psh = sh;
        if (!sh)
            return;
    }

    Debug_DumpHintList(pe);
}


void
AddSourceEntry(
    PMODULE_ENTRY mi,
    PSOURCE_ENTRY Src
    )
{
    PSOURCE_ENTRY SrcCur;

    // Overlap is currently permitted.
#if 0
    // Check for overlap between SOURCE_ENTRY address ranges.
    for (SrcCur = mi->SourceFiles;
         SrcCur != NULL;
         SrcCur = SrcCur->Next)
    {
        if (!(SrcCur->MinAddr > Src->MaxAddr ||
              SrcCur->MaxAddr < Src->MinAddr))
        {
            DbgOut("SOURCE_ENTRY overlap between %08I64X:%08I64X "
                   "and %08I64X:%08I64X\n",
                   Src->MinAddr, Src->MaxAddr,
                   SrcCur->MinAddr, SrcCur->MaxAddr);
        }
    }
#endif

    // Sort line info by address.
    dbg_qsort((PVOID)Src->LineInfo, Src->Lines, sizeof(Src->LineInfo[0]),
          CompareLineAddresses);

    // Link new source information into list, sorted by address
    // range covered by information.

    for (SrcCur = mi->SourceFiles;
         SrcCur != NULL;
         SrcCur = SrcCur->Next) {
        if (SrcCur->MinAddr > Src->MinAddr) {
            break;
        }
    }

    Src->Next = SrcCur;
    if (SrcCur == NULL) {
        if (mi->SourceFilesTail == NULL) {
            mi->SourceFiles = Src;
        } else {
            mi->SourceFilesTail->Next = Src;
        }
        Src->Prev = mi->SourceFilesTail;
        mi->SourceFilesTail = Src;
    } else {
        if (SrcCur->Prev == NULL) {
            mi->SourceFiles = Src;
        } else {
            SrcCur->Prev->Next = Src;
        }
        Src->Prev = SrcCur->Prev;
        SrcCur->Prev = Src;
    }

#ifdef DBG_LINES
    DbgOut("%08I64X %08I64X: %5d lines, '%s'\n",
           Src->MinAddr, Src->MaxAddr, Src->Lines, Src->File);
#endif
}

#define IS_SECTION_SYM(Sym) \
    ((Sym)->StorageClass == IMAGE_SYM_CLASS_STATIC && \
     (Sym)->Type == IMAGE_SYM_TYPE_NULL && \
     (Sym)->NumberOfAuxSymbols == 1)

BOOL
AddLinesForCoff(
    PMODULE_ENTRY mi,
    PIMAGE_SYMBOL allSymbols,
    DWORD numberOfSymbols,
    PIMAGE_LINENUMBER LineNumbers
    )
{
    PIMAGE_LINENUMBER *SecLines;
    BOOL Ret = false;
    PIMAGE_SECTION_HEADER sh;
    ULONG i;
    PIMAGE_SYMBOL Symbol;
    ULONG LowestPointer;

    // Allocate some space for per-section data.
    SecLines = (PIMAGE_LINENUMBER *)MemAlloc(sizeof(PIMAGE_LINENUMBER)*mi->NumSections);
    if (SecLines == NULL) {
        return false;
    }

    //
    // Add line number information for file groups if such
    // groups exist.
    //

    // First locate the lowest file offset for linenumbers.  This
    // is necessary to be able to compute relative linenumber pointers
    // in split images because currently the pointers aren't updated
    // during stripping.
    sh = mi->SectionHdrs;
    LowestPointer = 0xffffffff;
    for (i = 0; i < mi->NumSections; i++, sh++) {
        if (sh->NumberOfLinenumbers > 0 &&
            sh->PointerToLinenumbers != 0 &&
            sh->PointerToLinenumbers < LowestPointer)
        {
            LowestPointer = sh->PointerToLinenumbers;
        }
    }

    if (LowestPointer == 0xffffffff) {
        goto EH_FreeSecLines;
    }

    sh = mi->SectionHdrs;
    for (i = 0; i < mi->NumSections; i++, sh++) {
        if (sh->NumberOfLinenumbers > 0 &&
            sh->PointerToLinenumbers != 0)
        {
            SecLines[i] = (PIMAGE_LINENUMBER)
                (sh->PointerToLinenumbers - LowestPointer + (DWORD_PTR)LineNumbers);

#ifdef DBG_COFF_LINES
            DbgOut("Section %d: %d lines at %08X\n",
                   i, sh->NumberOfLinenumbers, SecLines[i]);
#endif
        } else {
            SecLines[i] = NULL;
        }
    }

    // Look for a file symbol.
    Symbol = allSymbols;
    for (i = 0; i < numberOfSymbols; i++) {
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_FILE) {
            break;
        }

        i += Symbol->NumberOfAuxSymbols;
        Symbol += 1+Symbol->NumberOfAuxSymbols;
    }

    // If no file symbols were found, don't attempt to add line
    // number information.  Something could be done with the raw
    // linenumber info in the image (if it exists) but this probably
    // isn't an important enough case to worry about.

    while (i < numberOfSymbols) {
        ULONG iNextFile, iAfterFile;
        ULONG iCur, iSym;
        PIMAGE_SYMBOL SymAfterFile, CurSym;
        PIMAGE_AUX_SYMBOL AuxSym;
        ULONG Lines;
        ULONG MinAddr, MaxAddr;
        LPSTR FileName;
        ULONG FileNameLen;

#ifdef DBG_COFF_LINES
        DbgOut("%3X: '%s', %X\n", i, Symbol+1, Symbol->Value);
#endif

        // A file symbol's Value is the index of the next file symbol.
        // In between the two file symbols there may be static
        // section symbols which give line number counts for all
        // the line numbers in the file.
        // The file chain can be NULL terminated or a circular list,
        // in which case this code assumes the end comes when the
        // list wraps around.

        if (Symbol->Value == 0 || Symbol->Value <= i) {
            iNextFile = numberOfSymbols;
        } else {
            iNextFile = Symbol->Value;
        }

        // Compute the index of the first symbol after the current file
        // symbol.
        iAfterFile = i+1+Symbol->NumberOfAuxSymbols;
        SymAfterFile = Symbol+1+Symbol->NumberOfAuxSymbols;

        // Look for section symbols and count up the number of linenumber
        // references, the min address and the max address.
        CurSym = SymAfterFile;
        iCur = iAfterFile;
        Lines = 0;
        MinAddr = 0xffffffff;
        MaxAddr = 0;
        while (iCur < iNextFile) {
            DWORD Addr;

            if (IS_SECTION_SYM(CurSym) &&
                SecLines[CurSym->SectionNumber-1] != NULL)
            {
                AuxSym = (PIMAGE_AUX_SYMBOL)(CurSym+1);

                Lines += AuxSym->Section.NumberOfLinenumbers;

                Addr = (ULONG)(CurSym->Value+mi->BaseOfDll);

#ifdef DBG_COFF_LINES
                DbgOut("    Range %08X %08X, min %08X max %08X\n",
                       Addr, Addr+AuxSym->Section.Length-1,
                       MinAddr, MaxAddr);
#endif

                if (Addr < MinAddr) {
                    MinAddr = Addr;
                }
                Addr += AuxSym->Section.Length-1;
                if (Addr > MaxAddr) {
                    MaxAddr = Addr;
                }
            }

            iCur += 1+CurSym->NumberOfAuxSymbols;
            CurSym += 1+CurSym->NumberOfAuxSymbols;
        }

        if (Lines > 0) {
            PSOURCE_ENTRY Src;
            PSOURCE_LINE SrcLine;
            ULONG iLine;

            // We have a filename and some linenumber information,
            // so create a SOURCE_ENTRY and fill it in.

            FileName = (LPSTR)(Symbol+1);
            FileNameLen = strlen(FileName);

            Src = (PSOURCE_ENTRY)MemAlloc(sizeof(SOURCE_ENTRY)+
                                          sizeof(SOURCE_LINE)*Lines+
                                          FileNameLen+1);
            if (Src == NULL) {
                goto EH_FreeSecLines;
            }

            Src->ModuleId = 0;
            Src->MinAddr = MinAddr;
            Src->MaxAddr = MaxAddr;
            Src->Lines = Lines;

            SrcLine = (PSOURCE_LINE)(Src+1);
            Src->LineInfo = SrcLine;

            // Now that we've got a place to put linenumber information,
            // retraverse the section symbols and grab COFF linenumbers
            // from the appropriate sections and format them into
            // the generic format.
            CurSym = SymAfterFile;
            iCur = iAfterFile;
            while (iCur < iNextFile) {
                if (IS_SECTION_SYM(CurSym) &&
                    SecLines[CurSym->SectionNumber-1] != NULL) {
                    PIMAGE_LINENUMBER CoffLine;

                    AuxSym = (PIMAGE_AUX_SYMBOL)(CurSym+1);
                    CoffLine = SecLines[CurSym->SectionNumber-1];

#ifdef DBG_COFF_LINES
                    DbgOut("    %d lines at %08X\n",
                           AuxSym->Section.NumberOfLinenumbers,
                           CoffLine);
#endif

                    for (iLine = 0;
                         iLine < AuxSym->Section.NumberOfLinenumbers;
                         iLine++)
                    {
                        SrcLine->Addr = CoffLine->Type.VirtualAddress+
                            mi->BaseOfDll;
                        SrcLine->Line = CoffLine->Linenumber;
                        CoffLine++;
                        SrcLine++;
                    }

                    SecLines[CurSym->SectionNumber-1] = CoffLine;
                }

                iCur += 1+CurSym->NumberOfAuxSymbols;
                CurSym += 1+CurSym->NumberOfAuxSymbols;
            }

            // Stick file name at the very end of the data block so
            // it doesn't interfere with alignment.
            Src->File = (LPSTR)SrcLine;
            memcpy(Src->File, FileName, FileNameLen+1);

            AddSourceEntry(mi, Src);

            // This routine is successful as long as it adds at least
            // one new source entry.
            Ret = true;
        }

        // After the loops above iCur and CurSym refer to the next
        // file symbol, so update the loop counters from them.
        i = iCur;
        Symbol = CurSym;
    }

 EH_FreeSecLines:
    MemFree(SecLines);

    return Ret;
}

BOOL
AddLinesForOmfSourceModule(
    PMODULE_ENTRY mi,
    BYTE *Base,
    OMFSourceModule *OmfSrcMod,
    PVOID PdbModule
    )
{
    BOOL Ret;
    ULONG iFile;

    Ret = false;

    for (iFile = 0; iFile < (ULONG)OmfSrcMod->cFile; iFile++) {
        OMFSourceFile *OmfSrcFile;
        BYTE OmfFileNameLen;
        LPSTR OmfFileName;
        PULONG OmfAddrRanges;
        OMFSourceLine *OmfSrcLine;
        ULONG iSeg;
        PSOURCE_ENTRY Src;
        PSOURCE_ENTRY Seg0Src = NULL;
        PSOURCE_LINE SrcLine;
        ULONG NameAllocLen;

        OmfSrcFile = (OMFSourceFile *)(Base+OmfSrcMod->baseSrcFile[iFile]);

        // The baseSrcLn array of offsets is immediately followed by
        // SVA pairs which define the address ranges for the segments.
        OmfAddrRanges = &OmfSrcFile->baseSrcLn[OmfSrcFile->cSeg];

        // The name length and data immediately follows the address
        // range information.
        OmfFileName = (LPSTR)(OmfAddrRanges+2*OmfSrcFile->cSeg)+1;
        OmfFileNameLen = *(BYTE *)(OmfFileName-1);

        // The compiler can potentially generate a lot of segments
        // per file.  The segments within a file have disjoint
        // address ranges as long as they are treated as separate
        // SOURCE_ENTRYs.  If all segments for a particular file get
        // combined into one SOURCE_ENTRY it leads to address range overlap
        // because of combining non-contiguous segments.  Allocating
        // a SOURCE_ENTRY per segment isn't that bad, particularly since
        // the name information only needs to be allocated in the first
        // entry for a file and the rest can share it.

        NameAllocLen = OmfFileNameLen+1;

        for (iSeg = 0; iSeg < (ULONG)OmfSrcFile->cSeg; iSeg++) {
            PULONG Off;
            PUSHORT Ln;
            ULONG iLine;
            PIMAGE_SECTION_HEADER sh;

            OmfSrcLine = (OMFSourceLine *)(Base+OmfSrcFile->baseSrcLn[iSeg]);

            Src = (PSOURCE_ENTRY)MemAlloc(sizeof(SOURCE_ENTRY)+
                                          sizeof(SOURCE_LINE)*OmfSrcLine->cLnOff+
                                          NameAllocLen);
            if (Src == NULL) {
                return Ret;
            }

            Src->ModuleId = (ULONG) (ULONG64) PdbModule;
            Src->Lines = OmfSrcLine->cLnOff;

            sh = &mi->SectionHdrs[OmfSrcLine->Seg-1];

            // Process raw segment limits into current addresses.
            Src->MinAddr = mi->BaseOfDll+sh->VirtualAddress+(*OmfAddrRanges++);
            Src->MaxAddr = mi->BaseOfDll+sh->VirtualAddress+(*OmfAddrRanges++);

            // Retrieve line numbers and offsets from raw data and
            // process them into current pointers.

            SrcLine = (SOURCE_LINE *)(Src+1);
            Src->LineInfo = SrcLine;

            Off = (ULONG *)&OmfSrcLine->offset[0];
            Ln = (USHORT *)(Off+OmfSrcLine->cLnOff);

            for (iLine = 0; iLine < OmfSrcLine->cLnOff; iLine++) {
                SrcLine->Line = *Ln++;
                SrcLine->Addr = (*Off++)+mi->BaseOfDll+sh->VirtualAddress;

                // Line symbol information names the IA64 bundle
                // syllables with 0,1,2 whereas the debugger expects
                // 0,4,8.  Convert.
                if (mi->MachineType == IMAGE_FILE_MACHINE_IA64 &&
                    (SrcLine->Addr & 3)) {
                    SrcLine->Addr = (SrcLine->Addr & ~3) |
                        ((SrcLine->Addr & 3) << 2);
                }

                SrcLine++;
            }

            if (iSeg == 0) {
                // Stick file name at the very end of the data block so
                // it doesn't interfere with alignment.
                Src->File = (LPSTR)SrcLine;
                memcpy(Src->File, OmfFileName, OmfFileNameLen);
                Src->File[OmfFileNameLen] = 0;

                // Later segments will share this initial name storage
                // space so they don't need to alloc their own.
                NameAllocLen = 0;
                Seg0Src = Src;
            } else if (Seg0Src) {
                Src->File = Seg0Src->File;
            }

            AddSourceEntry(mi, Src);

            // This routine is successful as long as it adds at least
            // one new source entry.
            Ret = true;
        }
    }

    return Ret;
}


void
srcline2sci(
    PSOURCE_ENTRY Src,
    PSOURCE_LINE SrcLine,
    PSRCCODEINFO sci
    )
{
    sci->Key = (PVOID)SrcLine;
    sci->LineNumber = SrcLine->Line;
    sci->Address = SrcLine->Addr;
    CopyStrArray(sci->FileName, Src->File ? Src->File : "");
}


PSOURCE_LINE
FindLineInSource(
    PSOURCE_ENTRY Src,
    DWORD64 Addr
    )
{
    int Low, Middle, High;
    PSOURCE_LINE SrcLine;

    Low = 0;
    High = Src->Lines-1;

    while (High >= Low) {
        Middle = (High <= Low) ? Low : (Low + High) >> 1;
        SrcLine = &Src->LineInfo[Middle];

#ifdef DBG_ADDR_SEARCH
        DbgOut("    Checking %4d:%x`%08X\n", Middle,
               (ULONG)(SrcLine->Addr>>32), (ULONG)SrcLine->Addr);
#endif

        if (Addr < SrcLine->Addr) {
            High = Middle-1;
        }
        else if (Middle < (int)Src->Lines-1 &&
                 Addr >= (SrcLine+1)->Addr) {
            Low = Middle+1;
        } else {
            PSOURCE_LINE HighLine;

            // Find the highest source line with this offset.
            // Source lines are sorted by offset so the highest
            // source line could be before or after this one.

            while (SrcLine > Src->LineInfo &&
                   (SrcLine - 1)->Addr == SrcLine->Addr) {
                SrcLine--;
            }
            HighLine = SrcLine;
            while (SrcLine < Src->LineInfo + Src->Lines - 1 &&
                   (++SrcLine)->Addr == HighLine->Addr) {
                if (SrcLine->Line > HighLine->Line) {
                    HighLine = SrcLine;
                }
            }
            return HighLine;
        }
    }

    return NULL;
}

PSOURCE_ENTRY
FindNextSourceEntryForAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr,
    PSOURCE_ENTRY SearchFrom
    )
{
    PSOURCE_ENTRY Src;

    Src = SearchFrom != NULL ? SearchFrom->Next : mi->SourceFiles;
    while (Src != NULL) {
        if (Addr < Src->MinAddr) {
            // Source files are kept sorted by increasing address so this
            // means that the address will not be found later and
            // we can stop checking.
            return NULL;
        } else if (Addr <= Src->MaxAddr) {
            // Found one.
            return Src;
        }
        Src = Src->Next;
    }

    return NULL;
}

BOOL
GetLineFromAddr(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY mi,
    DWORD64 Addr,
    PDWORD Displacement,
    PSRCCODEINFO sci
    )
{
    PSOURCE_ENTRY Src;
    DWORD Bias;
    DWORD64 srcAddr;
    BOOL rc;

    if (mi == NULL)
        return false;

    rc = false;

    if (mi->dia) {
        rc = diaGetLineFromAddr(mi, Addr, Displacement, sci);
        if (rc) 
            AddSourceFileToHintList(pe, mi, sci->FileName);
        return rc;
    }

    srcAddr = ConvertOmapToSrc(mi,
                               Addr,
                               &Bias,
                               option(SYMOPT_OMAP_FIND_NEAREST));

    if (!srcAddr) 
        return false;

    // We have successfully converted

    srcAddr += Bias;

    for (;;) {
        PSOURCE_ENTRY BestSrc;
        PSOURCE_LINE BestSrcLine;
        DWORD64 BestDisp;

        // Search through all the source entries that contain the given
        // address, looking for the line with the smallest displacement.

        BestDisp = 0xffffffffffffffff;
        BestSrc = NULL;
        Src = NULL;
        while (Src = FindNextSourceEntryForAddr(mi, srcAddr, Src)) {
            PSOURCE_LINE SrcLine;

#ifdef DBG_ADDR_SEARCH
            DbgOut("Found '%s' %d lines: %08I64X %08I64X for %08I64X\n",
                   Src->File, Src->Lines, Src->MinAddr, Src->MaxAddr, Addr);
#endif

            // Found a matching source entry, so look up the line
            // information.
            SrcLine = FindLineInSource(Src, srcAddr);
            if (SrcLine != NULL &&
                Addr-SrcLine->Addr < BestDisp) {
                BestDisp = Addr-SrcLine->Addr;

#ifdef DBG_ADDR_SEARCH
                DbgOut("  Best disp %I64X\n", BestDisp);
#endif

                BestSrc = Src;
                BestSrcLine = SrcLine;
                if (BestDisp == 0) {
                    break;
                }
            }
        }

        // Only accept displaced answers if there's no more symbol
        // information to load.
        if (BestSrc != NULL && BestDisp == 0) {
            srcline2sci(BestSrc, BestSrcLine, sci);
            *Displacement = (ULONG)BestDisp;
            return true;
        }

        return false;
    }

    return false;
}

PSOURCE_ENTRY
FindNextSourceEntryForFile(
    PMODULE_ENTRY mi,
    LPSTR FileStr,
    PSOURCE_ENTRY SearchFrom
    )
{
    PSOURCE_ENTRY Src;

    Src = SearchFrom != NULL ? SearchFrom->Next : mi->SourceFiles;
    while (Src != NULL)
    {
        if (SymMatchFileName(Src->File, FileStr, NULL, NULL))
        {
            return Src;
        }

        Src = Src->Next;
    }

    return NULL;
}

PSOURCE_ENTRY
FindPrevSourceEntryForFile(
    PMODULE_ENTRY mi,
    LPSTR FileStr,
    PSOURCE_ENTRY SearchFrom
    )
{
    PSOURCE_ENTRY Src;

    Src = SearchFrom != NULL ? SearchFrom->Prev : mi->SourceFilesTail;
    while (Src != NULL)
    {
        if (SymMatchFileName(Src->File, FileStr, NULL, NULL))
        {
            return Src;
        }

        Src = Src->Prev;
    }

    return NULL;
}


BOOL
GetLineFromName(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY mi,
    LPSTR FileName,
    DWORD LineNumber,
    PLONG Displacement,
    PSRCCODEINFO sci,
    DWORD method
    )
{
    BOOL rc;
    PSOURCE_ENTRY Src;
    BOOL AtOrGreater;

    ULONG Disp;
    ULONG BestDisp;
    PSOURCE_ENTRY BestSrc;
    PSOURCE_LINE BestSrcLine;

    if (!mi)
        return false;

    // If the high bit of the line number is set
    // it means that the caller only wants lines at
    // or greater than the given line.

    AtOrGreater = (LineNumber & 0x80000000) != 0;
    LineNumber &= 0x7fffffff;

    if (mi->dia)
    {
        rc = diaGetLineFromName(mi, FileName, LineNumber, Displacement, sci, method);
        if (rc)
            AddSourceFileToHintList(pe, mi, FileName);
        return rc;
    }

    //
    // Search existing source information for a filename match.
    // There can be multiple SOURCE_ENTRYs with the same filename,
    // so make sure and search them all for an exact match
    // before settling on an approximate match.
    //

    Src = NULL;
    BestDisp = 0x7fffffff;
    BestSrcLine = NULL;
    while (Src = FindNextSourceEntryForFile(mi, FileName, Src))
    {
        PSOURCE_LINE SrcLine;
        ULONG i;

        // Found a matching source entry, so look up the closest
        // line.  Line number info is sorted by address so the actual
        // line numbers can be in any order so we can't optimize
        // this linear search.

        SrcLine = Src->LineInfo;
        for (i = 0; i < Src->Lines; i++)
        {
            if (LineNumber > SrcLine->Line)
            {
                if (AtOrGreater)
                {
                    Disp = 0x7fffffff;
                }
                else
                {
                    Disp = LineNumber-SrcLine->Line;
                }
            }
            else
            {
                Disp = SrcLine->Line-LineNumber;
            }

            if (Disp < BestDisp)
            {
                BestDisp = Disp;
                BestSrc = Src;
                BestSrcLine = SrcLine;
                if (Disp == 0)
                {
                    break;
                }
            }

            SrcLine++;
        }

        // If we found an exact match we can stop.
        if (BestDisp == 0)
        {
            break;
        }
    }

    // Only accept displaced answers if there's no more symbol
    // information to load.

    if (BestSrcLine != NULL && (BestDisp == 0))
    {
        srcline2sci(BestSrc, BestSrcLine, sci);
        *Displacement = (LONG)(LineNumber-BestSrcLine->Line);
        AddSourceFileToHintList(pe, mi, FileName);
        return true;
    }

    return false;
}

#define LINE_ERROR 0xffffffff

// we need to get rid of this function!

ULONG
GetFileLineOffsets(
    PMODULE_ENTRY mi,
    LPSTR FileName,
    PDWORD64 Buffer,
    ULONG BufferLines
    )
{
    PSOURCE_ENTRY Src;
    ULONG HighestLine = 0;

    // This routine collects all line information in one pass so
    // there's no opportunity for lazy loading.  We have to
    // force lines to be loaded up front.
    if (mi->dia && option(SYMOPT_LOAD_LINES)) {
        if (!diaAddLinesForAllMod(mi)) {
            return LINE_ERROR;
        }
    }

    Src = NULL;
    while (Src = FindNextSourceEntryForFile(mi, FileName, Src)) {
        PSOURCE_LINE Line;
        ULONG i;
        ULONG Num;

        Line = Src->LineInfo;
        for (i = 0; i < Src->Lines; i++) {
            if (Line->Line > HighestLine) {
                HighestLine = Line->Line;
            }

            Num = Line->Line - 1;
            if (Num < BufferLines) {
                Buffer[Num] = Line->Addr;
            }

            Line++;
        }
    }

    return HighestLine;
}

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    IN  HANDLE                  hProcess,
    IN  LPSTR                   ModuleName,
    IN  LPSTR                   FileName,
    OUT PDWORD64                Buffer,
    IN  ULONG                   BufferLines
    )

/*++

Routine Description:

    This function locates the given file's line information
    and fills the given buffer with offsets for each
    line.  Buffer[Line - 1] is set to the offset for
    Line.  Buffer entries for lines that do not have information
    are left unchanged.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    ModuleName          - Module name or NULL.

    FileName            - File name.

    Buffer              - Array of offsets to fill.

    BufferLines         - Number of entries in the Buffer array.

Return Value:

    0                   - No information was found.

    LINE_ERROR          - Failure during operation.  Call GetLastError to
                          discover the cause of the failure.

    Otherwise the return value is the highest line number found.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi;
    ULONG               HighestLine = 0;
    PLIST_ENTRY         Next;

    __try {
        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return LINE_ERROR;
        }

        if (ModuleName != NULL) {

            mi = FindModule(hProcess, ProcessEntry, ModuleName, true);
            if (mi != NULL) {
                return GetFileLineOffsets(mi, FileName, Buffer, BufferLines);
            }

            SetLastError( ERROR_MOD_NOT_FOUND );
            return LINE_ERROR;
        }

        Next = ProcessEntry->ModuleList.Flink;
        if (Next) {
            while (Next != &ProcessEntry->ModuleList) {

                mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = mi->ListEntry.Flink;

                if (!LoadSymbols(hProcess, mi, LS_QUALIFIED | LS_LOAD_LINES)) {
                    continue;
                }

                HighestLine = GetFileLineOffsets(mi, FileName, Buffer,
                                                 BufferLines);
                // This will break on lines found or LINE_ERROR.
                if (HighestLine > 0) {
                    break;
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return LINE_ERROR;

    }

    return HighestLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\msvcrtp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msvcrtp.c

Abstract:

    This module implements vector new and delete so that
    dbghelp will run on systems with old copies of msvcrt.dll

Author:

    Pat Styles (patst) 09-November-2000

Revision History:

--*/

#ifdef _X86_
              
// these two exist so that we can work with old
// versions of msvcrt.dll that ships in NT4, SP6 and earlier

void __cdecl operator delete[](void * p)
{
    operator delete( p );
}

void * __cdecl operator new[]( size_t cb )
{
    void *res = operator new(cb);
    return res;
}

#endif // #ifdef _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\pdbp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pdb.h

Abstract:

    This header file contains typedefs and prototypes
    necessary for accessing pdb files thru the msvc pdb dll.

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

__inline
char *
DataSymNameStart(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return (char *)&((DATASYM32_16t *)dataSym)->name[1];

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return (char *)&((DATASYM32 *)dataSym)->name[1];
    }
}


__inline
unsigned char
DataSymNameLength(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(((DATASYM32_16t *)dataSym)->name[0]);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(((DATASYM32 *)dataSym)->name[0]);
    }
}


__inline
unsigned short
DataSymSeg(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(((DATASYM32_16t *)dataSym)->seg);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(((DATASYM32 *)dataSym)->seg);
    }
}


__inline
unsigned long
DataSymOffset(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(((DATASYM32_16t *)dataSym)->off);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(((DATASYM32 *)dataSym)->off);
    }
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\mapi.c ===
#ifndef _STRSAFE_H_INCLUDED_
#include <strsafe.h>
#endif

BOOL
MapAndLoad(
    LPSTR ImageName,
    LPSTR DllPath,
    PLOADED_IMAGE LoadedImage,
    BOOL DotDll,
    BOOL ReadOnly
    )
{
    HANDLE hFile;
    HANDLE hMappedFile;
    CHAR SearchBuffer[MAX_PATH];
    DWORD dw;
    LPSTR FilePart;
    LPSTR OpenName;
    int   NameLen;

    // open and map the file.
    // then fill in the loaded image descriptor

    if (!LoadedImage) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try {
        ZeroMemory(LoadedImage, sizeof(*LoadedImage));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    LoadedImage->hFile = INVALID_HANDLE_VALUE;

    OpenName = ImageName;
    dw = 0;
retry:
    hFile = CreateFile(
                OpenName,
                ReadOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
#ifdef STANDALONE_MAP
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
#else
                g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
#endif
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );


    if ( hFile == INVALID_HANDLE_VALUE ) {
        if ( !dw ) {
            //
            // open failed try to find the file on the search path
            //

            dw =   SearchPath(
                    DllPath,
                    ImageName,
                    DotDll ? ".dll" : ".exe",
                    MAX_PATH,
                    SearchBuffer,
                    &FilePart
                    );
            if ( dw && dw < MAX_PATH ) {
                OpenName = SearchBuffer;
                goto retry;
            }
        }
        return FALSE;
    }

    if (MapIt(hFile, LoadedImage, ReadOnly) == FALSE) {
        CloseHandle(hFile);
        return FALSE;
    } else {
        NameLen = strlen(OpenName) + 16;
#ifdef STANDALONE_MAP
        LoadedImage->ModuleName = (LPSTR) malloc( NameLen );
#else
        LoadedImage->ModuleName = (LPSTR) MemAlloc( NameLen );
#endif
        if (!LoadedImage->ModuleName) {
            return FALSE;
        }
        StringCchCopy(LoadedImage->ModuleName, NameLen, OpenName);

        // If readonly, no need to keep the file open..

        if (ReadOnly) {
            CloseHandle(hFile);
        }

        return TRUE;
    }
}


BOOL
MapIt(
    HANDLE hFile,
    PLOADED_IMAGE LoadedImage,
    BOOL   ReadOnly
    )
{
    HANDLE hMappedFile;

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    ReadOnly ? PAGE_READONLY : PAGE_READWRITE,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        return FALSE;
    }

    LoadedImage->MappedAddress = (PUCHAR) MapViewOfFile(
                                    hMappedFile,
                                    ReadOnly ? FILE_MAP_READ : FILE_MAP_WRITE,
                                    0,
                                    0,
                                    0
                                    );

    CloseHandle(hMappedFile);

    LoadedImage->SizeOfImage = GetFileSize(hFile, NULL);

    if (!LoadedImage->MappedAddress ||
        !CalculateImagePtrs(LoadedImage)) {
        return(FALSE);
    }

    if (ReadOnly) {
        LoadedImage->hFile = INVALID_HANDLE_VALUE;
    } else {
        LoadedImage->hFile = hFile;
    }

    return(TRUE);
}


BOOL
CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_FILE_HEADER FileHeader;
    BOOL fRC;

    // Everything is mapped. Now check the image and find nt image headers

    fRC = TRUE;  // Assume the best

    __try {
        DosHeader = (PIMAGE_DOS_HEADER)LoadedImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) {
            fRC = FALSE;
            goto tryout;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
            if (DosHeader->e_lfanew == 0) {
                LoadedImage->fDOSImage = TRUE;
                fRC = FALSE;
                goto tryout;
            }
            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            if (
                // If IMAGE_NT_HEADERS would extend past the end of file...
                (PBYTE)LoadedImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                    (PBYTE)LoadedImage->MappedAddress + LoadedImage->SizeOfImage ||

                 // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                     (PBYTE)LoadedImage->FileHeader <
                      (PBYTE)LoadedImage->MappedAddress + sizeof(IMAGE_DOS_HEADER)  )
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                fRC = FALSE;
                goto tryout;
            }
        } else {

            // No DOS header indicates an image built w/o a dos stub

            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader);
        }

        NtHeaders = LoadedImage->FileHeader;

        if ( NtHeaders->Signature != IMAGE_NT_SIGNATURE ) {
            if ( (USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE ||
                 (USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE_LE
               ) {
                LoadedImage->fDOSImage = TRUE;
            }

            fRC = FALSE;
            goto tryout;
        } else {
            LoadedImage->fDOSImage = FALSE;
        }

        FileHeader = &NtHeaders->FileHeader;

        // No optional header indicates an object...

        if ( FileHeader->SizeOfOptionalHeader == 0 ) {
            fRC = FALSE;
            goto tryout;
        }

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            // 32-bit image.  Do some tests.
            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase >= 0x80000000) {
                LoadedImage->fSystemImage = TRUE;
            } else {
                LoadedImage->fSystemImage = FALSE;
            }

            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MajorLinkerVersion < 3 &&
                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MinorLinkerVersion < 5)
            {
                fRC = FALSE;
                goto tryout;
            }

        } else {
            LoadedImage->fSystemImage = FALSE;
        }

        LoadedImage->Sections = IMAGE_FIRST_SECTION(NtHeaders);

        InitializeListHead( &LoadedImage->Links );
        LoadedImage->Characteristics = FileHeader->Characteristics;
        LoadedImage->NumberOfSections = FileHeader->NumberOfSections;
        LoadedImage->LastRvaSection = LoadedImage->Sections;

tryout:
        if (fRC == FALSE) {
            UnmapViewOfFile(LoadedImage->MappedAddress);
            SetLastError(ERROR_BAD_FORMAT);
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {
        fRC = FALSE;
    }

    return fRC;
}

BOOL
UnMapAndLoad(
    PLOADED_IMAGE pLi
    )
{
    if (!pLi) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try {
        UnMapIt(pLi);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pLi->hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(pLi->hFile);
    }

    if (pLi->ModuleName) {
#ifdef STANDALONE_MAP
        free( pLi->ModuleName );
#else
        MemFree( pLi->ModuleName );
#endif
    }

    return TRUE;
}

BOOL
GrowMap (
    PLOADED_IMAGE   pLi,
    LONG            lSizeOfDelta
    )
{
    if (pLi->hFile == INVALID_HANDLE_VALUE) {
        // Can't grow read/only files.
        return FALSE;
    } else {
        HANDLE hMappedFile;
        FlushViewOfFile(pLi->MappedAddress, pLi->SizeOfImage);
        UnmapViewOfFile(pLi->MappedAddress);

        pLi->SizeOfImage += lSizeOfDelta;

        SetFilePointer(pLi->hFile, pLi->SizeOfImage, NULL, FILE_BEGIN);
        SetEndOfFile(pLi->hFile);

        hMappedFile = CreateFileMapping(
                        pLi->hFile,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        pLi->SizeOfImage,
                        NULL
                        );
        if ( !hMappedFile ) {
            CloseHandle(pLi->hFile);
            pLi->hFile = INVALID_HANDLE_VALUE;
            return FALSE;
        }

        pLi->MappedAddress = (PUCHAR) MapViewOfFile(
                                        hMappedFile,
                                        FILE_MAP_WRITE,
                                        0,
                                        0,
                                        0
                                        );

        CloseHandle(hMappedFile);

        if (!pLi->MappedAddress) {
            CloseHandle(pLi->hFile);
            pLi->hFile = INVALID_HANDLE_VALUE;
            return(FALSE);
        }

        // Win95 doesn't zero fill when it extends.  Do it here.
        if (lSizeOfDelta > 0) {
            memset(pLi->MappedAddress + pLi->SizeOfImage - lSizeOfDelta, 0, lSizeOfDelta);
        }

        // Recalc the LoadedImage struct (remapping may have changed the map address)
        if (!CalculateImagePtrs(pLi)) {
            CloseHandle(pLi->hFile);
            pLi->hFile = INVALID_HANDLE_VALUE;
            return(FALSE);
        }

        return TRUE;
    }
}


VOID
UnMapIt(
    PLOADED_IMAGE pLi
    )
{
    DWORD HeaderSum, CheckSum;
    BOOL bl;
    DWORD dw;
    PIMAGE_NT_HEADERS NtHeaders;

    // Test for read-only
    if (pLi->hFile == INVALID_HANDLE_VALUE) {
        UnmapViewOfFile(pLi->MappedAddress);
    } else {
        CheckSumMappedFile( pLi->MappedAddress,
                            pLi->SizeOfImage,
                            &HeaderSum,
                            &CheckSum
                          );

        NtHeaders = pLi->FileHeader;

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
        } else {
            if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
            }
        }

        FlushViewOfFile(pLi->MappedAddress, pLi->SizeOfImage);
        UnmapViewOfFile(pLi->MappedAddress);

        if (pLi->SizeOfImage != GetFileSize(pLi->hFile, NULL)) {
            dw = SetFilePointer(pLi->hFile, pLi->SizeOfImage, NULL, FILE_BEGIN);
            dw = GetLastError();
            bl = SetEndOfFile(pLi->hFile);
            dw = GetLastError();
        }
    }
}


BOOL
GetImageConfigInformation(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation
    )
{
    // We're only able to read the old native loadcfg struct from this api.
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG i;
    ULONG V1LoadCfgLength = FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY, SEHandlerTable);

    if (!LoadedImage || 
        !ImageConfigInformation ||
#ifdef _WIN64
        (LoadedImage->FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
#else        
        (LoadedImage->FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
#endif
        ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY) ImageDirectoryEntryToData( LoadedImage->MappedAddress,
                                                 FALSE,
                                                 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                 &i
                                               );
    if (ImageConfigData && (i == V1LoadCfgLength)) {
        if (!ImageConfigData->Size || (ImageConfigData->Size == V1LoadCfgLength)) {
            memcpy( ImageConfigInformation, ImageConfigData, V1LoadCfgLength);
            return TRUE;
        } 
    }

    return FALSE;
}


BOOL
SetImageConfigInformation(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG i;
    ULONG DirectoryAddress;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_DATA_DIRECTORY pLoadCfgDataDir;
    // We can only write native loadcfg struct
    ULONG V1LoadCfgLength = FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY, SEHandlerTable);
    ULONG NewDataSize;

    if ((LoadedImage->hFile == INVALID_HANDLE_VALUE) ||
#ifdef _WIN64
        (LoadedImage->FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
#else        
        (LoadedImage->FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
#endif
        ) 
    {
        return FALSE;
    }

    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY) ImageDirectoryEntryToData( LoadedImage->MappedAddress,
                                                 FALSE,
                                                 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                 &i
                                               );
    if (ImageConfigData && (i == V1LoadCfgLength)) {
        if (ImageConfigInformation->Size) {
            // Incoming size specified?
            if (ImageConfigData->Size == ImageConfigInformation->Size) {
                // Current size same as new size?  Do the copy
                memcpy( ImageConfigData, ImageConfigInformation, ImageConfigInformation->Size);
                return TRUE;
            }
            if (ImageConfigData->Size > ImageConfigInformation->Size) {
                // New size < old size - can't allow that
                return FALSE;
            }
            // Last case is new size > old size - fall through and find room for new data.
        } else {
            // Incoming size not set - must be an V1 user.
            if (ImageConfigData->Size) {
                // Existing size set?  Can't overwrite new data with old data
                return FALSE;
            }
            // New and old are both V1 structs.
            memcpy( ImageConfigData, ImageConfigInformation, V1LoadCfgLength);
            return TRUE;
        }
    }

    NewDataSize = ImageConfigInformation->Size ? ImageConfigInformation->Size : V1LoadCfgLength;

    DirectoryAddress = GetImageUnusedHeaderBytes( LoadedImage, &i );
    if (i < NewDataSize) {
        return FALSE;
    }

    NtHeaders = LoadedImage->FileHeader;

    pLoadCfgDataDir = &NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];
    pLoadCfgDataDir->VirtualAddress = DirectoryAddress;
    pLoadCfgDataDir->Size = V1LoadCfgLength;
    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY) ((PCHAR)LoadedImage->MappedAddress + DirectoryAddress);
    memcpy( ImageConfigData, ImageConfigInformation, sizeof( *ImageConfigData ) );
    return TRUE;
}


BOOLEAN ImageLoadInit;
LIST_ENTRY ImageLoadList;

PLOADED_IMAGE
ImageLoad(
    LPSTR DllName,
    LPSTR DllPath
    )
{
    PLIST_ENTRY Head,Next;
    PLOADED_IMAGE LoadedImage;
    CHAR Drive[_MAX_DRIVE];
    CHAR Dir[_MAX_DIR];
    CHAR Filename[_MAX_FNAME];
    CHAR Ext[_MAX_EXT];
    CHAR LoadedModuleName[_MAX_PATH];
    BOOL fFileNameOnly;

    if (!DllName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (!ImageLoadInit) {
        InitializeListHead( &ImageLoadList );
        ImageLoadInit = TRUE;
    }

    Head = &ImageLoadList;
    Next = Head->Flink;

    _splitpath(DllName, Drive, Dir, Filename, Ext);
    if (!strlen(Drive) && !strlen(Dir)) {
        // The user only specified a filename (no drive/path).
        fFileNameOnly = TRUE;
    } else {
        fFileNameOnly = FALSE;
    }

    while (Next != Head) {
        LoadedImage = CONTAINING_RECORD( Next, LOADED_IMAGE, Links );
        if (fFileNameOnly) {
            _splitpath(LoadedImage->ModuleName, NULL, NULL, Filename, Ext);
            StringCchCopy(LoadedModuleName, MAX_PATH, Filename);
            StringCchCat(LoadedModuleName, MAX_PATH, Ext);
        } else {
            StringCchCopy(LoadedModuleName, MAX_PATH, LoadedImage->ModuleName);
        }

        if (!_stricmp( DllName, LoadedModuleName )) {
            return LoadedImage;
        }

        Next = Next->Flink;
    }

#ifdef STANDALONE_MAP
    LoadedImage = (PLOADED_IMAGE) calloc( sizeof( *LoadedImage ), 1);
#else
    LoadedImage = (PLOADED_IMAGE) MemAlloc( sizeof( *LoadedImage ) );
#endif
    if (LoadedImage != NULL) {
        if (MapAndLoad( DllName, DllPath, LoadedImage, TRUE, TRUE )) {
            InsertTailList( &ImageLoadList, &LoadedImage->Links );
            return LoadedImage;
        }

#ifdef STANDALONE_MAP
        free( LoadedImage );
#else
        MemFree( LoadedImage );
#endif
        LoadedImage = NULL;
    }

    return LoadedImage;
}

BOOL
ImageUnload(
    PLOADED_IMAGE LoadedImage
    )
{
    if (!LoadedImage) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try {
        if (!IsListEmpty( &LoadedImage->Links )) {
            RemoveEntryList( &LoadedImage->Links );
        }

        UnMapAndLoad( LoadedImage );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

#ifdef STANDALONE_MAP
    free( LoadedImage );
#else
    MemFree( LoadedImage );
#endif

    return TRUE;
}

BOOL
UnloadAllImages()
{
    PLIST_ENTRY Head,Next;
    PLOADED_IMAGE LoadedImage;

    if (!ImageLoadInit) {
        return(TRUE);
    }

    Head = &ImageLoadList;
    Next = Head->Flink;

    while (Next != Head) {
        LoadedImage = CONTAINING_RECORD( Next, LOADED_IMAGE, Links );
        Next = Next->Flink;
        ImageUnload(LoadedImage);
    }

    ImageLoadInit = FALSE;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\rebasei.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rebase.c

Abstract:

    Source file for the REBASE utility that takes a group of image files and
    rebases them so they are packed as closely together in the virtual address
    space as possible.

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

--*/

#include <private.h>

//
// byte swapping macros (LE/BE) used for IA64 relocations
// source != destination
//

#define SWAP_SHORT(_dst,_src)                                                  \
   ((((unsigned char *)_dst)[1] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[1]))

#define SWAP_INT(_dst,_src)                                                    \
   ((((unsigned char *)_dst)[3] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[1]),                 \
    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[2]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[3]))

#define SWAP_LONG_LONG(_dst,_src)                                              \
   ((((unsigned char *)_dst)[7] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[6] = ((unsigned char *)_src)[1]),                 \
    (((unsigned char *)_dst)[5] = ((unsigned char *)_src)[2]),                 \
    (((unsigned char *)_dst)[4] = ((unsigned char *)_src)[3]),                 \
    (((unsigned char *)_dst)[3] = ((unsigned char *)_src)[4]),                 \
    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[5]),                 \
    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[6]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[7]))


#define REBASE_ERR 99
#define REBASE_OK  0

static
PVOID
RvaToVa(
    ULONG Rva,
    PLOADED_IMAGE Image
    );

typedef
PIMAGE_BASE_RELOCATION
(WINAPI *LPRELOCATE_ROUTINE)(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    );

typedef
PIMAGE_BASE_RELOCATION
(WINAPI *LPRELOCATE_ROUTINE64)(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    );


static LPRELOCATE_ROUTINE RelocRoutineNative;
static LPRELOCATE_ROUTINE64 RelocRoutine64;


#include <ldrreloc_rebase.c>        // P/u ldrreloc from ntos\rtl

#define x256MEG (256*(1024*1024))

#define x256MEGSHIFT 28

#define ROUND_UP( Size, Amount ) (((ULONG)(Size) + ((Amount) - 1)) & ~((Amount) - 1))

VOID
AdjImageBaseSize(
    PULONG  pImageBase,
    PULONG  ImageSize,
    BOOL    fGoingDown
    );


BOOL
RelocateImage(
    PLOADED_IMAGE LoadedImage,
    ULONG64 NewBase,
    ULONG64 *Diff,
    ULONG tstamp
    );

BOOL
ReBaseImage(
    IN     LPSTR CurrentImageName,
    IN     LPSTR SymbolPath,        // Symbol path (if
    IN     BOOL  fReBase,           // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk,  // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,        // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,    // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,     // Returned from the header
    OUT    ULONG_PTR *OldImageBase, // Returned from the header
    OUT    ULONG *NewImageSize,     // Image size rounded to next separation boundary
    IN OUT ULONG_PTR *NewImageBase, // (in) Desired new address.
                                    // (out) Next new address (above/below this one)
    IN     ULONG tstamp             // new timestamp for image
    )
{
    ULONG64 xOldImageBase = *OldImageBase;
    ULONG64 xNewImageBase = *NewImageBase;
    BOOL rc;

    rc = ReBaseImage64(
        CurrentImageName,
        SymbolPath,
        fReBase,
        fRebaseSysfileOk,
        fGoingDown,
        CheckImageSize,
        OldImageSize,
        &xOldImageBase,
        NewImageSize,
        &xNewImageBase,
        tstamp);

    *OldImageBase = (ULONG_PTR)xOldImageBase;
    *NewImageBase = (ULONG_PTR)xNewImageBase;
    return rc;
}

BOOL
ReBaseImage64(
    IN     LPSTR CurrentImageName,
    IN     LPSTR SymbolPath,       // Symbol path (if
    IN     BOOL  fReBase,          // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk, // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,       // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,   // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,    // Returned from the header
    OUT    ULONG64 *OldImageBase,  // Returned from the header
    OUT    ULONG *NewImageSize,    // Image size rounded to next separation boundary
    IN OUT ULONG64 *NewImageBase,  // (in) Desired new address.
                                   // (out) Next new address (above/below this one)
    IN     ULONG tstamp            // new timestamp for image
    )
{
    BOOL  fSymbolsAlreadySplit = FALSE;
    CHAR  DebugFileName[ MAX_PATH+1 ];
    CHAR  DebugFilePath[ MAX_PATH+1 ];
    ULONG CurrentImageSize;
    ULONG64 DesiredImageBase;
    ULONG OldChecksum;
    ULONG64 Diff = 0;
    ULONG UpdateSymbolsError = 0;
    LOADED_IMAGE CurrentImage = {0};

    BOOL rc = TRUE;

    if (fReBase && (*NewImageBase & 0x0000FFFF) != 0) {
        rc = FALSE;
        UpdateSymbolsError = ERROR_INVALID_ADDRESS;
        goto Exit;
    }

    // Map and load the current image

    if ( MapAndLoad( CurrentImageName, NULL, &CurrentImage, FALSE, fReBase ? FALSE : TRUE ) ) {
        PVOID pData;
        DWORD dwDataSize;
        pData = ImageDirectoryEntryToData(
                                          CurrentImage.MappedAddress,
                                          FALSE,
                                          IMAGE_DIRECTORY_ENTRY_SECURITY,
                                          &dwDataSize
                                          );

        if (pData || dwDataSize) {
            // Certificates in the image, can't rebase
            UpdateSymbolsError = ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY;
            rc = FALSE;
            goto CleanupAndExit;
        }

        pData = ImageDirectoryEntryToData(
                                          CurrentImage.MappedAddress,
                                          FALSE,
                                          IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                          &dwDataSize
                                          );

        if (pData || dwDataSize) {
            // COR header found - see if it's strong signed
            if (((IMAGE_COR20_HEADER *)pData)->Flags & COMIMAGE_FLAGS_STRONGNAMESIGNED)
            {
                UpdateSymbolsError = ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY;
                rc = FALSE;
                goto CleanupAndExit;
            }
        }

        if (!(!fRebaseSysfileOk && CurrentImage.fSystemImage)) {
            fSymbolsAlreadySplit = CurrentImage.Characteristics & IMAGE_FILE_DEBUG_STRIPPED ? TRUE : FALSE;
            if ( fSymbolsAlreadySplit ) {

                // Find DebugFileName for later use.

                PIMAGE_DEBUG_DIRECTORY DebugDirectories;
                ULONG DebugDirectoriesSize;
                PIMAGE_DEBUG_MISC MiscDebug;

                strcpy( DebugFileName, CurrentImageName );

                DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(
                                                        CurrentImage.MappedAddress,
                                                        FALSE,
                                                        IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                        &DebugDirectoriesSize
                                                        );
                if (DebugDirectoryIsUseful(DebugDirectories, DebugDirectoriesSize)) {
                    while (DebugDirectoriesSize != 0) {
                        if (DebugDirectories->Type == IMAGE_DEBUG_TYPE_MISC) {
                            MiscDebug = (PIMAGE_DEBUG_MISC)
                                ((PCHAR)CurrentImage.MappedAddress +
                                 DebugDirectories->PointerToRawData
                                );
                            strcpy( DebugFileName, (PCHAR) MiscDebug->Data );
                            break;
                        }
                        else {
                            DebugDirectories += 1;
                            DebugDirectoriesSize -= sizeof( *DebugDirectories );
                        }
                    }
                }
            }

            if (CurrentImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                CurrentImageSize = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.SizeOfImage;
                *OldImageBase = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.ImageBase;
            } else {
                CurrentImageSize = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.SizeOfImage;
                *OldImageBase = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.ImageBase;
            }

            // Save the current settings for the caller.

            *OldImageSize = CurrentImageSize;
            *NewImageSize = ROUND_UP( CurrentImageSize, IMAGE_SEPARATION );

            if (CheckImageSize) {
                // The user asked for a max size test.

                if ( *NewImageSize > ROUND_UP(CheckImageSize, IMAGE_SEPARATION) ) {
                    *NewImageBase = 0;
                    rc = FALSE;
                    goto CleanupAndExit;
                }
            }

            DesiredImageBase = *NewImageBase;

            // So long as we're not basing to zero or rebasing to the same address,
            // go for it.

            if (fReBase) {
                BOOL fAdjust;
                if ((CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) &&
                    (CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_ALPHA) &&
                    (CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_ALPHA64) &&
                    (CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_IA64))
                {
                    fAdjust = TRUE;
                } else {
                    fAdjust = FALSE;
                }

                if (fGoingDown) {
                    DesiredImageBase -= *NewImageSize;
                    if (fAdjust) {
                        AdjImageBaseSize( (PULONG)&DesiredImageBase, &CurrentImageSize, fGoingDown );
                    }
                }

                if ((DesiredImageBase) &&
                    (DesiredImageBase != *OldImageBase)
                   ) {

                    if (CurrentImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                        OldChecksum = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum;
                    } else {
                        OldChecksum = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.CheckSum;
                    }
                    if ( !RelocateImage( &CurrentImage, DesiredImageBase, &Diff, tstamp ) ) {
                        UpdateSymbolsError = GetLastError();
                        rc = FALSE;
                        goto CleanupAndExit;
                    }

                    if ( fSymbolsAlreadySplit && Diff ) {
                        if ( UpdateDebugInfoFileEx(CurrentImageName,
                                                   SymbolPath,
                                                   DebugFilePath,
                                                   (PIMAGE_NT_HEADERS32)(CurrentImage.FileHeader),
                                                   OldChecksum )) {
                            UpdateSymbolsError = GetLastError();
                        } else {
                            UpdateSymbolsError = 0;
                        }
                    }
                } else {
                    //
                    // Should this be -1??  shouldn't it be 0 instead? - kentf
                    //
                    Diff = (ULONG) -1;
                }

                if (!fGoingDown && Diff) {
                    DesiredImageBase += *NewImageSize;
                    if (fAdjust) {
                        AdjImageBaseSize( (PULONG)&DesiredImageBase, &CurrentImageSize, fGoingDown );
                    }
                }

            }
        }

        if (fReBase) {
            if (Diff) {
                *NewImageBase = DesiredImageBase;
            } else {
                UpdateSymbolsError = ERROR_INVALID_ADDRESS;
                rc = FALSE;
                goto CleanupAndExit;
            }
        }
    } else {
        if (CurrentImage.fDOSImage == TRUE) {
            UpdateSymbolsError = ERROR_BAD_EXE_FORMAT;
        } else {
            UpdateSymbolsError = GetLastError();
        }
        rc = FALSE;
        goto Exit;
    }

CleanupAndExit:
    UnmapViewOfFile( CurrentImage.MappedAddress );
    if ( CurrentImage.hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( CurrentImage.hFile );
    }
    ZeroMemory( &CurrentImage, sizeof( CurrentImage ) );

Exit:

    SetLastError(UpdateSymbolsError);

    return(rc);
}


VOID
AdjImageBaseSize (
    PULONG pulImageBase,
    PULONG pulImageSize,
    BOOL   fGoingDown
    )
{

    DWORD Meg1, Meg2, Delta;

    //
    // ImageBase is the base for the current image. Make sure that
    // the image does not span a 256Mb boundry. This is due to an r4000
    // chip bug that has problems computing the correct address for absolute
    // jumps that occur in the last few instructions of a 256mb region
    //

    Meg1 = *pulImageBase >> x256MEGSHIFT;
    Meg2 = ( *pulImageBase + ROUND_UP( *pulImageSize, IMAGE_SEPARATION ) ) >> x256MEGSHIFT;

    if ( Meg1 != Meg2 ) {

        //
        // If we are going down, then subtract the overlap from ThisBase
        //

        if ( fGoingDown ) {

            Delta = ( *pulImageBase + ROUND_UP( *pulImageSize, IMAGE_SEPARATION ) ) -
                    ( Meg2 << x256MEGSHIFT );
            Delta += IMAGE_SEPARATION;
            *pulImageBase = *pulImageBase - Delta;
            *pulImageSize += Delta;
            }
        else {
            Delta = ( Meg2 << x256MEGSHIFT ) - *pulImageBase;
            *pulImageBase += Delta;
            *pulImageSize += Delta;
            }
        }
}

BOOL
RelocateImage(
    PLOADED_IMAGE LoadedImage,
    ULONG64 NewBase,
    ULONG64 *Diff,
    ULONG tstamp
    )
{
    ULONG_PTR VA;
    ULONG64 OldBase;
    ULONG SizeOfBlock;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;
    ULONG CheckSum;
    ULONG HeaderSum;
    PIMAGE_FILE_HEADER FileHeader;
    BOOL rc = TRUE;
    ULONG TotalCountBytes = 0;

    static BOOL  fInit = FALSE;

    if (!fInit) {

        RelocRoutineNative = (LPRELOCATE_ROUTINE)GetProcAddress(GetModuleHandle("ntdll"), "LdrProcessRelocationBlock");

#ifdef _WIN64
        RelocRoutine64 = RelocRoutineNative;
#else
        RelocRoutine64 = xxLdrProcessRelocationBlock64;
#endif
    }

    __try {
        if (LoadedImage->FileHeader->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) {
            // Relocations stripped.  Nothing to do.
            __leave;
        }

        NtHeaders = LoadedImage->FileHeader;
        FileHeader = &NtHeaders->FileHeader;
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            OldBase = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase;
        } else {
            OldBase = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase;
        }

        //
        // Locate the relocation section.
        //

        NextBlock = (PIMAGE_BASE_RELOCATION)ImageDirectoryEntryToData(
                                                LoadedImage->MappedAddress,
                                                FALSE,
                                                IMAGE_DIRECTORY_ENTRY_BASERELOC,
                                                &TotalCountBytes
                                                );

        *Diff = NewBase - OldBase;

        //
        // If the image has a relocation table, then apply the specified fixup
        // information to the image.
        //

        while (TotalCountBytes) {
            SizeOfBlock = NextBlock->SizeOfBlock;
            TotalCountBytes -= SizeOfBlock;
            SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
            SizeOfBlock /= sizeof(USHORT);
            NextOffset = (PUSHORT)(NextBlock + 1);

            //
            // Compute the address and value for the fixup.
            //

            if ( SizeOfBlock ) {
                VA = (ULONG_PTR)RvaToVa(NextBlock->VirtualAddress,LoadedImage);
                if ( !VA ) {
                    NtHeaders->Signature = (ULONG)-1;
                    rc = FALSE;
                    __leave;
                    }

                if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                    if ( !(NextBlock = (RelocRoutine64)(VA,SizeOfBlock,NextOffset,*Diff)) ) {
                        NtHeaders->Signature = (ULONG)-1;
                        rc = FALSE;
                        __leave;
                    }
                } else {
                    if ( !(NextBlock = (RelocRoutineNative)(VA,SizeOfBlock,NextOffset,(LONG_PTR)*Diff)) ) {
                        NtHeaders->Signature = (ULONG)-1;
                        rc = FALSE;
                        __leave;
                        }
                    }
                }
            else {
                NextBlock++;
                }
            }

        if (tstamp) {
            FileHeader->TimeDateStamp = tstamp;
        } else {
            FileHeader->TimeDateStamp++;
        }

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase = (ULONG)NewBase;
            if ( LoadedImage->hFile != INVALID_HANDLE_VALUE ) {

                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum = 0;

                CheckSumMappedFile(
                            (PVOID)LoadedImage->MappedAddress,
                            GetFileSize(LoadedImage->hFile, NULL),
                            &HeaderSum,
                            &CheckSum
                            );
                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
            }
        } else {
            ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase = NewBase;
            if ( LoadedImage->hFile != INVALID_HANDLE_VALUE ) {
                ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum = 0;

                CheckSumMappedFile(
                            (PVOID)LoadedImage->MappedAddress,
                            GetFileSize(LoadedImage->hFile, NULL),
                            &HeaderSum,
                            &CheckSum
                            );

                ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
            }
        }

        FlushViewOfFile(LoadedImage->MappedAddress,0);
        TouchFileTimes(LoadedImage->hFile,NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = FALSE;
    }

    return rc;
}


PVOID
RvaToVa(
    ULONG Rva,
    PLOADED_IMAGE Image
    )
{

    PIMAGE_SECTION_HEADER Section;
    ULONG i;
    PVOID Va;

    Va = NULL;
    Section = Image->LastRvaSection;
    if (Rva == 0) {
        // a NULL Rva will be sent if there are relocs before the first page
        //  (ie: we're relocating a system image)

        Va = Image->MappedAddress;

    } else {
        if ( Rva >= Section->VirtualAddress &&
             Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
            Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
        } else {
            for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
                if ( Rva >= Section->VirtualAddress &&
                     Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
                    Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
                    Image->LastRvaSection = Section;
                    break;
                }
            }
        }
    }

    return Va;
}

#ifndef STANDALONE_REBASE
// Dummy stub so the rebase.exe that shipped with VC5/VC6 will load.
VOID
RemoveRelocations(
    PCHAR ImageName
    )
{
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\rebase.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rebase.c

Abstract:

    Source file for the REBASE utility that takes a group of image files and
    rebases them so they are packed as closely together in the virtual address
    space as possible.

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

--*/

#include <private.h>

#define STANDALONE_REBASE
#include <rebasei.c>
#include <strsafe.h>

#define ROUNDUP(x, y) ((x + (y-1)) & ~(y-1))

VOID
RemoveRelocations(
    PCHAR ImageName
    );


#define REBASE_ERR 99
#define REBASE_OK  0
ULONG ReturnCode = REBASE_OK;

#define ROUND_UP( Size, Amount ) (((ULONG)(Size) + ((Amount) - 1)) & ~((Amount) - 1))

BOOL fVerbose;
BOOL fQuiet;
BOOL fGoingDown;
BOOL fSumOnly;
BOOL fRebaseSysfileOk;
BOOL fShowAllBases;
BOOL fCoffBaseIncExt;
FILE *CoffBaseDotTxt;
FILE *BaseAddrFile;
FILE *RebaseLog;
ULONG SplitFlags;
BOOL fRemoveRelocs;
BOOL fUpdateSymbolsOnly;

LPSTR BaseAddrFileName;

BOOL
ProcessGroupList(
    LPSTR ImagesRoot,
    LPSTR GroupListFName,
    BOOL  fReBase,
    BOOL  fOverlay
    );

BOOL
FindInIgnoreList(
    LPSTR chName
    );

ULONG64
FindInBaseAddrFile(
    LPSTR Name,
    PULONG pulSize
    );

VOID
ReBaseFile(
    LPSTR pstrName,
    BOOL  fReBase
    );

VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    );


VOID
ShowUsage(
    VOID
    );

typedef struct _GROUPNODE {
    struct _GROUPNODE *pgnNext;
    PCHAR chName;
} GROUPNODE, *PGROUPNODE;

PGROUPNODE pgnIgnoreListHdr, pgnIgnoreListEnd;

typedef BOOL (__stdcall *REBASEIMAGE64) (
    IN     PSTR CurrentImageName,
    IN     PSTR SymbolPath,
    IN     BOOL  fReBase,          // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk, // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,       // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,   // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,    // Returned from the header
    OUT    ULONG64 *OldImageBase,  // Returned from the header
    OUT    ULONG *NewImageSize,    // Image size rounded to next separation boundary
    IN OUT ULONG64 *NewImageBase,  // (in) Desired new address.
                                   // (out) Next address (actual if going down)
    IN     ULONG TimeStamp         // new timestamp for image, if non-zero
    );

REBASEIMAGE64 pReBaseImage64;

UCHAR ImagesRoot[ MAX_PATH+1 ];
PCHAR SymbolPath;
UCHAR DebugFilePath[ MAX_PATH+1 ];

ULONG64 OriginalImageBase;
ULONG OriginalImageSize;
ULONG64 NewImageBase;
ULONG NewImageSize;

ULONG64 InitialBase = 0;
ULONG64 MinBase = (~((ULONG64)0));
ULONG64 TotalSize;

ULONG SizeAdjustment;


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    char chChar, *pchChar;
    envp;
    _tzset();

    pgnIgnoreListHdr = (PGROUPNODE) malloc( sizeof ( GROUPNODE ) );
    if (!pgnIgnoreListHdr)
        return REBASE_ERR;

    pgnIgnoreListHdr->chName = NULL;
    pgnIgnoreListHdr->pgnNext = NULL;
    pgnIgnoreListEnd = pgnIgnoreListHdr;

#ifdef STANDALONE_REBASE
    pReBaseImage64 = ReBaseImage64;
#else
    pReBaseImage64 = (REBASEIMAGE64) GetProcAddress(GetModuleHandle("imagehlp.dll"), "ReBaseImage64");
    if (!pReBaseImage64) {
        puts("REBASE: Warning\n"
             "REBASE: Warning - unable to correctly rebase 64-bit images - update your imagehlp.dll\n"
             "REBASE: Warning");
        pReBaseImage64 = (REBASEIMAGE64) GetProcAddress(GetModuleHandle("imagehlp.dll"), "ReBaseImage");
    }
#endif
    fVerbose = FALSE;
    fQuiet = FALSE;
    fGoingDown = FALSE;
    fSumOnly = FALSE;
    fRebaseSysfileOk = FALSE;
    fShowAllBases = FALSE;

    ImagesRoot[ 0 ] = '\0';

    if (argc <= 1) {
        ShowUsage();
        }

    while (--argc) {
        pchChar = *++argv;
        if (*pchChar == '/' || *pchChar == '-') {
            while (chChar = *++pchChar) {
                ParseSwitch( chChar, &argc, &argv );
                }
            }
        else {
            if (*pchChar == '@') {
                // Inline response file with a list of files to rebase.
                FILE *hFiles;
                int ScanRet;
                CHAR pchFileName[_MAX_PATH];
                BOOL JustFileNames=TRUE;

                pchChar++;

                if (*pchChar == '@') {
                    JustFileNames=FALSE;
                    pchChar++;
                }
                hFiles=fopen(pchChar, "rt");
                if (hFiles == NULL) {
                    fprintf( stderr, "REBASE: fopen %s failed %d\n", pchChar, errno );
                    ExitProcess( REBASE_ERR );
                }

                if (JustFileNames) {
                    ScanRet = fscanf( hFiles, "%s", pchFileName);
                    while (ScanRet && ScanRet != EOF) {
                        if ( !FindInIgnoreList( pchFileName ) ) {
                            ReBaseFile( pchFileName, TRUE );
                        }
                        ScanRet = fscanf( hFiles, "%s", pchFileName );
                    }
                } else {
                    ULONGLONG PreferedImageBase;
                    ULONG MaxImageSize;
                    fRebaseSysfileOk = TRUE;
                    ScanRet = fscanf( hFiles, "%I64x %x %s", &PreferedImageBase, &MaxImageSize, pchFileName);
                    while (ScanRet && ScanRet != EOF) {
                        if (!FindInIgnoreList(pchFileName) ){
                            InitialBase = NewImageBase = PreferedImageBase;
                            ReBaseFile( pchFileName, TRUE );
                            if ((NewImageSize != -1) && (NewImageSize > MaxImageSize)) {
                                fprintf( stderr, "REBASE: Image: %s baseed at: %I64x exceeded Max size: %x (real size is %x)\n", pchFileName, PreferedImageBase, MaxImageSize, NewImageSize);
                            }
                        }
                        ScanRet = fscanf( hFiles, "%I64x %x %s", &PreferedImageBase, &MaxImageSize, pchFileName );
                    }
                }
                fclose(hFiles);
            } else {
                if ( !FindInIgnoreList( pchChar ) ) {
                    ReBaseFile( pchChar, TRUE );
                    }
                }
            }
        }

    if ( !fQuiet ) {

        if ( BaseAddrFile ) {
            InitialBase = MinBase;
        }

        if ( fGoingDown ) {
            TotalSize = InitialBase - NewImageBase;
        }
        else {
            TotalSize = NewImageBase - InitialBase;
        }

        fprintf( stdout, "\n" );
        fprintf( stdout, "REBASE: Total Size of mapping 0x%016I64x\n", TotalSize );
        fprintf( stdout, "REBASE: Range 0x%016I64x -0x%016I64x\n",
                 min(NewImageBase, InitialBase), max(NewImageBase, InitialBase));

        if (RebaseLog) {
            fprintf( RebaseLog, "\nTotal Size of mapping 0x%016I64x\n", TotalSize );
            fprintf( RebaseLog, "Range 0x%016I64x -0x%016I64x\n\n",
                     min(NewImageBase, InitialBase), max(NewImageBase, InitialBase));
        }
    }

    if (RebaseLog) {
        fclose(RebaseLog);
        }

    if (BaseAddrFile){
        fclose(BaseAddrFile);
        }

    if (CoffBaseDotTxt){
        fclose(CoffBaseDotTxt);
        }

    return ReturnCode;
}


VOID
ShowUsage(
    VOID
    )
{
    fputs( "usage: REBASE [switches]\n"
           "              [-R image-root [-G filename] [-O filename] [-N filename]]\n"
           "              image-names... \n"
           "\n"
           "              One of -b and -i switches are mandatory.\n"
           "\n"
           "              [-a] Does nothing\n"
           "              [-b InitialBase] specify initial base address\n"
           "              [-c coffbase_filename] generate coffbase.txt\n"
           "                  -C includes filename extensions, -c does not\n"
           "              [-d] top down rebase\n"
           "              [-e SizeAdjustment] specify extra size to allow for image growth\n"
           "              [-f] Strip relocs after rebasing the image\n"
           "              [-i coffbase_filename] get base addresses from coffbase_filename\n"
           "              [-l logFilePath] write image bases to log file.\n"
           "              [-p] Does nothing\n"
           "              [-q] minimal output\n"
           "              [-s] just sum image range\n"
           "              [-u symbol_dir] Update debug info in .DBG along this path\n"
           "              [-v] verbose output\n"
           "              [-x symbol_dir] Same as -u\n"
           "              [-z] allow system file rebasing\n"
           "              [-?] display this message\n"
           "\n"
           "              [-R image_root] set image root for use by -G, -O, -N\n"
           "              [-G filename] group images together in address space\n"
           "              [-O filename] overlay images in address space\n"
           "              [-N filename] leave images at their origional address\n"
           "                  -G, -O, -N, may occur multiple times.  File \"filename\"\n"
           "                  contains a list of files (relative to \"image-root\")\n"
           "\n"
           "              'image-names' can be either a file (foo.dll) or files (*.dll)\n"
           "                            or a file that lists other files (@files.txt).\n"
           "                            If you want to rebase to a fixed address (ala QFE)\n"
           "                            use the @@files.txt format where files.txt contains\n"
           "                            address/size combos in addition to the filename\n",
           stderr );

    exit( REBASE_ERR );
}


VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    )
{

    switch (toupper( chSwitch )) {

        case '?':
            ShowUsage();
            break;

        case 'A':
            break;

        case 'B':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            if (sscanf(**pArgv, "%I64x", &InitialBase) == 1) {
                NewImageBase = InitialBase;
            }
            break;

        case 'C':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            fCoffBaseIncExt = (chSwitch == 'C');
            CoffBaseDotTxt = fopen( *(*pArgv), "at" );
            if ( !CoffBaseDotTxt ) {
                fprintf( stderr, "REBASE: fopen %s failed %d\n", *(*pArgv), errno );
                ExitProcess( REBASE_ERR );
                }
            break;

        case 'D':
            fGoingDown = TRUE;
            break;

        case 'E':
            if (!--(*pArgc)) {
                ShowUsage();
            }
            (*pArgv)++;
            if (sscanf(**pArgv, "%x", &SizeAdjustment) != 1) {
                ShowUsage();
            }
            break;

        case 'F':
            fRemoveRelocs = TRUE;
            break;

        case 'G':
        case 'O':
        case 'N':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            if (!ImagesRoot[0]) {
                fprintf( stderr, "REBASE: -R must preceed -%c\n", chSwitch );
                exit( REBASE_ERR );
                }
            ProcessGroupList( (PCHAR) ImagesRoot,
                              *(*pArgv),
                              toupper(chSwitch) != 'N',
                              toupper(chSwitch) == 'O');
            break;

        case 'I':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            BaseAddrFileName = *(*pArgv);
            BaseAddrFile = fopen( *(*pArgv), "rt" );
            if ( !BaseAddrFile ) {
                fprintf( stderr, "REBASE: fopen %s failed %d\n", *(*pArgv), errno );
                ExitProcess( REBASE_ERR );
                }
            break;

        case 'L':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            RebaseLog = fopen( *(*pArgv), "at" );
            if ( !RebaseLog ) {
                fprintf( stderr, "REBASE: fopen %s failed %d\n", *(*pArgv), errno );
                ExitProcess( REBASE_ERR );
                }
            break;

        case 'P':
            break;

        case 'Q':
            fQuiet = TRUE;
            break;

        case 'R':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            StringCchCopy((PCHAR)ImagesRoot, MAX_PATH, *(*pArgv) );
            break;

        case 'S':
            fprintf(stdout,"\n");
            fSumOnly = TRUE;
            break;

        case 'U':
        case 'X':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            fUpdateSymbolsOnly = TRUE;
            SymbolPath = **pArgv;
            break;

        case 'V':
            fVerbose = TRUE;
            break;

        case 'Z':
            fRebaseSysfileOk = TRUE;
            break;

        default:
            fprintf( stderr, "REBASE: Invalid switch - /%c\n", chSwitch );
            ShowUsage();
            break;

        }
}


BOOL
ProcessGroupList(
    LPSTR ImagesRoot,
    LPSTR GroupListFName,
    BOOL  fReBase,
    BOOL  fOverlay
    )
{
    PGROUPNODE pgn;
    FILE *GroupList;

    CHAR  chName[MAX_PATH+1];
    int   ateof;
    ULONG64 SavedImageBase;
    ULONG MaxImageSize=0;

    DWORD dw;
    CHAR  Buffer[ MAX_PATH+1 ];
    LPSTR FilePart;

    if (RebaseLog) {
        fprintf( RebaseLog, "*** %s\n", GroupListFName );
    }

    GroupList = fopen( GroupListFName, "rt" );
    if ( !GroupList ) {
        fprintf( stderr, "REBASE: fopen %s failed %d\n", GroupListFName, errno );
        ExitProcess( REBASE_ERR );
    }

    ateof = fscanf( GroupList, "%s", chName );

    SavedImageBase = NewImageBase;

    while ( ateof && ateof != EOF ) {

        dw = SearchPath( ImagesRoot, chName, NULL, sizeof(Buffer), Buffer, &FilePart );
        if ( dw == 0 || dw > sizeof( Buffer ) ) {
            if (!fQuiet) {
                fprintf( stderr, "REBASE: Could Not Find %s\\%s\n", ImagesRoot, chName );
            }
        }
        else {

            _strlwr( Buffer );  // Lowercase for consistency when displayed.

            if (fReBase) {
                if (!FindInIgnoreList(Buffer)) {
                    // If the file hasn't already been listed in another group (either to ignore
                    // or to group/overlay somewhere else), rebase it.
                    ReBaseFile( Buffer, TRUE );
                }

                if ( fOverlay ) {
                    if ( MaxImageSize < NewImageSize ) {
                        MaxImageSize = NewImageSize;
                    }
                    NewImageBase = SavedImageBase;
                }
            }
    
            pgn = (PGROUPNODE) malloc( sizeof( GROUPNODE ) );
            if ( NULL == pgn ) {
                fprintf( stderr, "REBASE: *** malloc failed.\n" );
                ExitProcess( REBASE_ERR );
            }
            pgn->chName = _strdup( Buffer );
            if ( NULL == pgn->chName ) {
                fprintf( stderr, "REBASE: *** strdup failed (%s).\n", Buffer );
                ExitProcess( REBASE_ERR );
            }
            pgn->pgnNext = NULL;
            pgnIgnoreListEnd->pgnNext = pgn;
            pgnIgnoreListEnd = pgn;
        }

        ateof = fscanf( GroupList, "%s", chName );
    }

    fclose( GroupList );

    if ( fOverlay ) {
        if ( fGoingDown ) {
            NewImageBase -= ROUND_UP( MaxImageSize, IMAGE_SEPARATION );
        }
        else {
            NewImageBase += ROUND_UP( MaxImageSize, IMAGE_SEPARATION );
        }
    }

    if (RebaseLog) {
        fprintf( RebaseLog, "\n" );
    }

    return TRUE;
}


BOOL
FindInIgnoreList(
    LPSTR chName
    )
{
    PGROUPNODE pgn;

    DWORD dw;
    CHAR  Buffer[ MAX_PATH+1 ];
    LPSTR FilePart;


    dw = GetFullPathName( chName, sizeof(Buffer), Buffer, &FilePart );
    if ( dw == 0 || dw > sizeof( Buffer ) ) {
        fprintf( stderr, "REBASE: *** GetFullPathName failed (%s).\n", chName );
        ExitProcess( REBASE_ERR );
        }

    for (pgn = pgnIgnoreListHdr->pgnNext;
         pgn != NULL;
         pgn = pgn->pgnNext) {

        if (!_stricmp( Buffer, pgn->chName ) ) {
            return TRUE;
            }

        }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
/*
******************************************************************************
On a Hydra System, we don't want imaghlp.dll to load user32.dll since it
prevents CSRSS from exiting when running a under a debugger.
The following function has been copied from user32.dll so that we don't
link to user32.dll.
******************************************************************************
*/

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


VOID
ReBaseFile(
    LPSTR CurrentImageName,
    BOOL fReBase
    )
{
    DWORD dw;
    CHAR  Buffer[ MAX_PATH+1 ];
    CHAR  Buffer2[ MAX_PATH+1 ];
    LPSTR FilePart = NULL;
    LPSTR LocalSymbolPath;
    ULONG ThisImageExpectedSize = 0;
    ULONG64 ThisImageRequestedBase = NewImageBase;
    ULONG TimeStamp;
    static char LastName = '\0';
    static ULONG LastTimeStamp = 0;

    if ( !InitialBase && !BaseAddrFile ) {
        fprintf( stderr, "REBASE: -b switch must specify a non-zero base  --or--\n" );
        fprintf( stderr, "        -i must specify a filename\n" );
        exit( REBASE_ERR );
        }

    if ( BaseAddrFile && ( InitialBase || fGoingDown || CoffBaseDotTxt ) ) {
        fprintf( stderr, "REBASE: -i is incompatible with -b, -d, and -c\n" );
        exit( REBASE_ERR );
    }

    dw = GetFullPathName( CurrentImageName, sizeof(Buffer), Buffer, &FilePart );
    if ( dw == 0 || dw > sizeof(Buffer) || !FilePart ) {
        FilePart = CurrentImageName;
    }
    _strlwr( FilePart );  // Lowercase for consistency when displayed.

    if ( BaseAddrFile && !(NewImageBase = ThisImageRequestedBase = FindInBaseAddrFile( FilePart, &ThisImageExpectedSize )) ) {
        fprintf( stdout, "REBASE: %-16s Not listed in %s\n", FilePart, BaseAddrFileName );
    }

    if (fUpdateSymbolsOnly) {
        // On update, the symbol path is a semi-colon delimited path.  Find the one we want and
        // then fix the path for RebaseImage.
        HANDLE hDebugFile;
        CHAR Drive[_MAX_DRIVE];
        CHAR Dir[_MAX_DIR];
        PCHAR s;
        hDebugFile = FindDebugInfoFile(CurrentImageName, SymbolPath, DebugFilePath);
        if ( hDebugFile ) {
            CloseHandle(hDebugFile);
            _splitpath(DebugFilePath, Drive, Dir, NULL, NULL);
            _makepath(Buffer2, Drive, Dir, NULL, NULL);
            s = Buffer2 + strlen(Buffer2);
            s = CharPrev(Buffer2, s);
            if (*s == '\\') {
                *s = '\0';
            }
            LocalSymbolPath = Buffer2;
        } else {
            LocalSymbolPath = NULL;
        }
    } else {
        LocalSymbolPath = SymbolPath;
    }

    NewImageSize = (ULONG) -1;  // Hack so we can tell when system images are skipped.

    time( (time_t *) &TimeStamp );

    // Ensure all images with the same first letter have unique timestamps.

    if (!LastTimeStamp)
        LastTimeStamp = TimeStamp;

    if (LastName ==  *FilePart) {
        TimeStamp = LastTimeStamp++;
    } else {
        LastTimeStamp = TimeStamp;
        LastName = *FilePart;
    }

    if (SizeAdjustment && fGoingDown && !fSumOnly && fReBase) {
        if ((*pReBaseImage64)( CurrentImageName,
                          (PCHAR) LocalSymbolPath,
                          FALSE,
                          fRebaseSysfileOk,
                          TRUE,
                          ThisImageExpectedSize,
                          &OriginalImageSize,
                          &OriginalImageBase,
                          &NewImageSize,
                          &ThisImageRequestedBase,
                          TimeStamp ) ) {

            if (NewImageSize != (ULONG) -1) {
                if ((OriginalImageSize + SizeAdjustment) > NewImageSize) {
                    // If we were to add SizeAdjustment to the image (say as a ServicePack or QFE fix), we'd blow
                    // out our space.  Make room so this isn't necessary.
                    NewImageBase -= IMAGE_SEPARATION;
                    ThisImageRequestedBase = NewImageBase;
                }
            }
        }
    }

    if (!(*pReBaseImage64)( CurrentImageName,
                      (PCHAR) LocalSymbolPath,
                      fReBase && !fSumOnly,
                      fRebaseSysfileOk,
                      fGoingDown,
                      ThisImageExpectedSize,
                      &OriginalImageSize,
                      &OriginalImageBase,
                      &NewImageSize,
                      &ThisImageRequestedBase,
                      TimeStamp ) ) {

        if (ThisImageRequestedBase == 0) {
            fprintf(stderr,
                    "REBASE: %-16s ***Grew too large (Size=0x%x; ExpectedSize=0x%x)\n",
                    FilePart,
                    OriginalImageSize,
                    ThisImageExpectedSize);
        } else {
            switch(GetLastError()) {
                case ERROR_BAD_EXE_FORMAT:
                    if (fVerbose) {
                        fprintf( stderr,
                                "REBASE: %-16s DOS or OS/2 image ignored\n",
                                FilePart );
                    }
                    break;

                case ERROR_INVALID_ADDRESS:
                    fprintf( stderr,
                            "REBASE: %-16s Rebase failed.  Relocations are missing or new address is invalid\n",
                            FilePart );
                    if (RebaseLog) {
                        fprintf( RebaseLog,
                                 "%16s based at 0x%016I64x (size 0x%08x)  Unable to rebase. (missing relocations or new address is invalid)\n",
                                 FilePart,
                                 OriginalImageBase,
                                 OriginalImageSize);
                    }
                    break;

                case ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY:
                    if (fVerbose) {
                        fprintf( stderr,
                                "REBASE: %-16s Rebase failed.  Signed images can not be rebased.\n",
                                FilePart );
                    }
                    break;

                case ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY:
                    if (fVerbose) {
                        fprintf( stderr,
                                "REBASE: %-16s Rebase failed.  Strong signed images can not be rebased.\n",
                                FilePart );
                    }
                    break;

                default:
                    fprintf( stderr,
                            "REBASE: *** RelocateImage failed (%s).  Image may be corrupted\n",
                            FilePart );
                    break;
            }
        }

        ReturnCode = REBASE_ERR;
        return;

    } else {
        if (GetLastError() == ERROR_INVALID_DATA) {
            fprintf(stderr, "REBASE: Warning: DBG checksum did not match image.\n");
        }
    }

    // Keep track of the lowest base address.

    if (MinBase > NewImageBase) {
        MinBase = NewImageBase;
    }

    if ( fSumOnly || !fReBase ) {
        if (!fQuiet) {
            fprintf( stdout,
                     "REBASE: %16s mapped at %016I64x (size 0x%08x)\n",
                     FilePart,
                     OriginalImageBase,
                     OriginalImageSize);
        }
    } else {
        if (!fGoingDown && SizeAdjustment && (NewImageSize != (ULONG) -1)) {
            if ((OriginalImageSize + SizeAdjustment) > NewImageSize) {
                // If we were to add SizeAdjustment to the image (say as a ServicePack or QFE fix), we'd blow
                // out our space.  Make room so this isn't necessary.
                ThisImageRequestedBase += IMAGE_SEPARATION;
            }
        }
    
        if (RebaseLog) {
            fprintf( RebaseLog,
                     "%16s rebased to 0x%016I64x (size 0x%08x)\n",
                     FilePart,
                     fGoingDown ? ThisImageRequestedBase : NewImageBase,
                     NewImageSize);
        }

        if ((NewImageSize != (ULONG) -1) &&
            (OriginalImageBase != (fGoingDown ? ThisImageRequestedBase : NewImageBase)) &&
            ( fVerbose || fQuiet )
           ) {
            if ( fVerbose ) {
                fprintf( stdout,
                         "REBASE: %16s initial base at 0x%016I64x (size 0x%08x)\n",
                         FilePart,
                         OriginalImageBase,
                         OriginalImageSize);
            }

            fprintf( stdout,
                     "REBASE: %16s rebased to 0x%016I64x (size 0x%08x)\n",
                     FilePart,
                     fGoingDown ? ThisImageRequestedBase : NewImageBase,
                     NewImageSize);

            if ( fVerbose && fUpdateSymbolsOnly && DebugFilePath[0]) {
                char szExt[_MAX_EXT];
                _splitpath(DebugFilePath, NULL, NULL, NULL, szExt);
                if (_stricmp(szExt, ".pdb")) {
                    fprintf( stdout, "REBASE: %16s updated image base in %s\n", FilePart, DebugFilePath );
                }
            }
        }

        if (fRemoveRelocs) {
            RemoveRelocations(CurrentImageName);
        }
    }

    if ( CoffBaseDotTxt ) {
        if ( !fCoffBaseIncExt ) {
            char *n;
            if ( n  = strrchr(FilePart,'.') ) {
                *n = '\0';
            }
        }

        fprintf( CoffBaseDotTxt,
                 "%-16s 0x%016I64x 0x%08x\n",
                 FilePart,
                 fSumOnly ? OriginalImageBase : (fGoingDown ? ThisImageRequestedBase : NewImageBase),
                 NewImageSize);
    }

    NewImageBase = ThisImageRequestedBase;   // Set up the next one...
}

ULONG64
FindInBaseAddrFile(
    LPSTR Name,
    PULONG pulSize
    )
{

    struct {
        CHAR  Name[MAX_PATH+1];
        ULONG64 Base;
        ULONG Size;
    } BAFileEntry;

    CHAR NameNoExt[MAX_PATH+1];
//    PCHAR pchExt;
    int ateof;


    StringCchCopy(NameNoExt, MAX_PATH, Name);
//    if (pchExt = strrchr(NameNoExt,'.')) {
//        *pchExt = '\0';
//        }

    if (fseek(BaseAddrFile, 0, SEEK_SET)) {
        return 0;
    }

    ateof = fscanf(BaseAddrFile,"%s %I64x %x",BAFileEntry.Name,&BAFileEntry.Base,&BAFileEntry.Size);
    while ( ateof && ateof != EOF ) {
        if ( !_stricmp(NameNoExt,BAFileEntry.Name) ) {
            *pulSize = BAFileEntry.Size;
            return BAFileEntry.Base;
            }
        ateof = fscanf(BaseAddrFile,"%s %I64x %x",BAFileEntry.Name,&BAFileEntry.Base,&BAFileEntry.Size);
        }

    *pulSize = 0;
    return 0;
}

VOID
RemoveRelocations(
    PCHAR ImageName
    )
{
    // UnSafe...

    LOADED_IMAGE li;
    IMAGE_SECTION_HEADER RelocSectionHdr, *Section, *pRelocSecHdr;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    ULONG DebugDirectorySize, i, RelocSecNum;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    if (!MapAndLoad(ImageName, NULL, &li, FALSE, FALSE)) {
        return;
    }

    FileHeader = &li.FileHeader->FileHeader;

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)li.FileHeader, &OptionalHeader32, &OptionalHeader64);
    if (!OptionalHeader32 && !OptionalHeader64)
        return;

    // See if the image has already been stripped or there are no relocs.

    if ((FileHeader->Characteristics & IMAGE_FILE_RELOCS_STRIPPED) ||
        (!OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size))) {
        UnMapAndLoad(&li);
        return;
    }

    for (Section = li.Sections, i = 0; i < li.NumberOfSections; Section++, i++) {
        if (Section->PointerToRawData != 0) {
            if (!_stricmp( (char *) Section->Name, ".reloc" )) {
                RelocSectionHdr = *Section;
                pRelocSecHdr = Section;
                RelocSecNum = i + 1;
            }
        }
    }

    RelocSectionHdr.Misc.VirtualSize = ROUNDUP(RelocSectionHdr.Misc.VirtualSize, OPTIONALHEADER(SectionAlignment));
    RelocSectionHdr.SizeOfRawData = ROUNDUP(RelocSectionHdr.SizeOfRawData, OPTIONALHEADER(FileAlignment));

    if (RelocSecNum != li.NumberOfSections) {
        // Move everything else up and fixup old addresses.
        for (i = RelocSecNum - 1, Section = pRelocSecHdr;i < li.NumberOfSections - 1; Section++, i++) {
            *Section = *(Section + 1);
            Section->VirtualAddress -= RelocSectionHdr.Misc.VirtualSize;
            Section->PointerToRawData -= RelocSectionHdr.SizeOfRawData;
        }
    }

    // Zero out the last one.

    RtlZeroMemory(Section, sizeof(IMAGE_SECTION_HEADER));

    // Reduce the section count.

    FileHeader->NumberOfSections--;

    // Set the strip bit in the header

    FileHeader->Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;

    // If there's a pointer to the coff symbol table, move it back.

    if (FileHeader->PointerToSymbolTable) {
        FileHeader->PointerToSymbolTable -= RelocSectionHdr.SizeOfRawData;
    }

    // Clear out the base reloc entry in the data dir.

    OPTIONALHEADER_LV(DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) = 0;
    OPTIONALHEADER_LV(DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress) = 0;

    // Reduce the Init Data size.

    OPTIONALHEADER_LV(SizeOfInitializedData) -= RelocSectionHdr.Misc.VirtualSize;

    // Reduce the image size.

    OPTIONALHEADER_LV(SizeOfImage) -=
        ((RelocSectionHdr.SizeOfRawData +
          (OPTIONALHEADER(SectionAlignment) - 1)
         ) & ~(OPTIONALHEADER(SectionAlignment) - 1));

    // Move the debug info up (if there is any).

    DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
                            ImageDirectoryEntryToData( li.MappedAddress,
                                                      FALSE,
                                                      IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                      &DebugDirectorySize
                                                    );
    if (DebugDirectoryIsUseful(DebugDirectory, DebugDirectorySize)) {
        for (i = 0; i < (DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY)); i++) {
            RtlMoveMemory(li.MappedAddress + DebugDirectory->PointerToRawData - RelocSectionHdr.SizeOfRawData,
                            li.MappedAddress + DebugDirectory->PointerToRawData,
                            DebugDirectory->SizeOfData);

            DebugDirectory->PointerToRawData -= RelocSectionHdr.SizeOfRawData;

            if (DebugDirectory->AddressOfRawData) {
                DebugDirectory->AddressOfRawData -= RelocSectionHdr.Misc.VirtualSize;
            }

            DebugDirectory++;
        }
    }

    // Truncate the image size

    li.SizeOfImage -= RelocSectionHdr.SizeOfRawData;

    // And we're done.

    UnMapAndLoad(&li);
}

#define STANDALONE_MAP
#include <mapi.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\private.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    imagehlp.h

Abstract:

    This is a private header file for imagehlp.

Revision History:

--*/

#ifndef _IMAGEHLP_PRV_
#define _IMAGEHLP_PRV_

#define _IMAGEHLP_SOURCE_
#define _IA64REG_
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <time.h>
#include <ctype.h>
#include <memory.h>
#include <malloc.h>
#include <dbgeng.h>
#if DBG
// disable the -DNDEBUG set by oak\bin\makefile.def
#undef NDEBUG
#endif // DBG
#include <assert.h>
#include <string.h>
#include <time.h>
#include <ntverp.h>
#include <cvexefmt.h>
#define PDB_LIBRARY
#include <pdb.h>
#include "pdbp.h"
#include "util.h"
#include "srcsrv.h"
#include "dbgimage.h"

#ifdef __cplusplus
extern "C" {
#endif

// used for delayloading the pdb handler

#define REGKEY_DBGHELP    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\dbgHelp"
#define REGVAL_PDBHANDLER "PDBHandler"

// define the module

#ifdef BUILD_DBGHELP
 #define MOD_FILENAME "dbghelp.dll"
 #define MOD_NAME     "dbghelp"
#else
 #define MOD_FILENAME "imagehlp.dll"
 #define MOD_NAME     "imagehlp"
#endif

#ifndef DIMA
 #define DIMAT(Array, EltType) (sizeof(Array) / sizeof(EltType))
 #define DIMA(Array) DIMAT(Array, (Array)[0])
#endif

/******************************************************************************
On a Hydra System, we don't want imaghlp.dll to load user32.dll since it
prevents CSRSS from exiting when running a under a debugger.
The following two functions have been copied from user32.dll so that we don't
link to user32.dll.
******************************************************************************/
#undef CharNext
#undef CharPrev

LPSTR CharNext(
    LPCSTR lpCurrentChar);

LPSTR CharPrev(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar);


// Define some list prototypes

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
// some helpers for PE32/PE64 issues
//

#define OPTIONALHEADER(field) (OptionalHeader32 ? (OptionalHeader32->field) : (OptionalHeader64 ? OptionalHeader64->field : 0))
#define OPTIONALHEADER_LV(field) (*(OptionalHeader32 ? &(OptionalHeader32->field) : &(OptionalHeader64->field)))
#define OPTIONALHEADER_ASSIGN(field,value) (OptionalHeader32 ? (OptionalHeader32->field=(value)) : (OptionalHeader64->field=(value)))
#define OPTIONALHEADER_SET_FLAG(field,flag) (OptionalHeader32 ? (OptionalHeader32->field |=(flag)) : (OptionalHeader64->field|=(flag)))
#define OPTIONALHEADER_CLEAR_FLAG(field,flag) (OptionalHeader32 ? (OptionalHeader32->field &=(~flag)) : (OptionalHeader64->field&=(~flag)))


// IA64 unwind specific structures
#define VWNDIA64_FIXUP_TABLE_SIZE           5
#define VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE  5

typedef struct _VWNDIA64_FUXUP_REGION {
    ULONGLONG Ip;
    ULONGLONG Begin;
    ULONGLONG End;
    ULONGLONG Fixup;
} VWNDIA64_FUXUP_REGION, *PVWNDIA64_FUXUP_REGION;

typedef struct _VWNDIA64_UNWIND_CONTEXT {
    BOOL bFailureReported;
    VWNDIA64_FUXUP_REGION FixupTable[VWNDIA64_FIXUP_TABLE_SIZE];
} VWNDIA64_UNWIND_CONTEXT, *PVWNDIA64_UNWIND_CONTEXT;

// stackwalk operation flags

#define WALK_FIX_FPO_EBP    0x1

__inline
void
OptionalHeadersFromNtHeaders(
    PIMAGE_NT_HEADERS32 NtHeaders,
    PIMAGE_OPTIONAL_HEADER32 *OptionalHeader32,
    PIMAGE_OPTIONAL_HEADER64 *OptionalHeader64
    )
{
    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        if ( OptionalHeader32 )   {
            *OptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)&NtHeaders->OptionalHeader;
        }
        if ( OptionalHeader64 )  {
            *OptionalHeader64 = NULL;
        }
    } else
    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        if ( OptionalHeader64 )    {
            *OptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)&NtHeaders->OptionalHeader;
        }
        if ( OptionalHeader32 )  {
            *OptionalHeader32 = NULL;
        }
    }
}

#define DebugDirectoryIsUseful(Pointer, Size) (    \
    (Pointer != NULL) &&                          \
    (Size >= sizeof(IMAGE_DEBUG_DIRECTORY)) &&    \
    ((Size % sizeof(IMAGE_DEBUG_DIRECTORY)) == 0) \
    )

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    IN  HANDLE                  hProcess,
    IN  LPSTR                   ModuleName,
    IN  LPSTR                   FileName,
    OUT PDWORD64                Buffer,
    IN  ULONG                   BufferLines
    );

BOOL
CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    );

typedef void * ( __cdecl * Alloc_t )( unsigned int );
typedef void   ( __cdecl * Free_t  )( void * );

typedef BOOL  (__stdcall *PGET_MODULE)(HANDLE,LPSTR,DWORD64,DWORD,PVOID);
typedef PCHAR (__cdecl *PUNDNAME)( char *, const char *, int, Alloc_t, Free_t, unsigned short);

#ifdef IMAGEHLP_HEAP_DEBUG

#define HEAP_SIG 0x69696969
typedef struct _HEAP_BLOCK {
    LIST_ENTRY  ListEntry;
    ULONG       Signature;
    ULONG_PTR   Size;
    ULONG       Line;
    CHAR        File[16];
} HEAP_BLOCK, *PHEAP_BLOCK;

#define MemAlloc(s)     pMemAlloc(s,__LINE__,__FILE__)
#define MemReAlloc(s,n) pMemReAlloc(s,n,__LINE__,__FILE__)
#define MemFree(p)      pMemFree(p,__LINE__,__FILE__)
#define CheckHeap(p)    pCheckHeap(p,__LINE__,__FILE__)
#define HeapDump(s)     pHeapDump(s,__LINE__,__FILE__)
#define MemSize(p)      pMemSize(p)
#define HeapInitList(p) InitializeListHead(p);
#else
#define MemAlloc(s)     pMemAlloc(s)
#define MemReAlloc(s,n) pMemReAlloc(s,n)
#define MemFree(p)      pMemFree(p)
#define CheckHeap(p)
#define HeapDump(s)
#define MemSize(p)      pMemSize(p)
#define HeapInitList(p)
#endif

#ifdef IMAGEHLP_HEAP_DEBUG
BOOL
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    );

BOOL
pHeapDump(
    LPSTR sz,
    ULONG line,
    LPSTR file
    );

VOID PrintAllocations(VOID);
#endif


PVOID
pMemAlloc(
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

PVOID
pMemReAlloc(
    PVOID OldAlloc,
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFree(
    PVOID MemPtr
#ifdef IMAGEHLP_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

ULONG_PTR
pMemSize(
    PVOID MemPtr
    );

#define MAP_READONLY  TRUE
#define MAP_READWRITE FALSE


BOOL
MapIt(
    HANDLE FileHandle,
    PLOADED_IMAGE LoadedImage,
    BOOL ReadOnly
    );

VOID
UnMapIt(
    PLOADED_IMAGE LoadedImage
    );

BOOL
GrowMap(
    PLOADED_IMAGE   LoadedImage,
    LONG            lSizeOfDelta
    );

DWORD
ImagepSetLastErrorFromStatus(
    IN DWORD Status
    );

BOOL
UnloadAllImages(
    void
    );

#define CALLBACK_STACK(f)      (f->KdHelp.ThCallbackStack)
#define CALLBACK_BSTORE(f)     (f->KdHelp.ThCallbackBStore)
#define CALLBACK_NEXT(f)       (f->KdHelp.NextCallback)
#define CALLBACK_FUNC(f)       (f->KdHelp.KiCallUserMode)
#define CALLBACK_THREAD(f)     (f->KdHelp.Thread)
#define CALLBACK_FP(f)         (f->KdHelp.FramePointer)
#define CALLBACK_DISPATCHER(f) (f->KdHelp.KeUserCallbackDispatcher)
#define SYSTEM_RANGE_START(f)  (f->KdHelp.SystemRangeStart)

// These modifications of the RF_ macros are required because of the need
// for an explicit ULONG64 result

#define ALPHA_RF_FIXED_RETURN64(RF) (((ULONG64)(RF)->ExceptionHandler) & (~3))
#define ALPHA_RF_ALT_PROLOG64(RF)   (((ULONG64)(RF)->ExceptionHandler) & (~3))

extern ULONG g_vc7fpo;

enum
{
    SDB_DEBUG_OUT,
    SDB_CALLBACK_OUT,
};

#define SDB_NO_PREFIX 0x80000000

extern ULONG g_StackDebugMask;
extern ULONG g_StackDebugIo;

void __cdecl
SdbOut(
    ULONG Mask,
    PSTR Format,
    ...
    );

BOOL
WalkX86(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress,
    DWORD                             flags
    );

BOOL
WalkIa64(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
WalkAlpha(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    BOOL                              Use64
    );

BOOL
WalkAmd64(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
WalkArm(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

void
ConvertAlphaRf32To64(
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY rf32,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY rf64
    );

void
SymParseArgs(
    LPCSTR args
    );

VOID
EnsureTrailingBackslash(
    LPSTR sz
    );

enum {
    dsNone = 0,
    dsInProc,
    dsImage,
    dsDbg,
    dsPdb,
    dsDia,
    dsCallerData,
    dsVirtual
};

typedef struct _OMAP {
    ULONG  rva;
    ULONG  rvaTo;
} OMAP, *POMAP;

typedef struct _OMAPLIST {
   struct _OMAPLIST *next;
   OMAP             omap;
   ULONG            cb;
} OMAPLIST, *POMAPLIST;

enum {
    mdHeader = 100,
    mdSecHdrs,
    mdNum
};

#define NUM_MODULE_DATA_ENTRIES 14

typedef BOOL (*PGETINFOPROC)(struct _IMGHLP_DEBUG_DATA *);

typedef struct _MODULE_DATA {
    DWORD        id;
    DWORD        hint;
    DWORD        src;
    BOOL         required;
    PGETINFOPROC fn;
} MODULE_DATA, *PMODULE_DATA;

BOOL
CopyPdb(
    CHAR const * SrcPdb,
    CHAR const * DestPdb,
    BOOL StripPrivate
    );

BOOL
IMAGEAPI
RemovePrivateCvSymbolic(
    PCHAR   DebugData,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    );

BOOL
IMAGEAPI
RemovePrivateCvSymbolicEx(
    PCHAR   DebugData,
    ULONG   DebugSize,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    );


#define NO_PE64_IMAGES  0x01000

#define IMGHLP_FREE_ALL     0xffffffff
#define IMGHLP_FREE_FPO     0x00000001
#define IMGHLP_FREE_PDATA   0x00000002
#define IMGHLP_FREE_OMAPT   0x00000004
#define IMGHLP_FREE_OMAPF   0x00000008
#define IMGHLP_FREE_PDB     0x00000010
#define IMGHLP_FREE_SYMPATH 0x00000020
#define IMGHLP_FREE_OSECT   0x00000040
#define IMGHLP_FREE_CSECT   0x00000080
#define IMGHLP_FREE_XDATA   0x00000100

#define IMGHLP_FREE_STANDARD (IMGHLP_FREE_FPO | IMGHLP_FREE_SYMPATH | IMGHLP_FREE_PDATA | IMGHLP_FREE_XDATA) //  | IMGHLP_FREE_OMAPT | IMGHLP_FREE_OMAPF)
#if DBG

VOID
__cdecl
dbPrint(
    LPCSTR fmt,
    ...
    );

#else

 #define dbPrint

#endif

__inline
BOOL
IsPE64(PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER) OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC ? TRUE : FALSE;
}

__inline
UCHAR *
OHMajorLinkerVersion(PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->MajorLinkerVersion);
}

__inline
UCHAR *
OHMinorLinkerVersion(PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->MinorLinkerVersion);
}

__inline
ULONG  *
OHSizeOfCode (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->SizeOfCode);
}

__inline
ULONG  *
OHSizeOfInitializedData (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->SizeOfInitializedData);
}

__inline
ULONG  *
OHSizeOfUninitializedData (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->SizeOfUninitializedData);
}

__inline
ULONG  *
OHAddressOfEntryPoint (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->AddressOfEntryPoint);
}

__inline
ULONG  *
OHBaseOfCode (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->BaseOfCode);
}

__inline
ULONG  *
OHImageBase (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->ImageBase) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->ImageBase);
}

__inline
ULONG  *
OHSectionAlignment (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SectionAlignment) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SectionAlignment);
}

__inline
ULONG  *
OHFileAlignment (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->FileAlignment) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->FileAlignment);
}

__inline
USHORT *
OHMajorOperatingSystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MajorOperatingSystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MajorOperatingSystemVersion);
}

__inline
USHORT *
OHMinorOperatingSystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MinorOperatingSystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MinorOperatingSystemVersion);
}

__inline
USHORT *
OHMajorImageVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MajorImageVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MajorImageVersion);
}

__inline
USHORT *
OHMinorImageVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MinorImageVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MinorImageVersion);
}

__inline
USHORT *
OHMajorSubsystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MajorSubsystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MajorSubsystemVersion);
}

__inline
USHORT *
OHMinorSubsystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MinorSubsystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MinorSubsystemVersion);
}

__inline
ULONG  *
OHWin32VersionValue (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->Win32VersionValue) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->Win32VersionValue);
}

__inline
ULONG  *
OHSizeOfImage (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfImage) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfImage);
}

__inline
ULONG  *
OHSizeOfHeaders (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfHeaders) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfHeaders);
}

__inline
ULONG  *
OHCheckSum (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->CheckSum) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->CheckSum);
}

__inline
USHORT *
OHSubsystem (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->Subsystem) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->Subsystem);
}

__inline
USHORT *
OHDllCharacteristics (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->DllCharacteristics) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->DllCharacteristics);
}

__inline
ULONG  *
OHSizeOfStackReserve (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfStackReserve) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfStackReserve);
}

__inline
ULONG  *
OHSizeOfStackCommit (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfStackCommit) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfStackCommit);
}

__inline
ULONG  *
OHSizeOfHeapReserve (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfHeapReserve) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfHeapReserve);
}

__inline
ULONG  *
OHSizeOfHeapCommit (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfHeapCommit) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfHeapCommit);
}

__inline
ULONG  *
OHLoaderFlags (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->LoaderFlags) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->LoaderFlags);
}

__inline
ULONG  *
OHNumberOfRvaAndSizes (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->NumberOfRvaAndSizes) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->NumberOfRvaAndSizes);
}

__inline
IMAGE_DATA_DIRECTORY *
OHDataDirectory (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->DataDirectory[0]) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->DataDirectory[0]);
}

BOOL IsRegularExpression(const char *sz);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\sources.inc ===
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\imagehlp.def

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}

USE_NOLIBS=1
USE_MSVCRT=1

BUFFER_OVERFLOW_CHECKS=1

INCLUDES=..;$(DBG_ROOT)\dbg-common;$(DBG_ROOT)\vs

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\rpcrt4.lib   \
    $(SDK_LIB_PATH)\uuid.lib     \
    $(SDK_LIB_PATH)\version.lib  \
    $(SDK_LIB_PATH)\advapi32.lib

C_DEFINES=$(C_DEFINES) -DCC_CVTYPE32 -D_VC_VER_INC -DBBTFIX -DUSE_CACHE

UMTYPE=console
SUBSYSTEM_VERSION=4.00

USECXX_FLAG=/TP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\servers.c ===
/*
 * servers.c
 *
 * Code that calls external servers such as symsrv.dll and srcsrv.dll
 */

#include <private.h>
#include <symbols.h>
#include "globals.h"

// forward reference
      

void
symsrvClose(
    VOID
    )
{
    if (!g.hSymSrv)
        return;

    if (g.fnSymbolServerClose)
        g.fnSymbolServerClose();

    FreeLibrary(g.hSymSrv);

    g.hSymSrv = 0;
    g.fnSymbolServer = NULL;
    g.fnSymbolServerClose = NULL;
    g.fnSymbolServerSetOptions = NULL;
}


DWORD
symsrvError(
    PPROCESS_ENTRY pe,
    BOOL   success,
    LPCSTR params
    )
{
    DWORD  rc;
    char  *sz;

    if (success)
        return NO_ERROR;

    rc = GetLastError();
    switch(rc)
    {
    case ERROR_PATH_NOT_FOUND:
#if 0
        if (!g.fnSymbolServerPing) 
            break;
        if (g.fnSymbolServerPing(params))
            break;
        symsrvClose();
        g.hSymSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        rc = GetLastError();
        evtprint(pe, sevProblem, ERROR_INVALID_NAME, NULL, "SYMSRV: %s is not available\n", params);
        break;
#endif    
    case ERROR_NOT_READY:           // insert floppy
    case ERROR_FILE_NOT_FOUND:      // obvious
    case ERROR_MORE_DATA:           // didn't pass any tokens
    case ERROR_REQUEST_ABORTED:     // user cancelled
    case 0:                         // hmmmmmmmmmmmm...
        break;
    case ERROR_INVALID_PARAMETER:
        symsrvClose();
        g.hSymSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        evtprint(pe, sevProblem, ERROR_INVALID_NAME, NULL, "SYMSRV: %s is not a valid store\n", params);
        break;
    case ERROR_INVALID_NAME:
        symsrvClose();
        g.hSymSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        evtprint(pe, sevProblem, ERROR_INVALID_NAME, NULL, "SYMSRV: %s needs a downstream store\n", params);
        break;
    case ERROR_FILE_INVALID:
        evtprint(pe, sevProblem, ERROR_FILE_INVALID, NULL, "SYMSRV: Compressed file needs a downstream store\n");
        break;
    default:
        break;
    }

    return rc;
}


BOOL
symsrvPath(
    LPCSTR path
    )
{
    if (!_strnicmp(path, "SYMSRV*", 7)) 
        return true;
    if (!_strnicmp(path, "SRV*", 4)) 
        return true;

    return false;
}


HMODULE 
LoadDLL(
    char *filename
    )
    /*
     * LoadLibrary() a DLL, but first try to do
     * it from the same directory as dbghelp.dll.
     */
{
    char drive[10];
    char dir[MAX_PATH + 1];
    char file[MAX_PATH + 1];
    char ext[MAX_PATH + 1];
    char path[MAX_PATH + 1];
    HMODULE hm;
    
    _splitpath(filename, drive, dir, file, ext);
    if (!*drive && !*dir) {
        if (GetModuleFileName(g.hinst, path, MAX_PATH)) {
            _splitpath(path, drive, dir, NULL, NULL);
            if (*drive || *dir) {
                PrintString(path, DIMA(path), "%s%s%s%s", drive, dir, file, ext);
                hm = LoadLibrary(path);
                if (hm)
                    return hm;
            }
        }
    }
    
    return LoadLibrary(filename);
}


DWORD
symsrvGetFile(
    IN  PPROCESS_ENTRY pe,
    IN  LPCSTR ServerInfo,
    IN  LPCSTR FileName,
    IN  GUID  *guid,
    IN  DWORD  two,
    IN  DWORD  three,
    OUT LPSTR  FilePath
    )
{
    BOOL   rc;
    LPCSTR params;
    LPCSTR fname;
    char   dll[MAX_PATH * 2];
    char   proxy[MAX_PATH + 1];
    char   path[MAX_PATH + 1];
    char   drive[_MAX_DRIVE + 1];
    char   dir[_MAX_DIR + 1];

    // strip any path information from the filename

    for (fname = FileName + strlen(FileName); fname > FileName; fname--) {
        if (*fname == '\\') {
            fname++;
            break;
        }
    }

    if (!ValidGuid(guid) && !two && !three) {
        pprint(pe, "Can't use symbol server for %s - no header information available\n", FileName);
        return ERROR_NO_DATA;
    }

    // initialize server, if needed
    
    if (g.hSymSrv == (HINSTANCE)INVALID_HANDLE_VALUE)
        return ERROR_MOD_NOT_FOUND;

    if (!_strnicmp(ServerInfo, "symsrv*", 7)) {
        params = strchr(ServerInfo + 7, '*');
        if (!params)
            return ERROR_INVALID_PARAMETER;
        if (!g.hSymSrv) {
            memcpy(dll, &ServerInfo[7], params - &ServerInfo[7]);
            dll[params - &ServerInfo[7]] = 0;
            if (!*dll)
                return ERROR_INVALID_PARAMETER;
        }
        params++;
    } else if (!_strnicmp(ServerInfo, "SRV*", 4)) {
        params = ServerInfo + 4;
        if (*params == 0 || *params == ';') 
            params = "\\\\symbols\\symbols";
        else if (*params == '*')
            params = "*\\\\symbols\\symbols";
        if (!g.hSymSrv) 
            CopyStrArray(dll, "symsrv.dll");
    }

    if (option(SYMOPT_SECURE))
        CopyStrArray(dll, "symsrv.dll");

    if (!g.hSymSrv) {
        g.hSymSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        g.hSymSrv = LoadDLL(dll);
        if (g.hSymSrv) {
            g.fnSymbolServer = (PSYMBOLSERVERPROC)GetProcAddress(g.hSymSrv, "SymbolServer");
            if (!g.fnSymbolServer) {
                FreeLibrary(g.hSymSrv);
                g.hSymSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
            }
            g.fnSymbolServerClose = (PSYMBOLSERVERCLOSEPROC)GetProcAddress(g.hSymSrv, "SymbolServerClose");
            g.fnSymbolServerSetOptions = (PSYMBOLSERVERSETOPTIONSPROC)GetProcAddress(g.hSymSrv, "SymbolServerSetOptions");
            g.fnSymbolServerPing = (PSYMBOLSERVERPINGPROC)GetProcAddress(g.hSymSrv, "SymbolServerPing");
            symsrvSetOptions(SSRVOPT_PARAMTYPE, SSRVOPT_GUIDPTR);
            symsrvSetPrompts();
            symsrvSetCallback((option(SYMOPT_DEBUG) || g.hLog) ? true : false);
            if (GetEnvironmentVariable(SYMSRV_PROXY, proxy, DIMA(proxy))) 
                symsrvSetOptions(SSRVOPT_PROXY, (ULONG_PTR)proxy);
            SymSetHomeDirectory(g.HomeDir);
#if 0
            if (g.fnSymbolServerPing) {
                if (!g.fnSymbolServerPing(params)) {
                    g.hSymSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
                    rc = GetLastError();
                    evtprint(pe, sevProblem, ERROR_INVALID_NAME, NULL, "SYMSRV: %s is not available\n", params);
                }
            }
#endif
        } else 
            g.hSymSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
    }

    // bail, if we have no valid server

    if (g.hSymSrv == INVALID_HANDLE_VALUE) {
        pprint(pe, "SymSrv load failure: %s\n", dll);
        return ERROR_MOD_NOT_FOUND;
    }

    SetCriticalErrorMode();
#if 0
    if (g.fnSymbolServerPing) 
        gfnSymbolServerPing(params);
#endif    
    if (option(SYMOPT_DEBUG)) {
        EnterCriticalSection(&g.threadlock);
        symsrvSetOptions(SSRVOPT_SETCONTEXT, (ULONG64)pe);
    }
    rc = g.fnSymbolServer(params, fname, guid, two, three, FilePath);
    if (option(SYMOPT_DEBUG)) {
        symsrvSetOptions(SSRVOPT_SETCONTEXT, NULL);
        LeaveCriticalSection(&g.threadlock);
    }
    rc = symsrvError(pe, rc, params);
    ResetCriticalErrorMode();

    return rc;
}


DWORD
symsrvGetFileMultiIndex(
    IN  PPROCESS_ENTRY pe,
    IN  LPCSTR ServerInfo,
    IN  LPCSTR FileName,
    IN  DWORD  index1,
    IN  DWORD  index2,
    IN  DWORD  two,
    IN  DWORD  three,
    OUT LPSTR  FilePath
    )
{
    GUID  guid;
    DWORD err = ERROR_NO_DATA;

    ZeroMemory(&guid, sizeof(GUID));

    if (index1) {
        guid.Data1 = index1;
        err = symsrvGetFile(pe,
                            ServerInfo,
                            FileName,
                            &guid,
                            two,
                            three,
                            FilePath);
        if (err != ERROR_FILE_NOT_FOUND && err != ERROR_PATH_NOT_FOUND)
            return err;
    }

    if (index2 && (index2 != index1)) {
        guid.Data1 = index2;
        err = symsrvGetFile(pe,
                            ServerInfo,
                            FileName,
                            &guid,
                            two,
                            three,
                            FilePath);
    }

    return err;
}


BOOL
symsrvCallback(
    UINT_PTR action,
    ULONG64 data,
    ULONG64 context
    )
{
    PPROCESS_ENTRY pe = (PPROCESS_ENTRY)context;
    PIMAGEHLP_CBA_EVENT evt;
    BOOL rc = true;

    switch (action) 
    {
    case SSRVACTION_TRACE:
        peprint(pe, (char *)data);
        break;

    case SSRVACTION_QUERYCANCEL:
        *(BOOL *)data = DoCallback(pe, CBA_DEFERRED_SYMBOL_LOAD_CANCEL, NULL);
        break;

    case SSRVACTION_EVENT:
        evt = (PIMAGEHLP_CBA_EVENT)data;
        peprint(pe, evt->desc);
        break;

    default:
        // unsupported
        rc = false;
        break;
    }

    return rc;
}


void
symsrvSetOptions(
    ULONG_PTR options,
    ULONG64   data
    )
{
    static ULONG_PTR ssopts = 0;
    static ULONG64   ssdata = 0;

    if (options != SSRVOPT_RESET) {
        ssopts = options;
        ssdata = data;
    }

    if (g.fnSymbolServerSetOptions)
        g.fnSymbolServerSetOptions(ssopts, ssdata);
}


void
symsrvSetCallback(
    BOOL state
    )
{
    if (state)
        symsrvSetOptions(SSRVOPT_CALLBACK, (ULONG64)symsrvCallback);
    else
        symsrvSetOptions(SSRVOPT_CALLBACK, 0);
    symsrvSetOptions(SSRVOPT_TRACE, state);
}


void symsrvSetPrompts()
{
    symsrvSetOptions(SSRVOPT_PARENTWIN, (ULONG_PTR)g.hwndParent);
    if (option(SYMOPT_NO_PROMPTS))
        symsrvSetOptions(SSRVOPT_UNATTENDED, (ULONG_PTR)true);
    else
        symsrvSetOptions(SSRVOPT_UNATTENDED, (ULONG_PTR)false);
}


void symsrvSetDownstreamStore(
    char *dir
    )
{
    symsrvSetOptions(SSRVOPT_DOWNSTREAM_STORE, (ULONG_PTR)dir);
}


BOOL
srcsrvInit(
    HANDLE hp
    )
{
    PPROCESS_ENTRY pe;

    if (g.hSrcSrv == (HINSTANCE)INVALID_HANDLE_VALUE)
        return false;

    pe = FindProcessEntry(hp);

    if (!g.hSrcSrv) {
        g.hSrcSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        g.hSrcSrv = LoadLibrary("srcsrv.dll");
        if (g.hSrcSrv) {
            g.fnSrcSrvInit             = (PSRCSRVINITPROC)GetProcAddress(g.hSrcSrv, "SrcSrvInit");
            g.fnSrcSrvCleanup          = (PSRCSRVCLEANUPPROC)GetProcAddress(g.hSrcSrv, "SrcSrvCleanup");
            g.fnSrcSrvSetTargetPath    = (PSRCSRVSETTARGETPATHPROC)GetProcAddress(g.hSrcSrv, "SrcSrvSetTargetPath");
            g.fnSrcSrvSetOptions       = (PSRCSRVSETOPTIONSPROC)GetProcAddress(g.hSrcSrv, "SrcSrvSetOptions");
            g.fnSrcSrvGetOptions       = (PSRCSRVGETOPTIONSPROC)GetProcAddress(g.hSrcSrv, "SrcSrvGetOptions");
            g.fnSrcSrvLoadModule       = (PSRCSRVLOADMODULEPROC)GetProcAddress(g.hSrcSrv, "SrcSrvLoadModule");
            g.fnSrcSrvUnloadModule     = (PSRCSRVUNLOADMODULEPROC)GetProcAddress(g.hSrcSrv, "SrcSrvUnloadModule");
            g.fnSrcSrvRegisterCallback = (PSRCSRVREGISTERCALLBACKPROC)GetProcAddress(g.hSrcSrv, "SrcSrvRegisterCallback");
            g.fnSrcSrvGetFile          = (PSRCSRVGETFILEPROC)GetProcAddress(g.hSrcSrv, "SrcSrvGetFile");
            if (!g.fnSrcSrvInit
                || !g.fnSrcSrvCleanup
                || !g.fnSrcSrvSetTargetPath
                || !g.fnSrcSrvSetOptions
                || !g.fnSrcSrvGetOptions
                || !g.fnSrcSrvLoadModule
                || !g.fnSrcSrvUnloadModule
                || !g.fnSrcSrvRegisterCallback
                || !g.fnSrcSrvGetFile) 
            {
                FreeLibrary(g.hSrcSrv);
                g.hSrcSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
            }
            gfnSrcSrvInit(hp, "c:\\src");
            gfnSrcSrvRegisterCallback(hp, srcsrvCallback, NULL);
            pprint(pe, "srcsrv loaded!\n");
        } else {
            g.hSrcSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        }
    }

    if (g.hSrcSrv != INVALID_HANDLE_VALUE) 
        return true;
    
    return false;
}
    

BOOL
srcsrvCallback(
    UINT_PTR action,
    DWORD64 data,
    DWORD64 context
    )
{
    BOOL rc = true;
    char *sz;
    PPROCESS_ENTRY pe;;

    switch (action) {

    case SRCSRVACTION_TRACE:
        sz = (char *)data;
        pe = (PPROCESS_ENTRY)context;
        peprint(pe, (char *)data);
        break;

    default:
        // unsupported
        rc = false;
        break;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\smashlck.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    smashlck.c

Abstract:

    This function smashes lock prefixes replacing them with NOPs

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

--*/

#include <private.h>


BOOL fVerbose;
BOOL fUpdate;
BOOL fUsage;

UCHAR LockPrefixOpcode = 0xf0;
UCHAR NoOpOpcode = 0x90;

LPSTR CurrentImageName;
LOADED_IMAGE CurrentImage;
CHAR DebugFilePath[_MAX_PATH];
LPSTR SymbolPath;

PVOID
ImageVaToLoadVa(
    PVOID ImageVa,
    PLOADED_IMAGE Image
    )
{
    PIMAGE_SECTION_HEADER Section;
    ULONG i, Rva;
    PVOID Va;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    FileHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->FileHeader;

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Image->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);
    if (!OptionalHeader32 && !OptionalHeader64)
        return NULL;

    Rva = (ULONG)((ULONG_PTR)((PUCHAR)ImageVa - (PUCHAR)OPTIONALHEADER(ImageBase)));
    Va = NULL;
    Section = Image->LastRvaSection;
    if ( Rva >= Section->VirtualAddress &&
         Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
        Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
    } else {
        for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
            if ( Rva >= Section->VirtualAddress &&
                 Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
                Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
                Image->LastRvaSection = Section;
                break;
            }
        }
    }
    if ( !Va ) {
        fprintf(stderr,"SMASHLOCK: ImageVaToLoadVa %p in image %p failed\n",ImageVa,Image);
    }
    return Va;
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    DWORD dw;
    LPSTR FilePart;
    CHAR Buffer[MAX_PATH];
    PIMAGE_LOAD_CONFIG_DIRECTORY ConfigInfo;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64;
    PIMAGE_FILE_HEADER FileHeader;
    ULONG whocares;
    char c, *p;
    BOOLEAN LocksSmashed;
    ULONG CheckSum;
    ULONG HeaderSum;
    ULONG OldChecksum;
    int   retval = 0;

    fUsage = FALSE;
    fVerbose = FALSE;
    fUpdate = FALSE;

    _tzset();

    if (argc <= 1) {
        goto showUsage;
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
                case '?':
                    fUsage = TRUE;
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'U':
                    fUpdate = TRUE;
                    break;

                case 'S':
                    argc--, argv++;
                    SymbolPath = *argv;
                    break;

                default:
                    fprintf( stderr, "SMASHLOCK: Invalid switch - /%c\n", c );
                    fUsage = TRUE;
                    break;
            }

            if ( fUsage ) {
showUsage:
                fputs("usage: SMASHLOCK [switches] image-names... \n"
                      "              [-?] display this message\n"
                      "              [-u] update image\n"
                      "              [-v] verbose output\n"
                      "              [-s] path to symbol files\n", stderr );
                exit(1);
            }
        } else {
            LocksSmashed = FALSE;

            CurrentImageName = p;
            dw = GetFullPathName(CurrentImageName,sizeof(Buffer),Buffer,&FilePart);
            if ( dw == 0 || dw > sizeof(Buffer) ) {
                FilePart = CurrentImageName;
            }

            //
            // Map and load the current image
            //

            if ( MapAndLoad(CurrentImageName, NULL, &CurrentImage, FALSE, !fUpdate )) {

                FileHeader = &((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->FileHeader;

                OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                             &OptionalHeader32,
                                             &OptionalHeader64);
                //
                // make sure the image has correct configuration information,
                // and that the LockPrefixTable is set up properly
                //

                ConfigInfo = (PIMAGE_LOAD_CONFIG_DIRECTORY)ImageDirectoryEntryToData(
                                                                CurrentImage.MappedAddress,
                                                                FALSE,
                                                                IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                                &whocares
                                                                );
                if ( ConfigInfo && ConfigInfo->LockPrefixTable ) {

                    //
                    // Walk through the lock prefix table
                    //

                    PUCHAR *LockPrefixs;
                    PUCHAR LockPrefix;

                    LockPrefixs =  (PUCHAR *)ImageVaToLoadVa((PVOID)ConfigInfo->LockPrefixTable,&CurrentImage);

                    while(LockPrefixs && *LockPrefixs) {
                        LockPrefix = (PUCHAR) ImageVaToLoadVa(*LockPrefixs,&CurrentImage);
                        if ( LockPrefix && *LockPrefix == LockPrefixOpcode ) {
                            if (fVerbose) {
                                printf("LockPrefix Found at 0x%p = %x\n",*LockPrefixs,*LockPrefix);
                            }
                            if (fUpdate) {
                                LocksSmashed = TRUE;
                                *LockPrefix = NoOpOpcode;
                            }
                        }
                        LockPrefixs++;
                    }
                }

                if ( fUpdate && LocksSmashed ) {

                    //
                    // recompute the checksum.
                    //

                    OldChecksum = OPTIONALHEADER(CheckSum);
                    if ( CurrentImage.hFile != INVALID_HANDLE_VALUE ) {

                        OPTIONALHEADER_ASSIGN(CheckSum, 0);

                        CheckSumMappedFile(
                                    (PVOID)CurrentImage.MappedAddress,
                                    GetFileSize(CurrentImage.hFile, NULL),
                                    &HeaderSum,
                                    &CheckSum
                                    );

                        OPTIONALHEADER_ASSIGN(CheckSum, CheckSum);
                    }

                    FlushViewOfFile(CurrentImage.MappedAddress,0);
                    TouchFileTimes(CurrentImage.hFile,NULL);

                    // And update the .dbg file (if requested)
                    if (SymbolPath &&
                        FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                        if ( UpdateDebugInfoFileEx( CurrentImageName,
                                                    SymbolPath,
                                                    DebugFilePath,
                                                    (PIMAGE_NT_HEADERS32) CurrentImage.FileHeader,
                                                    OldChecksum) ) {
                            if (GetLastError() == ERROR_INVALID_DATA) {
                                printf( "Warning: Old checksum did not match for %s\n", DebugFilePath);
                                }
                            printf("Updated symbols for %s\n", DebugFilePath);
                        } else {
                            printf("Unable to update symbols: %s\n", DebugFilePath);
                            retval=1;
                        }
                    }
                }

                UnmapViewOfFile(CurrentImage.MappedAddress);
                if ( CurrentImage.hFile != INVALID_HANDLE_VALUE ) {
                    CloseHandle(CurrentImage.hFile);
                }
                ZeroMemory(&CurrentImage,sizeof(CurrentImage));
            } else {
                if (!CurrentImage.fSystemImage && !CurrentImage.fDOSImage) {
                    fprintf(stderr,"SMASHLOCK: failure mapping and loading %s\n",CurrentImageName);
                    retval=1;
                }
            }
        }
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\splitsym.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    splitsym.c

Abstract:

    This is the main source file for the SPLITSYM utility program.  This
    program can be used to split the debugging information contained in
    an executable image file into a separate .DBG file and strip it from
    the image file.  Allow stripped image files to be distributed which
    significantly reduces disk space requirements, but allows full
    debugging by accesing the associated .DBG files over the network
    when needed.

Author:

    Steve Wood (stevewo) 03-May-1993

Revision History:

--*/

#include <private.h>
#include <splitsymx.h>
#include <strsafe.h>

BOOL fVerbose;
BOOL fRecurse;
ULONG SplitFlags = 0;

UCHAR RecurseDirectory[MAX_PATH + 1];

UCHAR CurrentImageName[ MAX_PATH ];

UCHAR SymbolPath[MAX_PATH + 1];
UCHAR RSDSDllPath[MAX_PATH + 1];

UCHAR DbgFileName[ MAX_PATH ];

VOID
SplitSymbolsInTree(
    LPSTR RootPath
    );

void
Usage( void )
{
    fputs ( "usage: SPLITSYM [-?] [-v] [-p] [-a] [-s symbol directory] [-r directory] image-names...\n"
            "              [-?] display this message\n"
            "              [-v] verbose output\n"
            "              [-p] remove private debug info when creating .dbg file\n"
            "              [-a] extract all debug info into .dbg file\n"
            "              [-m] RSDS dll to load, default is mspdb70.dll\n"
            "              [-r directory] - recursively process all image files.\n"
            "              [-s symbol directory] - where to put .DBG files.\n"
            "                                      Default is same place as image file.\n",
            stderr );
    exit( 1 );
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *s;
    LPSTR FilePart;
    CHAR  PdbName[MAX_PATH] = "";

    if (argc <= 1) {
        Usage();
        }

    StringCchCopy(RSDSDllPath, MAX_PATH, "mspdb70.dll");

    SymbolPath[ 0 ] = '\0';
    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (c = *++s)
                switch (toupper( c )) {
                case '?':
                    Usage();
                    break;

                case 'M':
                    if (--argc) {
                        StringCchCopy(RSDSDllPath, MAX_PATH, *++argv );
                        }
                    else {
                        fprintf( stderr, "SPLITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'R':
                    if (--argc) {
                        fRecurse = TRUE;
                        StringCchCopy(RecurseDirectory, MAX_PATH, *++argv);
                        }
                    else {
                        fprintf( stderr, "SPLITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                case 'S':
                    if (--argc) {
                        StringCchCopy(SymbolPath, MAX_PATH, *++argv );
                        }
                    else {
                        fprintf( stderr, "SPLITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                case 'P':
                    SplitFlags |= SPLITSYM_REMOVE_PRIVATE;
                    break;

                case 'A':
                    SplitFlags |= SPLITSYM_EXTRACT_ALL;
                    break;

                default:
                    fprintf( stderr, "SPLITSYM: Invalid switch - /%c\n", c );
                    Usage();
                    break;
                }
            }
        else {
            if (fRecurse) {
                fprintf( stderr, "SPLITSYM: May not specify specific file names with /R switch.\n" );
                Usage();
                }
            else
            if (!GetFullPathNameA( s, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                fprintf( stderr, "SPLITSYM: invalid file name - %s (%u)\n", s, GetLastError() );
                }
            else {
                if (SplitSymbolsX( (PCHAR) CurrentImageName, (PCHAR) SymbolPath, (PCHAR) DbgFileName, 
                                   sizeof(DbgFileName), SplitFlags, RSDSDllPath, PdbName, sizeof(PdbName) )) {
                    if (fVerbose) {
                        fprintf( stdout,
                                 "SPLITSYM: %16s symbols split into %s\n",
                                 FilePart,
                                 DbgFileName
                               );
                        }
                    }
                else
                if (GetLastError() != ERROR_BAD_EXE_FORMAT &&
                    GetLastError() != ERROR_ALREADY_ASSIGNED
                   ) {
                    fprintf( stderr, "SPLITSYM: Unable to split symbols from '%s' into '%s' (%u)\n",
                             CurrentImageName,
                             DbgFileName,
                             GetLastError()
                           );
                    }
                }
            }
        }

    if (fRecurse) {
        SplitSymbolsInTree( (PCHAR) RecurseDirectory );
        }

    exit( 0 );
    return 0;
}


#define MAX_DEPTH 32

VOID
SplitSymbolsInTree(
    LPSTR RootPath
    )
{
    LPSTR FilePart;
    PUCHAR Prefix = (PUCHAR) "";
    CHAR PathBuffer[MAX_PATH + 1];
    ULONG Depth;
    PCHAR PathTail[ MAX_DEPTH ];
    PCHAR FindHandle[ MAX_DEPTH ];
    LPWIN32_FIND_DATA FindFileData;
    UCHAR FindFileBuffer[ MAX_PATH + sizeof( WIN32_FIND_DATA ) ];
    CHAR  PdbName[MAX_PATH] = "";

    StringCchCopy(PathBuffer, MAX_PATH, RootPath);
    FindFileData = (LPWIN32_FIND_DATA)FindFileBuffer;
    Depth = 0;
    while (TRUE) {
startDirectorySearch:
        PathTail[ Depth ] = strchr( PathBuffer, '\0' );
        if (PathTail[ Depth ] > PathBuffer && PathTail[ Depth ][ -1 ] != '\\') {
            *(PathTail[ Depth ])++ = '\\';
            }

        StringCchCopy(PathTail[Depth], MAX_PATH - (PathTail[Depth] - PathBuffer), "*.*" );
        FindHandle[ Depth ] = (PCHAR) FindFirstFile( PathBuffer, FindFileData );
        if (FindHandle[ Depth ] != INVALID_HANDLE_VALUE) {
            do {
                if (FindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if (strcmp( FindFileData->cFileName, "." ) &&
                        strcmp( FindFileData->cFileName, ".." ) &&
                        Depth < MAX_DEPTH
                       ) {
                        StringCchPrintf(PathTail[ Depth ], 
                                         MAX_PATH - (PathTail[Depth] - PathBuffer),
                                         "%s\\", 
                                         FindFileData->cFileName );
                        Depth++;
                        goto startDirectorySearch;
                        }
                    }
                else
                if (!(FindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY)) {
                    StringCchCopy(PathTail[Depth], MAX_PATH - (PathTail[Depth] - PathBuffer), FindFileData->cFileName);
                    if (!GetFullPathNameA( PathBuffer, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                        fprintf( stderr, "SPLITSYM: invalid file name - %s (%u)\n", PathBuffer, GetLastError() );
                        }
                    else {
                        if (SplitSymbolsX( (PCHAR) CurrentImageName, (PCHAR) SymbolPath, (PCHAR) DbgFileName, 
                                           sizeof(DbgFileName), SplitFlags, RSDSDllPath, PdbName, sizeof(PdbName) )) {
                            if (fVerbose) {
                                fprintf( stdout,
                                         "SPLITSYM: %16s symbols split into %s\n",
                                         FilePart,
                                         DbgFileName
                                       );
                                }
                            }
                        else
                        if (GetLastError() != ERROR_BAD_EXE_FORMAT ) {
                            fprintf( stderr, "SPLITSYM: Unable to split symbols from '%s' into '%s' (%u)\n",
                                     CurrentImageName,
                                     DbgFileName,
                                     GetLastError()
                                   );
                            }
                        }
                    }

restartDirectorySearch:
                ;
                }
            while (FindNextFile( FindHandle[ Depth ], FindFileData ));
            FindClose( FindHandle[ Depth ] );

            if (Depth == 0) {
                break;
                }

            Depth--;
            goto restartDirectorySearch;
            }
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\splitsymx.c ===
#define use_SplitSymbolsX 1

#include <splitsymi.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\imagehlp\splitsymi.c ===
#include <private.h>

#if defined(use_SplitSymbolsX)
#   include <splitsymx.h>
#   define SymMalloc(a) malloc(a)
#   define SymFree(a) { if (a != NULL) { free(a); a=NULL; } }
#else
#   define SymMalloc(a) MemAlloc(a)
#   define SymFree(a) { if (a != NULL) { MemFree(a); a=NULL; } }
#endif // use_SplitSymbolsX


#include <strsafe.h>

#define CLEAN_PD(addr) ((addr) & ~0x3)
#define CLEAN_PD64(addr) ((addr) & ~0x3UI64)

#if defined(use_SplitSymbolsX)

BOOL
SplitSymbolsX(
    LPSTR ImageName,
    LPSTR SymbolsPath,
    LPSTR SymbolFilePath,
    DWORD SizeOfSymbolFilePath,
    ULONG Flags,
    PCHAR RSDSDllToLoad,
    LPSTR CreatedPdb,
    DWORD SizeOfPdbBuffer
    )

#else

BOOL
IMAGEAPI
SplitSymbols(
    LPSTR ImageName,
    LPSTR SymbolsPath,
    LPSTR SymbolFilePath,
    ULONG Flags
    )

#endif // use_SplitSymbolsX

{
    // UnSafe...

    HANDLE FileHandle = INVALID_HANDLE_VALUE, SymbolFileHandle = INVALID_HANDLE_VALUE;
    HANDLE hMappedFile;
    LPVOID ImageBase = NULL;
    PIMAGE_NT_HEADERS32 NtHeaders;
    LPSTR ImageFileName;
    DWORD SizeOfSymbols;
    ULONG_PTR ImageNameOffset;
    ULONG_PTR DebugSectionStart;
    PIMAGE_SECTION_HEADER DebugSection = NULL;
    DWORD SectionNumber, BytesWritten, NewFileSize, HeaderSum, CheckSum;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory, DebugDirectories, DbgDebugDirectories = NULL;
    IMAGE_DEBUG_DIRECTORY MiscDebugDirectory = {0};
    IMAGE_DEBUG_DIRECTORY FpoDebugDirectory = {0};
    IMAGE_DEBUG_DIRECTORY FunctionTableDir;
    PIMAGE_DEBUG_DIRECTORY pFpoDebugDirectory = NULL;
    DWORD DebugDirectorySize, DbgFileHeaderSize, NumberOfDebugDirectories;
    IMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    DWORD  ExportedNamesSize;
    LPDWORD pp;
    LPSTR ExportedNames = NULL, Src, Dst;
    DWORD i, j, RvaOffset, ExportDirectorySize;
    PFPO_DATA FpoTable = NULL;
    DWORD FpoTableSize;
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY RuntimeFunctionTable, pSrc;
    DWORD RuntimeFunctionTableSize;
    PIMAGE_FUNCTION_ENTRY FunctionTable = NULL, pDst;
    DWORD FunctionTableSize;
    ULONG NumberOfFunctionTableEntries, DbgOffset;
    DWORD SavedErrorCode;
    BOOL InsertExtensionSubDir;
    LPSTR ImageFilePathToSaveInImage;
    BOOL MiscInRdata = FALSE;
    BOOL DiscardFPO = Flags & SPLITSYM_EXTRACT_ALL;
    BOOL MiscDebugFound, OtherDebugFound, PdbDebugFound;
    BOOL fNewCvData = FALSE;
    PCHAR  NewDebugData = NULL;
    CHAR AltPdbPath[_MAX_PATH+1];
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader;
    PIMAGE_SECTION_HEADER Sections;
    PCVDD pDebugCV;

#if !defined(use_SplitSymbolsX)                 // SplitSymbolsX recieves this as a param
    DWORD SizeOfSymbolFilePath = MAX_PATH+1;    // size of SymbolFilePath is assumed
#endif

    LPSTR   tempPtr;
    HRESULT hrRetCode;
    BOOL    bSplitSymRetValue    = FALSE;         // by default, assume failure
    DWORD   dwLastError          = 0;


    __try { // SymbolsPath is manipulated within this function, but the size of the string
            // is not known so wrap everything in order to catch possible exceptions.
            // I still need to verify if this can possibly lead to leaked resources.

        //
        // verify the two required parameters are not NULL
        //
        if (ImageName==NULL || SymbolFilePath==NULL) {
            dwLastError = ERROR_INVALID_PARAMETER;
            __leave;
        }

        if (Flags & SPLITSYM_SYMBOLPATH_IS_SRC) {
                if ( S_OK != (hrRetCode = StringCbCopy(AltPdbPath, sizeof(AltPdbPath), SymbolFilePath)) ) {
                    dwLastError = hrRetCode;
                    __leave;
                }

        }

        //
        // make ImageFileName point to the first char after the last directory in ImageName (first char of filename)
        //
        ImageFileName = ImageName + strlen( ImageName );
        while (ImageFileName > ImageName) {
            if (*ImageFileName == '\\' ||
                *ImageFileName == '/' ||
                *ImageFileName == ':' )
            {
                ImageFileName = CharNext(ImageFileName);
                break;
            } else {
                ImageFileName = CharPrev(ImageName, ImageFileName);
            }
        }


        //
        // Put the initial symbols path into SymbolFilePath
        //
        if (SymbolsPath == NULL ||
            SymbolsPath[ 0 ] == '\0' ||
            SymbolsPath[ 0 ] == '.' )
        {
            CHAR   TempChar;

            //
            // copy everything except the filename from ImageName to SymbolFilePath
            //
            TempChar = *ImageFileName;                              // temporarily null terminate ImageName immediately prior to the
            *ImageFileName = '\0';                                  //      filename
            if ( S_OK != (hrRetCode = StringCchCopy(SymbolFilePath, SizeOfSymbolFilePath, ImageName)) ) {
                dwLastError = hrRetCode;
                __leave;
            }
            *ImageFileName = TempChar;                              // replace the character we temporarily removed
            InsertExtensionSubDir = FALSE;

        } else {
            //
            // Use the provided SymbolsPath
            //
            if ( S_OK != (hrRetCode = StringCchCopy(SymbolFilePath, SizeOfSymbolFilePath, SymbolsPath)) ) {
                dwLastError = hrRetCode;
                __leave;
            }
            InsertExtensionSubDir = TRUE;
        }

        //
        // make sure SymbolFilePath ends in '\\' and that Dst points to the end of the string
        //
        Dst = SymbolFilePath + strlen( SymbolFilePath );
        tempPtr = CharPrev(SymbolFilePath, Dst); // clean up PreFast warning
        if (Dst > SymbolFilePath &&
            *tempPtr != '\\' &&
            *tempPtr != '/'  &&
            *tempPtr != ':')
        {
            if ( S_OK != (hrRetCode = StringCchCat(SymbolFilePath, SizeOfSymbolFilePath, "\\")) ) {
                dwLastError = hrRetCode;
                __leave;
            }

            Dst++; // fix prefast warning
        }

        // ImageFilePathToSaveInImage points to the end of SymbolFilePath
        ImageFilePathToSaveInImage = Dst;

        //
        // If there is a filename extension and InsertExtensionSubDir is TRUE, copy the extension to SymbolFilePath
        // as a subdirectory
        //
        Src = strrchr( ImageFileName, '.' );
        if (Src != NULL && InsertExtensionSubDir) {
            Src++;      // Skip past '.'
            if ( S_OK != (hrRetCode = StringCchCat(SymbolFilePath, SizeOfSymbolFilePath, Src)) ) {
                dwLastError = hrRetCode;
                __leave;
            }
            if ( S_OK != (hrRetCode = StringCchCat(SymbolFilePath, SizeOfSymbolFilePath, "\\")) ) {
                dwLastError = hrRetCode;
                __leave;
            }
        }

        //
        // add the filename to SymbolFilePath
        //
        if ( S_OK != (hrRetCode = StringCchCat(SymbolFilePath, SizeOfSymbolFilePath, ImageFileName)) ) {
            dwLastError = hrRetCode;
            __leave;
        }

        //
        // change the extension to ".dbg" (or just append ".dbg" ??)
        //
        Dst = strrchr(Dst, '.');
        if (Dst == NULL) {
            Dst = SymbolFilePath + strlen( SymbolFilePath );
        } else {
            *Dst = '\0';
        }

        if ( S_OK != (hrRetCode = StringCchCat( SymbolFilePath, SizeOfSymbolFilePath, ".dbg" )) ) {
            dwLastError = hrRetCode;
            __leave;
        }

        // Now, open and map the input file.
        FileHandle = CreateFile( ImageName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL
                               );


        if (FileHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }

        hMappedFile = CreateFileMapping( FileHandle,
                                         NULL,
                                         PAGE_READWRITE,
                                         0,
                                         0,
                                         NULL
                                       );
        if (!hMappedFile) {
            __leave;
        }

        ImageBase = MapViewOfFile( hMappedFile,
                                   FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0
                                 );
        CloseHandle( hMappedFile );
        if (!ImageBase) {
            __leave;
        }

        //
        // Everything is mapped. Now check the image and find nt image headers
        //

#ifndef _WIN64
        NtHeaders = ImageNtHeader( ImageBase );
        if (NtHeaders == NULL) {
            FileHeader = (PIMAGE_FILE_HEADER)ImageBase;
            OptionalHeader = ((PIMAGE_OPTIONAL_HEADER32)((ULONG_PTR)FileHeader+IMAGE_SIZEOF_FILE_HEADER));
            // One last check
            if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
                goto HeaderOk;
HeaderBad:
#endif
            dwLastError = ERROR_BAD_EXE_FORMAT;
            __leave;
#ifndef _WIN64
        } else {
            FileHeader = &NtHeaders->FileHeader;
            OptionalHeader = &NtHeaders->OptionalHeader;
            if (OptionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
                goto HeaderBad;
        }


HeaderOk:

        if ((OptionalHeader->MajorLinkerVersion < 3) &&
            (OptionalHeader->MinorLinkerVersion < 5) )
        {
            dwLastError = ERROR_BAD_EXE_FORMAT;
            __leave;
        }

        {
            DWORD dwDataSize;
            PVOID pData;
            pData = ImageDirectoryEntryToData(ImageBase, FALSE, IMAGE_DIRECTORY_ENTRY_SECURITY, &dwDataSize);
            if (pData || dwDataSize) {
                // This image has been signed.  Can't strip the symbols w/o invalidating the certificate.
                dwLastError = ERROR_BAD_EXE_FORMAT;
                __leave;
            }

            pData = ImageDirectoryEntryToData(
                                              ImageBase,
                                              FALSE,
                                              IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                              &dwDataSize
                                              );

            if (pData) {
                // COR header found - see if it's strong signed
                if (((IMAGE_COR20_HEADER *)pData)->Flags & COMIMAGE_FLAGS_STRONGNAMESIGNED)
                {
                    // This image has been strong signed.  Can't strip the symbols w/o invalidating the certificate.
                    dwLastError = ERROR_BAD_EXE_FORMAT;
                    __leave;
                }
            }
        }

        if (FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
        {
            // The symbols have already been stripped.  No need to continue.
            dwLastError = ERROR_ALREADY_ASSIGNED;
            __leave;
        }

        DebugDirectories = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData( ImageBase,
                                                      FALSE,
                                                      IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                      &DebugDirectorySize
                                                    );
        if (!DebugDirectoryIsUseful(DebugDirectories, DebugDirectorySize)) {
            dwLastError = ERROR_BAD_EXE_FORMAT;
            __leave;
        }

        NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

        // See if there's a MISC debug dir and if not, there s/b ONLY a CV data or it's an error.

        MiscDebugFound = FALSE;
        OtherDebugFound = FALSE;
        for (i=0,DebugDirectory=DebugDirectories; i<NumberOfDebugDirectories; i++,DebugDirectory++) {
            switch (DebugDirectory->Type) {
                case IMAGE_DEBUG_TYPE_MISC:
                    MiscDebugFound = TRUE;
                    break;

                case IMAGE_DEBUG_TYPE_CODEVIEW:
                    pDebugCV = ( PCVDD ) (DebugDirectory->PointerToRawData + (PCHAR)ImageBase);
                    if (pDebugCV->dwSig == '01BN') {
                        PdbDebugFound = TRUE;
                    }
#if defined(use_SplitSymbolsX)
                    if (pDebugCV->dwSig == 'SDSR') {
                        PdbDebugFound = TRUE;
                    }
#endif
                    break;

                default:
                    OtherDebugFound = TRUE;
                    break;
            }
        }

        if (OtherDebugFound && !MiscDebugFound) {
            dwLastError = ERROR_BAD_EXE_FORMAT;
            __leave;
        }

        if (PdbDebugFound && !OtherDebugFound && (OptionalHeader->MajorLinkerVersion >= 6)) {
            // This is a VC6 generated image.  Don't create a .dbg file.
            MiscDebugFound = FALSE;
        }

        // Make sure we can open the .dbg file before we continue...
        if (!MakeSureDirectoryPathExists( SymbolFilePath )) {
            __leave;
        }

        if (MiscDebugFound) {
            // Try to open the symbol file
            SymbolFileHandle = CreateFile( SymbolFilePath,
                                           GENERIC_WRITE,
                                           0,
                                           NULL,
                                           CREATE_ALWAYS,
                                           0,
                                           NULL
                                         );
            if (SymbolFileHandle == INVALID_HANDLE_VALUE) {
                goto nosyms;
            }
        }

        // The entire file is mapped so we don't have to care if the rva's
        // are correct.  It is interesting to note if there's a debug section
        // we need to whack before terminating, though.

        {
            if (NtHeaders) {
                Sections = IMAGE_FIRST_SECTION( NtHeaders );
            } else {
                Sections = (PIMAGE_SECTION_HEADER)
                            ((ULONG_PTR)ImageBase +
                              ((PIMAGE_FILE_HEADER)ImageBase)->SizeOfOptionalHeader +
                              IMAGE_SIZEOF_FILE_HEADER );
            }

            for (SectionNumber = 0;
                 SectionNumber < FileHeader->NumberOfSections;
                 SectionNumber++ ) {

                if (Sections[ SectionNumber ].PointerToRawData != 0 &&
                    !_stricmp( (char *) Sections[ SectionNumber ].Name, ".debug" )) {
                    DebugSection = &Sections[ SectionNumber ];
                }
            }
        }

        FpoTable           = NULL;
        ExportedNames      = NULL;
        DebugSectionStart  = 0xffffffff;

        //
        // Find the size of the debug section.
        //

        SizeOfSymbols = 0;

        for (i=0,DebugDirectory=DebugDirectories; i<NumberOfDebugDirectories; i++,DebugDirectory++) {

            switch (DebugDirectory->Type) {
                case IMAGE_DEBUG_TYPE_MISC :

                    // Save it away.
                    MiscDebugDirectory = *DebugDirectory;

                    // check to see if the misc debug data is in some other section.

                    // If Address Of Raw Data is cleared, it must be in .debug (there's no such thing as not-mapped rdata)
                    // If it's set and there's no debug section, it must be somewhere else.
                    // If it's set and there's a debug section, check the range.

                    if ((DebugDirectory->AddressOfRawData != 0) &&
                        ((DebugSection == NULL) ||
                         (((DebugDirectory->PointerToRawData < DebugSection->PointerToRawData) ||
                           (DebugDirectory->PointerToRawData >= DebugSection->PointerToRawData + DebugSection->SizeOfRawData)
                          )
                         )
                        )
                       )
                    {
                        MiscInRdata = TRUE;
                    } else {
                        if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                            DebugSectionStart = DebugDirectory->PointerToRawData;
                        }
                    }

                    break;

                case IMAGE_DEBUG_TYPE_FPO:
                    if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                        DebugSectionStart = DebugDirectory->PointerToRawData;
                    }

                    // Save it away.

                    FpoDebugDirectory = *DebugDirectory;
                    pFpoDebugDirectory = DebugDirectory;
                    break;

                case IMAGE_DEBUG_TYPE_CODEVIEW:
                    {
                        ULONG   NewDebugSize;

                        if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                            DebugSectionStart = DebugDirectory->PointerToRawData;
                        }

                        // If private's are removed do so to the static CV data and save the new size...
                        pDebugCV = ( PCVDD ) (DebugDirectory->PointerToRawData + (PCHAR)ImageBase);
                        if (pDebugCV->dwSig == '01BN') {
                            // Got a PDB.  The name immediately follows