tocol ].dwServiceFlags & XP_MESSAGE_ORIENTED     ? TRUE : FALSE );
	a_pInst->Setbool( L"PseudoStreamOriented",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_PSEUDO_STREAM        ? TRUE : FALSE );
	a_pInst->Setbool( L"GuaranteesDelivery",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_GUARANTEED_DELIVERY  ? TRUE : FALSE );
	a_pInst->Setbool( L"GuaranteesSequencing",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_GUARANTEED_ORDER     ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsGuaranteedBandwidth", m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_BANDWIDTH_ALLOCATION ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsGracefulClosing",	m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_GRACEFUL_CLOSE       ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsExpeditedData",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_EXPEDITED_DATA       ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsConnectData",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_CONNECT_DATA         ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsDisconnectData",	m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_DISCONNECT_DATA      ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsBroadcasting",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_SUPPORTS_BROADCAST   ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsMulticasting",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_SUPPORTS_MULTICAST   ? TRUE : FALSE );
	a_pInst->Setbool(  L"SupportsFragmentation",	m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_FRAGMENTATION        ? TRUE : FALSE );
	a_pInst->Setbool( L"SupportsEncryption",		m_pInfo[ m_nCurrentProtocol ].dwServiceFlags & XP_ENCRYPTS             ? TRUE : FALSE );
	a_pInst->Setbool( IDS_SupportsQualityofService, false ) ;

	// Sockets 1.1 status... open the socket and test
	CHString t_chsStatus ;
	GetStatus( &m_pInfo[ m_nCurrentProtocol ], t_chsStatus ) ;

	a_pInst->SetCHString( IDS_Status, t_chsStatus ) ;
}
void CSockets11::GetWin95RegistryStuff( CInstance *a_pInst, LPTSTR a_szProtocol )
{
	CRegistrySearch		t_Search;
	CHPtrArray			t_chsaList;
	CHString			*t_pPtr,
						t_chsValue,
						t_chsTmp ;
	SYSTEMTIME			t_sysTime;

	try
	{
		a_pInst->SetCHString( IDS_Status, IDS_STATUS_Unknown ) ;

		//====================================================
		//  Go thru, find the network transports, then check
		//  with config manager to see which ones are loaded
		//====================================================
		t_Search.SearchAndBuildList( L"Enum\\Network", t_chsaList, L"NetTrans", L"Class", VALUE_SEARCH ) ;

		for( int t_i = 0; t_i < t_chsaList.GetSize(); t_i++ )
		{
			CRegistry t_Reg ;
			t_pPtr = ( CHString* ) t_chsaList.GetAt( t_i ) ;

			//====================================================
			//  Opened the key, now I need to read the MasterCopy
			//  key and strip out enum\ and see if that is current
			//  in Config Manager
			//====================================================

			if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, *t_pPtr, KEY_READ ) )
			{
				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"DeviceDesc", t_chsValue ) )
				{
					if( _tcsicmp( a_szProtocol, TOBSTRT( t_chsValue ) ) != 0 )
					{
						continue ;
					}
				}
				else
				{
					break ;
				}

				if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"MasterCopy", t_chsValue ) )
				{
					CConfigMgrDevice t_Cfg ;

					//=================================================
					//  If we find the status, then we know that this
					//  is the current key, and to read the Driver key
					//  in the registry to tell us where the driver info
					//  is at.
					//=================================================
					if( t_Cfg.GetStatus( t_chsValue ) )
					{
						a_pInst->SetCHString( IDS_Status, t_chsValue ) ;

						if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"DeviceDesc", t_chsValue ) )
						{
							a_pInst->SetCHString( IDS_Caption, t_chsValue ) ;
						}

						if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"Mfg", t_chsTmp ) )
						{
							a_pInst->SetCHString( IDS_Description, t_chsTmp + CHString( _T("-")) + t_chsValue ) ;
						}

						if( ERROR_SUCCESS == t_Reg.GetCurrentKeyValue( L"Driver",t_chsTmp ) )
						{
							t_chsTmp = L"System\\CurrentControlSet\\Services\\Class\\" + t_chsTmp ;

							if( ERROR_SUCCESS == t_Reg.Open( HKEY_LOCAL_MACHINE, t_chsTmp, KEY_READ ) )
							{
								if( t_Reg.GetCurrentKeyValue( L"DriverDate", t_chsTmp ) == ERROR_SUCCESS )
								{
									swscanf( t_chsTmp,L"%d-%d-%d",
												&t_sysTime.wMonth,
												&t_sysTime.wDay,
												&t_sysTime.wYear);

									t_sysTime.wSecond = 0;
									t_sysTime.wMilliseconds = 0;
									a_pInst->SetDateTime( IDS_InstallDate, t_sysTime ) ;
								}
							}
						}

						break ;
					}
				}
			}
		}
	}
	catch( ... )
	{
		t_Search.FreeSearchList( CSTRING_PTR, t_chsaList ) ;

		throw ;
	}

	t_Search.FreeSearchList( CSTRING_PTR, t_chsaList ) ;
}

/*******************************************************************
    NAME:       GetSocketInfo( CInstance * a_pInst, LPWSAPROTOCOL_INFO pInfo, CHString &a_chsStatus )

    SYNOPSIS:   Get protocol status (9x )and checks for Guaranteed Bandwidth support.

				For Guaranteed Bandwidth, Determine if the local traffic control agent
				is installed and operational. If so, the agent can establish a negotiated
				bandwidth with the socket initiator.
				Although mutiple vendors could supply a traffic control agent this
				IODevCtl call is not currently IOC_WS2 abstracted. This is a vendor
				specific call(MS).
				This was discussed with Kam Lee in the NT networking group and suggested
				this IOCTL apply to all vendors (he will submit the request and follow up).

				Test note: this specific WSAIoctl is confirmed to fail with NT5 builds before 1932.

	ENTRY:      CInstance * a_pInst		:
				LPWSAPROTOCOL_INFO pInfo	:

    HISTORY:
                a-peterc  22-Nov-1998     Created
********************************************************************/
void CSockets22::GetSocketInfo( CInstance *a_pInst, LPWSAPROTOCOL_INFO a_pInfo, CHString &a_chsStatus )
{
	bool t_bGuaranteed = false ;

	if( !a_pInfo )
	{
		a_chsStatus = IDS_Error ;
		return;
	}

	// Create a socket for this protocol.
	SOCKET t_s = m_pws32api->WSASocket(	FROM_PROTOCOL_INFO,
										FROM_PROTOCOL_INFO,
										FROM_PROTOCOL_INFO,
										a_pInfo,
										0,
										NULL );
	if( INVALID_SOCKET != t_s )
	{
		try
        {
            if( a_pInfo->dwServiceFlags1 & XP1_QOS_SUPPORTED )
		    {
			    // The socket must be bound for the query
			    SOCKADDR	t_sAddr;

			    memset( &t_sAddr, 0, sizeof( t_sAddr ) ) ;
			    t_sAddr.sa_family = (u_short)a_pInfo->iAddressFamily;

			    if( SOCKET_ERROR != m_pws32api->Bind( t_s, &t_sAddr, sizeof( t_sAddr ) ) )
			    {
				    // query for local traffic control
				    DWORD	t_dwInBuf = 50004 ;	// LOCAL_TRAFFIC_CONTROL ( vendor specific, ms )
				    DWORD	t_dwOutBuf ;
				    DWORD	t_dwReturnedBytes = 0;

				    if( SOCKET_ERROR !=
					    m_pws32api->WSAIoctl( t_s,						// socket
										     _WSAIORW( IOC_VENDOR, 1 ), /* = SIO_CHK_QOS */	// dwIoControlCode
										     &t_dwInBuf,				// lpvInBuffer
										     sizeof( t_dwInBuf ),		// cbInBuffer
										     &t_dwOutBuf,				// lpvOUTBuffer
										     sizeof( t_dwOutBuf ),		// cbOUTBuffer
										     &t_dwReturnedBytes,		// lpcbBytesReturned
										     NULL ,						// lpOverlapped
										     NULL ) )					// lpCompletionROUTINE
				    {
					    if( sizeof( t_dwOutBuf ) == t_dwReturnedBytes )
					    {
						    t_bGuaranteed = t_dwOutBuf ? true : false ;

					    }
				    }
			    }
		    }
		    m_pws32api->CloseSocket( t_s ) ;

		    a_chsStatus = IDS_OK ;
        }
        catch(...)
        {
            m_pws32api->CloseSocket( t_s ) ;
            throw; 
        }
	}
	else
	{
		switch ( m_pws32api->WSAGetLastError() )
		{
			case WSAENETDOWN:
			case WSAEINPROGRESS:
			case WSAENOBUFS:
			case WSAEMFILE:
			{
				a_chsStatus = IDS_Degraded ;
				break;
			}
			case WSANOTINITIALISED:
			case WSAEAFNOSUPPORT:
			case WSAEPROTONOSUPPORT:
			case WSAEPROTOTYPE:
			case WSAESOCKTNOSUPPORT:
			case WSAEINVAL:
			case WSAEFAULT:
			{
				a_chsStatus = IDS_Error ;
				break;
			}

			default:
			{
				a_chsStatus = IDS_Unknown ;
				break;
			}
		}
	}

	a_pInst->Setbool( L"SupportsGuaranteedBandwidth", t_bGuaranteed ) ;
}





//==============================================================================
//
//	Callback function prototypes
//
//		NotifyHandler
//		AddFlowCompleteHandler
//		ModifyFlowCompleteHandler
//		DeleteFlowCompleteHandler
//
//  NOTE: These callback functions are all stub. They don't need to take 
//		  any action acccording to current functionality
//
//==============================================================================


VOID CALLBACK
NotifyHandler(
		HANDLE	ClRegCtx,
		HANDLE	ClIfcCtx,
		ULONG	Event, 
		HANDLE	SubCode,
		ULONG	BufSize,
		PVOID	Buffer)
{
	
	// Perform callback action

}



VOID CALLBACK
AddFlowCompleteHandler(
	HANDLE	ClFlowCtx,
	ULONG	Status)
{

	// Perform callback action

}


VOID CALLBACK
ModifyFlowCompleteHandler(
	HANDLE	ClFlowCtx,
	ULONG	Status)
{

	// Perform callback action

}



VOID CALLBACK 
DeleteFlowCompleteHandler(
	HANDLE	ClFlowCtx,
	ULONG	Status)
{

	// Perform callback action

}



//==============================================================================
//
// Define the list of callback functions that can be activated by 
// Traffic Control Interface.
//
//==============================================================================

TCI_CLIENT_FUNC_LIST	g_tciClientFuncList = 
{	
	NotifyHandler,
	AddFlowCompleteHandler,
	ModifyFlowCompleteHandler,
	DeleteFlowCompleteHandler
};


DWORD CSockets22::GetTrafficControlInfo(CInstance *a_pInst)
{
	DWORD dwRet = NO_ERROR;
	HANDLE	hClient				= INVALID_HANDLE_VALUE;
	HANDLE	hClientContext		= INVALID_HANDLE_VALUE; /* DEFAULT_CLNT_CONT */;
	ULONG	ulEnumBufSize		= 0;
	BYTE	buff[1];			// We only need a dummy buffer
    
    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;
    
    try 
    {
        //register the TC Client
	    dwRet = TcRegisterClient(
            CURRENT_TCI_VERSION,
		    hClientContext,
		    &g_tciClientFuncList,
		    &hClient);
	    
        // was the client registration successful?
	    if (dwRet == NO_ERROR)
	    {
		    //enumerate the interfaces available
		    dwRet = TcEnumerateInterfaces(
                hClient,
			    &ulEnumBufSize,
			    (TC_IFC_DESCRIPTOR*) buff);

		    // We expect ERROR_INSUFFICIENT_BUFFER
		    if (dwRet == ERROR_INSUFFICIENT_BUFFER)
            {
			    // Don't bother to enumerate the interfaces - 
                // we now know PSched is installed. 
			    a_pInst->Setbool( L"SupportsGuaranteedBandwidth", TRUE ) ;
                dwRet = ERROR_SUCCESS;
            }
            else
            {
                a_pInst->Setbool( L"SupportsGuaranteedBandwidth", FALSE ) ;
                dwRet = ERROR_SUCCESS;
            }
	    }

	    // De-register the TC client
	    TcDeregisterClient(hClient);
        hClient = INVALID_HANDLE_VALUE;
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        if(hClient != INVALID_HANDLE_VALUE)
        {
            TcDeregisterClient(hClient);
            hClient = INVALID_HANDLE_VALUE;
        }
        dwRet = ERROR_DLL_NOT_FOUND;
    }
    catch(...)
    {
        if(hClient != INVALID_HANDLE_VALUE)
        {
            TcDeregisterClient(hClient);
            hClient = INVALID_HANDLE_VALUE;
        }
        throw;
    }    

	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\protocol.h ===
//=================================================================

//

// Protocol.h -- Network Protocol property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//				 1/21/98	jennymc   Added protocol classes to deal
//									  with different socket versions
//=================================================================
#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_


// Property set identification
//============================

#define PROPSET_NAME_PROTOCOL L"Win32_NetworkProtocol"

class CProtocol
{
	public:
		CProtocol();
		virtual ~CProtocol();
		virtual BOOL BeginEnumeration()=0;
		virtual BOOL GetProtocol(CInstance *pInstance,CHString chsName)=0;

	protected:		
		void Init();
		BOOL SetDateFromFileName( CHString &a_chsFileName, CInstance *a_pInstance ) ;

		BYTE * m_pbBuffer;
		int    m_nTotalProtocols;
		int    m_nCurrentProtocol;
};

class CSockets22 : public CProtocol
{
	public:	
		BOOL BeginEnumeration();
		BOOL GetProtocol(CInstance *pInstance,CHString chsName);
		CSockets22();
		~CSockets22();
	private:

		BOOL					m_fAlive;
		CWs2_32Api             *m_pws32api;
		LPWSAPROTOCOL_INFO		m_pInfo;

		void LoadProtocol(CInstance *pInstance);
		void GetSocketInfo( CInstance *a_pInst, LPWSAPROTOCOL_INFO a_pInfo, CHString &a_chsStatus ) ;
		void ExtractNTRegistryInfo(CInstance *pInstance, LPWSTR szService);
        DWORD GetTrafficControlInfo(CInstance *a_pInst);
};		

class CSockets11 : public CProtocol
{
	public:	
		BOOL BeginEnumeration();
		BOOL GetProtocol(CInstance *pInstance,CHString chsName);
		CSockets11();
		~CSockets11();
	private:
		BOOL			m_fAlive;
		CWsock32Api		*m_pwsock32api;
		PROTOCOL_INFO	*m_pInfo;

		void GetStatus( PROTOCOL_INFO *a_ProtoInfo, CHString &a_chsStatus ) ;
		void LoadProtocol(CInstance *pInstance);
		void GetWin95RegistryStuff(CInstance *pInstance, LPTSTR szProtocol);

};

class CProtocolEnum
{
	public:
		CProtocolEnum();
		~CProtocolEnum();
		BOOL InitializeSockets();
		BOOL GetProtocol(CInstance *pInstance,CHString chsName);

	private:
		CProtocol * m_pProtocol;
};
//=====================================================================

class CWin32Protocol:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32Protocol(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32Protocol() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:
		BOOL EnumProtocolsTheOldWay(CInstance *pInstance,MethodContext * pMethod);
		BOOL EnumerateProtocols(CInstance *pInstance,MethodContext * pMethod);
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\qfe.cpp ===
//=================================================================

//

// CQfe.cpp -- quick fix engineering property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/01/99    a-peterc        Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "Qfe.h"


// Property set declaration
//=========================

CQfe MyCQfe ( PROPSET_NAME_CQfe , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::CQfe
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CQfe :: CQfe (

	LPCWSTR a_name,
	LPCWSTR a_pszNamespace

) : Provider ( a_name , a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::CQfe
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CQfe::~CQfe()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CQfe::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
  	HRESULT	t_hResult = WBEM_E_NOT_FOUND ;
	CQfeArray t_oQfeArray ;

	HRESULT t_hRes = hGetQfes ( t_oQfeArray ) ;
	if ( SUCCEEDED ( t_hRes ) )
	{
		CHString t_chsHotFixID;
		CHString t_chsServicePackInEffect;

		a_pInst->GetCHString( L"HotFixID", t_chsHotFixID ) ;

		if( !a_pInst->IsNull ( L"ServicePackInEffect" ) )
		{
			a_pInst->GetCHString( L"ServicePackInEffect", t_chsServicePackInEffect ) ;
		}

		for( int t_iCtrIndex = 0; t_iCtrIndex < t_oQfeArray.GetSize(); t_iCtrIndex++ )
		{
			CQfeElement *t_pQfeElement = (CQfeElement*)t_oQfeArray.GetAt( t_iCtrIndex ) ;

			// two keys for this class
			if( !t_chsHotFixID.CompareNoCase( t_pQfeElement->chsHotFixID ) &&
				!t_chsServicePackInEffect.CompareNoCase( t_pQfeElement->chsServicePackInEffect ) )
			{
				if( t_chsServicePackInEffect.IsEmpty() )
				{
					// populated the empty key
					a_pInst->SetCHString( L"ServicePackInEffect", t_pQfeElement->chsServicePackInEffect ) ;
				}

				a_pInst->SetCHString( L"Description",			t_pQfeElement->chsFixDescription ) ;
				a_pInst->SetCHString( L"FixComments",			t_pQfeElement->chsFixComments ) ;
				a_pInst->SetCHString( L"InstalledBy",			t_pQfeElement->chsInstalledBy ) ;
				a_pInst->SetCHString( L"InstalledOn",			t_pQfeElement->chsInstalledOn ) ;
				a_pInst->SetCHString( L"CSName",				GetLocalComputerName() ) ;

				t_hResult = WBEM_S_NO_ERROR ;
			}
		}
	}

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CQfe :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/
)
{
	HRESULT	t_hResult = WBEM_E_NOT_FOUND;

	CQfeArray	t_oQfeArray ;
	HRESULT		t_hRes = hGetQfes ( t_oQfeArray ) ;

	if ( SUCCEEDED ( t_hRes ) )
	{
		for( int t_iCtrIndex = 0; t_iCtrIndex < t_oQfeArray.GetSize(); t_iCtrIndex++ )
		{
			CQfeElement *t_pQfeElement = (CQfeElement*)t_oQfeArray.GetAt( t_iCtrIndex ) ;

			CInstancePtr t_pInst(CreateNewInstance ( a_pMethodContext ), false);

			if ( t_pInst )
			{
				t_pInst->SetCHString( L"HotFixID",				t_pQfeElement->chsHotFixID ) ;
				t_pInst->SetCHString( L"ServicePackInEffect",	t_pQfeElement->chsServicePackInEffect ) ;
				t_pInst->SetCHString( L"Description",			t_pQfeElement->chsFixDescription ) ;
				t_pInst->SetCHString( L"FixComments",			t_pQfeElement->chsFixComments ) ;
				t_pInst->SetCHString( L"InstalledBy",			t_pQfeElement->chsInstalledBy ) ;
				t_pInst->SetCHString( L"InstalledOn",			t_pQfeElement->chsInstalledOn ) ;
	 			t_pInst->SetCHString( L"CSName",				GetLocalComputerName() ) ;

				t_hResult = t_pInst->Commit(  );
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CQfe::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CQfe :: hGetQfes ( CQfeArray& a_rQfeArray )
{

	CHString t_chsHotFixKey (_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix"));

	// Under Hotfix

	CRegistry t_oRegistry;

	if ( ERROR_SUCCESS == t_oRegistry.OpenAndEnumerateSubKeys ( HKEY_LOCAL_MACHINE , t_chsHotFixKey , KEY_READ ) )
	{
		CHString t_csQFEInstKey ;

		// Walk through each instance under this key.

		while (	( ERROR_SUCCESS == t_oRegistry.GetCurrentSubKeyName ( t_csQFEInstKey ) ) )
		{
			CHString t_csQFECompleteKey;

			t_csQFECompleteKey = t_chsHotFixKey;
			t_csQFECompleteKey += _T("\\");
			t_csQFECompleteKey += t_csQFEInstKey;

			// If pre NT4 SP4 the key starts with a "Q". No SP info
			if( -1 != t_csQFEInstKey.Find( (CHString) "Q" ) )
			{
				CQfeElement *t_pElement = new CQfeElement ;
				if ( t_pElement )
				{
					try
					{
						// build the keys
						TCHAR t_chDelimiter = ',';
						int t_iTokLen = t_csQFEInstKey.Find( t_chDelimiter );

						if( -1 == t_iTokLen )
						{
							t_pElement->chsHotFixID = t_csQFEInstKey ;
						}
						else
						{
							t_pElement->chsHotFixID = t_csQFEInstKey.Left( t_iTokLen ) ;
						}

						t_pElement->chsServicePackInEffect = "" ;

						// open the hotfix

						CRegistry t_oRegistry2 ;

						if ( ERROR_SUCCESS == t_oRegistry2.Open (	HKEY_LOCAL_MACHINE,
																	t_csQFECompleteKey,
																	KEY_READ ) )
						{
							t_oRegistry2.GetCurrentKeyValue( L"Fix Description",t_pElement->chsFixDescription ) ;
							t_oRegistry2.GetCurrentKeyValue( L"Comments",		t_pElement->chsFixComments ) ;
							t_oRegistry2.GetCurrentKeyValue( L"Installed By",	t_pElement->chsInstalledBy ) ;
							t_oRegistry2.GetCurrentKeyValue( L"Installed On",	t_pElement->chsInstalledOn ) ;
							t_oRegistry2.GetCurrentKeyValue( L"Installed",		t_pElement->dwInstalled ) ;

							try
							{
								a_rQfeArray.Add ( t_pElement ) ;
							}
							catch ( ... )
							{
								t_pElement = NULL ;

								throw ;
							}
						}
					}
					catch ( ... )
					{
						if ( t_pElement )
						{
							delete t_pElement ;
						}
                        throw;
					}
				}
			}
			else // else by service pack
			{
				CRegistry t_oRegistry2 ;
				if ( ERROR_SUCCESS == t_oRegistry2.OpenAndEnumerateSubKeys ( HKEY_LOCAL_MACHINE ,
																			 t_csQFECompleteKey ,
																			 KEY_READ ) )
				{
					CHString t_csSpQFEInstKey;
                    CHString t_csSPName;

                    int j = t_csQFECompleteKey.ReverseFind(L'\\');
                    if(j != -1)
                    {
                        t_csSPName = t_csQFECompleteKey.Mid(j+1);
                    }

					// Hotfixes within a SP
					while (	(ERROR_SUCCESS == t_oRegistry2.GetCurrentSubKeyName( t_csSpQFEInstKey ) ) )
					{
						CQfeElement *t_pElement = new CQfeElement ;
						if ( t_pElement )
						{
							try
							{
								// build the keys
								TCHAR t_chDelimiter = ',';
								int t_iTokLen = t_csSpQFEInstKey.Find( t_chDelimiter ) ;

								if ( -1 == t_iTokLen )
								{
									t_pElement->chsHotFixID = t_csSpQFEInstKey ;
								}
								else
								{
									t_pElement->chsHotFixID = t_csSpQFEInstKey.Left( t_iTokLen ) ;
								}

								t_pElement->chsServicePackInEffect = t_csSPName ;

								// open the hotfix
								CHString t_csSpQFECompleteKey ;

								 t_csSpQFECompleteKey = t_csQFECompleteKey ;
								 t_csSpQFECompleteKey += _T("\\") ;
								 t_csSpQFECompleteKey += t_csSpQFEInstKey ;

								CRegistry t_oRegistry3 ;

								if (ERROR_SUCCESS == t_oRegistry3.Open(	HKEY_LOCAL_MACHINE,
																		t_csSpQFECompleteKey,
																		KEY_READ ) )
								{
									t_oRegistry3.GetCurrentKeyValue( L"Fix Description",t_pElement->chsFixDescription ) ;
									t_oRegistry3.GetCurrentKeyValue( L"Comments",		t_pElement->chsFixComments ) ;
									t_oRegistry3.GetCurrentKeyValue( L"Installed By",	t_pElement->chsInstalledBy ) ;
									t_oRegistry3.GetCurrentKeyValue( L"Installed On",	t_pElement->chsInstalledOn ) ;
									t_oRegistry3.GetCurrentKeyValue( L"Installed",		t_pElement->dwInstalled ) ;
								}

								try
								{
									a_rQfeArray.Add( t_pElement ) ;
								}
								catch ( ... )
								{
									t_pElement = NULL ;

									throw ;
								}
							}
							catch ( ... )
							{
								if ( t_pElement )
								{
									delete t_pElement ;
								}

								throw ;
							}
						}
                        t_oRegistry2.NextSubKey();
					}
				}
			}
			t_oRegistry.NextSubKey() ;
		}
	}

    // Now get info from the W2K and later portion of the registry...
    hGetQfesW2K(a_rQfeArray);

	return WBEM_S_NO_ERROR ;
}


// On Windows 2000 and later, QFEs are stored under the following key:
// HKEY_LOCAL_MACHINE\software\Microsoft\Updates\<product>\<updateID>", 
// where product might be something like "WMI", and updateID might be
// something like Q123456.
HRESULT CQfe :: hGetQfesW2K ( CQfeArray& a_rQfeArray )
{
    HRESULT hrRet = WBEM_S_NO_ERROR;
	
    CHString t_chsUpdateKey (_T("SOFTWARE\\Microsoft\\Updates"));

	// Under Hotfix

	CRegistry t_oRegistry;

	if ( ERROR_SUCCESS == t_oRegistry.OpenAndEnumerateSubKeys ( HKEY_LOCAL_MACHINE , t_chsUpdateKey , KEY_READ ) )
	{
		CHString t_csQFEProductKey ;

		// Walk through each instance under this key. Each instance under this key
        // is the <product>.

		while (	( ERROR_SUCCESS == t_oRegistry.GetCurrentSubKeyName ( t_csQFEProductKey ) ) )
		{
			CHString t_csQFEProductCompleteKey;

			t_csQFEProductCompleteKey = t_chsUpdateKey;
			t_csQFEProductCompleteKey += _T("\\");
			t_csQFEProductCompleteKey += t_csQFEProductKey;


			// Now we need to look under the product entries to get the updateID
            // keys.

			CRegistry t_oRegistry2 ;
			if ( ERROR_SUCCESS == t_oRegistry2.OpenAndEnumerateSubKeys ( HKEY_LOCAL_MACHINE ,
																		 t_csQFEProductCompleteKey ,
																		 KEY_READ ) )
			{
				CHString t_csQFEUpdateIDKey;

				while (	(ERROR_SUCCESS == t_oRegistry2.GetCurrentSubKeyName( t_csQFEUpdateIDKey ) ) )
				{
					CHString t_csQFEUpdateIDCompleteKey;
                    
                    t_csQFEUpdateIDCompleteKey = t_csQFEProductCompleteKey;
                    t_csQFEUpdateIDCompleteKey += _T("\\");
                    t_csQFEUpdateIDCompleteKey += t_csQFEUpdateIDKey;

                    // Now, as an added wrinkle, the updateID key might be the Q number (e.g., Q12345),
                    // or, in the case of service packs, just another grouping, under which in turn the
                    // Q numbers appear.  We can tell if it is just another grouping key by checking 
                    // whether there is a Description value.  If there is not one, we will assume it is
                    // a grouping key.

                    // Check if the Description value is present...
                    CRegistry t_oRegistry3;

                    if(ERROR_SUCCESS == t_oRegistry3.Open(	
                        HKEY_LOCAL_MACHINE,
						t_csQFEUpdateIDCompleteKey,
						KEY_READ))
                    {
                        CHString chsDescription;
                        if(t_oRegistry3.GetCurrentKeyValue(L"Description", chsDescription) == ERROR_SUCCESS)
                        {
                            // This is the level at which the QFE data exists.  Continue to collect the data.
                            GetDataForW2K(
                                t_csQFEUpdateIDKey,
                                L"",
                                t_oRegistry3,
                                a_rQfeArray);
                        }
                        else
                        {
                            // We are at a "grouping" level (e.g., something like SP1), so need to go
                            // one level deeper.
                            CHString t_csQFEDeeperUpdateIDKey;

                            if ( ERROR_SUCCESS == t_oRegistry3.OpenAndEnumerateSubKeys(
                                HKEY_LOCAL_MACHINE ,
								t_csQFEUpdateIDCompleteKey ,
								KEY_READ))
                            {
                                while (	(ERROR_SUCCESS == t_oRegistry3.GetCurrentSubKeyName( t_csQFEDeeperUpdateIDKey ) ) )
				                {
                                    CHString t_csQFEDeeperUpdateIDCompleteKey;
                    
                                    t_csQFEDeeperUpdateIDCompleteKey = t_csQFEUpdateIDCompleteKey;
                                    t_csQFEDeeperUpdateIDCompleteKey += _T("\\");
                                    t_csQFEDeeperUpdateIDCompleteKey += t_csQFEDeeperUpdateIDKey;

                                    CRegistry t_oRegistry4;

                                    if(ERROR_SUCCESS == t_oRegistry4.Open(	
                                        HKEY_LOCAL_MACHINE,
						                t_csQFEDeeperUpdateIDCompleteKey,
						                KEY_READ))
                                    {

                                        if(t_oRegistry4.GetCurrentKeyValue(L"Description", chsDescription) == ERROR_SUCCESS)
                                        {
                                            GetDataForW2K(
                                                t_csQFEDeeperUpdateIDKey,
                                                t_csQFEUpdateIDKey,
                                                t_oRegistry4, 
                                                a_rQfeArray);
                                        }
                                    }
                                
                                    // there might be other grouping keys at this level...
                                    t_oRegistry3.NextSubKey();
                                }
                            }
                        }        
                    }
                    // Now go to the next update ID key...
                    t_oRegistry2.NextSubKey();
				}
			}
            // Now get the next product key...
			t_oRegistry.NextSubKey() ;
		}
	}

	return hrRet ;
}

HRESULT CQfe::GetDataForW2K(
    const CHString& a_chstrQFEInstKey,
    LPCWSTR wstrServicePackOrGroup,
    CRegistry& a_reg,
    CQfeArray& a_rQfeArray)
{
    HRESULT hrRet = WBEM_S_NO_ERROR;

    CQfeElement *t_pElement = new CQfeElement;
	if(t_pElement)
	{
		try
		{
			// build the keys
			TCHAR t_chDelimiter = ',';
			int t_iTokLen = a_chstrQFEInstKey.Find( t_chDelimiter ) ;

			if ( -1 == t_iTokLen )
			{
				t_pElement->chsHotFixID = a_chstrQFEInstKey ;
			}
			else
			{
				t_pElement->chsHotFixID = a_chstrQFEInstKey.Left( t_iTokLen ) ;
			}

			t_pElement->chsServicePackInEffect = wstrServicePackOrGroup ;
            
            {
				a_reg.GetCurrentKeyValue( L"Description",t_pElement->chsFixDescription ) ;
				a_reg.GetCurrentKeyValue( L"Type",		t_pElement->chsFixComments ) ;
				a_reg.GetCurrentKeyValue( L"InstalledBy",	t_pElement->chsInstalledBy ) ;
				a_reg.GetCurrentKeyValue( L"InstallDate",	t_pElement->chsInstalledOn ) ;
				a_reg.GetCurrentKeyValue( L"Installed",		t_pElement->dwInstalled ) ;
			}

			try
			{
				a_rQfeArray.Add(t_pElement);
			}
			catch(...)
			{
				t_pElement = NULL;
				throw;
			}
		}
		catch(...)
		{
			if(t_pElement)
			{
				delete t_pElement;
                t_pElement = NULL;
			}
			throw;
		}
	}

    return hrRet;
}

//
CQfeElement :: CQfeElement ()
{
	dwInstalled = 0 ;
}

CQfeElement::~CQfeElement()
{
}


CQfeArray::CQfeArray()
{
}

CQfeArray::~CQfeArray()
{
	CQfeElement *t_pQfeElement ;

	for ( int t_iar = 0; t_iar < GetSize(); t_iar++ )
	{
		if( t_pQfeElement = (CQfeElement*)GetAt( t_iar ) )
		{
			delete t_pQfeElement ;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\protocolbinding.cpp ===
//=================================================================

//

// ProtocolBinding.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "protocolbinding.h"


// The Map we will use below is an STL Template, so make sure we have the std namespace
// available to us.

using namespace std;

// Property set declaration
//=========================

CWin32ProtocolBinding	win32ProtocolBinding( PROPSET_NAME_NETCARDtoPROTOCOL, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProtocolBinding::CWin32ProtocolBinding
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32ProtocolBinding::CWin32ProtocolBinding(LPCWSTR strName, LPCWSTR pszNamespace /*=NULL*/ )
:	Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32ProtocolBinding::~CWin32ProtocolBinding
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32ProtocolBinding::~CWin32ProtocolBinding()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32ProtocolBinding::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32ProtocolBinding::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	// Instances to mess around with
	CInstancePtr	pAdapter;
    CInstancePtr	pProtocol;
	CHString		strAdapterPath,
					strProtocolPath,
					strAdapterSystemName,
					strProtocolName;
	HRESULT		hr;

	//
	pInstance->GetCHString( IDS_Device, strAdapterPath );
	pInstance->GetCHString( IDS_Antecedent, strProtocolPath );

    // Perform queries
    //================

	if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(strAdapterPath,
		&pAdapter, pInstance->GetMethodContext())) &&
		SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strProtocolPath,
		&pProtocol, pInstance->GetMethodContext())))
	{

		// Get values necessary to determine association

		if (	pAdapter->GetCHString( IDS_ProductName, strAdapterSystemName )
			&&	pProtocol->GetCHString( IDS_Caption, strProtocolName ) )
		{
			BOOL fReturn = FALSE;

			// If the protocol and adapter are associated, we need to create
			// a new instance, fill it up with binding information and commit.
#ifdef NTONLY
			if(IsWinNT5())
            {
                CHString chstrAdapterDeviceID;
                if(pAdapter->GetCHString(IDS_DeviceID, chstrAdapterDeviceID))
                {
                    if(LinkageExistsNT5(chstrAdapterDeviceID, strProtocolName))
                    {
                        fReturn = SetProtocolBinding(pAdapter, pProtocol, pInstance);
                    }
                }
            }
            else if ( LinkageExists( strAdapterSystemName, strProtocolName ) )
			{

				// Try to finalize object values now.

				fReturn = SetProtocolBinding( pAdapter, pProtocol, pInstance );

			}	// IF Linkage Exists
#endif

			hr = fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;

		}	// IF Got strings

	}	// IF Got Instances

	return hr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32ProtocolBinding::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32ProtocolBinding::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
	BOOL		fReturn		=	FALSE;
	HRESULT		hr			=	WBEM_S_NO_ERROR;

	// Our instance lists.
	TRefPointerCollection<CInstance>	adapterList;
	TRefPointerCollection<CInstance>	protocolList;

	// Instances to mess around with
	CInstancePtr		pAdapter ;

    // Perform queries
    //================

//	if (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_NetworkAdapter"),
//		&adapterList, NULL, pMethodContext)) &&
//		SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_NetworkProtocol"),
//		&protocolList, NULL, pMethodContext)))

	if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select DeviceID, ProductName, ServiceName from Win32_NetworkAdapter",
		&adapterList, pMethodContext, GetNamespace())) &&
		SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select Name, Caption from Win32_NetworkProtocol",
		&protocolList, pMethodContext, GetNamespace())))
	{
		REFPTRCOLLECTION_POSITION	posAdapter;

		if ( adapterList.BeginEnum( posAdapter ) )
		{
			// Order is important.  Check hr first so we don't get another adapter, and
			// orphan it by not releasing it.

			for (pAdapter.Attach(adapterList.GetNext( posAdapter ));
                 (WBEM_S_NO_ERROR == hr) &&	(pAdapter != NULL );
                  pAdapter.Attach(adapterList.GetNext( posAdapter )))
			{

				hr = EnumProtocolsForAdapter( pAdapter, pMethodContext, protocolList );

			}	// for GetNext Adapter

			adapterList.EndEnum();

		}	// If BeginEnum

	}	// If GetAllInstances

	return hr;

}

HRESULT CWin32ProtocolBinding::EnumProtocolsForAdapter(
CInstance*							pAdapter,
MethodContext*						pMethodContext,
TRefPointerCollection<CInstance>&	protocolList
)
{
	HRESULT		hr	= WBEM_S_NO_ERROR;

	// Instances to mess around with
	CInstancePtr		pProtocol;
	CInstancePtr		pInstance;
	CHString		strAdapterSystemName,
					strProtocolName;

	REFPTRCOLLECTION_POSITION	posProtocol;

	if ( protocolList.BeginEnum( posProtocol ) )
	{
		// Order is important.  Check hr first so we don't get another protocol, and
		// orphan it by not releasing it.

		for (pProtocol.Attach(protocolList.GetNext( posProtocol )) ;
            WBEM_S_NO_ERROR == hr && ( pProtocol != NULL );
            pProtocol.Attach(protocolList.GetNext( posProtocol )) )
		{

			// We need the adapter's service name and the protocol's name

			if (	!pAdapter->IsNull( IDS_ServiceName )
				&&	pAdapter->GetCHString( IDS_ServiceName, strAdapterSystemName )
				&&	pProtocol->GetCHString( IDS_Caption, strProtocolName ) )
			{

				// If the protocol and adapter are associated, we need to create
				// a new instance, fill it up with binding information and commit.

				// unless we are in Win 95 or '98.  Then there is no linkage. It just works.
#ifdef NTONLY
                if(IsWinNT5())
                {
                    CHString chstrAdapterDeviceID;
                    if(pAdapter->GetCHString(IDS_DeviceID, chstrAdapterDeviceID))
                    {
                        if(LinkageExistsNT5(chstrAdapterDeviceID, strProtocolName))
                        {
                            pInstance.Attach(CreateNewInstance( pMethodContext ));
					        if ( NULL != pInstance )
					        {
						        // Commit the instance
						        if ( SetProtocolBinding( pAdapter, pProtocol, pInstance ) )
						        {
							        hr = pInstance->Commit(  );
						        }
					        }
					        else
					        {
						        hr = WBEM_E_OUT_OF_MEMORY;
					        }
                        }
                    }
                }
				else
                {
                    // The actual service name is stored in Win32_NetworkAdapter.ServiceName.  However,
                    // for NT4, we need the 'instance' name, which is stored in ProductName (don't ask
                    // me why).
                    pAdapter->GetCHString( IDS_ProductName, strAdapterSystemName);
                    if ( LinkageExists( strAdapterSystemName, strProtocolName ) )  // i.e., neither NT5 nor Win9x
				    {

					    pInstance.Attach(CreateNewInstance( pMethodContext ));

					    if ( NULL != pInstance )
					    {

						    // Commit the instance
						    if ( SetProtocolBinding( pAdapter, pProtocol, pInstance ) )
						    {
							    hr = pInstance->Commit(  );
						    }
					    }
					    else
					    {
						    hr = WBEM_E_OUT_OF_MEMORY;
					    }

				    }	// IF Linkage Exists
                }
#endif

			}	// IF Got required values

		}	// WHILE GetNext Protocol

		protocolList.EndEnum();

	}	// IF BeginEnum

	return hr;

}

bool CWin32ProtocolBinding::SetProtocolBinding(
CInstance*	pAdapter,
CInstance*	pProtocol,
CInstance*	pProtocolBinding
)
{
	bool		fReturn = FALSE;

	// Instances to mess around with
	CInstancePtr	pService;

	CHString		strAdapterServiceName,
					strServicePath,
					strProtocolPath,
					strAdapterPath;

#ifdef NTONLY
   {
	   // Use the product name from the Adapter Instance to get a Win32 Service, and
	   // then set our paths in the protocol binding instance

	   pAdapter->GetCHString( IDS_ServiceName, strAdapterServiceName );

	   // We must release this instance when we are through with it.
	   CHString strPath;
	   strPath.Format(	_T("\\\\%s\\%s:Win32_SystemDriver.Name=\"%s\""),
						(LPCTSTR) GetLocalComputerName(),
						IDS_CimWin32Namespace,
						(LPCTSTR) strAdapterServiceName );


	   if (SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(strPath, &pService, pAdapter->GetMethodContext())))
	   {
		   // Load all three paths, and if that succeeds, we can create
		   // a new instance

		   if (	GetLocalInstancePath( pAdapter, strAdapterPath )
			   &&	GetLocalInstancePath( pProtocol, strProtocolPath )
			   &&	GetLocalInstancePath( pService, strServicePath ) )
		   {

			   pProtocolBinding->SetCHString( IDS_Device, strAdapterPath );
			   pProtocolBinding->SetCHString( IDS_Antecedent, strProtocolPath );
			   pProtocolBinding->SetCHString( IDS_Dependent, strServicePath );

			   fReturn = TRUE;

		   }	// IF Get Paths

	   }	// IF GetEmptyInstance
   }
#endif

	return fReturn;

}

BOOL CWin32ProtocolBinding::LinkageExistsNT5(CHString& chstrAdapterDeviceID, CHString& chstrProtocolName)
{
    bool fRetCode = false ;
    CRegistry RegInfo;
    CRegistry RegAdapter;
	CHString strTemp;
    CHString strDevice;
    DWORD x;
    DWORD y;
    DWORD dwSize;
    CHStringArray asBindings;

    // This is where the bindings for this PROTOCOL are stored
	strTemp.Format( L"System\\CurrentControlSet\\Services\\%s\\Linkage",
        (LPCWSTR) chstrProtocolName);
    // Open it
    if( RegInfo.Open( HKEY_LOCAL_MACHINE, strTemp, KEY_READ ) == ERROR_SUCCESS )
	{
        // Read all the bindings (drivers supporting this protocol) into a chstringarray
        if (RegInfo.GetCurrentKeyValue(L"Bind", asBindings) == ERROR_SUCCESS)
		{
            // Walk the list looking for a 'match'
            dwSize = asBindings.GetSize();
            // Here is where we differ from the standard LinkageExists routine.  For NT5,
            // we need to look at the registry entry for this device.  Under the class for
            // network adapters (which is
            // HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318} )
            // are numeric entries, which (by our design) correspond to the DeviceIDs of
            // the network adapters.  Under each numeric subkey is a subkey "Linkage".
            // "Linkage" has a REG_MULTI_SZ value "Bind" that lists all the protocols bound
            // by this adapter.  For each of these strings in the multi-sz array, need to look
            // at each string in the multi-sz array opened up above (the Linkage subkey under
            // Services).  If and when we find a match, we are done.

            CHStringArray asAdapterBindings;
            WCHAR* tcEnd = NULL;
            LONG lNum = wcstol(chstrAdapterDeviceID,&tcEnd,10);
            strTemp.Format(L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\%04d\\Linkage",
                           lNum);
            if(RegAdapter.Open(HKEY_LOCAL_MACHINE, strTemp, KEY_READ ) == ERROR_SUCCESS)
            {
                // Read all the protocols supported by the adapter driver (usually only one):
                if(RegAdapter.GetCurrentKeyValue(L"Export", asAdapterBindings) == ERROR_SUCCESS)
                {
                    DWORD dwAdapterSize = asAdapterBindings.GetSize();
                    for(y=0L; y < dwAdapterSize && (!fRetCode); y++)
                    {
                        for (x=0L; (x < dwSize) && (!fRetCode); x++)
			            {
                            if(asBindings[x].CompareNoCase(asAdapterBindings[y]) == 0)
				            {
                                fRetCode = true ;
                            }
                        }
                    }
                }
            }
        }
    }
    return fRetCode;
}

BOOL CWin32ProtocolBinding::LinkageExists( LPCTSTR pszSystemName, LPCTSTR pszProtocolName)
{
    bool bRetCode = false ;
    CRegistry RegInfo, RegProt ;

    CHString	strTemp, strDevice;

    DWORD x, dwSize;

#ifdef NTONLY
    {
        CHStringArray asBindings;

        // This is where the bindings for this card are stored
        strTemp.Format( _T("System\\CurrentControlSet\\Services\\%s\\Linkage"), pszProtocolName );

        // Open it
        if( RegInfo.Open( HKEY_LOCAL_MACHINE, strTemp, KEY_READ ) == ERROR_SUCCESS )
        {
            // Read all the bindings into a chstringarray
            if (RegInfo.GetCurrentKeyValue(_T("Bind"), asBindings) == ERROR_SUCCESS)
            {
                // Walk the list looking for a 'match'
                dwSize = asBindings.GetSize();
                strDevice = _T("\\Device\\");
                strDevice += pszSystemName;

                for (x=0; (x < dwSize) && (!bRetCode); x++)
                {
                    if (asBindings[x].CompareNoCase(strDevice) == 0)
                    {

                        bRetCode = true ;
                    }
                }
            }
        }
    }
#endif

    return bRetCode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\protocolbinding.h ===
//=================================================================

//

// ProtocolBinding.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __ASSOC_PROTOCOLBINDING__
#define __ASSOC_PROTOCOLBINDING__

// Property set identification
//============================

#define	PROPSET_NAME_NETCARDtoPROTOCOL	L"Win32_ProtocolBinding"

class CWin32ProtocolBinding : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32ProtocolBinding( LPCWSTR strName, LPCWSTR pszNamespace = NULL ) ;
       ~CWin32ProtocolBinding() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility
        //========

        // Utility function(s)
        //====================

    private:

        // Utility function(s)
        //====================

		HRESULT EnumProtocolsForAdapter(	CInstance*		pAdapter,
											MethodContext*	pMethodContext,
											TRefPointerCollection<CInstance>&	protocolList );

		bool SetProtocolBinding(	CInstance*	pAdapter,
									CInstance*	pProtocol,
									CInstance*	pProtocolBinding );

        BOOL LinkageExists( LPCTSTR pszServiceName, LPCTSTR pszProtocolName ) ;
        BOOL LinkageExistsNT5(CHString& chstrAdapterDeviceID, CHString& chstrProtocolName);
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\recovery.h ===
//=================================================================

//

// Recovery.h -- OS Recovery Configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/97    davwoh         Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_RECOVERY_CONFIGURATION L"Win32_OSRecoveryConfiguration"

class CWin32OSRecoveryConfiguration:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32OSRecoveryConfiguration(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32OSRecoveryConfiguration() ;

        // Funcitons provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);

    private:
       void GetRecoveryInfo(CInstance *pInstance);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\qfe.h ===
//=================================================================

//

// qfe.h -- quick fix engineering property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/01/99    a-peterc        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_CQfe L"Win32_QuickFixEngineering"

class CQfeArray : public CHPtrArray 
{
    public:

        // Constructor/destructor
        //=======================

        CQfeArray() ;
       ~CQfeArray() ;
} ;

class CQfeElement
 {
    public:

        // Constructor/destructor
        //=======================

        CQfeElement() ;
       ~CQfeElement() ;

        
	   CHString chsHotFixID ;
	   CHString chsServicePackInEffect ;
	   CHString chsFixDescription ;
	   CHString chsFixComments ;
	   CHString chsInstalledBy ;
	   CHString chsInstalledOn ;
	   DWORD	dwInstalled ;
} ;

    
class CQfe : public Provider 
{
    public:

        // Constructor/destructor
        //=======================

        CQfe(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CQfe() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
		HRESULT hGetQfes( CQfeArray& a_rQfeArray ) ;

    private:

        HRESULT hGetQfesW2K(CQfeArray& a_rQfeArray);
        
        HRESULT GetDataForW2K(
            const CHString& a_chstrQFEInstKey,
            LPCWSTR wstrServicePackOrGroup,
            CRegistry& a_reg,
            CQfeArray& a_rQfeArray);
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\recovery.cpp ===
//=================================================================

//

// Recovery.h -- OS Recovery Configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/97    davwoh         Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "SystemName.h"

#include "Recovery.h"

// Property set declaration
//=========================

CWin32OSRecoveryConfiguration CWin32OSRecoveryConfiguration ( PROPSET_NAME_RECOVERY_CONFIGURATION , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::CWin32OSRecoveryConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32OSRecoveryConfiguration :: CWin32OSRecoveryConfiguration (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::~CWin32OSRecoveryConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32OSRecoveryConfiguration :: ~CWin32OSRecoveryConfiguration ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    : Returns info for running OS only until we discover other
 *                installed OSes
 *
 *****************************************************************************/

HRESULT CWin32OSRecoveryConfiguration :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
#ifdef NTONLY

    CSystemName cSN;

    // Not our object path
    if (!cSN.ObjectIsUs(pInstance))
	{
         return WBEM_E_NOT_FOUND;
	}

    GetRecoveryInfo ( pInstance ) ;

    return WBEM_S_NO_ERROR;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    : Returns only running OS info until we discover installed OSes
 *
 *****************************************************************************/

HRESULT CWin32OSRecoveryConfiguration :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
#ifdef NTONLY
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pInstance(CreateNewInstance ( pMethodContext), false) ;

	CSystemName cSN;
	cSN.SetKeys ( pInstance ) ;

	GetRecoveryInfo ( pInstance ) ;

	hr = pInstance->Commit ( ) ;

    return hr;

#endif

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::GetRecoveryInfo
 *
 *  DESCRIPTION : Assigns property values according to currently running OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32OSRecoveryConfiguration :: GetRecoveryInfo (

	CInstance *pInstance
)
{
	CRegistry RegInfo ;
	RegInfo.Open(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\CrashControl", KEY_READ);

	DWORD dwValue ;
	if ( RegInfo.GetCurrentKeyValue( L"LogEvent", dwValue) == ERROR_SUCCESS )
	{
      pInstance->Setbool( L"WriteToSystemLog", dwValue);
	}
	else
	{
		pInstance->Setbool( L"WriteToSystemLog", false);
	}

	if ( RegInfo.GetCurrentKeyValue( L"SendAlert", dwValue) == ERROR_SUCCESS )
	{
		pInstance->Setbool( L"SendAdminAlert", dwValue);
	}
	else
	{
		pInstance->Setbool( L"SendAdminAlert", false);
	}

	if ( RegInfo.GetCurrentKeyValue( L"CrashDumpEnabled", dwValue) == ERROR_SUCCESS)
	{
		pInstance->Setbool( L"WriteDebugInfo", dwValue);
		pInstance->SetDWORD( L"DebugInfoType", dwValue);
	}
	else
	{
		pInstance->Setbool( L"WriteDebugInfo", false);
		pInstance->SetDWORD( L"DebugInfoType", 0);
	}

	if ( RegInfo.GetCurrentKeyValue ( L"Overwrite", dwValue) == ERROR_SUCCESS )
	{
		pInstance->Setbool( L"OverwriteExistingDebugFile", dwValue);
	}
	else
	{
		pInstance->Setbool( L"OverwriteExistingDebugFile", false);
	}

	if ( RegInfo.GetCurrentKeyValue( L"KernelDumpOnly", dwValue) == ERROR_SUCCESS)
	{
		pInstance->Setbool( L"KernelDumpOnly", dwValue);
	}
	else
	{
		pInstance->Setbool( L"KernelDumpOnly", false);
	}

	if ( RegInfo.GetCurrentKeyValue( L"AutoReboot", dwValue) == ERROR_SUCCESS)
	{
		pInstance->Setbool( L"AutoReboot", dwValue);
	}
	else
	{
		pInstance->Setbool( L"AutoReboot", false);
	}

	TCHAR szEnvironment[_MAX_PATH];

	CHString sValue;
	if (RegInfo.GetCurrentKeyValue( L"DumpFile", sValue) == ERROR_SUCCESS)
	{
        pInstance->SetCharSplat( L"DebugFilePath", sValue);
		ExpandEnvironmentStrings(TOBSTRT(sValue), szEnvironment, _MAX_PATH);
	}
	else
	{
        pInstance->SetCharSplat( L"DebugFilePath", _T("%SystemRoot%\\MEMORY.DMP"));
		ExpandEnvironmentStrings( _T("%SystemRoot%\\MEMORY.DMP"), szEnvironment, _MAX_PATH);
	}

	pInstance->SetCharSplat( L"ExpandedDebugFilePath", szEnvironment);

	if (RegInfo.GetCurrentKeyValue( L"MiniDumpDir", sValue) == ERROR_SUCCESS)
	{
    	pInstance->SetCharSplat( L"MinidumpDirectory", sValue);
		ExpandEnvironmentStrings(TOBSTRT(sValue), szEnvironment, _MAX_PATH);
	}
	else
	{
    	pInstance->SetCharSplat( L"MinidumpDirectory", _T("%SystemRoot%\\MINIDUMP"));
		ExpandEnvironmentStrings( _T("%SystemRoot%\\MINIDUMP"), szEnvironment, _MAX_PATH);
	}

	pInstance->SetCharSplat( L"ExpandedMinidumpDirectory", szEnvironment);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32OSRecoveryConfiguration::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : pInstance to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : The only property we write is MaximumSize
 *
 *****************************************************************************/

HRESULT CWin32OSRecoveryConfiguration :: PutInstance (

	const CInstance &pInstance,
	long lFlags /*= 0L*/
)
{
   // Tell the user we can't create a new os (much as we might like to)
	if (lFlags & WBEM_FLAG_CREATE_ONLY)
	{
		return WBEM_E_UNSUPPORTED_PARAMETER;
	}

#ifdef NTONLY

   DWORD dwTemp;

	HRESULT hRet = WBEM_S_NO_ERROR;

   // Not our object path

	CSystemName cSN;
	if (!cSN.ObjectIsUs(&pInstance))
	{
		if ( lFlags & WBEM_FLAG_UPDATE_ONLY )
		{
			hRet = WBEM_E_NOT_FOUND;
		}
		else
		{
			hRet = WBEM_E_UNSUPPORTED_PARAMETER;
		}
	}
	else
	{
		CRegistry RegInfo ;
		RegInfo.Open ( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\CrashControl"), KEY_WRITE);

      // If a value was specified, write it.

		if ( ! pInstance.IsNull ( _T("WriteToSystemLog") ) )
		{
			bool bWrite;
			pInstance.Getbool( _T("WriteToSystemLog"), bWrite);

			if (bWrite)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("LogEvent"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("SendAdminAlert") ) )
		{
			bool bSend;
			pInstance.Getbool( _T("SendAdminAlert"), bSend);

			if (bSend)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("SendAlert"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if (!pInstance.IsNull( _T("DebugInfoType") ))
		{
			if (pInstance.GetDWORD( _T("DebugInfoType"), dwTemp))
			{
				DWORD dwRet = RegSetValueEx (

					RegInfo.GethKey(),
					_T("CrashDumpEnabled"),
					0,
					REG_DWORD,
					(CONST BYTE *)&dwTemp,
					sizeof(DWORD)
				) ;

				if (ERROR_SUCCESS != dwRet )
				{
					hRet = WBEM_E_FAILED;
				}
			}
		}
		else if (!pInstance.IsNull( _T("WriteDebugInfo") ) )
		{
			bool bWrite;
			pInstance.Getbool( _T("WriteDebugInfo"), bWrite);

			if (bWrite)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("CrashDumpEnabled"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if (ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("OverwriteExistingDebugFile") ) )
		{
			bool bOver;
			pInstance.Getbool( _T("OverwriteExistingDebugFile"), bOver);

			if (bOver)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("Overwrite"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		// KMH
		if ( ! pInstance.IsNull( _T("KernelDumpOnly") ) )
		{
			bool bOver;
			pInstance.Getbool( _T("KernelDumpOnly"), bOver);

			if (bOver)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("KernelDumpOnly"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("AutoReboot") ) )
		{
			bool bAuto;
			pInstance.Getbool( _T("AutoReboot"), bAuto);

			if (bAuto)
			{
				dwTemp = 1;
			}
			else
			{
				dwTemp = 0;
			}

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("AutoReboot"),
				0,
				REG_DWORD,
				(CONST BYTE *)&dwTemp,
				sizeof(DWORD)
			) ;

			if (ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("DebugFilePath") ) )
		{
			CHString sName ;
			pInstance.GetCHString( _T("DebugFilePath"), sName);

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("DumpFile"),
				0,
				REG_EXPAND_SZ,
				(CONST BYTE *)(LPCTSTR) sName,
				lstrlen ( sName )* sizeof(TCHAR)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}

		if ( ! pInstance.IsNull( _T("DirectoryPath") ) )
		{
			CHString sName ;
			pInstance.GetCHString( _T("DirectoryPath"), sName);

			DWORD dwRet = RegSetValueEx (

				RegInfo.GethKey(),
				_T("MiniDumpDir"),
				0,
				REG_EXPAND_SZ,
				(CONST BYTE *)(LPCTSTR) sName,
				lstrlen ( sName )* sizeof(TCHAR)
			) ;

			if ( ERROR_SUCCESS != dwRet )
			{
				hRet = WBEM_E_FAILED;
			}
		}
	}

	return hRet ;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\regcfg.cpp ===
//=================================================================

//

// RegCfg.h -- Registry Configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/97    davwoh         Created
//
//=================================================================

// All these nt routines are needed to support the NtQuerySystemInformation
// call.  They must come before FWCommon et all or else it won't compile.



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cregcls.h>
#include "SystemName.h"
#include "resource.h"

#include "DllWrapperBase.h"
#include "NtDllApi.h"

#include "RegCfg.h"

// Property set declaration
//=========================

CWin32RegistryConfiguration CWin32RegistryConfiguration ( PROPSET_NAME_REGISTRY_CONFIGURATION , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::CWin32RegistryConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32RegistryConfiguration :: CWin32RegistryConfiguration (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::~CWin32RegistryConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32RegistryConfiguration::~CWin32RegistryConfiguration()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    : Returns info for running OS only until we discover other
 *                installed OSes
 *
 *****************************************************************************/

HRESULT CWin32RegistryConfiguration :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
#ifdef NTONLY

	CSystemName cSN;
	if (!cSN.ObjectIsUs(pInstance))
	{
      return WBEM_E_NOT_FOUND;
	}

	GetRegistryInfo ( pInstance ) ;

	return WBEM_S_NO_ERROR;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    : Returns only running OS info until we discover installed OSes
 *
 *****************************************************************************/

HRESULT CWin32RegistryConfiguration :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR;
   // No workee on 95
#ifdef NTONLY

	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
	if (pInstance)
	{
		CSystemName cSN;

	// Sets the key properties common to several classes

		cSN.SetKeys ( pInstance ) ;
		GetRegistryInfo ( pInstance ) ;

	// Only one instance, save it.
		hr = pInstance->Commit() ;

	}

#endif

   return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::GetRunningOSInfo
 *
 *  DESCRIPTION : Assigns property values according to currently running OS
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32RegistryConfiguration :: GetRegistryInfo ( CInstance *pInstance )
{

    DWORD dwUsed = -1;
    DWORD dwProposedSize = -1;
    DWORD dwMaxSize = -1;

    bool bDone = false;

    CNtDllApi *t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if ( t_pNtDll != NULL )
    {
		try
		{
			// This is from ntdll.dll and is not doc'ed in the sdk docs

		    SYSTEM_REGISTRY_QUOTA_INFORMATION srqi;

   			NTSTATUS Status = t_pNtDll->NtQuerySystemInformation (

				SystemRegistryQuotaInformation,
				&srqi,
				sizeof(srqi),
				NULL
			);

			if (NT_SUCCESS(Status))
			{
				dwUsed = srqi.RegistryQuotaUsed;
				dwMaxSize = srqi.RegistryQuotaAllowed;
				bDone = true;
			}
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);

			throw ;
		}

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
        t_pNtDll = NULL;
    }

    // Read the size from the registry


	CRegistry RegInfo ;

    if ( RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control", KEY_READ) == ERROR_SUCCESS )
    {
        if ( RegInfo.GetCurrentKeyValue ( L"RegistrySizeLimit", dwProposedSize ) != ERROR_SUCCESS )
        {
            dwProposedSize = -1 ;
        }
    }
    else
    {
        dwProposedSize = -1 ;
    }

    if ( ! bDone )
    {
        // I don't see a good way to get this otherwise

        // Read the size from the registry

        RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control", KEY_READ ) ;
        if ( RegInfo.GetCurrentKeyValue ( L"RegistrySizeLimit", dwMaxSize) != ERROR_SUCCESS )
        {
            // If we couldn't read it, make a guess based on ppl

            RegInfo.Open ( HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management", KEY_READ ) ;

		    DWORD dwPPL ;

            if ( ( RegInfo.GetCurrentKeyValue( L"PagedPoolSize", dwPPL) != ERROR_SUCCESS) || (dwPPL == 0))
            {
                dwPPL = 5 * ONE_MEG;
            }

            dwMaxSize = dwPPL * 8 / 10;
        }
    }

    if ( dwMaxSize == -1 )
    {
        dwMaxSize = dwProposedSize;
    }

    // Massage it according to nt's arcane rules and store
    if ( dwMaxSize != -1 )
    {
        pInstance->SetDWORD ( L"MaximumSize", (dwMaxSize + ONE_MEG - 1) / ONE_MEG);
    }

    if ( dwUsed != -1 )
    {
        pInstance->SetDWORD ( L"CurrentSize", (dwUsed + ONE_MEG - 1) / ONE_MEG);
    }

    if (dwProposedSize != -1)
    {
        pInstance->SetDWORD ( L"ProposedSize", (dwProposedSize + ONE_MEG - 1) / ONE_MEG);
    }
    else
    {
        pInstance->SetDWORD ( L"ProposedSize", (dwMaxSize + ONE_MEG - 1) / ONE_MEG);
    }

    // Set some fixed values...
    CHString sTemp2;
    LoadStringW(sTemp2, IDR_Registry);

    pInstance->SetCHString ( L"Caption", sTemp2);
    pInstance->SetCHString ( L"Description", sTemp2);
    pInstance->SetCharSplat ( L"Status", L"OK" );

    // Since the registry was created when the os was installed,
    // get the os installed date.
    RegInfo.Open (

		HKEY_LOCAL_MACHINE,
        L"Software\\Microsoft\\Windows NT\\CurrentVersion",
        KEY_READ
	) ;

    DWORD dwInstallDate ;

    if ( ERROR_SUCCESS == RegInfo.GetCurrentKeyValue ( L"InstallDate", dwInstallDate ) )
    {
		time_t tTime = (time_t) dwInstallDate;

      // The followng line was commented out and replaced with the line following it
      // to be consistent with Win32_OperatingSystem (os.cpp).

		WBEMTime wTime(tTime);

		pInstance->SetDateTime( L"InstallDate", wTime );
   }
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32RegistryConfiguration::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : pInstance to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : The only property we write is MaximumSize
 *
 *****************************************************************************/

HRESULT CWin32RegistryConfiguration :: PutInstance (

	const CInstance &pInstance,
	long lFlags /*= 0L*/
)
{

#ifdef NTONLY

    HRESULT hRet = WBEM_S_NO_ERROR ;
	DWORD t_dwUsed = -1 ;
    // Tell the user we can't create a new registry
    if ( lFlags & WBEM_FLAG_CREATE_ONLY )
	{
        return WBEM_E_UNSUPPORTED_PARAMETER ;
	}

	CSystemName cSN;
    if (!cSN.ObjectIsUs(&pInstance))
	{
        if (lFlags & WBEM_FLAG_UPDATE_ONLY)
		{
            hRet = WBEM_E_NOT_FOUND;
        }
		else
		{
            hRet = WBEM_E_UNSUPPORTED_PARAMETER;
        }
    }
	else
	{
		CRegistry RegInfo;

        // See if they specified a value for this field
        if (!pInstance.IsNull( _T("ProposedSize") ) )
		{
			DWORD dwSize;
            pInstance.GetDWORD( _T("ProposedSize"), dwSize);

			CNtDllApi *t_pNtDll = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);

			if ( t_pNtDll != NULL )
			{
				try
				{
					// This is from ntdll.dll and is not doc'ed in the sdk docs

					SYSTEM_REGISTRY_QUOTA_INFORMATION srqi;

   					NTSTATUS Status = t_pNtDll->NtQuerySystemInformation (

						SystemRegistryQuotaInformation,
						&srqi,
						sizeof(srqi),
						NULL
					);

					if (NT_SUCCESS(Status))
					{
						t_dwUsed = srqi.RegistryQuotaUsed;
						t_dwUsed = (t_dwUsed + ONE_MEG - 1) / ONE_MEG ;
					}
				}
				catch ( ... )
				{
					CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);

					throw ;
				}

				CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, t_pNtDll);
				t_pNtDll = NULL;
			}

/*
 * Allow the put if the new proposed max size is greater than the current size
 */
			if ( t_dwUsed != -1 )
			{
				if ( dwSize >= t_dwUsed )
				{
					// Massage it and write it
					dwSize = dwSize * ONE_MEG;

					HRESULT res = RegInfo.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control"), KEY_WRITE) ;

					if ( res == ERROR_SUCCESS)
					{
						res = RegSetValueEx (

							RegInfo.GethKey(),
							_T("RegistrySizeLimit"),
							0,
							REG_DWORD,
							(const unsigned char *)&dwSize,
							sizeof(DWORD)
						) ;

						if ( res != ERROR_SUCCESS)
						{
							hRet = WBEM_E_FAILED;
						}
					}

					if (res == ERROR_ACCESS_DENIED)
					{
						hRet = WBEM_E_ACCESS_DENIED;
					}
				}
				else
				{
					hRet = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				hRet = WBEM_E_FAILED ;
			}
        }
    }

    return hRet;
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file. Copyright (c) 1997-2003 Microsoft Corporation
// Used by cimwin32.rc
//
#define IDR_UPSBatteryName              1
#define IDR_BatteryName                 2
//#define IDR_BOOT_CONFIG_NAME		3 //Not required ID maybe reused when next string is req'd.
#define IDR_PhysicalDriveFormat         4
#define IDR_IDEFixedDisk                5
#define IDR_SCSIFixedDisk               6
#define IDR_Unknown                     7
#define IDR_DiskPartitionFormat         8
#define IDR_DiskPartitionFormat1        9
#define IDR_PartitionDescUnused         10
#define IDR_PartitionDesc12bitFAT       11
#define IDR_PartitionDescXenixOne       12
#define IDR_PartitionDescXenixTwo       13
#define IDR_PartitionDesc16bitFAT       14
#define IDR_PartitionDescExtPartition   15
#define IDR_PartitionDescDOSV4Huge      16
#define IDR_PartitionDescInstallable    17
#define IDR_PartitionDescPowerPCRef     18
#define IDR_PartitionDescUnix           19
#define IDR_PartitionDescNTFT           20
#define IDR_PartitionDescWin95Ext       21
#define IDR_PartitionDescExt13          22
#define IDR_PartitionDescUnknown        23
#define IDR_PartitionDescLogicalDiskManager	24
#define IDR_DMAFormat                   25
#define IDR_IRQFormat                   26
#define IDR_PCXT                        27
#define IDR_PCAT                        28
#define IDR_ENHANCED101102              29
#define IDR_NOKIA1050                   30
#define IDR_NOKIA9140                   31
#define IDR_UnknownKeyboard             32
#define IDR_Japanese                    33
#define IDR_ICO                         34
#define IDR_525Floppy                   35
#define IDR_350Floppy                   36
#define IDR_800Floppy                   37
#define IDR_NetworkConnection           38
#define IDR_CDRomDisk                   39
#define IDR_RAMDisk                     40
#define IDR_LogicalMemoryConfiguration  41
#define IDR_Motherboard                 42
#define IDR_UPSName                     43
#define IDR_CPUFormat                   44
#define IDR_Registry                    45
#define IDR_VidModeFormat               46
#define IDR_VidControllerResolutionFormat		48
#define IDR_VidControllerResolutionFormatInterlaced	49
#define IDR_Bus                         50
#define IDR_DefaultMonitor              51
#define IDR_ChannelFormat               52
#define IDR_LocalFixedDisk              53
#define IDR_RemovableDisk               54
#define IDR_Resource_Remembered         55
#define IDR_Resource_Connected          56
#define IDR_ResourceRememberedFormat    57
#define IDR_ResourceConnectedFormat     58
#define IDR_ProcessOSFormat             59
#define IDR_ProcessOSFormat2            60
#define IDR_ComputerSystemProduct       61
#define IDR_BaseBoard                   62
#define IDR_SystemEnclosure             63
#define IDR_CacheMemory                 64
#define IDR_PortConnector               65
#define IDR_SystemSlot                  66
#define IDR_PhysicalMemory              67
#define IDR_PhysicalMemoryArray         68
#define IDR_PortableBattery             69
#define IDR_NumericSensor               70
#define IDR_MemoryArray                 71
#define IDR_MemoryDevice                72
#define IDR_CoolingDevice               73
#define IDR_ModelSteppingFormat         74
#define IDR_DECAlpha21064               108
#define IDR_DECAlpha21066               109
#define IDR_DECAlpha21164               110
#define IDR_ModelPassFormat             111
#define IDR_x86ProcessorFormat          112
#define IDR_UnknownDECAlphaProcessor    113
#define IDR_AMDK7                       114
#define IDR_x86FamilyModelStepping      115
#define IDR_W2k_StockName               116
#define IDR_W2k_Datacenter              117
#define IDR_W2k_AdvancedServer          118
#define IDR_W2k_Server                  119
#define IDR_W2k_Professional            120
#define IDR_NT_StockName                121
#define IDR_NT_EnterpriseServer         122
#define IDR_NT_Server                   123
#define IDR_NT_Workstation              124
#define IDR_9x_StockName                125
#define IDR_JOB_STATUS_PAUSED           126
#define IDR_JOB_STATUS_ERROR            127
#define IDR_JOB_STATUS_DELETING         128
#define IDR_JOB_STATUS_SPOOLING         129
#define IDR_JOB_STATUS_PRINTING         130
#define IDR_JOB_STATUS_OFFLINE          131
#define IDR_JOB_STATUS_PAPEROUT         132
#define IDR_JOB_STATUS_PRINTED          133
#define IDR_JOB_STATUS_DELETED          134
#define IDR_JOB_STATUS_BLOCKED_DEVQ     135
#define IDR_JOB_STATUS_USER_INTERVENTION	136
#define IDR_JOB_STATUS_RESTART          137
#define IDR_NdisMedium802_3             138
#define IDR_NdisMedium802_5             139
#define IDR_NdisMediumFddi              140
#define IDR_NdisMediumWan               141
#define IDR_NdisMediumLocalTalk         142
#define IDR_NdisMediumDix               143
#define IDR_NdisMediumArcnetRaw         144
#define IDR_NdisMediumArcnet878_2       145
#define IDR_NdisMediumAtm               146
#define IDR_NdisMediumWirelessWan       147
#define IDR_NdisMediumIrda              148
#define IDR_NdisMediumBpc               149
#define IDR_NdisMediumCoWan             150
#define IDR_NdisMedium1394              151
#define IDR_CurrentVideoConfiguration   152
#define IDR_Intel486DX                  153
#define IDR_Intel486SX                  154
#define IDR_Intel486DX2                 155
#define IDR_Intel486SL                  156
#define IDR_Intel486SX2                 157
#define IDR_Intel486DX4                 158
#define IDR_Intel486                    159
#define IDR_IntelPentiumMMX             160
#define IDR_IntelPentium                161
#define IDR_IntelPentiumPro             162
#define IDR_IntelCeleron                163
#define IDR_IntelPentiumII              164
#define IDR_IntelPentiumIIXeon          165
#define IDR_IntelPentiumIII             166
#define IDR_IntelPentiumIIIXeon         167
#define IDR_IntelUnknown                168
#define IDR_UnknownIntelP6              169
#define IDR_AMD4685x86                  170
#define IDR_AMDK5                       171
#define IDR_AMDK6                       172
#define IDR_AMDK62                      173
#define IDR_AMDK63                      174
#define IDR_AMDAthlon                   175
#define IDR_CyrixMediaGX                176
#define IDR_Cyrix486                    177
#define IDR_Cyrix6x86                   178
#define IDR_Cyrix6x86L                  179
#define IDR_CyrixMediaGXMMX             180
#define IDR_Cyrix586                    181
#define IDR_Cyrix6x86MX                 182
#define IDR_CyrixUnknown                183
#define IDR_IDTWinChip                  184
#define IDR_Intel486SX2WriteBack        185
#define IDR_AMDUnknown                  186
#define IDR_Itanium            		187
#define IDR_PartitionDescGPTUnused	188
#define IDR_PartitionDescGPTSystem	189
#define IDR_PartitionDescGPTMSFTReserved	190
#define IDR_PartitionDescGPTBasicData	191
#define IDR_PartitionDescGPTLDMMetaData 192
#define IDR_PartitionDescGPTLDMData	193
#define IDR_PartitionDescGPTUnknown	194
#define IDR_W2kPlus1_StockName          195
#define IDR_W2kPlus1_Datacenter         196
#define IDR_W2kPlus1_AdvancedServer     197
#define IDR_W2kPlus1_Server             198
#define IDR_W2kPlus1_Professional       199
#define IDR_W2kPlus1_Personal		200
#define IDR_Blade_StockName             201
#define IDR_W2kPlus1_Embedded		202
#define	IDR_W2kPlus1_Server_64Bit	203
#define	IDR_W2kPlus1_Professional_64Bit	204
#define	IDR_W2kPlus1_Server_SBS		205

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\schedjob.cpp ===
//=================================================================

//

// ScheduledJob.CPP --ScheduledJob property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/27/97	 a-hhance		updated to new framework paradigm.
//				 1/13/98	a-brads		updated to V2 MOF
//			     1/31/01	jennymc         Converted to WBEMTIME and got rid of multiple returns
//=================================================================
#include "precomp.h"

#include "lmcons.h"     // LAN Manager defines
#include "lmerr.h"      // LAN Manager error messages
#include "lmat.h"       // AT Command prototypes
#include "lmapibuf.h"
#include "wbemnetapi32.h"
#include "SchedJob.h"
#include <wbemtime.h>

// Property set declaration
//=========================

ScheduledJob s_ScheduledJob ( PROPSET_NAME_SCHEDULEDJOB , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::ScheduledJob
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

ScheduledJob :: ScheduledJob (LPCWSTR a_Name,LPCWSTR a_Namespace) : Provider ( a_Name, a_Namespace )
{

}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::~ScheduledJob
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

ScheduledJob::~ScheduledJob()
{

}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::GetJobObject
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

HRESULT ScheduledJob::GetJobObject (CInstance *a_Instance,DWORD a_JobId )
{
#ifdef NTONLY
    HRESULT hr = S_OK ;

	CNetAPI32 t_NetAPI ;

	if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
	{
		AT_INFO *AtInfo = NULL ;

		NET_API_STATUS dwStatus = t_NetAPI.NetScheduleJobGetInfo (NULL ,a_JobId,( LPBYTE * ) & AtInfo) ;

		if ( dwStatus == NERR_Success )
		{
			try
			{
				if ( AtInfo->Command )
				{
					CHString t_Command ( AtInfo->Command ) ;
					a_Instance->SetCHString ( PROPERTY_NAME_COMMAND , t_Command ) ;
				}

				a_Instance->Setbool ( PROPERTY_NAME_RUNREPEATEDLY , AtInfo->Flags & JOB_RUN_PERIODICALLY ? true : false ) ;

				if ( AtInfo->Flags & JOB_EXEC_ERROR )
				{
					a_Instance->SetCHString ( PROPERTY_NAME_JOBSTATUS , PROPERTY_VALUE_JOBSTATUS_FAILURE ) ;
				}
				else
				{
					a_Instance->SetCHString ( PROPERTY_NAME_JOBSTATUS , PROPERTY_VALUE_JOBSTATUS_SUCCESS ) ;
				}

				a_Instance->Setbool ( PROPERTY_NAME_INTERACTWITHDESKTOP , AtInfo->Flags & JOB_NONINTERACTIVE ? false : true ) ;

				a_Instance->Setbool ( PROPERTY_NAME_RUNSTODAY , AtInfo->Flags & JOB_RUNS_TODAY ? true : false ) ;

				
				CHString chsTime;
				if( FormatTimeString( chsTime, AtInfo->JobTime ) )
				{
					a_Instance->SetCHString ( PROPERTY_NAME_STARTTIME , (WCHAR*)(const WCHAR*) chsTime ) ;
				}

				if ( AtInfo->DaysOfMonth )
				{
					a_Instance->SetDWORD ( PROPERTY_NAME_DAYSOFMONTH , AtInfo->DaysOfMonth ) ;
				}

				if ( AtInfo->DaysOfWeek )
				{
					a_Instance->SetDWORD ( PROPERTY_NAME_DAYSOFWEEK , AtInfo->DaysOfWeek ) ;
				}
			}
			catch ( ... )
			{
				t_NetAPI.NetApiBufferFree ( (LPVOID) AtInfo ) ;

				throw ;
			}

			t_NetAPI.NetApiBufferFree ( (LPVOID) AtInfo ) ;
		}
		else
		{
			hr = GetScheduledJobResultCode ( dwStatus ) ;
		}
	}
    return hr ;

#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob::GetObject (CInstance *a_Instance,long a_Flags /*= 0L*/)
{
	HRESULT hr = WBEM_E_FAILED;
	DWORD t_JobId = 0 ;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( a_Instance->GetStatus ( PROPERTY_NAME_JOBID , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 ) )
		{
			if ( a_Instance->GetDWORD ( PROPERTY_NAME_JOBID , t_JobId ) )
			{
				hr = GetJobObject ( a_Instance , t_JobId ) ;
			}
		}
	}

    return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::InstantionJob
 *
 *  DESCRIPTION : Creates instance of property set for each discovered job
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : result code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob :: InstantiateJob (MethodContext *a_MethodContext,long a_Flags /*= 0L*/ ,	AT_ENUM *a_Job)
{
	HRESULT hr = S_OK ;

	CInstancePtr t_Instance(CreateNewInstance ( a_MethodContext ), false) ;

	t_Instance->SetDWORD ( PROPERTY_NAME_JOBID , a_Job->JobId ) ;

	if ( a_Job->Command )
	{
		CHString t_Command ( a_Job->Command ) ;
		t_Instance->SetCHString ( PROPERTY_NAME_COMMAND , t_Command ) ;
	}

	if ( a_Job->DaysOfMonth )
	{
		t_Instance->SetDWORD ( PROPERTY_NAME_DAYSOFMONTH , a_Job->DaysOfMonth ) ;
	}

	if ( a_Job->DaysOfWeek )
	{
		t_Instance->SetDWORD ( PROPERTY_NAME_DAYSOFWEEK , a_Job->DaysOfWeek ) ;
	}

	t_Instance->Setbool ( PROPERTY_NAME_RUNREPEATEDLY , a_Job->Flags & JOB_RUN_PERIODICALLY ? true : false ) ;

	if ( a_Job->Flags & JOB_EXEC_ERROR )
	{
		t_Instance->SetCHString ( PROPERTY_NAME_JOBSTATUS , PROPERTY_VALUE_JOBSTATUS_FAILURE ) ;
	}
	else
	{
		t_Instance->SetCHString ( PROPERTY_NAME_JOBSTATUS , PROPERTY_VALUE_JOBSTATUS_SUCCESS ) ;
	}

	t_Instance->Setbool ( PROPERTY_NAME_INTERACTWITHDESKTOP , a_Job->Flags & JOB_NONINTERACTIVE ? false : true ) ;

	t_Instance->Setbool ( PROPERTY_NAME_RUNSTODAY , a_Job->Flags & JOB_RUNS_TODAY ? true : false ) ;

	CHString chsTime;
	if( FormatTimeString( chsTime, a_Job->JobTime ) )
	{
		t_Instance->SetCHString ( PROPERTY_NAME_STARTTIME , chsTime) ;
	}

	hr = t_Instance->Commit () ;

    return  hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::EnumerateJobs
 *
 *  DESCRIPTION : Creates instance of property set for each discovered job
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : result code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob::EnumerateJobs (	MethodContext *a_MethodContext,	long a_Flags /*= 0L*/
)
{

#ifdef NTONLY
	HRESULT hr = S_OK ;

	CNetAPI32 t_NetAPI ;

	if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
	{
		BOOL t_EnumerationContinues = TRUE ;

		DWORD t_PreferedMaximumLength = 0xFFFFFFFF ;
		DWORD t_EntriesRead = 0 ;
		DWORD t_TotalEntriesRead = 0 ;
		DWORD t_ResumeJob = 0 ;

		while ( t_EnumerationContinues )
		{
			AT_ENUM *t_AtEnum = NULL ;

			NET_API_STATUS dwStatus = t_NetAPI.NetScheduleJobEnum (	NULL ,(LPBYTE *) & t_AtEnum, 1000 ,	& t_EntriesRead,
																	& t_TotalEntriesRead ,& t_ResumeJob	) ;

			try
			{
				t_EnumerationContinues = ( dwStatus == ERROR_MORE_DATA ) ? TRUE : FALSE ;

				if ( dwStatus == ERROR_MORE_DATA || dwStatus == NERR_Success )
				{
					for ( ULONG t_Index = 0 ; t_Index < t_EntriesRead ; t_Index ++ )
					{
						AT_ENUM *t_Job = & t_AtEnum [ t_Index ] ;
						hr = InstantiateJob (	a_MethodContext ,a_Flags ,t_Job	) ;
					}
				}
			}
			catch ( ... )
			{
				if ( t_AtEnum )
				{
					t_NetAPI.NetApiBufferFree ( (LPVOID) t_AtEnum ) ;
				}

				throw ;
			}

			if ( t_AtEnum )
			{
				t_NetAPI.NetApiBufferFree ( (LPVOID) t_AtEnum ) ;
			}
		}
	}
    return  hr ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered job
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : result code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob::EnumerateInstances (MethodContext *a_MethodContext,long a_Flags /*= 0L*/)
{
	HRESULT hr = S_OK ;

	hr = EnumerateJobs ( a_MethodContext , a_Flags ) ;

    return  hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob :: DeleteInstance ( const CInstance &a_Instance, long a_Flags /*= 0L*/ )
{
#ifdef NTONLY
	HRESULT hr = WBEM_E_TYPE_MISMATCH ;
	bool fExists = FALSE;
	VARTYPE vType ;

	DWORD t_JobId = 0 ;
	if ( a_Instance.GetStatus ( PROPERTY_NAME_JOBID , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 ) )
		{
			if ( a_Instance.GetDWORD ( PROPERTY_NAME_JOBID , t_JobId ) )
			{
				CNetAPI32 t_NetAPI ;

				if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					NET_API_STATUS t_JobStatus = t_NetAPI.NetScheduleJobDel(NULL ,t_JobId ,	t_JobId	) ;

					if ( t_JobStatus != NERR_Success )
					{
						hr = GetScheduledJobResultCode ( t_JobStatus ) ;
					}
				}
			}
		}
	}
    return hr ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT ScheduledJob::ExecMethod( const CInstance& a_Instance, const BSTR a_MethodName, CInstance *pInst ,
								  CInstance *a_OutParams ,long a_Flags )
{
	if ( ! a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}
	//========================================================
    // Do we recognize the method?
 	//========================================================
	if ( _wcsicmp ( a_MethodName , METHOD_NAME_CREATE ) == 0 )
	{
		return ExecCreate ( a_Instance , pInst , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_DELETE ) == 0 )
	{
		return ExecDelete ( a_Instance , pInst , a_OutParams , a_Flags ) ;
	}

	return WBEM_E_INVALID_METHOD;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD ScheduledJob :: GetScheduledJobErrorCode ( NET_API_STATUS dwNetStatus )
{
	DWORD dwStatus = STATUS_UNKNOWN_FAILURE;

	switch ( dwNetStatus )
	{
		case ERROR_INVALID_HANDLE:
		{
			dwStatus = STATUS_UNKNOWN_FAILURE ;
		}
		break ;

		case 3806:	/* special private error code which is not within includes */
		case ERROR_PATH_NOT_FOUND:
		{
			dwStatus = STATUS_PATH_NOT_FOUND ;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			dwStatus = STATUS_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			dwStatus = STATUS_INVALID_PARAMETER ;
		}
		break;

		case NERR_ServiceNotInstalled:
		{
			dwStatus = STATUS_SERVICE_NOT_STARTED ;
		}
		break ;

		default:
		{
			dwStatus = STATUS_UNKNOWN_FAILURE ;
		}
		break ;
	}

	return dwStatus ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob :: GetScheduledJobResultCode ( NET_API_STATUS dwStatus )
{
	HRESULT hr ;

	switch ( dwStatus )
	{
		case NERR_ServiceNotInstalled:
		{
			hr = WBEM_E_FAILED ;
		}
		break ;

		case ERROR_INVALID_HANDLE:
		{
			hr = STATUS_UNKNOWN_FAILURE ;
		}
		break ;

		case 3806:	/* special private error code which is not within includes */
		case ERROR_PATH_NOT_FOUND:
		{
			hr = WBEM_E_NOT_FOUND ;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			hr = WBEM_E_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			hr = WBEM_E_INVALID_PARAMETER ;
		}
		break;

		default:
		{
			hr = WBEM_E_FAILED ;
		}
		break ;
	}

	return hr ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Time handling functions
///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ScheduledJob::GetOffsetAndSeperator( WCHAR * wcsTime, LONG * lpOffSet, WCHAR * wchSep, BOOL fSetOffset )
{
	DWORD dwHours, dwMinutes, dwSeconds, dwMicros;
	return GetTimeStringParts( wcsTime, &dwHours, &dwMinutes, &dwSeconds, &dwMicros, lpOffSet, wchSep, fSetOffset );
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Time handling functions
///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ScheduledJob::GetTimeStringParts( WCHAR * wcsTime, DWORD * pdwHours, DWORD * pdwMinutes, DWORD * pdwSeconds,
									   DWORD * pdwMicros, LONG * lpOffSet, WCHAR * wchSep, BOOL fSetOffset)
{
	int nRes = swscanf(&wcsTime[8],L"%2d%2d%2d.%6d%c%3d",pdwHours,pdwMinutes,pdwSeconds,pdwMicros,wchSep,lpOffSet );
	if ( nRes != 6)
	{
		return FALSE;
	}
	
	if( fSetOffset && *wchSep == L'-')
	{
		*lpOffSet *= -1;
	}
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
// The StartTime parameter represents the UTC time to run the job.  
// This is of the form YYYYMMDDHHMMSS.MMMMMM(+-)OOO, 
// where YYYYMMDD must be replaced by ******** 
//			********123000.000000-420 which implies 12:30 pm PST with daylight savings time in effect
//
//	JobTime is coming in as:
//  The time is the local time at a computer on which the schedule service is running; 
//  it is measured from midnight, and is expressed in milliseconds. 
///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ScheduledJob::FormatTimeString( CHString & chsTime, DWORD dwTime)
{
	BOOL fRc = FALSE;
    WBEMTime wt;
	SYSTEMTIME st;

	GetSystemTime( &st );
	wt = st;
	if( wt.IsOk() )
	{
		//======================================================
		//  set the first eight chars to ********
		//======================================================
		_bstr_t cbsTmp;
		LONG lOffset = 0;
		WCHAR wchSep;
		cbsTmp = wt.GetDMTF(TRUE);
		if( GetOffsetAndSeperator( cbsTmp, &lOffset, &wchSep, FALSE) )
		{
			//=========================================================
			// convert from milliseconds since midnight to DMTF
			//=========================================================
			DWORD dwSeconds = dwTime/1000;
			DWORD dwMinutes = dwSeconds / 60 ;
			DWORD dwHours  = dwMinutes / 60 ;
			DWORD dwMicros = dwTime - ( dwSeconds * 1000 );

    		chsTime.Format(L"********%02ld%02ld%02ld.%06ld%c%03ld" ,dwHours,dwMinutes-( dwHours * 60 ) , dwSeconds-( dwMinutes * 60 ),
																	dwMicros, wchSep, lOffset);
			fRc = TRUE;
		}
	}
	return fRc;
}
//////////////////////////////////////////////////////////////////////////////////////////////
//  Time needs to be converted from property string to milliseconds
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetStartTime( CInstance * pInst, LONG & lTime, int & nShift )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	nShift = 0;
	if ( pInst->GetStatus( PROPERTY_NAME_STARTTIME, fExists , vType ) )
	{
		if ( fExists && ( vType == VT_BSTR ) )
		{
			CHString chsTimeString ;

			if ( pInst->GetCHString ( PROPERTY_NAME_STARTTIME , chsTimeString ) && ! chsTimeString.IsEmpty () )
			{
			    WBEMTime wtScheduledTime;
				_bstr_t cbstrScheduledTime, cbstrLocalTime;
				LONG lLocalOffset = 0, lScheduledOffset = 0;
				DWORD dwHours, dwMins, dwSecs, dwMicros;
				WCHAR wchSep = 0;
				dwHours = dwMins = dwSecs = dwMicros = 0;

				//================================================================
				//  Convert the incoming date to a DMTF date and break out the
				//  parts to get the milliseconds since midnight
				//================================================================
				cbstrScheduledTime = (WCHAR*) (const WCHAR*) chsTimeString;
				if( wtScheduledTime.SetDMTF( cbstrScheduledTime ) )
				{
					if( GetTimeStringParts( (WCHAR*)(const WCHAR*) cbstrScheduledTime, &dwHours, &dwMins, &dwSecs, &dwMicros, &lScheduledOffset, &wchSep, TRUE ))
					{
						//=========================================================
						// convert to milliseconds since midnight
						//=========================================================

                        lTime =  dwHours * 60 * 60;
                        lTime += dwMins * 60;
                        lTime += dwSecs;
                        lTime *= 1000;
                        lTime += dwMicros / 1000;

                        if ( lTime < MILLISECONDS_IN_A_DAY )
						{
							WBEMTime tmpTime;
							SYSTEMTIME st;
							GetSystemTime( &st );

							tmpTime = st;
							if( tmpTime.GetSYSTEMTIME(&st))
							{
								//=================================================
								//  Determine if we need to shift the days of the
								//  month and week
								//=================================================
								_bstr_t cbsTmp;
								cbsTmp = tmpTime.GetDMTF(TRUE);
								if( GetOffsetAndSeperator( cbsTmp, &lLocalOffset, &wchSep, TRUE) )
								{
									//=========================================================
									//  If these are not equal, then set flags to adjust for
									//  the day
									//=========================================================
									if( lScheduledOffset != lLocalOffset )
									{
										LONG lDelta = lLocalOffset - lScheduledOffset ;
                                        lTime = lTime + lDelta * 60 * 1000 ;

                                        if( lTime < (DWORD) 0)
										{
                                            lTime = MILLISECONDS_IN_A_DAY + lTime ;
											nShift = -1 ;
										}
										else
										{
                                            if ( lTime > MILLISECONDS_IN_A_DAY )
											{
                                                lTime = lTime - MILLISECONDS_IN_A_DAY ;
												nShift = 1;
											}
										}
									}
									hr = S_OK;
								}
							} 
						}
					}
				}
			}
		}
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  Get info from properties in instance
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetCommand( CInstance * pInst, CHString & chsCommand )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus( PROPERTY_NAME_COMMAND , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_BSTR ) )
		{
			if ( pInst->GetCHString ( PROPERTY_NAME_COMMAND , chsCommand ) && ! chsCommand.IsEmpty () )
			{
				hr = S_OK;
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetDaysOfMonth( CInstance * pInst, DWORD & dwDaysOfMonth, int nShift )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus( PROPERTY_NAME_DAYSOFMONTH , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 || vType == VT_NULL ) )
		{
			if ( vType == VT_NULL )
			{
				hr = S_OK;
			}
			else
			{
				if ( pInst->GetDWORD ( PROPERTY_NAME_DAYSOFMONTH , dwDaysOfMonth ) )
				{
					if ( dwDaysOfMonth >= ( 1 << 31 ) )
					{
						hr = WBEM_E_INVALID_PARAMETER;
					}
					else
					{
						if ( nShift < 0)
						{
							if ( dwDaysOfMonth & 1 )
							{
								dwDaysOfMonth = dwDaysOfMonth & 0xFFFFFFFE ;
								dwDaysOfMonth = ( dwDaysOfMonth >> 1 ) | 0x40000000 ;
							}
							else
							{
								dwDaysOfMonth = ( dwDaysOfMonth >> 1 ) ;
							}
						}
						else if ( nShift > 0 )
						{
							if ( dwDaysOfMonth & 0x4000000 )
							{
								dwDaysOfMonth = dwDaysOfMonth & 0xBFFFFFFF ;
								dwDaysOfMonth = ( dwDaysOfMonth << 1 ) | 0x1 ;
							}
							else
							{
								dwDaysOfMonth = ( dwDaysOfMonth << 1 ) | 0x1 ;
							}
						}
					}

					hr = S_OK;
				}
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetDaysOfWeek( CInstance * pInst,	DWORD dwDaysOfMonth, DWORD & dwDaysOfWeek, int nShift )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus ( PROPERTY_NAME_DAYSOFWEEK , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 || vType == VT_NULL ) )
		{
			if ( vType == VT_NULL )
			{
				hr = S_OK;
			}
			else
			{
				if ( pInst->GetDWORD ( PROPERTY_NAME_DAYSOFWEEK , dwDaysOfWeek) )
				{
					if ( dwDaysOfWeek >= ( 1 << 7 ) )
					{
						hr = WBEM_E_INVALID_PARAMETER;
					}
					else
					{
						if ( nShift < 0 )
						{
							if ( dwDaysOfWeek & 1 )
							{
								dwDaysOfMonth = dwDaysOfMonth & 0xBF ;
								dwDaysOfWeek = ( dwDaysOfWeek >> 1 ) | 0x40 ;
							}
							else
							{
								dwDaysOfWeek = ( dwDaysOfWeek >> 1 ) ;
							}
						}
						else if ( nShift > 0 )
						{
							if ( dwDaysOfWeek & 0x40 )
							{
								dwDaysOfMonth = dwDaysOfMonth & 0xFE ;
								dwDaysOfWeek = ( dwDaysOfWeek << 1 ) | 0x1 ;
							}
							else
							{
								dwDaysOfWeek = ( dwDaysOfWeek << 1 ) ;
							}
						}

						hr = S_OK;
					}
				}
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetInteractiveWithDeskTop(CInstance * pInst, bool & fInteract)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus ( PROPERTY_NAME_INTERACTWITHDESKTOP , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_BOOL || vType == VT_NULL ) )
		{
			if ( vType != VT_NULL )
			{
				if ( pInst->Getbool ( PROPERTY_NAME_INTERACTWITHDESKTOP , fInteract ) )
				{
					hr = S_OK;
				}
			}
			else
			{
				hr = S_OK;
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::GetRunRepeatedly(CInstance * pInst, bool & fRunRepeatedly )
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	bool fExists = FALSE;
	VARTYPE vType ;

	if ( pInst->GetStatus ( PROPERTY_NAME_RUNREPEATEDLY , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_BOOL || vType == VT_NULL ) )
		{
			if ( vType != VT_NULL )
			{
				if ( pInst->Getbool ( PROPERTY_NAME_RUNREPEATEDLY , fRunRepeatedly ) )
				{
					hr = S_OK;
				}
			}
			else
			{
				hr = S_OK;
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob::CreateJob( CInstance * pInst, DWORD &dwStatus, DWORD &a_JobId )
{
#ifdef NTONLY
	
	dwStatus = STATUS_INVALID_PARAMETER ;
	CHString chsCommand;

	HRESULT hr = GetCommand(pInst, chsCommand);
	if( S_OK == hr )
	{
		int nShift = 0;
        LONG lTime = 0;
        hr = GetStartTime( pInst, lTime, nShift );
		if( S_OK == hr )
		{
			DWORD dwDaysOfMonth = 0;
			hr = GetDaysOfMonth( pInst, dwDaysOfMonth, nShift );
			if( S_OK == hr )
			{
				DWORD dwDaysOfWeek = 0;
				hr = GetDaysOfWeek( pInst, dwDaysOfMonth, dwDaysOfWeek, nShift );
				if( S_OK == hr )
				{
					bool fInteract = TRUE;
					hr = GetInteractiveWithDeskTop(pInst, fInteract);
					if( S_OK == hr )
					{
						bool fRunRepeatedly = FALSE;
						hr = GetRunRepeatedly( pInst, fRunRepeatedly );
						if( S_OK == hr )
						{
							AT_INFO AtInfo ;
							_bstr_t cbstrCommand;

							cbstrCommand = (WCHAR*)(const WCHAR*) chsCommand;

							AtInfo.Command = cbstrCommand;
                                                        AtInfo.JobTime = lTime ;
							AtInfo.DaysOfMonth = dwDaysOfMonth ;
							AtInfo.DaysOfWeek = dwDaysOfWeek ;
							AtInfo.Flags = 0;

							if ( fRunRepeatedly )
							{
								AtInfo.Flags = AtInfo.Flags | JOB_RUN_PERIODICALLY ;
							}

							if ( !fInteract )
							{
								AtInfo.Flags = AtInfo.Flags | JOB_NONINTERACTIVE ;
							}

							CNetAPI32 t_NetAPI ;
							if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
							{
								NET_API_STATUS dwJobStatus = t_NetAPI.NetScheduleJobAdd(NULL,(LPBYTE)&AtInfo,&a_JobId);

								if ( dwJobStatus == NERR_Success )
								{
									dwStatus = S_OK;
								}
								else
								{
									dwStatus = GetScheduledJobErrorCode ( dwJobStatus ) ;
								}
							}
						}
					}
				}
			}
		}
	}
	return hr;
#endif
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob :: ExecCreate (const CInstance& a_Instance,CInstance *pInst,CInstance *a_OutParams,long lFlags)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER ;

	if ( pInst && a_OutParams )
	{
		DWORD t_JobId = 0 ;
		DWORD dwStatus = 0 ;

		hr = CreateJob (pInst ,dwStatus ,t_JobId	) ;
		if ( SUCCEEDED ( hr ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;

			if ( dwStatus == STATUS_SUCCESS )
			{
				a_OutParams->SetDWORD ( PROPERTY_NAME_JOBID , t_JobId ) ;
			}
 		}
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob :: DeleteJob (const CInstance& a_Instance,DWORD &dwStatus )
{
#ifdef NTONLY
	HRESULT hr = WBEM_E_PROVIDER_FAILURE;
	bool fExists = FALSE;
	VARTYPE vType ;
	DWORD t_JobId = 0 ;

	dwStatus = STATUS_INVALID_PARAMETER ;
	if ( a_Instance.GetStatus ( PROPERTY_NAME_JOBID , fExists , vType ) )
	{
		if ( fExists && ( vType == VT_I4 ) )
		{
			if ( a_Instance.GetDWORD ( PROPERTY_NAME_JOBID , t_JobId ) )
			{
				CNetAPI32 t_NetAPI ;

				if( ( hr = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					NET_API_STATUS t_JobStatus = t_NetAPI.NetScheduleJobDel (NULL ,	t_JobId ,t_JobId) ;

					if ( t_JobStatus != NERR_Success )
					{
						dwStatus = GetScheduledJobErrorCode ( t_JobStatus ) ;
					}
					else
					{
						dwStatus = STATUS_SUCCESS;
					}
				}
			}
		}
	}

	return hr ;
#endif
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ScheduledJob :: ExecDelete (const CInstance& a_Instance,CInstance *pInst,CInstance *a_OutParams,long lFlags)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER ;

	if ( a_OutParams )
	{
		DWORD dwStatus = 0 ;

		hr = DeleteJob (a_Instance , dwStatus) ;

		if ( SUCCEEDED ( hr ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\regcfg.h ===
//=================================================================

//

// RegCfg.h -- Registry Configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/97    davwoh         Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_REGISTRY_CONFIGURATION L"Win32_Registry"

// I have no idea why this isn't 1,024,000, but that's what nt uses.
#define ONE_MEG             1048576

class CWin32RegistryConfiguration:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32RegistryConfiguration(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32RegistryConfiguration() ;

        // Funcitons provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);

    private:
      void GetRegistryInfo(CInstance *pInstance);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\schedjob.h ===
//=================================================================

//

// schedjob.h -- scheduled job provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/11/98    stevm        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_SCHEDULEDJOB					L"Win32_ScheduledJob"

#define PROPERTY_NAME_JOBID					L"JobId"
#define PROPERTY_NAME_STARTTIME				L"StartTime"
#define PROPERTY_NAME_COMMAND				L"Command"
#define PROPERTY_NAME_RUNREPEATEDLY			L"RunRepeatedly"
#define PROPERTY_NAME_INTERACTWITHDESKTOP	L"InteractWithDesktop"
#define PROPERTY_NAME_DAYSOFWEEK			L"DaysOfWeek"
#define PROPERTY_NAME_DAYSOFMONTH			L"DaysOfMonth"
#define PROPERTY_NAME_JOBSTATUS				L"JobStatus"
#define PROPERTY_NAME_RUNSTODAY				L"RunsToday"

#define PROPERTY_VALUE_JOBSTATUS_SUCCESS L"Success"
#define PROPERTY_VALUE_JOBSTATUS_FAILURE L"Failure"

#define METHOD_NAME_CREATE				L"Create"
#define METHOD_NAME_DELETE				L"Delete"

#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"

#define PROPERTY_VALUE_MIN_DAYOFWEEK 0
#define PROPERTY_VALUE_MAX_DAYOFWEEK 6

#define PROPERTY_VALUE_MIN_DAYOFMONTH 0
#define PROPERTY_VALUE_MAX_DAYOFMONTH 30


#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS							0
#endif

#undef STATUS_NOT_SUPPORTED
#define STATUS_NOT_SUPPORTED					1

// Control
#undef STATUS_ACCESS_DENIED					
#define STATUS_ACCESS_DENIED					2
#define STATUS_UNKNOWN_FAILURE					8

// Start
#define STATUS_PATH_NOT_FOUND					9
#undef STATUS_INVALID_PARAMETER				
#define STATUS_INVALID_PARAMETER				21
#define STATUS_SERVICE_NOT_STARTED				22


#define MILLISECONDS_IN_A_DAY 86400000
#define DECPOS 14
#define SGNPOS 21
#define DMTFLEN 25


class ScheduledJob : public Provider
{
public:

	// Constructor/destructor
    //=======================

	ScheduledJob (

		LPCWSTR a_Name,
		LPCWSTR a_Namespace
	) ;

    ~ScheduledJob () ;

	// Funcitons provide properties with current values
    //=================================================

	HRESULT EnumerateInstances (

		MethodContext *a_MethodContext,
		long a_Flags = 0L
	) ;

	HRESULT GetObject (

		CInstance *a_Instance,
		long a_Flags = 0L
	) ;

	HRESULT DeleteInstance (

		const CInstance& a_Instance,
		long a_Flags = 0L
	) ;

	HRESULT ExecMethod (

		const CInstance &a_Instance,
		const BSTR a_MethodName,
		CInstance *a_InParams,
		CInstance *a_OutParams,
		long a_Flags = 0L
	) ;

private:

	DWORD m_Platform ;

        HRESULT GetStartTime( CInstance * pInst, LONG & lTime, int & fShift );
	BOOL FormatTimeString( CHString & chsTime, DWORD dwJobTime);
	BOOL GetOffsetAndSeperator( WCHAR * wcsTime, LONG * lpOffSet, WCHAR * wchSep, BOOL fSetOffset );
	BOOL GetTimeStringParts( WCHAR * wcsTime, DWORD * pdwHours, DWORD * pdwMinutes, DWORD * pdwSeconds,
		 				   DWORD * pdwMicros, LONG * lpOffSet, WCHAR * wchSep, BOOL fSetOffset);

	HRESULT GetCommand( CInstance * pInst, CHString & chsCommand );
	HRESULT GetDaysOfMonth( CInstance * pInst, DWORD & dwDaysOfMonth, int nShift);
	HRESULT GetDaysOfWeek( CInstance * pInst,	DWORD dwDaysOfMonth, DWORD & dwDaysOfWeek, int nShift );
	HRESULT GetInteractiveWithDeskTop(CInstance * pInst, bool & fInteract);
	HRESULT GetRunRepeatedly(CInstance * pInst, bool & fRunRepeatedly );

	DWORD GetScheduledJobErrorCode ( NET_API_STATUS a_Status ) ;

	HRESULT GetScheduledJobResultCode ( NET_API_STATUS a_Status ) ;

	HRESULT GetJobObject (
		
		CInstance *a_Instance,
		DWORD a_JobId
	) ;

	HRESULT InstantiateJob (

		MethodContext *a_MethodContext,
		long a_Flags /*= 0L*/ ,
		AT_ENUM *a_Job
	) ;

	HRESULT EnumerateJobs (

		MethodContext *a_MethodContext,
		long a_Flags /*= 0L*/
	) ;

	HRESULT CreateJob (

		CInstance *a_InParams,
		DWORD &a_Status ,
		DWORD &a_JobId
	) ;

	HRESULT DeleteJob (

		const CInstance& a_Instance,
		DWORD &a_Status
	) ;

	HRESULT ExecCreate (

		const CInstance& a_Instance,
		CInstance *a_InParams,
		CInstance *a_OutParams,
		long lFlags
	) ;

	HRESULT ExecDelete (

		const CInstance& a_Instance,
		CInstance *a_InParams,
		CInstance *a_OutParams,
		long lFlags
	) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\scsi.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//  w2k\scsi.cpp
//
//  Purpose: scsi controller property set provider
//
//***************************************************************************

#include "precomp.h"

#include <winbase.h>
#include <winioctl.h>
#include <ntddscsi.h>

#include "..\scsi.h"

#include <comdef.h>

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_SCSICONTROLLER L"SCSIAdapter"

CWin32_ScsiController s_ScsiController ( PROPSET_NAME_SCSICONTROLLER , IDS_CimWin32Namespace );

#define SCSIPORT_MAX 0x4000

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::CWin32_ScsiController
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_ScsiController :: CWin32_ScsiController (LPCTSTR a_Name,
	                                            LPCTSTR a_Namespace)
: Provider(a_Name, a_Namespace)
{
	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::~CWin32_ScsiController
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_ScsiController :: ~CWin32_ScsiController()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController :: GetObject ( CInstance *a_Instance, long a_Flags, CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND;
    CConfigManager t_ConfigManager;

    // Let's see if config manager recognizes this device at all
    CHString t_Key;
    a_Instance->GetCHString( IDS_DeviceID , t_Key);

    CConfigMgrDevicePtr t_pDevice;

	if(t_ConfigManager.LocateDevice(t_Key , t_pDevice))
    {
        //Ok, it knows about it.  Is it a scsi controller?
        if(IsOneOfMe( t_pDevice ) )
        {
			CHString t_DeviceId;
			if( t_pDevice->GetPhysicalDeviceObjectName( t_DeviceId ) )
			{
				TCHAR *t_DosDeviceNameList = NULL ;

				try
				{
					if ( QueryDosDeviceNames(t_DosDeviceNameList) )
					{
						UINT64     t_SpecifiedProperties = GetBitmap(a_Query);

						t_Result = LoadPropertyValues(&W2K_SCSI_LPVParms(a_Instance,
																		 t_pDevice ,
																		 t_DeviceId ,
																		 t_DosDeviceNameList,
																		 t_SpecifiedProperties));

						delete t_DosDeviceNameList;
						t_DosDeviceNameList = NULL ;
					}
					else
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				catch( ... )
				{
					if( t_DosDeviceNameList )
					{
						delete t_DosDeviceNameList ;
					}
					throw ;
				}
			}
        }
    }
    return t_Result ;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result ;
	t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_ScsiController :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    UINT64     t_SpecifiedProperties = GetBitmap(a_Query);

	//if ( t_SpecifiedProperties ) //removed since would result in no query being executed if no special properties were selected.
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController :: Enumerate ( MethodContext *a_pMethodContext , long a_Flags , UINT64 a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;
	TCHAR *t_DosDeviceNameList = NULL ;
	CConfigManager t_ConfigManager ;
	CDeviceCollection t_DeviceList ;

	try
	{
		if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
		{
		// While it might be more performant to use FilterByGuid, it appears that at least some
		// 95 boxes will report InfraRed info if we do it this way.
			if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_SCSICONTROLLER ) )
			{
				REFPTR_POSITION t_Position ;
				if( t_DeviceList.BeginEnum ( t_Position ) )
				{
					// smart ptrs
					CConfigMgrDevicePtr t_pDevice;
					CInstancePtr		t_pInst;

					t_Result = WBEM_S_NO_ERROR ;

					// Walk the list
					for (t_pDevice.Attach(t_DeviceList.GetNext ( t_Position ));
						 SUCCEEDED( t_Result ) && (t_pDevice != NULL);
						 t_pDevice.Attach(t_DeviceList.GetNext ( t_Position )))
					{
						// Now to find out if this is the scsi controller
						if(IsOneOfMe( t_pDevice ) )
						{
							t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

							CHString t_DeviceId ;
							if( t_pDevice->GetPhysicalDeviceObjectName ( t_DeviceId ) )
							{
								if( SUCCEEDED( t_Result =
									LoadPropertyValues(	&W2K_SCSI_LPVParms(	t_pInst,
																			t_pDevice,
																			t_DeviceId,
																			t_DosDeviceNameList,
																			a_SpecifiedProperties ) ) ) )
								{
									// Derived classes (like CW32SCSICntrlDev) may commit as result of call to LoadPropertyValues,
									// so check if we should -> only do so if we are of this class's type.
									if( ShouldBaseCommit( NULL ) )
									{
										t_Result = t_pInst->Commit();
									}
								}
							}
							else
							{
								t_Result = WBEM_E_PROVIDER_FAILURE;
							}
						}
					}
					// Always call EndEnum().  For all Beginnings, there must be an End
					t_DeviceList.EndEnum();
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}
	catch( ... )
	{
		// NOTE: EndEnum is not needed here. When t_DeviceList goes out of scope it will release a mutex.
		// same as .EndEnum
		if( t_DosDeviceNameList )
		{
			delete t_DosDeviceNameList ;
		}

		throw ;
	}

	delete t_DosDeviceNameList ;
	t_DosDeviceNameList = NULL ;

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_ScsiController::LoadPropertyValues(void* pv)
{
	// Unpack and confirm our parameters...
    W2K_SCSI_LPVParms* pData = (W2K_SCSI_LPVParms*)pv;
    CInstance* a_Instance = (CInstance*)(pData->m_pInstance);  // This instance released by caller
    CConfigMgrDevice* a_Device = (CConfigMgrDevice*)(pData->m_pDevice);
    CHString a_DeviceName = (CHString)(pData->m_chstrDeviceName);
    TCHAR* a_DosDeviceNameList = (TCHAR*)(pData->m_tstrDosDeviceNameList);
    UINT64 a_SpecifiedProperties = (UINT64)(pData->m_ui64SpecifiedProperties);
    if(a_Instance == NULL || a_Device == NULL) return WBEM_E_PROVIDER_FAILURE;

    HRESULT t_Result = LoadConfigManagerPropertyValues ( a_Instance , a_Device , a_DeviceName , a_SpecifiedProperties ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SpecifiedProperties & SPECIAL_SCSI )
		{
			CHString t_DosDeviceName ;
			t_Result = GetDeviceInformation ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_DosDeviceNameList , a_SpecifiedProperties ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = LoadMediaPropertyValues ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_SpecifiedProperties ) ;
			}
			else
			{
				t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
			}
		}
	}
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::LoadConfigManagerPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_ScsiController :: LoadConfigManagerPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	UINT64 a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

    if ( a_SpecifiedProperties & SPECIAL_PROPS_DRIVERNAME )
    {
        CHString t_DriverName;

        if ( a_Device->GetService( t_DriverName ) )
        {
            a_Instance->SetCHString (IDS_DriverName, t_DriverName ) ;
        }
    }

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
	{
	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported , 2 ) ;
	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController :: GetDeviceInformation
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController :: GetDeviceInformation (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	CHString a_DeviceName ,
	CHString &a_DosDeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	UINT64 a_SpecifiedProperties
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_CreatedSymbolicLink = FALSE ;

	CHString t_SymbolicLinkName ;

	try
	{
		BOOL t_Status = FindDosDeviceName ( a_DosDeviceNameList , a_DeviceName , t_SymbolicLinkName ) ;
		if ( ! t_Status )
		{
			t_SymbolicLinkName = CHString ( L"WMI_SCSICONTROLLERDEVICE_SYBOLICLINK" ) ;
			EnterCriticalSection ( & m_CriticalSection ) ;
			t_Status = DefineDosDevice ( DDD_RAW_TARGET_PATH , t_SymbolicLinkName , a_DeviceName ) ;
			LeaveCriticalSection ( & m_CriticalSection ) ;
			if ( t_Status )
			{
				t_CreatedSymbolicLink = TRUE ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				DWORD t_LastError = GetLastError () ;
			}
		}

		if ( t_CreatedSymbolicLink )
		{
			EnterCriticalSection ( & m_CriticalSection ) ;
			BOOL t_Status = DefineDosDevice ( /* DDD_EXACT_MATCH_ON_REMOVE | */ DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
			LeaveCriticalSection ( & m_CriticalSection ) ;
			if ( ! t_Status )
			{
				//t_Result = WBEM_E_PROVIDER_FAILURE ;

				DWORD t_LastError = GetLastError () ;
			}
		}

		return t_Result ;
	}
	catch( ... )
	{
		if ( t_CreatedSymbolicLink )
		{
			EnterCriticalSection ( & m_CriticalSection ) ;
			DefineDosDevice ( /* DDD_EXACT_MATCH_ON_REMOVE | */ DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
			LeaveCriticalSection ( & m_CriticalSection ) ;
		}

		throw ;
	}
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_ScsiController :: LoadMediaPropertyValues
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_ScsiController::LoadMediaPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const CHString &a_DosDeviceName ,
	UINT64 a_SpecifiedProperties
)
{

	HRESULT t_Result = S_OK ;

/*
 *
 */
    // Set common drive properties
    //=============================

	CHString t_DeviceLabel = CHString ( a_DosDeviceName ) ;

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DRIVE )
	{
	    if(t_DeviceLabel.GetLength() != 0) a_Instance->SetCharSplat ( IDS_Drive, t_DeviceLabel ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_ID )
	{
		if(t_DeviceLabel.GetLength() != 0) a_Instance->SetCharSplat ( IDS_Id, t_DeviceLabel ) ;
	}
    /* Capability is not a property of this class at this time...
	if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPABILITY )
	{
		// Create a safearray for the Capabilities information

		SAFEARRAYBOUND t_ArrayBounds ;

		t_ArrayBounds.cElements = 2;
		t_ArrayBounds.lLbound = 0;

		SAFEARRAY *t_SafeArray = NULL ;

		if ( t_SafeArray = SafeArrayCreate ( VT_I2 , 1 , & t_ArrayBounds ) )
		{
			long t_Capability = 3 ;
			long t_Index = 0;
			SafeArrayPutElement ( t_SafeArray , & t_Index , & t_Capability) ;

			t_Index = 1;
			t_Capability = 7 ;
			SafeArrayPutElement ( t_SafeArray , & t_Index , & t_Capability ) ;

			VARIANT t_CapabilityValue ;
			VariantInit( & t_CapabilityValue ) ;

			V_VT ( & t_CapabilityValue ) = VT_I2 | VT_ARRAY ;
			V_ARRAY ( & t_CapabilityValue ) = t_SafeArray ;

			a_Instance->SetVariant ( IDS_Capabilities , t_CapabilityValue ) ;

			VariantClear ( & t_CapabilityValue ) ;
		}
	}
    */

	if ( a_SpecifiedProperties & ( SPECIAL_PROPS_AVAILABILITY || SPECIAL_PROPS_STATUS || SPECIAL_PROPS_STATUSINFO ) )
	{
        CHString t_sStatus;
		if ( a_Device->GetStatus ( t_sStatus ) )
		{
			if (t_sStatus == IDS_STATUS_Degraded)
            {
				a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
				a_Instance->SetWBEMINT16 ( IDS_Availability , 10 ) ;
            }
            else if (t_sStatus == IDS_STATUS_OK)
            {

				a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
				a_Instance->SetWBEMINT16 ( IDS_Availability,  3 ) ;
            }
            else if (t_sStatus == IDS_STATUS_Error)
            {
				a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 4 ) ;
				a_Instance->SetWBEMINT16 ( IDS_Availability , 4 ) ;
            }
            else
            {
				a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 2 ) ;
				a_Instance->SetWBEMINT16 ( IDS_Availability , 2 ) ;
            }

            a_Instance->SetCHString(IDS_Status, t_sStatus);
        }
	}

	return t_Result ;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32_ScsiController::IsOneOfMe
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of SCSI device.
 *
 *  INPUTS      : CConfigMgrDevice* pDevice - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid USB class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32_ScsiController::IsOneOfMe(void* pv)
{
    bool fRet = false;

    if(pv != NULL)
    {
        CConfigMgrDevice* pDevice = (CConfigMgrDevice*) pv;
        // Ok, it knows about it.  Is it a usb device?
        if(pDevice->IsClass(CONFIG_MANAGER_CLASS_SCSICONTROLLER) )
        {
            fRet = true;
        }
    }
    return fRet;
}

DWORD CWin32_ScsiController::GetBitmap(CFrameworkQuery &a_Query)
{

    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_StatusInfo ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUSINFO ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Drive ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DRIVE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Id ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_ID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Capabilities ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPABILITY ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Availability ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_AVAILABILITY ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    if (a_Query.IsPropertyRequired (IDS_DriverName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_DRIVERNAME;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\secureregkey.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CSecureRegistryKey.h - header file for CSecureRegistryKey class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSECUREREGKEY_H__
#define __CSECUREREGKEY_H__




/*
 *	Class CSecureRegistryKey is a helper class. It groups user CSid together with its access mask.
 */ 

class CSecureRegistryKey : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CSecureRegistryKey();
		CSecureRegistryKey( HKEY hKeyParent, LPCTSTR pszKeyName, BOOL fGetSACL = TRUE );
		~CSecureRegistryKey();

		DWORD	SetKey( HKEY hKeyParent, LPCTSTR pszKeyName, BOOL fGetSACL = TRUE );

		virtual DWORD AllAccessMask( void );

	protected:

		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD );
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD , SECURITY_INFORMATION securityinfo  );

	private:
		HKEY	m_hParentKey;
		CHString	m_strKeyName;

};

#endif // __CSecureRegistryKey_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\secureregkey.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	SecurityDescriptor.cpp - implementation file for CSecureRegistryKey class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"

#include "SecurityDescriptor.h"			// CSid class
#include "secureregkey.h"
#include "tokenprivilege.h"


/*
 *	This constructor is the default
 */

CSecureRegistryKey::CSecureRegistryKey()
:	CSecurityDescriptor(),
	m_hParentKey( NULL ),
	m_strKeyName()
{
}

// This constructor takes in a parent key and key name, which it uses
// to initialize our security.
CSecureRegistryKey::CSecureRegistryKey( HKEY hParentKey, LPCTSTR pszRegKeyName, BOOL fGetSACL /*= TRUE*/ )
:	CSecurityDescriptor(),
	m_hParentKey( NULL ),
	m_strKeyName()
{
	SetKey( hParentKey, pszRegKeyName );
}

/*
 *	Destructor.
 */

CSecureRegistryKey::~CSecureRegistryKey( void )
{
}

// This function provides an entry point for obtaining a registry key and using
// it to get to its security descriptor so we can get who's who and what's what

DWORD CSecureRegistryKey::SetKey( HKEY hParentKey, LPCTSTR pszRegKeyName, BOOL fGetSACL /*= TRUE*/ )
{
	REGSAM	dwAccessMask = STANDARD_RIGHTS_READ;
	SECURITY_INFORMATION	siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;

	// We must have the security privilege enabled in order to access the object's SACL
	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( fGetSACL )
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
		dwAccessMask |= ACCESS_SYSTEM_SECURITY;
		siFlags |= SACL_SECURITY_INFORMATION;
	}

	// Open handle to the key
	HKEY	hKey	=	NULL;
	DWORD	dwError	=	RegOpenKeyEx(	hParentKey,				// Root key.
										pszRegKeyName,			// Subkey.
										NULL,						// Reserved, must be NULL.
										dwAccessMask,		// Access desired.
										&hKey );

	// if unable to open registry key, simply return error message.
	if ( dwError == ERROR_SUCCESS )
	{
		// Determine the length needed for self-relative SD
		DWORD dwLengthNeeded = 0;
		dwError = ::RegGetKeySecurity( hKey,
						siFlags,
						NULL,
						&dwLengthNeeded );

		// The only expected error at this point is insufficcient buffer
		if ( ERROR_INSUFFICIENT_BUFFER == dwError )
		{
            PSECURITY_DESCRIPTOR	pSD;
			pSD = NULL;
            try
            {
                pSD = malloc( dwLengthNeeded );

			    if ( NULL != pSD )
			    {
				    // Now obtain security descriptor
				    dwError = ::RegGetKeySecurity( hKey,
								    siFlags,
								    pSD,
								    &dwLengthNeeded );

				    if ( ERROR_SUCCESS == dwError )
				    {

					    if ( InitSecurity( pSD ) )
					    {
						    m_hParentKey = hParentKey;
						    m_strKeyName = pszRegKeyName;
					    }

				    }

				    // free up the security descriptor
				    //free( pSD );

			    }	// IF NULL != pSD
            }
            catch(...)
            {
                if(pSD != NULL)
                {
                    free(pSD);
                }
                throw;
            }
			free( pSD );

		}	// IF INSUFFICIENTBUFFER

		::RegCloseKey( hKey );


	}	// IF RegOpenKey

	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwError;

}

DWORD CSecureRegistryKey::WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo )
{
	REGSAM	dwAccessMask = WRITE_DAC;

	// We must have the security privilege enabled in order to access the object's SACL
	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( securityinfo & SACL_SECURITY_INFORMATION )
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
		dwAccessMask |= ACCESS_SYSTEM_SECURITY;
	}

	// Open with write DAC access
	HKEY	hKey	=	NULL;
	DWORD	dwResult =	RegOpenKeyEx(	m_hParentKey,				// Root key.
										TOBSTRT(m_strKeyName),		// Subkey.
										NULL,						// Reserved, must be NULL.
										dwAccessMask,				// Access desired.
										&hKey );

	if ( ERROR_SUCCESS == dwResult )
	{
		dwResult = ::RegSetKeySecurity( hKey,
										securityinfo,
										pAbsoluteSD );

		RegCloseKey( hKey );

	}

	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwResult;

}

DWORD CSecureRegistryKey::WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD )
{
	// Open with the appropriate access, set the security and leave

	HKEY	hKey	=	NULL;
	DWORD	dwResult =	RegOpenKeyEx( m_hParentKey,			// Root key.
								TOBSTRT(m_strKeyName),		// Subkey.
								NULL,						// Reserved, must be NULL.
								WRITE_OWNER,				// Access desired.
								&hKey );

	if ( ERROR_SUCCESS == dwResult )
	{
		dwResult = ::RegSetKeySecurity( hKey,
									OWNER_SECURITY_INFORMATION,
									pAbsoluteSD );

		RegCloseKey( hKey );

	}

	return dwResult;

}

DWORD CSecureRegistryKey::AllAccessMask( void )
{
	// Registry specific All Access Mask
	return KEY_ALL_ACCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\scsi.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  serialport.h
//
//  Purpose: scsi controller property set provider
//
//***************************************************************************

#ifndef _SCSI_H
#define _SCSI_H

//==================================
#define  PROPSET_NAME_SCSICONTROLLER L"Win32_SCSIController"
//#define  PROPSET_UUID_SCSIPORTS L"{14c7dd80-09a2-11cf-8d6f-00aa004bd99e}"

//==========================================================
// In WinNT the SCSI ports are enumerated under
// this key under HKEY_LOCAL_MACHINE
//==========================================================
#define WINNT_REG_SCSIPORT_KEY L"Hardware\\DeviceMap\\Scsi"
#define WIN95_REG_SCSIPORT_KEY L"ENUM\\Scsi"


#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_AVAILABILITY			0x00000001
#define SPECIAL_PROPS_STATUS				0x00000002
#define SPECIAL_PROPS_DEVICEID				0x00000004
#define SPECIAL_PROPS_CREATIONNAME			0x00000008
#define SPECIAL_PROPS_SYSTEMNAME			0x00000010
#define SPECIAL_PROPS_DESCRIPTION			0x00000020
#define SPECIAL_PROPS_CAPTION				0x00000040
#define SPECIAL_PROPS_NAME					0x00000080
#define SPECIAL_PROPS_MANUFACTURER			0x00000100
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000200
#define SPECIAL_PROPS_DRIVE					0x00000400
#define SPECIAL_PROPS_ID					0x00000800
#define SPECIAL_PROPS_CAPABILITY			0x00001000
#define SPECIAL_PROPS_PNPDEVICEID			0x00002000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00004000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x00008000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x00010000
#define SPECIAL_PROPS_HWREVISION			0x00020000
#define SPECIAL_PROPS_MAXIMUMLOGICALUNIT	0x00040000
#define SPECIAL_PROPS_STATUSINFO			0x00080000
#define SPECIAL_PROPS_DRIVERNAME            0x00100000


#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
                                    SPECIAL_PROPS_DRIVERNAME | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_SCSI				( SPECIAL_PROPS_HWREVISION | \
									SPECIAL_PROPS_MAXIMUMLOGICALUNIT )


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_SCSI )

#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000

#if ( NTONLY >= 5 )	

	#include "LPVParams.h"

	class CWin32_ScsiController;

	class W2K_SCSI_LPVParms : public CLPVParams
	{
	public:
		W2K_SCSI_LPVParms() {}
		W2K_SCSI_LPVParms(CInstance* pInstance, 
						  CConfigMgrDevice* pDevice,
						  CHString& chstrDeviceName,
						  TCHAR* tstrDosDeviceNameList,
                          DWORD dwWhichInstance,
						  UINT64 ui64SpecifiedProperties);
		~W2K_SCSI_LPVParms() {}
		CHString m_chstrDeviceName;
		TCHAR* m_tstrDosDeviceNameList;
		UINT64 m_ui64SpecifiedProperties;
        DWORD m_dwWhichInstance;

	};

	inline W2K_SCSI_LPVParms::W2K_SCSI_LPVParms(CInstance* pInstance, 
						  CConfigMgrDevice* pDevice,
						  CHString& chstrDeviceName,
						  TCHAR* tstrDosDeviceNameList,
                          DWORD dwWhichInstance,
						  UINT64 ui64SpecifiedProperties = SPECIAL_PROPS_ALL_REQUIRED) 
	:  CLPVParams(pInstance, pDevice, ui64SpecifiedProperties),
	   m_chstrDeviceName(chstrDeviceName),
	   m_tstrDosDeviceNameList(tstrDosDeviceNameList),
	   m_ui64SpecifiedProperties(ui64SpecifiedProperties),
       m_dwWhichInstance(dwWhichInstance)
	{
	}

#endif

// PROPERTY SET
//=============
class CWin32_ScsiController: virtual public Provider
{
    private:
      
    DWORD GetBitmap(CFrameworkQuery &a_Query);
	#if ( defined(WIN9XONLY) || NTONLY == 4 )	
	
		HRESULT OpenSCSIKey(CRegistry&	PrimaryReg, LPCTSTR szKey ) ;
		BOOL SetDateFromFileName(LPCTSTR szFileName,CInstance *& pInstance);


			// Winnt 
		#if NTONLY == 4
            typedef struct 
            {
                CRegistry *PrimaryReg;
                DWORD dwWhichInstance;
                CInstance* pInstance;
            } stValues;

			HRESULT RefreshNTInstance(CInstance* pInstance);
			HRESULT EnumerateNTInstances(MethodContext* pMethodContext);
			void GetNTCapabilities(CInstance* pInstance, DWORD dwWhichInstance);
			VOID SetStatusAndAvailabilityNT(CHString& chstrDeviceID, CInstance* pInstance);
		#endif
	
	#endif

	protected:

		virtual bool IsOneOfMe(void* pvData);

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			UINT64 a_SpecifiedProperties = SPECIAL_PROPS_ALL_REQUIRED
		) ;


        virtual HRESULT LoadPropertyValues(void* pvData);

#if ( NTONLY >= 5 )	
        // Utility function(s)
        //====================
        virtual bool ShouldBaseCommit(void* pvData);
#endif

	#if NTONLY >= 5
        CRITICAL_SECTION m_CriticalSection ;

		HRESULT LoadConfigManagerPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			UINT64 a_SpecifiedProperties
		) ;

		HRESULT GetDeviceInformation ( 

			CInstance *a_Instance ,
			CConfigMgrDevice *a_Device , 
			CHString a_DeviceName , 
			CHString &a_DosDeviceName ,
			const TCHAR *a_DosDeviceNameList ,
			UINT64 a_SpecifiedProperties
		) ;

		HRESULT LoadMediaPropertyValues (	

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const CHString &a_DosDeviceName , 
			UINT64 a_SpecifiedProperties 
		) ;

	#endif

public:

        // Constructor/destructor
        //=======================

        CWin32_ScsiController (LPCWSTR a_Name, LPCWSTR a_Namespace ) ;
       ~CWin32_ScsiController () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( CInstance *a_Instance, long a_Flags, CFrameworkQuery &a_Query );

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

 	
	#if NTONLY >= 5

		HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;
	
	#else	
		WORD LookupProtocol( CHString a_sSeek ) ;
	#endif
};

#if ( NTONLY >= 5 )	
	// This is the base; it should always commit in the base.
	inline bool CWin32_ScsiController::ShouldBaseCommit(void* pvData) { return true; }
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\serialportcfg.cpp ===
//=================================================================

//

// SerialPortCfg.cpp --Serial port configuration property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/24/97    jennymc        Moved to new framework
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>

#include "WDMBase.h"
#include "SerialPortCfg.h"

#include <profilestringimpl.h>
#include <strsafe.h>
// Property set declaration
//=========================
CWin32SerialPortConfiguration MyCWin32SerialPortConfigurationSet(PROPSET_NAME_SERIALCONFIG, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPortConfiguration::CWin32SerialPortConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SerialPortConfiguration::CWin32SerialPortConfiguration(
    LPCWSTR name,
    LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPortConfiguration::~CWin32SerialPortConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32SerialPortConfiguration::~CWin32SerialPortConfiguration()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SerialPortConfiguration::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
	HRESULT			hResult = WBEM_E_NOT_FOUND;
	CInstancePtr	pinstPort;
	CHString		strName,
					strPath;

	pInstance->GetCHString(IDS_Name, strName);

	strPath.Format(
		L"Win32_SerialPort.DeviceID=\"%s\"",
		(LPCWSTR) strName);

	// Try to find the item.
	hResult =
		CWbemProviderGlue::GetInstanceByPath(
			strPath,
			&pinstPort, pInstance->GetMethodContext());

	if (SUCCEEDED(hResult))
	{
		pInstance->SetCharSplat(IDS_Name, strName);
		hResult = LoadPropertyValues(pInstance, strName, FALSE);
	}

	return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SerialPortConfiguration::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance>
				listPorts;
	REFPTRCOLLECTION_POSITION
				posPorts;

	// guarded resources
	CInstancePtr pinstPort;

	// grab all of both items that could be endpoints
	hResult =
		CWbemProviderGlue::GetAllInstances(
			L"Win32_SerialPort",
			&listPorts,
			NULL,
			pMethodContext);

	if (SUCCEEDED(hResult))
	{
		if (listPorts.BeginEnum(posPorts))
		{
			for (pinstPort.Attach(listPorts.GetNext(posPorts));
				pinstPort != NULL && SUCCEEDED(hResult);
				pinstPort.Attach(listPorts.GetNext(posPorts)))
			{
				CHString strPort;

				if (pinstPort->GetCHString(L"DeviceID", strPort))
				{
					CInstancePtr pInst;

					pInst.Attach(CreateNewInstance(pMethodContext));

					pInst->SetCharSplat(IDS_Name, strPort);
					hResult = LoadPropertyValues(pInst, strPort, FALSE);
					if (SUCCEEDED(hResult))
						hResult = pInst->Commit();
				}
			}

			listPorts.EndEnum();
		}
	}

	return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties according to passed index
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if port was found & properties loaded, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32SerialPortConfiguration::GetDCBPropsViaIni(LPCTSTR szPort, DCB &dcb)
{
    CHString strBuffer;
    TCHAR    szBuffer[_MAX_PATH];
    BOOL     bRet;

	// get the com port info out of the WIN.INI file
	WMIRegistry_ProfileString(
								_T("Ports"),
								szPort,
								_T("9600,n,8,1,x"),
								szBuffer,
								sizeof(szBuffer) / sizeof(TCHAR));

    strBuffer = szBuffer;

    // Make sure the string is at least half way valid.
    if (CountCommas(strBuffer) >= 3)
    {
	    CHString strTemp;

        // Baud rate
        strTemp = strBuffer.SpanExcluding(L",");
        dcb.BaudRate = _wtol(strTemp);
        strBuffer = strBuffer.Mid(strTemp.GetLength() + 1);

        // Parity
        strTemp = strBuffer.SpanExcluding(L",");
        strBuffer = strBuffer.Mid(strTemp.GetLength() + 1);
        dcb.Parity = NOPARITY; // Setup a default.
        if (strTemp.GetLength() > 0)
		{
            switch (strTemp[0])
			{
			    case _T('o'):
				    dcb.Parity = ODDPARITY;
					break;
                case _T('e'):
				    dcb.Parity = EVENPARITY;
					break;
			    case _T('m'):
					dcb.Parity = MARKPARITY;
					break;
                case _T('n'):
				    dcb.Parity = NOPARITY;
					break;
		    }
		}

        // ByteSize
        strTemp = strBuffer.SpanExcluding(L",");
        dcb.ByteSize = _wtol(strTemp);
        strBuffer = strBuffer.Mid(strTemp.GetLength() + 1);

        // Stop bits
        strTemp = strBuffer.SpanExcluding(L",");
        strTemp.TrimRight();
	    if (strTemp == L"1.5")
		    dcb.StopBits = ONE5STOPBITS;
        else if (strTemp == L"2")
		    dcb.StopBits = TWOSTOPBITS;
        else
		    // The default.
            dcb.StopBits = ONESTOPBIT;

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

HRESULT CWin32SerialPortConfiguration::LoadPropertyValues(
    CInstance *pInstance,
    CHString &sPortName,
    bool bIsMouse)
{
    TCHAR   szTemp[_MAX_PATH],
            szPort[_MAX_PATH];
    HANDLE  hCOMHandle;
    DCB     dcb = { sizeof(DCB) };
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL    bGotDCB = FALSE,
            bGotIniSettings = FALSE;

    pInstance->Setbool(IDS_IsBusy, FALSE);
    pInstance->SetCharSplat(IDS_Description, sPortName);
    pInstance->SetCharSplat(IDS_Caption, sPortName);

    StringCchPrintf(szTemp, _MAX_PATH, _T("\\\\.\\%s"), (LPCTSTR) TOBSTRT(sPortName));
	StringCchPrintf(szPort,_MAX_PATH, _T("%s:"), (LPCTSTR) TOBSTRT(sPortName));


	hCOMHandle =
        CreateFile(
            szTemp,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hCOMHandle == INVALID_HANDLE_VALUE)
    {
		DWORD dwErr = GetLastError();

        // Try using wmi's interface to the kernel
		if (WBEM_S_NO_ERROR != hLoadWmiSerialData( pInstance))
		{
			// ACCESS_DENIED and IRQ_BUSY indicate that the port is in
			// use or in conflict with something else.
			if (dwErr == ERROR_ACCESS_DENIED ||
                dwErr == ERROR_IRQ_BUSY ||
                bIsMouse)
			{
				pInstance->Setbool( IDS_IsBusy, TRUE);
			}
			else
			{
				hr = WBEM_E_NOT_FOUND;
			}
		}
    }
    else
    {
		// So the handle will go away when we need it to.
		SmartCloseHandle handle(hCOMHandle);

		if (GetCommState(hCOMHandle, &dcb))
        {
	        pInstance->SetDWORD(IDS_XOnXMitThreshold, dcb.XonLim);
		    pInstance->SetDWORD(IDS_XOffXMitThreshold, dcb.XoffLim);
			pInstance->SetDWORD(IDS_XOnCharacter, dcb.XonChar);
			pInstance->SetDWORD(IDS_XOffCharacter, dcb.XoffChar);
			pInstance->SetDWORD(IDS_ErrorReplaceCharacter, dcb.ErrorChar);
			pInstance->SetDWORD(IDS_EndOfFileCharacter, dcb.EofChar);
			pInstance->SetDWORD(IDS_EventCharacter, dcb.EvtChar);

			pInstance->Setbool(IDS_BinaryModeEnabled, dcb.fBinary           ? TRUE : FALSE);
			pInstance->Setbool(IDS_ParityCheckEnabled, dcb.fParity           ? TRUE : FALSE);
			pInstance->Setbool(IDS_CTSOutflowControl, dcb.fOutxCtsFlow      ? TRUE : FALSE);
			pInstance->Setbool(IDS_DSROutflowControl, dcb.fOutxDsrFlow      ? TRUE : FALSE);
			pInstance->Setbool(IDS_DSRSensitivity, dcb.fDsrSensitivity   ? TRUE : FALSE);
			pInstance->Setbool(IDS_ContinueXMitOnXOff, dcb.fTXContinueOnXoff ? TRUE : FALSE);
			pInstance->Setbool(IDS_XOnXOffOutflowControl, dcb.fOutX             ? TRUE : FALSE);
			pInstance->Setbool(IDS_XOnXOffInflowControl, dcb.fInX              ? TRUE : FALSE);
			pInstance->Setbool(IDS_ErrorReplacementEnabled, dcb.fErrorChar        ? TRUE : FALSE);
			pInstance->Setbool(IDS_DiscardNULLBytes, dcb.fNull             ? TRUE : FALSE);
			pInstance->Setbool(IDS_AbortReadWriteOnError, dcb.fAbortOnError     ? TRUE : FALSE);

			pInstance->SetCHString(IDS_DTRFlowControlType, dcb.fDtrControl   == DTR_CONTROL_DISABLE  ? L"DISABLE"    :
				dcb.fDtrControl   == DTR_CONTROL_ENABLE   ? L"ENABLE"     :
				L"HANDSHAKE" );

			pInstance->SetCHString(IDS_RTSFlowControlType, dcb.fRtsControl   == RTS_CONTROL_DISABLE  ? L"DISABLE"    :
				dcb.fRtsControl   == RTS_CONTROL_ENABLE   ? L"ENABLE"     :
				dcb.fRtsControl   == RTS_CONTROL_TOGGLE   ? L"TOGGLE"     :
				L"HANDSHAKE" );
		}
    }

    // The ini values will override the DCB values as the DCB doesn't seem to
    // ever reflect the proper values.  The OS UI uses the .ini to display
    // these four values.
    bGotIniSettings =
        GetDCBPropsViaIni(szPort, dcb);

    if (bGotIniSettings || bGotDCB)
    {
        pInstance->SetDWORD(IDS_BaudRate, dcb.BaudRate);
		pInstance->SetDWORD(IDS_BitsPerByte, dcb.ByteSize);
		pInstance->SetCHString(IDS_Parity, dcb.Parity == ODDPARITY ? L"ODD" :
		    dcb.Parity == EVENPARITY ? L"EVEN" :
			dcb.Parity == MARKPARITY ? L"MARK" : L"NONE");

        pInstance->SetCHString(IDS_StopBits, dcb.StopBits == ONESTOPBIT ? L"1" :
		    dcb.StopBits == ONE5STOPBITS ? L"1.5" : L"2");
    }

    return hr;
}

// just like the name says, tries to find the port in a different place in the registry
// note that  "dwPort" is zero based.
BOOL CWin32SerialPortConfiguration::TryToFindNTCommPort(DWORD dwPort, CHString& strSerialPort, bool& bIsMouse)
{
	BOOL bRet = FALSE;
	bIsMouse = false;
	CRegistry reg;
	if (reg.Open(HKEY_LOCAL_MACHINE,
        L"HARDWARE\\DESCRIPTION\\SYSTEM\\MultifunctionAdapter",
        KEY_READ) == ERROR_SUCCESS)
	{
		DWORD count;
		count = reg.GetCurrentSubKeyCount();
		if (count > 0)
		{
			CHString key;
			key.Format(L"HARDWARE\\DESCRIPTION\\SYSTEM\\MultifunctionAdapter\\%d\\SerialController\\%d",
                count -1, dwPort);
			if (reg.Open(HKEY_LOCAL_MACHINE, key, KEY_READ) == ERROR_SUCCESS)
				if (bRet = (reg.GetCurrentKeyValue(L"Identifier", strSerialPort) == ERROR_SUCCESS))
				{
					key += L"\\PointerPeripheral";
					bIsMouse = (reg.Open(HKEY_LOCAL_MACHINE, key, KEY_READ) == ERROR_SUCCESS);
				}
		}
	}

	return bRet;
}

BOOL CWin32SerialPortConfiguration::TryToFindNTCommPortFriendlyName()
{
	// returning zero instances is not an error
	BOOL bRet = FALSE;
    DWORD dwPort;
    WCHAR szTemp[_MAX_PATH];
    CHString sPortName;
    CRegistry RegInfo;

    // Retrieve "friendly" names of COM ports
    //=======================================

    if(RegInfo.Open(HKEY_LOCAL_MACHINE, L"Hardware\\DeviceMap\\SerialComm",
        KEY_READ) == ERROR_SUCCESS) {

        for(dwPort = 0; dwPort < 16; dwPort++)
		{
			WCHAR *pKey;
#ifdef NTONLY
			{
				if (GetPlatformMajorVersion() >= 5)
					pKey = L"\\Device\\Serial";
				else
					pKey = L"Serial";
			}
#endif

            StringCchPrintf(szTemp,_MAX_PATH, L"%s%d", pKey, dwPort);


			bool bIsMouse = false;
#ifdef NTONLY
            if (RegInfo.GetCurrentKeyValue(szTemp, sPortName) == ERROR_SUCCESS ||
				TryToFindNTCommPort(dwPort, sPortName, bIsMouse))
#endif
			{
                bRet = TRUE;
            }
        }
        RegInfo.Close();
    }
    return bRet;
}

LONG CWin32SerialPortConfiguration::CountCommas(LPCWSTR szText)
{
    LONG    nCommas = 0;
    LPCWSTR szCurrent;

    for (szCurrent = szText; *szCurrent; szCurrent++)
    {
        if (*szCurrent == ',')
            nCommas++;
    }

    return nCommas;

}

#define Serial_ComInfo_Guid L"{EDB16A62-B16C-11D1-BD98-00A0C906BE2D}"
#define Serial_Name_Guid	L"{A0EC11A8-B16C-11D1-BD98-00A0C906BE2D}"

HRESULT CWin32SerialPortConfiguration::hLoadWmiSerialData( CInstance* pInstance)
{
	HRESULT			hRes;
	CWdmInterface	wdm;
	CNodeAll		oSerialNames(Serial_Name_Guid);

	hRes = wdm.hLoadBlock( oSerialNames);
	if(S_OK == hRes)
	{
		CHString chsName;
		pInstance->GetCHString( IDS_Name, chsName);

	    // Haven't found it yet.
        hRes = WBEM_E_NOT_FOUND;

		CHString chsSerialPortName;
		bool bValid = oSerialNames.FirstInstance();

		while( bValid)
		{
			// extract the friendly name
			oSerialNames.GetString( chsSerialPortName);

			// friendly name is a match
			if( !chsSerialPortName.CompareNoCase(chsName))
			{
				// instance name
				CHString chsNameInstanceName;
				oSerialNames.GetInstanceName( chsNameInstanceName);

				// key on the instance name
				return GetWMISerialInfo( pInstance, wdm, chsName, chsNameInstanceName);

			}
			bValid = oSerialNames.NextInstance();
		}
	}
	return hRes;
}

//
HRESULT CWin32SerialPortConfiguration::GetWMISerialInfo(
    CInstance* pInstance,
    CWdmInterface& rWdm,
    CHString& chsName,
    CHString& chsNameInstanceName)
{
	HRESULT		hRes = WBEM_E_NOT_FOUND;
	CNodeAll	oSerialData(Serial_ComInfo_Guid);

	hRes = rWdm.hLoadBlock( oSerialData);
	if(S_OK == hRes)
	{
		CHString chsDataInstanceName;
		bool bValid = oSerialData.FirstInstance();

		while( bValid)
		{
			oSerialData.GetInstanceName( chsDataInstanceName);

			// friendly name is a match
			if( !chsDataInstanceName.CompareNoCase( chsNameInstanceName))
			{
				// collect this MSSerial_CommInfo instance
				MSSerial_CommInfo ci;

				/*	We are currently without a class contract. The class within
					the wmi mof is not expected to changed however we have to
					explicitly indicate how the data is layed out. Having the class
					definition would allow us to examine the property qualifiers
					to get us the order (WmiDataId) and property types.

					Secondly, because the data is aligned on natural boundaries
					a direct offset to a specific piece of data is conditioned on
					what has preceeded it. Thus, a string followed by a DWORD may
					be 1 to 3 bytes away from each other.

					Serially extracting each property in order will take into
					account the alignment problem.
				*/
				oSerialData.GetDWORD( ci.BaudRate);
				oSerialData.GetDWORD( ci.BitsPerByte);
				oSerialData.GetDWORD( ci.Parity);
				oSerialData.GetBool( ci.ParityCheckEnable);
				oSerialData.GetDWORD( ci.StopBits);
				oSerialData.GetDWORD( ci.XoffCharacter);
				oSerialData.GetDWORD( ci.XoffXmitThreshold);
				oSerialData.GetDWORD( ci.XonCharacter);
				oSerialData.GetDWORD( ci.XonXmitThreshold);
				oSerialData.GetDWORD( ci.MaximumBaudRate);
				oSerialData.GetDWORD( ci.MaximumOutputBufferSize);
				oSerialData.GetDWORD( ci.MaximumInputBufferSize);
				oSerialData.GetBool( ci.Support16BitMode);
				oSerialData.GetBool( ci.SupportDTRDSR);
				oSerialData.GetBool( ci.SupportIntervalTimeouts);
				oSerialData.GetBool( ci.SupportParityCheck);
				oSerialData.GetBool( ci.SupportRTSCTS);
				oSerialData.GetBool( ci.SupportXonXoff);
				oSerialData.GetBool( ci.SettableBaudRate);
				oSerialData.GetBool( ci.SettableDataBits);
				oSerialData.GetBool( ci.SettableFlowControl);
				oSerialData.GetBool( ci.SettableParity);
				oSerialData.GetBool( ci.SettableParityCheck);
				oSerialData.GetBool( ci.SettableStopBits);
				oSerialData.GetBool( ci.IsBusy);

				// populate the instance
				pInstance->SetDWORD(IDS_BaudRate,			ci.BaudRate);
				pInstance->SetDWORD(IDS_XOnXMitThreshold,	ci.XonXmitThreshold);
				pInstance->SetDWORD(IDS_XOffXMitThreshold,	ci.XoffXmitThreshold);
				pInstance->SetDWORD(IDS_BitsPerByte,		ci.BitsPerByte);
				pInstance->SetDWORD(IDS_XOnCharacter,		ci.XonCharacter);
				pInstance->SetDWORD(IDS_XOffCharacter,		ci.XoffCharacter);
				pInstance->Setbool(IDS_ParityCheckEnabled,  ci.ParityCheckEnable ? TRUE : FALSE);


				pInstance->SetCHString(IDS_Parity, ci.Parity == ODDPARITY ? L"ODD" :
									  ci.Parity == EVENPARITY ? L"EVEN" :
									  ci.Parity == MARKPARITY ? L"MARK" : L"NONE");

				pInstance->SetCHString(IDS_StopBits, ci.StopBits == ONESTOPBIT ? L"1" :
													 ci.StopBits == ONE5STOPBITS ? L"1.5" : L"2");
				pInstance->Setbool( IDS_IsBusy, ci.IsBusy);

				return WBEM_S_NO_ERROR;
			}
			bValid = oSerialData.NextInstance();
		}
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\serialport.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//  w2k\serialport.cpp
//
//  Purpose: serialport property set provider
//
//***************************************************************************

#include "precomp.h"

#include <winbase.h>
#include <winioctl.h>
#include <ntddscsi.h>

#include <FRQueryEx.h>
#include <devguid.h>
#include <cregcls.h>

#include "..\WDMBase.h"
#include "..\serialport.h"
#include <strsafe.h>

#include <comdef.h>


// Property set declaration
//=========================

CWin32SerialPort win32SerialPort(PROPSET_NAME_SERPORT, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::CWin32SerialPort
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SerialPort::CWin32SerialPort(
	LPCWSTR pszName,
	LPCWSTR pszNamespace) :
    Provider(pszName, pszNamespace)
{
    // Identify the platform right away
    //=================================

	// property set names for query optimization
	m_ptrProperties.SetSize(e_End_Property_Marker);

	// Win32_SerialPort
	m_ptrProperties[e_Binary]					=(LPVOID) IDS_Binary;
	m_ptrProperties[e_MaximumInputBufferSize]	=(LPVOID) IDS_MaximumInputBufferSize;
	m_ptrProperties[e_MaximumOutputBufferSize]	=(LPVOID) IDS_MaximumOutputBufferSize;
	m_ptrProperties[e_ProviderType]				=(LPVOID) IDS_ProviderType;
	m_ptrProperties[e_SettableBaudRate]			=(LPVOID) IDS_SettableBaudRate;
	m_ptrProperties[e_SettableDataBits]			=(LPVOID) IDS_SettableDataBits;
	m_ptrProperties[e_SettableFlowControl]		=(LPVOID) IDS_SettableFlowControl;
	m_ptrProperties[e_SettableParity]			=(LPVOID) IDS_SettableParity;
	m_ptrProperties[e_SettableParityCheck]		=(LPVOID) IDS_SettableParityCheck;
	m_ptrProperties[e_SettableRLSD]				=(LPVOID) IDS_SettableRLSD;
	m_ptrProperties[e_SettableStopBits]			=(LPVOID) IDS_SettableStopBits;
	m_ptrProperties[e_Supports16BitMode]		=(LPVOID) IDS_Supports16BitMode;
	m_ptrProperties[e_SupportsDTRDSR]			=(LPVOID) IDS_SupportsDTRDSR;
	m_ptrProperties[e_SupportsElapsedTimeouts]	=(LPVOID) IDS_SupportsElapsedTimeouts;
	m_ptrProperties[e_SupportsIntTimeouts]		=(LPVOID) IDS_SupportsIntervalTimeouts;
	m_ptrProperties[e_SupportsParityCheck]		=(LPVOID) IDS_SupportsParityCheck;
	m_ptrProperties[e_SupportsRLSD]				=(LPVOID) IDS_SupportsRLSD;
	m_ptrProperties[e_SupportsRTSCTS]			=(LPVOID) IDS_SupportsRTSCTS;
	m_ptrProperties[e_SupportsSpecialCharacters]=(LPVOID) IDS_SupportsSpecialChars;
	m_ptrProperties[e_SupportsXOnXOff]			=(LPVOID) IDS_SupportsXOnXOff;
	m_ptrProperties[e_SupportsXOnXOffSet]		=(LPVOID) IDS_SupportsSettableXOnXOff;
	m_ptrProperties[e_OSAutoDiscovered]			=(LPVOID) IDS_OSAutoDiscovered;

	// CIM_SerialController
	m_ptrProperties[e_MaxBaudRate]				=(LPVOID) IDS_MaximumBaudRate;

	// CIM_Controller
	m_ptrProperties[e_MaxNumberControlled]		=(LPVOID) IDS_MaxNumberControlled;
	m_ptrProperties[e_ProtocolSupported]		=(LPVOID) IDS_ProtocolSupported;
	m_ptrProperties[e_TimeOfLastReset]			=(LPVOID) IDS_TimeOfLastReset;

	// CIM_LogicalDevice
	m_ptrProperties[e_Availability]				=(LPVOID) IDS_Availability;
	m_ptrProperties[e_CreationClassName]		=(LPVOID) IDS_CreationClassName;
	m_ptrProperties[e_ConfigManagerErrorCode]	=(LPVOID) IDS_ConfigManagerErrorCode;
	m_ptrProperties[e_ConfigManagerUserConfig]	=(LPVOID) IDS_ConfigManagerUserConfig;
	m_ptrProperties[e_DeviceID]					=(LPVOID) IDS_DeviceID;
	m_ptrProperties[e_PNPDeviceID]				=(LPVOID) IDS_PNPDeviceID;
	m_ptrProperties[e_PowerManagementCapabilities] =(LPVOID) IDS_PowerManagementCapabilities;
	m_ptrProperties[e_PowerManagementSupported] =(LPVOID) IDS_PowerManagementSupported;
	m_ptrProperties[e_StatusInfo]				=(LPVOID) IDS_StatusInfo;
	m_ptrProperties[e_SystemCreationClassName]	=(LPVOID) IDS_SystemCreationClassName;
	m_ptrProperties[e_SystemName]				=(LPVOID) IDS_SystemName;

	// CIM_ManagedSystemElement
	m_ptrProperties[e_Caption]					=(LPVOID) IDS_Caption;
	m_ptrProperties[e_Description]				=(LPVOID) IDS_Description;
	m_ptrProperties[e_InstallDate]				=(LPVOID) IDS_InstallDate;
	m_ptrProperties[e_Name]						=(LPVOID) IDS_Name;
	m_ptrProperties[e_Status]					=(LPVOID) IDS_Status;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::~CWin32SerialPort
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32SerialPort::~CWin32SerialPort()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32SerialPort::GetObject
//
//  Inputs:     CInstance*      pInst - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SerialPort::GetObject(CInstance *pInst, long lFlags, CFrameworkQuery &Query)
{
    BYTE bBits[e_End_Property_Marker/8 + 1];

	CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&Query);

	pQuery2->GetPropertyBitMask(m_ptrProperties, &bBits);

    return Enumerate(NULL, pInst, lFlags, bBits);
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32SerialPort::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SerialPort::EnumerateInstances(MethodContext *pMethodContext, long Flags)
{
	HRESULT hResult;

	// Property mask
	BYTE bBits[e_End_Property_Marker/8 + 1];
	SetAllBits(&bBits, e_End_Property_Marker);

	hResult = Enumerate(pMethodContext, NULL, Flags, bBits);

	return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SerialPort::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery &Query, long lFlags)
{
    HRESULT hResult;

    BYTE bBits[e_End_Property_Marker/8 + 1];

	CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&Query);

	pQuery2->GetPropertyBitMask(m_ptrProperties, &bBits);

  	hResult = Enumerate(pMethodContext, NULL, lFlags, bBits);

    return hResult;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32SerialPort::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

// Used to keep track of which ports we've already seen.
typedef std::map<CHString, BOOL> STRING2BOOL;

HRESULT CWin32SerialPort::Enumerate(
    MethodContext *pMethodContext,
    CInstance *pinstGetObj,
    long Flags,
    BYTE bBits[])
{
    // Here's the story: W2K will 'create' COM ports for various devices that
    // get plugged into the box, like modems, IR devices, etc.  These COM
    // ports won't show up in cfg mgr under the Ports class, because they
    // share the same device ID with the host device.  But, these COM
    // ports do show up in Hardware\DeviceMap\SerialComm.  So, enum the
    // values in the SerialCom and use the service name to enum the ports
    // found in the registry under the service name.  Examples:
    // \Device\Serial0 = COM1  --> Go to \SYSTEM\CurrentControlSet\Serial\Enum
    //                             From 0 to Count, get the PnPID and add the port
    // \Device\Serial1 = COM2  --> Skip since we already enumed Serial\Enum
    // RocketPort0     = COM5  --> Go to \SYSTEM\CurrentControlSet\RocketPort\Enum
    //                             From 0 to Count, get the PnPID and add the port
    //
    // This also allows us to pick up COM ports that aren't functioning because
    // such ports show up on the Enum key, but not in Hardware\DeviceMap\SerialComm.


    HRESULT   hResult = WBEM_S_NO_ERROR;
    CRegistry reg;
    BOOL      bDone = FALSE;

	if (reg.Open(
        HKEY_LOCAL_MACHINE,
        L"Hardware\\DeviceMap\\SerialComm",
        KEY_READ) == ERROR_SUCCESS)
	{
        STRING2BOOL    mapServices;
	    int            nKeys = reg.GetValueCount();
        CInstancePtr   pInstance;
        CHString       strDeviceID;
        CConfigManager cfgMgr;

	    // If this is a GetObject, get the DeviceID.
        if (!pMethodContext)
        {
            pinstGetObj->GetCHString(L"DeviceID", strDeviceID);
        }

		for (DWORD dwKey = 0;
            dwKey < nKeys && SUCCEEDED(hResult) && !bDone;
            dwKey++)
		{
		    WCHAR *pName;
            BYTE  *pValue;

            if (reg.EnumerateAndGetValues(
                dwKey,
                pName,
                pValue) != ERROR_SUCCESS)
			{
				continue;
			}

            // Wrap with CSmartBuffer so the memory will go away when the
            // variables go out of scope.
            CSmartBuffer bufferName((LPBYTE) pName),
                         bufferValue(pValue);
            CHString     strService;

            RegNameToServiceName(pName, strService);

            // Have we not seen this service name yet?
            if (mapServices.find(strService) == mapServices.end())
            {
			    CConfigMgrDevicePtr pDevice;
                CRegistry           regEnum;
                CHString            strKey;

                // Make sure we don't do this service again.
                mapServices[strService] = 0;

                strKey.Format(
                    L"SYSTEM\\CurrentControlSet\\Services\\%s\\Enum",
                    (LPCWSTR) strService);

                if (regEnum.Open(
                    HKEY_LOCAL_MACHINE,
                    strKey,
                    KEY_READ) == ERROR_SUCCESS)
                {
                    DWORD dwCount = 0;

                    regEnum.GetCurrentKeyValue(L"Count", dwCount);

                    // Each registry value looks like:
                    // # = PNPID
                    for (DWORD dwCurrent = 0; dwCurrent < dwCount; dwCurrent++)
                    {
                        WCHAR               szValue[MAXITOA];
                        CHString            strPNPID;
              			CConfigMgrDevicePtr pDevice;

                        _itow(dwCurrent, szValue, 10);

                        regEnum.GetCurrentKeyValue(szValue, strPNPID);

                        if (cfgMgr.LocateDevice(strPNPID, pDevice))
                        {
                            CHString strKey;

                            if (pDevice->GetRegistryKeyName(strKey))
                            {
                                CRegistry regDeviceParam;
                                CHString  strPort;

                                strKey += L"\\Device Parameters";

                                regDeviceParam.OpenLocalMachineKeyAndReadValue(
                                    strKey,
                                    L"PortName",
                                    strPort);

                                if (!strPort.IsEmpty())
                                {
                					if (pMethodContext)
                                    {
                                        pInstance.Attach(CreateNewInstance(pMethodContext));

                                        hResult =
                                            LoadPropertyValues(
                                                pInstance,
                                                pDevice,
                                                strPort, // COM1, COM2, etc.
                                                bBits);

					                    if (SUCCEEDED(hResult))
					                    {
						                    hResult = pInstance->Commit();
					                    }
                                    }
                                    else if (!_wcsicmp(strPort, strDeviceID))
                                    {
                                        hResult =
                                            LoadPropertyValues(
                                                pinstGetObj,
                                                pDevice,
                                                strPort, // COM1, COM2, etc.
                                                bBits);

                                        bDone = TRUE;

                                        break;
                                    }
                                } // if (!strPort.IsEmpty())
                            } // if (pDevice->GetRegistryKeyName
                        } // if (cfgMgr.LocateDevice
                    } // for (DWORD dwCurrent = 0;
                } // if (regEnum.Open(
            } // if (mapServices.find(pName) == mapPorts.end())
        } // for (DWORD dwKey
    } // if (reg.Open == ERROR_SUCCESS)

	// If we're doing a get object and we never finished, return not found.
    if (!bDone && pinstGetObj)
        hResult = WBEM_E_NOT_FOUND;

    return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance *pInst - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SerialPort::LoadPropertyValues(
	CInstance *pInst,
	CConfigMgrDevice *pDevice,
	LPCWSTR szDeviceName,
	BYTE bBits[])
{
	HRESULT hResult = WBEM_S_NO_ERROR;

	// Begin of CIM_LogicalDevice properties

    // Availability -- preset, will be reset if different than this default
	if (IsBitSet(bBits, e_Availability))
	{
		//set the Availability to unknown...
		pInst->SetWBEMINT16(IDS_Availability, 2);
	}

	// CreationClassName
	if (IsBitSet(bBits, e_CreationClassName))
	{
		SetCreationClassName(pInst);
	}

	// ConfigManagerErrorCode
	if (IsBitSet(bBits, e_ConfigManagerErrorCode))
	{
		DWORD	dwStatus,
				dwProblem;

		if (pDevice->GetStatus(&dwStatus, &dwProblem))
		{
			pInst->SetDWORD(IDS_ConfigManagerErrorCode, dwProblem);
		}
	}

	// ConfigManagerUserConfig
	if (IsBitSet(bBits, e_ConfigManagerUserConfig))
	{
		pInst->SetDWORD(IDS_ConfigManagerUserConfig, pDevice->IsUsingForcedConfig());
	}

	//	DeviceID
    // Always populate the key
	pInst->SetCHString(IDS_DeviceID, szDeviceName);

	// PNPDeviceID
	if (IsBitSet(bBits, e_PNPDeviceID))
	{
		CHString	strDeviceID;

		if (pDevice->GetDeviceID(strDeviceID))
			pInst->SetCHString(IDS_PNPDeviceID, strDeviceID);
	}

	// PowerManagementCapabilities
	if (IsBitSet(bBits, e_PowerManagementCapabilities))
	{
		//set the PowerManagementCapabilities to not supported...
		variant_t      vCaps;
        SAFEARRAYBOUND rgsabound;
		long           ix;

        ix = 0;
		rgsabound.cElements = 1;
		rgsabound.lLbound   = 0;

		V_ARRAY(&vCaps) = SafeArrayCreate(VT_I2, 1, &rgsabound);
        V_VT(&vCaps) = VT_I2 | VT_ARRAY;

		if (V_ARRAY(&vCaps))
		{
			int iPowerCapabilities = 1; // not supported

        	if (S_OK == SafeArrayPutElement(V_ARRAY(&vCaps), &ix, &iPowerCapabilities))
			{
				pInst->SetVariant(IDS_PowerManagementCapabilities, vCaps);
			}
		}
    }

	// PowerManagementSupported
	if (IsBitSet(bBits, e_PowerManagementSupported))
	{
		pInst->Setbool(IDS_PowerManagementSupported, FALSE);
	}

	// SystemCreationClassName
	if (IsBitSet(bBits, e_SystemCreationClassName))
	{
		pInst->SetWCHARSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
	}

	// SystemName
	if (IsBitSet(bBits, e_SystemName))
	{
		pInst->SetCHString(IDS_SystemName, GetLocalComputerName());
	}



    // Begin of CIM_ManagedSystemElement properties
	CHString strFriendlyName,
             strDescription;

	pDevice->GetFriendlyName(strFriendlyName);
	pDevice->GetDeviceDesc(strDescription);

    if (strFriendlyName.IsEmpty())
        strFriendlyName = strDescription;

	// Caption
	if (IsBitSet(bBits, e_Caption))
	{
		pInst->SetCHString(IDS_Caption, strFriendlyName);
	}

	// Description
	if (IsBitSet(bBits, e_Description))
	{
		pInst->SetCHString(IDS_Description, strDescription);
	}

	// InstallDate
	// if (IsBitSet(bBits, e_InstallDate)){}

	// Name
	if (IsBitSet(bBits, e_Name))
	{
		pInst->SetCHString(IDS_Name, strFriendlyName);
	}

	// Status
	if (IsBitSet(bBits, e_Status))
	{
        CHString sStatus;
		if (pDevice->GetStatus(sStatus))
		{
			pInst->SetCHString(IDS_Status, sStatus);
		}
	}


    // Begin of properties local to Win32_SerialPort.
	SHORT	    Status = 2; // Unknown
	WCHAR		szTemp[MAX_PATH];
	SmartCloseHandle
                hCOMHandle;
	COMMPROP	COMProp;

	// OSAutoDiscovered
	if (IsBitSet(bBits, e_OSAutoDiscovered))
	{
		pInst->Setbool(IDS_OSAutoDiscovered,(bool) TRUE);
	}

	if (!pInst->IsNull(IDS_DeviceID))
	{
		CHString sPortName;
		pInst->GetCHString(IDS_DeviceID, sPortName);

		StringCchPrintf(szTemp, MAX_PATH, L"\\\\.\\%s", (LPCWSTR) sPortName);
		hCOMHandle = CreateFile(szTemp, 0, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	}

	if (hCOMHandle == INVALID_HANDLE_VALUE)
	{
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
		{
			// Try using wdm's interface to the kernel
			if (WBEM_S_NO_ERROR == hLoadWmiSerialData(pInst, bBits))
			{
				// status
				if (IsBitSet(bBits, e_StatusInfo))
				{
					Status = 3; // Running/Full Power
					pInst->SetWBEMINT16(IDS_StatusInfo, Status);
				}
			}
		}

		// com port is valid, but we can't get to it.
		return hResult;
	}

	COMProp.wPacketLength = sizeof(COMMPROP);
	if (GetCommProperties(hCOMHandle, &COMProp))
	{
		// MaximumOutputBufferSize
		if (IsBitSet(bBits, e_MaximumOutputBufferSize))
		{
			pInst->SetDWORD(IDS_MaximumOutputBufferSize, COMProp.dwMaxTxQueue);
		}

		// MaximumInputBufferSize
		if (IsBitSet(bBits, e_MaximumInputBufferSize))
		{
			pInst->SetDWORD(IDS_MaximumInputBufferSize, COMProp.dwMaxTxQueue);
		}

		// SerialController::MaximumBaudRate
		if (IsBitSet(bBits, e_MaxBaudRate))
		{
			DWORD dwMaxBaudRate = 0L;

			switch(COMProp.dwMaxBaud)
			{
				case BAUD_075:
					dwMaxBaudRate = 75;
					break;

				case BAUD_110:
					dwMaxBaudRate = 110;
					break;

				case BAUD_134_5:
					dwMaxBaudRate = 1345;
					break;

				case BAUD_150:
					dwMaxBaudRate = 150;
					break;

				case BAUD_300:
					dwMaxBaudRate = 300;
					break;

				case BAUD_600:
					dwMaxBaudRate = 600;
					break;

				case BAUD_1200:
					dwMaxBaudRate = 1200;
					break;

				case BAUD_1800:
					dwMaxBaudRate = 1800;
					break;

				case BAUD_2400:
					dwMaxBaudRate = 2400;
					break;

				case BAUD_4800:
					dwMaxBaudRate = 4800;
					break;

				case BAUD_7200:
					dwMaxBaudRate = 7200;
					break;

				case BAUD_9600:
					dwMaxBaudRate = 9600;
					break;

				case BAUD_14400:
					dwMaxBaudRate = 14400;
					break;

				case BAUD_19200:
					dwMaxBaudRate = 19200;
					break;

				case BAUD_38400:
					dwMaxBaudRate = 38400;
					break;

				case BAUD_56K:
					dwMaxBaudRate = 56000;
					break;

				case BAUD_57600:
					dwMaxBaudRate = 57600;
					break;

				case BAUD_115200:
					dwMaxBaudRate = 115200;
					break;

				case BAUD_128K:
					dwMaxBaudRate = 128000;
					break;

				case BAUD_USER:
				{
					DWORD dwMaskBaudRate = COMProp.dwSettableBaud;

					if ( dwMaskBaudRate & BAUD_128K )
					{
						dwMaxBaudRate = 128000;
					}
					else
					if ( dwMaskBaudRate & BAUD_115200 )
					{
						dwMaxBaudRate = 115200;
					}
					else
					if ( dwMaskBaudRate & BAUD_57600 )
					{
						dwMaxBaudRate = 57600;
					}
					else
					if ( dwMaskBaudRate & BAUD_56K )
					{
						dwMaxBaudRate = 56000;
					}
					else
					if ( dwMaskBaudRate & BAUD_38400 )
					{
						dwMaxBaudRate = 38400;
					}
					else
					if ( dwMaskBaudRate & BAUD_19200 )
					{
						dwMaxBaudRate = 19200;
					}
					else
					if ( dwMaskBaudRate & BAUD_14400 )
					{
						dwMaxBaudRate = 14400;
					}
					else
					if ( dwMaskBaudRate & BAUD_9600 )
					{
						dwMaxBaudRate = 9600;
					}
					else
					if ( dwMaskBaudRate & BAUD_7200 )
					{
						dwMaxBaudRate = 7200;
					}
					else
					if ( dwMaskBaudRate & BAUD_4800 )
					{
						dwMaxBaudRate = 4800;
					}
					else
					if ( dwMaskBaudRate & BAUD_2400 )
					{
						dwMaxBaudRate = 2400;
					}
					else
					if ( dwMaskBaudRate & BAUD_134_5 )
					{
						dwMaxBaudRate = 1345;
					}
					else
					if ( dwMaskBaudRate & BAUD_1200 )
					{
						dwMaxBaudRate = 1200;
					}
					else
					if ( dwMaskBaudRate & BAUD_600 )
					{
						dwMaxBaudRate = 600;
					}
					else
					if ( dwMaskBaudRate & BAUD_300 )
					{
						dwMaxBaudRate = 300;
					}
					else
					if ( dwMaskBaudRate & BAUD_150 )
					{
						dwMaxBaudRate = 150;
					}
					else
					if ( dwMaskBaudRate & BAUD_110 )
					{
						dwMaxBaudRate = 110;
					}
					else
					if ( dwMaskBaudRate & BAUD_075 )
					{
						dwMaxBaudRate = 75;
					}
					else
					{
#ifdef NTONLY
						dwMaxBaudRate = GetPortPropertiesFromRegistry (	szDeviceName );
#else
						dwMaxBaudRate = 0L;
#endif
					}

					break;
				}

				default:
#ifdef NTONLY
					dwMaxBaudRate = GetPortPropertiesFromRegistry (	szDeviceName );
#else
					dwMaxBaudRate = 0L;
#endif
					break;
			}

			if (dwMaxBaudRate != 0)
				pInst->SetDWORD(IDS_MaximumBaudRate, dwMaxBaudRate);
		}

		// ProviderType
		if (IsBitSet(bBits, e_ProviderType))
		{
			CHString chsProviderType;
			switch(COMProp.dwProvSubType)
			{
				case PST_FAX:
					chsProviderType = L"FAX Device";
					break;

				case PST_LAT:
					chsProviderType = L"LAT Protocol";
					break;

				case PST_MODEM:
					chsProviderType = L"Modem Device";
					break;

				case PST_NETWORK_BRIDGE:
					chsProviderType = L"Network Bridge";
					break;

				case PST_PARALLELPORT:
					chsProviderType = L"Parallel Port";
					break;

				case PST_RS232:
					chsProviderType = L"RS232 Serial Port";
					break;

				case PST_RS422:
					chsProviderType = L"RS422 Port";
					break;

				case PST_RS423:
					chsProviderType = L"RS423 Port";
					break;

				case PST_RS449:
					chsProviderType = L"RS449 Port";
					break;

				case PST_SCANNER:
					chsProviderType = L"Scanner Device";
					break;

				case PST_TCPIP_TELNET:
					chsProviderType = L"TCP/IP TelNet";
					break;

				case PST_X25:
					chsProviderType = L"X.25";
					break;

				default:
					chsProviderType = L"Unspecified";
					break;
			}

			pInst->SetCHString(IDS_ProviderType, chsProviderType);
		}

		// Supports16BitMode
		if (IsBitSet(bBits, e_Supports16BitMode))
		{
			pInst->Setbool(IDS_Supports16BitMode,
								COMProp.dwProvCapabilities & PCF_16BITMODE ? TRUE : FALSE);
		}

		// SupportsDTRDSR
		if (IsBitSet(bBits, e_SupportsDTRDSR))
		{
			pInst->Setbool(IDS_SupportsDTRDSR,
								COMProp.dwProvCapabilities & PCF_DTRDSR ? TRUE : FALSE);
		}

		// SupportsIntervalTimeouts
		if (IsBitSet(bBits, e_SupportsIntTimeouts))
		{
			pInst->Setbool(IDS_SupportsIntervalTimeouts,
								COMProp.dwProvCapabilities & PCF_INTTIMEOUTS ? TRUE : FALSE);
		}

		// SupportsParityCheck
		if (IsBitSet(bBits, e_SupportsParityCheck))
		{
			pInst->Setbool(IDS_SupportsParityCheck,
								COMProp.dwProvCapabilities & PCF_PARITY_CHECK ? TRUE : FALSE);
		}

		// SupportsRLSD
		if (IsBitSet(bBits, e_SupportsRLSD))
		{
			pInst->Setbool(IDS_SupportsRLSD,
								COMProp.dwProvCapabilities & PCF_RLSD ? TRUE : FALSE);
		}

		// SupportsRTSCTS
		if (IsBitSet(bBits, e_SupportsRTSCTS))
		{
			pInst->Setbool(IDS_SupportsRTSCTS,
								COMProp.dwProvCapabilities & PCF_RTSCTS ? TRUE : FALSE);
		}

		// SupportsSettableXOnXOff
		if (IsBitSet(bBits, e_SupportsXOnXOffSet))
		{
			pInst->Setbool(IDS_SupportsSettableXOnXOff,
								COMProp.dwProvCapabilities & PCF_SETXCHAR ? TRUE : FALSE);
		}

		// SupportsSpecialChars
		if (IsBitSet(bBits, e_SupportsSpecialCharacters))
		{
			pInst->Setbool(IDS_SupportsSpecialChars,
								COMProp.dwProvCapabilities & PCF_SPECIALCHARS ? TRUE : FALSE);
		}

		// SupportsTotalTimeouts
		if (IsBitSet(bBits, e_SupportsElapsedTimeouts))
		{
			// Elapsed timeout support.....not total timeouts.
			pInst->Setbool(IDS_SupportsElapsedTimeouts,
								COMProp.dwProvCapabilities & PCF_TOTALTIMEOUTS ? TRUE : FALSE);
		}

		// SupportsXOnXOff
		if (IsBitSet(bBits, e_SupportsXOnXOff))
		{
			pInst->Setbool(IDS_SupportsXOnXOff,
								COMProp.dwProvCapabilities & PCF_XONXOFF ? TRUE : FALSE);
		}

		// SettableBaudRate
		if (IsBitSet(bBits, e_SettableBaudRate))
		{
			pInst->Setbool(IDS_SettableBaudRate,
								COMProp.dwSettableParams & SP_BAUD ? TRUE : FALSE);
		}

		// SettableDataBits
		if (IsBitSet(bBits, e_SettableDataBits))
		{
			pInst->Setbool(IDS_SettableDataBits,
								COMProp.dwSettableParams & SP_DATABITS ? TRUE : FALSE);
		}

		// SettableFlowControl
		if (IsBitSet(bBits, e_SettableFlowControl))
		{
			pInst->Setbool(IDS_SettableFlowControl,
								COMProp.dwSettableParams & SP_HANDSHAKING ? TRUE : FALSE);
		}

		// SettableParity
		if (IsBitSet(bBits, e_SettableParity))
		{
			pInst->Setbool(IDS_SettableParity,
								COMProp.dwSettableParams & SP_PARITY ? TRUE : FALSE);
		}

		// SettableParityCheck
		if (IsBitSet(bBits, e_SettableParityCheck))
		{
			pInst->Setbool(IDS_SettableParityCheck,
								COMProp.dwSettableParams & SP_PARITY_CHECK	? TRUE : FALSE);
		}

		// SettableRLSD
		if (IsBitSet(bBits, e_SettableRLSD))
		{
			pInst->Setbool(IDS_SettableRLSD,
								COMProp.dwSettableParams & SP_RLSD ? TRUE : FALSE);
		}

		// SettableStopBits
		if (IsBitSet(bBits, e_SettableStopBits))
		{
			pInst->Setbool(IDS_SettableStopBits,
								COMProp.dwSettableParams & SP_STOPBITS ? TRUE : FALSE);
		}

		// Binary
		if (IsBitSet(bBits, e_Binary))
		{
			DCB dcb;
			if (GetCommState(hCOMHandle, &dcb))
			{
				BOOL fBinary = FALSE;

				fBinary =(BOOL) dcb.fBinary;
				pInst->Setbool(IDS_Binary, fBinary);
			}
		}

		Status = 3; // Running/Full Power
	}

	// Status --
	if (IsBitSet(bBits, e_StatusInfo))
	{
		pInst->SetWBEMINT16(IDS_StatusInfo, Status);
	}


	return hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SerialPort::Load_Win32_SerialPort
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance *pInst - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    : This sets  fields in the Load_Win32_SerialPort class
 *
 *****************************************************************************/

#define Serial_ComInfo_Guid _T("{EDB16A62-B16C-11D1-BD98-00A0C906BE2D}")
#define Serial_Name_Guid	_T("{A0EC11A8-B16C-11D1-BD98-00A0C906BE2D}")

HRESULT CWin32SerialPort::hLoadWmiSerialData(CInstance *pInst, BYTE bBits[])
{
	HRESULT			hRes = WBEM_E_NOT_FOUND;
	CWdmInterface	wdm;
	CNodeAll		oSerialNames(Serial_Name_Guid);

	hRes = wdm.hLoadBlock(oSerialNames);
	if (S_OK == hRes)
	{
		CHString chsName;
		pInst->GetCHString(IDS_DeviceID, chsName);


		CHString chsSerialPortName;
		bool bValid = oSerialNames.FirstInstance();

		while (bValid)
		{
			// Extract the friendly name
			oSerialNames.GetString(chsSerialPortName);

			// friendly name is a match
			if (!chsSerialPortName.CompareNoCase(chsName))
			{
				// instance name
				CHString chsNameInstanceName;
				oSerialNames.GetInstanceName(chsNameInstanceName);

				// key on the instance name
				return GetWMISerialInfo(pInst, wdm, chsName, chsNameInstanceName, bBits);

			}
			bValid = oSerialNames.NextInstance();
		}
	}
	return hRes;
}

//
HRESULT CWin32SerialPort::GetWMISerialInfo(CInstance *pInst,
										   CWdmInterface& rWdm,
										   LPCWSTR szName,
										   LPCWSTR szNameInstanceName,
                                           BYTE bBits[])
{
	HRESULT		hRes = WBEM_E_NOT_FOUND;
	CNodeAll	oSerialData(Serial_ComInfo_Guid);

	hRes = rWdm.hLoadBlock(oSerialData);
	if (S_OK == hRes)
	{
		CHString chsDataInstanceName;
		bool bValid = oSerialData.FirstInstance();

		while (bValid)
		{
			oSerialData.GetInstanceName(chsDataInstanceName);

			// friendly name is a match
			if (!chsDataInstanceName.CompareNoCase(szNameInstanceName))
			{
				// collect this MSSerial_CommInfo instance
				MSSerial_CommInfo ci;

				/*	We are currently without a class contract. The class within
					the wmi mof is not expected to changed however we have to
					explicitly indicate how the data is layed out. Having the class
					definition would allow us to examine the property qualifiers
					to get us the order(WmiDataId) and property types.

					Secondly, because the data is aligned on natural boundaries
					a direct offset to a specific piece of data is conditioned on
					what has preceeded it. Thus, a string followed by a DWORD may
					be 0 to 2 bytes away from each other.

					Serially extracting each property in order will take into
					account the alignment problem.
				*/
				oSerialData.GetDWORD(ci.BaudRate);
				oSerialData.GetDWORD(ci.BitsPerByte);
				oSerialData.GetDWORD(ci.Parity);
				oSerialData.GetBool( ci.ParityCheckEnable);
				oSerialData.GetDWORD(ci.StopBits);
				oSerialData.GetDWORD(ci.XoffCharacter);
				oSerialData.GetDWORD(ci.XoffXmitThreshold);
				oSerialData.GetDWORD(ci.XonCharacter);
				oSerialData.GetDWORD(ci.XonXmitThreshold);
				oSerialData.GetDWORD(ci.MaximumBaudRate);
				oSerialData.GetDWORD(ci.MaximumOutputBufferSize);
				oSerialData.GetDWORD(ci.MaximumInputBufferSize);
				oSerialData.GetBool( ci.Support16BitMode);
				oSerialData.GetBool( ci.SupportDTRDSR);
				oSerialData.GetBool( ci.SupportIntervalTimeouts);
				oSerialData.GetBool( ci.SupportParityCheck);
				oSerialData.GetBool( ci.SupportRTSCTS);
				oSerialData.GetBool( ci.SupportXonXoff);
				oSerialData.GetBool( ci.SettableBaudRate);
				oSerialData.GetBool( ci.SettableDataBits);
				oSerialData.GetBool( ci.SettableFlowControl);
				oSerialData.GetBool( ci.SettableParity);
				oSerialData.GetBool( ci.SettableParityCheck);
				oSerialData.GetBool( ci.SettableStopBits);
				oSerialData.GetBool( ci.IsBusy);

				// populate the instance

				// MaximumOutputBufferSize
				if (IsBitSet(bBits, e_MaximumOutputBufferSize))
				{
					pInst->SetDWORD(IDS_MaximumOutputBufferSize, ci.MaximumOutputBufferSize);
				}

				// MaximumInputBufferSize
				if (IsBitSet(bBits, e_MaximumInputBufferSize))
				{
					pInst->SetDWORD(IDS_MaximumInputBufferSize, ci.MaximumInputBufferSize);
				}

				// SerialController::MaximumBaudRate
				if (IsBitSet(bBits, e_MaxBaudRate))
				{
					pInst->SetDWORD(IDS_MaximumBaudRate, ci.MaximumBaudRate);
				}

				// Supports16BitMode
				if (IsBitSet(bBits, e_Supports16BitMode))
				{
					pInst->Setbool(IDS_Supports16BitMode, ci.Support16BitMode ? TRUE : FALSE);
				}

				// SupportsDTRDSR
				if (IsBitSet(bBits, e_SupportsDTRDSR))
				{
					pInst->Setbool(IDS_SupportsDTRDSR,	ci.SupportDTRDSR ? TRUE : FALSE);
				}

				// SupportsIntervalTimeouts
				if (IsBitSet(bBits, e_SupportsIntTimeouts))
				{
					pInst->Setbool(IDS_SupportsIntervalTimeouts, ci.SupportIntervalTimeouts	? TRUE : FALSE);
				}

				// SupportsParityCheck
				if (IsBitSet(bBits, e_SupportsParityCheck))
				{
					pInst->Setbool(IDS_SupportsParityCheck, ci.SupportParityCheck ? TRUE : FALSE);
				}

				// SupportsRTSCTS
				if (IsBitSet(bBits, e_SupportsRTSCTS))
				{
					pInst->Setbool(IDS_SupportsRTSCTS,	ci.SupportRTSCTS ? TRUE : FALSE);
				}

				// SupportsXOnXOff
				if (IsBitSet(bBits, e_SupportsXOnXOff))
				{
					pInst->Setbool(IDS_SupportsXOnXOff, ci.SupportXonXoff ? TRUE : FALSE);
				}

				// SettableBaudRate
				if (IsBitSet(bBits, e_SettableBaudRate))
				{
					pInst->Setbool(IDS_SettableBaudRate, ci.SettableBaudRate ? TRUE : FALSE);
				}

				// SettableDataBits
				if (IsBitSet(bBits, e_SettableDataBits))
				{
					pInst->Setbool(IDS_SettableDataBits, ci.SettableDataBits ? TRUE : FALSE);
				}

				// SettableFlowControl
				if (IsBitSet(bBits, e_SettableFlowControl))
				{
					pInst->Setbool(IDS_SettableFlowControl, ci.SettableFlowControl	? TRUE : FALSE);
				}

				// SettableParity
				if (IsBitSet(bBits, e_SettableParity))
				{
					pInst->Setbool(IDS_SettableParity,	ci.SettableParityCheck	? TRUE : FALSE);
				}

				// SettableParityCheck
				if (IsBitSet(bBits, e_SettableParityCheck))
				{
					pInst->Setbool(IDS_SettableParityCheck, ci.SettableParityCheck	? TRUE : FALSE);
				}

				// SettableStopBits
				if (IsBitSet(bBits, e_SettableStopBits))
				{
					pInst->Setbool(IDS_SettableStopBits, ci.SettableStopBits ? TRUE : FALSE);
				}

				return WBEM_S_NO_ERROR;
			}
			bValid = oSerialData.NextInstance();
		}
	}
	return hRes;
}

// Strip off the service name from the registry value name.
// The service name will be in the form of service# (e.g. RocketPort5) or
// \Device\Service# (e.g. \Device\Serial0).

void WINAPI CWin32SerialPort::RegNameToServiceName(
    LPCWSTR szName,
    CHString &strService)
{
    LPWSTR szSlash = wcsrchr(szName, '\\');

    if (szSlash)
        strService = szSlash + 1;
    else
        strService = szName;

    int iWhere = strService.GetLength();

    while (iWhere && iswdigit(strService[iWhere - 1]))
    {
        iWhere--;
    }

    strService = strService.Left(iWhere);
}

#ifdef	NTONLY
DWORD CWin32SerialPort::GetPortPropertiesFromRegistry (	LPCWSTR szDeviceName )
{
	DWORD dwResult = 0L;

	// get registry value
	CRegistry reg;
	if ( ( reg.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Ports", KEY_READ ) ) == ERROR_SUCCESS )
	{
		// get value for serial port
		CHString Key ( szDeviceName );
		Key += L':';

		CHString Value;
		if ( ( reg.GetCurrentKeyValue ( Key, Value ) ) == ERROR_SUCCESS )
		{
			DWORD dwCount = 0L;
			if ( ! Value.IsEmpty () && ( dwCount = Value.Find ( L',' ) ) != 0L )
			{
				CHString BaudRate ( Value.Mid ( 0, dwCount ) );

				// get final baud rate from registry as devicer manager does
				dwResult = static_cast < DWORD > ( _wtoi ( static_cast < LPCWSTR > ( BaudRate ) ) ); 
			}
		}
	}

	return dwResult;
}
#endif	//NTONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\serialportcfg.h ===
//=================================================================

//

// SerialPortCfg.h -- Serial port configuration set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/24/97    jennymc        Moved to new framework
//
//=================================================================

#define PROPSET_NAME_SERIALCONFIG L"Win32_SerialPortConfiguration"

class CWin32SerialPortConfiguration : public Provider{

    public:

        // Constructor/destructor
        //=======================

        CWin32SerialPortConfiguration(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32SerialPortConfiguration() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);


        // Utility
        //========
    private:
        // Utility function(s)
        //====================
        HRESULT LoadPropertyValues(CInstance *pInstance,CHString &sPortName, bool bIsMouse) ;
		BOOL TryToFindNTCommPort(DWORD dwPort, CHString& strSerialPort, bool& bIsMouse); 
        BOOL TryToFindNTCommPortFriendlyName();
        static LONG CountCommas(LPCWSTR szText);
        static BOOL GetDCBPropsViaIni(LPCTSTR szPort, DCB &dcb);

		HRESULT hLoadWmiSerialData( CInstance* pInstance );
		HRESULT GetWMISerialInfo(	CInstance* pInstance,
									CWdmInterface& rWdm, 
									CHString& chsName, 
									CHString& chsNameInstanceName );
} ;

// WMI 
typedef struct _MSSerial_CommInfo
{
	DWORD	BaudRate;
	DWORD	BitsPerByte;
	DWORD	Parity;
	BYTE	ParityCheckEnable;
	DWORD	StopBits;
	DWORD	XoffCharacter;
	DWORD	XoffXmitThreshold;
	DWORD	XonCharacter;
	DWORD	XonXmitThreshold;
	DWORD	MaximumBaudRate;
	DWORD	MaximumOutputBufferSize;
	DWORD	MaximumInputBufferSize;
	BYTE	Support16BitMode;		
	BYTE	SupportDTRDSR;
	BYTE	SupportIntervalTimeouts;
	BYTE	SupportParityCheck;
	BYTE	SupportRTSCTS;
	BYTE	SupportXonXoff;
	BYTE	SettableBaudRate;
	BYTE	SettableDataBits;
	BYTE	SettableFlowControl;
	BYTE	SettableParity;
	BYTE	SettableParityCheck;
	BYTE	SettableStopBits;
	BYTE	IsBusy;
} MSSerial_CommInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\serialport.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  serialport.h
//
//  Purpose: serialport property set provider
//
//***************************************************************************

#ifndef _SERIALPORT_H
#define _SERIALPORT_H

// Property set identification
//============================
#define PROPSET_NAME_SERPORT	    L"Win32_SerialPort"
#define CONFIG_MANAGER_CLASS_PORTS  L"Ports"


#define	REQ_ALL_REQUIRED		0xFFFFFFFF
#define REQ_NONE_REQUIRED		x0x00000000

#if NTONLY >= 5
#else
	typedef std::map<CHString, DWORD> STRING2DWORD;
#endif
	
class CWin32SerialPort : public Provider
{
	private:	
	
	#if NTONLY >= 5
		CHPtrArray m_ptrProperties;
	#endif

	protected:

	#if NTONLY >= 5
        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
            CInstance *a_pinstGetObj,
			long a_Flags , 
			BYTE a_bBits[]
		) ;

		HRESULT LoadPropertyValues ( 

			CInstance *a_Instance, 
			CConfigMgrDevice *a_Device , 
			LPCWSTR szDeviceName , 
			BYTE a_bBits[] 
		) ;

        static void WINAPI RegNameToServiceName(
            LPCWSTR szName, 
            CHString &strService);

	#endif
	
	private:

		HRESULT hLoadWmiSerialData( CInstance* pInstance, BYTE a_bBits[] );

		HRESULT GetWMISerialInfo(	CInstance* pInstance,
									CWdmInterface& rWdm,
									LPCWSTR szName, 
									LPCWSTR szNameInstanceName, BYTE a_bBits[] );

	#ifdef NTONLY
		DWORD GetPortPropertiesFromRegistry ( LPCWSTR szDeviceName );
	#endif

    #if NTONLY == 4
        HRESULT CWin32SerialPort::EnumerateInstancesNT(
            MethodContext *a_pMethodContext, 
            long a_lFlags);
    #endif

	public:

        // Constructor/destructor
        //=======================

        CWin32SerialPort ( LPCWSTR a_pszName, LPCWSTR a_pszNamespace ) ;
       ~CWin32SerialPort () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( 

			CInstance *a_Instance, 
			long a_Flags,
            CFrameworkQuery &a_Query
		) ;

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

	#if NTONLY >= 5
        HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;
	#endif

	enum ePropertyIDs { 
		e_Binary,					// Win32_SerialPort
		e_MaximumInputBufferSize,
		e_MaximumOutputBufferSize,
		e_ProviderType,
		e_SettableBaudRate,
		e_SettableDataBits,
		e_SettableFlowControl,
		e_SettableParity,
		e_SettableParityCheck,
		e_SettableRLSD,
		e_SettableStopBits,
		e_Supports16BitMode,
		e_SupportsDTRDSR,
		e_SupportsElapsedTimeouts,
		e_SupportsIntTimeouts,
		e_SupportsParityCheck,
		e_SupportsRLSD,
		e_SupportsRTSCTS,
		e_SupportsSpecialCharacters,
		e_SupportsXOnXOff,
		e_SupportsXOnXOffSet,
		e_OSAutoDiscovered,
		e_MaxBaudRate,					// CIM_SerialController
		e_MaxNumberControlled,			// CIM_Controller
		e_ProtocolSupported,
		e_TimeOfLastReset,
		e_Availability,					// CIM_LogicalDevice
		e_CreationClassName,
		e_ConfigManagerErrorCode,
		e_ConfigManagerUserConfig,
		e_DeviceID,
		e_PNPDeviceID,
		e_PowerManagementCapabilities,
		e_PowerManagementSupported,
		e_StatusInfo,
		e_SystemCreationClassName,
		e_SystemName,
		e_Caption,						// CIM_ManagedSystemElement
		e_Description,
		e_InstallDate,
		e_Name,
		e_Status,
		e_End_Property_Marker			// end marker
	};	

} ;

// WDM 
typedef struct _MSSerial_CommInfo
{
	DWORD	BaudRate;
	DWORD	BitsPerByte;
	DWORD	Parity;
	BYTE	ParityCheckEnable;
	DWORD	StopBits;
	DWORD	XoffCharacter;
	DWORD	XoffXmitThreshold;
	DWORD	XonCharacter;
	DWORD	XonXmitThreshold;
	DWORD	MaximumBaudRate;
	DWORD	MaximumOutputBufferSize;
	DWORD	MaximumInputBufferSize;
	BYTE	Support16BitMode;		
	BYTE	SupportDTRDSR;
	BYTE	SupportIntervalTimeouts;
	BYTE	SupportParityCheck;
	BYTE	SupportRTSCTS;
	BYTE	SupportXonXoff;
	BYTE	SettableBaudRate;
	BYTE	SettableDataBits;
	BYTE	SettableFlowControl;
	BYTE	SettableParity;
	BYTE	SettableParityCheck;
	BYTE	SettableStopBits;
	BYTE	IsBusy;
} MSSerial_CommInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\service.h ===
//=================================================================

//

// Service.h -- Service property set provider (Windows NT only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_SERVICE			L"Win32_Service"

#define PROPERTY_VALUE_STATE_RUNNING			L"Running"
#define PROPERTY_VALUE_STATE_PAUSED				L"Paused"
#define PROPERTY_VALUE_STATE_STOPPED			L"Stopped"

// Get/set function protos
//========================

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

class CWin32Service:public Win32_BaseService 
{
public:

        // Constructor/destructor
        //=======================

	CWin32Service (

		LPCWSTR name, 
		LPCWSTR pszNamespace
	) ;

	~CWin32Service() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags,
        CFrameworkQuery& pQuery
	);

	HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

	HRESULT ExecQuery (

		MethodContext *pMethodContext, 
		CFrameworkQuery& pQuery, 
		long lFlags /*= 0L*/ 
	);

	HRESULT	PutInstance ( 

		const CInstance &a_Instance, 
		long lFlags /*= 0L*/ 
	) ;

private:

    CHPtrArray m_ptrProperties;

        // Utility function(s)
        //====================

	HRESULT RefreshInstanceNT (

		CInstance *pInstance,
        DWORD dwProperties
	) ;

	HRESULT RefreshInstanceWin95 (

		CInstance *pInstance
	) ;

	HRESULT AddDynamicInstancesNT (

		MethodContext *pMethodContext, 
		DWORD dwProperties
	) ;

	HRESULT AddDynamicInstancesWin95 (

		MethodContext *pMethodContext
	) ;

	HRESULT LoadPropertyValuesWin2K (

		SC_HANDLE hDBHandle, 
		SERVICE_STATUS_PROCESS &a_ServiceStatus ,
		LPCTSTR szServiceName, 
		CInstance *pInstance, 
		DWORD dwProperties,
		CAdvApi32Api *a_pAdvApi32
	) ;

	HRESULT LoadPropertyValuesNT (

		SC_HANDLE hDBHandle, 
		LPCTSTR szServiceName, 
		CInstance *pInstance, 
		DWORD dwProperties,
		CAdvApi32Api *a_pAdvApi32
	) ;

	void LoadPropertyValuesWin95 (

		LPCTSTR szServiceName, 
		CInstance *pInstance
	);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\serverdefs0.h ===
//=================================================================

//

// ServerDefs0.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __WMI_P_SERVER_DEFS_ALREADY_INCLUDED
#define __WMI_P_SERVER_DEFS_ALREADY_INCLUDED
// header file needed because these definitions are scattered around 93 different header
// files, none of which are compatible with other header files...


#ifndef CNLEN
#define CNLEN 15
#endif

// This structure comes from svrapi.h, which can't be included since it conflicts with the 
// nt header.  Grrr.
#pragma pack(1)
struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\service.cpp ===
//=================================================================

//

// Service.CPP --Service property set provider (Windows NT only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"
#include <winsvc.h>

#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include <frqueryex.h>

#include "bservice.h"
#include "Service.h"
#include "computersystem.h"

#define BIT_ALL_PROPERTIES          0xffffffff
#define BIT_Name                    0x00000001
#define BIT_State                   0x00000002
#define BIT_Started                 0x00000004
#define BIT_AcceptStop              0x00000008
#define BIT_AcceptPause             0x00000010
#define BIT_ProcessId               0x00000020
#define BIT_ExitCode                0x00000040
#define BIT_ServiceSpecificExitCode 0x00000080
#define BIT_CheckPoint              0x00000100
#define BIT_WaitHint                0x00000200
#define BIT_Status                  0x00000400
#define BIT_Caption                 0x00000800
#define BIT_DisplayName             0x00001000
#define BIT_Description             0x00002000
#define BIT_TagId                   0x00004000
#define BIT_ServiceType             0x00008000
#define BIT_DesktopInteract         0x00010000
#define BIT_StartMode               0x00020000
#define BIT_ErrorControl            0x00040000
#define BIT_PathName                0x00080000
#define BIT_StartName               0x00100000
#define BIT_CreationClassName       0x00200000
#define BIT_SystemCreationClassName 0x00400000
#define BIT_SystemName              0x00800000


// Property set declaration
//=========================

CWin32Service MyServiceSet ( PROPSET_NAME_SERVICE , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::CWin32Service
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Service::CWin32Service (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Win32_BaseService ( name , pszNamespace )
{
    m_ptrProperties.SetSize(24);

    m_ptrProperties[0] = ((LPVOID) IDS_Name);
    m_ptrProperties[1] = ((LPVOID) IDS_State);
    m_ptrProperties[2] = ((LPVOID) IDS_Started);
    m_ptrProperties[3] = ((LPVOID) IDS_AcceptStop);
    m_ptrProperties[4] = ((LPVOID) IDS_AcceptPause);
    m_ptrProperties[5] = ((LPVOID) IDS_ProcessId);
    m_ptrProperties[6] = ((LPVOID) IDS_ExitCode);
    m_ptrProperties[7] = ((LPVOID) IDS_ServiceSpecificExitCode);
    m_ptrProperties[8] = ((LPVOID) IDS_CheckPoint);
    m_ptrProperties[9] = ((LPVOID) IDS_WaitHint);
    m_ptrProperties[10] = ((LPVOID) IDS_Status);
    m_ptrProperties[11] = ((LPVOID) IDS_Caption);
    m_ptrProperties[12] = ((LPVOID) IDS_DisplayName);
    m_ptrProperties[13] = ((LPVOID) IDS_Description);
    m_ptrProperties[14] = ((LPVOID) IDS_TagId);
    m_ptrProperties[15] = ((LPVOID) IDS_ServiceType);
    m_ptrProperties[16] = ((LPVOID) IDS_DesktopInteract);
    m_ptrProperties[17] = ((LPVOID) IDS_StartMode);
    m_ptrProperties[18] = ((LPVOID) IDS_ErrorControl);
    m_ptrProperties[19] = ((LPVOID) IDS_PathName);
    m_ptrProperties[20] = ((LPVOID) IDS_StartName);
    m_ptrProperties[21] = ((LPVOID) IDS_CreationClassName);
    m_ptrProperties[22] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[23] = ((LPVOID) IDS_SystemName);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::~CWin32Service
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

CWin32Service :: ~CWin32Service ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Service :: ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery& pQuery,
	long lFlags /*= 0L*/
)
{
    HRESULT hRes ;

#ifdef NTONLY

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties = BIT_ALL_PROPERTIES;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    hRes = AddDynamicInstancesNT ( pMethodContext , dwProperties ) ;

#endif

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Service :: GetObject (

	CInstance *pInstance,
	long lFlags,
    CFrameworkQuery& pQuery
)
{

#ifdef NTONLY

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

	HRESULT hRes = RefreshInstanceNT(pInstance, dwProperties) ;
	if ( hRes == WBEM_E_ACCESS_DENIED )
	{
		hRes = WBEM_S_NO_ERROR ;
	}

#endif

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each service
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Service :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hRes;

#ifdef NTONLY

	hRes = AddDynamicInstancesNT ( pMethodContext , BIT_ALL_PROPERTIES ) ;

#endif

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::RefreshInstanceNT
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32Service :: RefreshInstanceNT (

	CInstance *pInstance,
    DWORD dwProperties

)
{
	HRESULT hRes = WBEM_E_FAILED;

   // Check to see if this is us...

	CHString sName;
	if( !pInstance->GetCHString( IDS_Name, sName ) || sName.IsEmpty() )
	{
		return WBEM_E_NOT_FOUND ;
	}

	// Get an scman handle

	SmartCloseServiceHandle hDBHandle = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
	if(hDBHandle != NULL)
	{
	  // Create copy of name & pass to LoadPropertyValues
	  //=================================================

		CAdvApi32Api *t_pAdvApi32 = NULL;

		if ( IsWinNT5 () )
		{
			t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource ( g_guidAdvApi32Api , NULL ) ;
		}

		try
		{
			hRes = LoadPropertyValuesNT (

				hDBHandle,
				(LPCTSTR)sName,
				pInstance,
				dwProperties,
				t_pAdvApi32
			);
		}
		catch ( ... )
		{
			if ( t_pAdvApi32 != NULL )
			{
				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidAdvApi32Api , t_pAdvApi32 ) ;
			}

			throw ;
		}

		if ( t_pAdvApi32 != NULL )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidAdvApi32Api , t_pAdvApi32 ) ;
		}
	}

	return hRes;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance of property set for each service
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#if NTONLY >= 5
HRESULT CWin32Service::AddDynamicInstancesNT (

	MethodContext *a_pMethodContext,
	DWORD dwProperties
)
{
    HRESULT t_hResult = WBEM_E_FAILED;

    // Get handle to the services database
    //====================================

	SmartCloseServiceHandle hDBHandle = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
    if ( hDBHandle )
	{
		// Make call once to get buffer size (should return
		// FALSE but fill in buffer size)
		//=================================================

		DWORD i, hEnumHandle = 0, dwByteCount = 0, dwEntryCount ;
		LPENUM_SERVICE_STATUS_PROCESS pServiceList = NULL ;

		BOOL t_EnumStatus = EnumServicesStatusEx (

			hDBHandle,
			SC_ENUM_PROCESS_INFO ,
			SERVICE_WIN32 ,
			SERVICE_ACTIVE | SERVICE_INACTIVE,
			( LPBYTE ) pServiceList,
			dwByteCount,
			&dwByteCount,
			&dwEntryCount,
			&hEnumHandle,
			NULL
		) ;

		if ( t_EnumStatus == FALSE && GetLastError() == ERROR_MORE_DATA)
		{
			// Allocate the required buffer
			//=============================

			pServiceList = reinterpret_cast<LPENUM_SERVICE_STATUS_PROCESS> (new char[dwByteCount]) ;
			if(pServiceList != NULL)
			{
				try
				{
					memset(pServiceList, 0, dwByteCount) ;

					t_EnumStatus = EnumServicesStatusEx(

						hDBHandle,
						SC_ENUM_PROCESS_INFO ,
						SERVICE_WIN32 ,
						SERVICE_ACTIVE | SERVICE_INACTIVE,
						( LPBYTE ) pServiceList,
						dwByteCount,
						&dwByteCount,
						&dwEntryCount,
						&hEnumHandle,
						NULL
					) ;

					if ( t_EnumStatus == TRUE )
					{
						t_hResult = WBEM_S_NO_ERROR;

						// Create instance for each returned service
						//==========================================

						CAdvApi32Api *t_pAdvApi32 = NULL;

						if ( IsWinNT5 () )
						{
							t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
						}

						try
						{
							// smart ptr
							CInstancePtr t_pInst ;

							for ( i = 0 ; i < dwEntryCount; i++ )
							{
								t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

								// Load and save
								t_hResult = LoadPropertyValuesWin2K (

									hDBHandle,
									pServiceList[i].ServiceStatusProcess ,
									pServiceList[i].lpServiceName,
									t_pInst,
									dwProperties ,
									t_pAdvApi32
								);

								if ( t_hResult == WBEM_S_NO_ERROR ||
									 t_hResult == WBEM_E_ACCESS_DENIED ) // can enumerate the service but can't open it
								{
									t_hResult = t_pInst->Commit() ;
								}

								// we reset to WBEM_S_NO_ERROR as the return is used
								// in ExecQuery and EnumerateInstances
								t_hResult = WBEM_S_NO_ERROR ;
							}
						}
						catch ( ... )
						{
							if ( t_pAdvApi32 != NULL )
							{
								CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
							}

							throw ;
						}

						if ( t_pAdvApi32 != NULL )
						{
							CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
						}
					}
				}
				catch ( ... )
				{
					delete [] reinterpret_cast<char *> (pServiceList) ;

					throw ;
				}

				delete [] reinterpret_cast<char *> (pServiceList) ;
			}
		}
	}

    return t_hResult;
}
#else
#ifdef NTONLY
HRESULT CWin32Service::AddDynamicInstancesNT (

	MethodContext *a_pMethodContext,
	DWORD dwProperties
)
{
    HRESULT t_hResult = WBEM_E_FAILED;

    // Get handle to the services database
    //====================================

	SmartCloseServiceHandle hDBHandle = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
    if ( hDBHandle )
	{
		// Make call once to get buffer size (should return
		// FALSE but fill in buffer size)
		//=================================================

		DWORD i, hEnumHandle = 0, dwByteCount = 0, dwEntryCount ;
		LPENUM_SERVICE_STATUS pServiceList = NULL ;

		BOOL t_EnumStatus = EnumServicesStatus (

			hDBHandle,
			SERVICE_WIN32 ,
			SERVICE_ACTIVE | SERVICE_INACTIVE,
			pServiceList,
			dwByteCount,
			&dwByteCount,
			&dwEntryCount,
			&hEnumHandle
		) ;

		if ( t_EnumStatus == FALSE && GetLastError() == ERROR_MORE_DATA)
		{
			// Allocate the required buffer
			//=============================

			pServiceList = reinterpret_cast<LPENUM_SERVICE_STATUS> (new char[dwByteCount]) ;
			if(pServiceList != NULL)
			{
				try
				{
					memset(pServiceList, 0, dwByteCount) ;

					t_EnumStatus = EnumServicesStatus(

						hDBHandle,
						SERVICE_WIN32 ,
						SERVICE_ACTIVE | SERVICE_INACTIVE,
						pServiceList,
						dwByteCount,
						&dwByteCount,
						&dwEntryCount,
						&hEnumHandle
					) ;

					if ( t_EnumStatus == TRUE )
					{
						t_hResult = WBEM_S_NO_ERROR;

						// Create instance for each returned service
						//==========================================

						CAdvApi32Api *t_pAdvApi32 = NULL;

						if ( IsWinNT5 () )
						{
							t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
						}

						try
						{
							// smart ptr
							CInstancePtr t_pInst ;

							for ( i = 0 ; i < dwEntryCount; i++ )
							{
								t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

								// Load and save
								t_hResult = LoadPropertyValuesNT (

									hDBHandle,
									pServiceList[i].lpServiceName,
									t_pInst,
									dwProperties ,
									t_pAdvApi32
								);

								if ( t_hResult == WBEM_S_NO_ERROR ||
									 t_hResult == WBEM_E_ACCESS_DENIED ) // can enumerate the service but can't open it
								{
									t_hResult = t_pInst->Commit() ;
								}

								// we reset to WBEM_S_NO_ERROR as the return is used
								// in ExecQuery and EnumerateInstances
								t_hResult = WBEM_S_NO_ERROR ;
							}
						}
						catch ( ... )
						{
							if ( t_pAdvApi32 != NULL )
							{
								CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
							}

							throw ;
						}

						if ( t_pAdvApi32 != NULL )
						{
							CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
						}
					}
				}
				catch ( ... )
				{
					delete [] reinterpret_cast<char *> (pServiceList) ;

					throw ;
				}

				delete [] reinterpret_cast<char *> (pServiceList) ;
			}
		}
	}

    return t_hResult;

}
#endif
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::LoadPropertyValuesNT
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Service::LoadPropertyValuesWin2K (

	SC_HANDLE hDBHandle,
	SERVICE_STATUS_PROCESS &a_StatusInfo ,
	LPCTSTR szServiceName,
	CInstance *pInstance,
	DWORD dwProperties,
	CAdvApi32Api* a_pAdvApi32
)
{
    HRESULT hRes = WBEM_S_NO_ERROR; // Since we have the name, we can populate the key.

    // Open the service
    //=================

    // Check to see if we HAVE to open the service.  If we are running as a
    // query and they didn't request some of these properties, let's not waste the time.


  // If they want any of these, we'll have to do StatusInfo

	BOOL bStatusInfo = dwProperties &
        (BIT_State | BIT_Started | BIT_AcceptStop | BIT_AcceptPause | BIT_Status |
         BIT_ProcessId | BIT_ExitCode | BIT_ServiceSpecificExitCode | BIT_CheckPoint |
         BIT_WaitHint );

  // If they want any of these, we'll have to do ConfigInfo

	BOOL bConfigInfo = dwProperties &
        (BIT_TagId | BIT_ServiceType | BIT_DesktopInteract | BIT_StartMode |
         BIT_ErrorControl | BIT_PathName | BIT_DisplayName | BIT_Caption |
         BIT_Description | BIT_StartName);

	// If all they wanted was the name, skip all this.
	if ( bStatusInfo || bConfigInfo )
	{
		SmartCloseServiceHandle hSvcHandle = NULL ;
		DWORD t_dwLastError = 0 ;

        if ( ( dwProperties & BIT_Status ) || bConfigInfo )
        {
			hSvcHandle = OpenService (

				hDBHandle,
				szServiceName,
				SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_INTERROGATE
			) ;

			t_dwLastError = GetLastError();

			if ( ( hSvcHandle == NULL ) && ( ERROR_SERVICE_DOES_NOT_EXIST == t_dwLastError || ERROR_INVALID_NAME == t_dwLastError) )
			{
				return WBEM_E_NOT_FOUND ;
			}
		}			

		// If the service could not be opened
		// drop through and collect up the defaults
		// ========================================
		if ( bStatusInfo )
		{
			DWORD t_ProcessId = a_StatusInfo.dwProcessId ;
			DWORD t_CurrentState = a_StatusInfo.dwCurrentState ;
			DWORD t_ControlsAccepted = a_StatusInfo.dwControlsAccepted ;
			DWORD t_Win32ExitCode = a_StatusInfo.dwWin32ExitCode ;
			DWORD t_ServiceSpecific = a_StatusInfo.dwServiceSpecificExitCode ;
			DWORD t_CheckPoint = a_StatusInfo.dwCheckPoint ;
			DWORD t_WaitHint = a_StatusInfo.dwWaitHint ;

			bool bStarted = true;

			switch (t_CurrentState)
			{
				case SERVICE_STOPPED:
				{
					pInstance->SetCharSplat(IDS_State, _T("Stopped"));
					bStarted = false;
				}
				break;

				case SERVICE_START_PENDING:
				{
					pInstance->SetCharSplat(IDS_State, _T("Start Pending"));
					bStarted = true;
				}
				break;

				case SERVICE_STOP_PENDING:
				{
					pInstance->SetCharSplat(IDS_State, _T("Stop Pending"));
					bStarted = true;
				}
				break;

				case SERVICE_RUNNING:
				{
					pInstance->SetCharSplat(IDS_State, _T("Running"));
					bStarted = true;
				}
				break;

				case SERVICE_CONTINUE_PENDING:
				{
					pInstance->SetCharSplat(IDS_State, _T("Continue Pending"));
					bStarted = true;
				}
				break;

				case SERVICE_PAUSE_PENDING:
				{
					pInstance->SetCharSplat(IDS_State, _T("Pause Pending"));
					bStarted = true;
				}
				break;

				case SERVICE_PAUSED:
				{
					pInstance->SetCharSplat(IDS_State, _T("Paused"));
					bStarted = true;
				}
				break;

				default:
				{
					pInstance->SetCharSplat(IDS_State, _T("Unknown") );
					bStarted = true;
				}
				break;
			}

			pInstance->Setbool(IDS_Started, bStarted);
			pInstance->Setbool(IDS_AcceptStop, (t_ControlsAccepted) & SERVICE_ACCEPT_STOP);
			pInstance->Setbool(IDS_AcceptPause, (t_ControlsAccepted) & SERVICE_ACCEPT_PAUSE_CONTINUE);

			pInstance->SetDWORD ( IDS_ProcessId , t_ProcessId ) ;
			pInstance->SetDWORD ( IDS_ExitCode , t_Win32ExitCode ) ;
			pInstance->SetDWORD ( IDS_ServiceSpecificExitCode , t_ServiceSpecific ) ;
			pInstance->SetDWORD ( IDS_CheckPoint , t_CheckPoint ) ;
			pInstance->SetDWORD ( IDS_WaitHint , t_WaitHint ) ;

            if (dwProperties & BIT_Status)
            {
			    if( hSvcHandle )
			    {
				    SERVICE_STATUS StatusInfo ;
				    if ( ( ! bStarted ) || ( ControlService ( hSvcHandle , SERVICE_CONTROL_INTERROGATE , &StatusInfo ) != 0 ) )
				    {
					    pInstance->SetCharSplat(IDS_Status, IDS_OK);
				    }
				    else
				    {
					    pInstance->SetCharSplat(IDS_Status, IDS_Degraded);
				    }
			    }
			    else
			    {
				    pInstance->SetCharSplat(IDS_Status, IDS_Unknown);
			    }
            }
		}

		if (bConfigInfo)
		{
			// Get the rest of the config info
			//================================
			char ConfigBuffer[1024] ;
			LPQUERY_SERVICE_CONFIG pConfigInfo = ( LPQUERY_SERVICE_CONFIG ) ConfigBuffer ;

			// These may get overwritten below if we can find something better

			pInstance->SetCharSplat(IDS_Caption, szServiceName );
			pInstance->SetCharSplat(IDS_DisplayName, szServiceName );
			

			// We need to make another call for getting the Description of the Service
			if ( NULL != (SC_HANDLE)hSvcHandle )
			{
				DWORD dwBufSize = 0;
				DWORD dwBytesNeeded = 0;
				SERVICE_DESCRIPTION *pBuffer = NULL;
				BOOL bSuccess = QueryServiceConfig2(
									(SC_HANDLE) hSvcHandle, 
									SERVICE_CONFIG_DESCRIPTION,      
									( LPBYTE ) pBuffer, 
									dwBufSize,
									&dwBytesNeeded  
								 );
				if ( !bSuccess )
				{
					DWORD dwError = GetLastError ();
					if ( dwError == ERROR_INSUFFICIENT_BUFFER )
					{
						pBuffer = ( SERVICE_DESCRIPTION *) new BYTE [ dwBytesNeeded ];
						if ( pBuffer != NULL )
						{
							try
							{
								BOOL bSuccess = QueryServiceConfig2(
													(SC_HANDLE) hSvcHandle, 
													SERVICE_CONFIG_DESCRIPTION,      
													( LPBYTE ) pBuffer, 
													dwBytesNeeded,
													&dwBytesNeeded  
												 );

								if ( bSuccess )
								{
									pInstance->SetCharSplat(IDS_Description, pBuffer->lpDescription );
								}
							}
							catch ( ... )
							{
								delete [] pBuffer;
								throw;
							}
							delete [] pBuffer;
						}
					}
				}
			}

			BOOL t_QueryStatus = FALSE ;

			if( NULL != (SC_HANDLE)hSvcHandle )
			{
				DWORD dwByteCount = 0 ;

				memset(ConfigBuffer, 0, sizeof(ConfigBuffer)) ;

				t_QueryStatus = QueryServiceConfig (

					hSvcHandle,
					pConfigInfo,
					sizeof(ConfigBuffer),
					&dwByteCount
				) ;
			}

			if ( t_QueryStatus == TRUE )
			{
				pInstance->SetDWORD(IDS_TagId, pConfigInfo->dwTagId );

				switch ( pConfigInfo->dwServiceType & ( ~SERVICE_INTERACTIVE_PROCESS ) )
				{
					case SERVICE_WIN32_OWN_PROCESS:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Own Process"));
					}
					break;

					case SERVICE_WIN32_SHARE_PROCESS:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Share Process"));
					}
					break;

					case SERVICE_KERNEL_DRIVER:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Kernel Driver"));
						hRes = WBEM_E_NOT_FOUND;  // Not a service
					}
					break;

					case SERVICE_FILE_SYSTEM_DRIVER:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("File System Driver"));
						hRes = WBEM_E_NOT_FOUND;  // Not a service
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Unknown"));
					}
					break;
				}

				pInstance->Setbool(IDS_DesktopInteract, pConfigInfo->dwServiceType & SERVICE_INTERACTIVE_PROCESS);

				switch (pConfigInfo->dwStartType)
				{
					case SERVICE_BOOT_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Boot"));
					}
					break;

					case SERVICE_SYSTEM_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("System"));
					}
					break;

					case SERVICE_AUTO_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Auto"));
					}
					break;

					case SERVICE_DEMAND_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Manual"));
					}
					break;

					case SERVICE_DISABLED:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Disabled"));
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Unknown"));
					}
					break;
				}

				switch (pConfigInfo->dwErrorControl)
				{
					case SERVICE_ERROR_IGNORE:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Ignore"));
					}
					break;

					case SERVICE_ERROR_NORMAL:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Normal"));
					}
					break;

					case SERVICE_ERROR_SEVERE:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Severe"));
					}
					break;

					case SERVICE_ERROR_CRITICAL:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Critical"));
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Unknown"));
					}
					break;
				}

				if ( pConfigInfo->lpBinaryPathName && pConfigInfo->lpBinaryPathName [ 0 ] )
				{
					pInstance->SetCharSplat ( IDS_PathName, pConfigInfo->lpBinaryPathName );
				}

				if ( pConfigInfo->lpServiceStartName && pConfigInfo->lpServiceStartName [ 0 ] )
				{
					pInstance->SetCharSplat ( IDS_StartName, pConfigInfo->lpServiceStartName ) ;
				}

				if ( pConfigInfo->lpDisplayName && pConfigInfo->lpDisplayName [ 0 ] )
				{
					pInstance->SetCharSplat ( IDS_DisplayName, pConfigInfo->lpDisplayName ) ;
					pInstance->SetCharSplat ( IDS_Caption, pConfigInfo->lpDisplayName ) ;
					// Not Required, since another API is made to get the description.
					//pInstance->SetCharSplat ( IDS_Description, pConfigInfo->lpDisplayName ) ;
				}
			}
			else
			{
				pInstance->SetCharSplat ( IDS_ServiceType, _T("Unknown") ) ;
				pInstance->SetCharSplat ( IDS_StartMode, _T("Unknown") ) ;
				pInstance->SetCharSplat ( IDS_ErrorControl, _T("Unknown") ) ;
			}
		}

		if( NULL == (SC_HANDLE)hSvcHandle && ERROR_ACCESS_DENIED == t_dwLastError )
		{
			// could enumerate the service but could not open it
			hRes = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			// Service not started, etc...
			hRes = WBEM_NO_ERROR ;
		}
	}
	else
	{
	   hRes = WBEM_S_NO_ERROR;
	}

    pInstance->SetCharSplat ( IDS_CreationClassName , PROPSET_NAME_SERVICE ) ;
    pInstance->SetCharSplat ( IDS_SystemCreationClassName , PROPSET_NAME_COMPSYS ) ;
    pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

    // Redundant for getobject, but hey...
    pInstance->SetCharSplat ( IDS_Name, szServiceName ) ;

    return hRes;
}

HRESULT CWin32Service::LoadPropertyValuesNT (

	SC_HANDLE hDBHandle,
	LPCTSTR szServiceName,
	CInstance *pInstance,
	DWORD dwProperties,
	CAdvApi32Api* a_pAdvApi32
)
{
    HRESULT hRes = WBEM_S_NO_ERROR; // Since we have the name, we can populate the key.

    // Open the service
    //=================

    // Check to see if we HAVE to open the service.  If we are running as a
    // query and they didn't request some of these properties, let's not waste the time.


  // If they want any of these, we'll have to do StatusInfo

	BOOL bStatusInfo = dwProperties &
        (BIT_State | BIT_Started | BIT_AcceptStop | BIT_AcceptPause | BIT_Status |
         BIT_ProcessId | BIT_ExitCode | BIT_ServiceSpecificExitCode | BIT_CheckPoint |
         BIT_WaitHint );

  // If they want any of these, we'll have to do ConfigInfo

	BOOL bConfigInfo = dwProperties &
        (BIT_TagId | BIT_ServiceType | BIT_DesktopInteract | BIT_StartMode |
         BIT_ErrorControl | BIT_PathName | BIT_DisplayName | BIT_Caption |
         BIT_Description | BIT_StartName);

    SmartCloseServiceHandle hSvcHandle = OpenService (

		hDBHandle,
		szServiceName,
		SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_INTERROGATE
	) ;

	DWORD t_dwLastError = GetLastError();

	if ( ( hSvcHandle == NULL ) && ( ERROR_SERVICE_DOES_NOT_EXIST == t_dwLastError || ERROR_INVALID_NAME == t_dwLastError) )
	{
		return WBEM_E_NOT_FOUND ;
	}

	// If all they wanted was the name, skip all this.
	if ( bStatusInfo || bConfigInfo )
	{
		// If the service could not be opened
		// drop through and collect up the defaults
		// ========================================
		if ( bStatusInfo )
		{
			DWORD t_ProcessId = 0 ;
			DWORD t_CurrentState ;
			DWORD t_ControlsAccepted ;
			DWORD t_Win32ExitCode = 0 ;
			DWORD t_ServiceSpecific = 0 ;
			DWORD t_CheckPoint = 0 ;
			DWORD t_WaitHint = 0 ;

			BOOL t_Status = FALSE ;

			if( NULL != (SC_HANDLE)hSvcHandle )
			{
				if ( IsWinNT5() && a_pAdvApi32 != NULL)
				{
					SERVICE_STATUS_PROCESS StatusInfo ;

					DWORD t_ExpectedSize = 0 ;

					DWORD t_dwRet = a_pAdvApi32->QueryServiceStatusEx (

						hSvcHandle,
						SC_STATUS_PROCESS_INFO ,
						( UCHAR * ) &StatusInfo ,
						sizeof ( StatusInfo ) ,
						& t_ExpectedSize ,
						&t_Status
					) ;

					if ( t_dwRet )
					{
						  // the function did indeed exist

						if ( t_Status == TRUE )
						{
							t_ProcessId = StatusInfo.dwProcessId ;
							t_CurrentState = StatusInfo.dwCurrentState ;
							t_ControlsAccepted = StatusInfo.dwControlsAccepted ;
							t_Win32ExitCode = StatusInfo.dwWin32ExitCode ;
							t_ServiceSpecific = StatusInfo.dwServiceSpecificExitCode ;
							t_CheckPoint = StatusInfo.dwCheckPoint ;
							t_WaitHint = StatusInfo.dwWaitHint ;
						}
					}
				}
				else
				{
					SERVICE_STATUS StatusInfo ;
					t_Status = QueryServiceStatus(hSvcHandle, &StatusInfo) ;
					if(t_Status == TRUE)
					{
						t_CurrentState = StatusInfo.dwCurrentState ;
						t_ControlsAccepted = StatusInfo.dwControlsAccepted ;
						t_Win32ExitCode = StatusInfo.dwWin32ExitCode ;
						t_ServiceSpecific = StatusInfo.dwServiceSpecificExitCode ;
						t_CheckPoint = StatusInfo.dwCheckPoint ;
						t_WaitHint = StatusInfo.dwWaitHint ;
					}
				}
			}

			bool bStarted = true;

			if ( t_Status )
			{
				switch (t_CurrentState)
				{
					case SERVICE_STOPPED:
					{
						pInstance->SetCharSplat(IDS_State, _T("Stopped"));
						bStarted = false;
					}
					break;

					case SERVICE_START_PENDING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Start Pending"));
						bStarted = true;
					}
					break;

					case SERVICE_STOP_PENDING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Stop Pending"));
						bStarted = true;
					}
					break;

					case SERVICE_RUNNING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Running"));
						bStarted = true;
					}
					break;

					case SERVICE_CONTINUE_PENDING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Continue Pending"));
						bStarted = true;
					}
					break;

					case SERVICE_PAUSE_PENDING:
					{
						pInstance->SetCharSplat(IDS_State, _T("Pause Pending"));
						bStarted = true;
					}
					break;

					case SERVICE_PAUSED:
					{
						pInstance->SetCharSplat(IDS_State, _T("Paused"));
						bStarted = true;
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_State, _T("Unknown") );
						bStarted = true;
					}
					break;
				}

				pInstance->Setbool(IDS_Started, bStarted);
				pInstance->Setbool(IDS_AcceptStop, (t_ControlsAccepted) & SERVICE_ACCEPT_STOP);
				pInstance->Setbool(IDS_AcceptPause, (t_ControlsAccepted) & SERVICE_ACCEPT_PAUSE_CONTINUE);

				pInstance->SetDWORD ( IDS_ProcessId , t_ProcessId ) ;
				pInstance->SetDWORD ( IDS_ExitCode , t_Win32ExitCode ) ;
				pInstance->SetDWORD ( IDS_ServiceSpecificExitCode , t_ServiceSpecific ) ;
				pInstance->SetDWORD ( IDS_CheckPoint , t_CheckPoint ) ;
				pInstance->SetDWORD ( IDS_WaitHint , t_WaitHint ) ;

			}
			else
			{
				pInstance->SetCharSplat(IDS_State, _T("Unknown") );
			}

            if (dwProperties & BIT_Status)
            {
			    if( hSvcHandle )
			    {
				    SERVICE_STATUS StatusInfo ;
				    if ( ( ! bStarted ) || ( ControlService ( hSvcHandle , SERVICE_CONTROL_INTERROGATE , &StatusInfo ) != 0 ) )
				    {
					    pInstance->SetCharSplat(IDS_Status, IDS_OK);
				    }
				    else
				    {
					    pInstance->SetCharSplat(IDS_Status, IDS_Degraded);
				    }
			    }
			    else
			    {
				    pInstance->SetCharSplat(IDS_Status, IDS_Unknown);
			    }
            }
		}

		if (bConfigInfo)
		{
			// Get the rest of the config info
			//================================
			char ConfigBuffer[1024] ;
			LPQUERY_SERVICE_CONFIG pConfigInfo = ( LPQUERY_SERVICE_CONFIG ) ConfigBuffer ;

			// These may get overwritten below if we can find something better

			pInstance->SetCharSplat(IDS_Caption, szServiceName );
			pInstance->SetCharSplat(IDS_DisplayName, szServiceName );
			

			// We need to make another call for getting the Description of the Service
			if ( NULL != (SC_HANDLE)hSvcHandle )
			{
				DWORD dwBufSize = 0;
				DWORD dwBytesNeeded = 0;
				SERVICE_DESCRIPTION *pBuffer = NULL;
				BOOL bSuccess = QueryServiceConfig2(
									(SC_HANDLE) hSvcHandle, 
									SERVICE_CONFIG_DESCRIPTION,      
									( LPBYTE ) pBuffer, 
									dwBufSize,
									&dwBytesNeeded  
								 );
				if ( !bSuccess )
				{
					DWORD dwError = GetLastError ();
					if ( dwError == ERROR_INSUFFICIENT_BUFFER )
					{
						pBuffer = ( SERVICE_DESCRIPTION *) new BYTE [ dwBytesNeeded ];
						if ( pBuffer != NULL )
						{
							try
							{
								BOOL bSuccess = QueryServiceConfig2(
													(SC_HANDLE) hSvcHandle, 
													SERVICE_CONFIG_DESCRIPTION,      
													( LPBYTE ) pBuffer, 
													dwBytesNeeded,
													&dwBytesNeeded  
												 );

								if ( bSuccess )
								{
									pInstance->SetCharSplat(IDS_Description, pBuffer->lpDescription );
								}
							}
							catch ( ... )
							{
								delete [] pBuffer;
								throw;
							}
							delete [] pBuffer;
						}
					}
				}
			}

			BOOL t_QueryStatus = FALSE ;

			if( NULL != (SC_HANDLE)hSvcHandle )
			{
				DWORD dwByteCount = 0 ;

				memset(ConfigBuffer, 0, sizeof(ConfigBuffer)) ;

				t_QueryStatus = QueryServiceConfig (

					hSvcHandle,
					pConfigInfo,
					sizeof(ConfigBuffer),
					&dwByteCount
				) ;
			}

			if ( t_QueryStatus == TRUE )
			{
				pInstance->SetDWORD(IDS_TagId, pConfigInfo->dwTagId );

				switch ( pConfigInfo->dwServiceType & ( ~SERVICE_INTERACTIVE_PROCESS ) )
				{
					case SERVICE_WIN32_OWN_PROCESS:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Own Process"));
					}
					break;

					case SERVICE_WIN32_SHARE_PROCESS:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Share Process"));
					}
					break;

					case SERVICE_KERNEL_DRIVER:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Kernel Driver"));
						hRes = WBEM_E_NOT_FOUND;  // Not a service
					}
					break;

					case SERVICE_FILE_SYSTEM_DRIVER:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("File System Driver"));
						hRes = WBEM_E_NOT_FOUND;  // Not a service
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_ServiceType, _T("Unknown"));
					}
					break;
				}

				pInstance->Setbool(IDS_DesktopInteract, pConfigInfo->dwServiceType & SERVICE_INTERACTIVE_PROCESS);

				switch (pConfigInfo->dwStartType)
				{
					case SERVICE_BOOT_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Boot"));
					}
					break;

					case SERVICE_SYSTEM_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("System"));
					}
					break;

					case SERVICE_AUTO_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Auto"));
					}
					break;

					case SERVICE_DEMAND_START:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Manual"));
					}
					break;

					case SERVICE_DISABLED:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Disabled"));
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_StartMode, _T("Unknown"));
					}
					break;
				}

				switch (pConfigInfo->dwErrorControl)
				{
					case SERVICE_ERROR_IGNORE:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Ignore"));
					}
					break;

					case SERVICE_ERROR_NORMAL:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Normal"));
					}
					break;

					case SERVICE_ERROR_SEVERE:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Severe"));
					}
					break;

					case SERVICE_ERROR_CRITICAL:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Critical"));
					}
					break;

					default:
					{
						pInstance->SetCharSplat(IDS_ErrorControl, _T("Unknown"));
					}
					break;
				}

				if ( pConfigInfo->lpBinaryPathName && pConfigInfo->lpBinaryPathName [ 0 ] )
				{
					pInstance->SetCharSplat ( IDS_PathName, pConfigInfo->lpBinaryPathName );
				}

				if ( pConfigInfo->lpServiceStartName && pConfigInfo->lpServiceStartName [ 0 ] )
				{
					pInstance->SetCharSplat ( IDS_StartName, pConfigInfo->lpServiceStartName ) ;
				}

				if ( pConfigInfo->lpDisplayName && pConfigInfo->lpDisplayName [ 0 ] )
				{
					pInstance->SetCharSplat ( IDS_DisplayName, pConfigInfo->lpDisplayName ) ;
					pInstance->SetCharSplat ( IDS_Caption, pConfigInfo->lpDisplayName ) ;
					// Not Required, since another API is made to get the description.
					//pInstance->SetCharSplat ( IDS_Description, pConfigInfo->lpDisplayName ) ;
				}
			}
			else
			{
				pInstance->SetCharSplat ( IDS_ServiceType, _T("Unknown") ) ;
				pInstance->SetCharSplat ( IDS_StartMode, _T("Unknown") ) ;
				pInstance->SetCharSplat ( IDS_ErrorControl, _T("Unknown") ) ;
			}
		}

		if( NULL == (SC_HANDLE)hSvcHandle && ERROR_ACCESS_DENIED == t_dwLastError )
		{
			// could enumerate the service but could not open it
			hRes = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			// Service not started, etc...
			hRes = WBEM_NO_ERROR ;
		}
	}
	else
	{
	   hRes = WBEM_S_NO_ERROR;
	}

    pInstance->SetCharSplat ( IDS_CreationClassName , PROPSET_NAME_SERVICE ) ;
    pInstance->SetCharSplat ( IDS_SystemCreationClassName , PROPSET_NAME_COMPSYS ) ;
    pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

    // Redundant for getobject, but hey...
    pInstance->SetCharSplat ( IDS_Name, szServiceName ) ;

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    : PutInstance
 *
 *  DESCRIPTION : Allows caller to assign state to service
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : BOOL indicating success/failure
 *
 *  COMMENTS    : We don't wait around for the service to start, pause or stop --
 *                the return code simply indicates that the command was success-
 *                fully received by the Service Control Manager.
 *
 *****************************************************************************/

HRESULT CWin32Service::PutInstance (

	const CInstance &a_Instance,
	long lFlags /*= 0L*/
)
{
    DWORD dwFlags = lFlags & 3;

#ifdef NTONLY
	if ( ( dwFlags != WBEM_FLAG_CREATE_OR_UPDATE ) && ( dwFlags != WBEM_FLAG_UPDATE_ONLY ) )
	{
		return WBEM_E_UNSUPPORTED_PARAMETER ;
	}

    CInstancePtr t_Instance;

	CHString t_State ;
    CHString t_RelPath;

    a_Instance.GetCHString ( IDS___Relpath, t_RelPath);
	a_Instance.GetCHString ( IDS_State , t_State ) ;

    // Only need to make sure it exists
	HRESULT t_Result = CWbemProviderGlue :: GetInstanceKeysByPath ( t_RelPath, &t_Instance, a_Instance.GetMethodContext() ) ;
	if ( FAILED(t_Result) )
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			if ( dwFlags == WBEM_FLAG_CREATE_OR_UPDATE )
			{
				return WBEM_E_UNSUPPORTED_PARAMETER ;
			}
			else if ( ( dwFlags & WBEM_FLAG_UPDATE_ONLY ) == dwFlags )
			{
				return t_Result ;
			}
			else
			{
				return t_Result ;
			}
		}
		else
		{
			return t_Result ;
		}
	}

	t_Result = WBEM_E_NOT_SUPPORTED ;

	CInstance *t_OutParam = NULL ;
	if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_RUNNING ) == 0 )
	{
		t_Result = ExecStart ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_PAUSED ) == 0 )
	{
		t_Result = ExecPause ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_STOPPED ) == 0 )
	{
		t_Result = ExecStop ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else
	{
	}
#endif

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\share.cpp ===
//=================================================================

//

// Share.CPP -- Logical Disk property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//=================================================================

#include "precomp.h"

#include <winioctl.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmshare.h>
#include <lmapibuf.h>
#include <assertbreak.h>
#ifdef NTONLY
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class
#include "securitydescriptor.h"
#include "secureshare.h"
#include "Win32Securitydescriptor.h"
#endif

#include "wbemnetapi32.h"

#include "Share.h"

#include "sid.h"
#include "accessentrylist.h"
#include "accctrl.h"
#include "AccessRights.h"
#include "ObjAccessRights.h"
#include "winspool.h"



// Property set declaration
//=========================

Share  MyShareSet(PROPSET_NAME_SHARE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Share::Share
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Share :: Share (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Share::~Share
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

Share::~Share()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Share::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Share :: GetObject (

	CInstance* pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT hRetCode =  WBEM_E_FAILED;
	CNetAPI32 NetAPI ;

	if ( NetAPI.Init() == ERROR_SUCCESS )
	{
		CHString shareName;
		pInstance->GetCHString(IDS_Name, shareName);

#ifdef NTONLY
		{
			// The nt versions take a wchar

			hRetCode = GetShareInfoNT (

				NetAPI,
				shareName,
				pInstance
			);

		}
#endif
	}

	return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Share::EnumerateInstances
 *
 *  DESCRIPTION : Calls appropriate Enum function
 *
 *  INPUTS      : MethodContext*  pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Share :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
#ifdef NTONLY
		return EnumerateInstancesNT ( pMethodContext ) ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : Share::EnumerateInstancesNT
 *
 *  DESCRIPTION : Enums shares for NT
 *
 *  INPUTS      : MethodContext*  pMethodContext
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT Share :: EnumerateInstancesNT (

	MethodContext *pMethodContext
)
{
    DWORD i;
    DWORD dwShareCount, dwTotalShareCount, dwResume, dwResume2;
    NET_API_STATUS nRetCode ;
    SHARE_INFO_0 *pShareInfo = NULL ;
	CNetAPI32 NetAPI ;
    if ( NetAPI.Init() != ERROR_SUCCESS )
	{
        return WBEM_E_FAILED ;
    }

    dwShareCount = dwTotalShareCount = dwResume = dwResume2 = 0;

    HRESULT hr = WBEM_S_NO_ERROR;
	
    try
	{
        nRetCode = NetAPI.NetShareEnum(
            NULL, 
            0, 
            (LPBYTE *) &pShareInfo,
		    MAX_PREFERRED_LENGTH, 
            &dwShareCount, 
            &dwTotalShareCount, 
            &dwResume);
	
        if(nRetCode == ERROR_SUCCESS && pShareInfo)
        {
			for(i = 0 ; i < dwShareCount && SUCCEEDED(hr); i++)
			{
       			CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false )  ;
				if(pInstance != NULL)
				{
                    if ( SUCCEEDED( GetShareInfoNT ( NetAPI , (WCHAR *)pShareInfo[i].shi0_netname , pInstance) ) )
					{
						hr = pInstance->Commit ();
					}
				}
			}
        }
	}
	catch ( ... )
	{
		if ( pShareInfo )
		{
			NetAPI.NetApiBufferFree ( pShareInfo ) ;
			pShareInfo = NULL ;
		}

		throw ;
	}

	if ( pShareInfo )
	{
		NetAPI.NetApiBufferFree ( pShareInfo ) ;
		pShareInfo = NULL ;
	}

	return hr;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Share::GetShareInfoNT
 *
 *  DESCRIPTION : Loads SHARE_INFO struct w/property values
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : You may wonder why we don't just call NetShareEnum with 502
 *                and populate from there.  There are two reasons.  One,
 *                structuring it this way makes GetObject easier.  Two, 502
 *                doesn't always seem to return all the shares. <sigh>
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT Share :: GetShareInfoNT (

	CNetAPI32 &NetAPI,
	const WCHAR *pShareName,
	CInstance* pInstance
)
{
	SHARE_INFO_502 *pShareInfo502 = NULL;
	SHARE_INFO_1	*pShareInfo1 = NULL;
	NET_API_STATUS dwRetCode;

	// yes, we're casting away the const on shareName
	// yes, we think we know what we're doing....

	// First get the basic share information with level 1 since no rights
	// are needed.
	try
	{
		dwRetCode = NetAPI.NetShareGetInfo (

			NULL,
			(LPTSTR) pShareName,
			1,
			(LPBYTE *) &pShareInfo1
		) ;

		if (NERR_Success != dwRetCode )
		{
			return WinErrorToWBEMhResult ( dwRetCode ) ;
		}

		pInstance->SetWCHARSplat(IDS_Name, (WCHAR *) pShareInfo1->shi1_netname);

		if ( wcslen((WCHAR *) pShareInfo1->shi1_remark ) == 0)
		{
			pInstance->SetWCHARSplat(IDS_Caption, (WCHAR *) pShareInfo1->shi1_netname);
		}
		else
		{
			pInstance->SetWCHARSplat(IDS_Caption, (WCHAR *) pShareInfo1->shi1_remark);
		}

		pInstance->SetWCHARSplat(IDS_Description, (WCHAR *) pShareInfo1->shi1_remark);
		pInstance->SetCharSplat(_T("Status"), _T("OK"));

		// Now try to get the advanced properties using the admin-level 502.
		dwRetCode = NetAPI.NetShareGetInfo (

			NULL,
			(LPTSTR) pShareName,
			502,
			(LPBYTE *) &pShareInfo502
		) ;

		if (dwRetCode == NERR_Success)
		{
			pInstance->SetWCHARSplat(_T("Path"), (WCHAR *)pShareInfo502->shi502_path);
			pInstance->SetDWORD(_T("Type"), pShareInfo502->shi502_type);

			if (pShareInfo502->shi502_max_uses == -1)
			{
				pInstance->Setbool(IDS_AllowMaximum, true);
			}
			else
			{
				pInstance->Setbool(IDS_AllowMaximum, false);
				pInstance->SetDWORD(IDS_MaximumAllowed, (DWORD) pShareInfo502->shi502_max_uses);
			}
		}
	}
	catch ( ... )
	{
		if ( pShareInfo502 )
		{
			NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
			pShareInfo502 = NULL ;
		}

		if ( pShareInfo1 )
		{
			NetAPI.NetApiBufferFree ( pShareInfo1 ) ;
			pShareInfo502 = NULL ;
		}

		throw ;
	}

	if ( pShareInfo502 )
	{
		NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
		pShareInfo502 = NULL ;
	}

	if ( pShareInfo1 )
	{
		NetAPI.NetApiBufferFree ( pShareInfo1 ) ;
		pShareInfo502 = NULL ;
	}

	return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : ScheduledJob::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Share :: DeleteInstance (

	const CInstance &a_Instance,
	long a_Flags /*= 0L*/
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = STATUS_SUCCESS ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_Name ;
	if ( a_Instance.GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
			{

				CNetAPI32 t_NetAPI ;

				if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					NET_API_STATUS t_ShareStatus = NERR_Success;
#ifdef NTONLY
                    // If is a printer share, we have some extra work...
                    // In order to get the type property, we need to 
                    // get a fully flushed out instance (the one we
                    // have here via a DeleteInstanceAsynch call only
                    // has the object path).  We need to do this before
                    // the call to NetShareDel, as we do a GetObject
                    // below, which will fail if we have already deleted
                    // the printer.  Furthermore, as this acutally
                    // deletes the share from Netapi's perspective as
                    // well, we don't need to call that api we do it this 
                    // way.
                    CHString chstr__PATH;
                    DWORD dwType = 0;
                    chstr__PATH.Format(L"Win32_Share.Name=\"%s\"",(LPCWSTR)t_Name); 
                    CInstancePtr pinstPrinter;
                    if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(
                        chstr__PATH, 
                        &pinstPrinter, 
                        a_Instance.GetMethodContext())))
                    {
                        pinstPrinter->GetDWORD(L"Type", dwType);

                        if(dwType == STYPE_PRINTQ)
                        {
                            HANDLE hPrinter = INVALID_HANDLE_VALUE;

                            try
                            {
                                PRINTER_DEFAULTS pd;
                                ZeroMemory(&pd, sizeof(PRINTER_DEFAULTS));
                                pd.DesiredAccess = PRINTER_ALL_ACCESS;

                                if(::OpenPrinter(
                                    _bstr_t(t_Name), 
                                    &hPrinter, 
                                    &pd))
                                {
                                    PPRINTER_INFO_2 ppi2 = NULL;
                                    DWORD dwNeeded;

                                    if(!::GetPrinter(
                                        hPrinter, 
                                        2, 
                                        NULL, 
                                        0, 
                                        &dwNeeded) && 
                                        ERROR_INSUFFICIENT_BUFFER == ::GetLastError())
                                    {
                                        CSmartBuffer pBuff(dwNeeded);
                                
                                        if(::GetPrinter(
                                            hPrinter, 
                                            2, 
                                            pBuff, 
                                            dwNeeded, 
                                            &dwNeeded))
                                        {
                                            ppi2 = (PPRINTER_INFO_2)(LPBYTE) pBuff;
                                            ppi2->Attributes = ppi2->Attributes & (~PRINTER_ATTRIBUTE_SHARED);
                                            if(!::SetPrinter(
                                                hPrinter,
                                                2,
                                                pBuff,
                                                0))
                                            {
                                                t_Result = WinErrorToWBEMhResult(::GetLastError());
                                            }
                                        }
                                        else
                                        {
                                            t_Result = WinErrorToWBEMhResult(::GetLastError());
                                        }
                                    }
                                    else
                                    {
                                        t_Result = WinErrorToWBEMhResult(::GetLastError());  
                                    }
                                
                                    ::ClosePrinter(hPrinter);
                                    hPrinter = INVALID_HANDLE_VALUE;
                                }
                                else
                                {
                                    t_Result = WinErrorToWBEMhResult(::GetLastError());
                                }
                            }
                            catch(...)
                            {
                                if(hPrinter != INVALID_HANDLE_VALUE)
                                {
                                    ::ClosePrinter(hPrinter);
                                    hPrinter = INVALID_HANDLE_VALUE;
                                }
                                throw;
                            }
                        }
                    }

                    // So now do the NetShareDel.
                    if(dwType != STYPE_PRINTQ)
                    {
						_bstr_t t_BStr_Name ( t_Name.AllocSysString (), false )  ;

						t_ShareStatus = t_NetAPI.NetShareDel (

							NULL ,
							(LPTSTR) (LPCTSTR) t_BStr_Name ,
							0
						) ;
					}


#endif

					if ( t_ShareStatus != NERR_Success )
					{
						t_Result = GetShareResultCode ( t_ShareStatus ) ;
					}
				}
			}
			else
			{
// Zero Length string

				t_Result = WBEM_E_TYPE_MISMATCH ;
			}
		}
		else
		{
			t_Result = WBEM_E_TYPE_MISMATCH ;
		}
	}
	else
	{
		t_Result = WBEM_E_TYPE_MISMATCH ;
	}

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Share ::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Share::ExecMethod (

	const CInstance& a_Instance,
	const BSTR a_MethodName ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	long a_Flags
)
{
	if ( ! a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

   // Do we recognize the method?

	if ( _wcsicmp ( a_MethodName , METHOD_NAME_CREATE ) == 0 )
	{
		return ExecCreate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_DELETE ) == 0 )
	{
		return ExecDelete ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_SETSHAREINFO ) == 0 )
	{
		return ExecSetShareInfo ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_GETACCESSMASK ) == 0 )
	{
		return ExecGetShareAccessMask ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}


	return WBEM_E_INVALID_METHOD;
}

DWORD Share :: GetShareErrorCode ( DWORD a_Error )
{
	DWORD t_Status ;
	switch ( a_Error )
	{
		case ERROR_INVALID_NAME:
		{
			t_Status = STATUS_INVALID_NAME ;
		}
		break ;

		case ERROR_INVALID_LEVEL:
		{
			t_Status = STATUS_INVALID_LEVEL;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			t_Status = STATUS_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Status = STATUS_INVALID_PARAMETER ;
		}
		break;

		//gone with the w...
		//case NERR_ShareExists:
		case NERR_DuplicateShare:
		{
			t_Status = STATUS_DUPLICATE_SHARE ;
		}
		break ;

		case NERR_RedirectedPath:
		{
			t_Status = STATUS_REDIRECTED_PATH ;
		}
		break ;

		case NERR_UnknownDevDir:
		case ERROR_BAD_NETPATH://win95
		case ERROR_FILE_NOT_FOUND: // NetShareAdd returns this if dir not present
		case ERROR_INVALID_PRINTER_NAME:// NetShareAdd returns this if printer name is not correct
		{
			t_Status = STATUS_UNKNOWN_DEVICE_OR_DIRECTORY ;
		}
		break ;

		case NERR_ShareNotFound:
		case NERR_NetNameNotFound:
		{
			t_Status = STATUS_NET_NAME_NOT_FOUND ;
		}
		break ;

		default:
		{
			t_Status = STATUS_UNKNOWN_FAILURE ;
		}
		break ;
	}

	return t_Status ;
}

HRESULT Share :: GetShareResultCode ( DWORD a_Error )
{
	HRESULT t_Result ;
	switch ( a_Error )
	{
		case ERROR_ACCESS_DENIED:
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
		break;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

typedef void (*GETDESCRIPTOR)(
	CInstance* pInstance, PSECURITY_DESCRIPTOR *ppDescriptor);


HRESULT Share :: CheckShareCreation (

	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	DWORD &a_Status
)
{
	HRESULT t_Result = S_OK ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_Name ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_InParams->GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
			{
			}
			else
			{
// Zero Length string

				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CHString t_Path ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_PATH , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_InParams->GetCHString ( METHOD_ARG_NAME_PATH , t_Path ) && ! t_Path .IsEmpty () )
			{

			}
			else
			{
// Zero Length string

				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_CommentSpecified = false ;
	CHString t_Comment ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_COMMENT , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_CommentSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_COMMENT , t_Comment ) )
				{
					t_CommentSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_PasswordSpecified = false ;
	CHString t_Password ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_PASSWORD , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_PasswordSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_PASSWORD , t_Password ) )
				{
					t_PasswordSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	DWORD t_ShareType ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_TYPE , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			DWORD t_Share ;
			if ( a_InParams->GetDWORD ( METHOD_ARG_NAME_TYPE , t_Share ) )
			{
				if ( ( t_Share <= STYPE_IPC ) ||
					( t_Share >= (STYPE_DISKTREE + STYPE_SPECIAL) && t_Share <= (STYPE_IPC + STYPE_SPECIAL) ) )
				{
					t_ShareType = t_Share ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	DWORD t_Permissions = 0 ;

	DWORD t_MaximumAllowed = SHI_USES_UNLIMITED ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_MAXIMUMALLOWED , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetDWORD ( METHOD_ARG_NAME_MAXIMUMALLOWED , t_MaximumAllowed ) )
				{
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CInstancePtr t_EmbeddedObject;

	bool t_AccessSpecified = true ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_ACCESS , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UNKNOWN || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_AccessSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetEmbeddedObject ( METHOD_ARG_NAME_ACCESS , &t_EmbeddedObject , a_InParams->GetMethodContext () ) )
				{
					t_AccessSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	PSECURITY_DESCRIPTOR pSD = NULL ;

	if ( t_AccessSpecified )
	{
		CHString t_ClassProperty ( L"__CLASS" ) ;
		if ( t_EmbeddedObject->GetStatus ( t_ClassProperty , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				CHString t_Class ;
				if ( t_EmbeddedObject->GetCHString ( t_ClassProperty , t_Class ) )
				{
					if ( t_Class.CompareNoCase ( PROPSET_NAME_SECURITYDESCRIPTOR ) != 0 )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else // now get the SD
					{
#ifdef NTONLY
                        GetDescriptorFromMySecurityDescriptor(t_EmbeddedObject, &pSD);
#endif
					}
				}
			}
			else
			{
				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
	}

	if ( a_Status == STATUS_SUCCESS )
	{

#ifdef NTONLY
		{
			try
			{
				SHARE_INFO_502 t_ShareInfo ;

				_bstr_t t_BStr_Name ( t_Name.AllocSysString (), false ) ;
				_bstr_t t_BStr_Path ( t_Path.AllocSysString (), false ) ;
				_bstr_t t_BStr_Comment = t_CommentSpecified ? t_Comment : ( ( PWCHAR ) NULL ) ;
				_bstr_t t_BStr_Password = t_PasswordSpecified ? t_Password  : ( ( PWCHAR ) NULL ) ;

				t_ShareInfo.shi502_netname = ( TCHAR * ) t_BStr_Name ;
				t_ShareInfo.shi502_type = t_ShareType ;
				t_ShareInfo.shi502_remark = ( TCHAR * ) t_BStr_Comment ;
				t_ShareInfo.shi502_permissions = t_Permissions ;
				t_ShareInfo.shi502_max_uses = t_MaximumAllowed ;
				t_ShareInfo.shi502_current_uses = 0 ;
				t_ShareInfo.shi502_path = ( TCHAR * ) t_BStr_Path ;
				t_ShareInfo.shi502_passwd = ( TCHAR * ) t_BStr_Password ;
				t_ShareInfo.shi502_reserved = 0 ;
				t_ShareInfo.shi502_security_descriptor = pSD ;

				DWORD t_ErrorIndex = 0 ;

				NET_API_STATUS t_ShareStatus ;

				CNetAPI32 t_NetAPI ;

				if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					t_ShareStatus = t_NetAPI.NetShareAdd (

						NULL ,
						502 ,
						( LPBYTE ) & t_ShareInfo ,
						& t_ErrorIndex
					) ;

					if ( t_ShareStatus != NERR_Success )
					{
						a_Status = GetShareErrorCode ( t_ShareStatus ) ;
					}
				}
			}
			catch ( ... )
			{
				if ( pSD )
				{
					free( pSD ) ;
					pSD = NULL ;
				}

				throw ;
			}

			if ( pSD )
			{
				free( pSD ) ;
				pSD = NULL ;
			}
		}
#endif
	}

	return t_Result ;
}

HRESULT Share :: CheckShareModification (

	const CInstance &a_Instance ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	DWORD &a_Status
)
{
	HRESULT t_Result = S_OK ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_Name ;
	if ( a_Instance.GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
			{
			}
			else
			{
// Zero Length string

				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_CommentSpecified = false ;
	CHString t_Comment ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_COMMENT , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_CommentSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_COMMENT , t_Comment ) )
				{
					t_CommentSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	DWORD t_Permissions = 0 ;

	DWORD t_MaximumAllowed = 0 ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_MAXIMUMALLOWED , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetDWORD ( METHOD_ARG_NAME_MAXIMUMALLOWED , t_MaximumAllowed ) )
				{
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CInstancePtr t_EmbeddedObject;

	bool t_AccessSpecified = true ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_ACCESS , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UNKNOWN || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_AccessSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetEmbeddedObject ( METHOD_ARG_NAME_ACCESS , &t_EmbeddedObject , a_InParams->GetMethodContext () ) )
				{
					t_AccessSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	PSECURITY_DESCRIPTOR pSD = NULL ;

	if ( t_AccessSpecified )
	{
		CHString t_ClassProperty ( L"__CLASS" ) ;
		if ( t_EmbeddedObject->GetStatus ( t_ClassProperty , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				CHString t_Class ;
				if ( t_EmbeddedObject->GetCHString ( t_ClassProperty , t_Class ) )
				{
					if ( t_Class.CompareNoCase ( PROPSET_NAME_SECURITYDESCRIPTOR ) != 0 )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else // now get the SD
					{
#ifdef NTONLY
                        GetDescriptorFromMySecurityDescriptor(t_EmbeddedObject, &pSD);
#endif
					}
				}
			}
			else
			{
				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
	}

    if ( a_Status == STATUS_SUCCESS )
	{
#ifdef NTONLY
		{
			try
			{
				SHARE_INFO_502 t_ShareInfo ;

				bstr_t t_BStr_Name ( t_Name.AllocSysString (), false ) ;
				bstr_t t_BStr_Comment = t_CommentSpecified ? t_Comment : ( ( PWCHAR ) NULL ) ;

				t_ShareInfo.shi502_netname = ( TCHAR * ) t_BStr_Name ;
				t_ShareInfo.shi502_type = 0 ;
				t_ShareInfo.shi502_remark = ( TCHAR * ) t_BStr_Comment ;
				t_ShareInfo.shi502_permissions = t_Permissions ;
				t_ShareInfo.shi502_max_uses = t_MaximumAllowed ;
				t_ShareInfo.shi502_current_uses = 0 ;
				t_ShareInfo.shi502_path = 0 ;
				t_ShareInfo.shi502_passwd = NULL ;
				t_ShareInfo.shi502_reserved = 0 ;
				t_ShareInfo.shi502_security_descriptor = pSD ;

				DWORD t_ErrorIndex = 0 ;

				CNetAPI32 t_NetAPI ;
				if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
				{
					NET_API_STATUS t_ShareStatus ;

					t_ShareStatus = t_NetAPI.NetShareSetInfo (

						NULL ,
						( LPTSTR ) t_BStr_Name ,
						502 ,
						( LPBYTE ) & t_ShareInfo ,
						& t_ErrorIndex
					) ;

					if ( t_ShareStatus != NERR_Success )
					{
						a_Status = GetShareErrorCode ( t_ShareStatus ) ;
					}
				}
			}
			catch ( ... )
			{
				if ( pSD )
				{
					free( pSD ) ;
					pSD = NULL ;
				}
				throw ;
			}

			if ( pSD )
			{
				free( pSD ) ;
				pSD = NULL ;
			}
		}
#endif

	} //if ( a_Status == STATUS_SUCCESS )

	return t_Result ;

}

HRESULT Share :: ExecCreate (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = STATUS_SUCCESS ;

	if ( a_InParams && a_OutParams )
	{
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CheckShareCreation (

				a_InParams ,
				a_OutParams ,
				t_Status
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

HRESULT Share :: ExecDelete (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = STATUS_SUCCESS ;

	if ( a_OutParams )
	{
		bool t_Exists ;
		VARTYPE t_Type ;

		CHString t_Name ;
		if ( a_Instance.GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				if ( a_Instance.GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
				{
					_bstr_t t_BStr_Name ( t_Name.AllocSysString (), false ) ;

					CNetAPI32 t_NetAPI ;

					if( ( t_Result = t_NetAPI.Init() ) == ERROR_SUCCESS )
					{
						NET_API_STATUS t_ShareStatus ;
	#ifdef NTONLY
						{
							t_ShareStatus = t_NetAPI.NetShareDel (

								NULL ,
								( LPTSTR ) t_BStr_Name ,
								0
							) ;
						}
	#endif

						if ( t_ShareStatus != NERR_Success )
						{
							t_Status = GetShareErrorCode ( t_ShareStatus ) ;
						}
					}
				}
				else
				{
	// Zero Length string

					t_Status = STATUS_INVALID_PARAMETER ;

				}
			}
			else
			{
				t_Status = STATUS_INVALID_PARAMETER ;
			}
		}
		else
		{
			t_Status = STATUS_INVALID_PARAMETER ;
			return WBEM_E_PROVIDER_FAILURE ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

HRESULT Share :: ExecSetShareInfo (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = STATUS_SUCCESS ;

	if ( a_InParams && a_OutParams )
	{
		t_Result = CheckShareModification (

			a_Instance ,
			a_InParams ,
			a_OutParams ,
			t_Status
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

HRESULT Share :: ExecGetShareAccessMask (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_Name ;
	if ( a_Instance.GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_Instance.GetCHString ( METHOD_ARG_NAME_NAME , t_Name ) && ! t_Name.IsEmpty () )
			{
			}
			else
			{
// Zero Length string
				t_Result = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if (SUCCEEDED(t_Result))
	{
		if ( a_OutParams )
		{
			t_Result = WBEM_E_FAILED ;
			ACCESS_MASK t_AccessMask;
			CObjAccessRights t_coar(t_Name, SE_LMSHARE, true);
			if(t_coar.GetError() == ERROR_SUCCESS)
			{
				if(t_coar.GetEffectiveAccessRights(&t_AccessMask) == ERROR_SUCCESS)
				{
					if (SUCCEEDED(a_OutParams->SetDWORD( METHOD_ARG_NAME_RETURNVALUE, t_AccessMask )))
					{
						t_Result = S_OK ;
					}
				}
			}
			else if(t_coar.GetError() == ERROR_ACCESS_DENIED)
			{
				if (SUCCEEDED(a_OutParams->SetDWORD( METHOD_ARG_NAME_RETURNVALUE, 0L )))
				{
					t_Result = S_OK ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\share.h ===
//=================================================================

//

// Share.h -- Logical disk property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/28/96    a-jmoon        Created
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_SHARE L"Win32_Share"
#define  PROPSET_NAME_SECURITYDESCRIPTOR L"Win32_SecurityDescriptor"

#define METHOD_NAME_CREATE				L"Create"
#define METHOD_NAME_DELETE				L"Delete"
#define METHOD_NAME_SETSHAREINFO		L"SetShareInfo"
#define METHOD_NAME_GETACCESSMASK		L"GetAccessMask"

#define METHOD_ARG_NAME_RETURNVALUE		L"ReturnValue"
#define METHOD_ARG_NAME_PATH			L"Path"
#define METHOD_ARG_NAME_NAME			L"Name"
#define METHOD_ARG_NAME_TYPE			L"Type"
#define METHOD_ARG_NAME_PERMISSIONS		L"Permissions"
#define METHOD_ARG_NAME_COMMENT			L"Description"
#define METHOD_ARG_NAME_MAXIMUMALLOWED	L"MaximumAllowed"
#define METHOD_ARG_NAME_PASSWORD		L"Password"
#define METHOD_ARG_NAME_ACCESS			L"Access"


#define PROPERTY_VALUE_TYPE_DISKTREE	0
#define PROPERTY_VALUE_TYPE_PRINTQ		1
#define PROPERTY_VALUE_TYPE_DEVICE		2
#define PROPERTY_VALUE_TYPE_IPC			3
#define	PROPERTY_VALUE_TYPE_SPECIAL		4

#define PROPERTY_VALUE_PERMISSIONS_READ			ACCESS_READ		// 0x01
#define PROPERTY_VALUE_PERMISSIONS_WRITE		ACCESS_WRITE	// 0x02
#define PROPERTY_VALUE_PERMISSIONS_CREATE		ACCESS_CREATE	// 0x04
#define PROPERTY_VALUE_PERMISSIONS_EXEC			ACCESS_EXEC		// 0x08
#define PROPERTY_VALUE_PERMISSIONS_DELETE		ACCESS_DELETE	// 0x10
#define PROPERTY_VALUE_PERMISSIONS_ATTRIB		ACCESS_ATRIB	// 0x20
#define PROPERTY_VALUE_PERMISSIONS_PERM			ACCESS_PERM		// 0x40

#define PROPERTY_VALUE_PERMISSIONS_ALL     (PROPERTY_VALUE_PERMISSIONS_READ|PROPERTY_VALUE_PERMISSIONS_WRITE|PROPERTY_VALUE_PERMISSIONS_CREATE|PROPERTY_VALUE_PERMISSIONS_EXEC|PROPERTY_VALUE_PERMISSIONS_DELETE|PROPERTY_VALUE_PERMISSIONS_ATTRIB|PROPERTY_VALUE_PERMISSIONS_PERM)

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS							0
#endif

#undef STATUS_NOT_SUPPORTED					
#define STATUS_NOT_SUPPORTED					1

// Control
#undef STATUS_ACCESS_DENIED					
#define STATUS_ACCESS_DENIED					2
#define STATUS_UNKNOWN_FAILURE					8

// Start
#define STATUS_INVALID_NAME						9
#undef STATUS_INVALID_LEVEL					
#define STATUS_INVALID_LEVEL					10
#undef STATUS_INVALID_PARAMETER				
#define STATUS_INVALID_PARAMETER				21

#define STATUS_DUPLICATE_SHARE					22
#define STATUS_REDIRECTED_PATH					23
#define STATUS_UNKNOWN_DEVICE_OR_DIRECTORY		24
#define STATUS_NET_NAME_NOT_FOUND				25

// These structures stolen from svrapi.h which conflicts with other .h files
struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];    /* share name */
	unsigned char 	shi50_type;                 /* see below */
    unsigned short	shi50_flags;                /* see below */
	char FAR *	shi50_remark;                   /* ANSI comment string */
	char FAR *	shi50_path;                     /* shared resource */
	char		shi50_rw_password[SHPWLEN+1];   /* read-write passwod (share-level security) */
	char		shi50_ro_password[SHPWLEN+1];   /* read-only password (share-level security) */
};	/* share_info_50 */

class Share:public Provider {

    public:

        // Constructor/destructor
        //=======================

        Share(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~Share() ;

        // Functions provide properties with current values
        //=================================================
		HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

		HRESULT ExecMethod (

			const CInstance& a_Instance,
			const BSTR a_MethodName,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags = 0L
		);

		HRESULT DeleteInstance (

			const CInstance& a_Instance,
			long a_Flags = 0L
		) ;

        // Utility
        //========
    private:

#ifdef NTONLY
        HRESULT EnumerateInstancesNT(MethodContext*  pMethodContext);
        HRESULT GetShareInfoNT(CNetAPI32 &NetAPI, const WCHAR *pShareName, CInstance* pInstance);
        bool GetAccessMask(LPCTSTR wstrShareName, ACCESS_MASK *pAccessMask);
#endif

		DWORD GetShareErrorCode ( DWORD a_ErrorCode ) ;

		HRESULT GetShareResultCode ( DWORD a_ErrorCode ) ;

		HRESULT CheckShareModification (

			const CInstance &a_Instance ,
			CInstance *a_InParams ,
			CInstance *a_OutParams ,
			DWORD &a_Status
		) ;

		HRESULT CheckShareCreation (

			CInstance *a_InParams ,
			CInstance *a_OutParams ,
			DWORD &a_Status
		) ;

		HRESULT ExecGetShareAccessMask (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecCreate (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecDelete (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecSetShareInfo (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\sharetodir.h ===
//=================================================================

//

// ShareToDir.h -- Share to Directory

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/31/98    davwoh         Created
//
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_SHARETODIR L"Win32_ShareToDirectory"

class CShareToDir:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CShareToDir(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CShareToDir() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\sharetodir.cpp ===
//=================================================================

//

// ShareToDir.cpp -- Share to Directory

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/31/98    davwoh         Created
//
//
//=================================================================

#include "precomp.h"

#include "ShareToDir.h"

// Property set declaration
//=========================

CShareToDir MyShareToDir(PROPSET_NAME_SHARETODIR, IDS_CimWin32Namespace);

/*****************************************************************************
*
*  FUNCTION    : CShareToDir::CShareToDir
*
*  DESCRIPTION : Constructor
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Registers property set with framework
*
*****************************************************************************/

CShareToDir::CShareToDir(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
*
*  FUNCTION    : CShareToDir::~CShareToDir
*
*  DESCRIPTION : Destructor
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Deregisters property set from framework
*
*****************************************************************************/

CShareToDir::~CShareToDir()
{
}

/*****************************************************************************
*
*  FUNCTION    : CShareToDir::GetObject
*
*  DESCRIPTION : Assigns values to property set according to key value
*                already set by framework
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : HRESULT
*
*  COMMENTS    :
*
*****************************************************************************/

HRESULT CShareToDir::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    CHString sPath, sName, sPath2, sPath3, sPath4;
    CInstancePtr pShare;
    CInstancePtr pDirInst;
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Get the two paths
    pInstance->GetCHString(L"SharedElement", sPath);
    pInstance->GetCHString(L"Share", sName);

    // Note that since directory is a property of share, I get the share, path-ify the path, and do
    // the compare.
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(sName, &pShare, pInstance->GetMethodContext())))
    {
        pShare->GetCHString(IDS_Path, sPath2);
        
        EscapeBackslashes(sPath2, sPath3);
        sPath4.Format(L"Win32_Directory.Name=\"%s\"", (LPCWSTR)sPath3);
        
        // Why get the file system?  Because asking for it
        // forces us to hit the disk.  Why would we want to
        // do that?  Because if one shared a cd drive, a GetObject
        // on the cd drive's root directory would work
        // even if a cd were not in the drive, if we only ask
        // for the key properties (since we wouldn't hit the
        // disk, since we weren't asking for the file system).
        CHStringArray csaProperties;
        csaProperties.Add(IDS___Path);
        csaProperties.Add(IDS_FSName);

        if(SUCCEEDED(hr = CWbemProviderGlue::GetInstancePropertiesByPath(
            sPath4, 
            &pDirInst, 
            pInstance->GetMethodContext(), 
            csaProperties)))
        {
            hr = WBEM_S_NO_ERROR;
        }
    }

    return hr;
}

/*****************************************************************************
*
*  FUNCTION    : CShareToDir::EnumerateInstances
*
*  DESCRIPTION : Creates instance of property set for cd rom
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : HRESULT
*
*  COMMENTS    :
*
*****************************************************************************/

HRESULT CShareToDir::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_FAILED;

    TRefPointerCollection<CInstance>	elementList;

    CInstancePtr pElement;
    CInstancePtr pDirInst;

    REFPTRCOLLECTION_POSITION	pos;

    // Get all the shares. 
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"Select Name, Path from Win32_Share Where type = 0 or type = 2147483648",
        &elementList, pMethodContext, IDS_CimWin32Namespace)))
    {
        if ( elementList.BeginEnum( pos ) )
        {

            CHString sPath, sPath2, sPath3, sTemp1;

            for (pElement.Attach(elementList.GetNext( pos ) ) ;
                   SUCCEEDED(hr) && ( pElement != NULL ) ;
                   pElement.Attach(elementList.GetNext( pos ) ) )

            {
                pElement->GetCHString(IDS_Path, sPath);

                EscapeBackslashes(sPath, sPath2);
                sPath3.Format(L"Win32_Directory.Name=\"%s\"", (LPCWSTR)sPath2);

                // Why get the file system?  Because asking for it
                // forces us to hit the disk.  Why would we want to
                // do that?  Because if one shared a cd drive, a GetObject
                // on the cd drive's root directory would work
                // even if a cd were not in the drive, if we only ask
                // for the key properties (since we wouldn't hit the
                // disk, since we weren't asking for the file system).
                CInstancePtr pDirInst;
                CHStringArray csaProperties;
                csaProperties.Add(IDS___Path);
                csaProperties.Add(IDS_FSName);

                if(SUCCEEDED(CWbemProviderGlue::GetInstancePropertiesByPath(
                    sPath3, 
                    &pDirInst, 
                    pMethodContext, 
                    csaProperties)))
                {
                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                    if (pInstance)
                    {
                        // Path-ify the path from win32_share
                        if(pDirInst->GetCHString(IDS___Path, sTemp1))
                        {
                            pInstance->SetCHString(L"SharedElement", sTemp1);
                            if(GetLocalInstancePath(pElement, sTemp1))
                            {
                                pInstance->SetCHString(L"Share", sTemp1);
                                hr = pInstance->Commit();
                            }
                        }
                    }
                }
            }	// IF GetNext Computer System
            elementList.EndEnum();
        }	// IF BeginEnum
    }	// IF GetInstancesByQuery
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\shortcutfile.cpp ===
//=================================================================
//
// CIMDataFile.CPP -- CIMDataFile property set provider
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"

#include "ShortcutFile.h"
#include <comdef.h>
#include <process.h>  // Note: NOT the one in the current directory!

#include <exdisp.h>
#include <shlobj.h>

#include "sid.h"
#include "ImpLogonUser.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"


// Property set declaration
//=========================

CShortcutFile MyCShortcutFile(PROPSET_NAME_WIN32SHORTCUTFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::CShortcutFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CShortcutFile::CShortcutFile(LPCWSTR a_setName, LPCWSTR a_pszNamespace )
    : CCIMDataFile( a_setName, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::~CShortcutFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CShortcutFile::~CShortcutFile()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::IsOneOfMe
 *
 *  DESCRIPTION : The guts of this class, actually.  IsOneOfMe is inherrited
 *                from CIM_LogicalFile.  That class returns files or
 *                directories where this one should only return directories,
 *                in response to queries, getobject commands, etc.  It is
 *                overridden here to return TRUE only if the file (the
 *                information for which is contained in the function arguement
 *                pstFindData) is of type directory.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/


BOOL CShortcutFile::IsOneOfMe(LPWIN32_FIND_DATAW a_pstFindData,
                             LPCWSTR a_wstrFullPathName )
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    BOOL	t_fRet = FALSE ;

    if( a_wstrFullPathName != NULL )
    {
        WCHAR t_wstrExt[ _MAX_EXT ] ;

        ZeroMemory( t_wstrExt, sizeof( t_wstrExt ) ) ;

        _wsplitpath( a_wstrFullPathName, NULL, NULL, NULL, t_wstrExt ) ;

		if( _wcsicmp( t_wstrExt, L".LNK" ) == 0 )
        {
            // it has the right extension, but can we get lnk data from it?
            if( ConfirmLinkFile( CHString(a_wstrFullPathName) ) )
            {
                t_fRet = TRUE ;
            }
        }
    }
    return t_fRet ;
}


/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::GetExtendedProperties
 *
 *  DESCRIPTION : Sets properties unique to this provider (not common to all
 *                CIM_LogicalFile derived classes).
 *
 *  INPUTS      : CInstance pointer and flags
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
 void CShortcutFile::GetExtendedProperties(CInstance* a_pInst,
                                          long a_lFlags )
{
    if( a_pInst == NULL )
	{
		return;
	}

    CHString t_chstrShortcutPathName;
	// Examine lFlags to determine if any of the shortcut file related properties
	// are required.  In NONE of them are, don't proceed further.
	if( a_lFlags & PROP_TARGET ) // DEVNOTE:  add || statements to this test as additional ShortcutFile properties are added to this class
	{
		a_pInst->GetCHString( IDS_Name, t_chstrShortcutPathName ) ;

		if( !t_chstrShortcutPathName.IsEmpty() )
		{
			// If the extension isn't .LNK, don't even bother.  This check is worthwhile since
			// this GetExtendedProperties WILL get called for every instance of a CIM_DataFile
			// at this level of CIM derivation or higher.
			 WCHAR t_wstrExt[ _MAX_EXT ] ;

			 ZeroMemory( t_wstrExt, sizeof( t_wstrExt ) ) ;
			_wsplitpath( (LPCWSTR)t_chstrShortcutPathName, NULL, NULL, NULL, t_wstrExt ) ;
			if( _wcsicmp( t_wstrExt, L".LNK" ) == 0 )
			{
			    CHString chstrTargetPathName;
                if(SUCCEEDED(m_csh.RunJob(t_chstrShortcutPathName, chstrTargetPathName, a_lFlags)))
                {
                    if(a_lFlags & PROP_TARGET)
                    {
                        if(!chstrTargetPathName.IsEmpty())
						{
                            a_pInst->SetCHString(IDS_Target, chstrTargetPathName ) ;
						}
                    }
                }
			} // had a LNK extension
		}   // chstrLinkFileName not empty
	} // needed one or more shortcut file related properties
}




/*****************************************************************************
 *
 *  FUNCTION    : CShortcutFile::ConfirmLinkFile
 *
 *  DESCRIPTION : Tries to access lnk file data to determine if really a link file.
 *
 *  INPUTS      : CInstance pointer and flags
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
BOOL CShortcutFile::ConfirmLinkFile(CHString &a_chstrFullPathName )
{
    // This is godawful, but have to try to access the link data to really
    // know if we have a link file or not.

	BOOL			t_fRet	= FALSE ;

	// Only continue if it is a link file...
	if( !a_chstrFullPathName.IsEmpty() )
	{
		CHString chstrTargetPathName;
        if(SUCCEEDED(m_csh.RunJob(a_chstrFullPathName, chstrTargetPathName, 0L)))
        {
            t_fRet = TRUE;
        }
	}   // a_chstrFullPathName not empty

	return t_fRet;
}


// This enumerateinstances is essentially the parent class's EnumDrives function (normally called
// by the parent's EnumerateInstances function), with one important difference: we specify an LNK
// extension to optimize our search.  This version also differs from the parent's in that it does
// not support a pszPath parameter.
HRESULT CShortcutFile::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    TCHAR tstrDrive[4];
    int x;
    DWORD dwDrives;
    TCHAR tstrFSName[_MAX_PATH];
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bRoot = false;


    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // Walk all the logical drives
    dwDrives = GetLogicalDrives();
    for (x=0; (x < 32) && SUCCEEDED(hr); x++)
    {
        // If the bit is set, the drive letter is active
        if (dwDrives & (1<<x))
        {
            tstrDrive[0] = x + _T('A');
            tstrDrive[1] = _T(':');
            tstrDrive[2] = _T('\\');
            tstrDrive[3] = _T('\0');

            // Only local drives
            if (IsValidDrive(tstrDrive))
            {
                BOOL bRet;
                try
                {
                    bRet = GetVolumeInformation(tstrDrive, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                }
                catch ( ... )
                {
                    bRet = FALSE;
                }

                if (bRet)
                {
                   tstrDrive[2] = '\0';
                    // If we were asked for a specific path, then we don't want to recurse, else
                    // start from the root.
#ifdef NTONLY
				    {
						bstr_t bstrDrive(tstrDrive);
                        bstr_t bstrName(tstrFSName);
                        {
                            CNTEnumParm p(pMethodContext, bstrDrive, L"", L"*", L"lnk", true, bstrName, PROP_ALL_SPECIAL, true, NULL);
					        hr = EnumDirsNT(p);
                        }
				    }
#endif
                }
            }
        }
    }

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\shortcutfile.h ===
//=================================================================
//
// ShortcutFile.h -- Win32_ShortcutFile property set provider
//
//  Copyright (c) 1998-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

// Property set identification
//============================
#ifndef _SHORTCUTFILE_H_
#define _SHORTCUTFILE_H_

#define  PROPSET_NAME_WIN32SHORTCUTFILE L"Win32_ShortcutFile"

#include "ShortcutHelper.h"

class CShortcutFile : public CCIMDataFile
{
	private:
        CShortcutHelper m_csh;

	protected:

        // Overridable function inherrited from CImplement_LogicalFile
        virtual BOOL IsOneOfMe( LPWIN32_FIND_DATAW a_pstFindData,
                                LPCWSTR a_wstrFullPathName ) ;

        // Overridable function inherrited from CProvider
        virtual void GetExtendedProperties( CInstance *a_pInst, long a_lFlags = 0L ) ;

        BOOL ConfirmLinkFile( CHString &a_chstrFullPathName ) ;
   
	public:

        // Constructor/destructor
        //=======================

        CShortcutFile( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CShortcutFile() ; 
       
       virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, 
                                           long lFlags = 0L);   
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\shortcuthelper.cpp ===
//=================================================================
//
// ShortcutHelper.h -- CIMDataFile property set provider
//
// Copyright (c) 1999-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"
#include "ShortcutFile.h"

#include <comdef.h>
#include <process.h>  // Note: NOT the one in the current directory!

#include <exdisp.h>
#include <shlobj.h>

#include <scopeguard.h>

#include <Sid.h>
#include <AccessEntry.h>			// CAccessEntry class
#include <AccessEntryList.h>
#include <DACL.h>					// CDACL class
#include <SACL.h>
#include <securitydescriptor.h>
#include <SecureKernelObj.h>

#include <ctoken.h>
#include <cominit.h>

#include "ShortcutHelper.h"

CShortcutHelper::CShortcutHelper()
 : m_hTerminateEvt(NULL),
   m_hRunJobEvt(NULL),
   m_hJobDoneEvt(NULL),
   m_dwReqProps(0L)
{
    m_hTerminateEvt = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hRunJobEvt    = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hJobDoneEvt   = ::CreateEvent(NULL, FALSE, FALSE, NULL);
}


CShortcutHelper::~CShortcutHelper()
{
    StopHelperThread();

    ::CloseHandle(m_hTerminateEvt);
    ::CloseHandle(m_hRunJobEvt);
    ::CloseHandle(m_hJobDoneEvt);
}

HRESULT CShortcutHelper::StartHelperThread()
{
	HRESULT hResult = WBEM_E_FAILED ;

	//
	// get process credentials
	// and create thread with process credentials
	// so I can impersonate inside by calling SetThreadToken
	//

	if ( SetThreadToken ( NULL, NULL ) )
	{
		unsigned int uThreadID ;

		m_hThread = (void*)_beginthreadex	(	(void*)NULL,
												(unsigned)0,
												(unsigned (__stdcall*)(void*))GetShortcutFileInfoW,
												(void*)this,
												(unsigned)0,
												&uThreadID 
											) ;

		if ( INVALID_HANDLE_VALUE == static_cast < HANDLE > ( m_hThread ) )
		{
			hResult = HRESULT_FROM_WIN32 ( ::GetLastError () ) ;
		}

		if ( ! SetThreadToken ( NULL, m_hThreadToken ) )
		{
			if ( INVALID_HANDLE_VALUE != static_cast < HANDLE > ( m_hThread ) )
			{
				//
				// must stop worker thread
				//

				StopHelperThread () ;
			}

			throw CFramework_Exception( L"CoImpersonateClient failed", ::GetLastError () ) ;
		}
	}
	else
	{
		hResult = HRESULT_FROM_WIN32 ( ::GetLastError () ) ;
	}

	return hResult ;
}

void CShortcutHelper::StopHelperThread()
{
    // Tell the thread to go away.
    SetEvent(m_hTerminateEvt);

	if ( INVALID_HANDLE_VALUE != static_cast < HANDLE > ( m_hThread ) )
	{
		::WaitForSingleObject ( m_hThread, INFINITE ) ;
	}
}

HRESULT CShortcutHelper::RunJob(CHString &chstrFileName, CHString &chstrTargetPathName, DWORD dwReqProps)
{
    HRESULT hr = E_FAIL;

    // Need to synchronize access to member variables by running just
    // one job at a time...
    m_cs.Enter();
	ON_BLOCK_EXIT_OBJ ( m_cs, CCritSec::Leave ) ;

	// Initialize the variables the thread uses for the job...
	m_chstrLinkFileName = chstrFileName;
	m_dwReqProps = dwReqProps;

	//
	// initialize ThreadToken if we can
	//
	if ( FALSE == ::OpenThreadToken	(
										::GetCurrentThread (), 
										TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
										FALSE,
										&m_hThreadToken
									)
		)
	{
		return HRESULT_FROM_WIN32 ( ::GetLastError () ) ;
	}

    HANDLE t_hHandles[2];
    t_hHandles[0] = m_hJobDoneEvt;

    DWORD dwWaitResult = WAIT_OBJECT_0 + 1;
	do
	{
		if ( WAIT_OBJECT_0 + 1 == dwWaitResult )
		{
			//
			// helper thread eventually time-outed or 
			// this is the first time to be started
			//

			if ( INVALID_HANDLE_VALUE == static_cast < HANDLE > ( m_hThread ) || WAIT_OBJECT_0 == ::WaitForSingleObject ( m_hThread, 0 ) )
			{
				HRESULT t_hResult = S_OK ;
				if ( FAILED ( t_hResult = StartHelperThread () ) )
				{
					return t_hResult ;
				}
			}

			//
			// refresh handle to wait for
			//
			t_hHandles[1] = m_hThread;

			//
			// reset wait condition state
			//
			dwWaitResult = WAIT_TIMEOUT ;

			// Tell the helper we are ready to run a job...
			::SetEvent(m_hRunJobEvt);
		}
		else if ( WAIT_OBJECT_0 == ( dwWaitResult = ::WaitForMultipleObjects ( 2, t_hHandles, FALSE, MAX_HELPER_WAIT_TIME ) ) )
		{
			hr = m_hrJobResult;
			chstrTargetPathName = m_chstrTargetPathName;

			break ;
		}
		else if ( WAIT_OBJECT_0 + 1 != dwWaitResult )
		{
			//
			// problem with any of handles or timeout ?
			//
			break ;
		}
	}
	while ( TRUE ) ;

    return hr;
}

unsigned int __stdcall GetShortcutFileInfoW( void* a_lParam )
{
    CShortcutHelper *t_this_ti = (CShortcutHelper*) a_lParam;
    HRESULT t_hResult = E_FAIL ;
 
	if ( NULL != t_this_ti )
	{   
		t_hResult = ::CoInitialize(NULL) ;
		if( SUCCEEDED( t_hResult ) )
		{
			try
			{
				// The thread is ready to work.  Wait for a job, or for termination signal...
				HANDLE t_hHandles[2];
				t_hHandles[0] = t_this_ti->m_hRunJobEvt;
				t_hHandles[1] = t_this_ti->m_hTerminateEvt;

				while(::WaitForMultipleObjects(2, t_hHandles, FALSE, MAX_HELPER_WAIT_TIME) == WAIT_OBJECT_0)
				{
					if ( !t_this_ti->m_chstrLinkFileName.IsEmpty() )
					{
						// We have a job, so run it...
						WIN32_FIND_DATAW	t_wfdw ;
						WCHAR				t_wstrGotPath[ _MAX_PATH * sizeof ( WCHAR ) ] ;
						IShellLinkWPtr      t_pslw;

						ZeroMemory(t_wstrGotPath,sizeof(t_wstrGotPath));

						t_hResult = ::CoCreateInstance(CLSID_ShellLink,
													NULL,
													CLSCTX_INPROC_SERVER,
													IID_IShellLinkW,
													(void**)&t_pslw ) ;

						if( SUCCEEDED( t_hResult ) )
						{
							IPersistFilePtr t_ppf;

							// Get a pointer to the IPersistFile interface.
							t_hResult = t_pslw->QueryInterface( IID_IPersistFile, (void**)&t_ppf ) ;

							if( SUCCEEDED( t_hResult ) )
							{
								//
								// impersonate if we can
								//
								if ( static_cast < HANDLE > ( t_this_ti->m_hThreadToken ) && INVALID_HANDLE_VALUE != static_cast < HANDLE > ( t_this_ti->m_hThreadToken ) )
								{
									if ( ! ::SetThreadToken ( NULL, t_this_ti->m_hThreadToken ) )
									{
										t_hResult = WBEM_E_ACCESS_DENIED ;
									}
								}
								else
								{
									//
									// unable to get thread token in the caller?
									//
									t_hResult = WBEM_E_FAILED ;
								}

								if ( SUCCEEDED ( t_hResult ) )
								{
									t_hResult = t_ppf->Load( (LPCWSTR)t_this_ti->m_chstrLinkFileName, STGM_READ ) ;
									if(SUCCEEDED( t_hResult ) )
									{
										// Get the path to the link target, if required...
										if( t_this_ti->m_dwReqProps & PROP_TARGET )
										{
											t_hResult = t_pslw->GetPath( t_wstrGotPath, (_MAX_PATH - 1)*sizeof(WCHAR), &t_wfdw, SLGP_UNCPRIORITY);
											if ( t_hResult == NOERROR )
											{
												if(wcslen(t_wstrGotPath) > 0)
												{
													t_this_ti->m_chstrTargetPathName = t_wstrGotPath ;
												}
											}
										}
									}
								}
							}
						}
					}
					else
					{
						t_hResult = E_UNEXPECTED ;
					}

					t_this_ti->m_hrJobResult = t_hResult;
					::SetEvent(t_this_ti->m_hJobDoneEvt);
				}
			}
			catch(...)
			{
			}
			
			::CoUninitialize();
		}
	}

	return(777);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\shortcuthelper.h ===
//=================================================================
//
// ShortcutHelper.h -- CIMDataFile property set provider
//
// Copyright (c) 1999-2002 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#ifndef _SHORTCUTFILE_HELPER_H
#define _SHORTCUTFILE_HELPER_H

#define MAX_HELPER_WAIT_TIME  60000

class CShortcutHelper
{
	public:
        CShortcutHelper();
        ~CShortcutHelper();
        HRESULT RunJob(CHString &chstrFileName, CHString &m_chstrTargetPathName, DWORD dwReqProps);
        
        void StopHelperThread();        

        friend unsigned int __stdcall GetShortcutFileInfoW( void* a_lParam );

	protected:

	private:

        CCritSec m_cs;
        HRESULT m_hrJobResult;
        HANDLE m_hTerminateEvt;
        HANDLE m_hRunJobEvt;
        HANDLE m_hJobDoneEvt;
        CHString m_chstrLinkFileName;
        CHString m_chstrTargetPathName;
        DWORD m_dwReqProps;

		SmartCloseHandle m_hThread ;
		SmartCloseHandle m_hThreadToken ;

        HRESULT StartHelperThread();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\smbassoc.cpp ===
//=================================================================

//

// smbassoc.cpp --

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "SmbAssoc.h"

#include "smbios.h"
#include "smbstruc.h"

BOOL ValidateTagProperty( CInstance *a_pInst, LPCWSTR a_szAltTag, LPCWSTR a_szBaseTag, UINT *a_index ) ;


//==============================================================================
// Processor to cache info association

CWin32AssocProcMemory MyAssocProcMemorySet( PROPSET_NAME_ASSOCPROCMEMORY, IDS_CimWin32Namespace ) ;

//
CWin32AssocProcMemory::CWin32AssocProcMemory( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{

}

//
CWin32AssocProcMemory::~CWin32AssocProcMemory()
{
}

//
HRESULT CWin32AssocProcMemory::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT		t_hResult = WBEM_E_NOT_FOUND ;

	CHString	t_sAntecedent,
				t_sDependent ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;

	// Get the two paths
	a_pInst->GetCHString( IDS_Antecedent, t_sAntecedent ) ;
	a_pInst->GetCHString( IDS_Dependent,  t_sDependent  ) ;

	if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sAntecedent, &t_pAntecedent, a_pInst->GetMethodContext() ) ) )
	{
		if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sDependent, &t_pDependent, a_pInst->GetMethodContext() ) ) )
		{
			t_hResult = WBEM_S_NO_ERROR ;
		}
	}

	return t_hResult ;
}

//
HRESULT CWin32AssocProcMemory::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT t_hResult = WBEM_E_NOT_FOUND ;

	CHString	t_sAntecedent,
				t_sDependent ;

	TRefPointerCollection<CInstance> t_Antecedent ;
	REFPTRCOLLECTION_POSITION t_pos ;

	DWORD	t_instanceCount = 0 ;
    CSMBios	t_smbios ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;
	CInstancePtr t_pInst;

	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_CacheMemory",
													&t_Antecedent,
													NULL,
													a_pMethodContext ) ;
	if ( SUCCEEDED( t_hResult ) && t_smbios.Init() )
	{
		int			t_cpuid,
                    t_cacheid = 0 ;
        PCACHEINFO  t_pci ;

        // I would have liked to assume this was always true on NT, but the
        // BIOS might actually report 2 CPUs on 9x, even though only one is
        // used.
        BOOL        bSingleCPU = t_smbios.GetNthStruct(4, 1) == NULL;

    	// get smbios struct and wbem instance simultaneously
		if ( t_Antecedent.BeginEnum( t_pos ) )
		{
            for (t_pAntecedent.Attach(t_Antecedent.GetNext( t_pos ));
                 SUCCEEDED( t_hResult ) &&
                 (t_pci = (PCACHEINFO) t_smbios.GetNthStruct( 7, t_cacheid++ )) &&
                 (t_pAntecedent != NULL);
                 t_pAntecedent.Attach(t_Antecedent.GetNext( t_pos )))
			{
                PSTLIST	        pstl = t_smbios.GetStructList(4);

				for ( t_cpuid = 0; SUCCEEDED( t_hResult ) && pstl; t_cpuid++ )
				{
            		PPROCESSORINFO t_ppi  = (PPROCESSORINFO) pstl->pshf;

                    // If we only have a single CPU, assume all cache instances
                    // belong to the single CPU.
                    // Matching cache handles are the binding check.  Cache handles are
					// in ver 2.1 and better.
					if ( bSingleCPU || (t_smbios.GetVersion() >= 0x00020001 &&
							(t_pci->Handle == t_ppi->L1_Cache_Handle ||
							t_pci->Handle == t_ppi->L2_Cache_Handle ||
							t_pci->Handle == t_ppi->L3_Cache_Handle)))
					{
						t_sDependent.Format( L"\\\\%s\\%s:Win32_Processor.DeviceID=\"CPU%d\"",
								GetLocalComputerName(), IDS_CimWin32Namespace, t_cpuid ) ;

						if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceKeysByPath( t_sDependent, &t_pDependent, a_pMethodContext ) ) )
						{
							GetLocalInstancePath( t_pAntecedent, t_sAntecedent ) ;

                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if (t_pInst != NULL)
							{
								t_pInst->SetCHString( IDS_Antecedent, t_sAntecedent ) ;
								t_pInst->SetCHString( IDS_Dependent,  t_sDependent  ) ;

								t_instanceCount++ ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
							{
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}
					pstl = pstl->next;
				}
			}

			t_Antecedent.EndEnum() ;
		}
	}

	if ( SUCCEEDED( t_hResult ) && t_instanceCount < 1 )
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}


//==============================================================================
// Associate physical memory to logical memory device

CWin32MemoryDeviceLocation MyMemoryDeviceLocationSet( PROPSET_NAME_MEMORYDEVICELOCATION, IDS_CimWin32Namespace ) ;

//
CWin32MemoryDeviceLocation::CWin32MemoryDeviceLocation( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{

}

//
CWin32MemoryDeviceLocation::~CWin32MemoryDeviceLocation()
{
}

//
HRESULT CWin32MemoryDeviceLocation::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;

	UINT				t_AntecedentIndex,
						t_DependentIndex ;
	CHString			t_sAntecedent,
						t_sDependent ;

    CSMBios				t_smbios;
	PMEMDEVICE			t_pmd ;
	PMEMDEVICEMAPADDR	t_pmdma ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;

	// Get the two paths
	a_pInst->GetCHString( IDS_Antecedent, t_sAntecedent ) ;
	a_pInst->GetCHString( IDS_Dependent,  t_sDependent  ) ;

    // Bug 161318: invalid to have exact same
    // antecedent and dependent (association with
    // equivalent endpoints.
    if(t_sAntecedent.CompareNoCase(t_sDependent) != 0)
    {
	    if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sAntecedent, &t_pAntecedent, a_pInst->GetMethodContext() ) ) )
	    {
		    if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sDependent, &t_pDependent, a_pInst->GetMethodContext() ) ) )
		    {
			    if ( ValidateTagProperty( t_pAntecedent, L"Tag", L"Physical Memory", &t_AntecedentIndex ) )
			    {
				    if ( t_smbios.Init() )
				    {
					    t_pmd = (PMEMDEVICE) t_smbios.GetNthStruct( 17, t_AntecedentIndex ) ;

					    if ( t_pmd && ValidateTagProperty(	t_pDependent,
														    L"DeviceID",
														    L"Memory Device",
														    &t_DependentIndex ) )
					    {
						    t_pmdma = (PMEMDEVICEMAPADDR) t_smbios.GetNthStruct( 20, t_DependentIndex ) ;

						    if ( t_pmdma && ( t_pmd->Handle == t_pmdma->Memory_Device_Handle ) )
						    {
							    t_hResult = WBEM_S_NO_ERROR ;
						    }
					    }
				    }
				    else
				    {
					    t_hResult = t_smbios.GetWbemResult() ;
				    }
			    }
		    }
	    }
    }
	return t_hResult ;
}

//
HRESULT CWin32MemoryDeviceLocation::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;

	UINT		t_AntecedentIndex,
				t_DependentIndex ;
	CHString	t_AntecedentPath,
				t_DependentPath ;


	// Perform queries
	//================
	TRefPointerCollection<CInstance> t_antecedents ;
	TRefPointerCollection<CInstance> t_dependents ;

	REFPTRCOLLECTION_POSITION t_posAntecedent ;
	REFPTRCOLLECTION_POSITION t_posDependent ;

    CSMBios	t_smbios ;
	PMEMDEVICE t_pmd ;
	PMEMDEVICEMAPADDR t_pmdma ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;
	CInstancePtr t_pInst;

	// grab all of both items that could be endpoints
	t_hResult = CWbemProviderGlue::GetAllInstances(	L"Win32_PhysicalMemory",
													&t_antecedents,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED( t_hResult ) )
	{
		return t_hResult ;
	}

	t_hResult = CWbemProviderGlue::GetAllInstances(	L"Win32_MemoryDevice",
													&t_dependents,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED( t_hResult ) )
	{
		return t_hResult ;
	}

	if ( !t_smbios.Init() )
	{
		return t_smbios.GetWbemResult() ;
	}

	if ( t_antecedents.BeginEnum( t_posAntecedent ) )
	{
        for (t_pAntecedent.Attach(t_antecedents.GetNext( t_posAntecedent ) );
             SUCCEEDED(t_hResult) && (t_pAntecedent != NULL);
             t_pAntecedent.Attach(t_antecedents.GetNext( t_posAntecedent ) ) )
		{
			// Extract element's binding property value
			//=========================================

			if ( ValidateTagProperty( t_pAntecedent, L"Tag", L"Physical Memory", &t_AntecedentIndex ) )
			{
				t_pmd = (PMEMDEVICE) t_smbios.GetNthStruct( 17, t_AntecedentIndex ) ;
			}
			else
			{
				t_pmd = NULL ;
			}
			// Associate w/all settings with matching props
			//=============================================
			if ( t_pmd && t_dependents.BeginEnum( t_posDependent ) )
			{
                for (t_pDependent.Attach(t_dependents.GetNext( t_posDependent ) );
                     SUCCEEDED (t_hResult) && (t_pDependent != NULL);
                     t_pDependent.Attach(t_dependents.GetNext( t_posDependent ) ))
				{
					if ( ValidateTagProperty(	t_pDependent,
												L"DeviceID",
												L"Memory Device",
												&t_DependentIndex ) )
					{
						t_pmdma = (PMEMDEVICEMAPADDR) t_smbios.GetNthStruct( 20, t_DependentIndex ) ;
					}
					else
					{
						t_pmdma = NULL;
					}

					if ( t_pmdma && ( t_pmd->Handle == t_pmdma->Memory_Device_Handle ) )
					{
						if ( GetLocalInstancePath( t_pAntecedent,  t_AntecedentPath ) &&
							 GetLocalInstancePath( t_pDependent, t_DependentPath ) )
						{
							// we got all the pieces - put them together...
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if (t_pInst != NULL)
							{
								t_pInst->SetCHString( IDS_Antecedent, t_AntecedentPath ) ;
								t_pInst->SetCHString( IDS_Dependent,  t_DependentPath ) ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
						}
					} // if variants equal

				} // while pDependent = dependents.GetNext

				t_dependents.EndEnum() ;
			} // if	dependents.BeginEnum

		} // while anty get next

		t_antecedents.EndEnum() ;
	} // if (antecedents.BeginEnum(

	return t_hResult ;
}

//==============================================================================
// Associate physical memory array to a logical memory array

CWin32MemoryArrayLocation MyMemoryArrayLocationSet( PROPSET_NAME_MEMORYARRAYLOCATION, IDS_CimWin32Namespace ) ;

//
CWin32MemoryArrayLocation::CWin32MemoryArrayLocation( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{

}

//
CWin32MemoryArrayLocation::~CWin32MemoryArrayLocation()
{
}

//
HRESULT CWin32MemoryArrayLocation::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;

	UINT				t_AntecedentIndex,
						t_DependentIndex ;
	CHString			t_sAntecedent,
						t_sDependent ;
	CSMBios				t_smbios;
	PPHYSMEMARRAY		t_ppma ;
	PMEMARRAYMAPADDR	t_pmama ;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;

	// Get the two paths
	a_pInst->GetCHString( IDS_Antecedent, t_sAntecedent ) ;
	a_pInst->GetCHString( IDS_Dependent,  t_sDependent  ) ;

    // Bug 161318: invalid to have exact same
    // antecedent and dependent (association with
    // equivalent endpoints.
    if(t_sAntecedent.CompareNoCase(t_sDependent) != 0)
    {
	    if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sAntecedent, &t_pAntecedent, a_pInst->GetMethodContext() ) ) )
	    {
		    if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sDependent, &t_pDependent, a_pInst->GetMethodContext() ) ) )
		    {
			    if ( ValidateTagProperty( t_pAntecedent, L"Tag", L"Physical Memory Array", &t_AntecedentIndex ) )
			    {
				    if ( t_smbios.Init() )
				    {
					    t_ppma = (PPHYSMEMARRAY) t_smbios.GetNthStruct( 16, t_AntecedentIndex ) ;

					    if ( t_ppma && ValidateTagProperty( t_pDependent,
														    L"DeviceID",
														    L"Memory Array",
														    &t_DependentIndex ) )
					    {
						    t_pmama = (PMEMARRAYMAPADDR) t_smbios.GetNthStruct( 19, t_DependentIndex ) ;

						    if ( t_pmama && ( t_ppma->Handle == t_pmama->Memory_Array_Handle ) )
						    {
							    t_hResult = WBEM_S_NO_ERROR ;
						    }
					    }
				    }
				    else
				    {
					    t_hResult = t_smbios.GetWbemResult() ;
				    }
			    }
		    }
	    }
    }

	return t_hResult ;
}


HRESULT CWin32MemoryArrayLocation::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;

	UINT		t_AntecedentIndex,
				t_DependentIndex;
	CHString	t_AntecedentPath,
				t_DependentPath ;

	// Perform queries
	//================
	TRefPointerCollection<CInstance> t_antecedents ;
	TRefPointerCollection<CInstance> t_dependents ;

	REFPTRCOLLECTION_POSITION t_posAntecedent;
	REFPTRCOLLECTION_POSITION t_posDependent;
    CSMBios				t_smbios;
	PPHYSMEMARRAY		t_ppma;
	PMEMARRAYMAPADDR	t_pmama;

	// guarded resources
	CInstancePtr t_pAntecedent;
	CInstancePtr t_pDependent;
	CInstancePtr t_pInst;

	// grab all of both items that could be endpoints
	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_PhysicalMemoryArray",
													&t_antecedents,
													NULL,
													a_pMethodContext ) ;

	if ( FAILED( t_hResult ) )
	{
		return t_hResult ;
	}

	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_MemoryArray",
													&t_dependents,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED( t_hResult ) )
	{
		return t_hResult ;
	}

	if ( !t_smbios.Init() )
	{
		return t_smbios.GetWbemResult() ;
	}

	if ( t_antecedents.BeginEnum( t_posAntecedent ) )
	{
        for (t_pAntecedent.Attach(t_antecedents.GetNext( t_posAntecedent ) );
             SUCCEEDED( t_hResult ) && (t_pAntecedent != NULL);
             t_pAntecedent.Attach(t_antecedents.GetNext( t_posAntecedent ) ))
		{
			// Extract element's binding property value
			//=========================================

			if ( ValidateTagProperty( t_pAntecedent, L"Tag", L"Physical Memory Array", &t_AntecedentIndex ) )
			{
				t_ppma = (PPHYSMEMARRAY) t_smbios.GetNthStruct( 16, t_AntecedentIndex ) ;
			}
			else
			{
				t_ppma = NULL ;
			}
			// Associate w/all settings with matching props
			//=============================================
			if ( t_ppma && t_dependents.BeginEnum( t_posDependent ) )
			{
                for (t_pDependent.Attach(t_dependents.GetNext( t_posDependent ) ) ;
                     SUCCEEDED( t_hResult ) && (t_pDependent != NULL);
                     t_pDependent.Attach(t_dependents.GetNext( t_posDependent ) ) )
				{
					if ( ValidateTagProperty( t_pDependent, L"DeviceID", L"Memory Array", &t_DependentIndex ) )
					{
						t_pmama = (PMEMARRAYMAPADDR) t_smbios.GetNthStruct( 19, t_DependentIndex ) ;
					}
					else
					{
						t_pmama = NULL ;
					}

					if ( t_pmama && ( t_ppma->Handle == t_pmama->Memory_Array_Handle ) )
					{
						if ( GetLocalInstancePath( t_pAntecedent,  t_AntecedentPath ) &&
							 GetLocalInstancePath( t_pDependent, t_DependentPath ) )
						{
							// we got all the pieces - put them together...
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if ( t_pInst != NULL )
							{
								t_pInst->SetCHString( IDS_Antecedent, t_AntecedentPath ) ;
								t_pInst->SetCHString( IDS_Dependent,  t_DependentPath ) ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
						}
					} // if variants equal

				} // while pDependent = dependents.GetNext

				t_dependents.EndEnum() ;

			} // if	dependents.BeginEnum

		} // while any get next

		t_antecedents.EndEnum() ;

	} // if (antecedents.BeginEnum(


	return t_hResult ;
}

//==============================================================================
// Associate physical memory to a physical memory array

CWin32PhysicalMemoryLocation MyPhysicalMemoryLocationSet( PROPSET_NAME_PHYSICALMEMORYLOCATION, IDS_CimWin32Namespace ) ;

//
CWin32PhysicalMemoryLocation::CWin32PhysicalMemoryLocation( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{}

//
CWin32PhysicalMemoryLocation::~CWin32PhysicalMemoryLocation()
{
}

//
HRESULT CWin32PhysicalMemoryLocation::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;

	UINT				t_GroupIndex,
						t_PartIndex ;
	CHString			t_sGroup,
						t_sPart ;
    CSMBios				t_smbios ;
	PPHYSMEMARRAY		t_ppma ;
	PMEMDEVICE			t_pmd ;

	// guarded resources
	CInstancePtr t_pGroup;
	CInstancePtr t_pPart;

	// Get the two paths
	a_pInst->GetCHString( IDS_GroupComponent, t_sGroup ) ;
	a_pInst->GetCHString( IDS_PartComponent,  t_sPart  ) ;

	if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sGroup, &t_pGroup, a_pInst->GetMethodContext()) ) )
	{
		if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sPart, &t_pPart, a_pInst->GetMethodContext() ) ) )
		{
			if ( ValidateTagProperty( t_pGroup, L"Tag", L"Physical Memory Array", &t_GroupIndex ) )
			{
				if ( t_smbios.Init() )
				{
					t_ppma = (PPHYSMEMARRAY) t_smbios.GetNthStruct( 16, t_GroupIndex ) ;
					if ( t_ppma && ValidateTagProperty( t_pPart, L"Tag", L"Physical Memory", &t_PartIndex ) )
					{
						t_pmd = (PMEMDEVICE) t_smbios.GetNthStruct( 17, t_PartIndex ) ;
						if ( t_pmd && ( t_ppma->Handle == t_pmd->Mem_Array_Handle ) )
						{
							t_hResult = WBEM_S_NO_ERROR ;
						}
					}
				}
				else
				{
					t_hResult = t_smbios.GetWbemResult() ;
				}
			}
		}
	}

	return t_hResult ;
}


HRESULT CWin32PhysicalMemoryLocation::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR ;

	UINT		t_GroupIndex,
				t_PartIndex ;
	CHString	t_GroupPath,
				t_PartPath ;

	// Perform queries
	//================
	TRefPointerCollection<CInstance> t_groups ;
	TRefPointerCollection<CInstance> t_parts ;

	REFPTRCOLLECTION_POSITION t_posGroup ;
	REFPTRCOLLECTION_POSITION t_posPart ;

	CSMBios			t_smbios ;
	PPHYSMEMARRAY	t_ppma ;
	PMEMDEVICE		t_pmd ;

	// guarded resources
	CInstancePtr t_pGroup;
	CInstancePtr t_pPart;
	CInstancePtr t_pInst;

	// grab all of both items that could be endpoints
	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_PhysicalMemoryArray",
													&t_groups,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED ( t_hResult ) )
	{
		return t_hResult ;
	}

	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_PhysicalMemory",
													&t_parts,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED ( t_hResult ) )
	{
		return t_hResult ;
	}

	if ( !t_smbios.Init() )
	{
		return t_smbios.GetWbemResult() ;
	}

	if ( t_groups.BeginEnum( t_posGroup ) )
	{
        for (t_pGroup.Attach(t_groups.GetNext( t_posGroup ) );
             SUCCEEDED( t_hResult ) && (t_pGroup != NULL);
             t_pGroup.Attach(t_groups.GetNext( t_posGroup ) ))
		{
			// Extract element's binding property value
			//=========================================
			if ( ValidateTagProperty( t_pGroup, L"Tag", L"Physical Memory Array", &t_GroupIndex ) )
			{
				t_ppma = (PPHYSMEMARRAY) t_smbios.GetNthStruct( 16, t_GroupIndex ) ;
			}
			else
			{
				t_ppma = NULL ;
			}
			// Associate w/all settings with matching props
			//=============================================
			if ( t_ppma && t_parts.BeginEnum( t_posPart ) )
			{
                for (t_pPart.Attach(t_parts.GetNext( t_posPart ) );
                     SUCCEEDED( t_hResult ) && (t_pPart != NULL);
                     t_pPart.Attach(t_parts.GetNext( t_posPart ) ))
				{
					if ( ValidateTagProperty( t_pPart, L"Tag", L"Physical Memory", &t_PartIndex ) )
					{
						t_pmd = (PMEMDEVICE) t_smbios.GetNthStruct( 17, t_PartIndex ) ;
					}
					else
					{
						t_pmd = NULL ;
					}

					if ( t_pmd && ( t_ppma->Handle == t_pmd->Mem_Array_Handle ) )
					{
						if ( GetLocalInstancePath( t_pGroup, t_GroupPath ) &&
							 GetLocalInstancePath( t_pPart,  t_PartPath ) )
						{
							// we got all the pieces - put them together...
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if ( t_pInst != NULL )
							{
								t_pInst->SetCHString( IDS_GroupComponent, t_GroupPath ) ;
								t_pInst->SetCHString( IDS_PartComponent,  t_PartPath ) ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
						}
					} // if variants equal
				} // while pDependent = dependents.GetNext

				t_parts.EndEnum() ;

			} // if	dependents.BeginEnum

		} // while any get next

		t_groups.EndEnum() ;

	} // if (antecedents.BeginEnum(

	return t_hResult ;
}


//==============================================================================
// Associate logial memory devices to logical memory arrays

CWin32MemoryDeviceArray MyMemoryDeviceArraySet( PROPSET_NAME_MEMDEVICEARRAY, IDS_CimWin32Namespace ) ;

//
CWin32MemoryDeviceArray::CWin32MemoryDeviceArray( LPCWSTR a_setName, LPCWSTR a_pszNamespace )
:Provider( a_setName, a_pszNamespace )
{
}

//
CWin32MemoryDeviceArray::~CWin32MemoryDeviceArray()
{
}

//
HRESULT CWin32MemoryDeviceArray::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	HRESULT				t_hResult = WBEM_E_NOT_FOUND ;

	UINT				t_GroupIndex,
						t_PartIndex ;
	CHString			t_sGroup,
						t_sPart ;

    CSMBios				t_smbios ;
	PMEMARRAYMAPADDR	t_pmama ;
	PMEMDEVICEMAPADDR	t_pmdma ;

	// guarded resources
	CInstancePtr t_pGroup;
	CInstancePtr t_pPart;

	// Get the two paths
	a_pInst->GetCHString( IDS_GroupComponent, t_sGroup ) ;
	a_pInst->GetCHString( IDS_PartComponent,  t_sPart  ) ;

	if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sGroup, &t_pGroup, a_pInst->GetMethodContext()) ) )
	{
		if ( SUCCEEDED( t_hResult = CWbemProviderGlue::GetInstanceByPath( t_sPart, &t_pPart, a_pInst->GetMethodContext() ) ) )
		{
			if ( ValidateTagProperty( t_pGroup, L"DeviceID", L"Memory Array", &t_GroupIndex ) )
			{
				if ( t_smbios.Init() )
				{
					t_pmama = (PMEMARRAYMAPADDR) t_smbios.GetNthStruct( 19, t_GroupIndex ) ;
					if ( t_pmama && ValidateTagProperty( t_pPart, L"DeviceID", L"Memory Device", &t_PartIndex ) )
					{
						t_pmdma = (PMEMDEVICEMAPADDR) t_smbios.GetNthStruct( 20, t_PartIndex ) ;

						if ( t_pmdma && ( t_pmama->Handle == t_pmdma->Mem_Array_Map_Addr_Handle ) )
						{
							t_hResult = WBEM_S_NO_ERROR ;
						}
					}
				}
				else
				{
					t_hResult = t_smbios.GetWbemResult() ;
				}
			}
		}
	}

	return t_hResult ;
}


HRESULT CWin32MemoryDeviceArray::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;

	UINT		t_GroupIndex,
				t_PartIndex ;
	CHString	t_GroupPath,
				t_PartPath ;

	// Perform queries
	//================
	TRefPointerCollection<CInstance> t_groups ;
	TRefPointerCollection<CInstance> t_parts ;

	REFPTRCOLLECTION_POSITION t_posGroup ;
	REFPTRCOLLECTION_POSITION t_posPart ;
    CSMBios				t_smbios;
	PMEMARRAYMAPADDR	t_pmama ;
	PMEMDEVICEMAPADDR	t_pmdma ;

	// guarded resources
	CInstancePtr t_pGroup;
	CInstancePtr t_pPart;
	CInstancePtr t_pInst;

	// grab all of both items that could be endpoints
	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_MemoryArray",
													&t_groups,
													NULL,
													a_pMethodContext ) ;
	if ( FAILED(t_hResult ) )
	{
		return t_hResult ;
	}

	t_hResult = CWbemProviderGlue::GetAllInstances( L"Win32_MemoryDevice",
													&t_parts,
													NULL,
													a_pMethodContext) ;
	if ( FAILED(t_hResult ) )
	{
		return t_hResult ;
	}

	if ( !t_smbios.Init() )
	{
		return t_smbios.GetWbemResult() ;
	}

	if ( t_groups.BeginEnum( t_posGroup ) )
	{
        for (t_pGroup.Attach(t_groups.GetNext( t_posGroup ) );
             SUCCEEDED( t_hResult ) && (t_pGroup != NULL);
             t_pGroup.Attach(t_groups.GetNext( t_posGroup ) ))
		{
			// Extract element's binding property value
			//=========================================

			if ( ValidateTagProperty( t_pGroup, L"DeviceID", L"Memory Array", &t_GroupIndex ) )
			{
				t_pmama = (PMEMARRAYMAPADDR) t_smbios.GetNthStruct( 19, t_GroupIndex ) ;
			}
			else
			{
				t_pmama = NULL ;
			}
			// Associate w/all settings with matching props
			//=============================================
			if ( t_pmama && t_parts.BeginEnum( t_posPart ) )
			{
                for (t_pPart.Attach(t_parts.GetNext( t_posPart ) );
                     SUCCEEDED( t_hResult ) && (t_pPart != NULL);
                     t_pPart.Attach(t_parts.GetNext( t_posPart ) ))
				{
					if ( ValidateTagProperty( t_pPart, L"DeviceID", L"Memory Device", &t_PartIndex ) )
					{
						t_pmdma = (PMEMDEVICEMAPADDR) t_smbios.GetNthStruct( 20, t_PartIndex ) ;
					}
					else
					{
						t_pmdma = NULL ;
					}

					if ( t_pmdma && ( t_pmama->Handle == t_pmdma->Mem_Array_Map_Addr_Handle ) )
					{
						if ( GetLocalInstancePath( t_pGroup, t_GroupPath ) &&
							 GetLocalInstancePath( t_pPart,  t_PartPath ) )
						{
							// we got all the pieces - put them together...
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
							if ( t_pInst != NULL )
							{
								t_pInst->SetCHString( IDS_GroupComponent, t_GroupPath ) ;
								t_pInst->SetCHString( IDS_PartComponent,  t_PartPath ) ;

								t_hResult = t_pInst->Commit(  ) ;
							}
							else
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
						}
					} // if variants equal

				} // while pDependent = dependents.GetNext

				t_parts.EndEnum() ;

			} // if	dependents.BeginEnum

		} // while anty get next

		t_groups.EndEnum() ;

	} // if (antecedents.BeginEnum(

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\smbios.h ===
//=================================================================

//

// SMBIOS.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================


#ifndef _SMBIOS_H_
#define _SMBIOS_H_

#pragma pack(push,1)

// Entry point structure for SMBIOS
typedef struct tagSMB_EPS
{
	char	anchor[4];	
	BYTE	checksum;
	BYTE	length;
	BYTE	version_major;
	BYTE	version_minor;
	USHORT	max_struct_size;
	BYTE	revision;
	BYTE	formatted[5];
	char	ianchor[5];
	BYTE	ieps_checksum;
	USHORT	table_length;
	ULONG	table_addr;
	USHORT	struct_count;
	BYTE	bcd_revision;

} SMB_EPS;

// Entry point structure for DMIBIOS
typedef struct tagDMI_EPS
{
	char	anchor[5];
	BYTE	checksum;
	USHORT	table_length;
	ULONG	table_addr;
	USHORT	struct_count;
	BYTE	bcd_revision;

} DMI_EPS;

//==============================================================================
// 3.1.2 Structure Header Format 

typedef struct _tagSHF
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;

} SHF, *PSHF;


//==============================================================================
// 3.2.1 BIOS Information (Type 0)

typedef struct _tagBIOSINFO
{
	BYTE	Type;							// 0	BIOS Information Indicator
	BYTE	Length;							// Varies, 12h + number of BIOS Characteristics Extension Bytes
	WORD	Handle;
	BYTE	Vendor;
	BYTE	BIOS_Version;
	WORD	BIOS_Starting_Address_Segment;
	BYTE	BIOS_Release_Date;
	BYTE	BIOS_ROM_Size;
	BYTE	BIOS_Characteristics[8];
	BYTE	BIOS_Characteristics_Ext[1];	// usually, one could be more.  see note on length.

} BIOSINFO, *PBIOSINFO;


// 3.2.1.1 BIOS Characteristics 
//QWORD Bit Position	Meaning if Set

#define TYPE0_RESERVED00					0x0000000000000001
#define	TYPE0_RESERVED01					0x0000000000000002
#define UNKNOWN								0x0000000000000004
#define	BIOS_CHARACTERISTICS_NOT_SUPPORTED	0x0000000000000008
#define ISA_SUPPORT							0x0000000000000010
#define	MCA_SUPPORT							0x0000000000000020
#define EISA_SUPPORT						0x0000000000000040
#define	PCI_SUPPORT							0x0000000000000080
#define PC_CARD_SUPPORT						0x0000000000000100
#define	PNP_SUPPORT							0x0000000000000200
#define APM_SUPPORT							0x0000000000000400
#define	BIOS_IS_FLASH_UPGRADEABLE			0x0000000000000800
#define BIOS_SHADOWING						0x0000000000001000
#define	VL_VESA								0x0000000000002000
#define ESCD_SUPPORT						0x0000000000004000
#define	BOOT_FROM_CD						0x0000000000008000
#define SELECTABLE_BOOT						0x0000000000010000
#define	BIOS_ROM_SOCKETED 					0x0000000000020000
#define BOOT_FROM_PC_CARD					0x0000000000040000
#define	EDD_SPEC_SUPPORTED					0x0000000000080000
#define INT_13H_JPN_FLOPPY_NEC_9800_1_2MB	0x0000000000100000
#define	INT_13H_JPN_FLOPPY_TOSHIBA_1_2MB	0x0000000000200000
#define INT_13H_5_25_360KB_FLOPPY			0x0000000000400000
#define	INT_13H_5_25_1_2MB_FLOPPY			0x0000000000800000
#define INT_13H_3_5_720KB_FLOPPY			0x0000000001000000
#define	INT_13H_3_5_2_88MB_FLOPPY			0x0000000002000000
#define INT_5H_PRINT_SCREEN					0x0000000004000000
#define	INT_9H_8042_KEYBOARD				0x0000000008000000
#define INT_14H_SERIAL						0x0000000010000000
#define	INT_17H_PRINTER						0x0000000020000000
#define INT_10H_CGA_MONO_VIDEO				0x0000000040000000
#define	NEC_PC_98							0x0000000080000000
#define BIOS_VENDOR_RESERVED				0x0000ffff00000000
#define	SYSTEM_VENDOR_RESERVED				0xffff000000000000

// 3.2.1.2 BIOS Characteristics Extension Byte 1

#define ACPI_SUPPORT					0x01
#define USB_LEGACY_SUPPORT				0x02
#define AGP_SUPPORT						0x04
#define I2O BOOT_SUPPORT				0x08
#define LS_120_BOOT_SUPPORT				0x10
#define ATAPI_ZIP_DRIVE_BOOT_SUPPORT	0x20
#define IEEE1394_BOOT_SUPPORT			0x40
#define SMART_BATTERY_SUPPORT			0x80


//==============================================================================
// 3.2.2 System Information (Type 1)

typedef struct tagSYSTEMINFO
{
	BYTE	Type; 		// 1	Component ID Information  Indicator
	BYTE	Length;		// 08h or 19h	Length dependent on version supported
	WORD	Handle;
	BYTE	Manufacturer;
	BYTE	Product_Name;
	BYTE	Version;
	BYTE	Serial_Number;
	// Ver 2.1+ beyond here
	BYTE	UUID[16];
	BYTE	Wakeup_Type;

} SYSTEMINFO, *PSYSTEMINFO;

// 3.2.2.1 System - Wake-up Type

#define WU_RESERVED				0x00	
#define WU_OTHER				0x01	
#define WU_UNKNOWN				0x02	
#define WU_APM_TIMER			0x03	
#define WU_MODEM_RING			0x04	
#define WU_LAN_REMOTE 			0x05	
#define WU_POWER_SWITCH			0x06
#define WU_PCI_PME				0x07	



//==============================================================================
// 3.2.3 Base Board Information (Type 2)

typedef struct tagBOARDINFO
{
	BYTE	Type;			// 2	Base Board Information Indicator
	BYTE	Length;			// 08h	
	WORD	Handle;
	BYTE	Manufacturer;
	BYTE	Product;
	BYTE	Version;
	BYTE	Serial_Number;

} BOARDINFO, *PBOARDINFO;



//==============================================================================
// 3.2.4 System Enclosure or Chassis (Type 3)

typedef struct tagENCLOSURE
{
	BYTE 	Type;	// 3	System Enclosure Indicator
	BYTE	Length;	// Varies	09h for v2.0 implementations; 0Dh for v2.1 and later implementations.
	WORD	Handle;
	BYTE	Manufacturer;		// string offset
	BYTE	Chassis_Type;		// byte enum
	BYTE	Version;			// string offset
	BYTE	Serial_Number;		// string offset
	BYTE	Asset_Tag_Number;	// string offset
	// Ver 2.1+
	BYTE	Bootup_State;		// byte enum
	BYTE	Power_Supply_State;	// byte enum
	BYTE	Thermal_State;		// byte enum
	BYTE	Security_Status;	// byte enum
	// Ver 2.3+
	DWORD	OEM_Defined;

} ENCLOSURE, *PENCLOSURE;

// 3.2.4.1 System Enclosure or Chassis Types


#define CT_OTHER					0x01
#define CT_UNKNOWN					0x02
#define CT_DESKTOP					0x03
#define CT_LOW_PROFILE_DESKTOP		0x04
#define CT_PIZZA_BOX				0x05
#define CT_MINI_TOWER				0x06
#define CT_TOWER					0x07
#define CT_PORTABLE					0x08
#define CT_LAPTOP					0x09
#define CT_NOTEBOOK					0x0A
#define CT_HAND_HELD				0x0B
#define CT_DOCKING_STATION			0x0C
#define CT_ALL_IN_ONE				0x0D
#define CT_SUB_NOTEBOOK				0x0E
#define CT_SPACE_SAVING				0x0F
#define CT_LUNCH_BOX				0x10
#define CT_MAIN_SERVER				0x11
#define CT_EXPANSION				0x12
#define CT_SUBCHASSIS				0x13
#define CT_BUS_EXPANSION			0x14
#define CT_PERIPHERAL				0x15
#define CT_RAID						0x16
#define CT_RACK_MOUNT				0x17
#define CT_SEALED_CASE_PC			0x18

#define CT_UPPER					CT_SEALED_CASE_PC
#define CT_LOWER					CT_OTHER

// 3.2.4.1 Bit field indicating if a chasis lock is present
#define CT_LOCK_PRESENT				0x80


// 3.2.4.2 System Enclosure or Chassis States

#define CS_OTHER					0x01
#define CS_UNKNOWN					0x02
#define CS_SAFE						0x03
#define CS_WARNING					0x04
#define CS_CRITICAL					0x05
#define CS_NON_RECOVERABLE			0x06


// 3.2.4.3 System Enclosure or Chassis Security Status

#define CSS_OTHER							0x01
#define CSS_UNKNOWN							0x02
#define CSS_NONE							0x03
#define CSS_EXTERNAL_INTERFACE_LOCKED OUT	0x04
#define CSS_EXTERNAL_INTERFACE_ENABLED		0x05


//==============================================================================
// 3.2.5 Processor  Information (Type 4)

typedef struct tagPROCESSORINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Socket_Designation;		// string offset
	BYTE	Processor_Type;			// byte enum
	BYTE	Processor_Family;		// byte enum
	BYTE	Processor_Manufacturer;	// string offset
	BYTE	Processor_ID[8];		// byte array
	BYTE	Processor_Version;		// string offset
	BYTE	Voltage;				// byte enum and flags
	WORD	External_Clock;
	WORD	Max_Speed;
	WORD	Current_Speed;
	BYTE	Status;					// byte enum and flags
	BYTE	Processor_Upgrade;		// byte enum
	// Ver 2.1+ beyond here
	WORD	L1_Cache_Handle;		//	WORD	Varies	The handle of a Cache Information structure which defines the attributes of the primary (Level 1) cache for this processor.  The value is 0FFFFh if the processor has no L1 cache.
	WORD	L2_Cache_Handle;
	WORD	L3_Cache_Handle;

} PROCESSORINFO, *PPROCESSORINFO;

// 3.2.5.1 Processor Information - Processor Type
#define PT_OTHER					0x01	
#define PT_UNKNOWN					0x02	
#define PT_CENTRAL_PROCESSOR		0x03	
#define PT_MATH_PROCESSOR			0x04	
#define PT_DSP_ PROCESSOR			0x05	
#define PT_VIDEO_PROCESSOR			0x06	


// 3.2.5.2 Processor Information - Processor Family

#define PF_OTHER					0x01	
#define PF_UNKNOWN					0x02	
#define PF_8086						0x03	
#define PF_80286					0x04	
#define PF_INTEL386					0x05	
#define PF_INTEL486					0x06	
#define PF_8087						0x07	
#define PF_80287					0x08	
#define PF_80387					0x09	
#define PF_80487					0x0A	
#define PF_PENTIUM					0x0B	
#define PF_PENTIUM_PRO				0x0C	
#define PF_PENTIUM_II				0x0D	
#define PF_PENTIUM_MMX				0x0E	
#define PF_INTEL_CELERON			0x0F	
#define PF_RESERVED0_PENTIUM		0x10 
#define PF_RESERVED1_PENTIUM		0x11 
#define PF_M1						0x12	
#define PF_RESERVED0_M1				0x13 
#define PF_RESERVED1_M1				0x14 
#define PF_RESERVED2_M1				0x15 
#define PF_RESERVED3_M1				0x16 
#define PF_RESERVED4_M1				0x17 
#define PF_RESERVED5_M1				0x18 
#define PF_K5						0x19	
#define PF_RESERVED0_K5				0x1A 
#define PF_RESERVED1_K5				0x1B 
#define PF_RESERVED2_K5				0x1C 
#define PF_RESERVED3_K5				0x1D 
#define PF_RESERVED4_K5				0x1E 
#define PF_RESERVED5_K5				0x1F 
#define PF_POWER_PC					0x20	
#define PF_POWER_PC_601				0x21	
#define PF_POWER_PC_603				0x22	
#define PF_POWER_PC_603_PLUS		0x23	
#define PF_POWER_PC_604				0x24	
#define PF_ALPHA					0x30	
#define PF_MIPS						0x40	
#define PF_SPARC					0x50	
#define PF_68040					0x60	
#define PF_68XXX					0x61	
#define PF_68000					0x62	
#define PF_68010					0x63	
#define PF_68020					0x64	
#define PF_68030					0x65	
#define PF_HOBBIT					0x70	
#define PF_WEITEK					0x80	
#define PF_PA_RISC					0x90	
#define PF_V30						0xA0	


// 3.2.5.3 Processor ID Field Format

// 3.2.5.4 Processor Information - Voltage

#define V_LEGACY					0x80	// bit 7 legacy field

// if legacy is clear, these bits are defined as:
#define V_RESERVED					0x70	// bits 6 - 4 reserved
#define V_5V						0x01	// bit 0 indicates 5v support
#define V_3_3V						0x02	// bit 1 indicates 3.3v support
#define V_2_9V						0x04	// bit 2 indicates 2.9v support
#define V_RESERVED3					0x08	// bits 6 - 4 reserved

// if legacy is set, the the lower seven bits are the current processor voltage
#define V_VOLTAGE					0x7f	// voltage = ( value & V_VOLTAGE ) / 10;


// Processor Information - Status

#define	S_RESERVED					0x80	// bit 7 reserved
#define	S_SOCKET					0x40	// bit 6 set if socket is populated

#define	S_UNKNOWN					0x00
#define	S_CPU_ENABLED				0x01
#define	S_CPU_DISABLED_BY_USER		0x02
#define	S_CPU_DISABLED_BY_BIOS		0x03
#define	S_CPU_IDLE					0x04
#define S_RESERVED5					0x05
#define S_RESERVED6					0x06
#define	S_OTHER						0x07

// 3.2.5.5 Processor Information - Processor Upgrade

#define PU_OTHER					0x01
#define PU_UNKNOWN					0x02
#define PU_DAUGHTER_BOARD			0x03
#define PU_ZIF SOCKET				0x04
#define PU_REPLACEABLE_PIGGY_BACK	0x05
#define PU_NONE						0x06
#define PU_LIF_SOCKET				0x07
#define PU_SLOT_1					0x08
#define PU_SLOT_2					0x09


//==============================================================================
// 3.2.6 Memory Controller Information (Type 5)

typedef struct tagMEMCONTROLINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Error_Detecting_Method;			// byte enum
	BYTE	Error_Correcting_Capability;	// flags
	BYTE	Supported_Interleave;			// byte enum
	BYTE	Current_Interleave;				// byte enum
	BYTE	Maximum_Memory_Module_Size;		// value
	WORD	Supported_Speeds;				// flags
	WORD	Supported_Memory_Types;			// flags
	BYTE	Memory_Module_Voltage;			// flags
	BYTE	Associated_Memory_Slots;			// value
	WORD	Memory_Module_Cfg_Handles[1];	// word array
	// Ver 2.1+ beyond here
	// todo...
	// Enabled_Error_Correcting_Capabilities byte is here.  Depends on the above array size

} MEMCONTROLINFO, *PMEMCONTROLINFO;


// 3.2.6.1 Memory Controller Error Detecting Method
#define ED_OTHER					0x01
#define ED_UNKNOWN					0x02
#define ED_NONE						0x03
#define ED_8_BIT_PARITY				0x04
#define ED_32_BIT_ECC				0x05
#define ED_64_BIT_ECC				0x06
#define ED_128_BIT_ECC				0x07
#define ED_CRC						0x08


// 3.2.6.2 Memory Controller Error Correcting Capability
#define EC_OTHER					0x01
#define EC_UNKNOWN					0x02
#define EC_NONE						0x04
#define EC_SINGLE_BIT				0x08
#define EC_DOUBLE_BIT				0x10
#define EC_ERROR_SCRUBBING			0x20


//3.2.6.3 Memory Controller Information - Interleave Support
#define IS_OTHER					0x01	
#define IS_UNKNOWN					0x02	
#define IS_ONE_WAY					0x03	
#define IS_TWO_WAY					0x04	
#define IS_FOUR_WAY					0x05	
#define IS_EIGHT_WAY				0x06	
#define IS_SIXTEEN_WAY				0x07	


// 3.2.6.4 Memory Controller Information - Memory Speeds

#define MS_OTHER					0x0001
#define MS_UNKNOWN					0x0002
#define MS_70NS						0x0004
#define MS_60NS						0x0008
#define MS_50NS						0x0010





//==============================================================================
// 3.2.7 Memory Module Information (Type 6) 

typedef struct tagMEMMODULEINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Socket_Designation;
	BYTE	Bank_Connections;
	BYTE	Current_Speed;
	WORD	Current_Memory_Type;
	BYTE	Installed_Size;
	BYTE	Enabled_Size;
	BYTE	Error_Status;

} MEMMODULEINFO, *PMEMMODULEINFO;

//==============================================================================
//	3.2.8 Cache Information (Type 7)

typedef struct tagCACHEINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Socket_Designation;
	WORD	Cache_Configuration;		
	WORD	Maximum_Cache_Size;
	WORD	Installed_Size;
	WORD	Supported_SRAM_Type;
	WORD	Current_SRAM_Type;
	BYTE	Cache_Speed;
	BYTE	Error_Correction_Type;
	BYTE	System_Cache_Type;
	BYTE	Associativity;

} CACHEINFO, *PCACHEINFO;

//==============================================================================
// 3.2.9 Port Connector Information (Type 8)

typedef struct tagPORTCONNECTORINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Int_Reference_Designator;
	BYTE	Int_Connector_Type;
	BYTE	Ext_Reference_Designator;
	BYTE	Ext_Connector_Type;
	BYTE	Port_Type;

} PORTCONNECTORINFO, *PPORTCONNECTORINFO;


//==============================================================================
// 3.2.10 System Slots (Type 9)

typedef struct tagSYSTEMSLOTS
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Slot_Designation;
	BYTE	Slot_Type;
	BYTE	Slot_Data_Bus_Width;
	BYTE	Current_Usage;
	BYTE	Slot_Length;
	WORD	Slot_ID;
	BYTE	Slot_Characteristics1;
	BYTE	Slot_Characteristics2;

} SYSTEMSLOTS, *PSYSTEMSLOTS;

// Slot types
#define ST_OTHER	0x01
#define ST_UNKNOWN	0x02
#define ST_ISA		0x03
#define ST_MCA		0x04
#define ST_EISA		0x05
#define	ST_PCI		0x06
#define ST_PCMCIA	0x07
#define ST_PCI66	0x0e
#define ST_AGP		0x0f
#define ST_AGP2X	0x10
#define ST_AGP4X	0x11

//==============================================================================
// 3.2.12 OEM Strings (Type 11) 
typedef struct tagOEMSTRINGS
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Count;			// byte enum

} OEMSTRINGS, *POEMSTRINGS;


//==============================================================================
// 3.2.13 System Configuration Options (Type 12) 
typedef struct tagSYSCFGOPTIONS
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Count;			// byte enum

} SYSCFGOPTIONS, *PSYSCFGOPTIONS;


//==============================================================================
// 3.2.14 BIOS Language Information (Type 13) 
typedef struct tagBIOSLANGINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Installable_Languages;
	BYTE	Flags;
	BYTE	Reserved[15];
	BYTE	Current_Language;

} BIOSLANGINFO, *PBIOSLANGINFO;

//==============================================================================
// 3.2.17 Physical Memory Array (Type 16)
typedef struct tagPHYSMEMARRAY
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Location;
	BYTE	Use;
	BYTE	Mem_Error_Correction;
	DWORD	Max_Capacity;
	WORD	Mem_Error_Info_Handle;
	WORD	Memory_Devices;

} PHYSMEMARRAY, *PPHYSMEMARRAY;

//==============================================================================
// 3.2.18 Memory Device (Type 17)
typedef struct tagMEMDEVICE
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	WORD	Mem_Array_Handle;
	WORD	Mem_Error_Info_Handle;
	WORD	Total_Width;
	WORD	Data_Width;
	WORD	Size;
	BYTE	Form_Factor;
	BYTE	Device_Set;
	BYTE	Device_Locator;
	BYTE	Bank_Locator;
	BYTE	Memory_Type;
	WORD	Type_Detail;
	// Ver 2.3+
	WORD	Speed;

} MEMDEVICE, *PMEMDEVICE;


//==============================================================================
// 3.2.19 32-bit Memory Error Information (Type 18)
typedef struct tagMEMERRORINFO32
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Error_Type;
	BYTE	Error_Granularity;
	BYTE	Error_Operation;
	DWORD	Vendor_Syndrome;
	DWORD	Mem_Array_Error_Addr;
	DWORD	Device_Error_Addr;
	DWORD	Error_Resolution;

} MEMERRORINFO32, *PMEMERRORINFO32;


//==============================================================================
// 3.2.20 32-bit Memory Array Mapped Address (Type 19)
typedef struct tagMEMARRAYMAPADDR
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	DWORD	Starting_Address;
	DWORD	Ending_Address;
	WORD	Memory_Array_Handle;
	BYTE	Partition_Width;

} MEMARRAYMAPADDR, *PMEMARRAYMAPADDR;


//==============================================================================
// 3.2.21 32-bit Memory Device Mapped Address (Type 20)
typedef struct tagMEMDEVICEMAPADDR
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	DWORD	Starting_Address;
	DWORD	Ending_Address;
	WORD	Memory_Device_Handle;
	WORD	Mem_Array_Map_Addr_Handle;
	BYTE	Partition_Row;
	BYTE	Interleave_Position;
	BYTE	Interleaved_Data_Depth;

} MEMDEVICEMAPADDR, *PMEMDEVICEMAPADDR;


//==============================================================================
// 1.1.22 Built-in Pointing Device (Type 21)
typedef struct tagBUILTINPOINTDEVICE
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	DeviceType;
	BYTE	Interface;
	BYTE	Buttons;

} BUILTINPOINTDEVICE, *PBUILTINPOINTDEVICE;


//==============================================================================
// 1.1.23 Portable Battery (Type 22)
typedef struct tagPORTABLEBATTERY
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Location;
	BYTE	Manufacturer;
	BYTE	Manufacture_Date;
	BYTE	Serial_Number;
	BYTE	Device_Name;
	BYTE	Device_Chemistry;
	WORD	Design_Capacity;
	WORD	Design_Voltage;
	BYTE	SBDS_Version;
	BYTE	Max_Error;
	// Ver. 2.2+
	WORD	SBDS_Serial_Number;
	WORD	SBDS_Manufacture_Date;
	BYTE	SBDS_Device_Chemistry;
	BYTE	Design_Capacity_Mult;
	// Ver 2.3+
	DWORD	OEM_Specific;

} PORTABLEBATTERY, *PPORTABLEBATTERY;



//==============================================================================
// System Reset (Type 23)
typedef struct tagSYSTEMRESET
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Capabilities;
	WORD	ResetCount;
	WORD	ResetLimit;
	WORD	TimerInterval;
	WORD	Timeout;

} SYSTEMRESET, *PSYSTEMRESET;


//==============================================================================
// Hardware Security (Type 24)
typedef struct tagHARDWARESECURITY
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	SecuritySettings;

} HARDWARESECURITY, *PHARDWARESECURITY;


//==============================================================================
// Cooling Device (Types 27)
typedef struct tagCOOLINGDEVICE
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	WORD	TempProbeHandle;
	BYTE	Type_Status;
	BYTE	CoolingUnitGroup;
	DWORD	OEM_Defined;
	WORD	NominalSpeed;

} COOLINGDEVICE, *PCOOLINGDEVICE;


//==============================================================================
// Probe Info (Types 26, 28 and 29)
typedef struct tagPROBEINFO
{
	BYTE	Type;
	BYTE	Length;
	WORD	Handle;
	BYTE	Description;
	BYTE	Location_Status;
	WORD	MaxValue;
	WORD	MinValue;
	WORD	Resolution;
	WORD	Tolerance;
	WORD	Accuracy;
	DWORD	OEM_Defined;

} PROBEINFO, *PPROBEINFO;

//==============================================================================
// Voltage Probe (Type 26)
typedef PROBEINFO VOLTAGEPROBE, *PVOLTAGEPROBE;

//==============================================================================
// Temperature Probe (Type 28)
typedef PROBEINFO TEMPERATUREPROBE, *PTEMPERATUREPROBE;

//==============================================================================
// Electrical Current Probe (Type 29)
typedef PROBEINFO CURRENTPROBE, *PCURRENTPROBE;

#pragma pack(pop)

#endif	// #define _SMBIOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\smbiosprov.cpp ===
//=================================================================

//

// SmbiosProv.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "smbios.h"
#include "smbstruc.h"
#include "smbiosprov.h"
#include "smbtocim.h"
#include "resource.h"

#include <helper.h>

// these are self contained in this source file
#define SMB_SYSTEMPRODUCT
#define SMB_BASEBOARD
#define SMB_SYSTEMENCLOSURE
#define SMB_CACHEMEMORY
#define SMB_PORTCONNECTOR
#define SMB_SYSTEMSLOT
#define SMB_PHYSICALMEMORY
#define SMB_PHYSMEMARRAY
#define SMB_PORTABLEBATTERY
#define SMB_PROBES
#define SMB_OEMBUCKET
#define SMB_MEMORYDEVICE
#define SMB_MEMORYARRAY
#define SMB_COOLINGDEVICE
#define SMB_ONBOARDDEVICE

//  mm/dd/yyyy
void FormatWBEMDate(WBEMTime &wbemdate, LPWSTR datestr)
{
	WCHAR	timestr[] = L"yyyymmdd000000.000000+000";
	int		len		= lstrlenW(datestr);

	if (len > 7)
	{
		if (len > 8)	// four digit year
		{
			timestr[ 0 ] = datestr[ 6 ];
			timestr[ 1 ] = datestr[ 7 ];
			timestr[ 2 ] = datestr[ 8 ];
			timestr[ 3 ] = datestr[ 9 ];
		}
		else			// two digit year
		{
			timestr[ 0 ] = '1';
			timestr[ 1 ] = '9';
			timestr[ 2 ] = datestr[ 6 ];
			timestr[ 3 ] = datestr[ 7 ];
		}
		timestr[ 4 ] = datestr[ 0 ];
		timestr[ 5 ] = datestr[ 1 ];
		timestr[ 6 ] = datestr[ 3 ];
		timestr[ 7 ] = datestr[ 4 ];
	}

#ifdef _UNICODE
	wbemdate = timestr;
#else
    wbemdate = _bstr_t(timestr);
#endif
}

BOOL ValidateTagProperty(CInstance *pInst, LPCWSTR szAltTag, LPCWSTR szBaseTag, UINT *index)
{
	CHString sTag;
	CHString sBaseTag;

	BOOL	bogus = TRUE;

	if (pInst)
	{
		if (szAltTag)
		{
			pInst->GetCHString(szAltTag, sTag);
		}
		else
		{
			pInst->GetCHString(L"Tag", sTag);
		}

		sTag.TrimRight();
		sTag.MakeUpper();

		sBaseTag = szBaseTag;
		sBaseTag.MakeUpper();

		if (sTag.Find(sBaseTag) == 0)
		{
			int spot, limit;
			TCHAR cTest = '\0';
			UINT tempindex = 0;

			limit = sTag.GetLength();
			spot  = sBaseTag.GetLength();
			cTest = sTag.GetAt(spot++);

			if (cTest == ' ')
			{
				bogus = FALSE;
				while (spot < limit && !bogus)
				{
    				cTest = sTag.GetAt(spot++);
					if (cTest >= '0' && cTest <= '9')
					{
						// Look out for bogus numbers like 01:
                        // If the number is '0' and tempindex is empty and
                        // we're not at the end, it's one of those bogus numbers.
                        if (cTest == '0' && !tempindex && spot != limit)
						{
                            bogus = TRUE;
                        }
						else
                        {
                            tempindex *= 10;
						    tempindex += (UINT) cTest - '0';
                        }
					}
					else
						bogus = TRUE;
				}
				if (!bogus)
				{
					*index = tempindex;
				}
			}
		}
	}

	return !bogus;
}

#ifdef SMB_SYSTEMPRODUCT
CWin32SystemProduct	MySystemProductSet(PROPSET_NAME_SYSTEMPRODUCT, IDS_CimWin32Namespace);

// The register/unregister caches the smbios data.
CWin32SystemProduct::CWin32SystemProduct(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32SystemProduct::~CWin32SystemProduct()
{
}

//
HRESULT CWin32SystemProduct::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
	HRESULT     hResult = WBEM_E_NOT_FOUND;

	CHString    strPathBefore,
                strPathAfter;

    CSMBios		smbios;

    // Get the previous __RELPATH
    GetLocalInstancePath(pInst, strPathBefore);

    if (smbios.Init())
    {
        PSTLIST	pstl = smbios.GetStructList(1);

		if (pstl)
		{
			hResult = LoadPropertyValues(pInst, smbios,
                (PSYSTEMINFO) pstl->pshf);
		}
	}

    // If we were able to get the properties but the new __RELPATH doesn't
    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
         strPathAfter.CompareNoCase(strPathBefore) != 0))
	{
        hResult = WBEM_E_NOT_FOUND;
	}
	return hResult;
}

//
HRESULT CWin32SystemProduct::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
	CSMBios		smbios;

	// guarded resource
	CInstance	*pInst = NULL;

	if (smbios.Init())
	{
        PSTLIST	pstl = smbios.GetStructList(1);

		if (pstl)
		{
			CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PSYSTEMINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32SystemProduct::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PSYSTEMINFO psi)
{
	WCHAR tempstr[MIF_STRING_LENGTH+1];

    CHString sTemp;
    LoadStringW(sTemp, IDR_ComputerSystemProduct);

	pInst->SetCHString(IDS_Caption, sTemp);
	pInst->SetCHString(IDS_Description, sTemp);

	if (smbios.GetStringAtOffset((PSHF) psi, tempstr, psi->Product_Name))
	{
		pInst->SetCharSplat(L"Name", tempstr);
	}
	else
	{
		pInst->SetCharSplat(L"Name", L"");
	}
	if (smbios.GetStringAtOffset((PSHF) psi, tempstr, psi->Version))
	{
    	pInst->SetCharSplat(L"Version", tempstr);
	}
	else
	{
    	pInst->SetCharSplat(L"Version", L"");
	}

	smbios.GetStringAtOffset((PSHF) psi, tempstr, psi->Manufacturer);
    pInst->SetCharSplat(L"Vendor", tempstr);

	smbios.GetStringAtOffset((PSHF) psi, tempstr, psi->Serial_Number);
    pInst->SetCharSplat(L"IdentifyingNumber", tempstr);

	if (smbios.GetVersion() > 0x00020000 && psi->Length >= sizeof(SYSTEMINFO))
	{
		// {8F680850-A584-11d1-BF38-00A0C9062910}
		swprintf(tempstr, L"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
					*(UNALIGNED ULONG*) psi->UUID,
					*(UNALIGNED USHORT*) &psi->UUID[ 4 ],
					*(UNALIGNED USHORT*) &psi->UUID[ 6 ],
					psi->UUID[ 8 ],
					psi->UUID[ 9 ],
					psi->UUID[ 10 ],
					psi->UUID[ 11 ],
					psi->UUID[ 12 ],
					psi->UUID[ 13 ],
					psi->UUID[ 14 ],
					psi->UUID[ 15 ]);

		pInst->SetCharSplat(L"UUID", tempstr);
	}
	else
	{
		// need somethimg to complete the key
	    lstrcpyW(tempstr, L"00000000-0000-0000-0000-000000000000");

		pInst->SetCharSplat(L"UUID", tempstr);
	}

    return WBEM_S_NO_ERROR;
}

#endif // SMB_SMBIOSINFO
//==============================================================================

//==============================================================================
// Base Board Class
//------------------------------------------------------------------------------
#ifdef SMB_BASEBOARD
CWin32BaseBoard	MyBaseBoardSet(PROPSET_NAME_BASEBOARD, IDS_CimWin32Namespace);

//
CWin32BaseBoard::CWin32BaseBoard(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32BaseBoard::~CWin32BaseBoard()
{
}

//
HRESULT CWin32BaseBoard::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
	HRESULT     hResult;
    CHString    strPathBefore,
                strPathAfter;
    CSMBios		smbios;

    // Get the previous __RELPATH
    GetLocalInstancePath(pInst, strPathBefore);

    if (smbios.Init())
    {
        PSTLIST	pstl = smbios.GetStructList(2);

		if (pstl)
		{
			hResult = LoadPropertyValues(pInst, smbios,
                (PBOARDINFO) pstl->pshf);
		}
	}

    // If we were able to get the properties but the new __RELPATH doesn't
    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
        strPathAfter.CompareNoCase(strPathBefore) != 0))
        hResult = WBEM_E_NOT_FOUND;

	return hResult;
}

HRESULT CWin32BaseBoard::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
	CSMBios		smbios;

	if (smbios.Init())
	{
        PSTLIST	pstl = smbios.GetStructList(2);
		if (pstl)
		{
			CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PBOARDINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32BaseBoard::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PBOARDINFO pbi)
{
	WCHAR tempstr[ MIF_STRING_LENGTH + 1 ];

	pInst->SetCharSplat(L"Tag", L"Base Board");
	pInst->Setbool(L"HostingBoard", true);
	pInst->Setbool(L"PoweredOn", true);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_BASEBOARD);

        CHString sTemp;
        LoadStringW(sTemp, IDR_BaseBoard);

	pInst->SetCHString(IDS_Name, sTemp);
	pInst->SetCHString(IDS_Caption, sTemp );
	pInst->SetCHString(IDS_Description, sTemp);

	smbios.GetStringAtOffset((PSHF) pbi, tempstr, pbi->Manufacturer);
	pInst->SetCharSplat(L"Manufacturer", tempstr);

	smbios.GetStringAtOffset((PSHF) pbi, tempstr, pbi->Product);
	pInst->SetCharSplat(L"Product", tempstr);

	smbios.GetStringAtOffset((PSHF) pbi, tempstr, pbi->Version);
	pInst->SetCharSplat(L"Version", tempstr);

	smbios.GetStringAtOffset((PSHF) pbi, tempstr, pbi->Serial_Number);
	pInst->SetCharSplat(L"SerialNumber", tempstr);


	//PSYSCFGOPTIONS psco = (PSYSCFGOPTIONS) smbios.GetFirstStruct(12);
	PSTLIST			pstl = smbios.GetStructList(12);
	if (pstl)
	{
		PSYSCFGOPTIONS	psco = (PSYSCFGOPTIONS) pstl->pshf;

		SAFEARRAY       *psa;
		SAFEARRAYBOUND  sab;

		sab.lLbound = 0;
		sab.cElements = psco->Count;
		psa = SafeArrayCreate(VT_BSTR, 1, &sab);
		if (psa)
		{
		      OnDelete<SAFEARRAY *,HRESULT(*)(SAFEARRAY *),SafeArrayDestroy> dm(psa);
			int i;

			for (i = 0; i < psco->Count; i++)
			{
				_bstr_t bstr;
				int     len;

				len = smbios.GetStringAtOffset((PSHF) psco, tempstr, i + 1);
				bstr = tempstr;
				SafeArrayPutElement(psa, (long *) &i, (LPVOID) (BSTR) bstr);
			}

			pInst->SetStringArray(L"ConfigOptions", *psa);

		}
	}

	return WBEM_S_NO_ERROR;
}

#endif // SMB_BASEBOARD
//==============================================================================

//==============================================================================
// System Enclosure Class
//------------------------------------------------------------------------------
#ifdef SMB_SYSTEMENCLOSURE
CWin32SystemEnclosure	MySystemEnclosureSet(PROPSET_NAME_SYSTEMENCLOSURE, IDS_CimWin32Namespace);

//
CWin32SystemEnclosure::CWin32SystemEnclosure(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32SystemEnclosure::~CWin32SystemEnclosure()
{
}

//
HRESULT CWin32SystemEnclosure::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"Tag", L"System Enclosure", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PENCLOSURE pEnclosure =
                            (PENCLOSURE) smbios.GetNthStruct(3, instanceNum);

			if (pEnclosure)
			{
				hResult = LoadPropertyValues(pInst, smbios, pEnclosure);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
					hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}

HRESULT CWin32SystemEnclosure::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_S_NO_ERROR;
	CSMBios		smbios;

	if (smbios.Init())
	{
		int			    i;
		CHString	    sTemp;
        PSTLIST		    pstl = smbios.GetStructList(3);
		CInstancePtr    pInst;

		for (i = 0; pstl != NULL && i < 1000 && SUCCEEDED(hResult); i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"System Enclosure %d", i);
			pInst->SetCharSplat(L"Tag", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PENCLOSURE) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}

			pstl = pstl->next;
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32SystemEnclosure::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PENCLOSURE pe)
{
	WCHAR tempstr[ MIF_STRING_LENGTH + 1 ];

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_SYSTEMENCLOSURE);

    CHString sTemp;
    LoadStringW(sTemp, IDR_SystemEnclosure);

	pInst->SetCHString(IDS_Name, sTemp);
	pInst->SetCHString(IDS_Caption, sTemp);
	pInst->SetCHString(IDS_Description, sTemp);

	smbios.GetStringAtOffset((PSHF) pe, tempstr, pe->Manufacturer);
	pInst->SetCharSplat(L"Manufacturer", tempstr);

    pInst->Setbool(L"LockPresent", (0x80 & pe->Chassis_Type) ? true : false);


    // Create a safearray for the ChassisType
	SAFEARRAYBOUND  rgsabound[1];
	variant_t       vValue;

    rgsabound[0].cElements = 1;
    rgsabound[0].lLbound = 0;
    V_ARRAY(&vValue) = SafeArrayCreate(VT_I2, 1, rgsabound);
	if (V_ARRAY(&vValue))
	{
		long    ix[1] = { 0 };
		DWORD   dwVal = 0x7f & pe->Chassis_Type;

		if ((dwVal < CT_LOWER) || (dwVal > CT_UPPER))
		{
			dwVal = CT_UNKNOWN;
		}

		V_VT(&vValue) = VT_I2 | VT_ARRAY;

		HRESULT Result = SafeArrayPutElement(V_ARRAY(&vValue), ix, &dwVal);
		if (Result == E_OUTOFMEMORY)
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		pInst->SetVariant(L"ChassisTypes", vValue);
	}
	else
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}



	smbios.GetStringAtOffset((PSHF) pe, tempstr, pe->Version);
	pInst->SetCharSplat(L"Version", tempstr);

	smbios.GetStringAtOffset((PSHF) pe, tempstr, pe->Serial_Number);
	pInst->SetCharSplat(L"SerialNumber", tempstr);

	smbios.GetStringAtOffset((PSHF) pe, tempstr, pe->Asset_Tag_Number);
	pInst->SetCharSplat(L"SMBIOSAssetTag", tempstr);

	if (smbios.GetVersion() > 0x00020000 && pe->Length >= sizeof(ENCLOSURE))
	{
	    pInst->SetByte(L"SecurityStatus", pe->Security_Status);
	}

    return WBEM_S_NO_ERROR;
}

#endif // SMB_SYSTEMENCLOSURE
//==============================================================================


//==============================================================================
#ifdef SMB_CACHEMEMORY

CWin32CacheMemory	MyCacheMemorySet(PROPSET_NAME_CACHEMEMORY, IDS_CimWin32Namespace);

//
CWin32CacheMemory::CWin32CacheMemory(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32CacheMemory::~CWin32CacheMemory()
{
}

//
HRESULT CWin32CacheMemory::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", L"Cache Memory", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PCACHEINFO	pci = (PCACHEINFO) smbios.GetNthStruct(7, instanceNum);

			if (pci)
			{
				hResult = LoadPropertyValues(pInst, smbios, pci);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
					hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}


HRESULT CWin32CacheMemory::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_S_NO_ERROR;
	CSMBios		smbios;

	if (smbios.Init())
	{
		int			i;
		CHString	sTemp(L"Cache Memory XXX");
		//PCACHEINFO	pci = (PCACHEINFO) smbios.GetFirstStruct(7);
        PSTLIST		pstl = smbios.GetStructList(7);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000 && SUCCEEDED(hResult); i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Cache Memory %d", i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PCACHEINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}

			pstl = pstl->next;
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32CacheMemory::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PCACHEINFO pci)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	DWORD		dwTemp;
	CHString	sTemp;

	pInst->GetCHString(L"DeviceID", sTemp);

	pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
	pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_CACHEMEMORY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_CacheMemory);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);
	pInst->SetCharSplat(IDS_Status, L"OK");

	smbios.GetStringAtOffset((PSHF) pci, tempstr, pci->Socket_Designation);
	pInst->SetCharSplat(L"Purpose", tempstr);

	// Write policy mapped here
	// ValueMap {"1", "2", "3", "4", "5"}: ToSubClass,
	// Values {"Other", "Unknown", "Write Back", "Write Through", "Varies with Address"}: ToSubClass,

	DWORD wp;

	switch ((pci->Cache_Configuration & 0x0300) >> 8)
	{
		case 0x00:	wp = 4; break;
		case 0x01:	wp = 3; break;
		case 0x02:	wp = 5; break;
		case 0x03:	wp = 2; break;
	}

	pInst->SetDWORD(L"WritePolicy", wp);

	pInst->SetDWORD(L"Availability", (pci->Cache_Configuration & 0x0080) ? 3 : 8);
	pInst->SetDWORD(L"StatusInfo", (pci->Cache_Configuration & 0x0080) ? 3 : 4);
	pInst->SetByte(L"Location", (BYTE) (pci->Cache_Configuration & 0x0060) >> 5);
	//pInst->Setbool("Socketed", (pci->Cache_Configuration & 0x0008) ? true : false);
	pInst->SetWBEMINT16(L"Level", (WORD) (pci->Cache_Configuration & 0x0007) + 3);

	dwTemp = pci->Maximum_Cache_Size & 0x8000 ? (pci->Maximum_Cache_Size & 0x7fff) * 64 : pci->Maximum_Cache_Size;
	pInst->SetDWORD(L"MaxCacheSize", dwTemp);

	dwTemp = pci->Installed_Size & 0x8000 ? (pci->Installed_Size & 0x7fff) * 64 : pci->Installed_Size;
	pInst->SetDWORD(L"InstalledSize", dwTemp);

	// use granularity as block size
	pInst->SetWBEMINT64(L"BlockSize",
        (__int64) ((pci->Installed_Size & 0x8000) ? 65536 : 1024));

	// the rest of installed size is the # of blocks
	pInst->SetWBEMINT64(L"NumberOfBlocks",
        (__int64) (pci->Installed_Size & 0x7fff));


	SAFEARRAYBOUND	sab;
	int				i;

	// count of supported SRAM types
	sab.lLbound	= 0;
	sab.cElements = 0;
	for (i = 0; i < 7; i++)
	{
		if (pci->Supported_SRAM_Type & (1 << i))
		{
			sab.cElements++;
		}
	}

	if (sab.cElements > 0)
	{
		variant_t vSRAM;

        if ((V_ARRAY(&vSRAM) = SafeArrayCreate(VT_UI1, 1, &sab)))
        {
			V_VT(&vSRAM) = VT_ARRAY | VT_UI1;

			long lElement = 0;

			for (BYTE b = 0; b < 7; b++)
			{
				if (pci->Supported_SRAM_Type & (1 << b))
				{
					SafeArrayPutElement(V_ARRAY(&vSRAM), &lElement, &b);
					lElement++;
				}
			}

			pInst->SetVariant(L"SupportedSRAM", vSRAM);
		}
    }

	// count of current SRAM types
	sab.lLbound	= 0;
	sab.cElements = 0;
	for (i = 0; i < 7; i++)
	{
		if (pci->Current_SRAM_Type & (1 << i))
		{
			sab.cElements++;
		}
	}

	if (sab.cElements > 0)
	{
		variant_t vSRAM;

        if ((V_ARRAY(&vSRAM) = SafeArrayCreate(VT_UI1, 1, &sab)))
		{
			V_VT(&vSRAM) = VT_ARRAY | VT_UI1;

			long lElement = 0;

            for (BYTE b = 0; b < 7; b++)
			{
			    if (pci->Current_SRAM_Type & (1 << b))
				{
					SafeArrayPutElement(V_ARRAY(&vSRAM), &lElement, &b);
					lElement++;
				}
			}

			pInst->SetVariant(L"CurrentSRAM", vSRAM);
		}
	}

	if (smbios.GetVersion() > 0x00020000 && pci->Length >= sizeof(CACHEINFO))
	{
		// Only set this if it's non zero.
        if (pci->Cache_Speed)
            pInst->SetDWORD(L"CacheSpeed", pci->Cache_Speed);

		pInst->SetDWORD(L"ErrorCorrectType", pci->Error_Correction_Type);
		pInst->SetDWORD(L"CacheType", pci->System_Cache_Type);
		pInst->SetDWORD(L"Associativity", pci->Associativity);
	}

	return WBEM_S_NO_ERROR;
}
#endif // SMB_CACHEINFO


//==============================================================================
// Port Connector class
//------------------------------------------------------------------------------
#ifdef SMB_PORTCONNECTOR
CWin32PortConnector	MyPortConnectorSet(PROPSET_NAME_PORTCONNECTOR, IDS_CimWin32Namespace);

//
CWin32PortConnector::CWin32PortConnector(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32PortConnector::~CWin32PortConnector()
{
}

//
HRESULT CWin32PortConnector::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, NULL, L"Port Connector", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PPORTCONNECTORINFO	ppci = (PPORTCONNECTORINFO) smbios.GetNthStruct(8, instanceNum);

			if (ppci)
			{
				hResult = LoadPropertyValues(pInst, smbios, ppci);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}

HRESULT CWin32PortConnector::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
	CSMBios		smbios;

	// guarded resource
	CInstance	*pInst = NULL;

	if (smbios.Init())
	{
		int 			i;
		CHString		sTemp(L"Port Connector XXX");
		//PPORTCONNECTORINFO	ppci = (PPORTCONNECTORINFO) smbios.GetFirstStruct(8);
        PSTLIST		    pstl = smbios.GetStructList(8);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Port Connector %d", i);

			pInst->SetCharSplat(L"Tag", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PPORTCONNECTORINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			//ppci = (PPORTCONNECTORINFO) smbios.GetNextStruct(8);
			pstl = pstl->next;
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}


HRESULT CWin32PortConnector::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PPORTCONNECTORINFO ppci)
{
	WCHAR			tempstr[ MIF_STRING_LENGTH + 1 ];
	ULONG			CimVal;
	ULONG			ConnType[3];
	int				i;

	SAFEARRAYBOUND	sab;
	CHString		sTemp;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PORTCONNECTOR);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PortConnector);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	smbios.GetStringAtOffset((PSHF) ppci, tempstr, ppci->Int_Reference_Designator);
	pInst->SetCharSplat(L"InternalReferenceDesignator", tempstr);

	smbios.GetStringAtOffset((PSHF) ppci, tempstr, ppci->Ext_Reference_Designator);
	pInst->SetCharSplat(L"ExternalReferenceDesignator", tempstr);

	// Put both the internal and external connector types into the array

	i = 0;
	CimVal = GetCimVal(ConnectorType, ppci->Ext_Connector_Type);
	if (CimVal == 0xff)
	{
		CimVal = 0;
	}
	if (CimVal)
	{
		ConnType[i++] = CimVal;
		CimVal = GetCimVal(ConnectorGender, ppci->Ext_Connector_Type);
		if (CimVal)
		{
			ConnType[i++] = CimVal;
		}
	}
	CimVal = GetCimVal(ConnectorType, ppci->Int_Connector_Type);
	if (CimVal == 0xff)
	{
		CimVal = 0;
	}
	if (CimVal)
	{
		ConnType[i++] = CimVal;
	}

	// if no connector types are found set just the first one to "unknown"
	if (i == 0)
	{
		ConnType[i++] = 0;
	}

	variant_t vType;

	sab.lLbound = 0;
	sab.cElements = i;	// max of 2 types plus a gender value
	if (i > 0 && (V_ARRAY(&vType) = SafeArrayCreate(VT_I4, 1, &sab)))
	{
		V_VT(&vType) = VT_ARRAY | VT_I4;

		for (i = 0; i < sab.cElements; i++)
		{
			SafeArrayPutElement(V_ARRAY(&vType), (long *) &i, &ConnType[i]);
		}

		pInst->SetVariant(L"ConnectorType", vType);

		pInst->SetDWORD(L"PortType", ppci->Port_Type == 0xff ? 0 : ppci->Port_Type);
    }

	return WBEM_S_NO_ERROR;
}
#endif // SMB_PORTCONNECTOR


//==============================================================================
// System Slot class
//------------------------------------------------------------------------------
#ifdef SMB_SYSTEMSLOT
CWin32SystemSlot	MySystemSlotSet(PROPSET_NAME_SYSTEMSLOT, IDS_CimWin32Namespace);

//
CWin32SystemSlot::CWin32SystemSlot(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32SystemSlot::~CWin32SystemSlot()
{
}

//
HRESULT CWin32SystemSlot::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, NULL, L"System Slot", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PSYSTEMSLOTS pss = (PSYSTEMSLOTS) smbios.GetNthStruct(9, instanceNum);

			if (pss)
			{
				hResult = LoadPropertyValues(pInst, smbios, pss);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CWin32SystemSlot::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
	CSMBios		smbios;

	if (smbios.Init())
    {
        int 			i;
		CHString		sTemp(L"System Slot XXX");
        //PSYSTEMSLOTS	pss = (PSYSTEMSLOTS) smbios.GetFirstStruct(9);
        PSTLIST		    pstl = smbios.GetStructList(9);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"System Slot %d", i);
			pInst->SetCharSplat(L"Tag", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PSYSTEMSLOTS) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
			//pss = (PSYSTEMSLOTS) smbios.GetNextStruct(9);
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32SystemSlot::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PSYSTEMSLOTS pss)
{
	WCHAR			tempstr[MIF_STRING_LENGTH+1];
	BOOL			cardbus;
	SAFEARRAYBOUND	sab;
	CHString		sTemp;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_SYSTEMSLOT);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_SystemSlot);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	// Properties in Win32_SystemSlot
	smbios.GetStringAtOffset((PSHF) pss, tempstr, pss->Slot_Designation);
	pInst->SetCharSplat(L"SlotDesignation", tempstr);
	pInst->SetByte(L"CurrentUsage", pss->Current_Usage);

	// status
	switch(pss->Current_Usage)
	{
		case 0x04:
		case 0x03:
			pInst->SetCHString(IDS_Status, L"OK");
			break;

		case 0x02:
		case 0x01:
			pInst->SetCHString(IDS_Status, L"Unknown");
			break;

		default:
			pInst->SetCHString(IDS_Status, IDS_STATUS_Error);
	}

	// Properties in CIM_Slot
	switch (pss->Slot_Type)
	{
		case ST_MCA:
		case ST_EISA:
		case ST_PCI:
		case ST_PCI66:
		case ST_AGP:
			pInst->SetWBEMINT16(L"Number", pss->Slot_ID & 0x00ff);
			break;

		case ST_PCMCIA:
			pInst->SetWBEMINT16(L"Number", pss->Slot_ID & 0x00ff);
			// need to do something with socket number (pss->SloID >> 8) in case of PCMCIA
			break;

		default:
			break;
	}

	// SMBIOS to CIM mapping skewed by 3 for data width
	//	 ValueMap {"8", "16", "32", "64", "128"},
	if (pss->Slot_Data_Bus_Width > 2)
	{
		pInst->SetByte(L"MaxDataWidth", pss->Slot_Data_Bus_Width - 3);
	}

	// Is slot shared?
	pInst->Setbool(L"Shared", pss->Slot_Characteristics1 & 0x08 ? true : false);

	// Slot Length only differentiates between short and long.  Length in inches is not known
	// unless there are standard values for short and long.
	//pInstance->SetWBEMINT16(L"LengthAllowed", pss->SloLength);
	sab.lLbound = 0;
	sab.cElements = 1;

	// check for special case of PCMCIA - is cardbus supported
	cardbus = (pss->Slot_Characteristics1 & 0x20) ? true : false;
	if (cardbus)
	{
		sab.cElements++;
	}

    variant_t vType;
	if ((V_ARRAY(&vType) = SafeArrayCreate(VT_I4, 1, &sab)))
	{
		ULONG CimVal;
		int i = 0;

		V_VT(&vType) = VT_ARRAY | VT_I4;

		CimVal = GetCimVal(SlotType, pss->Slot_Type);
		SafeArrayPutElement(V_ARRAY(&vType), (long *) &i, &CimVal);
		if (cardbus)
		{
			i++;
			CimVal = 52;
			//CimVal = CIM_SLOT_TYPE_CARDBUS;
			SafeArrayPutElement(V_ARRAY(&vType), (long *) &i, &CimVal);
		}

		pInst->SetVariant(L"ConnectorType", vType);
	}

	// pick apart the Characteristics1 byte

	// set slot voltage
    // Values {"Unknown", "Other", "3.3V", "5V"},

	ULONG voltages[4];

	sab.lLbound = 0;
	sab.cElements = 0;
	if ((pss->Slot_Characteristics1 & 0x01) || (!(pss->Slot_Characteristics1 & 0x06)))
	{
		voltages[ sab.cElements ] = 0;	// "Unknown"
		sab.cElements++;
	}
	else
	{
		if (pss->Slot_Characteristics1 & 0x02)
		{
			voltages[ sab.cElements ] = 3;	// "5V"
			sab.cElements++;
		}
		if (pss->Slot_Characteristics1 & 0x04)
		{
			voltages[ sab.cElements ] = 2;	// "3.3V"
			sab.cElements++;
		}
	}

    variant_t vVoltage;
	if (V_ARRAY(&vVoltage) = SafeArrayCreate(VT_I4, 1, &sab))
	{
		int i;

		V_VT(&vVoltage) = VT_ARRAY | VT_I4;

		for (i = 0; i < sab.cElements; i++)
		{
			SafeArrayPutElement(V_ARRAY(&vVoltage), (long *) &i, &voltages[ i ]);
		}

		pInst->SetVariant(L"VccMixedVoltageSupport", vVoltage);
	}

	// NOTE!! add shared slots association here
	if (smbios.GetVersion() > 0x00020000 && pss->Length >= sizeof(SYSTEMSLOTS))
	{
		pInst->Setbool(L"SupportsHotPlug", pss->Slot_Characteristics2 & 0x02 ? true : false);
		pInst->Setbool(L"PMESignal", pss->Slot_Characteristics2 & 0x01 ? true : false);
	}

	return WBEM_S_NO_ERROR;
}
#endif // SMB_SYSTEMSLOT
//==============================================================================


//==============================================================================
// On Board Devices class
//------------------------------------------------------------------------------
#ifdef SMB_ONBOARDDEVICE
CWin32OnBoardDevice	MyOnBoardDevice(PROPSET_NAME_ONBOARDDEVICE, IDS_CimWin32Namespace);

//
CWin32OnBoardDevice::CWin32OnBoardDevice(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32OnBoardDevice::~CWin32OnBoardDevice()
{
}

//
HRESULT CWin32OnBoardDevice::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, NULL, L"On Board Device", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PSTLIST pstl = smbios.GetStructList(10);
			PSHF pshf = NULL;
			if (pstl)
			{
				pshf = pstl->pshf;
				if ((instanceNum > 0) && (pshf->Length < (4 + 2 * (instanceNum + 1))))
		        {
		        	pshf = smbios.GetNthStruct(10, instanceNum);
				}
			}

			if (pshf)
			{
				hResult = LoadPropertyValues(pInst, smbios, pshf, instanceNum);
			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
			        hResult = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}

HRESULT CWin32OnBoardDevice::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hr			=	WBEM_E_NOT_FOUND;
    CSMBios smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        PSTLIST			pstl = smbios.GetStructList(10);

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
		    CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

			sTemp.Format(L"On Board Device %d", i);
			pInst->SetCharSplat(L"Tag", sTemp);
			if ((hr = LoadPropertyValues(pInst, smbios, pstl->pshf, i)) == WBEM_S_NO_ERROR)
			{
                hr = pInst->Commit();
			}

			if (pstl->pshf->Length <= (4 + 2 * (i + 1)))
	        {
	        	pstl = pstl->next;
			}
        }
		// Commit will Release pInstance
	}
	else
	{
		hr = smbios.GetWbemResult();
	}

	return hr;
}

//
HRESULT CWin32OnBoardDevice::LoadPropertyValues(
												CInstance *pInst,
												CSMBios &smbios,
												PSHF pshf,
												UINT instanceNum)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString	sTemp;
	ULONG		byteoff;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_ONBOARDDEVICE);
	pInst->SetCharSplat(IDS_Name, L"On Board Device");
	pInst->SetCharSplat(IDS_Caption, L"On Board Device");
	pInst->SetCharSplat(IDS_Description, L"On Board Device");

	byteoff = 4;
	if (pshf->Length > (4 + (instanceNum * 2)))
	{
		byteoff += (instanceNum * 2);
	}

	pInst->SetDWORD(L"DeviceType", *((PBYTE) pshf + byteoff) & 0x7f);
	pInst->Setbool(L"Enabled", (*((PBYTE) pshf + byteoff) & 0x80) ? true : false);

	smbios.GetStringAtOffset(pshf, tempstr, *((PBYTE) pshf + byteoff + 1));
	pInst->SetCharSplat(L"Description", tempstr);

    return WBEM_S_NO_ERROR;
}
#endif // SMB_ONBOARDDEVICES
//==============================================================================


//==============================================================================
// BIOS Language class
//------------------------------------------------------------------------------
#ifdef SMB_BIOSLANG
CWin32BIOSLanguage	MyBIOSLanguageSet(PROPSET_NAME_BIOSLANG, IDS_CimWin32Namespace);

//
CWin32BIOSLanguage::CWin32BIOSLanguage(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32BIOSLanguage::~CWin32BIOSLanguage()
{
}

//
HRESULT CWin32BIOSLanguage::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult;
    CSMBios		smbios;

    if (smbios.Init())
    {
        //PBIOSLANGINFO pbli = (PBIOSLANGINFO) smbios.GetFirstStruct(13);
		PSTLIST	pstl = smbios.GetStructList(13);

        if (pstl)
		{
			hResult = LoadPropertyValues(pInst, smbios,
                (PBIOSLANGINFO) pstl->pshf);
		}
	}

    // If we were able to get the BIOS properties but the new __RELPATH doesn't
    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
    //if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
    //    strPathAfter.CompareNoCase(strPathBefore) != 0))
    //    hResult = WBEM_E_NOT_FOUND;

	return hResult;
}

HRESULT CWin32BIOSLanguage::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT	hResult = WBEM_E_NOT_FOUND;
    CSMBios smbios;

    if (smbios.Init())
    {
        //PBIOSLANGINFO pbli = (PBIOSLANGINFO) smbios.GetFirstStruct(13);
		PSTLIST	pstl = smbios.GetStructList(13);

		CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

		if (pbli)
		{
			pInst->SetCharSplat(L"InstanceName", L"Bios Language");
			if ((hResult = LoadPropertyValues(pInst, smbios,
                (PBIOSLANGINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;

}

HRESULT CWin32BIOSLanguage::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PBIOSLANGINFO pbli)
{
	WCHAR tempstr[ MIF_STRING_LENGTH + 1 ];

	pInst->SetByte(L"InstallableLanguages", pbli->Installable_Languages);

	if (smbios.GetVersion() > 0x00020000 && pbli->Length >= sizeof(BIOSLANGINFO))
	{
	    pInst->Setbool(L"AbbrStrings", pbli->Flags & 0x01 ? true : false);
	}

	smbios.GetStringAtOffset((PSHF) pbli, tempstr, pbli->CurrenLanguage);
	pInst->SetCharSplat(L"CurrentLanguage", tempstr);

    return WBEM_S_NO_ERROR;
}
#endif // SMB_BIOSLANG
//==============================================================================


//==============================================================================
#ifdef SMB_PHYSICALMEMORY

CWin32PhysicalMemory	MyPhysicalMemorySet(PROPSET_NAME_PHYSICALMEMORY, IDS_CimWin32Namespace);

//
CWin32PhysicalMemory::CWin32PhysicalMemory(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32PhysicalMemory::~CWin32PhysicalMemory()
{
}

//
HRESULT CWin32PhysicalMemory::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hr = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"Tag", L"Physical Memory", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PSHF	pshf = smbios.GetNthStruct(17, instanceNum);

			if (pshf)
			{
				hr = LoadPropertyValues_MD(pInst, smbios, (PMEMDEVICE) pshf);
			}
			else
			{
		        pshf = smbios.GetNthStruct(6, instanceNum);
				if (pshf)
				{
					hr = LoadPropertyValues_MI(pInst, smbios, (PMEMMODULEINFO) pshf);
				}
			}
		    // If we were able to get the BIOS properties but the new __RELPATH doesn't
		    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
		    if (SUCCEEDED(hr) && (!GetLocalInstancePath(pInst, strPathAfter) ||
		        strPathAfter.CompareNoCase(strPathBefore) != 0))
		        hr = WBEM_E_NOT_FOUND;
		}
		else
		{
			hr = smbios.GetWbemResult();
		}
	}

	return hr;
}

HRESULT CWin32PhysicalMemory::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hr			=	WBEM_E_NOT_FOUND;
    CSMBios		smbios;
	BOOL		altstruct = FALSE;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        PSTLIST			pstl = smbios.GetStructList(17);

		if (!pstl)
		{
	        pstl = smbios.GetStructList(6);
			altstruct = TRUE;
		}

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
    		CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

			sTemp.Format(L"Physical Memory %d", i);
			pInstance->SetCharSplat(L"Tag", sTemp);
			if (altstruct)
			{
                hr =
                    LoadPropertyValues_MI(
                        pInstance,
                        smbios,
                        (PMEMMODULEINFO) pstl->pshf);
			}
			else
			{
				hr = LoadPropertyValues_MD(pInstance, smbios, (PMEMDEVICE) pstl->pshf);
			}
			if (hr == WBEM_S_NO_ERROR)
			{
				hr = pInstance->Commit();
			}
            // No big deal if the memory wasn't found (means the slot was empty).
            else if (hr == WBEM_E_NOT_FOUND)
                hr = WBEM_S_NO_ERROR;

			//pshf = smbios.GetNthStruct(altstruct ? 6 : 17, i + 1);
			pstl = pstl->next;
        }
		// Commit will Release pInstance
	}
	else
	{
		hr = smbios.GetWbemResult();
	}

	return hr;
}

HRESULT CWin32PhysicalMemory::LoadPropertyValues_MD(CInstance *pInst, CSMBios &smbios, PMEMDEVICE pmd)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString	sTemp;

	// This is not a valid memory if the size is 0 (means the bank is empty).
    if (!pmd->Size)
        return WBEM_E_NOT_FOUND;

    pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PHYSICALMEMORY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PhysicalMemory);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	// V2.1 properties
	if (smbios.GetVersion() > 0x00020000 && pmd->Length >= ((PBYTE) &pmd->Speed - (PBYTE) pmd))
	{
		__int64 memsize;

		// this goes into an association later
		//pInstance->SetDWORD(L"MemArrayHandle", pmd->Mem_Array_Handle);
		// this goes into an association later
		//pInstance->SetDWORD(L"MemErrorInfoHandle", pmd->Mem_Error_Info_Handle);

		if (pmd->Total_Width != 0xffff )
		{
			pInst->SetDWORD(L"TotalWidth", pmd->Total_Width);
		}
		if (pmd->Data_Width != 0xffff)
		{
			pInst->SetDWORD(L"DataWidth", pmd->Data_Width);
		}

		if (pmd->Size != 0xffff)
		{
			memsize = (__int64)(pmd->Size & 0x7fff);
			if (pmd->Size & 0x8000) // check multiplier
			{
				// one K multiplier
				memsize <<= 10;
			}
			else
			{
				// one Meg multiplier
				memsize <<= 20;
			}
            swprintf(tempstr, L"%I64d", memsize);
			pInst->SetWBEMINT64(L"Capacity", tempstr);
        }

		// this needs a CIM mapper -- FormFactor
		pInst->SetDWORD(L"FormFactor", GetCimVal(FormFactor, pmd->Form_Factor));

		// this goes into an association later
		//pInst->SetDWORD(L"DeviceSet", pmd->Device_Set);

		smbios.GetStringAtOffset((PSHF) pmd, tempstr, pmd->Device_Locator);
		pInst->SetCharSplat(L"DeviceLocator", tempstr);

		smbios.GetStringAtOffset((PSHF) pmd, tempstr, pmd->Bank_Locator);
		pInst->SetCharSplat(L"BankLabel", tempstr);

		// this needs a CIM mapper -- MemoryType
 		pInst->SetDWORD(L"MemoryType", GetCimVal(MemoryType, pmd->Memory_Type));
		pInst->SetDWORD(L"TypeDetail", pmd->Type_Detail);


		//PMEMDEVICEMAPADDR pmdma = (PMEMDEVICEMAPADDR) smbios.GetFirstStruct(20);
    	PMEMDEVICEMAPADDR pmdma;
	    PSTLIST pstl = smbios.GetStructList(20);

		while (pstl)
		{
            pmdma = (PMEMDEVICEMAPADDR) pstl->pshf;

            if (pmdma->Memory_Device_Handle == pmd->Handle)
			{
			    if (pmdma->Partition_Row > 0 && pmdma->Partition_Row < 0xff)
				{
					pInst->SetDWORD(L"PositionInRow", pmdma->Partition_Row);
				}
				if (pmdma->Interleave_Position < 0xff)
				{
					pInst->SetDWORD(L"InterleavePosition", pmdma->Interleave_Position);
				}
				if (pmdma->Interleaved_Data_Depth < 0xff)
				{
					pInst->SetDWORD(L"InterleaveDataDepth", pmdma->Interleaved_Data_Depth);
				}
				break;
			}
			else
			{
    			pstl = pstl->next;
			}
		}
	}

	// V2.3 properties
	if (smbios.GetVersion() > 0x00020002 && pmd->Length > ((PBYTE) &pmd->Speed - (PBYTE) pmd))
	{
		if (pmd->Speed)
            pInst->SetDWORD(L"Speed", pmd->Speed);
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CWin32PhysicalMemory::LoadPropertyValues_MI(CInstance *pInst, CSMBios &smbios, PMEMMODULEINFO pmmi)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString	sTemp;
	UINT		Form_Factor;
	UINT		Memory_Type;
	__int64     memsize;

	switch (pmmi->Installed_Size & 0x7f)
	{
		case 0x7d:
		case 0x7f:
			memsize = 0;
    		break;

		default:
			memsize = (1 << pmmi->Installed_Size) * 1024;
    		break;
	}

	// This is not a valid memory if the size is 0 (means the bank is empty).
    if (!memsize)
        return WBEM_E_NOT_FOUND;

	// one K multiplier
	memsize <<= 10;
	swprintf(tempstr, L"%I64d", memsize);
	pInst->SetWBEMINT64(L"Capacity", tempstr);

    if (pmmi->Current_Speed)
        pInst->SetDWORD(L"Speed", pmmi->Current_Speed);

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PHYSICALMEMORY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PhysicalMemory);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	// this goes into an association later
	smbios.GetStringAtOffset((PSHF) pmmi, tempstr, pmmi->Socket_Designation);
	pInst->SetCharSplat(L"DeviceLocator", tempstr);

	BYTE bank0 = pmmi->Bank_Connections & 0x0f;
	BYTE bank1 = pmmi->Bank_Connections >> 4;

	if (bank0 != 0xf && bank1 != 0xf)
	{
		swprintf(tempstr, L"RAS %d & %d" , bank0, bank1);
	}
	else if (bank0 != 0xf)
	{
		swprintf(tempstr, L"RAS %d" , bank0);
	}
	else if (bank1 != 0xf)
	{
		swprintf(tempstr, L"RAS %d" , bank1);
	}
	else
	{
		*tempstr = '\0';
	}

	pInst->SetCharSplat(L"BankLabel", tempstr);


	if (pmmi->Current_Memory_Type & 0x00800) // SIMM
	{
		Form_Factor = 3;
	}
	else if (pmmi->Current_Memory_Type & 0x0100) // DIMM
	{
		Form_Factor = 9;
	}
	else if (pmmi->Current_Memory_Type & 0x0002 || pmmi->Current_Memory_Type & 0x0001)
	{
		Form_Factor = pmmi->Current_Memory_Type & 0x0003;
	}
	// this needs a CIM mapper -- FormFactor
	pInst->SetDWORD(L"FormFactor", GetCimVal(FormFactor, Form_Factor));

	if (pmmi->Current_Memory_Type & 0x0004) // DRAM
	{
		Memory_Type = 3;
	}
	else if (pmmi->Current_Memory_Type & 0x0400) // SDRAM
	{
		Memory_Type = 15;
	}
	else if (pmmi->Current_Memory_Type & 0x0002 || pmmi->Current_Memory_Type & 0x0001)
	{
		Memory_Type = pmmi->Current_Memory_Type & 0x0003;
	}
	// this needs a CIM mapper -- MemoryType
	pInst->SetDWORD(L"MemoryType", GetCimVal(MemoryType, Memory_Type));

	DWORD dwTypeDetail = 0;

	if (pmmi->Current_Memory_Type & 0x0010) // EDO
	    dwTypeDetail |= 0x0200;

	if (pmmi->Current_Memory_Type & 0x0008) // Fast Paged
	    dwTypeDetail |= 8;

	// Set to unknown if we didn't find anything useful to put in it.
    if (!dwTypeDetail)
        dwTypeDetail = 4; // 4 == unknown

    pInst->SetDWORD(L"TypeDetail", dwTypeDetail);

	return WBEM_S_NO_ERROR;
}

#endif // SMB_PHYSICALMEMORY


//==============================================================================
#ifdef SMB_PHYSMEMARRAY
//
CWin32PhysMemoryArray	MyPhysMemArray(PROPSET_NAME_PHYSMEMARRAY, IDS_CimWin32Namespace);

//
CWin32PhysMemoryArray::CWin32PhysMemoryArray(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32PhysMemoryArray::~CWin32PhysMemoryArray()
{
}

//
HRESULT CWin32PhysMemoryArray::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, NULL, L"Physical Memory Array", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PSHF pshf = smbios.GetNthStruct(16, instanceNum);

			if (pshf)
			{
				hResult = LoadPropertyValues_PMA(pInst, smbios, (PPHYSMEMARRAY) pshf);
			}
			else
			{
		        pshf = smbios.GetNthStruct(5, instanceNum);

				if (pshf)
				{
					hResult = LoadPropertyValues_MCI(pInst, smbios, (PMEMCONTROLINFO) pshf);
				}
			}

			// If we were able to get the BIOS properties but the new __RELPATH doesn't
		    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
		    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
		        strPathAfter.CompareNoCase(strPathBefore) != 0))
			{
		        hResult = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}


HRESULT CWin32PhysMemoryArray::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;
	BOOL		altstruct = FALSE;

    if (smbios.Init())
    {
        int 		i;
		CHString	sTemp(L"Physical Memory Array XXX");
        PSTLIST		pstl = smbios.GetStructList(16);

		if (!pstl)
		{
	        pstl = smbios.GetStructList(5);
			altstruct = TRUE;
		}

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Physical Memory Array %d", i);
			pInst->SetCharSplat(L"Tag", sTemp);

			if (altstruct)
			{
				hResult = LoadPropertyValues_MCI(pInst, smbios, (PMEMCONTROLINFO) pstl->pshf);
			}
			else
			{
				hResult = LoadPropertyValues_PMA(pInst, smbios, (PPHYSMEMARRAY) pstl->pshf);
			}

			if (hResult == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}


HRESULT CWin32PhysMemoryArray::LoadPropertyValues_PMA(CInstance *pInst, CSMBios &smbios, PPHYSMEMARRAY ppma)
{
	CHString sTemp;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PHYSMEMARRAY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PhysicalMemoryArray);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	if (smbios.GetVersion() > 0x00020000 && ppma->Length >= sizeof(PHYSMEMARRAY))
	{
		pInst->SetWORD(L"Location", (WORD)ppma->Location);
	    pInst->SetWORD(L"Use", (WORD)ppma->Use);
	    pInst->SetWORD(L"MemoryErrorCorrection", (WORD)ppma->Mem_Error_Correction);
	    pInst->SetDWORD(L"MaxCapacity", ppma->Max_Capacity == 0x80000000 ? 0 : ppma->Max_Capacity);
	    //pInst->SetWBEMINT16(L"MemErrorInfoHandle", ppma->Mem_Error_Info_Handle);
	    pInst->SetDWORD(L"MemoryDevices", ppma->Memory_Devices);
	}

    return WBEM_S_NO_ERROR;
}


HRESULT CWin32PhysMemoryArray::LoadPropertyValues_MCI(CInstance *pInst, CSMBios &smbios, PMEMCONTROLINFO pmci)
{
	CHString sTemp;

	pInst->GetCHString(L"Tag", sTemp);

	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PHYSMEMARRAY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PhysicalMemoryArray);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	// map the error correction capability to that of Physical memory array's values
	BYTE mask = 0x20;
	BYTE ecc = 0;

	while (mask && ecc == 0)
	{
		switch (mask & pmci->Error_Correcting_Capability & 0x20)
		{
			case 0x20:	ecc = 7;	break;
			case 0x10:	ecc = 6;	break;
			case 0x08:	ecc = 5;	break;
			case 0x04:	ecc = 3;	break;
			case 0x02:	ecc = 2;	break;
			case 0x01:	ecc = 1;	break;
		}
		mask >>= 1;
	}
    pInst->SetWORD(L"MemoryErrorCorrection", (WORD) (ecc > 0 ? ecc : 1));

	// size (in K bytes) is module size * # of slots * 1K
	DWORD size = (1 << pmci->Maximum_Memory_Module_Size) * pmci->Associated_Memory_Slots * 1024;
    pInst->SetDWORD(L"MaxCapacity", size);
	pInst->SetDWORD(L"MemoryDevices", pmci->Associated_Memory_Slots);

    return WBEM_S_NO_ERROR;
}
#endif // SMB_PHYSMEMARRAY


//==============================================================================
// Portable Battery
// TODO: Until the Win32_Battery supports more than one internal battery, there's
// no use in this class producing more than one instance (since Win32_PortableBattery
// inherits from Win32_Battery).
//------------------------------------------------------------------------------
#ifdef SMB_PORTABLEBATTERY
CWin32PortableBattery	MyPortableBatterySet(PROPSET_NAME_PORTABLEBATTERY, IDS_CimWin32Namespace);

//
CWin32PortableBattery::CWin32PortableBattery(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32PortableBattery::~CWin32PortableBattery()
{
}

//
HRESULT CWin32PortableBattery::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    HRESULT  hResult = WBEM_E_NOT_FOUND;
	UINT instanceNum = 0;

	if (ValidateTagProperty(pInst, L"DeviceID", L"Portable Battery", &instanceNum))
	{
	    CSMBios smbios;

	    if (smbios.Init())
	    {
	        PPORTABLEBATTERY ppb = (PPORTABLEBATTERY) smbios.GetNthStruct(22, instanceNum);

			if (ppb)
			{
				hResult = LoadPropertyValues(pInst, smbios, ppb);
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CWin32PortableBattery::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int i = 0;
		CHString sTemp (L"Portable Battery XXX");
        PSTLIST	pstl = smbios.GetStructList(22);
    	CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));
			sTemp.Format(L"Portable Battery %d", i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PPORTABLEBATTERY) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}

			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}


HRESULT CWin32PortableBattery::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PPORTABLEBATTERY ppb)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	DWORD		dwValue;

    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	pInst->SetCharSplat(L"CreationClassName", PROPSET_NAME_PORTABLEBATTERY);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_PortableBattery);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	if (smbios.GetVersion() > 0x00020000)
	{
		WBEMTime wbemdate;

		smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Location);
    	pInst->SetCharSplat(L"Location", tempstr);

		smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Manufacturer);
    	pInst->SetCharSplat(L"Manufacturer", tempstr);

		if (smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Manufacture_Date))
		{
			FormatWBEMDate(wbemdate, tempstr);
	    	pInst->SetDateTime(L"ManufactureDate", wbemdate);
		}

		//smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Serial_Number);
    	//pInst->SetCharSplat(L"SerialNumber", tempstr);

		smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->Device_Name);
    	pInst->SetCharSplat(L"Name", tempstr);

	    pInst->SetDWORD(L"Chemistry", ppb->Device_Chemistry);

		// note special case when v2.2+, use multiplier
		dwValue = (smbios.GetVersion() > 0x00020001) ?
			(ppb->Design_Capacity * ppb->Design_Capacity_Mult) : ppb->Design_Capacity;
	    pInst->SetDWORD(L"DesignCapacity", dwValue);

	    pInst->SetDWORD(L"DesignVoltage", ppb->Design_Voltage);

		smbios.GetStringAtOffset((PSHF) ppb, tempstr, ppb->SBDS_Version);
    	pInst->SetCharSplat(L"SmartBatteryVersion", tempstr);

		dwValue = ppb->Max_Error == 0xff ? 0 : ppb->Max_Error;
	    pInst->SetDWORD(L"MaxBatteryError", dwValue);
	}

	if (smbios.GetVersion() > 0x00020001)
	{
		if (ppb->Manufacture_Date != 0)
        {
            struct tm   tm;
            WORD        wDate = ppb->SBDS_Manufacture_Date;

            // Fill out the fields of the time struct so we can pass it on to
            // WBEMTime.

            // Init everything to 0.
            memset(&tm, 0, sizeof(tm));

            // The SMIBOS year is biased by 1980, but the tm version is biased
            // by 1900.  So, add 80 years to make it right.
            tm.tm_year = (wDate >> 9) + 80;

            // SMBIOS month is 1 based, tm is 0 based, so subtract 1.
            tm.tm_mon = ((wDate >> 5) & 0xF) - 1;

            // SMBIOS day and tm are both 1 based.
            tm.tm_mday = wDate & 0x1F;

            WBEMTime wbemTime(tm);

            pInst->SetDateTime(L"ManufactureDate", wbemTime);
        }

        pInst->SetDWORD(L"CapacityMultiplier", ppb->Design_Capacity_Mult);
	}

    return WBEM_S_NO_ERROR;
}

#endif // SMB_PORTABLEBATTERY



//==============================================================================
// Probes class
//------------------------------------------------------------------------------
#ifdef SMB_PROBES

//
CCimNumericSensor		MyCurrentProbeSet(PROPSET_NAME_CURRENTPROBE, IDS_CimWin32Namespace,
							29, L"Electrical Current Probe");
//
CCimNumericSensor		MyTemperatureProbeSet(PROPSET_NAME_TEMPPROBE, IDS_CimWin32Namespace,
							28, L"Temperature Probe");
//
CCimNumericSensor		MyVoltageProbeSet(PROPSET_NAME_VOLTPROBE, IDS_CimWin32Namespace,
							26, L"Voltage Probe");
//
CCimNumericSensor::CCimNumericSensor(
									 LPCWSTR strName,
									 LPCWSTR pszNamespace,
									 UINT StructType,
									 LPCWSTR strTag)
:	Provider(strName, pszNamespace)
{
	m_StructType = StructType;
	m_TagName = pszNamespace;
}

//
CCimNumericSensor::~CCimNumericSensor()
{
}

//
HRESULT CCimNumericSensor::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
	HRESULT     hResult = WBEM_E_NOT_FOUND;
	CHString    strPathBefore,
                strPathAfter;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", m_TagName, &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PPROBEINFO ppi = (PPROBEINFO) smbios.GetNthStruct((BYTE)m_StructType, instanceNum);

			if (ppi)
			{
				hResult = LoadPropertyValues(pInst, smbios, ppi);

			    // If we were able to get the BIOS properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CCimNumericSensor::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        PSTLIST			pstl = smbios.GetStructList((BYTE)m_StructType);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"%s %d", m_TagName, i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PPROBEINFO) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CCimNumericSensor::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PPROBEINFO ppi)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString	sTemp;

	pInst->GetCHString(L"DeviceID", sTemp);

    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	SetCreationClassName(pInst);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_NumericSensor);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	smbios.GetStringAtOffset((PSHF) ppi, tempstr, ppi->Description);
    pInst->SetCharSplat(L"Description", tempstr);

	switch (ppi->Location_Status & 0xe0)
	{
		case 0x60:
		    pInst->SetCharSplat(L"Status", L"OK");
			break;
		case 0x80:
		    pInst->SetCharSplat(L"Status", L"Degraded");
			break;
		case 0xa0:
		case 0xc0:
		    pInst->SetCharSplat(L"Status", L"Error");
			break;
		case 0x20:
		case 0x40:
		default:
		    pInst->SetCharSplat(L"Status", L"Unknown");
			break;
	}

	pInst->SetDWORD(L"MaxReadable", ppi->MaxValue);
	pInst->SetDWORD(L"MinReadable", ppi->MinValue);
	pInst->SetDWORD(L"Resolution", ppi->Resolution);
	pInst->SetDWORD(L"Tolerance", ppi->Tolerance);
	pInst->SetDWORD(L"Accuracy", ppi->Accuracy);

    return WBEM_S_NO_ERROR;
}
#endif // SMB_PROBES
//==============================================================================



//==============================================================================
// Memory Array class
//------------------------------------------------------------------------------
#ifdef SMB_MEMORYARRAY

CWin32MemoryArray	MyMemoryArraySet(PROPSET_NAME_MEMORYARRAY, IDS_CimWin32Namespace);

//
CWin32MemoryArray::CWin32MemoryArray(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32MemoryArray::~CWin32MemoryArray()
{
}

//
HRESULT CWin32MemoryArray::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", L"Memory Array", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PMEMARRAYMAPADDR pmama = (PMEMARRAYMAPADDR) smbios.GetNthStruct(19, instanceNum);

			if (pmama)
			{
				hResult = LoadPropertyValues(pInst, smbios, pmama);

			    // If we were able to get the BIOS properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}
	return hResult;
}

HRESULT CWin32MemoryArray::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        //PMEMARRAYMAPADDR pmama = (PMEMARRAYMAPADDR) smbios.GetFirstStruct(19);
        PSTLIST			pstl = smbios.GetStructList(19);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Memory Array %d", i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PMEMARRAYMAPADDR) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32MemoryArray::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PMEMARRAYMAPADDR pmama)
{
	WCHAR			tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString		sTemp;
	__int64			memaddr;
	PPHYSMEMARRAY	pma;
	PMEMERRORINFO32 pmei;

	pInst->GetCHString(L"DeviceID", sTemp);

    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	SetCreationClassName(pInst);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_MemoryArray);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	memaddr = pmama->Starting_Address;
	swprintf(tempstr, L"%I64d", memaddr);
	pInst->SetWBEMINT64(IDS_StartingAddress, tempstr);

	memaddr = pmama->Ending_Address;
	swprintf(tempstr, L"%I64d", memaddr);
	pInst->SetWBEMINT64(IDS_EndingAddress, tempstr);

	// Go pickup any error info for this array
	pma = (PPHYSMEMARRAY) smbios.SeekViaHandle(pmama->Memory_Array_Handle);
	if (pma)
	{
		pmei = (PMEMERRORINFO32) smbios.SeekViaHandle(pma->Mem_Error_Info_Handle);

		if (pmei)
		{
			pInst->SetDWORD(L"ErrorInfo", pmei->Error_Type);
			if (pmei->Error_Type != 3)
			{
				pInst->SetDWORD(L"ErrorAccess", pmei->Error_Operation);

				memaddr = pmei->Mem_Array_Error_Addr;
				swprintf(tempstr, L"%I64d", memaddr);
				pInst->SetWBEMINT64(L"ErrorAddress", tempstr);

				memaddr = pmei->Error_Resolution;
				swprintf(tempstr, L"%I64d", memaddr);
				pInst->SetWBEMINT64(L"ErrorResolution", tempstr);

				pInst->Setbool(L"CorrectableError", pmei->Error_Type != 0x0e ? true : false);
				pInst->SetDWORD(L"ErrorGranularity", pmei->Error_Granularity);
			}
		}
	}

    return WBEM_S_NO_ERROR;
}
#endif // SMB_MEMORYARRAY
//==============================================================================



//==============================================================================
// Memory Device class
//------------------------------------------------------------------------------
#ifdef SMB_MEMORYDEVICE
CWin32MemoryDevice	MyMemoryDeviceSet(PROPSET_NAME_MEMORYDEVICE, IDS_CimWin32Namespace);

//
CWin32MemoryDevice::CWin32MemoryDevice(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32MemoryDevice::~CWin32MemoryDevice()
{
}

//
HRESULT CWin32MemoryDevice::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", L"Memory Device", &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PMEMDEVICEMAPADDR pmdma = (PMEMDEVICEMAPADDR) smbios.GetNthStruct(20, instanceNum);

			if (pmdma)
			{
				hResult = LoadPropertyValues(pInst, smbios, pmdma);

			    // If we were able to get the BIOS properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CWin32MemoryDevice::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        //PMEMDEVICEMAPADDR pmdma = (PMEMDEVICEMAPADDR) smbios.GetFirstStruct(20);
        PSTLIST			pstl = smbios.GetStructList(20);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"Memory Device %d", i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PMEMDEVICEMAPADDR) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

HRESULT CWin32MemoryDevice::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PMEMDEVICEMAPADDR pmdma)
{
	WCHAR			tempstr[ MIF_STRING_LENGTH + 1 ];
	CHString		sTemp;
	__int64			memaddr;
	PMEMDEVICE		pmd;
	PMEMERRORINFO32 pmei;

	pInst->GetCHString(L"DeviceID", sTemp);

    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());
	SetCreationClassName(pInst);

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_MemoryDevice);

	pInst->SetCHString(IDS_Name, sTemp2);
	pInst->SetCHString(IDS_Caption, sTemp2);
	pInst->SetCHString(IDS_Description, sTemp2);

	memaddr = pmdma->Starting_Address;
	swprintf(tempstr, L"%I64d", memaddr);
	pInst->SetWBEMINT64(IDS_StartingAddress, tempstr);

	memaddr = pmdma->Ending_Address;
	swprintf(tempstr, L"%I64d", memaddr);
	pInst->SetWBEMINT64(IDS_EndingAddress, tempstr);

	// Go pickup any error info for this device
	pmd = (PMEMDEVICE) smbios.SeekViaHandle(pmdma->Memory_Device_Handle);
	if (pmd)
	{
		pmei = (PMEMERRORINFO32) smbios.SeekViaHandle(pmd->Mem_Error_Info_Handle);

		if (pmei)
		{
			pInst->SetDWORD(L"ErrorInfo", pmei->Error_Type);
			if (pmei->Error_Type != 3)
			{
				pInst->SetDWORD(L"ErrorAccess", pmei->Error_Operation);

				memaddr = pmei->Device_Error_Addr;
				swprintf(tempstr, L"%I64d", memaddr);
				pInst->SetWBEMINT64(L"ErrorAddress", tempstr);

				memaddr = pmei->Error_Resolution;
				swprintf(tempstr, L"%I64d", memaddr);
				pInst->SetWBEMINT64(L"ErrorResolution", tempstr);

				pInst->Setbool(L"CorrectableError", pmei->Error_Type != 0x0e ? true : false);
				pInst->SetDWORD(L"ErrorGranularity", pmei->Error_Granularity);
			}
		}
	}

    return WBEM_S_NO_ERROR;
}
#endif // SMB_MEMORYDEVICE
//==============================================================================

//==============================================================================
// Probes class
//------------------------------------------------------------------------------
#ifdef SMB_COOLINGDEVICE

//
CCimCoolingDevice		MyFanSet(PROPSET_NAME_FAN, IDS_CimWin32Namespace,
							27, L"Fan");
//
CCimCoolingDevice		MyHeatPipeSet(PROPSET_NAME_HEATPIPE, IDS_CimWin32Namespace,
							27, L"Heat Pipe");
//
CCimCoolingDevice		MyRefrigeration(PROPSET_NAME_REFRIG, IDS_CimWin32Namespace,
							27, L"Refrigeration");
//
CCimCoolingDevice::CCimCoolingDevice(
									 LPCWSTR strName,
									 LPCWSTR pszNamespace,
									 UINT StructType,
									 LPCWSTR strTag)
:	Provider(strName, pszNamespace)
{
	m_StructType = StructType;
	m_TagName = pszNamespace;
}

//
CCimCoolingDevice::~CCimCoolingDevice()
{
}

//
HRESULT CCimCoolingDevice::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult = WBEM_E_NOT_FOUND;
	UINT		instanceNum;

	if (ValidateTagProperty(pInst, L"DeviceID", m_TagName, &instanceNum))
	{
	    CSMBios smbios;

	    // Get the previous __RELPATH
	    GetLocalInstancePath(pInst, strPathBefore);

	    if (smbios.Init())
	    {
	        PCOOLINGDEVICE pcd = (PCOOLINGDEVICE) smbios.GetNthStruct((BYTE)m_StructType, instanceNum);

			if (pcd)
			{
				hResult = LoadPropertyValues(pInst, smbios, pcd);

			    // If we were able to get the properties but the new __RELPATH doesn't
			    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
			    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
			        strPathAfter.CompareNoCase(strPathBefore) != 0))
				{
			        hResult = WBEM_E_NOT_FOUND;
				}
			}
		}
		else
		{
			hResult = smbios.GetWbemResult();
		}
	}

	return hResult;
}

HRESULT CCimCoolingDevice::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

    if (smbios.Init())
    {
        int 			i;
		CHString		sTemp;
        PSTLIST			pstl = smbios.GetStructList((BYTE)m_StructType);

		CInstancePtr pInst;

		for (i = 0; pstl != NULL && i < 1000; i++)
		{
			pInst.Attach(CreateNewInstance(pMethodContext));

			sTemp.Format(L"%s %d", m_TagName, i);
			pInst->SetCharSplat(L"DeviceID", sTemp);

			if ((hResult = LoadPropertyValues(pInst, smbios, (PCOOLINGDEVICE) pstl->pshf)) == WBEM_S_NO_ERROR)
			{
				hResult = pInst->Commit();
			}
			pstl = pstl->next;
        }
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;
}

//
HRESULT CCimCoolingDevice::LoadPropertyValues(CInstance *pInst, CSMBios &smbios, PCOOLINGDEVICE pcd)
{
	HRESULT		hResult;
	CHString	sTemp,
				sClass;
    BOOL        bActive;

	// validate device type
    switch(pcd->Type_Status & 0x1F)
	{
		// fan types
        case 3: // Fan
        case 4: // Centrifugal blower
        case 5: // Chip fan
        case 6: // Cabinet fan
        case 7: // Power supply fan
			sTemp = PROPSET_NAME_FAN;
            bActive = TRUE;
			break;

		// heat pipe
		case 8:
			sTemp = PROPSET_NAME_HEATPIPE;
            bActive = FALSE;
			break;

		// refrigeration
		case 9:
			sTemp = PROPSET_NAME_REFRIG;
            bActive = TRUE;
			break;

        case 20: // Active cooling
        case 21: // Passive cooling
		default:
			// We don't know what kind of device this is, so get out.
            return WBEM_E_NOT_FOUND;
	}

	pInst->GetCHString(L"__CLASS", sClass);

    if (sTemp.CompareNoCase(sClass) == 0)
	{
		// Get the status and availability.
        CHString    strStatus;
        int         iAvailabilty;

        switch(pcd->Type_Status >> 5)
        {
            case 4: // Non-critical
            case 1: // Other
            default:
                strStatus = L"Other";
                iAvailabilty = 1;
                break;

            case 2: // Unknown
                strStatus = L"Unknown";
                iAvailabilty = 2;
                break;

            case 3: // OK
                strStatus = L"OK";
                iAvailabilty = 3;
                break;

            case 5: // Critical
            case 6: // Non-recoverable
                strStatus = L"Error";
                iAvailabilty = 1;
                break;
        }

        pInst->SetCharSplat(L"Status", strStatus);
        pInst->SetDWORD(L"Availability", iAvailabilty);

  	    // We'll assume it's always enabled if SMBIOS is reporting it.
        pInst->SetDWORD(L"StatusInfo", 2);

        SetCreationClassName(pInst);
	    pInst->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");
  	    pInst->SetCharSplat(IDS_SystemName, GetLocalComputerName());

        CHString sTemp2;
        LoadStringW(sTemp2, IDR_CoolingDevice);

		pInst->SetCHString(IDS_Name, sTemp2);
		pInst->SetCHString(IDS_Caption, sTemp2);
		pInst->SetCHString(IDS_Description, sTemp2);
        pInst->Setbool(L"ActiveCooling", bActive);

		hResult = WBEM_S_NO_ERROR;
	}
	else
	{
		hResult = WBEM_E_NOT_FOUND;
	}

    return hResult;
}

#endif // SMB_COOLINGDEVICE
//==============================================================================


//==============================================================================
// OEM Bucket class
//------------------------------------------------------------------------------
#ifdef SMB_OEMBUCKET
//CWin32OEMBucket	MyOEMBucket(PROPSET_NAME_OEMBUCKET, IDS_CimWin32Namespace);
CWin32OEMBucket	MyOEMBucket(PROPSET_NAME_OEMBUCKET, L"root\\VendorSpecific");

//
CWin32OEMBucket::CWin32OEMBucket(LPCWSTR strName, LPCWSTR pszNamespace)
:	Provider(strName, pszNamespace)
{
}

//
CWin32OEMBucket::~CWin32OEMBucket()
{
}

//
HRESULT CWin32OEMBucket::GetObject(CInstance *pInst, long lFlags /*= 0L*/)
{
    CHString    strPathBefore,
                strPathAfter;
    HRESULT     hResult;
    CSMBios		smbios;

    // Get the previous __RELPATH
    GetLocalInstancePath(pInst, strPathBefore);

    if (smbios.Init())
    {
		hResult = LoadPropertyValues(pInst, smbios);
	}

    // If we were able to get the properties but the new __RELPATH doesn't
    // match the old __RELPATH, return WBEM_E_NOT_FOUND.
    if (SUCCEEDED(hResult) && (!GetLocalInstancePath(pInst, strPathAfter) ||
        strPathAfter.CompareNoCase(strPathBefore) != 0))
	{
        hResult = WBEM_E_NOT_FOUND;
	}

	return hResult;
}

HRESULT CWin32OEMBucket::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
	HRESULT		hResult = WBEM_E_NOT_FOUND;
    CSMBios		smbios;

	if (smbios.Init())
    {
		CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

		pInst->SetCharSplat(L"InstanceName", L"OEM Bucket");
		if ((hResult = LoadPropertyValues(pInst, smbios)) == WBEM_S_NO_ERROR)
		{
			hResult = pInst->Commit();
		}
	}
	else
	{
		hResult = smbios.GetWbemResult();
	}

	return hResult;

}

HRESULT CWin32OEMBucket::LoadPropertyValues(CInstance *pInst, CSMBios &smbios)
{
	WCHAR		tempstr[ MIF_STRING_LENGTH + 1 ];
	PSTLIST		pstl;

    pstl = smbios.GetStructList(0);

	if (pstl)
	{
		PBIOSINFO pbi = (PBIOSINFO) pstl->pshf;

		pInst->SetDWORD(L"Type0_BIOSVendorBits", *(WORD *) &pbi->BIOS_Characteristics[ 4 ]);
		pInst->SetDWORD(L"Type0_SystemVendorBits", *(WORD *) &pbi->BIOS_Characteristics[ 6 ]);
	}

   	pstl = smbios.GetStructList(3);

	if (pstl)
	{
    	PENCLOSURE pe = (PENCLOSURE) pstl->pshf;

		if (pe->Length > (PBYTE) &pe->OEM_Defined - (PBYTE) pe)
		{
			pInst->SetDWORD(L"Type3_OEMDefined", pe->OEM_Defined);
		}
	}

   	pstl = smbios.GetStructList(11);

	if (pstl)
	{
		SAFEARRAYBOUND	sab;
		POEMSTRINGS     poem = (POEMSTRINGS) pstl->pshf;
        variant_t       vStrings;

		sab.lLbound = 0;
		sab.cElements = poem->Count;
		if (V_ARRAY(&vStrings) = SafeArrayCreate(VT_BSTR, 1, &sab))
		{
			for (int i = 0; i < poem->Count; i++)
			{
				_bstr_t bstr;

				smbios.GetStringAtOffset((PSHF) poem, tempstr, i + 1);
				bstr = tempstr;
				SafeArrayPutElement(V_ARRAY(&vStrings), (long *) &i, (LPVOID) (BSTR) bstr);
			}

            pInst->SetStringArray(L"Type11_OEMStrings", *V_ARRAY(&vStrings));
		}
    }

	// this really stinks but I have to count how many structures there are
	// allocating the array
	SAFEARRAYBOUND	sab;
    int				count;
    DWORD			dval;

    sab.lLbound = 0;
    sab.cElements = smbios.GetStructCount(22);

    if (sab.cElements > 0)
    {
	    variant_t vVals;

        pstl = smbios.GetStructList(22);

	    if (V_ARRAY(&vVals) = SafeArrayCreate(VT_I4, 1, &sab))
	    {
		    PPORTABLEBATTERY ppb;

			V_VT(&vVals) = VT_ARRAY | VT_I4;

			for (count = 0; pstl && count < sab.cElements; count++)
			{
			    ppb = (PPORTABLEBATTERY) pstl->pshf;
				dval = ppb->Length > ((PBYTE) &ppb->OEM_Specific - (PBYTE) ppb) ? ppb->OEM_Specific : 0;
				SafeArrayPutElement(V_ARRAY(&vVals), (long *) &count, &dval);
				pstl = pstl->next;
			}

			pInst->SetVariant(L"Type22_OEMSpecific", vVals);
		}
	}


    sab.cElements = smbios.GetStructCount(26);
    if (sab.cElements > 0)
    {
	    variant_t vVals;

	    pstl = smbios.GetStructList(26);
	    if (V_ARRAY(&vVals) = SafeArrayCreate(VT_I4, 1, &sab))
	    {
		    PPROBEINFO ppi;

		    V_VT(&vVals) = VT_ARRAY | VT_I4;

		    for (count = 0; pstl && count < sab.cElements; count++)
		    {
			    ppi = (PPROBEINFO) pstl->pshf;
			    dval = ppi->Length > ((PBYTE) &ppi->OEM_Defined - (PBYTE) ppi) ? ppi->OEM_Defined : 0;
			    SafeArrayPutElement(V_ARRAY(&vVals), (long *) &count, &dval);
			    pstl = pstl->next;
		    }

		    pInst->SetVariant(L"Type26_OEMDefined", vVals);
	    }
    }

    sab.cElements = smbios.GetStructCount(28);
    if (sab.cElements > 0)
    {
	    variant_t vVals;

	    pstl = smbios.GetStructList(28);
	    if (V_ARRAY(&vVals) = SafeArrayCreate(VT_I4, 1, &sab))
	    {
		    PPROBEINFO ppi;

		    V_VT(&vVals) = VT_ARRAY | VT_I4;

		    for (count = 0; pstl && count < sab.cElements; count++)
		    {
			    ppi = (PPROBEINFO) pstl->pshf;
			    dval = ppi->Length > ((PBYTE) &ppi->OEM_Defined - (PBYTE) ppi) ? ppi->OEM_Defined : 0;
			    SafeArrayPutElement(V_ARRAY(&vVals), (long *) &count, &dval);
			    pstl = pstl->next;
		    }
		    pInst->SetVariant(L"Type28_OEMDefined", vVals);
	    }
    }

	sab.cElements = smbios.GetStructCount(29);
	if (sab.cElements > 0)
	{
	    variant_t vVals;

	    pstl = smbios.GetStructList(29);

	    if (V_ARRAY(&vVals) = SafeArrayCreate(VT_I4, 1, &sab))
	    {
	        PPROBEINFO ppi;

		    V_VT(&vVals) = VT_ARRAY | VT_I4;

		    for (count = 0; pstl && count < sab.cElements; count++)
		    {
			    ppi = (PPROBEINFO) pstl->pshf;
			    dval = ppi->Length > ((PBYTE) &ppi->OEM_Defined - (PBYTE) ppi) ? ppi->OEM_Defined : 0;
			    SafeArrayPutElement(V_ARRAY(&vVals), (long *) &count, &dval);
			    pstl = pstl->next;
		    }
		    pInst->SetVariant(L"Type29_OEMDefined", vVals);
	    }
    }

	return WBEM_S_NO_ERROR;
}
#endif // SMB_OEMBUCKET
//==============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\smbassoc.h ===
//=================================================================

//

// SmbAssoc.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#define  PROPSET_NAME_ASSOCPROCMEMORY L"Win32_AssociatedProcessorMemory"

class CWin32AssocProcMemory : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32AssocProcMemory(LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32AssocProcMemory( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};



#define  PROPSET_NAME_MEMORYDEVICELOCATION L"Win32_MemoryDeviceLocation"

class CWin32MemoryDeviceLocation : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryDeviceLocation( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32MemoryDeviceLocation( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};



#define  PROPSET_NAME_MEMORYARRAYLOCATION L"Win32_MemoryArrayLocation"

class CWin32MemoryArrayLocation : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryArrayLocation( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32MemoryArrayLocation( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};


#define  PROPSET_NAME_PHYSICALMEMORYLOCATION L"Win32_PhysicalMemoryLocation"

class CWin32PhysicalMemoryLocation : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PhysicalMemoryLocation( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32PhysicalMemoryLocation( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};


#define  PROPSET_NAME_MEMDEVICEARRAY L"Win32_MemoryDeviceArray"

class CWin32MemoryDeviceArray : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryDeviceArray( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32MemoryDeviceArray( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, long lFlags = 0L ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\smbiosprov.h ===
//=================================================================

//

// SmbiosProv.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

// Property set identification
//============================
#define PROPSET_NAME_SYSTEMPRODUCT		L"Win32_ComputerSystemProduct"
#define PROPSET_NAME_BASEBOARD			L"Win32_BaseBoard"
#define PROPSET_NAME_SYSTEMENCLOSURE	L"Win32_SystemEnclosure"
#define	PROPSET_NAME_CACHEMEMORY		L"Win32_CacheMemory" 
#define	PROPSET_NAME_PORTCONNECTOR		L"Win32_PortConnector" 
#define	PROPSET_NAME_SYSTEMSLOT			L"Win32_SystemSlot" 
//#define	PROPSET_NAME_BIOSLANG			L"Win32_BiosLanguage" 
#define PROPSET_NAME_PHYSMEMARRAY		L"Win32_PhysicalMemoryArray"
#define PROPSET_NAME_PHYSICALMEMORY		L"Win32_PhysicalMemory"
#define PROPSET_NAME_MEMERROR32			L"Win32_MemoryError32"
#define PROPSET_NAME_PORTABLEBATTERY	L"Win32_PortableBattery"
#define PROPSET_NAME_CURRENTPROBE		L"Win32_CurrentProbe"
#define PROPSET_NAME_TEMPPROBE			L"Win32_TemperatureProbe"
#define PROPSET_NAME_VOLTPROBE			L"Win32_VoltageProbe"
#define PROPSET_NAME_FAN				L"Win32_Fan"
#define PROPSET_NAME_HEATPIPE			L"Win32_HeatPipe"
#define PROPSET_NAME_REFRIG				L"Win32_Refrigeration"
#define PROPSET_NAME_MEMORYDEVICE		L"Win32_MemoryDevice"
#define PROPSET_NAME_MEMORYARRAY		L"Win32_MemoryArray"
#define PROPSET_NAME_ONBOARDDEVICE		L"Win32_OnBoardDevice"
#define PROPSET_NAME_OEMBUCKET			L"Win32_OEMBucket"



class CWin32SystemProduct : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32SystemProduct( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32SystemProduct( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PSYSTEMINFO psi );

};

class CWin32BaseBoard : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32BaseBoard( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32BaseBoard( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PBOARDINFO pbi );

};

class CWin32SystemEnclosure : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32SystemEnclosure( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32SystemEnclosure( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PENCLOSURE pe );
};



class CWin32CacheMemory : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32CacheMemory( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32CacheMemory( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PCACHEINFO pci );
        //HRESULT LoadPropertyValues( CInstance* pInstance ) ;

};

class CWin32SystemSlot : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32SystemSlot( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32SystemSlot() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PSYSTEMSLOTS pss );
        //HRESULT LoadPropertyValues( CInstance* pInstance ) ;
};

class CWin32OnBoardDevice : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32OnBoardDevice( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32OnBoardDevice( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PSHF pshf, UINT instanceNum );
};


class CWin32PortConnector : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PortConnector( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32PortConnector( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PPORTCONNECTORINFO ppci );
};

//class CWin32BIOSLanguage : public Provider
//{
//
//    public:
//
//        // Constructor/destructor
//        //=======================
//
//        CWin32BIOSLanguage( LPCWSTR strName, LPCWSTR pszNamespace );
//       ~CWin32BIOSLanguage( );
//
//        // Functions provide properties with current values
//        //=================================================
//
//        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
//        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
//
//        // Utility
//        //========
//
//        DWORD			m_dwPlatformId;
//
//        // Utility function(s)
//        //====================
//
//		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PBIOSLANGINFO pbli );
//};


class CWin32PhysicalMemory : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PhysicalMemory( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32PhysicalMemory( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		//HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PMEMDEVICE pmd );
		HRESULT LoadPropertyValues_MD( CInstance* pInstance, CSMBios &smbios, PMEMDEVICE pmd );
		HRESULT LoadPropertyValues_MI( CInstance* pInstance, CSMBios &smbios, PMEMMODULEINFO pmmi );
};


class CWin32PhysMemoryArray : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PhysMemoryArray( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32PhysMemoryArray( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility
        //========

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues_PMA( CInstance* pInstance, CSMBios &smbios, PPHYSMEMARRAY ppma );
		HRESULT LoadPropertyValues_MCI( CInstance* pInstance, CSMBios &smbios, PMEMCONTROLINFO pmci );
};

class CWin32PortableBattery : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32PortableBattery( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32PortableBattery( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility
        //========

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PPORTABLEBATTERY ppb );
};

class CCimNumericSensor : public Provider
{

    public:

        // Constructor/destructor
        //=======================

		CCimNumericSensor( LPCWSTR strName, LPCWSTR pszNamespace, UINT StructType, LPCWSTR strTag );
        //CCimSensor( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CCimNumericSensor( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:		

        // Utility function(s)
        //====================
		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PPROBEINFO ppi );

		UINT	m_StructType;
		CHString m_TagName;
	
};


class CWin32MemoryArray : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryArray( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32MemoryArray( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PMEMARRAYMAPADDR pmama );
};

class CWin32MemoryDevice : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32MemoryDevice( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32MemoryDevice( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PMEMDEVICEMAPADDR pmdma );
};

class CCimCoolingDevice : public Provider
{

    public:

        // Constructor/destructor
        //=======================

		CCimCoolingDevice( LPCWSTR strName, LPCWSTR pszNamespace, UINT StructType, LPCWSTR strTag );
       ~CCimCoolingDevice( ) ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:		

        // Utility function(s)
        //====================
		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios, PCOOLINGDEVICE pcd );

		UINT	m_StructType;
		CHString m_TagName;
	
};


class CWin32OEMBucket : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32OEMBucket( LPCWSTR strName, LPCWSTR pszNamespace );
       ~CWin32OEMBucket( );

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility function(s)
        //====================

		HRESULT LoadPropertyValues( CInstance* pInstance, CSMBios &smbios );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\smbtocim.h ===
//==============================================================================

// SMBIOS --> CIM array mappings

// 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _SMBTOCIM_
#define _SMBTOCIM_

// add mapper ids here
typedef enum
{
	SlotType = 0,
	ConnectorType,
	ConnectorGender,
	FormFactor,
	MemoryType

} CIMMAPPERS;


UINT GetCimVal( CIMMAPPERS arrayid, UINT smb_val );

#endif	// _SMBTOCIM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\smbtocim.cpp ===
//==============================================================================

// SMBIOS --> CIM array mappings

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "smbtocim.h"

typedef struct tagCIM_MAP_PAIRS
{
	UINT	smb_val;
	UINT	cim_val;

} CIM_MAP_PAIRS, *PCIM_MAP_PAIRS;


typedef struct tagCIM_MAP_ARRAY
{
	PCIM_MAP_PAIRS	array;
	UINT			length;

} CIM_MAP_ARRAY, *PCIM_MAP_ARRAY;



CIM_MAP_PAIRS g_SlotTypeMapPairs[] =
{
	{ 0x01, 00 },		// Other
	{ 0x02, 00 },		// Unknown
	{ 0x03, 44 },		// ISA
	{ 0x04,	01 },		// MCA
	{ 0x05,	45 },		// EISA
	{ 0x06, 43 },		// PCI
	{ 0x07, 47 },		// PC Card (PCMCIA)
	{ 0x08, 46 },		// VL-VESA
	{ 0x09, 01 },		// Proprietary
	{ 0x0A, 76 },		// Processor Card Slot
	{ 0x0B, 77 },		// Proprietary Memory Card Slot
	{ 0x0C, 78 },		// I/O Riser Card Slot
	{ 0x0D, 65 },		// NuBus
	{ 0x0E, 79 },		// PCI - 66MHz Capable
	{ 0x0F, 73 },		// AGP
	{ 0x10, 80 },		// AGP 2X
	{ 0x11, 81 },		// AGP 4X
	{ 0xA0, 82 },		// PC-98/C20
	{ 0xA1, 83 },		// PC-98/C24
	{ 0xA2, 84 },	 	// PC-98/E
	{ 0xA3, 85 },		// PC-98/Local Bus
	{ 0xA4, 86 },		// PC-98/Card
};


CIM_MAP_PAIRS g_ConnectorTypeMapPairs[] =
{
	{ 0x00, 00 },		// None
	{ 0x01, 66 },		// Centronics
	{ 0x02, 67 },		// Mini Centronics
	{ 0x03, 01 },		// Proprietary
	{ 0x04, 23 },		// DB-25 pin male
	{ 0x05, 23 },		// DB-25 pin female
	{ 0x06, 22 },		// DB-15  pin male
	{ 0x07, 22 },		// DB-15 pin female
	{ 0x08, 21 },		// DB-9 pin male
	{ 0x09, 21 },		// DB-9  pin female
	{ 0x0A, 38 },		// RJ-11
	{ 0x0B, 39 },		// RJ-45
	{ 0x0C, 06 },		// 50 Pin MiniSCSI
	{ 0x0D, 59 },		// Mini-DIN
	{ 0x0E, 60 },		// Micro-DIN
	{ 0x0F, 61 },		// PS/2
	{ 0x10, 62 },		// Infrared
	{ 0x11, 63 },		// HP-HIL
	{ 0x12, 64 },		// Access Bus (USB)
	{ 0x13, 13 },		// SSA SCSI
	{ 0x14, 59 },		// Circular DIN-8 male
	{ 0x15, 59 },		// Circular DIN-8 female
	{ 0x16, 16 },		// On Board IDE
	{ 0x17, 89 },		// On Board Floppy
	{ 0x18, 90 },		// 9 Pin Dual Inline (pin 10 cut)
	{ 0x19, 91 },		// 25 Pin Dual Inline (pin 26 cut)
	{ 0x1A, 92 },		// 50 Pin Dual Inline
	{ 0x1B, 93 },		// 68 Pin  Dual Inline
	{ 0x1C, 94 },		// On Board Sound Input from CD-ROM
	{ 0x1D, 68 },		// Mini-Centronics Type-14
	{ 0x1E, 70 },		// Mini-Centronics Type-26
	{ 0x1F, 88 },		// Mini-jack (headphones)
	{ 0x20, 37 },		// BNC
	{ 0x21, 54 },		// 1394
	{ 0xA0, 83 },		// PC-98
	{ 0xA1, 84 },		// PC-98Hireso
	{ 0xA2, 85 },		// PC-H98
	{ 0xA3, 86 },		// PC-98Note
	{ 0xA4, 87 },		// PC-98Full
};

CIM_MAP_PAIRS g_ConnectorGenderMapPairs[] =
{
	{ 0x00, 00 },		// None
	{ 0x01, 00 },		// Centronics
	{ 0x02, 00 },		// Mini Centronics
	{ 0x03, 00 },		// Proprietary
	{ 0x04, 02 },		// DB-25 pin male
	{ 0x05, 03 },		// DB-25 pin female
	{ 0x06, 02 },		// DB-15  pin male
	{ 0x07, 03 },		// DB-15 pin female
	{ 0x08, 02 },		// DB-9 pin male
	{ 0x09, 03 },		// DB-9  pin female
	{ 0x0A, 00 },		// RJ-11
	{ 0x0B, 00 },		// RJ-45
	{ 0x0C, 00 },		// 50 Pin MiniSCSI
	{ 0x0D, 00 },		// Mini-DIN
	{ 0x0E, 00 },		// Micro-DIN
	{ 0x0F, 00 },		// PS/2
	{ 0x10, 00 },		// Infrared
	{ 0x11, 00 },		// HP-HIL
	{ 0x12, 00 },		// Access Bus (USB)
	{ 0x13, 00 },		// SSA SCSI
	{ 0x14, 02 },		// Circular DIN-8 male
	{ 0x15, 03 },		// Circular DIN-8 female
	{ 0x16, 00 },		// On Board IDE
	{ 0x17, 00 },		// On Board Floppy
	{ 0x18, 00 },		// 9 Pin Dual Inline (pin 10 cut)
	{ 0x19, 00 },		// 25 Pin Dual Inline (pin 26 cut)
	{ 0x1A, 00 },		// 50 Pin Dual Inline
	{ 0x1B, 00 },		// 68 Pin  Dual Inline
	{ 0x1C, 00 },		// On Board Sound Input from CD-ROM
	{ 0x1D, 00 },		// Mini-Centronics Type-14
	{ 0x1E, 00 },		// Mini-Centronics Type-26
	{ 0x1F, 00 },		// Mini-jack (headphones)
	{ 0x20, 00 },		// BNC
	{ 0x21, 00 },		// 1394
	{ 0xA0, 00 },		// PC-98
	{ 0xA1, 00 },		// PC-98Hireso
	{ 0xA2, 00 },		// PC-H98
	{ 0xA3, 00 },		// PC-98Note
	{ 0xA4, 00 },		// PC-98Full
};


CIM_MAP_PAIRS g_FormFactorTypeMapPairs[] =
{
	{ 0x01,	 1 },		// Other
	{ 0x02,	 0 },		// Unknown
	{ 0x03,	 7 },		// SIMM
	{ 0x04,	 2 },		// SIP
	{ 0x05,	 0 },		// Chip
	{ 0x06,	 3 },		// DIP
	{ 0x07,	 4 },		// ZIP
	{ 0x08,	 6 },		// Proprietary Card
	{ 0x09,	 8 },		// DIMM
	{ 0x0A,	 9 },		// TSOP
	{ 0x0B,	 0 },		// Row of chips
	{ 0x0C,	11 },		// RIMM
	{ 0x0D,	12 },		// SODIMM
};


CIM_MAP_PAIRS g_MemoryTypeMapPairs[] =
{
	{ 0x01,  1 },		// Other
	{ 0x02,  0 },		// Unknown
	{ 0x03,  2 },		// DRAM
	{ 0x04,  6 },		// EDRAM
	{ 0x05,  7 },		// VRAM
	{ 0x06,  8 },		// SRAM
	{ 0x07,  9 },		// RAM
	{ 0x08, 10 },		// ROM
	{ 0x09, 11 },		// FLASH
	{ 0x0A, 12 },		// EEPROM
	{ 0x0B, 13 },		// FEPROM
	{ 0x0C, 14 },		// EPROM
	{ 0x0D, 15 },		// CDRAM
	{ 0x0E, 16 },		// 3DRAM
	{ 0x0F, 17 },		// SDRAM
	{ 0x10, 18 },		// SGRAM
};

CIM_MAP_ARRAY g_CimMapArrayList[] =
{
	{ g_SlotTypeMapPairs,        sizeof( g_SlotTypeMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
	{ g_ConnectorTypeMapPairs,   sizeof( g_ConnectorTypeMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
	{ g_ConnectorGenderMapPairs, sizeof( g_ConnectorGenderMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
	{ g_FormFactorTypeMapPairs,  sizeof( g_FormFactorTypeMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
	{ g_MemoryTypeMapPairs,      sizeof( g_MemoryTypeMapPairs ) / sizeof( CIM_MAP_PAIRS ) },
};


UINT GetCimVal( CIMMAPPERS a_arrayid, UINT a_smb_val )
{
	CIM_MAP_PAIRS *t_cimmaparray = g_CimMapArrayList[ a_arrayid ].array ;

	for ( int t_i = 0; t_i < g_CimMapArrayList[ a_arrayid ].length; t_i++ )
	{
		if ( t_cimmaparray->smb_val == a_smb_val )
		{
			return t_cimmaparray->cim_val ;
		}
		t_cimmaparray++ ;
	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\smbstruc.h ===
//=================================================================

//

// SmbStruc.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _SMBSTRUC_H_
#define _SMBSTRUC_H_

// This is file for struct types and their fields.
#include "smbios.h"

#define MIF_STRING_LENGTH	64

typedef struct _STLIST
{
	PSHF	pshf;
	ULONG	size;
	struct _STLIST *next;

} STLIST, *PSTLIST;


typedef struct _STTREE
{
	struct _STTREE *left;
	struct _STTREE *right;
	PSTLIST stlist;
	ULONG	li;

} STTREE, *PSTTREE;

typedef struct _HTREE
{
	struct _HTREE *left;
	struct _HTREE *right;
	PSHF pshf;

} HTREE, *PHTREE;



// SMBIOS data and accessor class
class CSMBios
{
	public:
	    CSMBios( );
		~CSMBios( );

		BOOL	Init( BOOL bRefresh = FALSE );
    // 0xFF means don't look for a certain type.
    //PSHF GetFirstStruct(BYTE cType = 0xFF);
    //PSHF GetNextStruct(BYTE cType = 0xFF);
		PSHF	GetNthStruct( BYTE cType, DWORD Nth );
	    PSHF	SeekViaHandle (WORD handle );
		PSTLIST	GetStructList( BYTE type );
		ULONG	GetStructCount( BYTE type );
	    int		GetStringAtOffset( PSHF pStruct, LPWSTR szString, DWORD dwOffset );
	    DWORD	GetMinorVersion( ) { return LOWORD( m_Version ); }
	    DWORD	GetMajorVersion( ) { return HIWORD( m_Version ); }
	    DWORD	GetVersion( ) { return m_Version;}
	    HRESULT	GetWbemResult( ) { return m_WbemResult; }
		PVOID	Register( VOID );
		LONG	Unregister( VOID );

	private:
		static PVOID	m_pMem;
//    static PSHF    m_pshfCurrent;
		static PSHF		m_pTable;
		static PVOID	m_pSTTree;
		static PVOID	m_pHTree;
	    static ULONG	m_Size;
	    static ULONG	m_Version;
		static ULONG	m_stcount;
        static BOOL     m_bValid;
		HRESULT	m_WbemResult;

	private:
		DWORD	GetTotalStructCount();
		BOOL	BuildStructureTree();
		BOOL	BuildHandleTree();
		PSHF	FirstStructure();
		PSHF	NextStructure( PSHF pshf );
		BOOL	InitData( LPCTSTR szFileName );
	    BOOL	InitData( GUID *pSMBiosGuid );
	    //void	SetVersion();

	    //BOOL IsRightType(BYTE cType);
	    //BOOL IsRightHandle(WORD wHandle);
	    //void MoveNext();
	    void	FreeData( );
		void	CreateInfoFile( );

};


class StructTree
{
	public:
		StructTree( PVOID pMem );
		~StructTree( );

		void Initialize( void );
		PSTTREE InsertStruct( PSHF pshf );
		PSTLIST ListNext( PSTLIST list ) { return list->next; }
		PSTTREE FindAttachNode( BYTE type );

	protected:
		PSTTREE StartTree( PSHF pshf );
		PSTTREE TreeAdd( PSTTREE tree, PSHF pshf );
		PSTLIST StartList( PSHF pshf );
		PSTLIST ListAdd( PSTLIST list, PSHF pshf );

		PSTTREE	m_tree;
		PBYTE	m_allocator;

};


class HandleTree
{
	public:
		HandleTree( PVOID pMem );
		~HandleTree( );

		void Initialize( void );
		PHTREE InsertStruct( PSHF pshf );
		PHTREE FindAttachNode( WORD handle );

	protected:
		PHTREE StartTree( PSHF pshf );
		PHTREE TreeAdd( PHTREE tree, PSHF pshf );

		PHTREE	m_tree;
		PBYTE	m_allocator;

};

#endif	// _SMBSTRUC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\snddevice.h ===
//=================================================================

//

// SndDevice.h

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __SNDDEVICE_H_
#define __SNDDEVICE_H_

#define PROPSET_NAME_SOUNDDEVICE	L"Win32_SoundDevice"

class CWin32SndDevice : public Provider
{
public:

	// constructor/destructor
	CWin32SndDevice ( LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
	virtual ~CWin32SndDevice () ;

    //=================================================
    // Functions provide properties with current values
    //=================================================
	virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;

#ifdef NTONLY
	virtual HRESULT GetObjectNT4( CInstance *a_pInst, long a_lFlags = 0L ) ;
	virtual HRESULT GetObjectNT5( CInstance *a_pInst, long a_lFlags = 0L ) ;
	virtual HRESULT EnumerateInstancesNT4( CWinmmApi &a_WinmmApi , MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
	virtual HRESULT EnumerateInstancesNT5( CWinmmApi &a_WinmmApi , MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
	virtual HRESULT LoadPropertiesNT4( CWinmmApi &a_WinmmApi , CInstance *a_pInst ) ;
	virtual HRESULT LoadPropertiesNT5( CWinmmApi &a_WinmmApi , CInstance *a_pInst ) ;
#endif

	virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;

    void SetCommonCfgMgrProperties(CConfigMgrDevice *pDevice, CInstance *pInstance);

};	// end class CWin32SndDevice

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\snddevice.cpp ===
//=================================================================

//

// SndDevice.cpp

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "DllWrapperBase.h"
#include "WinmmApi.h"
#include "snddevice.h"

// Property set declaration
//=========================
CWin32SndDevice	win32SoundDevice(PROPSET_NAME_SOUNDDEVICE, IDS_CimWin32Namespace );


CWin32SndDevice::CWin32SndDevice (LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

CWin32SndDevice::~CWin32SndDevice ()
{

}

HRESULT CWin32SndDevice::GetObject(CInstance *pInst, long lFlags/* = 0L*/)
{
	HRESULT hResult = WBEM_E_NOT_FOUND;

#ifdef NTONLY
	if (IsWinNT5())
		hResult = GetObjectNT5(pInst, lFlags);
	else
		hResult = GetObjectNT4(pInst, lFlags);
#endif

	return hResult;
}

#ifdef NTONLY
HRESULT CWin32SndDevice::GetObjectNT4 (CInstance *pInst, long lFlags/* = 0L*/)
{
	HRESULT Result = WBEM_E_FAILED;

	CWinmmApi *pWinmmApi = (CWinmmApi *)CResourceManager::sm_TheResourceManager.GetResource (g_guidWinmmApi, NULL);
	if (pWinmmApi)
	{
		Result = LoadPropertiesNT4(*pWinmmApi , pInst);

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidWinmmApi , pWinmmApi);
	}

	return Result;
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::GetObjectNT5(CInstance *pInst, long lFlags)
{
	HRESULT Result = WBEM_E_FAILED;

	CWinmmApi *pWinmmApi = (CWinmmApi *)CResourceManager::sm_TheResourceManager.GetResource (g_guidWinmmApi, NULL);
	if (pWinmmApi)
	{
		Result = LoadPropertiesNT5(*pWinmmApi , pInst);

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidWinmmApi , pWinmmApi);
	}

	return Result;
}
#endif

HRESULT CWin32SndDevice::EnumerateInstances(MethodContext *pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hResult = WBEM_E_FAILED;

#ifdef NTONLY

	CWinmmApi *pWinmmApi = (CWinmmApi *)CResourceManager::sm_TheResourceManager.GetResource (g_guidWinmmApi, NULL);
	if (pWinmmApi)
	{
		if (IsWinNT5())
			hResult = EnumerateInstancesNT5(*pWinmmApi , pMethodContext);
		else
			hResult = EnumerateInstancesNT4(*pWinmmApi , pMethodContext);

		CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidWinmmApi , pWinmmApi);
	}

#endif

	return hResult;
}

#ifdef NTONLY
HRESULT CWin32SndDevice::EnumerateInstancesNT4(CWinmmApi &WinmmApi , MethodContext *pMethodContext, long lFlags)
{
	HRESULT		hResult = WBEM_S_NO_ERROR;

	int nCount = WinmmApi.WinMMwaveOutGetNumDevs();

	for (int i = 0; i < nCount && SUCCEEDED(hResult); i++)
	{
		CHString		str;

		// smart ptr
		CInstancePtr	pInst(CreateNewInstance(pMethodContext), false);

		if (NULL != pInst)
		{
			str.Format(L"%d", i);

			pInst->SetCharSplat(L"DeviceID", str);

			if (SUCCEEDED(hResult = LoadPropertiesNT4(WinmmApi , pInst)))
			{
				hResult = pInst->Commit();
			}
		}
		else
		{
			hResult = WBEM_E_FAILED;
		}
	}

	return hResult;
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::EnumerateInstancesNT5(CWinmmApi &WinmmApi , MethodContext *pMethodContext, long lFlags)
{
	HRESULT             hResult = WBEM_S_NO_ERROR;
	CDeviceCollection   devCollection;
	CConfigManager      configMngr;
	REFPTR_POSITION     pos;

	if (!configMngr.GetDeviceListFilterByClass(devCollection, L"Media"))
	{
		return hResult;
	}

	devCollection.BeginEnum(pos);

	if (!devCollection.GetSize())
	{
		return hResult;
	}

	// smart ptr
	CConfigMgrDevicePtr pDevice;

	// Go through all the Media devices.
	for (	pDevice.Attach(devCollection.GetNext(pos));
			SUCCEEDED(hResult) && (NULL != pDevice);
			pDevice.Attach(devCollection.GetNext(pos)))
	{
		CHString    strDriverKey,
					strFullKey,
					strDeviceID;
		CRegistry   reg;

		// Find out if this device is a WAV device.
		pDevice->GetDriver(strDriverKey);

		strFullKey.Format(
			L"System\\CurrentControlSet\\Control\\Class\\%s\\Drivers\\Wave",
			(LPCWSTR) strDriverKey);

		if (reg.Open(HKEY_LOCAL_MACHINE, strFullKey, KEY_READ) == ERROR_SUCCESS)
		{
			// smart ptr
			CInstancePtr pInst(CreateNewInstance(pMethodContext), false);

			if (NULL != pInst)
			{
				pDevice->GetDeviceID(strDeviceID);

				pInst->SetCHString(L"DeviceID", strDeviceID);

				if (SUCCEEDED(hResult = LoadPropertiesNT5(WinmmApi , pInst)))
				{
					hResult = pInst->Commit();
				}
			}
			else
				hResult = WBEM_E_FAILED;
		}
	}

	return hResult;
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::LoadPropertiesNT4(CWinmmApi &WinmmApi , CInstance *pInst)
{
	// LoadPropertiesNT5 was designed to work for both.
	return LoadPropertiesNT5(WinmmApi , pInst);
}
#endif

#ifdef NTONLY
HRESULT CWin32SndDevice::LoadPropertiesNT5(CWinmmApi &WinmmApi , CInstance *pInst)
{
	CHString			strDeviceID,
						strDesc;
	CConfigManager		configMngr;

	pInst->GetCHString(L"DeviceID", strDeviceID);

	if (strDeviceID.IsEmpty())
	{
		return WBEM_E_NOT_FOUND;
	}

	// smart ptr
	CConfigMgrDevicePtr pDevice;

	if (configMngr.LocateDevice(strDeviceID, pDevice))
	{
		pDevice->GetDeviceDesc(strDesc);
	}
	else
	{
		// If we can't find it in the device manager, maybe we just got it
		// from the wave APIs.
		WAVEOUTCAPS caps;
		int			iWhich = _wtoi(strDeviceID);

		// Make sure this string only has numbers.
		for (int i = 0; i < strDeviceID.GetLength(); i++)
		{
			if (!_istdigit(strDeviceID[ i ]))
			{
				return WBEM_E_NOT_FOUND;
			}
		}

		if (WinmmApi.WinmmwaveOutGetDevCaps(iWhich, &caps, sizeof(caps)) != MMSYSERR_NOERROR)
		{
			return WBEM_E_NOT_FOUND;
		}
		strDesc = caps.szPname;
	}

    // We want to make this call even if pDevice is NULL.
    SetCommonCfgMgrProperties(pDevice, pInst);

	// Now we have a valid name, so put it in the instance.
	pInst->SetCHString(L"Caption", strDesc);
	pInst->SetCHString(L"Name", strDesc);
	pInst->SetCHString(L"ProductName", strDesc);
	pInst->SetCHString(L"Description", strDesc);

	return WBEM_S_NO_ERROR;
}
#endif

void CWin32SndDevice::SetCommonCfgMgrProperties(
    CConfigMgrDevice *pDevice,
    CInstance *pInstance)
{
    // 2 means we don't know if the device is enabled or not.
    DWORD       dwStatusInfo = 2;
    CHString    strInfo = L"Unknown";

    if (pDevice)
    {
        CHString strTemp;

        SetConfigMgrProperties(pDevice, pInstance);

	    if (pDevice->GetStatus(strInfo))
	    {
	        if (strInfo == L"OK")
		    {
                // Means the device is enabled.
                dwStatusInfo = 3;
            }
	    }

        if (pDevice->GetMfg(strTemp))
            pInstance->SetCharSplat(L"Manufacturer", strTemp);
    }

    pInstance->SetCHString(L"Status", strInfo);


    // Other common properties

    pInstance->SetDWORD(L"StatusInfo", dwStatusInfo);

	// CreationClassName
	SetCreationClassName(pInstance);

	// PowerManagementSupported
	pInstance->Setbool(IDS_PowerManagementSupported, FALSE);

	// SystemCreationClassName
	pInstance->SetCharSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");

	// SystemName
	pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include ..\..\..\..\common\makefile.cmn
SOURCES_USED=..\..\..\..\common\makefile.cmn

TARGETNAME=cimwin32

TARGETPATH=obj
TARGETTYPE=DYNLINK

INCLUDES=$(INCLUDES); \
	$(COMMON_NEWTHROW_INC); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
	$(CIMWIN32_LIB_INC); \
	$(WMIIDL_INC); \
	$(CRT_INC_PATH); \
	$(FRAMEDYN_PRIVATE); \
	$(NET_INC_PATH); \
	$(BASE_INC_PATH); \
        $(MDHELPPROX_INC_PATH); \
        $(SHELL_INC_PATH); \
        $(SHELL_INC_PATH)\imapi; \
	$(DS_INC_PATH); \
        $(BASEDIR)\public\internal\net\inc


# PRESOURCES must have precomp.h as the first #include in the file.
# There cannot be any #defines before the #include.
PRESOURCES=$(PRESOURCES) \
	..\1394.cpp \
	..\AutochkSetting.cpp \
	..\Battery.cpp \
	..\bios.cpp \
	..\BootConfig.cpp \
	..\bservice.cpp \
	..\bus.cpp \
	..\cadapters.cpp \
	..\CIMDataFile.cpp \
	..\CIMLogicalDevice_CIMDataFile.cpp \
	..\cNetConn.cpp \
	..\CodecFile.cpp \
	..\COMObjSecRegKey.cpp \
	..\ComputerSystem.cpp \
	..\cpuid.cpp \
        ..\DelayLoadHandler.cpp \
	..\dependentservice.cpp \
	..\desktop.cpp \
	..\DesktopMonitor.cpp \
	..\devbattery.cpp \
	..\devbus.cpp \
	..\DeviceMemory.cpp \
	..\devid.cpp \
	..\DhcpcsvcApi.cpp \
	..\dhcpinfo.cpp \
	..\Directory.cpp \
	..\DirectoryContainsFile.cpp \
	..\diskdrive.cpp \
	..\displaycfg.cpp \
	..\displayctrlcfg.cpp \
	..\DriverForDevice.cpp \
	..\elementsetting.cpp \
	..\Environment.cpp \
	..\FileFile.cpp \
	..\Floppy.cpp \
	..\FloppyController.cpp \
	..\group.cpp \
	..\GroupUser.cpp \
	..\IDE.cpp \
	..\IRQ.cpp \
	..\Implement_LogicalFile.cpp \
	..\InfraRed.cpp \
	..\Keyboard.cpp \
	..\loaddepends.cpp \
	..\loadmember.cpp \
	..\loadorder.cpp \
	..\logdiskpartition.cpp \
	..\LogicalDisk.cpp \
	..\LogicalMemory.cpp \
	..\LogicalProgramGroup.cpp \
	..\LogicalProgramGroupItem.cpp \
	..\LogicalShareAccess.cpp \
	..\LogicalShareAudit.cpp \
	..\loginprofile.cpp \
	..\motherboard.cpp \
	..\MSINFO_cdrom.cpp \
	..\multimonitor.cpp \
	..\netadapter.cpp \
	..\netadaptercfg.cpp \
	..\netclient.cpp \
	..\NetConn.cpp \
	..\ntlastboottime.cpp \
	..\os.cpp \
	..\PageFile.cpp \
	..\PageFileSetting.cpp \
	..\Parallelport.cpp \
	..\pcmcia.cpp \
	..\pointer.cpp \
	..\port.cpp \
	..\Power.cpp \
	..\PowerManagement.cpp \
	..\Printer.cpp \
	..\Printerdriver2.cpp \
	..\Printerport.cpp \
	..\PrnUtil.cpp \
	..\PrnInterface.cpp \
	..\printercfg.cpp \
	..\printercontroller.cpp \
	..\printerdriver.cpp \
	..\printershare.cpp \
	..\printjob.cpp \
	..\processor.cpp \
	..\programgroup.cpp \
	..\protocolbinding.cpp \
	..\Qfe.cpp \
	..\recovery.cpp \
	..\schedjob.cpp \
	..\serialportcfg.cpp \
	..\service.cpp \
	..\share.cpp \
	..\ShareToDir.cpp \
	..\ShortcutFile.cpp \
	..\ShortcutHelper.cpp \
	..\SmbAssoc.cpp \
	..\SmbiosProv.cpp \
	..\smbstruc.cpp \
	..\SmbToCim.cpp \
	..\snddevice.cpp \
	..\startupcommand.cpp \
	..\systemaccount.cpp \
	..\systemdriver.cpp \
	..\SystemName.cpp \
	..\threadprov.cpp \
	..\timezone.cpp \
	..\usb.cpp \
	..\user.cpp \
	..\videocontroller.cpp \
	..\videocontrollerresolution.cpp \
	..\videosettings.cpp \
	..\VXD.cpp \
	..\wavedevcfg.cpp \
	..\WbemNTthread.cpp \
	..\WBEMToolH.cpp \
	..\WDMBase.cpp \
	..\Win32_1394ControllerDevice.cpp \
	..\Win32_ClassicCOMApplicationClasses.cpp \
	..\Win32_ClassicCOMClass.cpp \
	..\Win32_ClassicCOMClassSetting.cpp \
	..\Win32_ClassicCOMClassSettings.cpp \
	..\Win32_ClientApplicationSetting.cpp \
	..\Win32_COMApplicationSettings.cpp \
	..\Win32_COMClassAutoEmulator.cpp \
	..\Win32_COMClassEmulator.cpp \
	..\Win32_ComponentCategory.cpp \
	..\Win32_DCOMApplication.cpp \
	..\Win32_DCOMApplicationAccessAllowedSetting.cpp \
	..\Win32_DCOMApplicationLaunchAllowedSetting.cpp \
	..\Win32_DCOMApplicationSetting.cpp \
	..\Win32_ImplementedCategory.cpp \
	..\Win32IDEControllerDevice.cpp \
	..\Win32LogicalDiskRootWin32Directory.cpp \
	..\win32logicalsharesecuritysetting.cpp \
	..\Win32ProgramGroupContents.cpp \
	..\Win32ProgramGroupItemDataFile.cpp \
	..\Win32ProgramGroupWin32Directory.cpp \
	..\Win32SCSIControllerDevice.cpp \
	..\Win32SecuritySettingofLogicalShare.cpp \
	..\Win32SubDirectory.cpp \
	..\WIN32SystemDriverPNPEntity.cpp \
	..\Win32SystemUsers.cpp \
	..\Win32USBControllerDevice.cpp \
	..\modem.cpp \
	..\protocol.cpp \
        ..\SystemConfigChange.cpp    \
	..\DMA.cpp \
	..\PNPEntity.cpp \
	..\devres.cpp \
	..\usebinding.cpp \
	..\useassoc.cpp \
	..\win32allocatedresource.cpp \
	..\cdrom.cpp \
	..\Scsi.cpp \
	..\serialport.cpp \
	..\TapeDrive.cpp \


# NTSOURCES must have exactly the following items
# before #include "precomp.h"
#
# #include <nt.h>
# #include <ntrtl.h>
# #include <nturtl.h>
# #include <ntobapi.h>
#
# #define _WINNT_	// have what is needed from above

NTSOURCES=$(NTSOURCES) \
	..\KUserdata.cpp \
	..\nvram.cpp \
	..\ntdriverio.cpp \
	..\PageFileUsage.cpp \
	..\regcfg.cpp \
	..\CProcess.cpp \
	..\ProcessDLL.cpp \
	..\TapiApi.cpp \
	..\diskpartition.cpp \
	..\file.cpp	\
        ..\logonsession.cpp \
	..\win32loggedonuser.cpp \
	..\win32sessionprocess.cpp \
        ..\Win32MappedLogicalDisk.cpp \


#	..\NtDllApi.cpp \
#	..\WinmmApi.cpp \
#	..\WinSpoolApi.cpp \

# MISCSOURCES are the files that don't fit in either NTSOURCES or PRESOURCES
MISCSOURCES=$(MISCSOURCES) \
	..\cimwin32.rc \
	..\MainDLL.cpp \


#       ..\InitResource.cpp \
#	..\ResourceManager.cpp \
#	..\TimerQueue.cpp \
#	..\TimeOutRule.cpp \
#	..\confgmgr.cpp \
#	..\TimedDllResource.cpp

TARGETLIBS= \
	$(COMMON_NEWTHROW_LIB) \
!ifdef USE_FRAMEDYD
	$(WMIROOT)\SDK\FrameDyn\dyd\$(O)\framedydp.lib \
!else
	$(WMIROOT)\SDK\FrameDyn\dyn\$(O)\framedynp.lib \
!endif
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(CIMWIN32_LIB)	\
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\gdi32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\winspool.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\version.lib \
        $(SDK_LIB_PATH)\mpr.lib \
        $(SDK_LIB_PATH)\traffic.lib \
        $(SDK_LIB_PATH)\setupapi.lib \
        $(SDK_LIB_PATH)\iphlpapi.lib \
	$(SDK_LIB_PATH)\dnsapi.lib

C_DEFINES=$(C_DEFINES) /D_WINDLL /D_WIN32_DCOM
USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1
USE_STL=1
USE_IOSTREAM=1
DLLENTRY=_DllMainCRTStartup

DELAYLOAD=mpr.DLL;version.DLL;winspool.drv;traffic.dll;iphlpapi.dll
DLOAD_ERROR_HANDLER=DliHook

!ifdef USE_FRAMEDYD
DEBUG_CRTS=1
!endif

DLLDEF=$(O)\cimwin32.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\smbstruc.cpp ===
//=================================================================

//

// SmbStruc.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#pragma warning( disable : 4200 )

#include "wmium.h"
#include "smbstruc.h"
#include "wbemcli.h"
#include "wmiapi.h"

// Leave this here until we're sure the tree corruption is gone.
#if 0
// Functions to help find memory corruption.
LPVOID mallocEx(DWORD dwSize)
{
    return
        VirtualAlloc(
            NULL,
            dwSize,
            MEM_COMMIT,
            PAGE_READWRITE);
}

void freeEx(LPVOID pMem)
{
    VirtualFree(
        pMem,
        0,
        MEM_RELEASE);
}

void MakeMemReadOnly(LPVOID pMem, DWORD dwSize, BOOL bReadOnly)
{
    DWORD dwOldProtect;

    VirtualProtect(
        pMem,
        dwSize,
        bReadOnly ? PAGE_READONLY : PAGE_READWRITE,
        &dwOldProtect);
}

void MBTrace(LPCTSTR szFormat, ...)
{
	va_list ap;

	TCHAR szMessage[512];

	va_start(ap, szFormat);
	_vstprintf(szMessage, szFormat, ap);
	va_end(ap);

	MessageBox(NULL, szMessage, _T("TRACE"), MB_OK | MB_SERVICE_NOTIFICATION);
}
#endif

//==============================================================================
// SMBios structure base class definition

#define SMBIOS_FILENAME _T("\\system\\smbios.dat")
#define EPS_FILENAME _T("\\system\\smbios.eps")


GUID guidSMBios =
   {0x8f680850, 0xa584, 0x11d1, 0xbf, 0x38, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10};

LONG	g_lRef = 0;

CCritSec smbcs;


PVOID	CSMBios::m_pMem    = NULL;
PSHF	CSMBios::m_pTable  = NULL;
PVOID	CSMBios::m_pSTTree = NULL;
PVOID	CSMBios::m_pHTree  = NULL;
ULONG	CSMBios::m_Size    = 0;
ULONG	CSMBios::m_Version = 0;
ULONG	CSMBios::m_stcount = 0;
BOOL    CSMBios::m_bValid = FALSE;

// This class loads up the SMBIOS data so it's cached.
class CBIOSInit
{
public:
    CBIOSInit();
    ~CBIOSInit();
};

CBIOSInit::CBIOSInit()
{
    CSMBios bios;

    // We can't do this here because of the resource manager.  We'll
    // now let the first call to CSMBios::Init take care of this.
    // Load up the cache.
    //bios.Init();

    // Make sure the cache doesn't go away.
    bios.Register();
}

CBIOSInit::~CBIOSInit()
{
    CSMBios bios;

    bios.Unregister();
}

// Add a refcount to the cache with a global.  Strangely enough we can't
// load the cache here because of the resource manager.
static CBIOSInit s_biosInit;

CSMBios::CSMBios( )
{
	m_WbemResult = WBEM_S_NO_ERROR;
}


CSMBios::~CSMBios( )
{
	//FreeData();
}

PVOID CSMBios::Register( void )
{
	InterlockedIncrement( &g_lRef );

	return (PVOID) this;
}


LONG CSMBios::Unregister( void )
{
	LONG lRef = -1;

	lRef = InterlockedDecrement( &g_lRef );
	if ( lRef == 0 )
	{
		FreeData( );
	}

	return lRef;
}

BOOL CSMBios::Init( BOOL bRefresh )
{
	BOOL rc = TRUE;

	if (!m_bValid)
	{
		BOOL bOutOfMemory = FALSE;

        smbcs.Enter( );

        // someone waiting while we were allocating?
        if (!m_bValid)
		{
            // NT5
	        rc = InitData( &guidSMBios );
			if (rc && (m_stcount = GetTotalStructCount()) > 0)
            {
				rc = BuildStructureTree() && BuildHandleTree();

			    if (!rc)
			    {
				    bOutOfMemory = TRUE;
                    FreeData();
			    }
                else
                    m_bValid = TRUE;
            }
		}

        smbcs.Leave( );

        if (bOutOfMemory)
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

	return rc;
}

// Get Data from a file
BOOL CSMBios::InitData(LPCTSTR szFileName)
{
	BOOL    bRet = FALSE;
	DWORD   dwSize,
            dwRead = 0;
    HANDLE  hFile;

	hFile =
        CreateFile(
            szFileName,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);

	// Get rid of previous data.
    FreeData( );

    m_WbemResult = WBEM_E_NOT_FOUND;
	// read dat file if it's there and it is larger than the stub size (4 bytes)
    if (hFile != INVALID_HANDLE_VALUE && ((dwSize = GetFileSize(hFile, NULL)) > sizeof(DWORD)))
	{
		m_pMem = malloc(dwSize);
        if (m_pMem)
		{
	        if (ReadFile(hFile, m_pMem, dwSize, &dwRead, NULL) &&
                dwSize == dwRead)
		    {
                m_Size = dwRead;

                // Point at the memory we read in.
                m_pTable = (PSHF) m_pMem;

			    TCHAR szEpsFile[MAX_PATH];
			    HANDLE hEpsFile;
			    DWORD EpsSize, dwRead;
			    BYTE EpsData[sizeof(SMB_EPS)];

			    // assume minimum version of 2.0
			    m_Version = 0x00020000;

			    GetWindowsDirectory( szEpsFile, MAX_PATH );
			    lstrcat( szEpsFile, EPS_FILENAME );
			    hEpsFile =
                    CreateFile( szEpsFile,
			            GENERIC_READ,
			            0,
			            NULL,
			            OPEN_EXISTING,
			            0,
			            NULL);
			    if (hEpsFile != INVALID_HANDLE_VALUE)
			    {
    	            EpsSize = min( GetFileSize( hEpsFile, NULL ), sizeof( SMB_EPS ) );
				    if ( ReadFile( hEpsFile, EpsData, EpsSize, &dwRead, NULL ) )
				    {
					    if ( dwRead >= sizeof( SMB_EPS ) && EpsData[1] == 'S' )
					    {
						    m_Version = MAKELONG( ( (SMB_EPS *)(EpsData) )->version_minor,
						                                ( (SMB_EPS *)(EpsData) )->version_major );
                        }
					    else if ( dwRead >= sizeof( DMI_EPS ) && EpsData[1] == 'D' )
					    {
						    m_Version = MAKELONG( ( (DMI_EPS *)(EpsData) )->bcd_revision & 0x0f,
						                                ( (DMI_EPS *)(EpsData) )->bcd_revision >> 4 );
					    }
				    }
				    CloseHandle( hEpsFile );
		        }

		        bRet = TRUE;
            }
		}
        else
        {
			m_WbemResult  = WBEM_E_OUT_OF_MEMORY;
        }
	}

    if (hFile)
        CloseHandle(hFile);

    if (!bRet && m_pMem)
        // If everything didn't succeed, reset the instance.
        FreeData();

	if (m_WbemResult == WBEM_E_OUT_OF_MEMORY)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    return bRet;
}

#define DEFAULT_MEM_SIZE    4096
#define EPS_DATA_LENGTH		8

typedef	ULONG (WINAPI *WMIOPENBLOCK)(IN GUID *, IN ULONG, OUT WMIHANDLE);
typedef ULONG (WINAPI *WMICLOSEBLOCK)(IN WMIHANDLE);
typedef ULONG (WINAPI *WMIQUERYALLDATA)(IN WMIHANDLE, IN OUT ULONG *, OUT PVOID);

// Get Data from WMI
BOOL CSMBios::InitData(GUID *pSMBiosGuid)
{
	BOOL        bRet = FALSE;
	WMIHANDLE   dbh = NULL;
	CWmiApi		*pWmi = NULL ;

	if (!pSMBiosGuid)
        return FALSE;

    // Get rid of previous data.
    FreeData();

    // Reset our error flag.
    m_WbemResult = WBEM_S_NO_ERROR;

	pWmi = (CWmiApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWmiApi, NULL);
    if (pWmi && pWmi->WmiOpenBlock(pSMBiosGuid, WMIGUID_QUERY, &dbh) == ERROR_SUCCESS)
	{
        DWORD           dwSize = DEFAULT_MEM_SIZE;
        PWNODE_ALL_DATA pwad = (PWNODE_ALL_DATA) malloc(dwSize);
        DWORD           dwErr;

        if (pwad)
		{
            memset(pwad, 0, dwSize);

            // Make sure our obj points at the memory we allocated.
            m_pMem = pwad;

            if ((dwErr = pWmi->WmiQueryAllData(dbh, &dwSize, (PVOID) pwad)) ==
                ERROR_INSUFFICIENT_BUFFER)
            {
                // Was the size we passed too small?  If so, try it again.
                free(pwad);
                pwad = (PWNODE_ALL_DATA) malloc(dwSize);
                m_pMem = pwad;

                if (pwad)
                {
                    memset(pwad, 0, dwSize);

                    if ((dwErr = pWmi->WmiQueryAllData(dbh, &dwSize, (PVOID) pwad))
                        != ERROR_SUCCESS)
                        m_WbemResult = WBEM_E_NOT_FOUND;
                }
                else
                    m_WbemResult = WBEM_E_OUT_OF_MEMORY;
            }
            else if (dwErr != ERROR_SUCCESS)
                m_WbemResult = WBEM_E_NOT_FOUND;

            if (m_WbemResult == WBEM_S_NO_ERROR)
            {
                // Check for table data after the eps data items (of EPS_DATA_LENGTH long)
		        // The table top pointer is set and if valid, the size is > 0
                if (pwad->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE)
                {
                    m_pTable = (PSHF) ((PBYTE) pwad + pwad->DataBlockOffset +
                                EPS_DATA_LENGTH);

                    if (pwad->FixedInstanceSize > EPS_DATA_LENGTH)
                        m_Size = pwad->FixedInstanceSize - EPS_DATA_LENGTH;
		            else
           	            m_Size = 0;
	            }
                else
	            {
                    m_pTable =
                        (PSHF) ((PBYTE) pwad + EPS_DATA_LENGTH +
                            pwad->OffsetInstanceDataAndLength[0].OffsetInstanceData);

                    if (pwad->OffsetInstanceDataAndLength[0].LengthInstanceData >
                        EPS_DATA_LENGTH)
                    {
				        m_Size =
                            pwad->OffsetInstanceDataAndLength[0].LengthInstanceData
                                - EPS_DATA_LENGTH;
                    }
                    else
                    {
                        m_Size = 0;
                    }
                }

                // Determine Version.  Some EPS data is returned in the first X bytes
		        if ( m_Size > 0 )
		        {
			        PBYTE eps_data = (PBYTE) m_pTable - EPS_DATA_LENGTH;

                    // read the bcd revision field if PnP calling method was used.
                    // Also, W2K seems to sometimes mess up and not set this flag.
                    // So, if we see that eps_data[1] (major version) is 0, we know
                    // we had better use the PnP method instead.

                    if (eps_data[0] || !eps_data[1])
			        {
				        m_Version = MAKELONG(eps_data[3] & 0x0f, eps_data[3] >> 4);
                    }
			        else	// read the smbios major and minor version fields
			        {
				        m_Version = MAKELONG(eps_data[2], eps_data[1]);
                    }

                    bRet = TRUE;	// valid table data is found

                    // Some BIOSes are naughty and report 0 as the version.
                    // Assume this means 2.0.
                    if (!m_Version)
                        m_Version = MAKELONG(0, 2);
                }
            }
		}
        else
        {
			m_WbemResult = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        LogMessage(L"No smbios data");
    }

    if (pWmi)
    {
        // dbh will only be non-null if we got something for pWmi.
        if (dbh)
            pWmi->WmiCloseBlock(dbh);

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWmiApi, pWmi);
    }

    // Free up the memory if something went wrong along the way.
    if (!bRet && m_pMem)
	{
        FreeData();
    }

	if (m_WbemResult == WBEM_E_OUT_OF_MEMORY)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

	return bRet;
}


void CSMBios::FreeData( )
{
    smbcs.Enter();

    m_bValid = FALSE;

    if ( m_pSTTree )
	{
		//freeEx( m_pSTTree );
		free( m_pSTTree );
		m_pSTTree = NULL;
	}
	if ( m_pHTree )
	{
		//freeEx( m_pHTree );
		free( m_pHTree );
		m_pHTree = NULL;
	}
	if ( m_pMem )
    {
        free( m_pMem );
        m_pMem = NULL;
        m_pTable = NULL;
    }

    smbcs.Leave();
}

#define MAX_KNOWN_SMBIOS_STRUCT 36

const BOOL g_bStructHasStrings[MAX_KNOWN_SMBIOS_STRUCT + 1] =
{
    TRUE,  // 0 - BIOS Information
    TRUE,  // 1 - System Information
    TRUE,  // 2 - Base board Information
    TRUE,  // 3 - System enclosure or chassis
    TRUE,  // 4 - Processor Information
    FALSE, // 5 - Memory Controller Information
    TRUE,  // 6 - Memory Module Information
    TRUE,  // 7 - Cache Information
    TRUE,  // 8 - Port Connector Information
    TRUE,  // 9 - System Slots
    TRUE,  // 10 - On board Devices information
    TRUE,  // 11 - OEM Strings
    TRUE,  // 12 - System Configuration Options
    TRUE,  // 13 - BIOS Language Information
    TRUE,  // 14 - Group Associations
    FALSE, // 15 - System Event Log
    FALSE, // 16 - Physical Memory Area
    TRUE,  // 17 - Memory Device
    FALSE, // 18 - Memory Error Information
    FALSE, // 19 - Memory Array Mapped Address
    FALSE, // 20 - Memory Device Mapped Address
    FALSE, // 21 - Built-in Pointing Device
    TRUE,  // 22 - Portable Battery
    FALSE, // 23 - System Reset
    FALSE, // 24 - Hardware Security
    FALSE, // 25 - System Power Controls
    TRUE,  // 26 - Voltage Probe
    FALSE, // 27 - Cooling Device
    TRUE,  // 28 - Temperature Probe
    TRUE,  // 29 - Electrical Current Probe
    TRUE,  // 30 - Out of Band Remote Access
    FALSE, // 31 - Boot Integrity Services
    FALSE, // 32 - System Boot Information
    FALSE, // 33 - 64bit Memory Error Information
    TRUE,  // 34 - Management Device
    TRUE,  // 35 - Management Device Component
    FALSE  // 36 - Management Device Threshold Data

};

PSHF CSMBios::NextStructure( PSHF pshf )
{
	PBYTE dp;
	ULONG i;
    LONG limit;

	limit = m_Size - ( (PBYTE) pshf - (PBYTE) m_pTable );
	if ( limit > 0 )
	{
		limit--;
	}
    else
    {
        // If we are already past the limit, no point in proceeding
        return NULL;
    }

	dp = (PBYTE) pshf;
	i = pshf->Length;

    // HACK: We found an SMBIOS 2.0 board that doesn't terminate
    // its stringless structures with a double null.  So, see if the
    // current struct is stringless, and then check to see if the 1st
    // byte past the length of the current struct is non-null.  If it
    // is non-null we're sitting on the next structure so return it.
    if (i && pshf->Type <= MAX_KNOWN_SMBIOS_STRUCT &&
        !g_bStructHasStrings[pshf->Type] && dp[i])
        return (PSHF) (dp + i);

	pshf = NULL;
    while ( i < limit )
	{
		if ( !( dp[i] || dp[i+1] ) )
		{
			i += 2;
			pshf = (PSHF) ( dp + i );
			break;
		}
		else
		{
			i++;
		}
	}

	return ( i < limit ) ? pshf : NULL;
}

PSHF CSMBios::FirstStructure( void )
{
    return m_pTable;
}

int CSMBios::GetStringAtOffset(PSHF pshf, LPWSTR szString, DWORD dwOffset)
{
	int     iLen = 0;
	PBYTE   pstart = (PBYTE) pshf + pshf->Length,
            pTotalEnd = (PBYTE) m_pTable + m_Size;
    DWORD   dwString;
    LPWSTR  szOut = szString;

	// hunt for the start of the requested string
    for (dwString = 1; pstart < pTotalEnd && *pstart && dwOffset > dwString;
        dwString++, pstart++)
    {
        while (pstart < pTotalEnd && *pstart)
            pstart++;
    }

	// Null offset means string isn't present
	if ( dwOffset > 0 )
	{
		iLen = MIF_STRING_LENGTH;
	    // Can't use lstrcpy because it's not always null terminated!
	    while (pstart < pTotalEnd && *pstart > 0x0F && iLen)
		{
	        // This should work fine for unicode.
            *szOut++ = *pstart++;
			iLen--;
		}
	}

    // Throw on a 0 at the end.
    *szOut++ = 0;

	return lstrlenW(szString);
}

ULONG CSMBios::GetStructCount( BYTE type )
{
	StructTree	sttree( m_pSTTree );
	PSTTREE tree;

	tree = sttree.FindAttachNode( type );
	if ( tree )
	{
		return tree->li;
	}

	return 0;
}


PSTLIST CSMBios::GetStructList( BYTE type )
{
	StructTree	sttree( m_pSTTree );
	PSTTREE tree;

	tree = sttree.FindAttachNode( type );
	if ( tree )
	{
		return tree->stlist;
	}

    LogMessage(L"SMBios Structure not found");

	return NULL;
}


PSHF CSMBios::GetNthStruct( BYTE type, DWORD Nth )
{
	StructTree	sttree( m_pSTTree );
	PSTTREE tree;
	PSTLIST pstl;
	PSHF pshf = NULL;

	tree = sttree.FindAttachNode( type );
	if ( tree )
	{
		pstl = tree->stlist;
		while ( Nth-- && pstl )
		{
			pstl = pstl->next;
		}
		if ( pstl )
		{
			pshf = pstl->pshf;
		}
	}

    return pshf;
}

PSHF CSMBios::SeekViaHandle( WORD handle )
{
	HandleTree	htree( m_pHTree );
	PHTREE tree;

	tree = htree.FindAttachNode( handle );
	if ( tree )
	{
		return tree->pshf;
	}

	return NULL;
}


DWORD CSMBios::GetTotalStructCount()
{
    DWORD dwCount = 0;

    for (PSHF pshf = FirstStructure(); pshf != NULL;
        pshf = NextStructure(pshf))
	{
		dwCount++;
    }

    return dwCount;
}

BOOL CSMBios::BuildStructureTree( void )
{
	PSHF pshf;

	//m_pSTTree = mallocEx( ( sizeof( STTREE ) * m_stcount ) + ( sizeof( STLIST ) * m_stcount ) );
	m_pSTTree = malloc( ( sizeof( STTREE ) * m_stcount ) + ( sizeof( STLIST ) * m_stcount ) );

	if ( m_pSTTree )
	{
		StructTree sttree( m_pSTTree );

		sttree.Initialize( );

		pshf = FirstStructure( );
		while ( pshf )
		{
			sttree.InsertStruct( pshf );
			pshf = NextStructure( pshf );
		}

        //MakeMemReadOnly(
        //    m_pSTTree,
        //    ( sizeof( STTREE ) * m_stcount ) + ( sizeof( STLIST ) * m_stcount ),
        //    TRUE);
	}

	return m_pSTTree ? TRUE : FALSE;
}


BOOL CSMBios::BuildHandleTree( void )
{
	PSHF pshf;

	//m_pHTree = mallocEx( sizeof( HTREE ) * m_stcount );
	m_pHTree = malloc( sizeof( HTREE ) * m_stcount );

	if ( m_pHTree )
	{
		HandleTree htree( m_pHTree );

		htree.Initialize( );

		pshf = FirstStructure( );
		while ( pshf )
		{
			htree.InsertStruct( pshf );
			pshf = NextStructure( pshf );
		}

        //MakeMemReadOnly(
        //    m_pHTree,
        //    (sizeof( HTREE ) * m_stcount),
        //    TRUE);
	}

	return m_pHTree ? TRUE : FALSE;
}


//==============================================================================
//	SMBIOS structure tree operation class
//
//	Allocation of memory is external
//==============================================================================
StructTree::StructTree( PVOID pMem )
{
	m_tree = (PSTTREE) pMem;
	m_allocator = NULL;
}


StructTree::~StructTree( )
{
}


void StructTree::Initialize( void )
{
	m_tree->left   = NULL;
	m_tree->right  = NULL;
	m_tree->stlist = NULL;
	m_tree->li     = 0;
	m_allocator = (PBYTE) m_tree;
}


PSTTREE StructTree::InsertStruct( PSHF pshf )
{
	PSTTREE tree;

	if ( m_tree->stlist == NULL )
	{
		tree = StartTree( pshf );
	}
	else
	{
		tree = TreeAdd( m_tree, pshf );
	}

	return tree;
}


PSTTREE StructTree::StartTree( PSHF pshf )
{
	PSTTREE tree = (PSTTREE) m_allocator;

	m_allocator += sizeof( STTREE );
	tree->stlist = StartList( pshf );
	tree->left   = NULL;
	tree->right  = NULL;
	tree->li     = 1;

	return tree;
}


PSTTREE StructTree::TreeAdd( PSTTREE tree, PSHF pshf )
{
	PSTTREE next = tree;

	while ( next )
	{
		tree = next;

		if ( tree->stlist->pshf->Type < pshf->Type )
		{
			next = tree->right;
			if ( next == NULL )
			{
				tree->right = StartTree( pshf );
				tree = tree->right;
			}
		}
		else if ( tree->stlist->pshf->Type > pshf->Type )
		{
			next = tree->left;
			if ( next == NULL )
			{
				tree->left = StartTree( pshf );
				tree = tree->left;
			}
		}
		else
		{
			ListAdd( tree->stlist, pshf );
			tree->li++;
			next = NULL;
		}
	}

	return tree;
}


PSTTREE StructTree::FindAttachNode( BYTE type )
{
	PSTTREE		next, tree;
	BOOL		found = FALSE;

	next = m_tree;
	tree = m_tree;

	while ( next )
	{
		tree = next;

		if ( tree->stlist->pshf->Type < type )
		{
			next = tree->right;
		}
		else if ( tree->stlist->pshf->Type > type )
		{
			next = tree->left;
		}
		else
		{
			next = NULL;
			found = TRUE;
		}
	}

	return found ? tree : NULL;
}


PSTLIST StructTree::StartList( PSHF pshf )
{
	PSTLIST stlist;

	stlist = (PSTLIST) m_allocator;
	m_allocator += sizeof( STLIST );

	stlist->pshf = pshf;
	stlist->next = NULL;

	return stlist;
}


PSTLIST StructTree::ListAdd( PSTLIST list, PSHF pshf )
{
	PSTLIST added;

	while ( list->next )
	{
		list = list->next;
	}
	added = (PSTLIST) m_allocator;
	m_allocator += sizeof( STLIST );

	list->next = added;
	added->pshf = pshf;
	added->next = NULL;

	return added;
}


//==============================================================================
//	SMBIOS handle tree operation class
//
//	Allocation of memory is external
//==============================================================================
HandleTree::HandleTree( PVOID pMem )
{
	m_tree = (PHTREE) pMem;
	m_allocator = NULL;
}

HandleTree::~HandleTree( )
{
}


void HandleTree::Initialize( void )
{
	m_tree->left   = NULL;
	m_tree->right  = NULL;
	m_tree->pshf   = NULL;
	m_allocator = (PBYTE) m_tree;
}


PHTREE HandleTree::InsertStruct( PSHF pshf )
{
	PHTREE tree;

	if ( m_tree->pshf == NULL )
	{
		tree = StartTree( pshf );
	}
	else
	{
		tree = TreeAdd( m_tree, pshf );
	}

	return tree;
}


PHTREE HandleTree::StartTree( PSHF pshf )
{
	PHTREE tree = (PHTREE) m_allocator;

	m_allocator += sizeof( HTREE );
	tree->pshf  = pshf;
	tree->left  = NULL;
	tree->right = NULL;

	return tree;
}


PHTREE HandleTree::TreeAdd( PHTREE tree, PSHF pshf )
{
	PHTREE next = tree;

	while ( next )
	{
		tree = next;

		if ( tree->pshf->Handle < pshf->Handle )
		{
			next = tree->right;
			if ( next == NULL )
			{
				tree->right = StartTree( pshf );
				tree = tree->right;
			}
		}
		else if ( tree->pshf->Handle > pshf->Handle )
		{
			next = tree->left;
			if ( next == NULL )
			{
				tree->left = StartTree( pshf );
				tree = tree->left;
			}
		}
		else
		{
			tree->pshf = pshf;
			next = NULL;
		}
	}

	return tree;
}


PHTREE HandleTree::FindAttachNode( WORD handle )
{
	PHTREE		next, tree;
	BOOL		found = FALSE;

	next = m_tree;
	tree = m_tree;

	while ( next )
	{
		tree = next;

		if ( tree->pshf->Handle < handle )
		{
			next = tree->right;
		}
		else if ( tree->pshf->Handle > handle )
		{
			next = tree->left;
		}
		else
		{
			next  = NULL;
			found = TRUE;
		}
	}

	return found ? tree : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\startupcommand.cpp ===
//=================================================================

//

// StartupCommand.CPP -- CodecFile property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//				 03/03/99    a-peterc		Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include <shlguid.h>
#include <shlobj.h>
#include <ProvExce.h>
#include "StartupCommand.h"
#include "userhive.h"

#include <profilestringimpl.h>

// Property set declaration
//=========================

CWin32StartupCommand startupCommand(
	L"Win32_StartupCommand",
	IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32StartupCommand::CWin32StartupCommand
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32StartupCommand::CWin32StartupCommand(
	LPCWSTR a_szName,
	LPCWSTR a_szNamespace) : Provider( a_szName, a_szNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32StartupCommand::~CWin32StartupCommand
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32StartupCommand::~CWin32StartupCommand()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32StartupCommand::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32StartupCommand::EnumerateInstances(
	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/)
{
	return EnumStartupOptions( a_pMethodContext, NULL ) ;
}

class CIconInfo
{
public:
	TCHAR	szPath[ MAX_PATH * 2 ] ;
	TCHAR	szTarget[ MAX_PATH * 2 ] ;
	TCHAR	szArgs[ MAX_PATH * 2 ] ;
	HRESULT	hResult;
};

DWORD GetIconInfoProc( CIconInfo *a_pInfo )
{
	HRESULT t_hResult;
	IShellLink	    *t_psl = NULL ;
	IPersistFile    *t_ppf = NULL ;

	try
	{
		// We have to use COINIT_APARTMENTTHREADED.
		if (SUCCEEDED( t_hResult = CoInitialize( NULL ) ) )
		{
			// Get a pointer to the IShellLink interface.
			if ( SUCCEEDED( t_hResult = CoCreateInstance(
															CLSID_ShellLink,
															NULL,
															CLSCTX_INPROC_SERVER,
															IID_IShellLink,
															(VOID **) &t_psl ) ) )
			{
				// Get a pointer to the IPersistFile interface.
				if ( SUCCEEDED( t_hResult = t_psl->QueryInterface(
					IID_IPersistFile,
					(VOID **) &t_ppf ) ) )
				{
					_bstr_t t_bstr = a_pInfo->szPath ;

					if ( SUCCEEDED( t_hResult = t_ppf->Load( t_bstr, STGM_READ ) ) )
					{
						WIN32_FIND_DATA t_fd ;

						t_hResult = t_psl->GetPath(
													a_pInfo->szTarget,
													sizeof( a_pInfo->szTarget ),
													&t_fd,
													SLGP_SHORTPATH ) ;

						t_hResult = t_psl->GetArguments( a_pInfo->szArgs, sizeof( a_pInfo->szArgs) ) ;
					}
				}
			}
		}

		a_pInfo->hResult = t_hResult ;

	}
	catch( ... )
	{
		a_pInfo->hResult = WBEM_E_FAILED ;
	}

	if ( t_psl )
	{
		t_psl->Release( ) ;
		t_psl = NULL ;
	}

	if ( t_ppf )
	{
		t_ppf->Release( ) ;
		t_ppf = NULL ;
	}

	CoUninitialize( ) ;

	return 0;
}

// This uses a thread because we need to be in apartment model to use the
// shortcut interfaces.
HRESULT GetIconInfo( CIconInfo &a_info )
{
	DWORD	t_dwID;
	SmartCloseHandle	t_hThread;

	if ( t_hThread = CreateThread (
									NULL,
									0,
									(LPTHREAD_START_ROUTINE) GetIconInfoProc,
									&a_info,
									0,
									&t_dwID ) )
	{

		a_info.hResult = WBEM_S_NO_ERROR ;

		WaitForSingleObject( t_hThread, INFINITE ) ;
	}
	else
	{
		a_info.hResult = WBEM_E_FAILED ;
	}

	return a_info.hResult;
}

HRESULT CWin32StartupCommand::EnumStartupFolderItems(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor,
	LPCWSTR			a_szKeyName,
	LPCWSTR			a_szUserName )
{
	HKEY		t_hkey ;
	CHString	t_strKey,
				t_strValueName,
				t_strFolder,
				t_strWhere,
                t_strLookingForPath ;
	CRegistry	t_reg ;
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	DWORD		t_dwRet;
	HANDLE		t_hFind			= NULL ;

		// If szUserName == NULL, we're looking at the common keys group.

		// Setup stuff if we're doing a GetObject.
		if ( a_pinstLookingFor )
		{
			GetLocalInstancePath( a_pinstLookingFor, t_strLookingForPath ) ;

			// Until we prove otherwise, we haven't found one.
			t_hResult = WBEM_E_NOT_FOUND ;
		}

		// Setup the registry vars depending on whether we're looking for
		// Common Startup or User Startup items.
		if ( !a_szUserName )
		{
			t_hkey = HKEY_LOCAL_MACHINE ;

			t_strKey =
				_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\")
				_T("Explorer\\Shell Folders" ) ;

			t_strValueName = _T("Common Startup") ;
		}
		else
		{
			t_hkey = HKEY_USERS ;

			t_strKey = a_szKeyName ;
			t_strKey +=
				_T("\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\")
				_T("Explorer\\Shell Folders") ;

			t_strValueName = _T("Startup") ;
		}

		if ( ( t_dwRet = t_reg.Open( t_hkey, t_strKey, KEY_READ ) ) != ERROR_SUCCESS ||
			 ( t_dwRet = t_reg.GetCurrentKeyValue( t_strValueName, t_strFolder ) ) !=
				ERROR_SUCCESS )
		{
			t_hResult = WinErrorToWBEMhResult( t_dwRet ) ;
		}
		else
		{
			// We opened the key.  Now try to enum the folder contents.
			TCHAR		t_szFolderSpec[ MAX_PATH * 2 ],
						t_szNameOnly[ MAX_PATH * 2 ];
			HRESULT		t_hresInternal = WBEM_S_NO_ERROR ;

			// Add '*.*' to the end of the directory.  Use _tmakepath
			// so we don't have to look for '\\' on the end.
			_tmakepath( t_szFolderSpec, NULL, TOBSTRT( t_strFolder ), _T("*.*"), NULL ) ;

			WIN32_FIND_DATA	t_fd;

			t_hFind = FindFirstFile( t_szFolderSpec, &t_fd ) ;

			BOOL t_bDone = t_hFind == INVALID_HANDLE_VALUE ;

			while ( !t_bDone )
			{
				BOOL bNewInstance = FALSE;
				// Directories can't be startup items.
				if ( ( t_fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 )
				{
					CIconInfo t_info;
					CInstancePtr t_pWorkingInst;

					// establish the working instance
					if ( !a_pinstLookingFor )
					{
						t_pWorkingInst.Attach ( CreateNewInstance( a_pMethodContext ) );
						bNewInstance = TRUE;
					}
					else
					{
						t_pWorkingInst = a_pinstLookingFor ;
					}

					// Split off the extension from the name so it looks better.
					_tsplitpath( t_fd.cFileName, NULL, NULL, t_szNameOnly, NULL ) ;

					t_pWorkingInst->SetCharSplat( L"Name", t_szNameOnly ) ;
					t_pWorkingInst->SetCharSplat( L"Description", t_szNameOnly ) ;
					t_pWorkingInst->SetCharSplat( L"Caption", t_szNameOnly ) ;
					t_pWorkingInst->SetCharSplat( L"Location", t_strValueName ) ;
					
                    if(a_szUserName)
                    {
                        t_pWorkingInst->SetCharSplat( L"User", a_szUserName ) ;
                    }
                    else
                    {
                        CHString chstrAllUsersName;
                        if(GetAllUsersName(chstrAllUsersName))
                        {
                            t_pWorkingInst->SetCharSplat( L"User", chstrAllUsersName ) ;
                        }
                        else
                        {
                            t_pWorkingInst->SetCharSplat( L"User", L"All Users" ) ;
                        }
                    }

					_tmakepath( t_info.szPath, NULL, TOBSTRT( t_strFolder ), t_fd.cFileName, NULL ) ;

					if ( SUCCEEDED( GetIconInfo( t_info ) ) )
					{
						CHString t_szCommand ( t_info.szTarget ) ;
						t_szCommand = t_szCommand + CHString ( _T(" " ) ) ;
						t_szCommand = t_szCommand + CHString ( t_info.szArgs ) ;
						t_pWorkingInst->SetCharSplat( L"Command", t_szCommand ) ;
					}
					else
						t_pWorkingInst->SetCharSplat( L"Command", t_fd.cFileName ) ;

					if ( bNewInstance )
					{
						t_hResult = t_pWorkingInst->Commit() ;

						if (FAILED(t_hResult))
						{
							break;
						}
					}
					else
					{
						CHString t_strPathAfter ;

						GetLocalInstancePath( t_pWorkingInst, t_strPathAfter ) ;

						// If we found the one we're looking for, get out.
						if (!_wcsicmp( t_strPathAfter, t_strLookingForPath ) )
						{
							t_hResult = WBEM_S_NO_ERROR ;
							break ;
						}
					}
				}

				t_bDone = !FindNextFile( t_hFind, &t_fd ) ;
			}

			// We're done with the find now.
			FindClose( t_hFind ) ;
			t_hFind = NULL ;
		}

		return t_hResult;
}

HRESULT CWin32StartupCommand::EnumRunKeyItems(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor,
	LPCWSTR			a_szKeyName,
	LPCWSTR			a_szUserName )
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	LPCWSTR     t_szKeys[] =
				{
					L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
					L"Software\\Microsoft\\Windows\\CurrentVersion\\RunServices",
				} ;
	HKEY		t_hkey;
	int         t_nRunKeys;
	BOOL        t_bDone = FALSE;
	CHString	t_strKey,
				t_strWherePrefix,
				t_strWhere,
				t_strLookingForPath,
				t_strUser = a_szUserName ? a_szUserName : L"All Users" ;
	CRegistry	t_reg ;

	WCHAR		*t_szValueName	= NULL ;
	BYTE		*t_szValue		= NULL ;

	// If szUserName == NULL, we're looking at the common keys group.

	// Setup stuff if we're doing a GetObject.
	if ( a_pinstLookingFor )
	{
		GetLocalInstancePath( a_pinstLookingFor, t_strLookingForPath ) ;

		// Until we prove otherwise, we haven't found one.
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	// Setup the registry vars depending on whether we're looking for
	// Common Startup or User Startup items.
	if ( !a_szUserName )
	{
		t_hkey = HKEY_LOCAL_MACHINE ;
		t_strWherePrefix = _T("HKLM\\") ;
	}
	else
	{
		t_hkey = HKEY_USERS ;
		t_strWherePrefix = _T("HKU\\") ;
	}

	// If we're 9x and doing All Users, look at both the main key
	// and the services key.
	{
		t_nRunKeys = 1;
	}

	for ( int t_i = 0; t_i < t_nRunKeys && !t_bDone; t_i++ )
	{
		CRegistry   t_reg;
		DWORD       t_dwRet;
		CHString	t_strKey;

		if ( a_szKeyName )
		{
			t_strKey.Format( L"%s\\%s", a_szKeyName, t_szKeys[ t_i ] ) ;
		}
		else
		{
			t_strKey = t_szKeys[ t_i ] ;
		}

		if ( ( t_dwRet = t_reg.Open( t_hkey, t_strKey, KEY_READ ) ) != ERROR_SUCCESS )
		{
			t_hResult = WinErrorToWBEMhResult( t_dwRet ) ;
			break ;
		}

		// Make the where string.
		t_strWhere = t_strWherePrefix + t_strKey ;

		DWORD	t_nKeys = t_reg.GetValueCount( ),
				t_dwKey;

		for ( t_dwKey = 0; t_dwKey < t_nKeys; t_dwKey++ )
		{
			BOOL bNewInstance = FALSE;
			if ( t_reg.EnumerateAndGetValues( t_dwKey, t_szValueName, t_szValue ) !=
				ERROR_SUCCESS )
			{
				continue ;
			}

			CInstancePtr t_pWorkingInst;

			// establish the working instance
			if ( !a_pinstLookingFor )
			{
				t_pWorkingInst.Attach (  CreateNewInstance( a_pMethodContext ) );
				bNewInstance = TRUE;
			}
			else
			{
				t_pWorkingInst = a_pinstLookingFor ;
			}

			t_pWorkingInst->SetCharSplat( L"Name", t_szValueName ) ;
			t_pWorkingInst->SetCharSplat( L"Description", t_szValueName ) ;
			t_pWorkingInst->SetCharSplat( L"Caption", t_szValueName ) ;
			t_pWorkingInst->SetCharSplat( L"Command", (LPCWSTR) t_szValue ) ;
			t_pWorkingInst->SetCharSplat( L"Location", t_strWhere ) ;
			t_pWorkingInst->SetCharSplat( L"User", t_strUser ) ;

			// Get rid of szValue and szValue.
			delete [] t_szValueName ;
			t_szValueName = NULL ;

			delete [] t_szValue ;
			t_szValue = NULL ;

			if ( bNewInstance )
			{
				t_hResult = t_pWorkingInst->Commit();
			
				if ( FAILED( t_hResult ) )
				{
					t_bDone = TRUE ;
					break ;
				}
			}
			else
			{
				CHString t_strPathAfter ;

				GetLocalInstancePath( t_pWorkingInst, t_strPathAfter ) ;

				// If we found the one we're looking for, get out.
				if ( !_wcsicmp( t_strPathAfter, t_strLookingForPath ) )
				{
					t_hResult = WBEM_S_NO_ERROR ;
					t_bDone = TRUE ;
					break ;
				}
			}
		}
	}

	return t_hResult;
}

HRESULT CWin32StartupCommand::EnumRunValueItems(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor,
	LPCWSTR			a_szKeyName,
	LPCWSTR			a_szUserName )
{
    LPCWSTR     t_szValueNames[] =
                {
                    L"Run",
                    L"Load",
				} ;
	DWORD       t_dwRet;
	CHString	t_strKey,
                t_strWherePrefix,
                t_strLookingForPath;
	CRegistry	t_reg;
	HRESULT		t_hResult = a_pinstLookingFor ? WBEM_E_NOT_FOUND : WBEM_S_NO_ERROR;

	// If szUserName == NULL, we're looking at the common keys group.

	// Win9x doesn't support these keys, and neither does HKLM, so get out now.
#ifdef NTONLY
	if ( !a_szUserName )
#endif
	{
		return t_hResult ;
	}

	// Setup stuff if we're doing a GetObject.
	if ( a_pinstLookingFor )
	{
        GetLocalInstancePath( a_pinstLookingFor, t_strLookingForPath ) ;
	}
	// Setup the registry vars depending on whether we're looking for
    // Common Startup or User Startup items.
	t_strWherePrefix = L"*HKU\\" ;

	t_strKey	= a_szKeyName;
	t_strKey	+= L"\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\Windows" ;

	if ( ( t_dwRet = t_reg.Open( HKEY_USERS, t_strKey, KEY_READ ) ) != ERROR_SUCCESS )
	{
		t_hResult = WinErrorToWBEMhResult( t_dwRet ) ;
	}
	else
	{
		// Make the where string.
		CHString t_strWhere = t_strWherePrefix + t_strKey;

		for ( int t_i = 0; t_i < sizeof( t_szValueNames ) / sizeof( t_szValueNames[ 0 ] ) ; t_i++ )
		{
			CHString t_strValue;

			if ( t_reg.GetCurrentKeyValue( t_szValueNames[ t_i ], t_strValue ) != ERROR_SUCCESS )
			{
				continue;
			}

			t_hResult =
				// Splits up a command-seperated value string, fills out instances,
				// etc.
				EnumCommandSeperatedValuesHelper(
					a_pMethodContext,
					a_pinstLookingFor,
                    t_strLookingForPath,
					t_szValueNames[ t_i ],
					t_strWhere,
					a_szUserName,
					t_strValue ) ;

			// If we found the one we're looking for, get out.
			if ( a_pinstLookingFor && t_hResult == WBEM_S_NO_ERROR )
			{
				break;
			}
		}
	}

	return t_hResult;
}

HRESULT	CWin32StartupCommand::EnumCommandSeperatedValuesHelper(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor,
    LPCWSTR         a_szLookingForPath,
	LPCWSTR			a_szValueName,
	LPCWSTR			a_szLocation,
	LPCWSTR			a_szUserName,
	LPCWSTR			a_szValue )
{
	HRESULT		t_hResult = a_pinstLookingFor ? WBEM_E_NOT_FOUND : WBEM_S_NO_ERROR ;
	LPWSTR		t_pszCurrent ;
	int			t_iItem = 0 ;

	LPWSTR		t_szTemp		= NULL ;
	
	t_szTemp = _wcsdup( a_szValue ) ;

	if ( !t_szTemp )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	for (	t_pszCurrent = wcstok( t_szTemp, L"," );
			t_pszCurrent;
			t_pszCurrent = wcstok( NULL, L"," ), t_iItem++ )
	{
		CHString	t_strName,
					t_strCommand = t_pszCurrent ;

		CInstancePtr t_pWorkingInst;
		BOOL bNewInstance = FALSE;

		// establish the working instance
		if ( !a_pinstLookingFor )
		{			
			t_pWorkingInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;
			bNewInstance = TRUE;
		}
		else
		{
			t_pWorkingInst = a_pinstLookingFor ;
		}


		t_strName.Format( L"%s[%d]", a_szValueName, t_iItem ) ;

		// Make sure we don't have leading spaces on the command.
		t_strCommand.TrimLeft( ) ;

		t_pWorkingInst->SetCharSplat( L"Name", t_strName ) ;
		t_pWorkingInst->SetCharSplat( L"Description", t_strName ) ;
		t_pWorkingInst->SetCharSplat( L"Caption", t_strName ) ;
		t_pWorkingInst->SetCharSplat( L"Command", t_strCommand ) ;
		t_pWorkingInst->SetCharSplat( L"Location", a_szLocation ) ;
		t_pWorkingInst->SetCharSplat( L"User", a_szUserName ) ;

		if ( bNewInstance )
		{
			t_hResult = t_pWorkingInst ->Commit();

			if ( FAILED( t_hResult ) )
			{
				break ;
			}
		}
		else
		{
			CHString t_strPathAfter;

			GetLocalInstancePath( t_pWorkingInst, t_strPathAfter ) ;

			// If we found the one we're looking for, get out.
			if (!_wcsicmp( t_strPathAfter, a_szLookingForPath ) )
			{
				t_hResult = WBEM_S_NO_ERROR ;
				break ;
			}
		}
	}

	// Get rid of our temporary string buffer.
	free( t_szTemp ) ;
	t_szTemp = NULL ;

	return t_hResult;
}


#ifdef NTONLY
HRESULT CWin32StartupCommand::EnumIniValueItems(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor)
{
	HRESULT		t_hResult = a_pinstLookingFor ? WBEM_E_NOT_FOUND : WBEM_S_NO_ERROR ;
    LPCTSTR     t_szValueNames[] =
                {
                    _T("Run"),
                    _T("Load"),
                };
    CHString    t_strLookingForPath;

	// Setup stuff if we're doing a GetObject.
	if ( a_pinstLookingFor )
	{
        GetLocalInstancePath( a_pinstLookingFor, t_strLookingForPath ) ;
	}

	for ( int t_i = 0; t_i < sizeof( t_szValueNames ) / sizeof( t_szValueNames [ 0 ] ) ; t_i++ )
	{
        TCHAR t_szValue[ MAX_PATH * 2 ] ;

		WMIRegistry_ProfileString(
									_T("Windows"),
									t_szValueNames[ t_i ],
									_T(""),
									t_szValue,
									sizeof( t_szValue ) / sizeof(TCHAR) ) ;

        t_hResult =
			// Splits up a command-seperated value string, fills out instances,
			// etc.
			EnumCommandSeperatedValuesHelper(
												a_pMethodContext,
												a_pinstLookingFor,
												t_strLookingForPath,
												t_szValueNames[ t_i ],
												_T("win.ini"),
												_T("All Users"),
												t_szValue ) ;

		// If we found the one we're looking for, get out.
		if ( a_pinstLookingFor && t_hResult == WBEM_S_NO_ERROR )
		{
			break ;
		}
	}
	return t_hResult ;
}
#endif

BOOL CWin32StartupCommand::UserNameToUserKey(
	LPCWSTR a_szUserName,
	CHString &a_strKeyName )
{
	BOOL t_bRet = TRUE ;

	if ( !_wcsicmp( a_szUserName, L".DEFAULT" ) )
	{
		a_strKeyName = a_szUserName ;
	}
	else if ( !_wcsicmp( a_szUserName, L"All Users" ) )
	{
		a_strKeyName = _T("") ;
	}
	else

#ifdef NTONLY
	{
		CUserHive t_hive;

		// If we couldn't open the hive, go to the next one.
		if ( t_hive.Load( a_szUserName, a_strKeyName.GetBuffer( MAX_PATH ), MAX_PATH ) !=	ERROR_SUCCESS )
		{
			t_bRet = FALSE;
		}
        else
        {
            t_hive.Unload(a_strKeyName);
        }
		a_strKeyName.ReleaseBuffer( ) ;
	}
#endif

	return t_bRet;
}

BOOL CWin32StartupCommand::UserKeyToUserName(
	LPCWSTR a_szKeyName,
	CHString &a_strUserName )
{
	BOOL t_bRet = TRUE ;

	if ( !_wcsicmp( a_szKeyName, L".DEFAULT" ) )
	{
		a_strUserName = a_szKeyName ;
	}
	else

#ifdef NTONLY
	{
		CUserHive t_hive ;
		try
		{
			// If we couldn't open the hive, go to the next one.
			if ( t_hive.LoadProfile( a_szKeyName, a_strUserName ) != ERROR_SUCCESS  && 
                            a_strUserName.GetLength() > 0 )
			{
				t_bRet = FALSE ;
			}
			else
			{
				// We've got to do the unloading because the destructor doesn't.
				//t_hive.Unload( a_szKeyName ) ;
			}
		}
		catch( ... )
		{
			t_hive.Unload( a_szKeyName ) ;
			throw ;
		}

		t_hive.Unload( a_szKeyName ) ;
	}
#endif

	return t_bRet;
}

HRESULT CWin32StartupCommand::EnumStartupOptions(
	MethodContext	*a_pMethodContext,
	CInstance		*a_pinstLookingFor)
{
	CHStringList	t_list ;
	CRegistry		t_regHKCU ;
	HRESULT			t_hResult = WBEM_S_NO_ERROR ;

	// Get the list of user names for HKEY_CURRENT_USER.
	if ( FAILED( t_hResult = GetHKUserNames( t_list ) ) )
	{
		return t_hResult;
	}

	for ( CHStringList_Iterator t_i = t_list.begin( ) ; t_i != t_list.end( ) ; ++t_i )
	{
		CHString	&t_strKeyName = *t_i,
					t_strUserName;

		if ( !UserKeyToUserName( t_strKeyName, t_strUserName ) )
			continue;

		EnumStartupFolderItems(
						a_pMethodContext,
						a_pinstLookingFor,
						t_strKeyName,
						t_strUserName ) ;

		EnumRunKeyItems(
						a_pMethodContext,
						a_pinstLookingFor,
						t_strKeyName,
						t_strUserName ) ;

		EnumRunValueItems(
						a_pMethodContext,
						a_pinstLookingFor,
						t_strKeyName,
						t_strUserName ) ;


        // Ini items are only global, which is why we're not calling the .ini
        // enum function here.
	}

	// Now do all the global startup items.
	EnumStartupFolderItems(
						a_pMethodContext,
						a_pinstLookingFor,
						NULL,
						NULL ) ;
	EnumRunKeyItems(
						a_pMethodContext,
						a_pinstLookingFor,
						NULL,
						NULL ) ;
	// These never exist.
    //EnumRunValueItems(
	//					a_pMethodContext,
	//					a_pinstLookingFor,
	//					NULL,
	//					NULL ) ;
	EnumIniValueItems(
						a_pMethodContext,
						a_pinstLookingFor ) ;

	return t_hResult;
}

HRESULT CWin32StartupCommand::GetObject( CInstance *a_pInst, long a_lFlags )
{
	CHString	t_strWhere,
				t_strUserName,
				t_strKey ;
	HRESULT		t_hResult = WBEM_E_NOT_FOUND ;

    a_pInst->GetCHString( L"Location", t_strWhere ) ;
	a_pInst->GetCHString( L"User", t_strUserName ) ;

	if ( UserNameToUserKey( t_strUserName, t_strKey ) )
	{
		// Make sure this has been upcased so that we're case insenstive when
        // looking for "HKLM\\", etc.
        t_strWhere.MakeUpper();

        // Startup group
		if ( !_wcsicmp( t_strWhere, L"Startup" ) )
		{
			t_hResult =
				EnumStartupFolderItems(
										NULL,
										a_pInst,
										t_strKey,
										t_strUserName ) ;
		}
		// Common startup group
		else if ( !_wcsicmp( t_strWhere, L"Common Startup" ) )
		{
			t_hResult =
				EnumStartupFolderItems(
					NULL,
					a_pInst,
					NULL,
					NULL ) ;
		}
		// User run keys
		else if ( t_strWhere.Find( L"HKU\\" ) == 0 )
		{
			t_hResult =
				EnumRunKeyItems(
					NULL,
					a_pInst,
					t_strKey,
					t_strUserName ) ;
		}
		// Global run keys
		else if ( t_strWhere.Find( L"HKLM\\" ) == 0 )
		{
			t_hResult =
				EnumRunKeyItems(
					NULL,
					a_pInst,
					NULL,
					NULL ) ;
		}
		// User run value
		else if ( t_strWhere.Find( L"*HKU\\" ) == 0 )
		{
			t_hResult =
				EnumRunValueItems(
					NULL,
					a_pInst,
					t_strKey,
					t_strUserName ) ;
		}
		// Global win.ini strings.
		else if ( t_strWhere.Find( L"win.ini" ) == 0 )
		{
			t_hResult =
				EnumIniValueItems(
					NULL,
					a_pInst ) ;
		}
	}

	return t_hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\startupcommand.h ===
//=================================================================

//

// StartupCommand.h -- CWin32StartupCommand property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//
//=================================================================
#ifndef _STARTUPCOMMAND_H
#define _STARTUPCOMMAND_H

class CWin32StartupCommand : public Provider
{
	protected:

		HRESULT EnumStartupFolderItems(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor,
			LPCWSTR a_szKeyName,
			LPCWSTR a_szUserName);

		HRESULT EnumRunKeyItems(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor,
			LPCWSTR	a_szKeyName,
			LPCWSTR	a_szUserName ) ;

		HRESULT EnumRunValueItems(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor,
			LPCWSTR a_szKeyName,
			LPCWSTR a_szUserName ) ;

		HRESULT EnumIniValueItems(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor ) ;

		HRESULT EnumStartupOptions(
			MethodContext *a_pMethodContext,
			CInstance *a_pinstLookingFor ) ;

		HRESULT	EnumCommandSeperatedValuesHelper(
			MethodContext *a_pMethodContext, 
			CInstance *a_pinstLookingFor,
			LPCWSTR a_szLookingForPath,
			LPCWSTR	a_szValueName,
			LPCWSTR	a_szLocation,
			LPCWSTR	a_szUserName,
			LPCWSTR	a_szValue ) ;

		static BOOL UserKeyToUserName( LPCWSTR a_szKeyName, CHString &a_strUserName ) ;
		static BOOL UserNameToUserKey( LPCWSTR szUserName,	CHString &a_strKeyName ) ;
	
	public:

		// Constructor/destructor
		//=======================
		CWin32StartupCommand( LPCWSTR a_szName, LPCWSTR a_szNamespace ) ;
		~CWin32StartupCommand();

		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0 ) ;
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0 ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\systemaccount.h ===
//=================================================================

//

// systemaccount.h -- Group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain Groups
//				 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//											clean up			
//
//=================================================================

// Property set identification
//============================

#define	PROPSET_NAME_SYSTEMACCOUNT L"Win32_SystemAccount"

class CWin32SystemAccount : public Provider
{
	   private:

        // Utility function(s)
        //====================

		BOOL GetSysAccountNameAndDomain( 
										PSID_IDENTIFIER_AUTHORITY a_pAuthority,
										CSid &a_accountsid,
										BYTE a_saCount = 0,
										DWORD a_dwSubAuthority1 = 0,
										DWORD a_dwSubAuthority2 = 0 ) ;

		HRESULT CommitSystemAccount( CSid &a_accountsid, MethodContext *a_pMethodContext ) ;
		void FillInstance( CSid& a_accountsid, CInstance *a_pInst ) ;
	
	#ifdef NTONLY
        BOOL RefreshInstanceNT( CInstance *a_pInst ) ;
        HRESULT AddDynamicInstancesNT( MethodContext *a_pMethodContext ) ;
	#endif

    public:

        // Constructor/destructor
        //=======================

        CWin32SystemAccount( const CHString &a_strName, LPCWSTR a_pszNamespace ) ;
       ~CWin32SystemAccount() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst , long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ); 
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\systemconfigchange.cpp ===
//=================================================================

//

// SystemConfigChange.cpp -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <dbt.h>
#include "SystemConfigChange.h"

//=================================================================
//
// CFactoryRouter
//
// provides for registration and instance creation  
//
//
//=================================================================

// Implements a SystemConfigChangeProvider
IUnknown * CSystemConfigChangeFactory::CreateInstance (

REFIID a_riid ,
LPVOID FAR *a_ppvObject
)
{
	return static_cast<IWbemProviderInit *>(new CSystemConfigChangeEvent) ;
}

//=================================================================
//
// CSystemConfigChangeEvent
//
// provides for eventing of power management events  
//
//
//=================================================================
//

// CEventProvider::Initialize needs the class name. Caller frees
BSTR CSystemConfigChangeEvent::GetClassName()
{
	return SysAllocString(SYSTEM_CONFIG_EVENT); 
}

// CEventProvider signals us to begin providing for events
void CSystemConfigChangeEvent::ProvideEvents()
{
	// Tell CWinMsgEvent what windows messages we're interested in
	if (!m_bRegistered)
	{
		m_bRegistered = TRUE ;
		CWinMsgEvent::RegisterForMessage( WM_DEVICECHANGE ) ;
	}
}


// CWinMsgEvent signals that a message event has arrived
void CSystemConfigChangeEvent::WinMsgEvent(
			
IN	HWND a_hWnd,
IN	UINT a_message,
IN	WPARAM a_wParam,
IN	LPARAM	a_lParam,
OUT E_ReturnAction &a_eRetAction,
OUT LRESULT &a_lResult
)
{
    switch ( a_wParam )
    {
        case DBT_DEVNODES_CHANGED:
        {
            HandleEvent(1);
            break;
        }

        case DBT_DEVICEARRIVAL:
        {
            DEV_BROADCAST_HDR *pHdr = (DEV_BROADCAST_HDR *)a_lParam;

            if (pHdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE || 
                pHdr->dbch_devicetype == DBT_DEVTYP_PORT)
            {
                HandleEvent(2);
            }
            break;
        }

        case DBT_DEVICEREMOVECOMPLETE:
        {
            DEV_BROADCAST_HDR *pHdr = (DEV_BROADCAST_HDR *)a_lParam;

            if (pHdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE || 
                pHdr->dbch_devicetype == DBT_DEVTYP_PORT)
            {
                HandleEvent(3);
            }
            break;
        }

        case DBT_CONFIGCHANGED:
        {
            HandleEvent(4);
            break;
        }

        default:
        {
            break;
        }
    }
}

// Turn the message into a wmi event
void CSystemConfigChangeEvent::HandleEvent( long lValue )
{
	IWbemObjectSinkPtr t_pHandler(CEventProvider::GetHandler(), false);
	IWbemClassObjectPtr t_pClass(CEventProvider::GetClass(), false); 

	if( t_pClass != NULL && t_pHandler != NULL )
	{
        variant_t vValue(lValue);

    	IWbemClassObjectPtr t_pInst;

		if( SUCCEEDED( t_pClass->SpawnInstance( 0L, &t_pInst ) ) )
        {
            if (SUCCEEDED( t_pInst->Put( L"EventType", 0, &vValue, 0 ) ) )
		    {
                // We can't use t_pInst here, cuz the operator(cast) for this smartptr
                // will FREE the pointer before passing it in, under the assumption
                // that Indicate is going to POPULATE this pointer.
                IWbemClassObject *p2 = t_pInst;
			    t_pHandler->Indicate ( 1, &p2 ) ;
		    }
        }
	}
}

//
void CSystemConfigChangeEvent::OnFinalRelease()
{
	if (m_bRegistered)
	{
		CWinMsgEvent::UnRegisterMessage( WM_DEVICECHANGE ) ;
	}

    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\systemconfigchange.h ===
//=================================================================

//

// SystemConfigChange.h -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include "FactoryRouter.h"
#include "EventProvider.h"
#include "WinMsgEvent.h"

#define SYSTEM_CONFIG_EVENT L"Win32_SystemConfigurationChangeEvent"

//
class CSystemConfigChangeFactory :	public CFactoryRouter 
{
	private:
	protected:
	public:

		CSystemConfigChangeFactory( REFGUID a_rClsId, LPCWSTR a_pClassName )
			: CFactoryRouter( a_rClsId, a_pClassName ) {} ;

		~CSystemConfigChangeFactory() {};

		// implementation of abstract CProviderClassFactory
		virtual IUnknown * CreateInstance (

			REFIID a_riid ,
			LPVOID FAR *a_ppvObject
			) ;	
};

//
class CSystemConfigChangeEvent : 
	public CEventProvider, 
	public CWinMsgEvent
{
	private:
        void HandleEvent( long lValue );
		BOOL m_bRegistered;
	
	protected:
	public:

		CSystemConfigChangeEvent() : m_bRegistered ( FALSE ) {};
		~CSystemConfigChangeEvent() {};

		// implementation of abstract CWinMsgEvent
		virtual void WinMsgEvent(
			
			IN	HWND a_hWnd,
			IN	UINT a_message,
			IN	WPARAM a_wParam,
			IN	LPARAM	a_lParam,
			OUT E_ReturnAction &a_eRetAction,
			OUT LRESULT &a_lResult
			) ;

		// implementation of abstract CWmiEventProvider
		virtual void ProvideEvents() ;

		// implementation of class name retrieval for CEventProvider
		virtual void OnFinalRelease() ;

		// implementation of class name retrieval for CWmiProviderInit
		virtual BSTR GetClassName() ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\systemaccount.cpp ===
//=================================================================

//

// SystemAccount.CPP -- System account property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain Groups
//				 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================

#include "precomp.h"
#include "sid.h"
#include <ProvExce.h>
#include "SystemAccount.h"

//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32SystemAccount	Win32GroupAccount( PROPSET_NAME_SYSTEMACCOUNT, IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::CWin32SystemAccount
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SystemAccount::CWin32SystemAccount( const CHString &a_strName, LPCWSTR a_pszNamespace /*=NULL*/ )
:	Provider( a_strName, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::~CWin32SystemAccount
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32SystemAccount::~CWin32SystemAccount()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SystemAccount::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SystemAccount::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	BOOL t_fReturn = FALSE;

	// Find the instance depending on platform id.
	#ifdef NTONLY
		t_fReturn = RefreshInstanceNT( a_pInst ) ;
	#endif

	return t_fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND ;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SystemAccount::EnumerateInstances
//
//	Inputs:		MethodContext*	a_pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SystemAccount::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;

	// Get the proper OS dependent instance
	#ifdef NTONLY
		t_hResult = AddDynamicInstancesNT( a_pMethodContext ) ;
	#endif

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32SystemAccount::AddDynamicInstancesNT( MethodContext *a_pMethodContext )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;

	SID_IDENTIFIER_AUTHORITY	t_worldsidAuthority		= SECURITY_WORLD_SID_AUTHORITY,
								t_localsidAuthority		= SECURITY_LOCAL_SID_AUTHORITY,
								t_creatorsidAuthority	= SECURITY_CREATOR_SID_AUTHORITY,
								t_ntsidAuthority		= SECURITY_NT_AUTHORITY ;
	CSid t_accountsid;

	// This function returns what amounts to a hardcoded list of Sid Accounts meaningful
	// for security and that's about it

	// Start with the Universal Sids

	if ( GetSysAccountNameAndDomain( &t_worldsidAuthority, t_accountsid, 1, SECURITY_WORLD_RID ) )
	{
		t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_localsidAuthority, t_accountsid, 1, SECURITY_LOCAL_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_creatorsidAuthority, t_accountsid, 1, SECURITY_CREATOR_OWNER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_creatorsidAuthority, t_accountsid, 1, SECURITY_CREATOR_GROUP_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_creatorsidAuthority, t_accountsid, 1, SECURITY_CREATOR_OWNER_SERVER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_creatorsidAuthority, t_accountsid, 1, SECURITY_CREATOR_GROUP_SERVER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	// Now we handle the NT AUTHORITY Accounts

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_DIALUP_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_NETWORK_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_BATCH_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_INTERACTIVE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_SERVICE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_ANONYMOUS_LOGON_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_PROXY_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

// this creates a duplicate instance of BATCH. If you cahnge the sidAuthority to any of the other
// possible choices, it creates dupes of other instances.   I say we don't need it.  BWS.
//	if ( SUCCEEDED( t_hResult ) )
//	{
//		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_CREATOR_GROUP_SERVER_RID ) )
//		{
//			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
//		}
//	}

	if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_LOCAL_SYSTEM_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}
    
    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_ENTERPRISE_CONTROLLERS_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_PRINCIPAL_SELF_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_AUTHENTICATED_USER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_RESTRICTED_CODE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_TERMINAL_SERVER_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_REMOTE_LOGON_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_LOGON_IDS_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_LOCAL_SERVICE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_NETWORK_SERVICE_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}

    if ( SUCCEEDED( t_hResult ) )
	{
		if ( GetSysAccountNameAndDomain( &t_ntsidAuthority, t_accountsid, 1, SECURITY_BUILTIN_DOMAIN_RID ) )
		{
			t_hResult = CommitSystemAccount( t_accountsid, a_pMethodContext ) ;
		}
	}
    

    return t_hResult;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::GetSysAccountNameAndDomain
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32SystemAccount::GetSysAccountNameAndDomain(
													 PSID_IDENTIFIER_AUTHORITY a_pAuthority,
													 CSid& a_accountsid,
													 BYTE  a_saCount /*=0*/,
													 DWORD a_dwSubAuthority1 /*=0*/,
													 DWORD a_dwSubAuthority2 /*=0*/  )
{
	BOOL t_fReturn = FALSE;
	PSID t_psid = NULL;

	if ( AllocateAndInitializeSid(	a_pAuthority,
									a_saCount,
									a_dwSubAuthority1,
									a_dwSubAuthority2,
									0,
									0,
									0,
									0,
									0,
									0,
									&t_psid ) )
	{
	    try
	    {
			CSid t_sid( t_psid ) ;

            // a-kevhu said this line is redundant duplication
//			CSid t_sid2( TOBSTRT( t_sid.GetAccountName() ), NULL ) ;

			// The SID may be valid in this case, however the Lookup may have failed
			if ( t_sid.IsValid() && t_sid.IsOK() )
			{
				a_accountsid = t_sid;
				t_fReturn = TRUE;
			}

	    }
	    catch( ... )
	    {
		    if( t_psid )
		    {
			    FreeSid( t_psid ) ;
		    }
		    throw ;
	    }

		// Cleanup the sid
		FreeSid( t_psid ) ;
	}

	return t_fReturn;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::CommitSystemAccount
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SystemAccount::CommitSystemAccount( CSid &a_accountsid, MethodContext *a_pMethodContext )
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	CInstancePtr t_pInst(CreateNewInstance( a_pMethodContext ), false);

	FillInstance( a_accountsid, t_pInst ) ;

	t_hResult = t_pInst->Commit(  ) ;

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemAccount::FillInstance
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32SystemAccount::FillInstance( CSid &a_accountsid, CInstance *a_pInst )
{
	CHString t_strDesc;
	CHString t_strDomain = a_accountsid.GetDomainName() ;
    CHString chstrNT_AUTHORITY;
    CHString chstrBuiltIn;

    if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) && GetLocalizedBuiltInString(chstrBuiltIn))
    {
		// Replace NT AUTHORITY with a human readable string
		//if ( 0 == t_strDomain.CompareNoCase( L"NT AUTHORITY" ) )
		if ( 0 == t_strDomain.CompareNoCase(chstrNT_AUTHORITY) ||
			 t_strDomain.IsEmpty())
		{
			t_strDomain = GetLocalComputerName() ;
		}
		else if( t_strDomain.CompareNoCase(chstrBuiltIn) == 0)
		{
			t_strDomain = GetLocalComputerName() ;
		}
	}

	if ( t_strDomain.IsEmpty() )
	{
		t_strDesc = a_accountsid.GetAccountName() ;
	}
	else
	{
		t_strDesc = t_strDomain + _T('\\') + a_accountsid.GetAccountName() ;
	}

	a_pInst->SetCHString(	IDS_Name, a_accountsid.GetAccountName() ) ;
	a_pInst->SetCHString(	IDS_Domain, t_strDomain ) ;
	a_pInst->SetCHString(	L"SID", a_accountsid.GetSidString() ) ;
	a_pInst->SetByte(		L"SIDType", a_accountsid.GetAccountType() ) ;
	a_pInst->SetCHString(	L"Caption", t_strDesc ) ;
	a_pInst->SetCHString(	L"Description", t_strDesc ) ;
	a_pInst->SetCharSplat(	L"Status", _T("OK") ) ;
    a_pInst->Setbool(IDS_LocalAccount, true);

}

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceNT
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32SystemAccount::RefreshInstanceNT( CInstance *a_pInst )
{
	BOOL		t_fReturn = FALSE;

	CHString	t_strDomain,
				t_strAccountDomain,
				t_strName,
				t_strComputerName;

	a_pInst->GetCHString( IDS_Name, t_strName ) ;
	a_pInst->GetCHString( IDS_Domain, t_strDomain ) ;

	t_strComputerName = GetLocalComputerName() ;

    CHString chstrNT_AUTHORITY;
    CHString chstrBuiltIn;

    if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) && GetLocalizedBuiltInString(chstrBuiltIn))
    {
		// Supplied domain name must be either "Empty" or the computer name
		if ( t_strDomain.IsEmpty() || t_strDomain.CompareNoCase( t_strComputerName ) == 0 )
		{
			CSid t_sidAccount( t_strName, NULL ) ;

			if ( t_sidAccount.IsValid() && t_sidAccount.IsOK() )
			{
				// This will give us the value returned by the Lookup as opposed to what
				// was passed in.

				t_strAccountDomain = t_sidAccount.GetDomainName() ;

				// The only valid retrieved domain names we support are: "" and "NT AUTHORITY"
				//if ( t_strAccountDomain.IsEmpty() || t_strAccountDomain.CompareNoCase( _T("NT AUTHORITY") ) == 0 )
				if ( t_strAccountDomain.IsEmpty() || 
					t_strAccountDomain.CompareNoCase( chstrNT_AUTHORITY ) == 0 ||
					t_strAccountDomain.CompareNoCase(chstrBuiltIn) == 0)
				{
					// NT AUTHORITY means the local computer name.
					//if ( t_strAccountDomain.CompareNoCase( _T("NT AUTHORITY") ) == 0 )
					//if ( t_strAccountDomain.CompareNoCase( t_strAuthorityDomain ) == 0 )
					{
						t_strAccountDomain = GetLocalComputerName() ;
					}

					// The retrieved Account Domain and the supplied account domain must be the same, or the
					// values really don't quite match the instance
					if ( t_strDomain.CompareNoCase( t_strAccountDomain ) == 0 )
					{
						FillInstance( t_sidAccount, a_pInst ) ;
						t_fReturn = TRUE;
					}

				}	// IF valid account domain

			}	// IF account ok

		}	// IF valid domain
    } 

    return t_fReturn ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\systemdriver.h ===
//=================================================================

//

// SystemDriver.h -- Service property set provider (Windows NT only)

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//				 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//											clean up	
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_SYSTEM_DRIVER L"Win32_SystemDriver"
#define PROPSET_NAME_PARAMETERCLASS		"__PARAMETERS"

// Get/set function protos
//========================

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

typedef WINADVAPI BOOL ( WINAPI *PROC_QueryServiceStatusEx ) (

    SC_HANDLE           hService,
    SC_STATUS_TYPE      InfoLevel,
    LPBYTE              lpBuffer,
    DWORD               cbBufSize,
    LPDWORD             pcbBytesNeeded
) ;

class CWin32SystemDriver : public Win32_BaseService 
{
	private:

        CHPtrArray m_ptrProperties;

		// Utility function(s)
		//====================

		HRESULT RefreshInstance (

			CInstance *pInstance,
            DWORD dwProperties
		) ;

		HRESULT AddDynamicInstances (

			MethodContext *pMethodContext, 
			DWORD dwProperties
		) ;


        HRESULT AddDynamicInstancesWin95(	

            MethodContext *a_pMethodContext,
			DWORD dwProperties
        ) ;

		HRESULT LoadPropertyValuesNT (

			SC_HANDLE hDBHandle, 
			LPCTSTR szServiceName, 
			CInstance *pInstance, 
			DWORD dwProperties,
			CAdvApi32Api *a_pAdvApi32
		) ;

		HRESULT LoadPropertyValuesWin2K (

			SC_HANDLE hDBHandle, 
			SERVICE_STATUS &a_ServiceStatus ,
			LPCTSTR szServiceName, 
			CInstance *pInstance, 
			DWORD dwProperties,
			CAdvApi32Api *a_pAdvApi32
		) ;

		void LoadPropertyValuesWin95 (

			LPCTSTR szServiceName, 
			CInstance *pInstance, 
			CRegistry &COne, 
			DWORD dwType)
		;
	public:

		// Constructor/destructor
		//=======================

		CWin32SystemDriver( const CHString &a_name, LPCWSTR a_pszNamespace ) ;
		~CWin32SystemDriver() ;

		// Functions provide properties with current values
		//=================================================

		HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
            CFrameworkQuery& pQuery
		);

		HRESULT EnumerateInstances (

			MethodContext *pMethodContext, 
			long lFlags = 0L
		);

		HRESULT ExecQuery (

			MethodContext *pMethodContext, 
			CFrameworkQuery& pQuery, 
			long lFlags /*= 0L*/ 
		);

		HRESULT PutInstance ( 

			const CInstance &a_Instance, 
			long lFlags /*= 0L*/ 
		) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\systemdriver.cpp ===
//=================================================================

//

// SystemDriver.CPP -- SystemDriver property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//				 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//											syntactic clean up
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>

#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include <frqueryex.h>

#include "bservice.h"
#include "SystemDriver.h"
#include "computersystem.h"

#define BIT_ALL_PROPERTIES          0xffffffff
#define BIT_Name                    0x00000001
#define BIT_State                   0x00000002
#define BIT_Started                 0x00000004
#define BIT_AcceptStop              0x00000008
#define BIT_AcceptPause             0x00000010
//#define BIT_ProcessId               0x00000020 // Does not apply to drivers
#define BIT_ExitCode                0x00000040
#define BIT_ServiceSpecificExitCode 0x00000080
//#define BIT_CheckPoint              0x00000100 // Does not apply to drivers
//#define BIT_WaitHint                0x00000200 // Does not apply to drivers
#define BIT_Status                  0x00000400
#define BIT_Caption                 0x00000800
#define BIT_DisplayName             0x00001000
#define BIT_Description             0x00002000
#define BIT_TagId                   0x00004000
#define BIT_ServiceType             0x00008000
#define BIT_DesktopInteract         0x00010000
#define BIT_StartMode               0x00020000
#define BIT_ErrorControl            0x00040000
#define BIT_PathName                0x00080000
#define BIT_StartName               0x00100000
#define BIT_CreationClassName       0x00200000
#define BIT_SystemCreationClassName 0x00400000
#define BIT_SystemName              0x00800000

// Property set declaration
//=========================

CWin32SystemDriver MySystemDriver(PROPSET_NAME_SYSTEM_DRIVER, IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::CWin32SystemDriver
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SystemDriver :: CWin32SystemDriver (
	const CHString &a_name,
	LPCWSTR a_pszNamespace

) : Win32_BaseService( a_name, a_pszNamespace )
{
    m_ptrProperties.SetSize(24);

    m_ptrProperties[0] = ((LPVOID) IDS_Name);
    m_ptrProperties[1] = ((LPVOID) IDS_State);
    m_ptrProperties[2] = ((LPVOID) IDS_Started);
    m_ptrProperties[3] = ((LPVOID) IDS_AcceptStop);
    m_ptrProperties[4] = ((LPVOID) IDS_AcceptPause);
    m_ptrProperties[5] = ((LPVOID) IDS_ProcessId);
    m_ptrProperties[6] = ((LPVOID) IDS_ExitCode);
    m_ptrProperties[7] = ((LPVOID) IDS_ServiceSpecificExitCode);
    m_ptrProperties[8] = ((LPVOID) IDS_CheckPoint);
    m_ptrProperties[9] = ((LPVOID) IDS_WaitHint);
    m_ptrProperties[10] = ((LPVOID) IDS_Status);
    m_ptrProperties[11] = ((LPVOID) IDS_Caption);
    m_ptrProperties[12] = ((LPVOID) IDS_DisplayName);
    m_ptrProperties[13] = ((LPVOID) IDS_Description);
    m_ptrProperties[14] = ((LPVOID) IDS_TagId);
    m_ptrProperties[15] = ((LPVOID) IDS_ServiceType);
    m_ptrProperties[16] = ((LPVOID) IDS_DesktopInteract);
    m_ptrProperties[17] = ((LPVOID) IDS_StartMode);
    m_ptrProperties[18] = ((LPVOID) IDS_ErrorControl);
    m_ptrProperties[19] = ((LPVOID) IDS_PathName);
    m_ptrProperties[20] = ((LPVOID) IDS_StartName);
    m_ptrProperties[21] = ((LPVOID) IDS_CreationClassName);
    m_ptrProperties[22] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[23] = ((LPVOID) IDS_SystemName);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::~CWin32SystemDriver
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

CWin32SystemDriver :: ~CWin32SystemDriver ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SystemDriver :: ExecQuery (
	MethodContext *a_pMethodContext,
	CFrameworkQuery &a_pQuery,
	long a_lFlags /*= 0L*/
)
{
    HRESULT t_hResult ;

#ifdef NTONLY
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&a_pQuery);

    DWORD dwProperties = BIT_ALL_PROPERTIES;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    t_hResult = AddDynamicInstances( a_pMethodContext, dwProperties ) ;
#endif
    return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SystemDriver :: GetObject (
	CInstance *a_pInst,
	long a_lFlags,
    CFrameworkQuery &a_pQuery
)
{
	// OS specific compiled call
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&a_pQuery);

    DWORD dwProperties = BIT_ALL_PROPERTIES;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

	HRESULT hRes = RefreshInstance( a_pInst, dwProperties ) ;
	if ( hRes == WBEM_E_ACCESS_DENIED )
	{
		hRes = WBEM_S_NO_ERROR ;
	}

	return hRes ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SystemDriver :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long lFlags /*= 0L*/
)
{
	// OS specific compiled call
#ifdef NTONLY
	return AddDynamicInstances( a_pMethodContext, BIT_ALL_PROPERTIES ) ;
#endif

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::RefreshInstanceNT
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32SystemDriver::RefreshInstance( CInstance *a_pInst, DWORD dwProperties )
{
	HRESULT t_hResult = WBEM_E_FAILED;

	SmartCloseServiceHandle t_hDBHandle;
	CAdvApi32Api *t_pAdvApi32 = NULL ;

	// Check to see if this is us...

	try
	{
		CHString t_sName;
		if( !a_pInst->GetCHString( IDS_Name, t_sName ) || t_sName.IsEmpty() )
		{
			return WBEM_E_NOT_FOUND ;
		}

		// Get an scman handle
		if( t_hDBHandle = OpenSCManager( NULL, NULL, GENERIC_READ ) )
		{
			// Create copy of name & pass to LoadPropertyValues
			//=================================================

			PROC_QueryServiceStatusEx t_QueryServiceStatusEx = NULL ;

			if ( IsWinNT5 () )
			{
				t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidAdvApi32Api, NULL ) ;
			}

			t_hResult = LoadPropertyValuesNT (

				t_hDBHandle,
				(LPCTSTR) t_sName,
				a_pInst,
				dwProperties ,
				t_pAdvApi32
			 ) ;
		}
	}
	catch( ... )
	{
		if( t_pAdvApi32 )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidAdvApi32Api, t_pAdvApi32 ) ;
		}
		throw ;
	}

	if( t_pAdvApi32 != NULL )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidAdvApi32Api, t_pAdvApi32 ) ;
		t_pAdvApi32 = NULL;
	}

	return t_hResult;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32SystemDriver::AddDynamicInstances (

	MethodContext *a_pMethodContext,
	DWORD dwProperties
)
{
    HRESULT t_hResult	= WBEM_E_FAILED ;
	SmartCloseServiceHandle	t_hDBHandle;
	ENUM_SERVICE_STATUS	*t_pServiceList = NULL ;
	CAdvApi32Api		*t_pAdvApi32 = NULL ;

	try
	{
		// Get handle to the services database
		//====================================

		t_hDBHandle = OpenSCManager( NULL, NULL, GENERIC_READ ) ;

		if( t_hDBHandle == NULL )
		{
			return t_hResult;
		}

		// Make call once to get buffer size (should return
		// FALSE but fill in buffer size)
		//=================================================

		DWORD t_i, t_hEnumHandle = 0, t_dwByteCount = 0, t_dwEntryCount ;

		BOOL t_EnumStatus = EnumServicesStatus (

			t_hDBHandle,
			SERVICE_DRIVER ,
			SERVICE_ACTIVE | SERVICE_INACTIVE,
			t_pServiceList,
			t_dwByteCount,
			&t_dwByteCount,
			&t_dwEntryCount,
			&t_hEnumHandle
		) ;

		if ( t_EnumStatus == FALSE && GetLastError() == ERROR_MORE_DATA )
		{
			// Allocate the required buffer
			//=============================

			t_pServiceList = reinterpret_cast<LPENUM_SERVICE_STATUS> (new char[ t_dwByteCount ] ) ;
			if( t_pServiceList != NULL )
			{
                try
                {
				    memset( t_pServiceList, 0, t_dwByteCount ) ;

				    t_EnumStatus = EnumServicesStatus (

					    t_hDBHandle,
					    SERVICE_DRIVER, SERVICE_ACTIVE | SERVICE_INACTIVE,
					    t_pServiceList,
					    t_dwByteCount,
					    &t_dwByteCount,
					    &t_dwEntryCount,
					    &t_hEnumHandle
				    ) ;

				    if ( t_EnumStatus == TRUE )
				    {

					    t_hResult = WBEM_S_NO_ERROR;

					    if ( IsWinNT5 () )
					    {
						    t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidAdvApi32Api, NULL ) ;
					    }

					    // smart ptr
					    CInstancePtr t_pInst ;

					    // Create instance for each returned Driver
					    //==========================================

					    for( t_i = 0 ; t_i < t_dwEntryCount; t_i++ )
					    {
						    t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

							// Load and save
#if NTONLY >= 5
							t_hResult = LoadPropertyValuesWin2K (

								t_hDBHandle,
								t_pServiceList[ t_i ].ServiceStatus,
								t_pServiceList[ t_i ].lpServiceName,
								t_pInst,
								dwProperties ,
								t_pAdvApi32
							 ) ;
#else
							t_hResult = LoadPropertyValuesNT (

								t_hDBHandle,
								t_pServiceList[ t_i ].lpServiceName,
								t_pInst,
								dwProperties ,
								t_pAdvApi32
							 ) ;
#endif

							if ( t_hResult == WBEM_S_NO_ERROR ||
								 t_hResult == WBEM_E_ACCESS_DENIED ) // can enumerate the driver but can't open it
							{
								t_hResult = t_pInst->Commit() ;
							}

							t_hResult = WBEM_S_NO_ERROR ;
					    }
				    }
                }
                catch ( ... )
                {
    				delete [] reinterpret_cast<char *> ( t_pServiceList ) ;
					t_pServiceList = NULL ;
                    throw;
                }

				delete [] reinterpret_cast<char *> ( t_pServiceList ) ;
				t_pServiceList = NULL ;
			}
		}
	}
	catch( ... )
	{
		if( t_pServiceList )
		{
			delete [] reinterpret_cast<char *> ( t_pServiceList ) ;
		}
		if( t_pAdvApi32 )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidAdvApi32Api, t_pAdvApi32 ) ;
		}

		throw ;
	}

	if( t_pAdvApi32 != NULL )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidAdvApi32Api, t_pAdvApi32 ) ;
		t_pAdvApi32 = NULL ;
	}

	return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Service::LoadPropertyValuesNT
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32SystemDriver::LoadPropertyValuesWin2K (

	SC_HANDLE hDBHandle,
	SERVICE_STATUS &a_StatusInfo ,
	LPCTSTR a_szServiceName,
	CInstance *a_pInst,
	DWORD dwProperties,
	CAdvApi32Api* a_pAdvApi32
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR; // Since we have the name, we can populate the key.

	// Redundant for getobject, but hey...

	a_pInst->SetCHString( IDS_Name, a_szServiceName ) ;
	a_pInst->SetCHString( IDS_CreationClassName, PROPSET_NAME_SYSTEM_DRIVER ) ;
	a_pInst->SetCHString( IDS_SystemCreationClassName, PROPSET_NAME_COMPSYS ) ;
	a_pInst->SetCHString( IDS_SystemName, (LPCTSTR)GetLocalComputerName() ) ;

  // If they want any of these, we'll have to do StatusInfo

    BOOL t_bStatusInfo = dwProperties &
        (BIT_State | BIT_Started | BIT_AcceptStop | BIT_AcceptPause | BIT_Status |
         BIT_ExitCode | BIT_ServiceSpecificExitCode );


    BOOL t_bConfigInfo = dwProperties &
        (BIT_TagId | BIT_ServiceType | BIT_DesktopInteract | BIT_StartMode |
         BIT_ErrorControl | BIT_PathName | BIT_DisplayName | BIT_Caption |
         BIT_Description | BIT_StartName);

	// If all they wanted was the name, skip all this.
	if ( t_bStatusInfo || t_bConfigInfo )
	{
		SmartCloseServiceHandle hSvcHandle = NULL ;
		DWORD t_dwLastError = 0 ;

        if ( ( dwProperties & BIT_Status ) || t_bConfigInfo )
        {
			hSvcHandle = OpenService (

				hDBHandle,
				a_szServiceName,
				SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_INTERROGATE
			) ;

			t_dwLastError = GetLastError();

			if ( ( hSvcHandle == NULL ) && ( ERROR_SERVICE_DOES_NOT_EXIST == t_dwLastError || ERROR_INVALID_NAME == t_dwLastError) )
			{
				return WBEM_E_NOT_FOUND ;
			}
		}			

		// If the service could not be opened
		// drop through and collect up the defaults
		// ========================================
		if ( t_bStatusInfo )
		{
			DWORD t_CurrentState = a_StatusInfo.dwCurrentState ;
			DWORD t_ControlsAccepted = a_StatusInfo.dwControlsAccepted ;
			DWORD t_Win32ExitCode = a_StatusInfo.dwWin32ExitCode ;
			DWORD t_ServiceSpecific = a_StatusInfo.dwServiceSpecificExitCode ;

			bool bStarted = true;

			switch (t_CurrentState)
			{
				case SERVICE_STOPPED:
				{
					a_pInst->SetCharSplat(IDS_State, _T("Stopped"));
					bStarted = false;
				}
				break;

				case SERVICE_START_PENDING:
				{
					a_pInst->SetCharSplat(IDS_State, _T("Start Pending"));
					bStarted = true;
				}
				break;

				case SERVICE_STOP_PENDING:
				{
					a_pInst->SetCharSplat(IDS_State, _T("Stop Pending"));
					bStarted = true;
				}
				break;

				case SERVICE_RUNNING:
				{
					a_pInst->SetCharSplat(IDS_State, _T("Running"));
					bStarted = true;
				}
				break;

				case SERVICE_CONTINUE_PENDING:
				{
					a_pInst->SetCharSplat(IDS_State, _T("Continue Pending"));
					bStarted = true;
				}
				break;

				case SERVICE_PAUSE_PENDING:
				{
					a_pInst->SetCharSplat(IDS_State, _T("Pause Pending"));
					bStarted = true;
				}
				break;

				case SERVICE_PAUSED:
				{
					a_pInst->SetCharSplat(IDS_State, _T("Paused"));
					bStarted = true;
				}
				break;

				default:
				{
					a_pInst->SetCharSplat(IDS_State, _T("Unknown") );
					bStarted = true;
				}
				break;
			}

			a_pInst->Setbool(IDS_Started, bStarted);
			a_pInst->Setbool(IDS_AcceptStop, (t_ControlsAccepted) & SERVICE_ACCEPT_STOP);
			a_pInst->Setbool(IDS_AcceptPause, (t_ControlsAccepted) & SERVICE_ACCEPT_PAUSE_CONTINUE);

			a_pInst->SetDWORD ( IDS_ExitCode , t_Win32ExitCode ) ;
			a_pInst->SetDWORD ( IDS_ServiceSpecificExitCode , t_ServiceSpecific ) ;

            if (dwProperties & BIT_Status)
            {
			    if( hSvcHandle )
			    {
				    SERVICE_STATUS StatusInfo ;
				    if ( ( ! bStarted ) || ( ControlService ( hSvcHandle , SERVICE_CONTROL_INTERROGATE , &StatusInfo ) != 0 ) )
				    {
					    a_pInst->SetCharSplat(IDS_Status, IDS_OK);
				    }
				    else
				    {
					    a_pInst->SetCharSplat(IDS_Status, IDS_Degraded);
				    }
			    }
			    else
			    {
				    a_pInst->SetCharSplat(IDS_Status, IDS_Unknown);
			    }
            }
		}

		if (t_bConfigInfo)
		{
			// Get the rest of the config info
			//================================
			char ConfigBuffer[1024] ;
			LPQUERY_SERVICE_CONFIG t_pConfigInfo = ( LPQUERY_SERVICE_CONFIG ) ConfigBuffer ;

			// These may get overwritten below if we can find something better

			a_pInst->SetCharSplat(IDS_Caption, a_szServiceName );
			a_pInst->SetCharSplat(IDS_DisplayName, a_szServiceName );
			a_pInst->SetCHString( IDS_Description, a_szServiceName ) ;

			memset( ConfigBuffer, 0, sizeof( ConfigBuffer ) ) ;
			DWORD t_dwByteCount ;

			if( QueryServiceConfig( hSvcHandle, t_pConfigInfo, sizeof( ConfigBuffer ), &t_dwByteCount ) == TRUE )
			{
				a_pInst->SetDWORD( IDS_TagId, t_pConfigInfo->dwTagId ) ;

				switch ( t_pConfigInfo->dwServiceType & (~SERVICE_INTERACTIVE_PROCESS) )
				{
					case SERVICE_WIN32_OWN_PROCESS:
					{
						a_pInst->SetCharSplat( IDS_ServiceType, _T("Own Process") ) ;
						t_hResult = WBEM_E_NOT_FOUND ;  // Not a driver
					}
					break ;

					case SERVICE_WIN32_SHARE_PROCESS:
					{
						a_pInst->SetCharSplat( IDS_ServiceType, L"Share Process" ) ;
						t_hResult = WBEM_E_NOT_FOUND ;  // Not a driver
					}
					break ;

					case SERVICE_KERNEL_DRIVER:
					{
						a_pInst->SetCharSplat( IDS_ServiceType, L"Kernel Driver" ) ;
					}
					break ;

					case SERVICE_FILE_SYSTEM_DRIVER:
					{
						a_pInst->SetCharSplat( IDS_ServiceType, L"File System Driver" ) ;
					}
					break ;

					default:
					{
						a_pInst->SetCharSplat( IDS_ServiceType, L"Unknown" ) ;
					}
					break ;
				}

				switch ( t_pConfigInfo->dwStartType )
				{
					case SERVICE_BOOT_START:
					{
						a_pInst->SetCharSplat( IDS_StartMode, L"Boot" ) ;
					}
					break ;

					case SERVICE_SYSTEM_START:
					{
						a_pInst->SetCharSplat( IDS_StartMode, L"System" ) ;
					}
					break ;

					case SERVICE_AUTO_START:
					{
						a_pInst->SetCharSplat( IDS_StartMode, L"Auto" ) ;
					}
					break ;

					case SERVICE_DEMAND_START:
					{
						a_pInst->SetCharSplat( IDS_StartMode, L"Manual" ) ;
					}
					break ;

					case SERVICE_DISABLED:
					{
						a_pInst->SetCharSplat( IDS_StartMode, L"Disabled" ) ;
					}
					break ;

					default:
					{
						a_pInst->SetCharSplat( IDS_StartMode, L"Unknown" ) ;
					}
					break ;
				}

				a_pInst->Setbool( IDS_DesktopInteract, t_pConfigInfo->dwServiceType & SERVICE_INTERACTIVE_PROCESS ) ;

				switch ( t_pConfigInfo->dwErrorControl )
				{
					case SERVICE_ERROR_IGNORE:
					{
						a_pInst->SetCharSplat( IDS_ErrorControl, L"Ignore" ) ;
					}
					break ;

					case SERVICE_ERROR_NORMAL:
					{
						a_pInst->SetCharSplat( IDS_ErrorControl, L"Normal" ) ;
					}
					break ;

					case SERVICE_ERROR_SEVERE:
					{
						a_pInst->SetCharSplat( IDS_ErrorControl, L"Severe" ) ;
					}
					break ;

					case SERVICE_ERROR_CRITICAL:
					{
						a_pInst->SetCharSplat( IDS_ErrorControl, L"Critical" ) ;
					}
					break ;

					default:
					{
						a_pInst->SetCharSplat( IDS_ErrorControl, L"Unknown" ) ;
					}
					break ;
				}

				if( t_pConfigInfo->lpBinaryPathName && t_pConfigInfo->lpBinaryPathName[ 0 ] )
				{
					// NT sometimes stores strange strings for the path.  This
					// code attempts to turn them back into real paths.
					CHString t_sPathName( t_pConfigInfo->lpBinaryPathName ) ;

					if ( t_sPathName.Left( 9 ).CompareNoCase( L"System32\\" ) == 0 )
					{
						CHString t_sSystemDir ;
        				GetSystemDirectory( t_sSystemDir.GetBuffer(MAX_PATH), MAX_PATH ) ;
						t_sSystemDir.ReleaseBuffer( ) ;

						t_sPathName = t_sSystemDir + L'\\' + t_sPathName.Mid( 9 ) ;
					}

					if ( t_sPathName.Left(21).CompareNoCase( L"\\SystemRoot\\System32\\" ) == 0 )
					{
						CHString t_sSystemDir;
        				GetSystemDirectory( t_sSystemDir.GetBuffer(MAX_PATH), MAX_PATH ) ;
						t_sSystemDir.ReleaseBuffer( ) ;

						t_sPathName = t_sSystemDir + L'\\' + t_sPathName.Mid( 21 ) ;
					}

					a_pInst->SetCHString( IDS_PathName, t_sPathName  ) ;
				}
				else
				{
					// Let's make a guess about where we think the file might live (This is how
					// device manager in nt5 does this).
					CHString t_sPathName;

    				GetSystemDirectory( t_sPathName.GetBuffer( MAX_PATH ), MAX_PATH ) ;
	    			t_sPathName.ReleaseBuffer( ) ;

					t_sPathName += L"\\drivers\\" ;
					t_sPathName += a_szServiceName;
					t_sPathName += L".sys" ;

					// Now, if the file doesn't really exist there, let's not pretend it does.
					if ( GetFileAttributes( t_sPathName ) != 0xffffffff )
					{
    					a_pInst->SetCHString( IDS_PathName, t_sPathName ) ;
					}
				}

				if( t_pConfigInfo->lpServiceStartName && t_pConfigInfo->lpServiceStartName[ 0 ] )
				{
					a_pInst->SetCHString( IDS_StartName, t_pConfigInfo->lpServiceStartName ) ;
				}
				else
				{
					a_pInst->SetCHString( IDS_StartName, _T("") ) ;
				}

				// The display name would make a better description and caption if we can get it

				if( t_pConfigInfo->lpDisplayName && t_pConfigInfo->lpDisplayName[ 0 ] )
				{
					a_pInst->SetCHString( IDS_DisplayName, t_pConfigInfo->lpDisplayName  ) ;
					a_pInst->SetCHString( IDS_Caption, t_pConfigInfo->lpDisplayName  ) ;
					a_pInst->SetCHString( IDS_Description, t_pConfigInfo->lpDisplayName  ) ;
				}
			}
			else
			{
				a_pInst->SetCHString( IDS_ServiceType, _T("Unknown") ) ;
				a_pInst->SetCHString( IDS_StartMode, _T("Unknown") ) ;
				a_pInst->SetCHString( IDS_ErrorControl, _T("Unknown") ) ;
			}
		}

		if( NULL == (SC_HANDLE)hSvcHandle && ERROR_ACCESS_DENIED == t_dwLastError )
		{
			// could enumerate the service but could not open it
			t_hResult = WBEM_E_ACCESS_DENIED ;
		}
		else
		{
			// Service not started, etc...
			t_hResult = WBEM_NO_ERROR ;
		}
	}
	else
	{
	   t_hResult = WBEM_S_NO_ERROR;
	}

    return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemDriver::LoadPropertyValuesNT
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32SystemDriver :: LoadPropertyValuesNT (

	SC_HANDLE	a_hDBHandle,
	LPCTSTR		a_szServiceName,
	CInstance	*a_pInst,
	DWORD dwProperties,
	CAdvApi32Api *a_pAdvApi32
)
{
    char	t_ConfigBuffer[1024] ;
    LPQUERY_SERVICE_CONFIG t_pConfigInfo = (LPQUERY_SERVICE_CONFIG) t_ConfigBuffer ;
    DWORD	t_dwByteCount ;
    bool	t_bStarted;

    HRESULT t_hResult = WBEM_S_NO_ERROR ; // Since we have the name, we can populate the key.
	SmartCloseServiceHandle t_hSvcHandle;

	// Redundant for getobject, but hey...

	a_pInst->SetCHString( IDS_Name, a_szServiceName ) ;
	a_pInst->SetCHString( IDS_CreationClassName, PROPSET_NAME_SYSTEM_DRIVER ) ;
	a_pInst->SetCHString( IDS_SystemCreationClassName, PROPSET_NAME_COMPSYS ) ;
	a_pInst->SetCHString( IDS_SystemName, (LPCTSTR)GetLocalComputerName() ) ;

	// Open the Driver
	//=================

	// Check to see if we HAVE to open the service.  If we are running as a
	// query and they didn't request some of these properties, let's not waste the time.

    BOOL t_bStatusInfo = dwProperties &
        (BIT_State | BIT_Started | BIT_AcceptStop | BIT_AcceptPause | BIT_Status |
         BIT_ExitCode | BIT_ServiceSpecificExitCode );


    BOOL t_bConfigInfo = dwProperties &
        (BIT_TagId | BIT_ServiceType | BIT_DesktopInteract | BIT_StartMode |
         BIT_ErrorControl | BIT_PathName | BIT_DisplayName | BIT_Caption |
         BIT_Description | BIT_StartName);

	t_hSvcHandle = OpenService (

		a_hDBHandle,
		a_szServiceName,
		SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_INTERROGATE
	) ;

	DWORD t_dwLastError = GetLastError();

	if ( ( t_hSvcHandle == NULL ) && ( ERROR_SERVICE_DOES_NOT_EXIST == t_dwLastError || ERROR_INVALID_NAME == t_dwLastError) )
	{
		return WBEM_E_NOT_FOUND;
	}

	// is it a System driver?
	memset( t_ConfigBuffer, 0, sizeof( t_ConfigBuffer ) ) ;

	if( QueryServiceConfig( t_hSvcHandle, t_pConfigInfo, sizeof( t_ConfigBuffer ), &t_dwByteCount ) == TRUE )
	{
		a_pInst->SetDWORD( IDS_TagId, t_pConfigInfo->dwTagId ) ;

		switch ( t_pConfigInfo->dwServiceType & (~SERVICE_INTERACTIVE_PROCESS) )
		{
			case SERVICE_WIN32_OWN_PROCESS:
			case SERVICE_WIN32_SHARE_PROCESS:
			{
				return WBEM_E_NOT_FOUND;  // Not a driver
			}
			break ;
		}
	}

	{
		// If all they wanted was the name, skip all this.
		if ( t_bStatusInfo || t_bConfigInfo )
		{
			// Get current service status
			//===========================

			if ( t_bStatusInfo)
			{
				DWORD t_CurrentState ;
				DWORD t_ControlsAccepted ;
				DWORD t_Win32ExitCode = 0 ;
				DWORD t_ServiceSpecific = 0 ;

				BOOL t_Status = FALSE ;
				if ( IsWinNT5() && a_pAdvApi32 != NULL )
				{
					SERVICE_STATUS_PROCESS t_StatusInfo ;

					DWORD t_ExpectedSize = 0 ;
					if(a_pAdvApi32->QueryServiceStatusEx(	t_hSvcHandle,
																	SC_STATUS_PROCESS_INFO,
																	( UCHAR * ) &t_StatusInfo,
																	sizeof ( t_StatusInfo ),
																	&t_ExpectedSize , &t_Status ) )
					{
						if ( t_Status == TRUE )
						{
							t_CurrentState		= t_StatusInfo.dwCurrentState ;
							t_ControlsAccepted	= t_StatusInfo.dwControlsAccepted ;
							t_Win32ExitCode		= t_StatusInfo.dwWin32ExitCode ;
							t_ServiceSpecific	= t_StatusInfo.dwServiceSpecificExitCode ;
						}
					}
				}

				if(!t_Status)
				{
					SERVICE_STATUS t_StatusInfo ;
					t_Status = QueryServiceStatus( t_hSvcHandle, &t_StatusInfo ) ;

					if( t_Status == TRUE )
					{
						t_CurrentState		= t_StatusInfo.dwCurrentState ;
						t_ControlsAccepted	= t_StatusInfo.dwControlsAccepted ;
						t_Win32ExitCode		= t_StatusInfo.dwWin32ExitCode ;
						t_ServiceSpecific	= t_StatusInfo.dwServiceSpecificExitCode ;
					}
				}

				if ( t_Status )
				{
					switch ( t_CurrentState )
					{
						case SERVICE_STOPPED:
						{
							a_pInst->SetCharSplat( IDS_State , L"Stopped" ) ;
							t_bStarted = false ;
						}
						break ;

						case SERVICE_START_PENDING:
						{
							a_pInst->SetCharSplat( IDS_State, L"Start Pending"  ) ;
							t_bStarted = true ;
						}
						break ;

						case SERVICE_STOP_PENDING:
						{
							a_pInst->SetCharSplat( IDS_State , L"Stop Pending"  ) ;
							t_bStarted = true ;
						}
						break ;

						case SERVICE_RUNNING:
						{
							a_pInst->SetCharSplat( IDS_State, L"Running" ) ;
							t_bStarted = true;
						}
						break ;

						case SERVICE_CONTINUE_PENDING:
						{
							a_pInst->SetCharSplat( IDS_State, L"Continue Pending" ) ;
							t_bStarted = true ;
						}
						break ;

						case SERVICE_PAUSE_PENDING:
						{
							a_pInst->SetCharSplat( IDS_State, L"Pause Pending" ) ;
							t_bStarted = true;
						}
						break ;

						case SERVICE_PAUSED:
						{
							a_pInst->SetCharSplat( IDS_State, L"Paused" ) ;
							t_bStarted = true ;
						}
						break ;

						default:
						{
							a_pInst->SetCharSplat( IDS_State, L"Unknown" ) ;
							t_bStarted = true ;
						}
						break ;
					}

					a_pInst->Setbool( IDS_Started, t_bStarted ) ;
					a_pInst->Setbool( IDS_AcceptStop, t_ControlsAccepted & SERVICE_ACCEPT_STOP ) ;
					a_pInst->Setbool( IDS_AcceptPause, t_ControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE ) ;

					a_pInst->SetDWORD ( IDS_ExitCode, t_Win32ExitCode ) ;
					a_pInst->SetDWORD ( IDS_ServiceSpecificExitCode, t_ServiceSpecific ) ;

				}
				else
				{
					a_pInst->SetCharSplat( IDS_State, L"Unknown" ) ;
				}

                if (dwProperties & BIT_Status)
                {
				    if( t_hSvcHandle )
				    {
					    SERVICE_STATUS t_StatusInfo ;
					    if ((!t_bStarted) || ( ControlService( t_hSvcHandle, SERVICE_CONTROL_INTERROGATE, &t_StatusInfo) != 0) )
					    {
						    a_pInst->SetCharSplat( IDS_Status, L"OK" ) ;
					    }
					    else
					    {
						    a_pInst->SetCharSplat( IDS_Status, L"Degraded" ) ;
					    }
				    }
				    else
				    {
					    a_pInst->SetCharSplat(IDS_Status, _T("Unknown"));
				    }
                }
			}

			if ( t_bConfigInfo )
			{
			  // Get the rest of the config info
			  //================================

			  // These may get overwritten below if we can find something better
				a_pInst->SetCHString( IDS_Caption, a_szServiceName ) ;
				a_pInst->SetCHString( IDS_DisplayName, a_szServiceName ) ;
				a_pInst->SetCHString( IDS_Description, a_szServiceName ) ;

				memset( t_ConfigBuffer, 0, sizeof( t_ConfigBuffer ) ) ;
				if( QueryServiceConfig( t_hSvcHandle, t_pConfigInfo, sizeof( t_ConfigBuffer ), &t_dwByteCount ) == TRUE )
				{
					a_pInst->SetDWORD( IDS_TagId, t_pConfigInfo->dwTagId ) ;

					switch ( t_pConfigInfo->dwServiceType & (~SERVICE_INTERACTIVE_PROCESS) )
					{
						case SERVICE_WIN32_OWN_PROCESS:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, _T("Own Process") ) ;
							t_hResult = WBEM_E_NOT_FOUND ;  // Not a driver
						}
						break ;

						case SERVICE_WIN32_SHARE_PROCESS:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, L"Share Process" ) ;
							t_hResult = WBEM_E_NOT_FOUND ;  // Not a driver
						}
						break ;

						case SERVICE_KERNEL_DRIVER:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, L"Kernel Driver" ) ;
						}
						break ;

						case SERVICE_FILE_SYSTEM_DRIVER:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, L"File System Driver" ) ;
						}
						break ;

						default:
						{
							a_pInst->SetCharSplat( IDS_ServiceType, L"Unknown" ) ;
						}
						break ;
					}

					switch ( t_pConfigInfo->dwStartType )
					{
						case SERVICE_BOOT_START:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Boot" ) ;
						}
						break ;

						case SERVICE_SYSTEM_START:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"System" ) ;
						}
						break ;

						case SERVICE_AUTO_START:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Auto" ) ;
						}
						break ;

						case SERVICE_DEMAND_START:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Manual" ) ;
						}
						break ;

						case SERVICE_DISABLED:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Disabled" ) ;
						}
						break ;

						default:
						{
							a_pInst->SetCharSplat( IDS_StartMode, L"Unknown" ) ;
						}
						break ;
					}

					a_pInst->Setbool( IDS_DesktopInteract, t_pConfigInfo->dwServiceType & SERVICE_INTERACTIVE_PROCESS ) ;

					switch ( t_pConfigInfo->dwErrorControl )
					{
						case SERVICE_ERROR_IGNORE:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Ignore" ) ;
						}
						break ;

						case SERVICE_ERROR_NORMAL:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Normal" ) ;
						}
						break ;

						case SERVICE_ERROR_SEVERE:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Severe" ) ;
						}
						break ;

						case SERVICE_ERROR_CRITICAL:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Critical" ) ;
						}
						break ;

						default:
						{
							a_pInst->SetCharSplat( IDS_ErrorControl, L"Unknown" ) ;
						}
						break ;
					}

					if( t_pConfigInfo->lpBinaryPathName && t_pConfigInfo->lpBinaryPathName[ 0 ] )
					{
						// NT sometimes stores strange strings for the path.  This
						// code attempts to turn them back into real paths.
						CHString t_sPathName( t_pConfigInfo->lpBinaryPathName ) ;

						if ( t_sPathName.Left( 9 ).CompareNoCase( L"System32\\" ) == 0 )
						{
							CHString t_sSystemDir ;
        					GetSystemDirectory( t_sSystemDir.GetBuffer(MAX_PATH), MAX_PATH ) ;
							t_sSystemDir.ReleaseBuffer( ) ;

							t_sPathName = t_sSystemDir + L'\\' + t_sPathName.Mid( 9 ) ;
						}

						if ( t_sPathName.Left(21).CompareNoCase( L"\\SystemRoot\\System32\\" ) == 0 )
						{
							CHString t_sSystemDir;
        					GetSystemDirectory( t_sSystemDir.GetBuffer(MAX_PATH), MAX_PATH ) ;
							t_sSystemDir.ReleaseBuffer( ) ;

							t_sPathName = t_sSystemDir + L'\\' + t_sPathName.Mid( 21 ) ;
						}

						a_pInst->SetCHString( IDS_PathName, t_sPathName  ) ;
					}
					else
					{
						// Let's make a guess about where we think the file might live (This is how
						// device manager in nt5 does this).
						CHString t_sPathName;

    					GetSystemDirectory( t_sPathName.GetBuffer( MAX_PATH ), MAX_PATH ) ;
	    				t_sPathName.ReleaseBuffer( ) ;

						t_sPathName += L"\\drivers\\" ;
						t_sPathName += a_szServiceName;
						t_sPathName += L".sys" ;

						// Now, if the file doesn't really exist there, let's not pretend it does.
						if ( GetFileAttributes( t_sPathName ) != 0xffffffff )
						{
    						a_pInst->SetCHString( IDS_PathName, t_sPathName ) ;
						}
					}

					if( t_pConfigInfo->lpServiceStartName && t_pConfigInfo->lpServiceStartName[ 0 ] )
					{
						a_pInst->SetCHString( IDS_StartName, t_pConfigInfo->lpServiceStartName ) ;
					}
					else
					{
						a_pInst->SetCHString( IDS_StartName, _T("") ) ;
					}

					// The display name would make a better description and caption if we can get it

					if( t_pConfigInfo->lpDisplayName && t_pConfigInfo->lpDisplayName[ 0 ] )
					{
						a_pInst->SetCHString( IDS_DisplayName, t_pConfigInfo->lpDisplayName  ) ;
						a_pInst->SetCHString( IDS_Caption, t_pConfigInfo->lpDisplayName  ) ;
						a_pInst->SetCHString( IDS_Description, t_pConfigInfo->lpDisplayName  ) ;
					}
				}
				else
				{
					a_pInst->SetCHString( IDS_ServiceType, _T("Unknown") ) ;
					a_pInst->SetCHString( IDS_StartMode, _T("Unknown") ) ;
					a_pInst->SetCHString( IDS_ErrorControl, _T("Unknown") ) ;
				}
			}
		}
		if( !t_hSvcHandle )
		{
			if( ERROR_ACCESS_DENIED == t_dwLastError )
			{
				// could enumerate the service but could not open it
				t_hResult = WBEM_E_ACCESS_DENIED ;
			}
			else
			{
				// Service not started, etc...
				t_hResult = WBEM_NO_ERROR ;
			}
		}
	}

	return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : PutInstance
 *
 *  DESCRIPTION : Allows caller to assign state to service
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : BOOL indicating success/failure
 *
 *  COMMENTS    : We don't wait around for the service to start, pause or stop --
 *                the return code simply indicates that the command was success-
 *                fully received by the Service Control Manager.
 *
 *****************************************************************************/

HRESULT CWin32SystemDriver::PutInstance (

	const CInstance &a_Instance,
	long lFlags /*= 0L*/
)
{
    DWORD dwFlags = lFlags & 3;

#ifdef NTONLY
	if ( ( dwFlags != WBEM_FLAG_CREATE_OR_UPDATE ) && ( dwFlags != WBEM_FLAG_UPDATE_ONLY ) )
	{
		return WBEM_E_UNSUPPORTED_PARAMETER ;
	}

    CInstancePtr t_Instance;

	CHString t_State ;
    CHString t_RelPath;

    a_Instance.GetCHString ( IDS___Relpath, t_RelPath);
	a_Instance.GetCHString ( IDS_State , t_State ) ;

    // Only need to make sure it exists
	HRESULT t_Result = CWbemProviderGlue :: GetInstanceKeysByPath ( t_RelPath, &t_Instance, a_Instance.GetMethodContext() ) ;
	if ( FAILED(t_Result) )
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			if ( dwFlags == WBEM_FLAG_CREATE_OR_UPDATE )
			{
				return WBEM_E_UNSUPPORTED_PARAMETER ;
			}
			else if ( ( dwFlags & WBEM_FLAG_UPDATE_ONLY ) == dwFlags )
			{
				return t_Result ;
			}
			else
			{
				return t_Result ;
			}
		}
		else
		{
			return t_Result ;
		}
	}

	t_Result = WBEM_E_NOT_SUPPORTED ;

	CInstance *t_OutParam = NULL ;
	if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_RUNNING ) == 0 )
	{
		t_Result = ExecStart ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_PAUSED ) == 0 )
	{
		t_Result = ExecPause ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else if ( t_State.CompareNoCase ( PROPERTY_VALUE_STATE_STOPPED ) == 0 )
	{
		t_Result = ExecStop ( a_Instance , NULL , t_OutParam , 0 ) ;
	}
	else
	{
	}
#endif

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\systemname.h ===
//=================================================================

//

// SystemName.h

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _SYSTEMNAME_H_
#define _SYSTEMNAME_H_

class CSystemName
{
public:
   CSystemName();
   ~CSystemName();

   void SetKeys(CInstance *pInstance);
   bool ObjectIsUs(const CInstance *pInstance);
   
   CHString GetLongKeyName(void) { return s_sKeyName; }
   CHString GetLocalizedName(void);

protected:

   CHString GetKeyName(void);

   static CHString s_sKeyName;
   static CHString s_sLocalKeyName;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\systemname.cpp ===
//=================================================================
//
// SystemName.cpp
//
//  Copyright (c) 1995-2003 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include <lockwrap.h>
#include "resource.h"

#include "SystemName.h"

#include "KUserdata.h"
#include "WMI_FilePrivateProfile.h"

CHString CSystemName::s_sKeyName;
CHString CSystemName::s_sLocalKeyName;

CSystemName::CSystemName()
{
    CLockWrapper SystemName(g_csSystemName);

    if (s_sKeyName.IsEmpty())
    {
	    TCHAR szDir[_MAX_PATH];
	    TCHAR szDevice[_MAX_PATH] ;

	    CRegistry RegInfo ;

	    s_sKeyName = GetKeyName();

	    if ( ! GetWindowsDirectory ( szDir, sizeof ( szDir ) / sizeof(TCHAR)) )
	    {
		    szDir[0] = '\0';
	    }

    #ifdef NTONLY
	    {
    	    WCHAR szFileName[_MAX_PATH] ;

		    wcscpy ( szFileName , szDir ) ;
		    wcscat ( szFileName , L"\\REPAIR\\SETUP.LOG" ) ;

		    WMI_FILE_GetPrivateProfileStringW (
                    L"Paths" ,
                    L"TargetDevice" ,
                    L"" ,
                    szDevice ,
                    sizeof ( szDevice ) / sizeof(WCHAR) ,
                    szFileName
                    ) ;
	    }
    #endif
	    s_sKeyName += '|' ;
	    s_sKeyName += szDir ;
	    s_sKeyName += '|' ;
	    s_sKeyName += szDevice ;
    }
}

CSystemName::~CSystemName()
{
}

bool CSystemName::ObjectIsUs(const CInstance *pInstance)
{
   CHString sName ;

   // Get the values from the object
   pInstance->GetCHString(IDS_Name, sName);

   // Do the comparison
   return (s_sKeyName.CompareNoCase(sName) == 0);
}

void CSystemName::SetKeys(CInstance *pInstance)
{
	pInstance->SetCHString(IDS_Name, s_sKeyName);
}

/*****************************************************************************
 *
 *  FUNCTION    : GetKeyName
 *
 *  DESCRIPTION : Gets the Name property (not the machine name!)
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : CHString for the name
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
CHString CSystemName::GetKeyName(void)
{
	CHString chsName;
	CRegistry RegInfo;

#ifdef NTONLY
	{
		KUserdata ku;
		ULONG uProductType = 0xffffffff;

		if ( ku.ProductTypeIsValid() )
			uProductType = ku.NtProductType();

		// Start with the product name
		if( IsWinNT5() )
		{
			if( ERROR_SUCCESS == RegInfo.Open ( HKEY_LOCAL_MACHINE ,
									_T("SOFTWARE\\Microsoft\\Windows NT\\Currentversion") ,
									KEY_READ) )
			{
				RegInfo.GetCurrentKeyValue( _T("ProductName") , chsName );
			}

			if(chsName.IsEmpty())
			{
				if ( IsWinNT51 () || IsWinNT52 () )
				{
					if ( VER_NT_SERVER == uProductType || VER_NT_DOMAIN_CONTROLLER == uProductType )
					{
						if ( VER_SUITE_SMALLBUSINESS_RESTRICTED & ku.SuiteMask() )
						{
							//
							// SBS doesn't seem to contain coma in the name
							//
							chsName = L"Microsoft(R) Windows(R) Server 2003" ;
						}
						else
						{
							chsName = _T("Microsoft(R) Windows(R) Server 2003,");
						}
					}
					else
					{
						chsName = _T("Microsoft Windows XP");
					}
				}
				else if ( IsWinNT5 () )
				{
					chsName = _T("Microsoft Windows 2000");
				}
				else
				{
					chsName = _T("Unknown Microsoft Windows");
				}
			}
		}
		else
			chsName = _T("Microsoft Windows NT");


		/* now for the product type */

		// Blade Server
		if ( IsWinNT5() && VER_SUITE_BLADE & ku.SuiteMask() )
		{
            chsName += _T(" Web Edition");
		}
		// NT5 Datacenter Server
		else if( IsWinNT5() &&
			( VER_SUITE_DATACENTER & ku.SuiteMask() ) &&
			( VER_NT_SERVER == uProductType || VER_NT_DOMAIN_CONTROLLER == uProductType ) )
		{
			chsName += _T(" Datacenter Edition");
		}
		// Enterprise or Advanced Server
		else if( (VER_SUITE_ENTERPRISE & ku.SuiteMask()) &&
				 (VER_NT_SERVER == uProductType ||VER_NT_DOMAIN_CONTROLLER == uProductType ) )
		{
			if( IsWinNT5() )
			{
				if ( IsWinNT52 () )
				{
					chsName += _T(" Enterprise Edition");
				}
				else
				{
					chsName += _T(" Advanced Server");
				}
			}
			else
			{
				chsName += _T(" Enterprise Server");
			}
		}
		// Server edition
		else if( ( VER_NT_SERVER == uProductType || VER_NT_DOMAIN_CONTROLLER == uProductType ) )
		{

#ifdef	_WIN64
			chsName = _T(" Microsoft Windows Advanced Server Limited Edition");
#else
			if( IsWinNT52 () )
			{
				if ( VER_SUITE_SMALLBUSINESS_RESTRICTED & ku.SuiteMask() )
				{
					chsName += L" for Small Business Server" ;
				}
				else
				{
					chsName += _T(" Standard Edition");
				}
			}
			else
			{
				chsName += _T(" Server");
			}
#endif	_WIN64

		}
		// embedded windows
		else if ( IsWinNT51() && VER_SUITE_EMBEDDEDNT & ku.SuiteMask() )
		{
			chsName += _T(" Embedded");
		}
		// NT5 Professional or NT4 Workstation
		else if(VER_NT_WORKSTATION == uProductType)
		{

#ifdef	_WIN64
			chsName += _T(" 64-Bit Edition");
#else
			if( IsWinNT5() )
			{
				if (VER_SUITE_PERSONAL & ku.SuiteMask())
				{
					chsName += _T(" Home Edition");
				}
				else
				{
					chsName += _T(" Professional");
				}
			}
			else
			{
				chsName += _T(" Workstation");
			}
#endif	_WIN64

		}
	}
#endif
	return chsName;
}
/*****************************************************************************
 *
 *  FUNCTION    : GetLocalizedName
 *
 *  DESCRIPTION : Gets the Name property (not the machine name!) localized
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : CHString for the name
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
CHString CSystemName::GetLocalizedName(void)
{
    CLockWrapper SystemName(g_csSystemName);
    if (s_sLocalKeyName.IsEmpty())
    {

#ifdef NTONLY
		KUserdata	t_ku ;
		ULONG		t_uProductType = 0xffffffff ;
		UINT		t_nID ;

		if ( t_ku.ProductTypeIsValid() )
		{
			t_uProductType = t_ku.NtProductType();
		}

		//windows powered
		if ( IsWinNT5() && VER_SUITE_BLADE & t_ku.SuiteMask() )
		{
			t_nID = IDR_Blade_StockName ;
		}

		// W2k Datacenter Server
		else if( IsWinNT5() && ( VER_SUITE_DATACENTER & t_ku.SuiteMask() ) &&
							( VER_NT_SERVER == t_uProductType ||
							  VER_NT_DOMAIN_CONTROLLER == t_uProductType ) )
		{
			if ( IsWinNT52 () )
			{
				t_nID = IDR_W2kPlus1_Datacenter ;
			}
			else
			{
				t_nID = IDR_W2k_Datacenter ;
			}
		}

		// Enterprise or Advanced Server
		else if( ( VER_SUITE_ENTERPRISE & t_ku.SuiteMask() ) &&
					( VER_NT_SERVER == t_uProductType ||
					  VER_NT_DOMAIN_CONTROLLER == t_uProductType ) )
		{
			if( IsWinNT5() )
			{
				if ( IsWinNT52 () )
				{
					t_nID = IDR_W2kPlus1_AdvancedServer ;
				}
				else
				{
					t_nID = IDR_W2k_AdvancedServer ;
				}
			}
			else
			{
				t_nID = IDR_NT_EnterpriseServer ;
			}
		}

		// Server edition
		else if( ( VER_NT_SERVER == t_uProductType ||
				   VER_NT_DOMAIN_CONTROLLER == t_uProductType ) )
		{

#ifdef	_WIN64
			t_nID = IDR_W2kPlus1_Server_64Bit;
#else
			if( IsWinNT5() )
			{
				if ( IsWinNT52 () )
				{
					if ( VER_SUITE_SMALLBUSINESS_RESTRICTED & t_ku.SuiteMask() )
					{
						t_nID = IDR_W2kPlus1_Server_SBS ;
					}
					else
					{
						t_nID = IDR_W2kPlus1_Server ;
					}
				}
				else
				{
					t_nID = IDR_W2k_Server ;
				}				    
			}
			else
			{
				t_nID = IDR_NT_Server ;
			}
#endif	_WIN64

		}

		// embedded windows
		else if ( IsWinNT51() && VER_SUITE_EMBEDDEDNT & t_ku.SuiteMask() )
		{
			t_nID = IDR_W2kPlus1_Embedded;
		}

		// NT5 Professional or NT4 Workstation
		else if( VER_NT_WORKSTATION == t_uProductType )
		{

#ifdef	_WIN64
			t_nID = IDR_W2kPlus1_Professional_64Bit;
#else
			if( IsWinNT5() )
			{
				if ( IsWinNT51() )
				{
					if (VER_SUITE_PERSONAL & t_ku.SuiteMask())
					{
						t_nID = IDR_W2kPlus1_Personal ; 
					}
					else
					{
						t_nID = IDR_W2kPlus1_Professional ; 
					}
				}
				else
				{
					t_nID = IDR_W2k_Professional ;
				}				    
			}
			else
			{
				t_nID = IDR_NT_Workstation ;
			}
#endif	_WIN64

		}

		// Stock name ( should not be here )
		else
		{
			if( IsWinNT5() )
			{
				if ( IsWinNT51 () )
				{
					t_nID = IDR_W2kPlus1_StockName ;
				}
				else
				{
					t_nID = IDR_W2k_StockName ;
				}				    
			}
			else
			{
				t_nID = IDR_NT_StockName ;
			}
		}

		LoadStringW( s_sLocalKeyName, t_nID );
#endif
    }
	return s_sLocalKeyName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\tapedrive.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//  w2k\tapedrive.cpp
//
//  Purpose: CDROM property set provider
//
//***************************************************************************

#include "precomp.h"

#include <winioctl.h>
#include <ntddscsi.h>
#include <ntddtape.h>

#include <dllutils.h>
#include <strings.h>

#include "..\tapedrive.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_TAPEDRIVE L"TAPEDRIVE"

CWin32TapeDrive s_TapeDrive ( PROPSET_NAME_TAPEDRIVE , IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::CWin32TapeDrive
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32TapeDrive :: CWin32TapeDrive (

	LPCWSTR a_pszName,
	LPCWSTR a_pszNamespace

) : Provider ( a_pszName, a_pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::~CWin32TapeDrive
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32TapeDrive :: ~CWin32TapeDrive()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive :: GetObject ( CInstance *a_Inst, long a_Flags , CFrameworkQuery &a_Query )
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND ;

    CConfigManager t_ConfigManager ;

/*
 * Let's see if config manager recognizes this device at all
 */

    CHString t_Key ;
    a_Inst->GetCHString ( IDS_DeviceID , t_Key ) ;

    CConfigMgrDevicePtr t_Device;
    if ( t_ConfigManager.LocateDevice ( t_Key , t_Device ) )
    {
/*
 * Ok, it knows about it.  Is it a CDROM device?
 */

        if ( t_Device->IsClass ( CONFIG_MANAGER_CLASS_TAPEDRIVE ) )
        {
			TCHAR *t_DosDeviceNameList = NULL ;
			if (QueryDosDeviceNames ( t_DosDeviceNameList ))
            {
                try
                {
			        CHString t_DeviceId ;
			        if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
			        {
                        UINT64 t_SpecifiedProperties = GetBitMask( a_Query );
				        t_hResult = LoadPropertyValues ( a_Inst, t_Device , t_DeviceId , t_DosDeviceNameList , t_SpecifiedProperties ) ;
			        }
                }
                catch ( ... )
                {
                    delete [] t_DosDeviceNameList ;
                    throw ;
                }

				delete [] t_DosDeviceNameList ;
            }
        }
    }

    return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_hResult ;
	t_hResult = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32TapeDrive :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_hResult = WBEM_E_FAILED ;

    UINT64 t_SpecifiedProperties = GetBitMask( a_Query );
	//if ( t_SpecifiedProperties ) //removed since would result in no query being executed if no special properties were selected.
	{
		t_hResult = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , UINT64 a_SpecifiedProperties )
{
    HRESULT t_hResult = WBEM_E_FAILED ;

	TCHAR *t_DosDeviceNameList = NULL ;
	if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
	{
		CConfigManager		t_ConfigManager ;
		CDeviceCollection	t_DeviceList ;
		CInstancePtr        t_pInst;
		CConfigMgrDevicePtr t_Device;

		/*
		*	While it might be more performant to use FilterByGuid, it appears that at least some
		*	95 boxes will report InfraRed info if we do it this way.
		*/

		if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_TAPEDRIVE ) )
		{
			try
			{
				REFPTR_POSITION t_Position ;

				if ( t_DeviceList.BeginEnum ( t_Position ) )
				{
					t_hResult = WBEM_S_NO_ERROR ;

					// Walk the list

					for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ));
						 SUCCEEDED ( t_hResult ) && ( NULL != t_Device );
						 t_Device.Attach(t_DeviceList.GetNext ( t_Position )))
					{

						t_pInst.Attach(CreateNewInstance ( a_MethodContext ));
						CHString t_DeviceId ;
						if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
						{
							t_hResult = LoadPropertyValues ( t_pInst , t_Device , t_DeviceId , t_DosDeviceNameList , a_SpecifiedProperties ) ;
							if ( SUCCEEDED ( t_hResult ) )
							{
								t_hResult = t_pInst->Commit (  ) ;
							}
						}
						else
						{
							t_hResult = WBEM_E_PROVIDER_FAILURE ;
							LogErrorMessage(L"Failed to GetPhysicalDeviceObjectName");
						}
					}

					// Always call EndEnum().  For all Beginnings, there must be an End

					t_DeviceList.EndEnum();
				}
			}
			catch( ... )
			{
				t_DeviceList.EndEnum();

				if( t_DosDeviceNameList )
				{
					delete [] t_DosDeviceNameList ;
				}

				throw ;
			}

			delete [] t_DosDeviceNameList ;
			t_DosDeviceNameList = NULL ;

		}
	}
	else
	{
		t_hResult = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32TapeDrive :: LoadPropertyValues (

	CInstance *a_Inst,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	UINT64 a_SpecifiedProperties
)
{
	HRESULT t_hResult = LoadConfigManagerPropertyValues ( a_Inst , a_Device , a_DeviceName , a_SpecifiedProperties ) ;
	if ( SUCCEEDED ( t_hResult ) )
	{
		if ( a_SpecifiedProperties & (SPECIAL_MEDIA | SPECIAL_TAPEINFO) )
		{
			CHString t_DosDeviceName ;
			t_hResult = GetDeviceInformation ( a_Inst , a_Device , a_DeviceName , t_DosDeviceName , a_DosDeviceNameList , a_SpecifiedProperties ) ;
			if ( SUCCEEDED ( t_hResult ) && (a_SpecifiedProperties & SPECIAL_MEDIA) )
			{
				t_hResult = LoadMediaPropertyValues ( a_Inst , a_Device , a_DeviceName , t_DosDeviceName , a_SpecifiedProperties ) ;
			}
			else
			{
				t_hResult = ( t_hResult == WBEM_E_NOT_FOUND ) ? S_OK : t_hResult ;
			}
		}
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32TapeDrive::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32TapeDrive :: LoadConfigManagerPropertyValues (

	CInstance *a_Inst ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	UINT64 a_SpecifiedProperties
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Inst ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & ( SPECIAL_PROPS_AVAILABILITY | SPECIAL_PROPS_STATUS | SPECIAL_PROPS_STATUSINFO ) )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				if (t_sStatus == IDS_STATUS_Degraded)
                {
					a_Inst->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
					a_Inst->SetWBEMINT16 ( IDS_Availability , 10 ) ;
                }
                else if (t_sStatus == IDS_STATUS_OK)
                {

				    a_Inst->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
				    a_Inst->SetWBEMINT16 ( IDS_Availability,  3 ) ;
                }
                else if (t_sStatus == IDS_STATUS_Error)
                {
				    a_Inst->SetWBEMINT16 ( IDS_StatusInfo , 4 ) ;
				    a_Inst->SetWBEMINT16 ( IDS_Availability , 4 ) ;
                }
                else
                {
					a_Inst->SetWBEMINT16 ( IDS_StatusInfo , 2 ) ;
					a_Inst->SetWBEMINT16 ( IDS_Availability , 2 ) ;
                }

                a_Inst->SetCHString(IDS_Status, t_sStatus);
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Inst->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Inst->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Inst->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Inst ) ;
	}

	if ( a_SpecifiedProperties & (SPECIAL_PROPS_DESCRIPTION | SPECIAL_PROPS_CAPTION | SPECIAL_PROPS_NAME) )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties &  SPECIAL_PROPS_DESCRIPTION)
			{
				a_Inst->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & (SPECIAL_PROPS_CAPTION | SPECIAL_PROPS_NAME) )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Inst->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Inst->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Inst->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Inst->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Inst->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_ID )
	{
		CHString t_ManufacturerFriendlyName ;

		if ( a_Device->GetFriendlyName ( t_ManufacturerFriendlyName ) )
		{
			a_Inst->SetCharSplat ( IDS_Id, t_ManufacturerFriendlyName ) ;
		}
	}


/*
 *	Fixed value from enumerated list
 */

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
//	{
//	    a_Inst->SetWBEMINT16 ( _T("ProtocolSupported") , 16 ) ;
//	}

    return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive :: GetDeviceInformation
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive :: GetDeviceInformation (

	CInstance *a_Inst ,
	CConfigMgrDevice *a_Device ,
	CHString a_DeviceName ,
	CHString &a_DosDeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	UINT64 a_SpecifiedProperties
)
{
	HRESULT t_hResult = S_OK ;
	BOOL t_CreatedSymbolicLink = FALSE ;

	CHString t_SymbolicLinkName ;
	BOOL t_Status = FindDosDeviceName ( a_DosDeviceNameList , a_DeviceName , t_SymbolicLinkName ) ;
	if ( ! t_Status )
	{
		t_SymbolicLinkName = CHString ( L"WMI_TAPEDEVICE_SYBOLICLINK" ) ;

		{
			CInCritSec cs( &m_CriticalSection ) ;
			t_Status = DefineDosDevice ( DDD_RAW_TARGET_PATH , t_SymbolicLinkName , a_DeviceName ) ;
		}

		if ( t_Status )
		{
			t_CreatedSymbolicLink = TRUE ;
		}
		else
		{
			t_hResult = WBEM_E_PROVIDER_FAILURE ;

			DWORD t_LastError = GetLastError () ;
            LogErrorMessage2(L"Failed to DefineDosDevice (%d)", t_LastError);
		}
	}

	if ( t_Status )
	{
		CHString t_Device = CHString ( L"\\\\.\\" ) + t_SymbolicLinkName ;

		SmartCloseHandle t_Handle = CreateFile (

			t_Device,
			FILE_ANY_ACCESS ,
			FILE_SHARE_READ,
			NULL,
			OPEN_EXISTING,
			0,
			NULL
		);

		if ( t_Handle != INVALID_HANDLE_VALUE )
		{
			STORAGE_DEVICE_NUMBER t_DeviceNumber;
			DWORD t_BytesReturned;
			ULONG t_Return = 0;

			t_Status = DeviceIoControl (

				t_Handle ,
				IOCTL_STORAGE_GET_DEVICE_NUMBER ,
				NULL ,
				0 ,
				& t_DeviceNumber ,
				sizeof ( STORAGE_DEVICE_NUMBER ) ,
				& t_BytesReturned ,
				NULL
			) ;

			if ( t_Status )
			{
				TCHAR t_DeviceLabel [ sizeof ( TCHAR ) * 17 + sizeof ( _TEXT("\\Device\\Tape") ) ] ;
				_stprintf ( t_DeviceLabel , _TEXT("\\Device\\Tape%d") , t_DeviceNumber.DeviceNumber ) ;

				t_Status = FindDosDeviceName ( a_DosDeviceNameList , t_DeviceLabel, a_DosDeviceName ) ;
				if ( ! t_Status )
				{
					t_hResult = WBEM_E_NOT_FOUND ;
				}
			}
			else
			{
				t_hResult = WBEM_E_PROVIDER_FAILURE ;

				DWORD t_Error = GetLastError () ;
                LogErrorMessage2(L"Failed DeviceIoControl (%d)", t_Error);
			}

	/*
	 * Get SCSI information (IDE drives are still
	 * controlled by subset of SCSI miniport)
	 */

			if ( a_SpecifiedProperties & SPECIAL_TAPEINFO )
			{
				TAPE_GET_DRIVE_PARAMETERS t_DriveInfo ;
				t_Return = sizeof ( t_DriveInfo ) ;

				//Get info on drive, using Win32 API function
				//===========================================
				DWORD t_Status = GetTapeParameters (

					t_Handle,
					GET_TAPE_DRIVE_INFORMATION,
					& t_Return ,
					& t_DriveInfo
				) ;

				if ( t_Status == NO_ERROR)
				{
					if ( a_SpecifiedProperties & SPECIAL_PROPS_ECC )
					{
						a_Inst->SetDWORD ( IDS_ECC , ( DWORD ) t_DriveInfo.ECC ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_COMPRESSION )
					{
						a_Inst->SetDWORD ( IDS_Compression , ( DWORD ) t_DriveInfo.Compression ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_PADDING )
					{
						a_Inst->SetDWORD ( IDS_Padding , ( DWORD ) t_DriveInfo.DataPadding ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_REPORTSETMARKS )
					{
						a_Inst->SetDWORD ( IDS_ReportSetMarks , ( DWORD ) t_DriveInfo.ReportSetmarks ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_DEFAULTBLOCKSIZE )
					{
						a_Inst->SetWBEMINT64 ( IDS_DefaultBlockSize , (ULONGLONG)t_DriveInfo.DefaultBlockSize ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_MAXIMUMBLOCKSIZE )
					{
						a_Inst->SetWBEMINT64 ( IDS_MaximumBlockSize , (ULONGLONG)t_DriveInfo.MaximumBlockSize ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_MINIMUMBLOCKSIZE )
					{
						a_Inst->SetWBEMINT64 ( IDS_MinimumBlockSize , (ULONGLONG)t_DriveInfo.MinimumBlockSize ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_MAXPARTITIONCOUNT )
					{
						a_Inst->SetDWORD ( IDS_MaximumPartitionCount , t_DriveInfo.MaximumPartitionCount ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_FEATURESLOW )
					{
						a_Inst->SetDWORD ( IDS_FeaturesLow , t_DriveInfo.FeaturesLow ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_FEATUREHIGH )
					{
						a_Inst->SetDWORD ( IDS_FeaturesHigh , t_DriveInfo.FeaturesHigh ) ;
					}

					if ( a_SpecifiedProperties & SPECIAL_PROPS_ENDOFTAPEWARNINGZONESIZE )
					{
						a_Inst->SetDWORD ( IDS_EndOfTapeWarningZoneSize , t_DriveInfo.EOTWarningZoneSize ) ;
					}
				}
			}

		}
		else
		{
			DWORD t_Error = GetLastError () ;

            // Non-admins might get this error.  We return the instance anyway
            if (t_Error == ERROR_ACCESS_DENIED)
            {
                t_hResult = WBEM_S_NO_ERROR;
            }
            else
            {
                t_hResult = WBEM_E_PROVIDER_FAILURE ;
                LogErrorMessage2(L"Failed to CreateFile (%d)", t_Error);
            }
		}
	}

	if ( t_CreatedSymbolicLink )
	{
		BOOL t_Status ;

		{
			CInCritSec cs( &m_CriticalSection ) ;
			t_Status = DefineDosDevice ( DDD_EXACT_MATCH_ON_REMOVE | DDD_REMOVE_DEFINITION , t_SymbolicLinkName , t_SymbolicLinkName ) ;
		}

		if ( ! t_Status )
		{
			t_hResult = WBEM_E_PROVIDER_FAILURE ;

			DWORD t_LastError = GetLastError () ;
            LogErrorMessage2(L"Failed to Delete DOS Device (%d)", t_LastError);
		}
	}

	return t_hResult ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32TapeDrive :: LoadMediaPropertyValues
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32TapeDrive::LoadMediaPropertyValues (

	CInstance *a_Inst ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const CHString &a_DosDeviceName ,
	UINT64 a_SpecifiedProperties
)
{

	HRESULT t_hResult = S_OK ;

/*
 *
 */
    // Set common drive properties
    //=============================

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPABILITY )
	{
		// Create a safearray for the Capabilities information

		SAFEARRAYBOUND t_ArrayBounds ;

		t_ArrayBounds.cElements = 2;
		t_ArrayBounds.lLbound = 0;

		variant_t t_CapabilityValue ;

		if ( V_ARRAY ( & t_CapabilityValue ) = SafeArrayCreate ( VT_I2 , 1 , & t_ArrayBounds ) )
		{
			V_VT ( & t_CapabilityValue ) = VT_I2 | VT_ARRAY ;
			long t_Capability = 2 ;
			long t_Index = 0;
			SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ) , & t_Index , & t_Capability) ;

			t_Index = 1;
			t_Capability = 7 ;
			SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ) , & t_Index , & t_Capability ) ;

			a_Inst->SetVariant ( IDS_Capabilities , t_CapabilityValue ) ;
		}
	}

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_AVAILABILITY )
//	{
//		a_Inst->SetWBEMINT16(IDS_Availability, 3);
//	}

/*
 * Media type
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIATYPE )
	{
	    a_Inst->SetWCHARSplat ( IDS_MediaType , L"Tape Drive" ) ;
	}

	return t_hResult ;
}

UINT64 CWin32TapeDrive::GetBitMask(CFrameworkQuery &a_Query)
{
    UINT64 t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_StatusInfo ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUSINFO ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSITargetId ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSITARGETID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Id ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_ID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Capabilities ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPABILITY ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaType ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIATYPE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_VOLUMENAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MaximumComponentLength ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MAXCOMPONENTLENGTH ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_FileSystemFlags ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_FILESYSTEMFLAGS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeSerialNumber ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SERIALNUMBER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Size ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SIZE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Availability ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_AVAILABILITY ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ECC ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_ECC ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_Compression ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_COMPRESSION ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_Padding ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PADDING ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ReportSetMarks ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_REPORTSETMARKS ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_DefaultBlockSize ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_DEFAULTBLOCKSIZE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_MaximumBlockSize ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_MAXIMUMBLOCKSIZE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_MinimumBlockSize ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_MINIMUMBLOCKSIZE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_MaximumPartitionCount ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_MAXPARTITIONCOUNT ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_FeaturesLow ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_FEATURESLOW;
    }

    if ( a_Query.IsPropertyRequired ( IDS_FeaturesHigh ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_FEATUREHIGH ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_EndOfTapeWarningZoneSize ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_ENDOFTAPEWARNINGZONESIZE ;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\tapedrive.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  tapedrive.h
//
//  Purpose: tapedrive property set provider 
//
//***************************************************************************

#ifndef _TAPEDRIVE_H
#define _TAPEDRIVE_H

// Property set identification
//============================

// Property set identification
//============================

#define PROPSET_NAME_TAPEDRIVE				L"Win32_TapeDrive"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFFFFFFFFFFi64
#define SPECIAL_PROPS_NONE_REQUIRED         0x0000000000000000i64
#define SPECIAL_PROPS_AVAILABILITY		0x0000000000000002i64
#define SPECIAL_PROPS_STATUS			0x0000000000000004i64
#define SPECIAL_PROPS_DEVICEID			0x0000000000000008i64
#define SPECIAL_PROPS_CREATIONNAME		0x0000000000000010i64
#define SPECIAL_PROPS_SYSTEMNAME		0x0000000000000020i64
#define SPECIAL_PROPS_DESCRIPTION		0x0000000000000040i64
#define SPECIAL_PROPS_CAPTION			0x0000000000000080i64
#define SPECIAL_PROPS_NAME			0x0000000000000100i64
#define SPECIAL_PROPS_MANUFACTURER		0x0000000000000200i64
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x0000000000000400i64
#define SPECIAL_PROPS_SCSITARGETID		0x0000000000000800i64
#define SPECIAL_PROPS_ID			0x0000000000002000i64
#define SPECIAL_PROPS_CAPABILITY		0x0000000000004000i64
#define SPECIAL_PROPS_MEDIATYPE			0x0000000000008000i64
#define SPECIAL_PROPS_VOLUMENAME		0x0000000000010000i64
#define SPECIAL_PROPS_MAXCOMPONENTLENGTH	0x0000000000020000i64
#define SPECIAL_PROPS_FILESYSTEMFLAGS		0x0000000000040000i64
#define SPECIAL_PROPS_SERIALNUMBER		0x0000000000080000i64
#define SPECIAL_PROPS_SIZE			0x0000000000100000i64
#define SPECIAL_PROPS_MEDIALOADED		0x0000000000200000i64
#define SPECIAL_PROPS_PNPDEVICEID		0x0000000000400000i64
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x0000000000800000i64
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x0000000001000000i64
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x0000000002000000i64
#define SPECIAL_PROPS_ECC			0x0000000004000000i64
#define SPECIAL_PROPS_COMPRESSION		0x0000000008000000i64
#define SPECIAL_PROPS_PADDING			0x0000000010000000i64
#define SPECIAL_PROPS_REPORTSETMARKS		0x0000000020000000i64
#define SPECIAL_PROPS_DEFAULTBLOCKSIZE		0x0000000040000000i64
#define SPECIAL_PROPS_MAXIMUMBLOCKSIZE		0x0000000080000000i64
#define SPECIAL_PROPS_MINIMUMBLOCKSIZE		0x0000000100000000i64
#define SPECIAL_PROPS_MAXPARTITIONCOUNT		0x0000000200000000i64
#define SPECIAL_PROPS_FEATURESLOW		0x0000000400000000i64
#define SPECIAL_PROPS_FEATUREHIGH		0x0000000800000000i64
#define SPECIAL_PROPS_ENDOFTAPEWARNINGZONESIZE	0x0000001000000000i64
#define SPECIAL_PROPS_STATUSINFO		0x0000002000000000i64

#define SPECIAL_CONFIGMANAGER		( SPECIAL_CONFIGPROPERTIES | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_ID | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_AVAILABILITY | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_STATUSINFO )

#define SPECIAL_MEDIA				( SPECIAL_PROPS_CAPABILITY | \
									SPECIAL_PROPS_MEDIATYPE )

#define SPECIAL_TAPEINFO			( SPECIAL_PROPS_ECC | \
									SPECIAL_PROPS_COMPRESSION | \
									SPECIAL_PROPS_PADDING | \
									SPECIAL_PROPS_REPORTSETMARKS | \
									SPECIAL_PROPS_DEFAULTBLOCKSIZE | \
									SPECIAL_PROPS_MAXIMUMBLOCKSIZE | \
									SPECIAL_PROPS_MINIMUMBLOCKSIZE | \
									SPECIAL_PROPS_MAXPARTITIONCOUNT | \
									SPECIAL_PROPS_FEATURESLOW | \
									SPECIAL_PROPS_FEATUREHIGH | \
									SPECIAL_PROPS_ENDOFTAPEWARNINGZONESIZE )

#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA | \
									SPECIAL_TAPEINFO )

#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000
	
class CWin32TapeDrive : public Provider
{
		// Utility
		//========
    private:
	
        UINT64 GetBitMask(CFrameworkQuery &a_Query);
		HRESULT LoadPropertyValues( CInstance *a_pInst, CConfigMgrDevice *a_pDevice ) ;
        BOOL IsTapeDrive( CConfigMgrDevice *a_Device );

		CStaticCritSec m_CriticalSection ;
	
        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			UINT64 a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

		HRESULT LoadPropertyValues ( 

			CInstance *a_Instance, 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const TCHAR *a_DosDeviceNameList ,
			UINT64 a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

		HRESULT LoadConfigManagerPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			UINT64 a_SpecifiedPropertied
		) ;

		HRESULT GetDeviceInformation ( 

			CInstance *a_Instance ,
			CConfigMgrDevice *a_Device , 
			CHString a_DeviceName , 
			CHString &a_DosDeviceName ,
			const TCHAR *a_DosDeviceNameList ,
			UINT64 a_SpecifiedPropertied
		) ;

		HRESULT LoadMediaPropertyValues (	

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const CHString &a_DosDeviceName , 
			UINT64 a_SpecifiedPropertied 
		) ;

public:

        // Constructor/destructor
        //=======================

        CWin32TapeDrive ( LPCWSTR a_pszName, LPCWSTR a_pszNamespace ) ;
       ~CWin32TapeDrive () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( 

			CInstance *a_Instance, 
			long a_Flags,
            CFrameworkQuery &a_Query
		) ;

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

		HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\tapiapi.h ===
//=================================================================

//

// TapiApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_TapiAPI_H_
#define	_TapiAPI_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidTapi32Api;
extern const TCHAR g_tstrTapi32[];

/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef LONG (WINAPI *PFN_Tapi_lineInitialize )
(
		LPHLINEAPP lphLineApp,
		HINSTANCE hInstance,
		LINECALLBACK lpfnCallback,
		LPCSTR lpszAppName,
		LPDWORD lpdwNumDevs
) ;

typedef LONG (WINAPI *PFN_Tapi_lineShutdown )
(
		HLINEAPP hLineApp
) ;

typedef LONG (WINAPI *PFN_Tapi_lineNegotiateAPIVersion )
(
		HLINEAPP hLineApp,
		DWORD dwDeviceID,
		DWORD dwAPILowVersion,
		DWORD dwAPIHighVersion,
		LPDWORD lpdwAPIVersion,
		LPLINEEXTENSIONID lpExtensionID
) ;

typedef LONG ( WINAPI *PFN_Tapi_lineGetDevCaps )
(
		HLINEAPP hLineApp,
		DWORD dwDeviceID,
		DWORD dwAPIVersion,
		DWORD dwExtVersion,
		LPLINEDEVCAPS lpLineDevCaps
);

#ifdef UNICODE
typedef LONG ( WINAPI *PFN_Tapi_lineGetID )
(

	HLINE hLine,
	DWORD dwAddressID,
	HCALL hCall,
	DWORD dwSelect,
	LPVARSTRING lpDeviceID,
	LPCWSTR lpszDeviceClass
) ;
#else
typedef LONG ( WINAPI *PFN_Tapi_lineGetID )
(
	HLINE hLine,
	DWORD dwAddressID,
	HCALL hCall,
	DWORD dwSelect,
	LPVARSTRING lpDeviceID,
	LPCSTR lpszDeviceClass
);
#endif

typedef LONG ( WINAPI *PFN_Tapi_lineOpen )
(
	HLINEAPP hLineApp,
	DWORD dwDeviceID,
	LPHLINE lphLine,
	DWORD dwAPIVersion,
	DWORD dwExtVersion,
	DWORD_PTR dwCallbackInstance,
	DWORD dwPrivileges,
	DWORD dwMediaModes,
	LPLINECALLPARAMS const lpCallParams
) ;

/******************************************************************************
 * Wrapper class for Tapi load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CTapi32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Tapi functions.
    // Add new functions here as required.

	PFN_Tapi_lineInitialize m_pfnlineInitialize ;
	PFN_Tapi_lineShutdown m_pfnlineShutdown ;
	PFN_Tapi_lineNegotiateAPIVersion m_pfnlineNegotiateAPIVersion ;
	PFN_Tapi_lineGetDevCaps m_pfnlineGetDevCaps ;
	PFN_Tapi_lineGetID m_pfnlineGetID ;
	PFN_Tapi_lineOpen m_pfnlineOpen ;

public:

    // Constructor and destructor:
    CTapi32Api(LPCTSTR a_tstrWrappedDllName);
    ~CTapi32Api();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Tapi functions.
    // Add new functions here as required:

	LONG lineInitialize (

		LPHLINEAPP lphLineApp,
		HINSTANCE hInstance,
		LINECALLBACK lpfnCallback,
		LPCSTR lpszAppName,
		LPDWORD lpdwNumDevs
	) ;

	LONG lineShutdown (

		HLINEAPP hLineApp
	) ;

	LONG lineNegotiateAPIVersion (

		HLINEAPP hLineApp,
		DWORD dwDeviceID,
		DWORD dwAPILowVersion,
		DWORD dwAPIHighVersion,
		LPDWORD lpdwAPIVersion,
		LPLINEEXTENSIONID lpExtensionID
	) ;

	LONG TapilineGetDevCaps (

		HLINEAPP hLineApp,
		DWORD dwDeviceID,
		DWORD dwAPIVersion,
		DWORD dwExtVersion,
		LPLINEDEVCAPS lpLineDevCaps
	) ;

#ifdef UNICODE
	LONG TapilineGetID (

		HLINE hLine,
		DWORD dwAddressID,
		HCALL hCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass
    ) ;
#else
	LONG TapilineGetID (

		HLINE hLine,
		DWORD dwAddressID,
		HCALL hCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCSTR lpszDeviceClass
    );
#endif

	LONG TapilineOpen (

	    HLINEAPP hLineApp,
		DWORD dwDeviceID,
		LPHLINE lphLine,
		DWORD dwAPIVersion,
		DWORD dwExtVersion,
		DWORD_PTR dwCallbackInstance,
		DWORD dwPrivileges,
		DWORD dwMediaModes,
		LPLINECALLPARAMS const lpCallParams
    ) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\tapiapi.cpp ===
//=================================================================

//

// TapiAPI.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cominit.h>

#include <tapi.h>
#include "DllWrapperBase.h"
#include "TapiApi.h"
#include "DllWrapperCreatorReg.h"

// {73E9A405-0FA4-11d3-910C-00105AA630BE}
static const GUID g_guidTapi32Api =
{ 0x73e9a405, 0xfa4, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrTapi32 [] = _T("Tapi32.Dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CTapi32Api, &g_guidTapi32Api, g_tstrTapi32> MyRegisteredTapi32Wrapper;

/******************************************************************************
 * Constructor
 *****************************************************************************/
CTapi32Api :: CTapi32Api (

	LPCTSTR a_tstrWrappedDllName

) : CDllWrapperBase ( a_tstrWrappedDllName ),
	m_pfnlineInitialize(NULL),
	m_pfnlineShutdown(NULL),
	m_pfnlineNegotiateAPIVersion(NULL) ,
	m_pfnlineGetDevCaps(NULL) ,
	m_pfnlineGetID(NULL),
	m_pfnlineOpen(NULL)
{
}

/******************************************************************************
 * Destructor
 *****************************************************************************/
CTapi32Api::~CTapi32Api()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CTapi32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef UNICODE
		m_pfnlineGetDevCaps = ( PFN_Tapi_lineGetDevCaps ) GetProcAddress ( "lineGetDevCapsW" ) ;
		m_pfnlineGetID = ( PFN_Tapi_lineGetID ) GetProcAddress ( "lineGetIDW" ) ;
		m_pfnlineOpen = ( PFN_Tapi_lineOpen ) GetProcAddress ( "lineOpenW" ) ;
#else
		// No 'A' on the end because 95 doesn't have lineGetDevCapsA.  But both 95 and 98
        // have lineGetDevCaps.
        m_pfnlineGetDevCaps = ( PFN_Tapi_lineGetDevCaps ) GetProcAddress ( "lineGetDevCaps" ) ;
		m_pfnlineGetID = ( PFN_Tapi_lineGetID ) GetProcAddress ( "lineGetIDA" ) ;
		m_pfnlineOpen = ( PFN_Tapi_lineOpen ) GetProcAddress ( "lineOpenA" ) ;
#endif

		m_pfnlineInitialize = ( PFN_Tapi_lineInitialize ) GetProcAddress ( "lineInitialize" ) ;
		m_pfnlineShutdown = ( PFN_Tapi_lineShutdown ) GetProcAddress ( "lineShutdown" ) ;
		m_pfnlineNegotiateAPIVersion = ( PFN_Tapi_lineNegotiateAPIVersion ) GetProcAddress ( "lineNegotiateAPIVersion" ) ;
    }

    // We require these function for all versions of this dll.

	if ( m_pfnlineInitialize == NULL ||
	    m_pfnlineShutdown == NULL ||
	    m_pfnlineNegotiateAPIVersion == NULL ||
		m_pfnlineGetDevCaps == NULL ||
		m_pfnlineGetID == NULL ||
		m_pfnlineOpen == NULL )
	{
        fRet = false;
	}

    return fRet;
}

/******************************************************************************
 * Member functions wrapping Tapi api functions. Add new functions here
 * as required.
 *****************************************************************************/

LONG CTapi32Api :: lineInitialize (

	LPHLINEAPP lphLineApp,
    HINSTANCE hInstance,
    LINECALLBACK lpfnCallback,
    LPCSTR lpszAppName,
    LPDWORD lpdwNumDevs
)
{
	return m_pfnlineInitialize (

		lphLineApp,
		hInstance,
		lpfnCallback,
		lpszAppName,
		lpdwNumDevs

	) ;
}

LONG CTapi32Api :: lineShutdown (

	HLINEAPP hLineApp
)
{
	return m_pfnlineShutdown (

		hLineApp

	) ;
}

LONG CTapi32Api :: lineNegotiateAPIVersion (

	HLINEAPP hLineApp,
	DWORD dwDeviceID,
	DWORD dwAPILowVersion,
	DWORD dwAPIHighVersion,
	LPDWORD lpdwAPIVersion,
	LPLINEEXTENSIONID lpExtensionID
)
{
	return m_pfnlineNegotiateAPIVersion (

		hLineApp,
		dwDeviceID,
		dwAPILowVersion,
		dwAPIHighVersion,
		lpdwAPIVersion,
		lpExtensionID

	) ;
}

LONG CTapi32Api :: TapilineGetDevCaps (

    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    DWORD dwAPIVersion,
    DWORD dwExtVersion,
    LPLINEDEVCAPS lpLineDevCaps
)
{
	return m_pfnlineGetDevCaps (

		hLineApp,
		dwDeviceID,
		dwAPIVersion,
		dwExtVersion,
		lpLineDevCaps
	) ;
}

#ifdef UNICODE
LONG CTapi32Api :: TapilineGetID (

		HLINE hLine,
		DWORD dwAddressID,
		HCALL hCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass
)
#else
LONG CTapi32Api :: TapilineGetID (

		HLINE hLine,
		DWORD dwAddressID,
		HCALL hCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCSTR lpszDeviceClass
)
#endif
{
	return m_pfnlineGetID (

		hLine,
		dwAddressID,
		hCall,
		dwSelect,
		lpDeviceID,
		lpszDeviceClass
	) ;
}

LONG CTapi32Api :: TapilineOpen (

	HLINEAPP hLineApp,
	DWORD dwDeviceID,
	LPHLINE lphLine,
	DWORD dwAPIVersion,
	DWORD dwExtVersion,
	DWORD_PTR dwCallbackInstance,
	DWORD dwPrivileges,
	DWORD dwMediaModes,
	LPLINECALLPARAMS const lpCallParams
)
{
	return m_pfnlineOpen (

		hLineApp,
		dwDeviceID,
		lphLine,
		dwAPIVersion,
		dwExtVersion,
		dwCallbackInstance,
		dwPrivileges,
		dwMediaModes,
		lpCallParams
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\threadprov.h ===
//=======================================================================

// ThreadProv.h

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//=======================================================================

#include "WBEMToolH.h"

#define  PROPSET_NAME_THREAD L"Win32_Thread"

class WbemThreadProvider;

class WbemNTThread ; //remove this after friend removal

// base model for thread access  
class CThreadModel : public CThreadBase /* reference and thread safety inheritance */
{	
	public:

        // Constructor/destructor
        //=======================
		CThreadModel() ;
		virtual ~CThreadModel() ;
	
		
		// resource control
		//=================
		ULONG		AddRef() ; 
		ULONG		Release() { return CThreadBase::Release() ; } ; 
		BOOL		fUnLoadResourcesTry() ;
		HRESULT		hrCanUnloadNow() ;
		
		// override these to control resource lifetime, use with AddRef() and Release().
		virtual LONG fLoadResources() { return ERROR_SUCCESS ; } ;
		virtual LONG fUnLoadResources() { return ERROR_SUCCESS ; } ;

		// operations
		//===========
		virtual WBEMSTATUS eLoadCommonThreadProperties( WbemThreadProvider *a_pProv, CInstance *a_pInst ) ;
				
		// Pure operations
		//================
		virtual WBEMSTATUS eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst ) = 0 ;
		virtual WBEMSTATUS eEnumerateThreadInstances(WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext ) = 0 ;
};	   

// 
class CWin9xThread : public CThreadModel
{
	public:

        // Constructor/destructor
        //=======================
        CWin9xThread() ;
        virtual ~CWin9xThread() ;

        // overrides
	    //==========
		virtual LONG fLoadResources() ;
		virtual LONG fUnLoadResources() ;
				
		// operations
		//=========== 

	WBEMSTATUS eEnumerateThreadByProcess(	MethodContext		*a_pMethodContext,
											WbemThreadProvider	*a_pProvider,
											DWORD				a_dwProcessID ) ;

			
		// Pure implementations
	    //================
	    virtual WBEMSTATUS eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst ) ;
		virtual WBEMSTATUS eEnumerateThreadInstances( WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext ) ;
};



class WbemThreadProvider: public Provider
{
	private:
		
		CThreadModel *m_pTheadAccess ;

		       // Utility
        //========
	protected:
		
		// override to unload support DLLs
		virtual void Flush(void) ;
	public:

		// Constructor/destructor
        //=======================
        WbemThreadProvider(LPCWSTR a_name, LPCWSTR a_pszNamespace ) ;
       ~WbemThreadProvider() ;

        // Functions provide properties with current values
        //=================================================
	virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
	virtual HRESULT GetObject(CInstance *a_pInstance, long a_lFlags = 0L ) ;

	// Lets have a party
	friend CThreadModel;
	friend CWin9xThread;
	friend WbemNTThread;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\threadprov.cpp ===
//=======================================================================

// ThreadProv.cpp

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//=======================================================================


#include "precomp.h"
#include "SystemName.h"
#include <winperf.h>

#include "ThreadProv.h"
#include "WBemNTThread.h"
#include <tchar.h>

/*
 * This function gets the Priority of a thread, given the priority of the ProcessClass & the PriorityValue of the thread.
 */
DWORD GetThreadPriority ( DWORD a_dwPriorityOfProcessClass , int a_PriorityValue ) ;
// Property set declaration
//=========================
WbemThreadProvider MyThreadSet(PROPSET_NAME_THREAD, IDS_CimWin32Namespace) ;

//=============================
// WBEM thread provider follows
//=============================
WbemThreadProvider::WbemThreadProvider( LPCWSTR a_name, LPCWSTR a_pszNamespace )
: Provider( a_name, a_pszNamespace )
{
	#ifdef NTONLY
			m_pTheadAccess = new WbemNTThread ;
	#endif

	if( !m_pTheadAccess )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}
}

WbemThreadProvider::~WbemThreadProvider()
{
    if( m_pTheadAccess )
	{
		delete m_pTheadAccess ;
	}
}

void WbemThreadProvider::Flush()
{
	// unload suppport DLLs and resources to keep the footprint down
	if( m_pTheadAccess )

	m_pTheadAccess->fUnLoadResourcesTry() ;	// should always work here

	Provider::Flush() ;
}

HRESULT WbemThreadProvider::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
	if( m_pTheadAccess )
	{
		if( m_pTheadAccess->AddRef() )
		{
			HRESULT t_hResult = m_pTheadAccess->eGetThreadObject( this, a_pInst ) ;

			m_pTheadAccess->Release() ;

			return t_hResult ;
		}
	}
	return WBEM_E_FAILED ;
}


HRESULT WbemThreadProvider::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	if( m_pTheadAccess )
	{
		if( m_pTheadAccess->AddRef() )
		{
			HRESULT t_hResult = m_pTheadAccess->eEnumerateThreadInstances( this , a_pMethodContext ) ;

			m_pTheadAccess->Release() ;

			return t_hResult ;
		}
	}
	return WBEM_E_FAILED ;
}


//=======================================
// Common thread extraction model follows
//=======================================
CThreadModel::CThreadModel() {}
CThreadModel::~CThreadModel() {}

WBEMSTATUS CThreadModel::eLoadCommonThreadProperties( WbemThreadProvider *a_pProv, CInstance *a_pInst )
{
//	CHString t_chsScratch ;

	if( !a_pInst )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	/* CIM_Thread properties follow */

	a_pProv->SetCreationClassName( a_pInst ) ;	// IDS_CreationClassName

	a_pInst->SetWCHARSplat( IDS_CSCreationClassName, L"Win32_ComputerSystem" ) ;
	a_pInst->SetCHString( IDS_CSName, a_pProv->GetLocalComputerName() ) ;

	// REVIEW: is IDS_ProcessCreationClassName the same as IDS_CreationClassName?
//	a_pInst->GetCHString( IDS_CreationClassName, t_chsScratch ) ;

	a_pInst->SetWCHARSplat( IDS_ProcessCreationClassName, L"Win32_Process" ) ;

	// REVIEW:
	// Provider.cpp shows "Win32_OperatingSystem" for NT but " " for Win95
	// We'll keep it the same here for now
	a_pInst->SetWCHARSplat(IDS_OSCreationClassName, L"Win32_OperatingSystem" ) ;

	// OSName

	CSystemName t_cSN ;

	a_pInst->SetCHString( IDS_OSName, t_cSN.GetLongKeyName() ) ;
	// Note: the following are supplied in the OS specific derived class

	/* Note:	These following two properties are keys.
				If called via GetObject() these	keys should be valid
				and and need not be filled in. Although a sanity check should be made.
				If called via EnumerateInstances() the keys will not be present
				and must be filled in.
	// ProcessHandle	( ProcessID )
	// Handle			( ThreadID )

	/* CIM_Thread properties */
	// Priority
	// ExecutionState
	// UserModeTime
	// KernelModeTime

	/* Win32_Thread properties */
	// ElapesedTime
	// PriorityBase
	// StartAddress
	// ThreadState
	// ThreadWaitreason

	return WBEM_NO_ERROR ;
}

//
ULONG CThreadModel::AddRef()
{
	ULONG t_uRefCount;

	BeginWrite() ;
    try
    {

	    if( 2 == ( t_uRefCount = CThreadBase::AddRef()) )			// 1st ref after initialization.
	    {
		    fLoadResources() ;	// Check to see if resources are here.
	    }
    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite() ;

	return t_uRefCount ;
}

//
HRESULT CThreadModel::hrCanUnloadNow()
{
	ULONG t_uRefCount = CThreadBase::AddRef() ;
						 CThreadBase::Release() ;

	return ( 2 == t_uRefCount ) ?  S_OK : S_FALSE ;
}

// Called by WbemThreadProvider::Flush() when idle for awhile.
// Attempt to unload support DLL's, instance independent memory blocks, etc
BOOL CThreadModel::fUnLoadResourcesTry()
{
	BOOL t_fRet = FALSE ;

	BeginWrite() ;

    try
    {
	    if( S_OK == hrCanUnloadNow() )
	    {
		    if( ERROR_SUCCESS == fUnLoadResources() )
		    {
			    t_fRet = TRUE ;
		    }
	    }
    }
    catch ( ... )
    {
    	EndWrite() ;
        throw;
    }

	EndWrite() ;

	return t_fRet ;
}

//=============================================
// Win9x implementation of thread model follows
//=============================================
CWin9xThread::CWin9xThread(){}
CWin9xThread::~CWin9xThread(){}

//------------------------------------------------------------
// Support for resource allocation, initializations, DLL loads
//
//-----------------------------------------------------------
LONG CWin9xThread::fLoadResources()
{
	return ERROR_SUCCESS ;
}

//--------------------------------------------------
// Support for resource deallocation and DLL unloads
//
//--------------------------------------------------
LONG CWin9xThread::fUnLoadResources()
{
	return ERROR_SUCCESS ;
}

//---------------------------------------
// Populate Thread properties by instance
//
//---------------------------------------
WBEMSTATUS CWin9xThread::eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst )
{
 	WBEMSTATUS t_wStatus = WBEM_E_FAILED ;

	// Extract the process and thread handles
    // ======================================
	CHString t_chsHandle ;

	SmartCloseHandle t_hSnapshot;

	a_pInst->GetCHString( IDS_ProcessHandle, t_chsHandle ) ;
	DWORD t_dwProcessID = _wtol( t_chsHandle ) ;

	a_pInst->GetCHString( IDS_Handle, t_chsHandle ) ;
	DWORD t_dwThreadID = _wtol( t_chsHandle ) ;

	// Take a thread snapshot by process
	// =================================
	CKernel32Api *t_pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidKernel32Api, NULL ) ;

	if( t_pKernel32 != NULL )
	{
		t_hSnapshot = INVALID_HANDLE_VALUE;
        t_pKernel32->CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, t_dwProcessID, &t_hSnapshot ) ;

		if( INVALID_HANDLE_VALUE == t_hSnapshot )
		{
			return WBEM_E_FAILED ;
		}

		// Step through the threads
		// ========================
		BOOL t_fRetCode ;
		THREADENTRY32 t_oThreadEntry ;

		t_oThreadEntry.dwSize = sizeof( THREADENTRY32 ) ;

		t_fRetCode = false;
        t_pKernel32->Thread32First( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) ;

		while( t_fRetCode )
		{
			// Thread test
			if( ( 12 <= t_oThreadEntry.dwSize ) &&
				t_dwThreadID == t_oThreadEntry.th32ThreadID )
			{
				// Process test ( redundant
				if( ( 16 <= t_oThreadEntry.dwSize ) &&
					t_dwProcessID == t_oThreadEntry.th32OwnerProcessID )
				{
					// Not much here, but good to go.

	//Uncomment these after updating Instance files

					/* CIM_Thread properties */
	/*				a_pInst->SetNull( IDS_Priority ) ;
					a_pInst->SetNull( IDS_ExecutionState ) ;
					a_pInst->SetNull( IDS_UserModeTime ) ;
					a_pInst->SetNull( IDS_KernelModeTime ) ;
	*/
					/* Win32_Thread properties */
	//				a_pInst->SetNull( IDS_ElapsedTime ) ;
					a_pInst->SetDWORD( IDS_PriorityBase, t_oThreadEntry.tpBasePri ) ;
					a_pInst->SetDWORD( IDS_Priority, GetThreadPriority ( t_oThreadEntry.tpBasePri , t_oThreadEntry.tpDeltaPri ) ) ;
	//				a_pInst->SetNull( IDS_StartAddress ) ;
	//				a_pInst->SetNull( IDS_ThreadState ) ;
	//				a_pInst->SetNull( IDS_ThreadWaitreason ) ;

					// collect the common static properties
					return eLoadCommonThreadProperties( a_pProvider, a_pInst ) ;
				}
			}

			// next
			t_oThreadEntry.dwSize = sizeof( THREADENTRY32 ) ;
			t_pKernel32->Thread32Next( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) ;
		}

		// not found
		t_wStatus = ( ERROR_NO_MORE_FILES == GetLastError() ) ? WBEM_E_NOT_FOUND : WBEM_E_FAILED ;

		CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidKernel32Api, t_pKernel32 ) ;

		t_pKernel32 = NULL ;
	}

	return t_wStatus;
}

//
WBEMSTATUS CWin9xThread::eEnumerateThreadInstances( WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext )
{
	WBEMSTATUS			t_wStatus = WBEM_E_FAILED ;
	SmartCloseHandle	t_hSnapshot ;

	// Take a process snapshot
	// =======================
	CKernel32Api *t_pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidKernel32Api, NULL ) ;

	if( t_pKernel32 != NULL )
	{
		t_hSnapshot = INVALID_HANDLE_VALUE;
        t_pKernel32->CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0, &t_hSnapshot ) ;

		if( INVALID_HANDLE_VALUE == t_hSnapshot )
		{
			return WBEM_E_FAILED ;
		}

		// Step through the process
		// ========================
		BOOL			t_fRetCode ;
		PROCESSENTRY32	t_oProcessEntry ;

		t_oProcessEntry.dwSize = sizeof( PROCESSENTRY32 ) ;

		t_fRetCode = false;
        t_pKernel32->Process32First( t_hSnapshot, &t_oProcessEntry, &t_fRetCode ) ;

		while( t_fRetCode )
		{
			// Process test ( redundant
			if( 16 <= t_oProcessEntry.dwSize )
			{
				if(	WBEM_NO_ERROR != ( t_wStatus =
					eEnumerateThreadByProcess( a_pMethodContext, a_pProvider,
											   t_oProcessEntry.th32ProcessID ) ) )
				{
					return t_wStatus ;
				}
			}

			// next
			t_oProcessEntry.dwSize = sizeof( PROCESSENTRY32 ) ;

			t_pKernel32->Process32Next( t_hSnapshot, &t_oProcessEntry, &t_fRetCode ) ;
		}

		// not found
		t_wStatus = ( ERROR_NO_MORE_FILES == GetLastError() ) ? WBEM_NO_ERROR : WBEM_E_FAILED ;

		CResourceManager::sm_TheResourceManager.ReleaseResource( g_guidKernel32Api, t_pKernel32 ) ;

		t_pKernel32 = NULL ;
	}
	return t_wStatus ;
}

//--------------------------------------
// Populate Thread properties by Process
//
//--------------------------------------
WBEMSTATUS CWin9xThread::eEnumerateThreadByProcess( MethodContext *a_pMethodContext,
												    WbemThreadProvider *a_pProvider,
												    DWORD a_dwProcessID )
{
 	CHString	t_chsHandle ;
	WBEMSTATUS	t_wStatus  = WBEM_NO_ERROR ;
	SmartCloseHandle t_hSnapshot;

	// Take a thread snapshot by process
	// =================================
	CKernel32Api *t_pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource( g_guidKernel32Api, NULL ) ;

	if( NULL == t_pKernel32 )
	{
		return WBEM_E_FAILED ;
	}

    t_hSnapshot = INVALID_HANDLE_VALUE;
	t_pKernel32->CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, a_dwProcessID, &t_hSnapshot ) ;

	if( INVALID_HANDLE_VALUE == t_hSnapshot )
	{
		return WBEM_E_FAILED ;
	}

	// Step through the threads
	// ========================
	BOOL t_fRetCode ;
	THREADENTRY32 t_oThreadEntry ;

	t_oThreadEntry.dwSize = sizeof( THREADENTRY32 ) ;

	t_fRetCode = false;
    t_pKernel32->Thread32First( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) ;

	// smart ptr
	CInstancePtr t_pInst ;

	while( t_fRetCode )
	{
		// Process test
		if( ( 16 <= t_oThreadEntry.dwSize ) &&
			a_dwProcessID == t_oThreadEntry.th32OwnerProcessID )
		{
			// Create an instance
			t_pInst.Attach( a_pProvider->CreateNewInstance( a_pMethodContext ) ) ;

			// ProcesID
			t_chsHandle.Format( L"%lu", t_oThreadEntry.th32OwnerProcessID  ) ;
			t_pInst->SetCHString( IDS_ProcessHandle, t_chsHandle ) ;

			// ThreadID
			t_chsHandle.Format( L"%lu", t_oThreadEntry.th32ThreadID ) ;
			t_pInst->SetCHString( IDS_Handle, t_chsHandle ) ;

			/* CIM_Thread properties */
/*			t_pInst->SetNull( IDS_Priority ) ;
			t_pInst->SetNull( IDS_ExecutionState ) ;
			t_pInst->SetNull( IDS_UserModeTime ) ;
			t_pInst->SetNull( IDS_KernelModeTime ) ;

*/			/* Win32_Thread properties */
//			t_pInst->SetNull( IDS_ElapsedTime ) ;
			t_pInst->SetDWORD( IDS_PriorityBase, t_oThreadEntry.tpBasePri ) ;
			t_pInst->SetDWORD( IDS_Priority, GetThreadPriority ( t_oThreadEntry.tpBasePri , t_oThreadEntry.tpDeltaPri ) ) ;
//			t_pInst->SetNull( IDS_StartAddress ) ;
//			t_pInst->SetNull( IDS_ThreadState ) ;
//			t_pInst->SetNull( IDS_ThreadWaitreason ) ;

			// collect the common static properties
			if( WBEM_NO_ERROR != ( t_wStatus = eLoadCommonThreadProperties( a_pProvider, t_pInst )) )
			{
				break ;
			}

			t_wStatus = (WBEMSTATUS)t_pInst->Commit() ;
		}

        if (SUCCEEDED(t_wStatus))
        {
			// next
			t_oThreadEntry.dwSize = sizeof( THREADENTRY32 ) ;
			t_pKernel32->Thread32Next( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) ;
        }
        else
        {
            break;
        }
	}

    if (SUCCEEDED(t_wStatus))
    {
    	t_wStatus = ( ERROR_NO_MORE_FILES == GetLastError() ) ? WBEM_NO_ERROR : WBEM_E_FAILED ;
    }

	CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, t_pKernel32 ) ;
	t_pKernel32 = NULL ;

	return t_wStatus ;
}

/*
 * From observations, THREADENTRY32.tpBasePri contains the "BasePriority" of a thread whose "PriorityValue" is THREAD_PRIORITY_NORMAL
 * (or the priority associated with the process class ) .
 * "BasePriority" of a thread is determined by the "PriorityClass" of the process & the "PriorityValue" of the thread. To make things
 * more interesting, the system may increase or lower the "DynamicPriority" of a thread wrt it's "BasePriority"
 * THREADENTRY32.tpDeltaPri contains the "PriorityValue" of the thread.
 */
DWORD GetThreadPriority ( DWORD a_dwPriorityOfProcessClass , int a_PriorityValue )
{
	DWORD t_dwThreadPriority ;

/*
 * If value is THREAD_PRIORITY_NORMAL , then priority is the same as that associated with the process class
 */
	if ( a_PriorityValue == THREAD_PRIORITY_NORMAL )
	{
		t_dwThreadPriority = a_dwPriorityOfProcessClass ;
	}
	else if ( a_PriorityValue == THREAD_PRIORITY_IDLE )
	{
		if ( a_dwPriorityOfProcessClass < 16 )
		{
			t_dwThreadPriority = 1 ;
		}
		else
		{
			t_dwThreadPriority = 16 ;
		}
	}
	else if ( a_PriorityValue == THREAD_PRIORITY_TIME_CRITICAL )
	{
		if ( a_dwPriorityOfProcessClass < 16 )
		{
			t_dwThreadPriority = 15 ;
		}
		else
		{
			t_dwThreadPriority = 31 ;
		}
	}
	else
	{
		t_dwThreadPriority = a_dwPriorityOfProcessClass + a_PriorityValue ;
	}

	return t_dwThreadPriority ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\timezone.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// TimeZone.h        	

//                                                                  

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
//  10/14/96     jennymc    Updated to meet current standards
//  10/27/97     davwoh     Moved to curly
//	03/02/99	 a-peterc	Added graceful exit on SEH and memory failures,
//							syntactic clean up
//                                                                   
///////////////////////////////////////////////////////////////////////

#define PROPSET_NAME_TIMEZONE L"Win32_TimeZone"

///////////////////////////////////////////////////////////////////////
// Declare Get and Put functions for individual properties
// here before they are used in template declarations
// Match the pointer types to the type that you pass
// as the first argument to the template, so if the property
// type is a DWORD then make the the function call have
// a DWORD pointer. It is done this way rather than through
// void pointers to help prevent memory overwrites that may
// happen with memcpy type of code
//
// Place "get" and "put" function prototypes here
// Example:
// BOOL GetFunction(void* myvalue);
// Then just use the name of your function as the get or put
// argument location in the property declaration
//==========================================================

// PROPERTY SET
//=============
class CWin32TimeZone : public Provider  
{
	private:
		BOOL GetTimeZoneInfo( CInstance *a_pInst ) ;

	public:
		// Constructor sets the name and description of the property set
		// and initializes the properties to their startup values
		//==============================================================
		CWin32TimeZone( const CHString &a_name, LPCWSTR a_pszNamespace ) ;  // constructor
		~CWin32TimeZone() ;  // destructor

		// These functions are REQUIRED for the property set
		//==================================================
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\timezone.cpp ===
///////////////////////////////////////////////////////////////////////

//

// TimeZone.cpp -- Implementation of MO Provider for CD Rom

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  10/15/96     jennymc    Updated to meet current standards
//	03/02/99	 a-peterc	Added graceful exit on SEH and memory failures,
//							clean up
//
///////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <ProvExce.h>

#include "timezone.h"
#include <cregcls.h>

CWin32TimeZone MyTimeZone( PROPSET_NAME_TIMEZONE, IDS_CimWin32Namespace ) ;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32TimeZone::CWin32TimeZone
 Description: CONSTRUCTOR
 Arguments: None
 Returns:   Nothing
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
CWin32TimeZone::CWin32TimeZone( const CHString &a_name, LPCWSTR a_pszNamespace )
:Provider( a_name, a_pszNamespace )
{
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32TimeZone::~CWin32TimeZone
 Description: CONSTRUCTOR
 Arguments: None
 Returns:   Nothing
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
CWin32TimeZone::~CWin32TimeZone()
{
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  BOOL CWin32TimeZone::GetObject(void)
 Description: Refreshes the property set upon request
 			  This function is only required when you
			  need an update of the properties but the
			  properties are only set in the context of
			  the complete property set like this example
 Arguments: None
 Returns:   TRUE is success else FALSE
 Inputs:
 Outputs:
 Caveats:
     LONG       Bias;
    WCHAR      StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG       StandardBias;
    WCHAR      DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG       DaylightBias;

 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
HRESULT CWin32TimeZone::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
	HRESULT t_hResult ;
	CHString t_chsStandardIn, t_chsStandardOut ;

	a_pInst->GetCHString( IDS_StandardName, t_chsStandardIn ) ;

	if ( GetTimeZoneInfo( a_pInst ) )
	{
		// We got an instance, is it the one they asked for?
		a_pInst->GetCHString( IDS_StandardName, t_chsStandardOut ) ;

		if( t_chsStandardOut.CompareNoCase( t_chsStandardIn ) != 0 )
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
		else
		{
			t_hResult = WBEM_S_NO_ERROR ;
		}
	}
	else
	{
      // Couldn't get an instance
      t_hResult = WBEM_E_FAILED ;
   }

	return t_hResult ;

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: DWORD CWin32TimeZone::EnumerateInstances
 Description: Loops through the process list and add a new
              instance for each process
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
HRESULT CWin32TimeZone::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;

	CInstancePtr t_pInst(CreateNewInstance( a_pMethodContext ), false);
	if ( t_pInst != NULL )
	{
		if( GetTimeZoneInfo( t_pInst ) )
		{
			t_hResult = t_pInst->Commit(  ) ;
		}
	}
	else
	{
		t_hResult = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_hResult;
}

////////////////////////////////////////////////////////////////////////
BOOL CWin32TimeZone::GetTimeZoneInfo(CInstance *a_pInst )
{
    TIME_ZONE_INFORMATION t_tzone ;

	// 0xffffffff compare is per spec
	// ==============================
	if( 0xffffffff != GetTimeZoneInformation( &t_tzone ) )
	{
		// Start building a new instance
		//==============================
		a_pInst->SetWBEMINT16(	L"Bias",				( -1 * t_tzone.Bias ) ) ;
		a_pInst->SetWCHARSplat(	L"StandardName",		t_tzone.StandardName ) ;
		a_pInst->SetDWORD(		L"StandardYear",		t_tzone.StandardDate.wYear ) ;
		a_pInst->SetDWORD(		L"StandardMonth",		t_tzone.StandardDate.wMonth ) ;
		a_pInst->SetDWORD(		L"StandardDay",			t_tzone.StandardDate.wDay ) ;
		a_pInst->SetDWORD(		L"StandardHour",		t_tzone.StandardDate.wHour ) ;
		a_pInst->SetDWORD(		L"StandardMinute",		t_tzone.StandardDate.wMinute ) ;
		a_pInst->SetDWORD(		L"StandardSecond",		t_tzone.StandardDate.wSecond ) ;
		a_pInst->SetDWORD(		L"StandardMillisecond", t_tzone.StandardDate.wMilliseconds ) ;
		a_pInst->SetDWORD(		L"StandardBias",		t_tzone.StandardBias ) ;
		a_pInst->SetWCHARSplat(	L"DaylightName",		t_tzone.DaylightName ) ;
		a_pInst->SetDWORD(		L"DaylightYear",		t_tzone.DaylightDate.wYear ) ;
		a_pInst->SetDWORD(		L"DaylightMonth",		t_tzone.DaylightDate.wMonth ) ;
		a_pInst->SetDWORD(		L"DaylightDay",			t_tzone.DaylightDate.wDay ) ;
		a_pInst->SetDWORD(		L"DaylightHour",		t_tzone.DaylightDate.wHour ) ;
		a_pInst->SetDWORD(		L"DaylightMinute",		t_tzone.DaylightDate.wMinute ) ;
		a_pInst->SetDWORD(		L"DaylightSecond",		t_tzone.DaylightDate.wSecond ) ;
		a_pInst->SetDWORD(		L"DaylightMillisecond", t_tzone.DaylightDate.wMilliseconds ) ;
		a_pInst->SetDWORD(		L"DaylightBias",		t_tzone.DaylightBias ) ;
		a_pInst->SetByte(		L"StandardDayOfWeek",	t_tzone.StandardDate.wDayOfWeek ) ;
		a_pInst->SetByte(		L"DaylightDayOfWeek",	t_tzone.DaylightDate.wDayOfWeek ) ;

		CRegistry t_RegInfo ;
		CHString t_chsTimeZoneStandardName ;

#ifdef NTONLY
		CHString t_chsTimeZoneInfoRegistryKey ( L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\" ) ;
		t_chsTimeZoneStandardName = t_tzone.StandardName ;
#endif

		if ( !t_chsTimeZoneStandardName.IsEmpty () )
		{
			CHString t_chsTmp ;

			if (	t_RegInfo.Open (
										HKEY_LOCAL_MACHINE,
										t_chsTimeZoneInfoRegistryKey + t_chsTimeZoneStandardName,
										KEY_READ
									) == ERROR_SUCCESS
				)
			{
				if (t_RegInfo.GetCurrentKeyValue ( L"Display", t_chsTmp ) != ERROR_SUCCESS)
				{
					t_chsTmp.Empty();
				}
			}
			else
			{
				//the name be localised so search for it...
				LONG lErr = t_RegInfo.Open (

					HKEY_LOCAL_MACHINE,
					L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones",
					KEY_READ
				);
				
				while (lErr == ERROR_SUCCESS)
				{
					CHString strStd ;

					if (t_RegInfo.GetCurrentSubKeyValue ( L"Std" , strStd ) == ERROR_SUCCESS)
					{
						if (!strStd.IsEmpty() && (strStd.CompareNoCase(t_chsTimeZoneStandardName) == 0))
						{
							if (t_RegInfo.GetCurrentSubKeyValue ( L"Display" , t_chsTmp ) != ERROR_SUCCESS)
							{
								t_chsTmp.Empty();
							}
							
							//matched on std name, no need to search further...
							break;
						}
					}

					lErr = t_RegInfo.NextSubKey();
				}
			}

			if (!t_chsTmp.IsEmpty ())
			{
				a_pInst->SetCHString ( L"Description", t_chsTmp ) ;
				a_pInst->SetCHString ( L"Caption", t_chsTmp ) ;
			}
		}
		return TRUE ;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\useassoc.cpp ===
//=================================================================

//

// useassoc.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <Assoc.h>

CAssociation MySystemToBootConfigGroup(
    L"Win32_SystemBootConfiguration",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_BootConfiguration",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToDesktops(
    L"Win32_SystemDesktop",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_Desktop",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToLogicalMemoryConfig(
    L"Win32_SystemLogicalMemoryConfiguration",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_LogicalMemoryConfiguration",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToProgramGroup(
    L"Win32_SystemProgramGroups",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_LogicalProgramGroup",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToTimeZone(
    L"Win32_SystemTimeZone",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_TimeZone",
    IDS_Element,
    IDS_Setting
);

CAssociation MySystemToBiosSet(
    L"Win32_SystemBIOS",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_BIOS",
    IDS_GroupComponent,
    IDS_PartComponent
);

CAssociation MySystemToPartitionSet(
    L"Win32_SystemPartitions",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_DiskPartition",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToProcessSet(
    L"Win32_SystemProcesses",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_Process",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToSystemDriversSet(
    L"Win32_SystemSystemDriver",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_SystemDriver",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToServicesSet(
    L"Win32_SystemServices",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_Service",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToLoadOrderGroup(
    L"Win32_SystemLoadOrderGroups",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_LoadOrderGroup",
    IDS_GroupComponent,
    IDS_PartComponent
);

CAssociation MySystemToProcessor(
    L"Win32_ComputerSystemProcessor",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_Processor",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToSystemResourceSet(
    L"Win32_SystemResources",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"CIM_SystemResource",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToLogicalDeviceSet(
    L"Win32_SystemDevices",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"CIM_LogicalDevice",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

CAssociation MySystemToNetConnSet(
    L"Win32_SystemNetworkConnections",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_NetworkConnection",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

//========================
class CAssocSystemToOS : public CAssociation
{
    public:

        CAssocSystemToOS(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName

        );

        ~CAssocSystemToOS();

    protected:
        HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        );


};

CAssocSystemToOS::CAssocSystemToOS(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName
) : CAssociation (

    pwszClassName,
    pwszNamespaceName,

    pwszLeftClassName,
    pwszRightClassName,

    pwszLeftPropertyName,
    pwszRightPropertyName
    )
{
}

CAssocSystemToOS::~CAssocSystemToOS()
{
}

HRESULT CAssocSystemToOS::LoadPropertyValues(

    CInstance *pInstance,
    const CInstance *pLeft,
    const CInstance *pRight
)
{
    CAssociation::LoadPropertyValues(pInstance, pLeft, pRight);

    // This will work... until win32_os returns more than one instance.
    pInstance->Setbool(L"PrimaryOS", true);

    return WBEM_S_NO_ERROR;
}



CAssocSystemToOS MySystemToOperatingSystem(
    L"Win32_SystemOperatingSystem",
    IDS_CimWin32Namespace,
    L"Win32_ComputerSystem",
    L"Win32_OperatingSystem",
    IDS_GroupComponent,
    IDS_PartComponent
) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <Binding.h>

CBinding MySerialPortToConfig(
    L"Win32_SerialPortSetting",
    IDS_CimWin32Namespace,
    L"Win32_SerialPort",
    L"Win32_SerialPortConfiguration",
    IDS_Element,
    IDS_Setting,
    IDS_DeviceID,
    IDS_Name);

CBinding MyNetAdaptToNetAdaptConfig(
    L"Win32_NetworkAdapterSetting",
    IDS_CimWin32Namespace,
    L"Win32_NetworkAdapter",
    L"Win32_NetworkAdapterConfiguration",
    IDS_Element,
    IDS_Setting,
    IDS_Index,
    IDS_Index);

CBinding PageFileToPagefileSetting(
    L"Win32_PageFileElementSetting",
    IDS_CimWin32Namespace,
    L"Win32_PageFileUsage",
    L"Win32_PageFileSetting",
    IDS_Element,
    IDS_Setting,
    IDS_Name,
    IDS_Name);

CBinding MyPrinterSetting(
    L"Win32_PrinterSetting",
    IDS_CimWin32Namespace,
    L"Win32_Printer",
    L"Win32_PrinterConfiguration",
    IDS_Element,
    IDS_Setting,
    IDS_DeviceID,
    IDS_Name);

CBinding MyDiskToPartitionSet(
    L"Win32_DiskDriveToDiskPartition",
    IDS_CimWin32Namespace,
    L"Win32_DiskDrive",
    L"Win32_DiskPartition",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_Index,
    IDS_DiskIndex
);

CBinding assocPOTSModemToSerialPort(
    L"Win32_POTSModemToSerialPort",
    IDS_CimWin32Namespace,
    L"Win32_SerialPort",
    L"Win32_POTSModem",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_DeviceID,
    IDS_AttachedTo
);

CBinding OStoQFE(
    L"Win32_OperatingSystemQFE",
    IDS_CimWin32Namespace,
    L"Win32_OperatingSystem",
    L"Win32_QuickFixEngineering",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_CSName,
    IDS_CSName
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\usb.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  USB.cpp
//
//  Purpose: USB Controller property set provider
//
//***************************************************************************

#include "precomp.h"
#include "LPVParams.h"
#include <FRQueryEx.h>
#include <ProvExce.h>

#include "USB.h"

// Property set declaration
//=========================

CWin32USB MyUSBController( PROPSET_NAME_USB, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USB::CWin32USB
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32USB::CWin32USB
(
	const CHString &a_strName,
	LPCWSTR a_pszNamespace
)
: Provider( a_strName, a_pszNamespace )
{
    m_ptrProperties.SetSize(13);
    m_ptrProperties[0]	= ( (LPVOID) IDS_ConfigManagerErrorCode );
    m_ptrProperties[1]	= ( (LPVOID) IDS_ConfigManagerUserConfig );
    m_ptrProperties[2]	= ( (LPVOID) IDS_Status);
    m_ptrProperties[3]	= ( (LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[4]	= ( (LPVOID) IDS_DeviceID);
    m_ptrProperties[5]	= ( (LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6]	= ( (LPVOID) IDS_SystemName);
    m_ptrProperties[7]	= ( (LPVOID) IDS_Description);
    m_ptrProperties[8]	= ( (LPVOID) IDS_Caption);
    m_ptrProperties[9]	= ( (LPVOID) IDS_Name);
    m_ptrProperties[10] = ( (LPVOID) IDS_Manufacturer);
    m_ptrProperties[11] = ( (LPVOID) IDS_ProtocolSupported );
    m_ptrProperties[12] = ( (LPVOID) IDS_CreationClassName );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USB::~CWin32USB
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 ****************************************************************************/

CWin32USB::~CWin32USB()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USB::GetObject
//
//  Inputs:     CInstance		*a_pInst - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USB::GetObject
(
    CInstance *a_pInst,
    long a_lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND ;
    CConfigManager t_cfgmgr ;

	// Let's see if config manager recognizes this device at all
	CHString t_sDeviceID ;
	a_pInst->GetCHString( IDS_DeviceID, t_sDeviceID ) ;

	CConfigMgrDevicePtr t_pDevice;
	if( t_cfgmgr.LocateDevice( t_sDeviceID, t_pDevice ) )
	{
		// OK, it knows about it.  Is it a USBController?
		if( IsOneOfMe(t_pDevice ) )
		{
            CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx*>( &pQuery ) ;
            DWORD t_dwProperties ;

	        t_pQuery2->GetPropertyBitMask( m_ptrProperties, &t_dwProperties ) ;

			t_hResult = LoadPropertyValues( &CLPVParams( a_pInst,
														t_pDevice,
														t_dwProperties ) ) ;
		}
	}

	return t_hResult;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::ExecQuery
//
//  Inputs:     MethodContext *a_pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USB::ExecQuery
(
    MethodContext *a_pMethodContext,
    CFrameworkQuery &a_pQuery,
    long a_lFlags
)
{
    CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_pQuery ) ;
    DWORD t_dwProperties ;

	t_pQuery2->GetPropertyBitMask( m_ptrProperties, &t_dwProperties ) ;
    return Enumerate( a_pMethodContext, a_lFlags, t_dwProperties ) ;
}



////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USB::EnumerateInstances
//
//  Inputs:     MethodContext   *a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USB::EnumerateInstances
(
    MethodContext *a_pMethodContext,
    long a_lFlags /*= 0L*/
)
{
    return Enumerate( a_pMethodContext, a_lFlags ) ;
}



////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USB::Enumerate
//
//  Inputs:     MethodContext   *a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USB::Enumerate
(
    MethodContext *a_pMethodContext,
    long a_lFlags,
    DWORD a_dwReqProps
)
{
    HRESULT				t_hResult = WBEM_E_FAILED ;
    CConfigManager		t_cfgManager ;
    CDeviceCollection	t_deviceList ;
	CInstancePtr		t_pInst;
	CConfigMgrDevicePtr t_pDevice;

	// While it might be more performant to use FilterByGuid, it appears
	// that at least some95 boxes will report usb info if we do it this
	// way.
	if( t_cfgManager.GetDeviceListFilterByClass( t_deviceList, L"USB" ) )
	{
		REFPTR_POSITION t_pos;
		if( t_deviceList.BeginEnum( t_pos ) )
		{
			t_hResult = WBEM_S_NO_ERROR;

			// Walk the list
            for (t_pDevice.Attach(t_deviceList.GetNext( t_pos ));
                 SUCCEEDED( t_hResult ) && (t_pDevice != NULL);
                 t_pDevice.Attach(t_deviceList.GetNext( t_pos )))
			{
				// Now to find out if this is the usb controller
				if( IsOneOfMe( t_pDevice ) )
				{
                    t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
					if( SUCCEEDED( t_hResult = LoadPropertyValues( &CLPVParams(
																		t_pInst,
																		t_pDevice,
																		a_dwReqProps ) ) ) )
					{
						// Derived classes (like CW32USBCntrlDev) may
						// commit as result of call to
						// LoadPropertyValues, so check if we should
						// (only do so if we are of this class's type).
						if( ShouldBaseCommit( NULL ) )
						{
							t_hResult = t_pInst->Commit(  ) ;
						}
					}
				}
			}

			// Always call EndEnum().
			t_deviceList.EndEnum();
		}
	}

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USB::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : void *a_pv - Instance package to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32USB::LoadPropertyValues
(
    void *a_pv
)
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR;
    CHString	t_chstrDeviceID, t_chstrDesc, t_chstrTemp;

    /*************************************
    * Unpack and confirm our parameters...
    *************************************/
    CLPVParams			*t_pData		= ( CLPVParams * ) a_pv ;
    CInstance			*t_pInst		= ( CInstance * )( t_pData->m_pInstance ) ; // This instance released by caller
    CConfigMgrDevice	*t_pDevice		= ( CConfigMgrDevice * )( t_pData->m_pDevice ) ;
    DWORD				t_dwReqProps	= ( DWORD )( t_pData->m_dwReqProps ) ;

    if( t_pInst == NULL || t_pDevice == NULL )
    {
        return WBEM_E_PROVIDER_FAILURE;
    }


    /***********************
    * Set the key properties
    ***********************/

    t_pDevice->GetDeviceID( t_chstrDeviceID ) ;

    if( t_chstrDeviceID.GetLength() == 0 )
    {
        // We need the device id for the key property of this class.  If we can
        // not obtain it, we can't set the key, which is an unacceptable error.
        return WBEM_E_PROVIDER_FAILURE;
    }
    else
    {
        t_pInst->SetCHString( IDS_DeviceID, t_chstrDeviceID ) ;
    }


    /*****************************
    * Set USBController properties
    *****************************/

    if( t_dwReqProps & USB_PROP_Manufacturer )
    {
        if( t_pDevice->GetMfg( t_chstrTemp ) )
        {
            t_pInst->SetCHString( IDS_Manufacturer, t_chstrTemp ) ;
        }
    }


    /*****************************
    * Set CIMController properties
    *****************************/

    // Fixed value from enumerated list
    if( t_dwReqProps & USB_PROP_ProtocolSupported )
    {
        t_pInst->SetWBEMINT16( IDS_ProtocolSupported, 16 ) ;
    }


    /*********************************
    * Set CIM_LogicalDevice properties
    *********************************/

    if( t_dwReqProps & USB_PROP_PNPDeviceID )
    {
        t_pInst->SetCHString( IDS_PNPDeviceID, t_chstrDeviceID ) ;
    }

	if( t_dwReqProps & USB_PROP_SystemCreationClassName )
    {
        t_pInst->SetCHString( IDS_SystemCreationClassName,
                                  IDS_Win32ComputerSystem ) ;
    }
	if( t_dwReqProps & USB_PROP_CreationClassName )
    {
        SetCreationClassName(t_pInst);
    }
    if( t_dwReqProps & USB_PROP_SystemName )
    {
        t_pInst->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;
    }

    if( t_dwReqProps & (USB_PROP_Description | USB_PROP_Caption | USB_PROP_Name) )
    {
        if( t_pDevice->GetDeviceDesc( t_chstrDesc ) )
        {
            t_pInst->SetCHString( IDS_Description, t_chstrDesc ) ;
        }
    }

    if( t_dwReqProps & USB_PROP_ConfigManagerErrorCode ||
        t_dwReqProps & USB_PROP_Status )
    {
        DWORD t_dwStatus	= 0L;
        DWORD t_dwProblem	= 0L;

		if( t_pDevice->GetStatus( &t_dwStatus, &t_dwProblem ) )
        {
            if( t_dwReqProps & USB_PROP_ConfigManagerErrorCode )
            {
                t_pInst->SetDWORD( IDS_ConfigManagerErrorCode, t_dwProblem ) ;
            }

            if( t_dwReqProps & USB_PROP_Status )
            {
                CHString t_chsTmp;

				ConfigStatusToCimStatus ( t_dwStatus , t_chsTmp ) ;
                t_pInst->SetCHString(IDS_Status, t_chsTmp);
            }
        }
    }

    if( t_dwReqProps & USB_PROP_ConfigManagerUserConfig )
    {
        t_pInst->SetDWORD( IDS_ConfigManagerUserConfig,
                               t_pDevice->IsUsingForcedConfig() ) ;
    }

    // Use the friendly name for caption and name
    if( t_dwReqProps & USB_PROP_Caption || t_dwReqProps & USB_PROP_Name )
    {
        if( t_pDevice->GetFriendlyName( t_chstrTemp ) )
        {
            t_pInst->SetCHString( IDS_Caption, t_chstrTemp ) ;
            t_pInst->SetCHString( IDS_Name, t_chstrTemp ) ;
        }
        else
        {
            // If we can't get the name, settle for the description
            if( t_chstrDesc.GetLength() > 0 )
            {
                t_pInst->SetCHString( IDS_Caption, t_chstrDesc ) ;
                t_pInst->SetCHString( IDS_Name, t_chstrDesc ) ;
            }
        }
    }
    return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USB::IsOneOfMe
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of USB device.
 *
 *  INPUTS      : void *a_pv - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid USB class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32USB::IsOneOfMe
(
    void *a_pv
)
{
    bool t_fRet = false;

    if( NULL != a_pv )
    {
        CConfigMgrDevice *t_pDevice = ( CConfigMgrDevice * ) a_pv ;

		// Ok, it knows about it. Is it a usb device?
        if( t_pDevice->IsClass( L"USB" ) )
        {
            // Now to find out if this is the usb controller
            CConfigMgrDevicePtr t_pParentDevice;

			if( t_pDevice->GetParent(t_pParentDevice))
            {
				// If the class of the parent isn't 'USB', this is the
                // controller...
                if( !t_pParentDevice->IsClass( L"USB" ) )
                {
                    t_fRet = true ;
                }
            }
        }
    }
    return t_fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\usb.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  USB.h
//
//  Purpose: USB Controller property set provider
//
//***************************************************************************

// Property set identification
//============================
#ifndef _USB_H
#define _USB_H



#define USB_ALL_PROPS                    0xFFFFFFFF
#define USB_KEY_ONLY                     0x00000010
#define USB_PROP_ConfigManagerErrorCode  0x00000001
#define USB_PROP_ConfigManagerUserConfig 0x00000002
#define USB_PROP_Status                  0x00000004
#define USB_PROP_PNPDeviceID             0x00000008
#define USB_PROP_DeviceID                0x00000010
#define USB_PROP_SystemCreationClassName 0x00000020
#define USB_PROP_SystemName              0x00000040
#define USB_PROP_Description             0x00000080
#define USB_PROP_Caption                 0x00000100
#define USB_PROP_Name                    0x00000200
#define USB_PROP_Manufacturer            0x00000400
#define USB_PROP_ProtocolSupported       0x00000800
#define USB_PROP_CreationClassName       0x00001000






#define	PROPSET_NAME_USB	L"Win32_USBController"

class CWin32USB : virtual public Provider
{
    private:
        CHPtrArray m_ptrProperties;

    protected:

        virtual bool IsOneOfMe
        (
            void *a_pv
        );

        virtual HRESULT LoadPropertyValues
        (
            void *a_pv
        );

        virtual bool ShouldBaseCommit
        (
            void *a_pvData
        );

        HRESULT Enumerate
        (
            MethodContext *a_pMethodContext, 
            long a_lFlags, 
            DWORD a_dwReqProps = USB_ALL_PROPS
        );

    public:

        // Constructor/destructor
        //=======================

        CWin32USB
        (
			const CHString &a_strName, 
			LPCWSTR a_pszNamespace
        );

        ~CWin32USB();

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject
        (
            CInstance *a_pInst, 
            long a_lFlags,
            CFrameworkQuery& pQuery
        );

        virtual HRESULT ExecQuery
        (
            MethodContext *a_pMethodContext, 
            CFrameworkQuery &a_pQuery, 
            long a_Flags = 0L 
        );

        virtual HRESULT EnumerateInstances
        (
            MethodContext *a_pMethodContext, 
            long a_lFlags = 0L
        );        
} ;

// This is the base; it should always commit in the base.
inline bool CWin32USB::ShouldBaseCommit
(
    void *a_pvData
)
{ 
    return true; 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\user.h ===
//=================================================================

//

// User.h -- User property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain users
//
//=================================================================

// Method name for changing the key in this WMI class
#define METHOD_NAME_RenameAccount	L"Rename"

// Method return property
#define METHOD_ARG_NAME_METHODRESULT L"ReturnValue"


// Property set identification
//============================
#define	PROPSET_NAME_USER	L"Win32_UserAccount"

class CWin32UserAccount : public Provider
{
   private:

        // Utility function(s)
        //====================

		BOOL	RefreshInstance( CInstance *a_pInst ) ;
		HRESULT AddDynamicInstances( MethodContext *a_pMethodContext ) ;

	#ifdef NTONLY      
        void LoadUserValuesNT(CHString a_strDomainName, 
                              CHString a_strUserName, 
                              WCHAR *a_pwszFullName, 
                              WCHAR *a_pwszDescription, 
                              DWORD a_dwFlags,
                              WCHAR *a_pwszComputerName, 
                              CInstance *a_pInstance );

        void LoadUserValuesNTW(LPCWSTR a_strDomainName, 
                               LPCWSTR a_strUserName, 
                               LPCWSTR a_pwszFullName, 
                               LPCWSTR a_pwszDescription, 
                               DWORD a_dwFlags,
                               WCHAR *a_pwszComputerName, 
                               CInstance *a_pInstance );

		BOOL GetSIDInformation(const CHString &a_strDomainName, 
                               const CHString &a_strAccountName, 
                               const CHString &a_strComputerName, 
                               CInstance *a_pInst );

        BOOL GetSIDInformationW(LPCWSTR a_wstrDomainName, 
                                LPCWSTR a_wstrAccountName, 
                                LPCWSTR a_wstrComputerName, 
                                CInstance *a_pInst ) ;

        HRESULT GetDomainUsersNTW( CNetAPI32 &a_netapi, LPCWSTR a_pszDomain, MethodContext *a_pMethodContext );
		BOOL GetSingleUserNT( CNetAPI32 &a_netapi, CInstance *a_pInst );
        BOOL GetSingleUserNTW( CNetAPI32 &a_netapi, CInstance *a_pInst );
	#endif

		HRESULT hRenameAccount( 

			CInstance *a_pInst,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long a_Flags ) ;

    
public:

        // Constructor/destructor
        //=======================

        CWin32UserAccount( const CHString& strName, LPCWSTR pszNamespace ) ;
       ~CWin32UserAccount() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
        virtual HRESULT ExecQuery( MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ ) ;

#ifdef NTONLY	
		virtual	HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);

		virtual	HRESULT ExecMethod(	const CInstance &a_Inst,
									const BSTR a_MethodName, 
									CInstance *a_InParams,
									CInstance *a_OutParams,
									long a_Flags = 0L ) ;

		// method errors -- maps to mof
		enum E_MethodResult	{
			e_Success,
			e_InstanceNotFound,
			e_NoInstance,
			e_InvalidParameter,
			e_UserNotFound,
			e_InvalidComputer,
			e_NotPrimary,
			e_LastAdmin,
			e_SpeGroupOp,
			e_ApiError,
			e_InternalError
		};		

#endif		
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\user.cpp ===
//=================================================================

//

// User.CPP -- User property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain users
//
//=================================================================

#include "precomp.h"

#include "wbemnetapi32.h"
#include <comdef.h>
#include "sid.h"
#include <ProvExce.h>
#include "User.h"
#include <vector>
#include <stack>
#include <frqueryex.h>

#include <computerAPI.h>

//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32UserAccount	Win32UserAccount( PROPSET_NAME_USER, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::CWin32UserAccount
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32UserAccount::CWin32UserAccount( const CHString& strName, LPCWSTR pszNamespace /*=NULL*/ )
:	Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::~CWin32UserAccount
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CWin32UserAccount::~CWin32UserAccount()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Directory::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32UserAccount::ExecQuery(
									 MethodContext *a_pMethodContext,
									 CFrameworkQuery &a_pQuery,
									 long a_lFlags /*= 0L*/ )
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR ;
    std::vector<_bstr_t> t_vectorDomains;
    std::vector<_bstr_t> t_vectorUsers;
    std::vector<_variant_t> t_vectorLocalAccount;
    DWORD t_dwReqDomains;
    DWORD t_dwReqUsers;
    CInstancePtr t_pInst;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&a_pQuery);
    bool fLocalAccountPropertySpecified = false;
    bool fLocalAccount = false;

    // Get the definitive values for Domain and Name
    // Where domain = 'a' gives domain=a, user=''
    // Where (domain = 'a' and user = 'b') or (domain = 'c' and user = 'd') gives domain=a,c user=b,d
    // Where domain='a' or user='b' gives domain='', user='' (nothing is definitive)
    // Where domain>'a' gives domain='', user='' (nothing is definitive)
    a_pQuery.GetValuesForProp( L"Domain", t_vectorDomains ) ;
    a_pQuery.GetValuesForProp( L"Name", t_vectorUsers ) ;
    pQuery2->GetValuesForProp( IDS_LocalAccount, t_vectorLocalAccount ) ;

    // See if only local accounts requested
    if(t_vectorLocalAccount.size() > 0)
    {
        fLocalAccountPropertySpecified = true;
        // use variant_t's bool extractor...
        fLocalAccount = t_vectorLocalAccount[0];
    }

    // Get the counts
    t_dwReqDomains = t_vectorDomains.size() ;
    t_dwReqUsers = t_vectorUsers.size() ;

    WCHAR t_wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH + 1 ] ;
    DWORD t_dwNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;
    ZeroMemory( t_wstrLocalComputerName, sizeof( t_wstrLocalComputerName ) ) ;
	if(!ProviderGetComputerName( t_wstrLocalComputerName, &t_dwNameSize ) )
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError () )
		{
			return WBEM_E_ACCESS_DENIED;
		}
		else
		{
			return WBEM_E_FAILED;
		}
	}

	// If the query didn't use a path or an operator on a path that I know
	// how to optimize, get them all and let cimom sort it out
	DWORD t_dwOurDomains;

	if ( t_dwReqDomains == 0 && t_dwReqUsers == 0 && fLocalAccount == false)
	{
	  EnumerateInstances( a_pMethodContext ) ;
	}
	else
	{
		CNetAPI32 t_NetAPI ;
		bool t_bFound;
		int t_x, t_y, t_z;

		if( t_NetAPI.Init() == ERROR_SUCCESS )
		{
			// Get all the domains related to this one (plus this one)
			std::vector<_bstr_t> t_vectorTrustList;
			t_NetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;
			t_dwOurDomains = t_vectorTrustList.size() ;

			// Walk all of our domains.  I do it this way instead of walking acsDomains for two reasons
			// 1) It disallows the enumeration of domains that aren't "ours"
			// 2) It deals with the possibility of duplicates (where domain='a' and domain='a' will have two entries in acsDomains)
            bool fDone = false;
			for ( t_x = 0; t_x < t_dwOurDomains && !fDone; t_x++ )
			{
				// If this 'if' is true, we have domains but no users
				if ( t_dwReqUsers == 0)
				{
					t_bFound = false;

					// See if this entry (from the 'for x' above) of 'our' domains is in the list of domains requested
					for ( t_y = 0; ( (t_y < t_dwReqDomains) || fLocalAccount ) && ( !t_bFound ) && (!fDone); t_y++ )
					{
						// Found one
						if ( (fLocalAccountPropertySpecified && fLocalAccount) ?
                                 _wcsicmp((WCHAR*) t_vectorTrustList[t_x], t_wstrLocalComputerName) == 0  :
                                 _wcsicmp((WCHAR*) t_vectorTrustList[t_x], t_vectorDomains[t_y]) == 0 )
						{
							t_bFound = true;
                            if(fLocalAccountPropertySpecified)
                            {
                                if(fLocalAccount)
                                {
                                    if(_wcsicmp(t_wstrLocalComputerName, t_vectorTrustList[t_x]) == 0)
                                    {
                                        t_hResult = GetDomainUsersNTW( t_NetAPI, (WCHAR*) t_vectorTrustList[t_x], a_pMethodContext ) ;
                                        fDone = true;
                                    }
                                }
                                else
                                {
                                    if(_wcsicmp(t_wstrLocalComputerName, t_vectorTrustList[t_x]) != 0)
                                    {
                                        t_hResult = GetDomainUsersNTW( t_NetAPI, (WCHAR*) t_vectorTrustList[t_x], a_pMethodContext ) ;
                                    }
                                }
                            }
                            else
                            {
							    t_hResult = GetDomainUsersNTW( t_NetAPI, (WCHAR*) t_vectorTrustList[t_x], a_pMethodContext ) ;
                            }
						}
					}

				// Users but no domains
				}
				else if ( t_dwReqDomains == 0 )
				{
				   // If they ask for a user with no domain, we must check for that user
				   // in all of 'our' domains.  Remember, we are walking domains in the 'for x' above.
				   for ( t_y = 0; t_y < t_dwReqUsers; t_y++ )
				   {
                        t_pInst.Attach(CreateNewInstance( a_pMethodContext ));

						// Do the setup
						t_pInst->SetWCHARSplat( IDS_Domain, (WCHAR*) t_vectorTrustList[t_x] ) ;

						_bstr_t t( t_vectorUsers[ t_y ] ) ;
						t_pInst->SetWCHARSplat( IDS_Name, t_vectorUsers[t_y] ) ;

						// See if we can find one
						if ( GetSingleUserNTW( t_NetAPI, t_pInst ) )
						{
							t_hResult = t_pInst->Commit(  ) ;
						}
					}

				// We got BOTH users AND domains.  In this case we need to look for each of the entries
				// in the users list in each of the domains in the domains list.  This can give us more
				// than they requested, but cimom will filter the excess.
				}
				else
				{
				   t_bFound = false;

				   for (t_y = 0; ( t_y < t_dwReqDomains ) && ( !t_bFound ); t_y++ )
				   {
					  // See if this entry (from the 'for x' above) of 'our' domains is in the list of domains requested
					  if ( _wcsicmp((WCHAR*) t_vectorTrustList[t_x], t_vectorDomains[t_y]) == 0 )
					  {
						 t_bFound = true;

						 // Now walk all the users they requested and return instances
						 for ( t_z = 0; t_z < t_dwReqUsers; t_z++ )
						 {
                            t_pInst.Attach(CreateNewInstance( a_pMethodContext ));
							t_pInst->SetWCHARSplat( IDS_Domain, (WCHAR*) t_vectorTrustList[t_x] ) ;
							t_pInst->SetWCHARSplat( IDS_Name, t_vectorUsers[t_z] ) ;

							if ( GetSingleUserNTW( t_NetAPI, t_pInst) )
							{
							   t_hResult = t_pInst->Commit(  ) ;
							}
						 }
					  }
				   }
				}
			}
		}
	}
	return t_hResult;
}
#endif
////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32UserAccount::GetObject( CInstance *a_pInst, long a_lFlags /*= 0L*/ )
{
	BOOL t_fReturn = FALSE;

	// Find the instance depending on platform id.
	t_fReturn = RefreshInstance( a_pInst );

	return t_fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND ;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32UserAccount::EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/ )
{
	// Get the proper OS dependent instance
	return AddDynamicInstances( a_pMethodContext );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::PutInstance
 *
 *  DESCRIPTION : Write changed instance
 *
 *  INPUTS      : a_rInst to store data from
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY

HRESULT CWin32UserAccount::PutInstance(

const CInstance &a_rInst,
long			a_lFlags /*= 0L*/
)
{
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	USER_INFO_2 *t_pUserInfo2 = NULL;

	CHString	t_chsUserName ;
	CHString	t_chsDomainName ;

	// No user creation
	if ( a_lFlags & WBEM_FLAG_CREATE_ONLY )
	{
		return WBEM_E_UNSUPPORTED_PARAMETER;
	}

	CNetAPI32 t_NetAPI;

	if ( t_NetAPI.Init () == ERROR_SUCCESS )
	{
		a_rInst.GetCHString( IDS_Name , t_chsUserName ) ;
		a_rInst.GetCHString( IDS_Domain, t_chsDomainName ) ;

		NET_API_STATUS t_Status = t_NetAPI.NetUserGetInfo(	(LPCWSTR)t_chsDomainName,
															(LPCWSTR)t_chsUserName,
															2,
															(LPBYTE*) &t_pUserInfo2 ) ;
		try
		{
			bool t_bSetFlags = false ;

			if( NERR_Success == t_Status && t_pUserInfo2 )
			{
				// Disabled?
				if( !a_rInst.IsNull( IDS_Disabled ) )
				{
					bool t_bDisabled = false ;
					if( a_rInst.Getbool( IDS_Disabled, t_bDisabled ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_ACCOUNTDISABLE ? true : false ;

						if( t_bCurrentSetting != t_bDisabled )
						{
							t_bSetFlags = true ;

							if( t_bDisabled )
							{
								t_pUserInfo2->usri2_flags |= UF_ACCOUNTDISABLE ;
							}
							else
							{
								t_pUserInfo2->usri2_flags &= ~UF_ACCOUNTDISABLE ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Lockout?
				if( !a_rInst.IsNull( IDS_Lockout ) )
				{
					bool t_bLockout = false ;
					if( a_rInst.Getbool( IDS_Lockout, t_bLockout ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_LOCKOUT ? true : false ;

						if( t_bCurrentSetting != t_bLockout )
						{
							t_bSetFlags = true ;

							if( t_bLockout )
							{
								t_pUserInfo2->usri2_flags |= UF_LOCKOUT ;
							}
							else
							{
								t_pUserInfo2->usri2_flags &= ~UF_LOCKOUT ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Password changable?
				if( !a_rInst.IsNull( IDS_PasswordChangeable ) )
				{
					bool t_bPwChangable = false ;
					if( a_rInst.Getbool( IDS_PasswordChangeable, t_bPwChangable ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_PASSWD_CANT_CHANGE ? false : true ;

						if( t_bCurrentSetting != t_bPwChangable )
						{
							t_bSetFlags = true ;

							if( t_bPwChangable )
							{
								t_pUserInfo2->usri2_flags &= ~UF_PASSWD_CANT_CHANGE ;
							}
							else
							{
								t_pUserInfo2->usri2_flags |= UF_PASSWD_CANT_CHANGE ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Password expires?
				if( !a_rInst.IsNull( IDS_PasswordExpires ) )
				{
					bool t_bPwExpires = false ;
					if( a_rInst.Getbool( IDS_PasswordExpires, t_bPwExpires ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_DONT_EXPIRE_PASSWD ? false : true ;

						if( t_bCurrentSetting != t_bPwExpires )
						{
							t_bSetFlags = true ;

							if( t_bPwExpires )
							{
								t_pUserInfo2->usri2_flags &= ~UF_DONT_EXPIRE_PASSWD ;
							}
							else
							{
								t_pUserInfo2->usri2_flags |= UF_DONT_EXPIRE_PASSWD ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Password required?
				if( !a_rInst.IsNull( IDS_PasswordRequired ) )
				{
					bool t_bPwRequired = false ;
					if( a_rInst.Getbool( IDS_PasswordRequired, t_bPwRequired ) )
					{
						bool t_bCurrentSetting = t_pUserInfo2->usri2_flags & UF_PASSWD_NOTREQD ? false : true ;

						if( t_bCurrentSetting != t_bPwRequired )
						{
							t_bSetFlags = true ;

							if( t_bPwRequired )
							{
								t_pUserInfo2->usri2_flags &= ~UF_PASSWD_NOTREQD ;
							}
							else
							{
								t_pUserInfo2->usri2_flags |= UF_PASSWD_NOTREQD ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// flags update...
				if( t_bSetFlags )
				{
					DWORD t_ParmError = 0 ;
					USER_INFO_1008 t_UserInfo_1008 ;

					t_UserInfo_1008.usri1008_flags = t_pUserInfo2->usri2_flags ;

					t_Status = t_NetAPI.NetUserSetInfo(
												(LPCWSTR)t_chsDomainName,
												(LPCWSTR)t_chsUserName,
												1008,
												(LPBYTE) &t_UserInfo_1008,
												&t_ParmError
												) ;

					if( NERR_Success != t_Status )
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}

				// Full Name
				if( !a_rInst.IsNull( IDS_FullName ) )
				{
					CHString t_chsFullName ;

					if( a_rInst.GetCHString( IDS_FullName, t_chsFullName ) )
					{
						if( t_chsFullName != t_pUserInfo2->usri2_full_name )
						{
							DWORD t_ParmError = 0 ;
							USER_INFO_1011 t_UserInfo_1101 ;

							t_UserInfo_1101.usri1011_full_name = (LPWSTR)(LPCWSTR)t_chsFullName ;

							t_Status = t_NetAPI.NetUserSetInfo(
														(LPCWSTR)t_chsDomainName,
														(LPCWSTR)t_chsUserName,
														1011,
														(LPBYTE) &t_UserInfo_1101,
														&t_ParmError
														) ;

							if( NERR_Success != t_Status )
							{
								t_hResult = WBEM_E_FAILED ;
							}
						}
					}
					else
					{
						t_hResult = WBEM_E_FAILED ;
					}
				}
			}
			else if( NERR_UserNotFound == t_Status ||
					 NERR_InvalidComputer == t_Status  )
			{
				t_hResult = WBEM_E_NOT_FOUND ;
			}
			else
			{
				t_hResult = WBEM_E_FAILED ;
			}
		}
		catch( ... )
		{
			t_NetAPI.NetApiBufferFree( t_pUserInfo2 ) ;
			throw ;
		}

		t_NetAPI.NetApiBufferFree( t_pUserInfo2 ) ;
		t_pUserInfo2 = NULL ;
	}

	return t_hResult;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY

HRESULT CWin32UserAccount::ExecMethod(

const CInstance &a_rInst,
const BSTR a_MethodName,
CInstance *a_pInParams,
CInstance *a_pOutParams,
long a_Flags )
{
	if ( !a_pOutParams )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Method recognized?
	if( !_wcsicmp ( a_MethodName, METHOD_NAME_RenameAccount ) )
	{
		return hRenameAccount( (CInstance*)&a_rInst, a_pInParams, a_pOutParams, a_Flags ) ;
	}

	return WBEM_E_INVALID_METHOD ;
}

#endif

/*******************************************************************
    NAME:       hRenameAccount

    SYNOPSIS:   Sets a new account name for this instance.
				A method is required here since we are changing the key
				on the instance.

    ENTRY:      const CInstance &a_rInst,
				CInstance *a_pInParams,
				CInstance *a_pOutParams,
				long a_Flags	:

	NOTES:		This is a non static, instance dependent method call

    HISTORY:
********************************************************************/
#ifdef NTONLY

HRESULT CWin32UserAccount::hRenameAccount(

CInstance *a_pInst,
CInstance *a_pInParams,
CInstance *a_pOutParams,
long a_Flags )
{
	E_MethodResult	t_eResult = e_InstanceNotFound ;
	CHString		t_chsUserName ;
	CHString		t_chsDomainName ;
	CHString		t_chsNewUserName ;

	if( !a_pOutParams )
	{
		return WBEM_E_FAILED ;
	}

	if( !a_pInParams )
	{
		a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, e_InternalError ) ;
		return S_OK ;
	}

	// nonstatic method requires an instance
	if( !a_pInst )
	{
		a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, e_NoInstance ) ;
		return S_OK ;
	}

	// keys
	if( !a_pInst->IsNull( IDS_Name ) && !a_pInst->IsNull( IDS_Domain ) )
	{
		// Name
		if( a_pInst->GetCHString( IDS_Name , t_chsUserName ) )
		{
			// Domain
			if( a_pInst->GetCHString( IDS_Domain, t_chsDomainName ) )
			{
				// New user name
				if( !a_pInParams->IsNull( IDS_Name ) &&
					a_pInParams->GetCHString( IDS_Name, t_chsNewUserName ) )
				{
					t_eResult = e_Success ;
				}
				else
				{
					t_eResult = e_InvalidParameter ;
				}
			}
		}
	}

	// proceed with the update...
	if( e_Success == t_eResult )
	{
		if( t_chsNewUserName != t_chsUserName )
		{
			CNetAPI32	t_NetAPI;

			if ( ERROR_SUCCESS == t_NetAPI.Init () )
			{
				DWORD t_ParmError = 0 ;
				USER_INFO_0 t_UserInfo_0 ;

				t_UserInfo_0.usri0_name  = (LPWSTR)(LPCWSTR)t_chsNewUserName ;

				NET_API_STATUS t_Status = t_NetAPI.NetUserSetInfo(
																	(LPCWSTR)t_chsDomainName,
																	(LPCWSTR)t_chsUserName,
																	0,
																	(LPBYTE) &t_UserInfo_0,
																	&t_ParmError ) ;
				switch( t_Status )
				{
					case NERR_Success:			t_eResult = e_Success ;			break ;
					case NERR_UserNotFound:		t_eResult = e_UserNotFound ;	break ;
					case NERR_InvalidComputer:	t_eResult = e_InvalidComputer ;	break ;
					case NERR_NotPrimary:		t_eResult = e_NotPrimary ;		break ;
					case NERR_LastAdmin:		t_eResult = e_LastAdmin ;		break ;
					case NERR_SpeGroupOp:		t_eResult = e_SpeGroupOp ;		break ;
					default:					t_eResult = e_ApiError;			break ;
				}
			}
		}
	}

	a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, t_eResult ) ;
	return S_OK ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32UserAccount::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known users (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32UserAccount::AddDynamicInstances( MethodContext *a_pMethodContext )
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR;
    CNetAPI32 t_NetAPI ;

    // Get NETAPI32.DLL entry points
    //==============================

	if( t_NetAPI.Init() == ERROR_SUCCESS )
	{
		// Get all the domains related to this one (plus this one)
		std::vector<_bstr_t> t_vectorTrustList ;
		t_NetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;

		// For each domain, get the users
		LONG t_lTrustListSize = t_vectorTrustList.size() ;
		for (int t_x = 0; t_x < t_lTrustListSize && SUCCEEDED ( t_hResult ) ; t_x++ )
		{
			//Just because we are denied on one domain doesn't mean we will be on others,
			//so ignore return value of GetDomainUsersNTW.
			t_hResult = GetDomainUsersNTW( t_NetAPI, (WCHAR*) t_vectorTrustList[t_x], a_pMethodContext ) ;
#if DBG
			if ( FAILED ( t_hResult ) )
			{
				OutputDebugString ( L"\nGetDomainUsersNTW Failed" ) ;
			}
#endif
		}
	}
    return t_hResult;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceNT
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CWin32UserAccount::RefreshInstance( CInstance *a_pInst )
{
    HMODULE		t_hNetApi32 = NULL ;
    BOOL		t_bRetCode = FALSE ;
    CNetAPI32	t_NetAPI ;
    CHString	t_sDomain ;

    // Get NETAPI32.DLL entry points
    //==============================

    if( t_NetAPI.Init() == ERROR_SUCCESS )
	 {
		CHStringArray t_strarrayTrustedDomains ;

      // Get all the domains related to this one (plus this one)
      CHStringArray t_achsTrustList;
      t_NetAPI.GetTrustedDomainsNT( t_achsTrustList ) ;

      a_pInst->GetCHString( IDS_Domain, t_sDomain ) ;

      // If the domain we want is in the list we support, try to get the instance.
      for (int t_x = 0; t_x < t_achsTrustList.GetSize(); t_x++ )
	  {
         if ( t_achsTrustList[t_x].CompareNoCase( t_sDomain ) == 0 )
		 {
   		   t_bRetCode = GetSingleUserNTW( t_NetAPI, a_pInst ) ;
         }
      }
    }

    return t_bRetCode ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : LoadUserValuesNT
 *
 *  DESCRIPTION : Loads property values according to passed user name
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : zip
 *
 *  COMMENTS    : While it would make more sense to pass the structure containing
 *                the data, I can't.  Enum and GetObject end up with different
 *                structs.
 *
 *****************************************************************************/

#ifdef NTONLY
void CWin32UserAccount::LoadUserValuesNT(
										 CHString	a_strDomainName,
										 CHString	a_strUserName,
										 WCHAR		*a_pwszFullName,
										 WCHAR		*a_pwszDescription,
										 DWORD		a_dwFlags,
                                         WCHAR      *a_pwszComputerName,
										 CInstance	*a_pInst )
{
   // Assign NT properties -- string values are unassigned if
   // NULL or empty
   //========================================================

	// We've established it's a valid user, so we should be able to get the Sid.
   GetSIDInformation( a_strDomainName, a_strUserName, a_pwszComputerName, a_pInst );

   a_pInst->SetCHString( IDS_Caption, a_strDomainName + _T('\\') + a_strUserName );
   a_pInst->SetCHString( IDS_FullName, a_pwszFullName ) ;
   a_pInst->SetCHString( IDS_Description, a_pwszDescription ) ;

   a_pInst->Setbool( IDS_Disabled, a_dwFlags & UF_ACCOUNTDISABLE ) ;
   a_pInst->Setbool( IDS_PasswordRequired, !( a_dwFlags & UF_PASSWD_NOTREQD ) ) ;
   a_pInst->Setbool( IDS_PasswordChangeable, !( a_dwFlags & UF_PASSWD_CANT_CHANGE ) ) ;
   a_pInst->Setbool( IDS_Lockout, a_dwFlags & UF_LOCKOUT ) ;
   a_pInst->Setbool( IDS_PasswordExpires, !( a_dwFlags & UF_DONT_EXPIRE_PASSWD ) ) ;

   a_pInst->SetDWORD( IDS_AccountType, a_dwFlags & UF_ACCOUNT_TYPE_MASK ) ;

   if ( ( a_dwFlags & UF_ACCOUNTDISABLE) || ( a_dwFlags & UF_LOCKOUT ) )
   {
      a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_Degraded ) ;
   }
   else
   {
      a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_OK ) ;
   }

   return ;
}
#endif

#ifdef NTONLY
void CWin32UserAccount::LoadUserValuesNTW(LPCWSTR a_wstrDomainName,
                                          LPCWSTR a_wstrUserName,
                                          LPCWSTR a_wstrFullName,
                                          LPCWSTR a_wstrDescription,
                                          DWORD a_dwFlags,
                                          WCHAR *a_pwszComputerName,
                                          CInstance* a_pInst )
{
   // Assign NT properties -- string values are unassigned if
   // NULL or empty
   //========================================================
	// We've established it's a valid user, so we should be able to get the Sid.
	GetSIDInformationW( a_wstrDomainName, a_wstrUserName, a_pwszComputerName, a_pInst );

	_bstr_t t_bstrtCaption( a_wstrDomainName ) ;
	t_bstrtCaption += L"\\" ;
	t_bstrtCaption += a_wstrUserName ;

	a_pInst->SetWCHARSplat( IDS_Caption, (WCHAR*) t_bstrtCaption ) ;
	a_pInst->SetWCHARSplat( IDS_FullName, a_wstrFullName ) ;
	a_pInst->SetWCHARSplat( IDS_Description, a_wstrDescription ) ;

	a_pInst->Setbool( IDS_Disabled, a_dwFlags & UF_ACCOUNTDISABLE ) ;
	a_pInst->Setbool( IDS_PasswordRequired, !( a_dwFlags & UF_PASSWD_NOTREQD ) ) ;
	a_pInst->Setbool( IDS_PasswordChangeable, !( a_dwFlags & UF_PASSWD_CANT_CHANGE ) ) ;
	a_pInst->Setbool( IDS_Lockout, a_dwFlags & UF_LOCKOUT ) ;
	a_pInst->Setbool( IDS_PasswordExpires, !( a_dwFlags & UF_DONT_EXPIRE_PASSWD ) ) ;

	a_pInst->SetDWORD( IDS_AccountType, a_dwFlags & UF_ACCOUNT_TYPE_MASK ) ;

	if ( ( a_dwFlags & UF_ACCOUNTDISABLE ) || ( a_dwFlags & UF_LOCKOUT ) )
	{
		a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_Degraded ) ;
	}
	else
	{
		a_pInst->SetCharSplat( IDS_Status, IDS_STATUS_OK ) ;
	}
	return ;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetDomainUsersNT
//
//	Obtains User Names for all users in the specified domain.  If no
//	domain is specified, then we assume the local machine.
//
//	Inputs:		CNetAPI32		netapi - network api functions.
//				LPCTSTR			pszDomain - Domain to retrieve users from.
//				MethodContext*	pMethodContext - Method Context
//
//	Outputs:	None.
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:	No special access is necessary here, although there are
//				a couple of methods we can implement, once we have the
//				name of the domain controller that we need to use to
//				get the user names from.  First, we can use NetQueryDisplay
//				Information() to get the names, but this may necessitate
//				hitting the DC a few times.  We can also use NetUserEnum
//				with a level of 0, which requires no special access, but
//				will use two queries, one to find out how many users and
//				another to get them all.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
//BOOL CWin32UserAccount::GetDomainUsersNT( CNetAPI32& netapi, LPCTSTR pszDomain, MethodContext* pMethodContext )
//{
//    BOOL		fReturn = FALSE,
//        fGotDC	= TRUE;
//    bool bCancelled = false;
//    LPWSTR		pwcsDCName = NULL;
//    CHString	strComputerName, strDomainName( pszDomain );
//
//    // When the computer name is the same as the domain name, that's the local accounts
//    strComputerName = GetLocalComputerName();
//    if (lstrcmp(strComputerName, pszDomain) != 0)
//    {
//        fGotDC = GetDomainControllerNameNT( netapi, pszDomain, &pwcsDCName );
//    }
//
//    if ( fGotDC )
//    {
//        NET_DISPLAY_USER *pUserData = NULL;
//        DWORD			dwNumReturnedEntries = 0,
//            dwIndex = 0;
//        NET_API_STATUS	stat;
//        CHString		strUserName;
//        CInstance *pInstance = NULL;
//
//        do {
//            // Accept 16384 entries back as a maximum, and up to 256k worth of data.
//
//            stat = netapi.NetQueryDisplayInformation( pwcsDCName, 1, dwIndex, 16384, 262144, &dwNumReturnedEntries, (PVOID*) &pUserData );
//
//            if ( ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat )
//            {
//                fReturn = TRUE;
//
//                // Walk through the returned entries
//                for ( DWORD	dwCtr = 0; (dwCtr < dwNumReturnedEntries) && (!bCancelled); dwCtr++ )
//                {
//                    // Create an instance for each
//                    pInstance = CreateNewInstance( pMethodContext );
//
//                    if ( NULL != pInstance )
//                    {
//                        // Save the data
//                        pInstance->SetCHString( IDS_Domain, strDomainName );
//                        //pInstance->SetCHString( IDS_Name, pUserData[dwCtr].usri1_name );
//                        pInstance->SetWCHARSplat( IDS_Name, (WCHAR*)_bstr_t(pUserData[dwCtr].usri1_name) );
//
//                        // NT5 works correctly
//                        if (IsWinNT5())
//                        {
//                            LoadUserValuesNT(strDomainName, pUserData[dwCtr].usri1_name, pUserData[dwCtr].usri1_full_name, pUserData[dwCtr].usri1_comment, pUserData[dwCtr].usri1_flags, pInstance);
//                            bCancelled = FAILED(Commit( pInstance ));
//                        }
//                        else
//                        {
//                            // Major yuck alert!  NetQueryDisplayInformation doesn't return the correct
//                            // values for the flags.  As a result, to get the correct information, we need to
//                            // make a SECOND call to get the data.
//                            if (GetSingleUserNT(netapi, pInstance)) {
//                                LoadUserValuesNT(strDomainName, pUserData[dwCtr].usri1_name, pUserData[dwCtr].usri1_full_name, pUserData[dwCtr].usri1_comment, pUserData[dwCtr].usri1_flags, pInstance);
//                                bCancelled = FAILED(Commit( pInstance ));
//                            } else {
//                                pInstance->elease();
//                            }
//                        }
//                    }
//
//                }
//
//                // The index for continuing the search is stored in the last entry
//                if ( dwNumReturnedEntries != 0 ) {
//                    dwIndex = pUserData[dwCtr-1].usri1_next_index;
//                }
//
//                netapi.NetApiBufferFree( pUserData );
//
//            }	// IF stat OK
//
//        } while ( (ERROR_MORE_DATA == stat) && (!bCancelled) );
//
//        // Clean up the domain controller name if we got one.
//        if ( NULL != pwcsDCName ) {
//            netapi.NetApiBufferFree( pwcsDCName );
//        }
//
//    }	// IF fGotDC
//
//    if (bCancelled)
//        fReturn = FALSE;
//
//    return fReturn;
//}
#endif

// Same function as above, but ALWAYS takes wstrDomain as a LPCWSTR (whether _UNICODE defined or not).
// Uses wides throughout the function body as well.
#ifdef NTONLY
HRESULT CWin32UserAccount::GetDomainUsersNTW(
										  CNetAPI32 &a_netapi,
										  LPCWSTR a_wstrDomain,
										  MethodContext *a_pMethodContext )
{
    HRESULT		t_hReturn		= WBEM_S_NO_ERROR ;
	BOOL		t_fGotDC		= TRUE;
	CHString	t_chstrDCName;
	USER_INFO_2 *t_pUserData    = NULL;
	CInstancePtr t_pInst;

	WCHAR t_wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH + 1 ] ;
    DWORD t_dwNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;

    ZeroMemory( t_wstrLocalComputerName, sizeof( t_wstrLocalComputerName ) ) ;

	try
	{
		if(!ProviderGetComputerName( t_wstrLocalComputerName, &t_dwNameSize ) )
		{
#ifdef DBG		
			OutputDebugString ( L"\nProviderGetComputerName Failed" ) ;
#endif
			return WBEM_E_CRITICAL_ERROR ;
		}

		// When the computer name is the same as the domain name, that's the local accounts
		if ( wcscmp( t_wstrLocalComputerName, a_wstrDomain ) != 0 )
		{
 			t_fGotDC = (a_netapi.GetDCName( a_wstrDomain, t_chstrDCName ) == ERROR_SUCCESS) ;
		}

		if ( t_fGotDC )
		{
			DWORD			t_dwNumReturnedEntries = 0,
							t_dwIndex = 0,
                            t_dwTotalEntries,
                            t_dwResumeHandle = 0;
			NET_API_STATUS	t_stat;

			do {
				// Accept up to 256K worth of data.
                t_stat =
                    // We used to use NetQueryDisplayInformation here, but it has a bug
                    // where it doesn't return the flags.
                    a_netapi.NetUserEnum(
                        t_chstrDCName,
                        2,
                        FILTER_NORMAL_ACCOUNT,
                        (LPBYTE*) &t_pUserData,
                        262144,
                        &t_dwNumReturnedEntries,
                        &t_dwTotalEntries,
                        &t_dwResumeHandle);

				if ( ERROR_SUCCESS == t_stat || ERROR_MORE_DATA == t_stat )
				{
					t_hReturn = WBEM_S_NO_ERROR ;

					// Walk through the returned entries
					for ( DWORD	t_dwCtr = 0; ( t_dwCtr < t_dwNumReturnedEntries) &&
											 ( SUCCEEDED( t_hReturn) ); t_dwCtr++ )
					{
						// Create an instance for each
                        t_pInst.Attach(CreateNewInstance( a_pMethodContext ));

						// Save the data
						t_pInst->SetWCHARSplat( IDS_Domain, a_wstrDomain );

						t_pInst->SetWCHARSplat( IDS_Name, t_pUserData[t_dwCtr].usri2_name  );

                        if(_wcsicmp(t_wstrLocalComputerName, a_wstrDomain) == 0)
                        {
                            t_pInst->Setbool(IDS_LocalAccount, true);
                        }
                        else
                        {
                            t_pInst->Setbool(IDS_LocalAccount, false);
                        }

						LoadUserValuesNT(
                            a_wstrDomain,
							t_pUserData[ t_dwCtr ].usri2_name,
							t_pUserData[ t_dwCtr ].usri2_full_name,
							t_pUserData[ t_dwCtr ].usri2_comment,
							t_pUserData[ t_dwCtr ].usri2_flags,
                            _bstr_t((LPCWSTR)t_chstrDCName),
							t_pInst ) ;

					 	bool t_bCancelled = FAILED(t_hReturn = t_pInst->Commit(  ) ) ;					 	
						if ( t_bCancelled ) 
						{
#if DBG						
							wchar_t t_Buffer [ 64 ];
							wsprintf ( t_Buffer , L"\nCommit Failed with %lx" , t_hReturn ) ;
							OutputDebugString ( t_Buffer ) ;
#endif							
						}

 					}
				}	// IF stat OK
				else
				{
#if DBG
					wchar_t t_Buffer [ 64 ];
					wsprintf ( t_Buffer , L"\nOther Error %lx" , t_stat ) ;
					OutputDebugString ( t_Buffer ) ;
#endif

					break ;
				}

			} while ( (ERROR_MORE_DATA == t_stat) && ( SUCCEEDED (t_hReturn) ) ) ;


		}	// IF fGotDC
		else
		{
#if DBG
			OutputDebugString ( L"\nGet DC failed" ) ;
#endif
		}
	}
	catch( ... )
	{
		if( t_pUserData )
		{
			a_netapi.NetApiBufferFree( t_pUserData ) ;
		}

		throw ;
	}

	// Clean up the domain controller name if we got one.
	if( t_pUserData )
	{
		a_netapi.NetApiBufferFree( t_pUserData ) ;
	}

	return t_hReturn ;

}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetSingleUserNT
//
//	Obtains the user name from the specified domain (which can be the
//	local workstation)
//
//	Inputs:		CNetAPI32		netapi - network api functions.
//				CInstance*		pInstance - Instance to get.
//
//	Outputs:	None.
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:	No special access is necessary here.  We just need to make sure
//				we are able to get the appropriate domain controller.
//
/////////////////////////////////////////////////////////////////////////////

/*
#ifdef NTONLY
BOOL CWin32UserAccount::GetSingleUserNT( CNetAPI32 &a_netapi, CInstance *a_pInst )
{
	BOOL		t_fReturn		= FALSE ,
				t_fGotDC		= TRUE ;
	LPWSTR		t_pwcsDCName	= NULL ;
	CHString	t_strDomainName ;
    WCHAR*      t_wstrUserName	= NULL;
	USER_INFO_2 *t_pUserInfo	= NULL;
	CHString	t_strComputerName ;

	try
	{
		a_pInst->GetCHString( IDS_Domain, t_strDomainName ) ;
		a_pInst->GetWCHAR( IDS_Name, &t_wstrUserName ) ;

		if( t_wstrUserName == NULL )
		{
			return FALSE;
		}

		t_strComputerName = GetLocalComputerName() ;

		if ( 0 != t_strDomainName.CompareNoCase( t_strComputerName ) )
		{
			t_fGotDC = GetDomainControllerNameNT( a_netapi, t_strDomainName, &t_pwcsDCName ) ;
		}

		if ( t_fGotDC )
		{
			bstr_t t_bstrUserName( t_wstrUserName ) ;

			if ( ERROR_SUCCESS == a_netapi.NetUserGetInfo(	t_pwcsDCName,
															t_bstrUserName,
															2,
															(LPBYTE*) &t_pUserInfo ) )
			{

				t_fReturn = TRUE;
				LoadUserValuesNT(	t_strDomainName,
									t_wstrUserName,
									t_pUserInfo->usri2_full_name,
									t_pUserInfo->usri2_comment,
									t_pUserInfo->usri2_flags,
									a_pInst ) ;

				a_netapi.NetApiBufferFree( t_pUserInfo ) ;
				t_pUserInfo = NULL ;

			}

			// Clean up the domain controller name if we got one.
			if ( NULL != t_pwcsDCName )
			{
				a_netapi.NetApiBufferFree( t_pwcsDCName ) ;
				t_pwcsDCName = NULL ;
			}

		}

		free( t_wstrUserName ) ;
		t_wstrUserName = NULL ;

		return t_fReturn;

	}
	catch( ... )
	{
		if( t_pUserInfo )
		{
			a_netapi.NetApiBufferFree( t_pUserInfo ) ;
		}

		if( t_pwcsDCName )
		{
			a_netapi.NetApiBufferFree( t_pwcsDCName ) ;
		}

		if( t_wstrUserName )
		{
			free( t_wstrUserName ) ;
		}

		throw ;
	}
}
#endif
*/

#ifdef NTONLY
BOOL CWin32UserAccount::GetSingleUserNTW( CNetAPI32& a_netapi, CInstance* a_pInst )
{
	BOOL	t_fReturn			= FALSE,
			t_fGotDC			= TRUE;
	CHString t_chstrDCName;
    WCHAR*	t_wstrDomainName	= NULL;
    WCHAR*	t_wstrUserName		= NULL;
	USER_INFO_2 *t_pUserInfo	= NULL;

    WCHAR t_wstrLocalComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD t_dwNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;

	try
	{
		ZeroMemory( t_wstrLocalComputerName, sizeof( t_wstrLocalComputerName ) ) ;

		if(!ProviderGetComputerName( t_wstrLocalComputerName, &t_dwNameSize ) )
		{
			return FALSE;
		}

		a_pInst->GetWCHAR( IDS_Domain, &t_wstrDomainName );

		if( t_wstrDomainName == NULL )
		{
			return FALSE;
		}

        if(_wcsicmp(t_wstrLocalComputerName, t_wstrDomainName) == 0)
        {
            a_pInst->Setbool(IDS_LocalAccount, true);
        }
        else
        {
            a_pInst->Setbool(IDS_LocalAccount, false);
        }

		a_pInst->GetWCHAR( IDS_Name, &t_wstrUserName ) ;

		if( t_wstrUserName == NULL )
		{
			free ( t_wstrDomainName ) ;
			t_wstrDomainName = NULL ;
			return FALSE;
		}

 		if ( 0 != _wcsicmp( t_wstrLocalComputerName, t_wstrDomainName ) )
		{
			t_fGotDC = (a_netapi.GetDCName( t_wstrDomainName, t_chstrDCName ) == ERROR_SUCCESS) ;
		}

		if ( t_fGotDC )
		{
			_bstr_t t_bstrtUserName( t_wstrUserName ) ;

			DWORD t_dwError = a_netapi.NetUserGetInfo(	t_chstrDCName,
														(WCHAR*) t_bstrtUserName,
														2,
														(LPBYTE*) &t_pUserInfo ) ;
			if ( ERROR_SUCCESS == t_dwError )
			{

				t_fReturn = TRUE;
				LoadUserValuesNTW(	t_wstrDomainName,
									t_wstrUserName,
									t_pUserInfo->usri2_full_name,
									t_pUserInfo->usri2_comment,
									t_pUserInfo->usri2_flags,
                                    _bstr_t((LPCWSTR)t_chstrDCName),
									a_pInst ) ;

//				a_netapi.NetApiBufferFree( t_pUserInfo ) ;
//				t_pUserInfo = NULL ;
			}

		}
	}
	catch( ... )
	{
        if( t_pUserInfo )
		{
			a_netapi.NetApiBufferFree( t_pUserInfo ) ;
		}

		if( t_wstrUserName )
		{
			free( t_wstrUserName ) ;
		}

		if( t_wstrDomainName )
		{
			free( t_wstrDomainName ) ;
		}

		throw ;
	}

    if( t_pUserInfo )
	{
		a_netapi.NetApiBufferFree( t_pUserInfo ) ;
	}

	free( t_wstrUserName ) ;
	t_wstrUserName = NULL ;

	free( t_wstrDomainName ) ;
	t_wstrDomainName = NULL ;

	return t_fReturn;

}
#endif


/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetSIDInformation
//
//	Obtains the SID Information for the user.
//
//	Inputs:		CHString&		strDomainName - Domain Name.
//				CHString&		strAccountName - Account Name
//				CHString&		strComputerName - Computer Name
//				CInstance*		pInstance - Instance to put values in.
//
//	Outputs:	None.
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:	Call for valid users to get SID data.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CWin32UserAccount::GetSIDInformation(
											const CHString &a_strDomainName,
											const CHString &a_strAccountName,
											const CHString &a_strComputerName,
											CInstance *a_pInst
											)
{
	BOOL t_fReturn = FALSE;


	LPCTSTR	t_pszDomain = (LPCTSTR) a_strDomainName;

  	// Make sure we got the SID and it's all okey dokey
	CSid t_sid( t_pszDomain, a_strAccountName, a_strComputerName ) ;

	if ( t_sid.IsValid() && t_sid.IsOK() )
	{
		a_pInst->SetCHString( IDS_SID, t_sid.GetSidString() ) ;
		a_pInst->SetByte( IDS_SIDType, t_sid.GetAccountType() ) ;

		t_fReturn = TRUE ;
	}

	return t_fReturn;

}
#endif

#ifdef NTONLY
BOOL CWin32UserAccount::GetSIDInformationW(
										   LPCWSTR a_wstrDomainName,
                                           LPCWSTR a_wstrAccountName,
                                           LPCWSTR a_wstrComputerName,
                                           CInstance *a_pInst )
{
	BOOL t_fReturn = FALSE;

	// Make sure we got the SID and it's all okey dokey
	CSid t_sid( a_wstrDomainName, a_wstrAccountName, a_wstrComputerName ) ;

	if ( t_sid.IsValid() && t_sid.IsOK() )
	{
		a_pInst->SetWCHARSplat( IDS_SID, t_sid.GetSidStringW() ) ;
		a_pInst->SetByte( IDS_SIDType, t_sid.GetAccountType() ) ;

		t_fReturn = TRUE ;
	}
	return t_fReturn;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\videocontroller.h ===
//=================================================================

//

// VideoController.h -- CWin32VideoController property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/05/98    sotteson         Created
//
//=================================================================
#ifndef _VIDEOCONTROLLER_H
#define _VIDEOCONTROLLER_H

class CMultiMonitor;

class CWin32VideoController : public Provider
{
	protected:
	
		void SetProperties( CInstance *a_pInstance, CMultiMonitor *a_pMon, int a_iWhich ) ;
		BOOL AssignDriverValues( LPCWSTR a_szDriver, CInstance *pInstance ) ;

	#ifdef NTONLY
		void GetFileExtensionIfNotAlreadyThere(CHString* pchsInstalledDriverFiles);
		void GetFileExtension(CHString& pchsFindfileExtension, CHString* pstrFindFile);
		void SetDCProperties( CInstance *a_pInstance, LPCTSTR a_szDeviceName, int a_iWhich ) ;
	    void SetServiceProperties(
            CInstance *a_pInstance, 
            LPCWSTR a_szService,
            LPCWSTR a_szSettingsKey);
    #endif
	public:
	
		// Constructor/destructor
		//=======================
		CWin32VideoController( const CHString& a_szName, LPCWSTR a_szNamespacev) ;
		~CWin32VideoController();

		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0 ) ;
		virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0 ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\videocontroller.cpp ===
//=================================================================

//

// VideoController.CPP

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//				 03/02/99    a-peterc		  added graceful exit on SEH and memory failures
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "sid.h"
#include "implogonuser.h"
#include "VideoController.h"
#include <ProvExce.h>
#include "multimonitor.h"
#include "resource.h"

// Property set declaration
//=========================

CWin32VideoController startupCommand(
	L"Win32_VideoController",
	IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoController::CWin32VideoController
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32VideoController::CWin32VideoController(const CHString& szName,
	LPCWSTR szNamespace) : Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoController::~CWin32VideoController
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32VideoController::~CWin32VideoController()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoController::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32VideoController::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags /*= 0L*/)
{
	HRESULT       hResult = WBEM_S_NO_ERROR;
	CInstancePtr  pInst;
    CMultiMonitor monitor;

	for (int i = 0; i < monitor.GetNumAdapters() && SUCCEEDED(hResult); i++)
	{
		CHString strDeviceID,
				 strDeviceName;

        pInst.Attach(CreateNewInstance(pMethodContext));

		// Set the device ID.
		strDeviceID.Format(L"VideoController%d", i + 1);
		pInst->SetCharSplat(L"DeviceID", strDeviceID);

		SetProperties(pInst, &monitor, i);
		hResult = pInst->Commit();
	}

	return hResult;
}

#ifdef NTONLY
void CWin32VideoController::SetServiceProperties(
    CInstance *pInst,
    LPCWSTR szService,
    LPCWSTR szSettingsKey)
{
 	CRegistry reg;
    CHString  strFileName,
              strVersion;
	DWORD     dwTemp;
    WCHAR     wszTemp[256];

    // Get the version by getting the service name and getting its
	// version information.
	if (!GetServiceFileName(szService, strFileName) ||
        strFileName.IsEmpty())
    {
        WCHAR szSystem[MAX_PATH * 2];

        GetSystemDirectoryW(szSystem, sizeof(szSystem) / sizeof(WCHAR));
        strFileName.Format(
            L"%s\\drivers\\%s.sys",
            szSystem,
            szService);
    }

	if (GetVersionFromFileName(strFileName, strVersion))
   	    pInst->SetCHString(IDS_DriverVersion, strVersion);

    CHString strDate = GetDateTimeViaFilenameFiletime(
                           TOBSTRT(strFileName),
                           FT_MODIFIED_DATE);

    if (!strDate.IsEmpty())
    {
        pInst->SetCharSplat(L"DriverDate", strDate);
    }

    DWORD dwRegSize;

	// Do the setttings property stuff.
	if (reg.Open(
		HKEY_LOCAL_MACHINE,
		szSettingsKey,
		KEY_READ) == ERROR_SUCCESS)
	{
    	CHString strDrivers;

		// This is a REG_MULTI_SZ, so replace all '\n' with ','.
		if (reg.GetCurrentKeyValue(
			L"InstalledDisplayDrivers",
			strDrivers) == ERROR_SUCCESS)
		{
			int iWhere,
				iLen = strDrivers.GetLength();

			// Replace all '\n' with ','.
			while ((iWhere = strDrivers.Find(L'\n')) != -1)
			{
				// If the last char is a '\n', make it a '\0'.
				strDrivers.SetAt(iWhere, iWhere == iLen - 1 ? 0 : L',');
			}
			GetFileExtensionIfNotAlreadyThere(&strDrivers);
		}

		if (!strDrivers.IsEmpty())
		{
			pInst->SetCHString(IDS_InstalledDisplayDrivers, strDrivers);
		}

        dwRegSize = 4;

		if (reg.GetCurrentBinaryKeyValue(
			L"HardwareInformation.MemorySize",
			(LPBYTE) &dwTemp, &dwRegSize) == ERROR_SUCCESS)
		{
			pInst->SetDWORD(IDS_AdapterRAM, dwTemp);
		}

		// Get the device description.  This might have already been done by
        // the cfg mgr properties, in which case we can skip the extra work.
		if (pInst->IsNull(IDS_Description))
        {
		    CHString    strDescription;
		    DWORD       dwType,
					    dwSize;

		    // First we have to find what type this field is.  On NT4 it's
		    // REG_SZ, on NT5 it's REG_BINARY.
		    if (RegQueryValueEx(
			    reg.GethKey(),
			    _T("Device Description"),
			    NULL,
			    &dwType,
			    NULL,
			    &dwSize) == ERROR_SUCCESS)
		    {
			    if (dwType == REG_SZ)
			    {
				    reg.GetCurrentKeyValue(
					    _T("Device Description"),
					    strDescription);
			    }
			    else if (dwType == REG_BINARY)
			    {
                    dwRegSize = sizeof(wszTemp);
				    reg.GetCurrentBinaryKeyValue(
					    _T("Device Description"),
					    (BYTE *) wszTemp, &dwRegSize);

				    strDescription = wszTemp;
			    }
		    }

		    if (strDescription.IsEmpty())
		    {
			    // If Device Description didn't work, try AdapterString.
                dwRegSize = sizeof(wszTemp);

			    if (reg.GetCurrentBinaryKeyValue(
				    _T("HardwareInformation.AdapterString"),
				    (BYTE *) wszTemp, &dwRegSize) == ERROR_SUCCESS)
			    {
				    strDescription = wszTemp;
			    }
		    }

            pInst->SetCHString(IDS_Description, strDescription);
		    pInst->SetCHString(IDS_Caption, strDescription);
		    pInst->SetCHString(IDS_Name, strDescription);
        }

        dwRegSize = sizeof(wszTemp);
		if (reg.GetCurrentBinaryKeyValue(
			_T("HardwareInformation.ChipType"),
			(BYTE *) wszTemp, &dwRegSize) == ERROR_SUCCESS)
		{
			pInst->SetCHString(_T("VideoProcessor"), wszTemp);
		}

        dwRegSize = sizeof(wszTemp);
		if (reg.GetCurrentBinaryKeyValue(
			_T("HardwareInformation.DACType"),
			(BYTE *) wszTemp, &dwRegSize) == ERROR_SUCCESS)
		{
			pInst->SetCHString(IDS_AdapterDACType, wszTemp);
		}
	}
}
#endif

#ifdef NTONLY
void CWin32VideoController::GetFileExtensionIfNotAlreadyThere(CHString* pchsInstalledDriverFiles)
{
	CHString strFindFile;
	CHString strInstalledAllDriverFiles, strTemp;
	CHString* pstrInstalledDriverFiles = pchsInstalledDriverFiles;
	int iWhere,
		iFirst = 0;

    while ((iWhere = pstrInstalledDriverFiles->Find(_T(','))) != -1)
	{
		strFindFile = pstrInstalledDriverFiles->Mid(iFirst, iWhere);
		*pstrInstalledDriverFiles = pstrInstalledDriverFiles->Mid(iWhere + 1);
		GetFileExtension(strFindFile, &strTemp);
		if(strTemp.IsEmpty())
			strInstalledAllDriverFiles = strInstalledAllDriverFiles + strFindFile + L",";
		else
			strInstalledAllDriverFiles = strInstalledAllDriverFiles + strTemp + L",";
	}
	strFindFile.Format(L"%s", pstrInstalledDriverFiles->GetBuffer(_MAX_PATH));
	GetFileExtension(strFindFile, &strTemp);
	if(strTemp.IsEmpty())
		strInstalledAllDriverFiles = strInstalledAllDriverFiles + strFindFile;
	else
		strInstalledAllDriverFiles = strInstalledAllDriverFiles + strTemp;
	pchsInstalledDriverFiles->Format(L"%s", strInstalledAllDriverFiles);
}
void CWin32VideoController::GetFileExtension(CHString& pchsFindfileExtension, CHString* pstrFindFile)
{
	int iWhere;
	while ((iWhere = pchsFindfileExtension.Find(_T('.'))) != -1)
	{
		return;
	}
	TCHAR szPath[_MAX_PATH];
	if(GetWindowsDirectory(szPath, _MAX_PATH) == 0)
	{
		pstrFindFile->Empty();
		return;
	}

	WIN32_FIND_DATA stWin32FindData;
	SmartFindClose hFileHandle ;

	pstrFindFile->Format(L"%s\\system32\\%s.*", szPath, pchsFindfileExtension);
	hFileHandle = FindFirstFile(pstrFindFile->GetBuffer(_MAX_PATH), &stWin32FindData);
	if (hFileHandle != INVALID_HANDLE_VALUE)
	{
		pstrFindFile->Format(L"%s", stWin32FindData.cFileName);
		return;
	}
	pstrFindFile->Format(L"%s\\system32\\drivers\\%s.*", szPath, pchsFindfileExtension);
	hFileHandle = FindFirstFile(pstrFindFile->GetBuffer(_MAX_PATH), &stWin32FindData);
	if (hFileHandle != INVALID_HANDLE_VALUE)
	{
		pstrFindFile->Format(L"%s", stWin32FindData.cFileName);
		return;
	}
	pstrFindFile->Empty();
}
#endif

#ifdef NTONLY
BOOL CWin32VideoController::AssignDriverValues(LPCWSTR szDriver, CInstance *pInst)
{
    CHString  strKey;
    BOOL      bRet;
    CRegistry reg;

    strKey.Format(
        _T("SYSTEM\\CurrentControlSet\\Control\\Class\\%s"),
		(LPCWSTR) szDriver);

    // Get the driver settings.
	if (reg.Open(
	    HKEY_LOCAL_MACHINE,
		strKey,
		KEY_READ) == ERROR_SUCCESS)
    {
	    CHString strTemp;

        if (reg.GetCurrentKeyValue(_T("InfPath"), strTemp) == ERROR_SUCCESS)
		    pInst->SetCHString(IDS_InfFileName, strTemp);

        if (reg.GetCurrentKeyValue(_T("InfSection"), strTemp) == ERROR_SUCCESS)
		    pInst->SetCHString(IDS_InfSection, strTemp);

        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}
#endif

void CWin32VideoController::SetProperties(CInstance *pInst, CMultiMonitor *pMon, int iWhich)
{
	// Set the config mgr properties.
    CHString            strTemp,
                        strDriver,
	                    strDeviceName;
	CConfigMgrDevicePtr pDeviceAdapter;

	pMon->GetAdapterDevice(iWhich, pDeviceAdapter);

#ifdef NTONLY
    // Do the NT service and settings properties.
    CHString strSettingsKey,
             strService;

    pMon->GetAdapterSettingsKey(iWhich, strSettingsKey);

#if NTONLY == 4
    pMon->GetAdapterServiceName(strService);
#endif

#endif // #ifdef NTONLY

	// If we have an cfg mgr device, set some cfg mgr properties.
    if (pDeviceAdapter)
    {
		if (pDeviceAdapter->GetDeviceDesc(strTemp))
		{
			pInst->SetCHString(IDS_Description, strTemp);
			pInst->SetCHString(IDS_Caption, strTemp);
			pInst->SetCHString(IDS_Name, strTemp);
		}

		if (pDeviceAdapter->GetMfg(strTemp))
		{
			pInst->SetCHString(IDS_AdapterCompatibility, strTemp);
		}

	    if (pDeviceAdapter->GetStatus(strTemp))
	    {
		    pInst->SetCHString(IDS_Status, strTemp);
	    }

        SetConfigMgrProperties(pDeviceAdapter, pInst);

		// If we get the driver we can get more values.
		if (pDeviceAdapter->GetDriver(strDriver))
		{
			AssignDriverValues(strDriver, pInst);
		}

#if NTONLY >= 5
        pDeviceAdapter->GetService(strService);
#endif

	}

	// Set some standard properties.
	pInst->SetCharSplat(L"SystemName", GetLocalComputerName());
    pInst->SetCharSplat(IDS_SystemCreationClassName,
        L"Win32_ComputerSystem");
    pInst->SetCharSplat(IDS_CreationClassName, L"Win32_VideoController");
	pInst->Setbool(L"Monochrome", false);
	pInst->SetDWORD(L"VideoArchitecture", 5); // 5 == VGA
	pInst->SetDWORD(L"VideoMemoryType", 2); // 2 == Unknown

	// Set the properties that require a DC.

    // strDeviceName will be \\.\Display# on Win9x and W2K
    // and DISPLAY on NT4.
    pMon->GetAdapterDisplayName(iWhich, strDeviceName);

#ifdef NTONLY
	SetDCProperties(pInst, TOBSTRT(strDeviceName), iWhich);

    // SetServiceProperties should be called after we set the cfg mgr
    // properties.
    if (!strService.IsEmpty())
        SetServiceProperties(pInst, strService, strSettingsKey);
#endif
}

HRESULT CWin32VideoController::GetObject(CInstance *pInst, long lFlags)
{
	HRESULT	 hResult = WBEM_E_NOT_FOUND;
	CHString strDeviceID;
    DWORD    dwWhich;

    pInst->GetCHString(L"DeviceID", strDeviceID);

    if (ValidateNumberedDeviceID(strDeviceID, L"VIDEOCONTROLLER", &dwWhich))
    {
        CMultiMonitor monitor;

        if (1 <= dwWhich && dwWhich <= monitor.GetNumAdapters())
        {
            SetProperties(pInst, &monitor, dwWhich - 1);

            hResult = WBEM_S_NO_ERROR;
        }
    }

	return hResult;
}

#ifndef DM_INTERLACED
#define DM_INTERLACED   2
#endif

#ifdef NTONLY
void CWin32VideoController::SetDCProperties(CInstance *pInst,
											LPCTSTR szDeviceName,
											int iWhich)
#endif
{
	HDC hdc =
		    CreateDC(
			    szDeviceName,
				NULL,
				NULL,
				NULL);

	// Bail if we couldn't get the DC.
	if (!hdc)
    {
		// Assume this is because the device is not in use.  Set Availability
        // to 8 (off line).
        pInst->SetDWORD(IDS_Availability, 8);

        return;
    }

    CSmartCreatedDC hdcWrap(hdc);

    pInst->SetDWORD(IDS_Availability, 3); // 3 == Running
	pInst->SetDWORD(L"CurrentBitsPerPixel", GetDeviceCaps(hdc, BITSPIXEL));
    pInst->SetDWORD(L"NumberOfColorPlanes", GetDeviceCaps(hdc, PLANES));
	pInst->SetDWORD(IDS_DeviceSpecificPens, GetDeviceCaps(hdc, NUMPENS));
	pInst->SetDWORD(L"CurrentHorizontalResolution",
        GetDeviceCaps(hdc, HORZRES));
    pInst->SetDWORD(L"CurrentVerticalResolution",
        GetDeviceCaps(hdc, VERTRES));

    // Only valid if 8 or less bpp.
	if (GetDeviceCaps(hdc, BITSPIXEL) <= 8)
		pInst->SetDWORD(IDS_ColorTableEntries, GetDeviceCaps(hdc, NUMCOLORS));

    pInst->SetWBEMINT64(L"CurrentNumberOfColors", (__int64) 1 <<
        (__int64) GetDeviceCaps(hdc, BITSPIXEL));

	// According to the MOF, these are 0 since we're not in character mode.
	pInst->SetDWORD(L"CurrentNumberOfRows", 0);
	pInst->SetDWORD(L"CurrentNumberOfColumns", 0);

	if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
	{
		pInst->SetDWORD(IDS_SystemPaletteEntries,
            GetDeviceCaps(hdc, SIZEPALETTE));
        pInst->SetDWORD(IDS_ReservedSystemPaletteEntries,
		    GetDeviceCaps(hdc, NUMRESERVED));
	}

	TCHAR       szTemp[100];
	CHString    strTemp;

	_i64tot((__int64) 1 << (__int64) GetDeviceCaps(hdc, BITSPIXEL), szTemp, 10);

	FormatMessageW(strTemp,
		IDR_VidModeFormat,
		GetDeviceCaps(hdc, HORZRES),
		GetDeviceCaps(hdc, VERTRES),
		szTemp);

	pInst->SetCharSplat(L"VideoModeDescription", strTemp);


	// Get the dither type
    DEVMODE devmode;

	memset(&devmode, 0, sizeof(DEVMODE));

	devmode.dmSize = sizeof(DEVMODE);
	devmode.dmSpecVersion = DM_SPECVERSION;


    // Get some properties using EnumDisplaySettings.
    LPCTSTR szEnumDeviceName;

#ifdef NTONLY
    szEnumDeviceName = IsWinNT5() ? szDeviceName : NULL;
#endif

    if (EnumDisplaySettings(
        szEnumDeviceName,
        ENUM_CURRENT_SETTINGS,
        &devmode))
	{
		if (devmode.dmFields & DM_DITHERTYPE)
			pInst->SetDWORD(IDS_DitherType, devmode.dmDitherType);

    	// Use these if we can because they're more accurate than the HDC
        // functions.
        pInst->SetDWORD(L"CurrentBitsPerPixel", devmode.dmBitsPerPel);
        pInst->SetWBEMINT64(L"CurrentNumberOfColors", (__int64) 1 <<
            (__int64) devmode.dmBitsPerPel);

#ifdef NTONLY
        pInst->SetDWORD(L"CurrentRefreshRate", devmode.dmDisplayFrequency);

        pInst->SetDWORD(L"CurrentScanMode",
            devmode.dmDisplayFlags & DM_INTERLACED ? 3 : 4);
#endif
	}
#ifdef NTONLY
    else
        pInst->SetDWORD(L"CurrentScanMode", 2);
#endif

#ifdef NTONLY
    // Only works for NT.  Win9x only returns refresh rates as 0 and -1.
	// Find the min/max refresh rate using EnumDisplaySettings.
    DWORD   dwMinRefresh = 0xFFFFFFFF,
            dwMaxRefresh = 0;

    for (int iMode = 0; EnumDisplaySettings(szEnumDeviceName, iMode, &devmode);
        iMode++)
    {
        // Ignore '1' since it means 'default' instead of a real value.
        if (devmode.dmDisplayFrequency < dwMinRefresh &&
            devmode.dmDisplayFrequency > 1)
            dwMinRefresh = devmode.dmDisplayFrequency;

        if (devmode.dmDisplayFrequency > dwMaxRefresh)
            dwMaxRefresh = devmode.dmDisplayFrequency;
    }

    if (dwMinRefresh != 0xFFFFFFFF)
        pInst->SetDWORD(L"MinRefreshRate", dwMinRefresh);

    if (dwMinRefresh != 0)
        pInst->SetDWORD(L"MaxRefreshRate", dwMaxRefresh);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\videocfg.cpp ===
//

// VideoCfg.cpp -- video managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 09/23/95     a-skaja     Prototype for demo
// 09/27/96     jennymc     Updated to current standards
// 03/02/99    a-peterc		Added graceful exit on SEH and memory failures,
//							clean up
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>
#include "ProvExce.h"
#include "multimonitor.h"
#include "videocfg.h"
#include "resource.h"


//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32VideoConfiguration	win32VideoCfg(PROPSET_NAME_VIDEOCFG, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoConfiguration::CWin32VideoConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32VideoConfiguration::CWin32VideoConfiguration(const CHString& a_strName,
												   LPCWSTR a_pszNamespace /*=NULL*/)
:	Provider(a_strName, a_pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoConfiguration::~CWin32VideoConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32VideoConfiguration::~CWin32VideoConfiguration()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32VideoConfiguration::GetObject
//
//	Inputs:		CInstance*		a_pInst - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32VideoConfiguration::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
	BOOL	t_fReturn = FALSE;
	CHString t_InName, t_OutName, t_InAdapter, t_OutAdapter;

	a_pInst->GetCHString(IDS_AdapterCompatibility, t_InAdapter);
	a_pInst->GetCHString(IDS_Name, t_InName);

	// Find the instance depending on platform id.
	t_fReturn = GetInstance(a_pInst);

	a_pInst->GetCHString(IDS_AdapterCompatibility, t_OutAdapter);
	a_pInst->GetCHString(IDS_Name, t_OutName);

	if (t_InAdapter.CompareNoCase(t_OutAdapter) != 0 ||
		t_OutName.CompareNoCase(t_InName) != 0)
	{
		t_fReturn = FALSE;
	}

	return t_fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32VideoConfiguration::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32VideoConfiguration::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
	HRESULT		t_hResult	= WBEM_S_NO_ERROR;
	CInstancePtr t_pInst(CreateNewInstance(a_pMethodContext), false);

	// Get the proper OS dependent instance
	if (GetInstance(t_pInst))
	{
		t_hResult = t_pInst->Commit();
	}

	return t_hResult;
}

//////////////////////////////////////////////////////////////////
BOOL CWin32VideoConfiguration::GetCommonVideoInfo(CInstance *a_pInst)
{
    HDC t_hdc = NULL;

	try
	{
		a_pInst->SetCharSplat(IDS_Name, L"Current Video Configuration");

        CHString sTemp2;
        LoadStringW(sTemp2, IDR_CurrentVideoConfiguration);

		a_pInst->SetCHString(IDS_Caption, sTemp2);
		a_pInst->SetCHString(IDS_Description, sTemp2);

		if (!(t_hdc = GetDC (NULL)))
		{
			return FALSE;
		}

		//  Get the common info
		//=============================
		a_pInst->SetDWORD(IDS_ScreenWidth, (DWORD) GetDeviceCaps (t_hdc, HORZSIZE));
		a_pInst->SetDWORD(IDS_ScreenHeight, (DWORD) GetDeviceCaps (t_hdc, VERTSIZE));
		a_pInst->SetDWORD(IDS_HorizontalResolution, (DWORD) GetDeviceCaps (t_hdc, HORZRES));
		a_pInst->SetDWORD(IDS_VerticalResolution, (DWORD) GetDeviceCaps (t_hdc, VERTRES));
		a_pInst->SetDWORD(IDS_PixelsPerXLogicalInch, (DWORD) GetDeviceCaps (t_hdc, LOGPIXELSX));
		a_pInst->SetDWORD(IDS_PixelsPerYLogicalInch, (DWORD) GetDeviceCaps (t_hdc, LOGPIXELSY));
		a_pInst->SetDWORD(IDS_BitsPerPixel, (DWORD) GetDeviceCaps (t_hdc, BITSPIXEL));
		a_pInst->SetDWORD(IDS_ColorPlanes, (DWORD) GetDeviceCaps (t_hdc, PLANES));
		a_pInst->SetDWORD(IDS_DeviceSpecificPens, (DWORD) GetDeviceCaps (t_hdc, NUMPENS));
		a_pInst->SetDWORD(IDS_ColorTableEntries, (DWORD) GetDeviceCaps (t_hdc, NUMCOLORS));
		a_pInst->SetDWORD(IDS_ActualColorResolution, (DWORD) GetDeviceCaps (t_hdc, COLORRES));

		if (GetDeviceCaps(t_hdc, RASTERCAPS) & RC_PALETTE)
		{
			a_pInst->SetDWORD(IDS_SystemPaletteEntries, (DWORD) GetDeviceCaps (t_hdc, SIZEPALETTE));
		}
		// if we didn't find refresh rate before - try this way...
	#ifdef NTONLY
			DWORD t_deWord = (DWORD) GetDeviceCaps(t_hdc, VREFRESH);
			BOOL t_Clear = a_pInst->IsNull (IDS_RefreshRate) ||
							(! a_pInst->GetDWORD(IDS_RefreshRate, t_deWord)) || (! t_deWord);
			if (t_Clear)
			{
				a_pInst->SetDWORD(IDS_RefreshRate,  (DWORD) GetDeviceCaps(t_hdc, VREFRESH));
			}
	#endif

	}
	catch(...)
	{
        if (t_hdc)
		{
			ReleaseDC (NULL, t_hdc);
		}

		throw;
	}

	ReleaseDC(NULL, t_hdc);

	return TRUE;
}

//////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32VideoConfiguration::AssignAdapterLocaleForNT(LPCTSTR a_szSubKey,  CInstance *a_pInst)
{
    CRegistry t_Reg;
    CHString t_TempBuffer;
    TCHAR t_szTempBuffer[_MAX_PATH+2];

    if (t_Reg.OpenLocalMachineKeyAndReadValue(a_szSubKey, IDENTIFIER, t_TempBuffer) != ERROR_SUCCESS)
	{
        return FALSE;
    }

	t_TempBuffer.MakeUpper();

    if (_tcsstr (t_TempBuffer, INTERNAL))
	{
        a_pInst->SetCHString(IDS_AdapterLocale, INTEGRATED_CIRCUITRY);
    }
	else {
        _stprintf(t_szTempBuffer, _T("%s%s"), ADD_ON_CARD, t_TempBuffer);
        a_pInst->SetCHString(IDS_AdapterLocale, t_szTempBuffer);
    }

    return TRUE;
}
#endif
//////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32VideoConfiguration::AssignAdapterCompatibilityForNT(LPCTSTR a_szVideoInfo, CInstance *a_pInst)
{
    TCHAR *t_pPtr;
    TCHAR t_szTemp[_MAX_PATH+2];

    t_pPtr = _tcsstr (a_szVideoInfo, SERVICES);

    if (t_pPtr)
	{
        t_pPtr += lstrlen (SERVICES);
        lstrcpy (t_szTemp, t_pPtr);

		t_pPtr = _tcsstr (t_szTemp, DEVICE);
        *t_pPtr = NULL;

        a_pInst->SetCHString(IDS_AdapterCompatibility, t_szTemp);

		return TRUE;
    }
    else
	{
		LogEnumValueError(_T(__FILE__), __LINE__, ADAPTER_COMPATIBILITY, WINNT_VIDEO_REGISTRY_KEY);
        return FALSE;
	}
}
#endif
////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32VideoConfiguration::OpenVideoResolutionKeyForNT(LPCTSTR a_szVideoInfo,
                                                        CRegistry &a_PrimaryReg)
{
    TCHAR *t_pPtr;
    TCHAR t_szTemp[_MAX_PATH+2];

    // point to the system section
    //============================
    t_pPtr = _tcsstr(a_szVideoInfo, SYSTEM);

    // If "system" existed, then use the balance
    // as a pointer into the registry
    //============================================
    if (!t_pPtr)
	{
        return FALSE;
	}

	// get past backslash
    //============================================
    ++t_pPtr;

    // Copy the balance of the string as a pointer
    // to the location in the registry for the
    // information for the miniport video driver
    //============================================
    lstrcpy(t_szTemp, (LPCTSTR) t_pPtr);

    // use path to locate the video resolution etc and TYPE
    //=====================================================
    if (a_PrimaryReg.Open(HKEY_LOCAL_MACHINE, t_szTemp, KEY_READ) != ERROR_SUCCESS)
	{
        LogOpenRegistryError(_T(__FILE__), __LINE__, t_szTemp);
		return FALSE;
	}

	// else...
    return TRUE;
}
#endif
////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32VideoConfiguration::GetInstance(CInstance* a_pInst)
{
    CRegistry t_PrimaryReg;
    CHString t_chsTmp, t_chsVideoInfo;
    TCHAR* t_pPtr;
    DWORD t_dwTmp;
    BOOL t_fComma = FALSE;
    WCHAR t_szTemp[_MAX_PATH];
    TCHAR t_szTmp[_MAX_PATH];

    //****************************************
    //  Get AdapterLocale, Monitor Type and
    //  Adapter Type
    //****************************************
    AssignFirmwareSetValuesInNT (a_pInst);

    //****************************************
    //  Now, open the key to get the NT stuff
    //****************************************
    if (t_PrimaryReg.OpenLocalMachineKeyAndReadValue(
            WINNT_VIDEO_REGISTRY_KEY,
            VIDEO_INFO_PATH,
            t_chsVideoInfo) != ERROR_SUCCESS)
	{
        return FALSE;
    }
	t_chsVideoInfo.MakeUpper();

    if (!AssignAdapterCompatibilityForNT(t_chsVideoInfo, a_pInst))
	{
        return FALSE;
	}

    if (!OpenVideoResolutionKeyForNT(t_chsVideoInfo, t_PrimaryReg))
	{
        return FALSE;
	}

	CHString t_strInstalledDisplayDrivers;

    if (t_PrimaryReg.GetCurrentKeyValue(INSTALLED_DISPLAY_DRIVERS, t_chsTmp) == ERROR_SUCCESS)
	{
        t_pPtr = _tcstok((LPTSTR) (LPCTSTR) t_chsTmp, _T("\n"));

		while(t_pPtr)
		{
            if (t_fComma)
			{
                t_strInstalledDisplayDrivers += _T(",");
            }

			t_strInstalledDisplayDrivers += t_pPtr;
            t_fComma = TRUE;
            t_pPtr = _tcstok(NULL, _T("\n"));
        }
    }

	if (!t_strInstalledDisplayDrivers.IsEmpty())
	{
		a_pInst->SetCHString(IDS_InstalledDisplayDrivers, t_strInstalledDisplayDrivers);
 	}

    DWORD dwSize;

    dwSize = 4;
    if (t_PrimaryReg.GetCurrentBinaryKeyValue(ADAPTER_RAM,(LPBYTE) &t_dwTmp, &dwSize) == ERROR_SUCCESS)
        a_pInst->SetDWORD(IDS_AdapterRAM, t_dwTmp);

    dwSize = sizeof(t_szTemp);
    if (t_PrimaryReg.GetCurrentBinaryKeyValue(ADAPTER_DESCRIPTION, (BYTE *) &t_szTemp, &dwSize) == ERROR_SUCCESS)
	{
        a_pInst->SetCHString(IDS_AdapterDescription, t_szTemp);
    }

    dwSize = sizeof(t_szTemp);
    if (t_PrimaryReg.GetCurrentBinaryKeyValue(ADAPTER_CHIPTYPE, (BYTE *) &t_szTemp, &dwSize) == ERROR_SUCCESS)
	{
        a_pInst->SetCHString(IDS_AdapterChipType, t_szTemp);
    }

    dwSize = sizeof(t_szTemp);
    if (t_PrimaryReg.GetCurrentBinaryKeyValue(ADAPTER_DAC_TYPE, (BYTE *) &t_szTemp, &dwSize) == ERROR_SUCCESS)
	{
		a_pInst->SetCHString(IDS_AdapterDACType, t_szTemp);
    }

    //****************************************
    //  Get the info from Current Config
    //****************************************
    _stprintf(t_szTmp,
        _T("System\\CurrentControlSet\\Services\\%s\\Device0"),
        t_strInstalledDisplayDrivers);

    if (t_PrimaryReg.Open(HKEY_CURRENT_CONFIG, t_szTmp, KEY_READ) == ERROR_SUCCESS)
	{
        dwSize = 4;
        if (t_PrimaryReg.GetCurrentBinaryKeyValue(INTERLACED,(BYTE*) &t_dwTmp, &dwSize)== ERROR_SUCCESS)
		{
            if (0 == t_dwTmp)
			{
                a_pInst->SetCHString(IDS_ScanMode, _T("Non Interlaced"));
            }
			else
			{
                a_pInst->SetCHString(IDS_ScanMode, _T("Interlaced"));
			}
        }

        dwSize = 4;
		if (t_PrimaryReg.GetCurrentBinaryKeyValue(VREFRESH_RATE, (BYTE *) &t_dwTmp, &dwSize) == ERROR_SUCCESS)
		{
            a_pInst->SetDWORD(IDS_RefreshRate, t_dwTmp);
        }
    }

	// try reading INF stuff out of currentControlSet, if that doesn't work, try 001.
	// (On NT five, CurrentControlSet doesn't seem very populated, real data shows up in ControlSet001)
	if (t_PrimaryReg.Open(HKEY_LOCAL_MACHINE, WINNT_OTHER_VIDEO_REGISTRY_KEY, KEY_READ) == ERROR_SUCCESS	||
		 t_PrimaryReg.Open(HKEY_LOCAL_MACHINE, WINNT_OTHER_OTHER_VIDEO_REGISTRY_KEY, KEY_READ) == ERROR_SUCCESS)
	{
		CHString t_tmp;

		if (t_PrimaryReg.GetCurrentKeyValue(INF_PATH, t_tmp) == ERROR_SUCCESS)
		{
		    a_pInst->SetCHString(IDS_InfFileName, t_tmp);
		}

		if (t_PrimaryReg.GetCurrentKeyValue(INF_SECTION, t_chsTmp) == ERROR_SUCCESS)
		{
		    a_pInst->SetCHString(IDS_InfSection, t_chsTmp);
		}

		t_PrimaryReg.Close();
	}

    //****************************************
    //  Get the common Video info
    //****************************************
    return GetCommonVideoInfo(a_pInst);
}
#endif

////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
void CWin32VideoConfiguration::AssignFirmwareSetValuesInNT (CInstance *a_pInst)
{
    CHString *t_pPtr, t_chsTmp;
    CHPtrArray t_chsaList;
    CRegistrySearch t_Search;
    CRegistry t_PrimaryReg;

	try
	{
		t_chsTmp=_T("");
		t_Search.SearchAndBuildList(WINNT_HARDWARE_DESCRIPTION_REGISTRY_KEY,
								   t_chsaList, DISPLAY_CONTROLLER, t_chsTmp,
								   KEY_FULL_MATCH_SEARCH);

		int t_nNum =  t_chsaList.GetSize();

		if (t_nNum > 0)
		{
			t_pPtr = (CHString *) t_chsaList.GetAt(0);

			if (t_pPtr)
			{
				if (t_PrimaryReg.Open(HKEY_LOCAL_MACHINE, *t_pPtr, KEY_READ) == ERROR_SUCCESS)
				{
					CRegistry t_Reg;
					TCHAR t_szSubKey[_MAX_PATH+2];

					AssignAdapterLocaleForNT(*t_pPtr, a_pInst);

					_stprintf(t_szSubKey, _T("%s%s"),*t_pPtr, ZERO);

                    if (t_Reg.OpenLocalMachineKeyAndReadValue(t_szSubKey, IDENTIFIER, t_chsTmp) == ERROR_SUCCESS)
					{
						a_pInst->SetCHString(IDS_AdapterType, t_chsTmp);
					}

					_stprintf(t_szSubKey, _T("%s%s"), *t_pPtr, MONITOR_PERIPHERAL);
                    if (t_Reg.OpenLocalMachineKeyAndReadValue(t_szSubKey, IDENTIFIER, t_chsTmp) == ERROR_SUCCESS)
					{
						a_pInst->SetCHString(IDS_MonitorType, t_chsTmp);
					}
				}
			}
		}
		else // That didn't work, so try using config. manager.
		{
			// This code lifted from displaycfg.cpp.
			// TODO: Win32_DisplayConfiguration and Win32_VideoConfiguration seem
			//       to be an awful lot alike.  Why do we have both?
    		CConfigManager      t_configMngr;
			CDeviceCollection   t_devCollection;

			if (t_configMngr.GetDeviceListFilterByClass(t_devCollection, _T("Display")))
			{
				REFPTR_POSITION t_pos;

				t_devCollection.BeginEnum(t_pos);

				CHString            t_strDriverName,
									t_strDesc;

				if (t_devCollection.GetSize())
				{
                    CConfigMgrDevicePtr t_pDevice;
					t_pDevice.Attach(t_devCollection.GetNext(t_pos));
					if (t_pDevice != NULL)
					{
						t_pDevice->GetDeviceDesc(t_strDesc);
						a_pInst->SetCHString(IDS_AdapterType, t_strDesc);

					}
				}
			}
		}

	}
	catch(...)
	{
		t_Search.FreeSearchList(CSTRING_PTR, t_chsaList);

		throw;
	}

	t_Search.FreeSearchList(CSTRING_PTR, t_chsaList);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\videocfg.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// VideoCfg.h -- Video property set description for WBEM MO          //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   //
// 09/08/95     a-skaja     Prototype                                //
// 09/27/96     jennymc     Updated to meet current standards        //
// 03/02/99    a-peterc		added graceful exit on SEH and memory failures,
//							clean up
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define	PROPSET_NAME_VIDEOCFG	L"Win32_VideoConfiguration"

class CWin32VideoConfiguration : public Provider
{
	// Utility function(s)
	//====================
   private:

		BOOL GetInstance( CInstance *a_pInst ) ;

	#ifdef NTONLY	    
	    BOOL AssignAdapterLocaleForNT( LPCTSTR a_szSubKey, CInstance *a_pInst ) ;
        BOOL AssignAdapterCompatibilityForNT( LPCTSTR a_szVideoInfo, CInstance*a_pInst ) ;
        BOOL OpenVideoResolutionKeyForNT( LPCTSTR a_szVideoInfo, CRegistry &a_PrimaryReg ) ;
        void AssignFirmwareSetValuesInNT ( CInstance *a_pInst ) ;
	#endif

        BOOL GetCommonVideoInfo( CInstance *a_pInst ) ;

    public:

        // Constructor/destructor
        //=======================

        CWin32VideoConfiguration( const CHString& a_strName, LPCWSTR a_pszNamespace ) ;
       ~CWin32VideoConfiguration() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject( CInstance *a_pInst, long a_lFlags = 0L ) ;
        virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;
} ;

///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
#define WINNT_VIDEO_REGISTRY_KEY             L"HARDWARE\\DEVICEMAP\\VIDEO"
#define WINNT_OTHER_VIDEO_REGISTRY_KEY		 L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000"
#define WINNT_OTHER_OTHER_VIDEO_REGISTRY_KEY L"SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000"

#define ADAPTER_DESC L"DriverDesc"
#define MONITOR_TYPE L"DriverDesc"
#define MONITOR_MFG L"DriverDesc"
#define MFG L"Mfg"
#define VREFRESH_RATE                        L"DefaultSettings.VRefresh"
#define ADAPTER_COMPATIBILITY                L"Adapter Compatibility"
#define VIDEO_INFO_PATH                      L"\\Device\\Video0"
#define SERVICES                             L"\\SERVICES\\"
#define DEVICE                               L"\\DEVICE"
#define SYSTEM                               L"\\SYSTEM"
#define INTERLACED                           L"DefaultSettings.Interlaced"
#define INSTALLED_DISPLAY_DRIVERS            L"InstalledDisplayDrivers"
#define ADAPTER_RAM                          L"HardwareInformation.MemorySize"
#define ADAPTER_DESCRIPTION                  L"HardwareInformation.AdapterString"
#define ADAPTER_CHIPTYPE                     L"HardwareInformation.ChipType"
#define ADAPTER_DAC_TYPE                     L"HardwareInformation.DACType"
#define WINNT_HARDWARE_DESCRIPTION_REGISTRY_KEY L"HARDWARE\\Description\\System"
#define DISPLAY_CONTROLLER                   L"DisplayController"
#define INTERNAL                             L"INTERNAL"
#define INTEGRATED_CIRCUITRY                 L"Integrated circuitry/Internal"
#define ADD_ON_CARD                          L"Add-on card on "
#define MONITOR_PERIPHERAL                   L"\\MonitorPeripheral\\0"
#define ZERO                                 L"\\0"
#define IDENTIFIER                           L"Identifier"
#define SLASH                                L"\\"
#define	REFRESHRATE							L"RefreshRate"
#define INF_PATH        L"InfPath"
#define INF_SECTION     L"InfSection"
#define DRIVER_DATE     L"DriverDate"
///////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\videocontrollerresolution.h ===
//=================================================================

//

// VideoControllerResolution.h -- CWin32VideoControllerResolution property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/05/98    sotteson         Created
//
//=================================================================
#ifndef _VIDEOCONTROLLERRESOLUTION_H
#define _VIDEOCONTROLLERRESOLUTION_H

class CMultiMonitor;

class CCIMVideoControllerResolution : public Provider
{
public:
	// Constructor/destructor
	//=======================
	CCIMVideoControllerResolution(const CHString& szName, LPCWSTR szNamespace);
	~CCIMVideoControllerResolution();

	virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
		long lFlags = 0);
	virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0);

    static void DevModeToSettingID(DEVMODE *pMode, CHString &strSettingID);
    static void DevModeToCaption(DEVMODE *pMode, CHString &strCaption);

protected:
    void SetProperties(CInstance *pInstance, DEVMODE *pMode);
    HRESULT EnumResolutions(MethodContext *pMethodContext, 
        CInstance *pInstanceLookingFor, LPCWSTR szDeviceName, 
        CHStringList &listIDs);
    static BOOL IDInList(CHStringList &list, LPCWSTR szID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\videocontrollerresolution.cpp ===
//=================================================================

//

// VideoControllerResolution.CPP -- CodecFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//				 03/02/99    a-peterc		  added graceful exit on SEH and memory failures
//
//=================================================================

#include "precomp.h"
#include "VideoControllerResolution.h"
#include <multimon.h>
#include <ProvExce.h>
#include "multimonitor.h"
#include "resource.h"

// Property set declaration
//=========================

CCIMVideoControllerResolution videoControllerResolution(
	L"CIM_VideoControllerResolution",
	IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CCIMVideoControllerResolution::CCIMVideoControllerResolution
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CCIMVideoControllerResolution::CCIMVideoControllerResolution(const CHString& szName,
	LPCWSTR szNamespace) : Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMVideoControllerResolution::~CCIMVideoControllerResolution
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CCIMVideoControllerResolution::~CCIMVideoControllerResolution()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMVideoControllerResolution::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CCIMVideoControllerResolution::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags /*= 0L*/)
{
    HRESULT         hres = WBEM_S_NO_ERROR;
    CMultiMonitor   monitor;
    CHStringList    listIDs;

    for (int i = 0; i < monitor.GetNumAdapters(); i++)
    {
        CHString strDeviceName;

        monitor.GetAdapterDisplayName(i, strDeviceName);

        EnumResolutions(
            pMethodContext,
            NULL,
            // If this OS doesn't support multi-monitor we'll have 'DISPLAY' as
            // the name, in which case we need to send NULL to the enum function.
            strDeviceName == L"DISPLAY" ? NULL : (LPCWSTR) strDeviceName,
            listIDs);
    }

    return hres;
}

BOOL CCIMVideoControllerResolution::IDInList(CHStringList &list, LPCWSTR szID)
{
	for (CHStringList_Iterator i = list.begin(); i != list.end(); ++i)
	{
		CHString &str = *i;

		if (!str.CompareNoCase(szID))
			return TRUE;
	}

	return FALSE;
}

HRESULT CCIMVideoControllerResolution::EnumResolutions(
    MethodContext *a_pMethodContext,
    CInstance *a_pInstanceLookingFor,
    LPCWSTR a_szDeviceName,
    CHStringList &a_listIDs )
{
    int         t_i = 0 ;
    DEVMODE     t_devmode ;
    CHString    t_strIDLookingFor ;
    HRESULT     t_hResult	= WBEM_S_NO_ERROR ;
	BOOL		t_bFound	= TRUE ;
	CInstancePtr t_pInst;

	if ( a_pInstanceLookingFor )
	{
		t_bFound = FALSE ;
		a_pInstanceLookingFor->GetCHString( L"SettingID", t_strIDLookingFor ) ;
	}

	while ( EnumDisplaySettings( TOBSTRT(a_szDeviceName), t_i, &t_devmode ) && SUCCEEDED( t_hResult ) )
	{
		CHString t_strID ;

		// Convert the devmode to a string ID.
		DevModeToSettingID( &t_devmode, t_strID ) ;

		// If we haven't already processed this one...
		if ( !IDInList( a_listIDs, t_strID ) )
		{
			// If we're doing a GetObject()...
			if ( a_pInstanceLookingFor )
			{
				// If this is the right setting id...
				if ( !t_strIDLookingFor.CompareNoCase( t_strID ) )
				{
					CHString t_strCaption ;

					// Convert the devmode to a caption.
					DevModeToCaption( &t_devmode, t_strCaption ) ;

					// Set the properties and get out.
					t_bFound = TRUE ;
					t_hResult = WBEM_S_NO_ERROR ;
					SetProperties( a_pInstanceLookingFor, &t_devmode ) ;
					a_pInstanceLookingFor->SetCharSplat( L"SettingID",	t_strID) ;
					a_pInstanceLookingFor->SetCharSplat( L"Description", t_strCaption) ;
					a_pInstanceLookingFor->SetCharSplat( L"Caption",		t_strCaption) ;
					break;
				}
			}
			// Must be doing an EnumerateInstances().
			else
			{
                t_pInst.Attach(CreateNewInstance( a_pMethodContext ));
				if ( t_pInst != NULL )
				{
					CHString t_strCaption ;

					// Convert the devmode to a caption.
					DevModeToCaption( &t_devmode, t_strCaption ) ;

					SetProperties(t_pInst, &t_devmode ) ;

					t_pInst->SetCharSplat( L"SettingID",		t_strID ) ;
					t_pInst->SetCharSplat( L"Description",	t_strCaption ) ;
					t_pInst->SetCharSplat( L"Caption",		t_strCaption ) ;

					t_hResult = t_pInst->Commit(  ) ;
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
					break;
				}
			}

			a_listIDs.push_back( t_strID ) ;
		}

		t_i++ ;
	}

	if ( !t_bFound )
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}

BOOL WINAPI IsModeInterlaced(DEVMODE *pMode)
{
    return pMode->dmDisplayFrequency > 1 && pMode->dmDisplayFrequency <= 50;
}

void CCIMVideoControllerResolution::DevModeToSettingID(
    DEVMODE *pMode,
    CHString &strSettingID)
{
    WCHAR szID[512];

    swprintf(
        szID,
        L"%d x %d x %I64d colors @ %d Hertz",
        pMode->dmPelsWidth,
        pMode->dmPelsHeight,
        (__int64) 1 << (__int64) pMode->dmBitsPerPel,
        pMode->dmDisplayFrequency);

    if (IsModeInterlaced(pMode))
        wcscat(szID, L" (Interlaced)");

    strSettingID = szID;
}

void CCIMVideoControllerResolution::DevModeToCaption(
    DEVMODE *pMode,
    CHString &strCaption)
{
    TCHAR szColors[512];

    _i64tot((__int64) 1 << (__int64) pMode->dmBitsPerPel, szColors, 10);

    FormatMessageW(strCaption,
        IsModeInterlaced(pMode) ?
            IDR_VidControllerResolutionFormatInterlaced :
            IDR_VidControllerResolutionFormat,
        pMode->dmPelsWidth,
        pMode->dmPelsHeight,
        szColors,
        pMode->dmDisplayFrequency);
}

void CCIMVideoControllerResolution::SetProperties(CInstance *pInstance, DEVMODE *pMode)
{
    pInstance->SetDWORD(L"HorizontalResolution", pMode->dmPelsWidth);
    pInstance->SetDWORD(L"VerticalResolution", pMode->dmPelsHeight);
    pInstance->SetDWORD(L"RefreshRate", pMode->dmDisplayFrequency);
    pInstance->SetDWORD(L"ScanMode", IsModeInterlaced(pMode) ? 5 : 4);
    pInstance->SetWBEMINT64(L"NumberOfColors", (__int64) 1 <<
        (__int64) pMode->dmBitsPerPel);
}

HRESULT CCIMVideoControllerResolution::GetObject(CInstance *pInstance, long lFlags)
{
    HRESULT         hres = WBEM_E_NOT_FOUND;
    CMultiMonitor   monitor;
    CHStringList    listIDs;

    for (int i = 0; i < monitor.GetNumAdapters(); i++)
    {
        CHString strDeviceName;

        monitor.GetAdapterDisplayName(i, strDeviceName);

        if (SUCCEEDED(hres =
            EnumResolutions(
                NULL,
                pInstance,
                // If this OS doesn't support multi-monitor we'll have 'DISPLAY' as
                // the name, in which case we need to send NULL to the enum function.
                strDeviceName == L"DISPLAY" ? NULL : (LPCWSTR) strDeviceName,
                listIDs)))
            break;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\wavedevcfg.h ===
/*******************************************************************

 *

 *    WavedevCfg.h

 *

*  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
 *
 *******************************************************************/

#ifndef __WAVEDEVCFG_H_
#define __WAVEDEVCFG_H_

class CWin32WaveDeviceCfg : public Provider
{
public:

	// constructor/destructor
	CWin32WaveDeviceCfg (const CHString& name, LPCWSTR pszNamespace);
	virtual ~CWin32WaveDeviceCfg ();

    //=================================================
    // Functions provide properties with current values
    //=================================================
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);

protected:
private:
};	// end class CWin32SndDeviceCfg

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\wavedevcfg.cpp ===
/*******************************************************************

 *

 *    WAVEdevCfg.cpp

 *

*  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
 *
 *******************************************************************/
#include "precomp.h"
#include "wavedevcfg.h"

CWin32WaveDeviceCfg::CWin32WaveDeviceCfg (const CHString& name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{

}

CWin32WaveDeviceCfg::~CWin32WaveDeviceCfg ()
{

}

HRESULT CWin32WaveDeviceCfg::GetObject (CInstance* pInstance, long lFlags/* = 0L*/)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	return(hr);
}

HRESULT CWin32WaveDeviceCfg::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\vxd.cpp ===
////////////////////////////////////////////////////////////////////

//

//  vxd.CPP

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//		Implementation of VXD
//      10/23/97    jennymc     updated to new framework
//
//      03/02/99 - a-peterc - added graceful exit on SEH and memory failures
//
////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <io.h>
#include <stddef.h>
#include "vxd.h"
#include <locale.h>
#include <ProvExce.h>

#include "lockwrap.h"

CWin32DriverVXD MyCWin32VXDSet(PROPSET_NAME_VXD, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DriverVXD::CWin32DriverVXD
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
CWin32DriverVXD::CWin32DriverVXD(const CHString& name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}
/*****************************************************************************
 *
 *  FUNCTION    : CWin32DriverVXD::~CWin32DriverVXD
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
CWin32DriverVXD::~CWin32DriverVXD()
{
}
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32DriverVXD::GetObject(CInstance *a_pInst, long a_lFlags /*= 0L*/)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

	// =======================================
	// Process only if the platform is Win95+
	// =======================================

	return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DriverVXD::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32DriverVXD::EnumerateInstances(MethodContext *a_pMethodContext, long a_lFlags /*= 0L*/)
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR;

	// =======================================
	// Process only if the platform is Win95+
	// =======================================

    return t_hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\videosettings.h ===
//=================================================================

//

// VideoSettings.h -- CWin32VideoSettings property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/05/98    sotteson         Created
//
//=================================================================
#ifndef _VIDEOSETTINGS_H
#define _VIDEOSETTINGS_H

class CMultiMonitor;

class CWin32VideoSettings : public Provider
{
	protected:

		HRESULT SetProperties( MethodContext *a_pMethodContext, CInstance *a_pInstance, 
			LPCWSTR a_szID, int a_iAdapter ) ;

		HRESULT EnumResolutions(MethodContext *a_pMethodContext, 
			CInstance *a_pInstanceLookingFor, LPCWSTR a_szLookingForPath, 
			LPCWSTR a_szDeviceName, int a_iWhich ) ;
	public:

		// Constructor/destructor
		//=======================
		CWin32VideoSettings(LPCWSTR a_szName, LPCWSTR a_szNamespace ) ;
		~CWin32VideoSettings() ;

		virtual HRESULT EnumerateInstances(MethodContext *a_pMethodContext, 
			long a_lFlags = 0 ) ;
		virtual HRESULT GetObject( CInstance *a_pInstance, long a_lFlags = 0 ) ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\vxd.h ===
////////////////////////////////////////////////////////////////////

//

//  vxd.h

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//		Implementation of VXD
//      10/23/97    jennymc     updated to new framework
//		
////////////////////////////////////////////////////////////////////
#define PROPSET_NAME_VXD  L"Win32_DriverVXD"


class CWin32DriverVXD : public Provider
{
		//=================================================
		// Utility
		//=================================================
    private:
	
	public:

        //=================================================
        // Constructor/destructor
        //=================================================

        CWin32DriverVXD(const CHString& a_name, LPCWSTR a_pszNamespace ) ;
       ~CWin32DriverVXD() ;

        //=================================================
        // Functions provide properties with current values
        //=================================================
		virtual HRESULT GetObject( CInstance *a_pInstance, long a_lFlags = 0L ) ;
		virtual HRESULT EnumerateInstances( MethodContext *a_pMethodContext, long a_lFlags = 0L ) ;

  
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\w2kenum.cpp ===
//=================================================================

//

// W2kEnum.cpp -- W2k enumeration support

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/28/99            Created
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>
#include "W2kEnum.h"

// max length of NTE REG_MULTI_SZ.
#define MAX_NTE_VALUE 132

/*	Note: As you read into this code and ask why all this registry routing is necessary for WMI
	understand that the model for the classes that use this under W2k is restrictive, flat and
	totally out of sync with the reality of Microsoft networking today. Adapters have interfaces,
	protocols are bound to adapters, some are virtual, and one class makes use of all these concepts
	attempting to represent this as an occurrence of an instance. This is becoming increasingly
	hard to maintain and changes are occurring faster and faster.

	The architecture is strictly bound and held over from a simpler time in	the networking world.
	A lot has changed in three years of Microsoft networking. Unfortunately	we can not change the
	architecture of the classes in WMI that represent networking. A view initiated in the Win95 days.
	We will do the best to hammer Microsoft networking into the small hole we have here. At some point
	we will be able to sit down and get this model right.

*/

CW2kAdapterEnum::CW2kAdapterEnum()
{
	try
	{
		GetW2kInstances() ;
	}
	catch ( ... )
	{
		CW2kAdapterInstance *t_pchsDel;

		for( int t_iar = 0; t_iar < GetSize(); t_iar++ )
		{
			if( t_pchsDel = (CW2kAdapterInstance*) GetAt( t_iar ) )
			{
				delete t_pchsDel ;
			}
		}

		throw;
	}
}
//
CW2kAdapterEnum::~CW2kAdapterEnum()
{
	CW2kAdapterInstance *t_pchsDel;

	for( int t_iar = 0; t_iar < GetSize(); t_iar++ )
	{
		if( t_pchsDel = (CW2kAdapterInstance*) GetAt( t_iar ) )
		{
			delete t_pchsDel ;
		}
	}
}

//
BOOL CW2kAdapterEnum::GetW2kInstances()
{
	BOOL			t_fRet = FALSE ;
	TCHAR			t_szKey[ MAX_PATH + 2 ] ;

	CW2kAdapterInstance	*t_pW2kInstance ;

	CRegistry			t_NetReg ;
	CRegistry			t_oRegLinkage ;
	CHString			t_csAdapterKey ;

	_stprintf( t_szKey, _T("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}") ) ;

	// open the master list of adapters
	if( ERROR_SUCCESS != t_NetReg.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_szKey, KEY_READ ) )
	{
		return FALSE ;
	}

	// Walk through each instance under this key.  These are all
	// adapters that show up in NT 5's Control Panel
	while( ERROR_SUCCESS == t_NetReg.GetCurrentSubKeyName( t_csAdapterKey ) )
	{
		// the key
		DWORD				t_dwIndex = _ttol( t_csAdapterKey ) ;

		CHString			t_chsCaption ;
		CHString			t_chsDescription ;
		CHString			t_chsNetCfgInstanceID ;

		CHString			t_chsCompleteKey ;
							t_chsCompleteKey = t_szKey ;
							t_chsCompleteKey += _T("\\" ) ;
							t_chsCompleteKey += t_csAdapterKey ;

		// Net instance identifier
		CRegistry	t_oRegAdapter ;
		if( ERROR_SUCCESS == t_oRegAdapter.Open( HKEY_LOCAL_MACHINE, t_chsCompleteKey, KEY_READ ) )
		{
			t_oRegAdapter.GetCurrentKeyValue( _T("NetCfgInstanceID"), t_chsNetCfgInstanceID ) ;

			// descriptions
			t_oRegAdapter.GetCurrentKeyValue( _T("DriverDesc"), t_chsCaption ) ;
			t_oRegAdapter.GetCurrentKeyValue( _T("Description"), t_chsDescription ) ;
		}

		// Get the service name
		CHString	t_chsServiceName ;
		CRegistry	t_RegNDI;
		CHString	t_chsNDIkey = t_chsCompleteKey + _T("\\Ndi" ) ;

		t_RegNDI.OpenLocalMachineKeyAndReadValue( t_chsNDIkey, _T("Service"), t_chsServiceName ) ;

		// linkage to the root device array
		CHStringArray	t_chsRootDeviceArray ;
		CHString		t_csLinkageKey = t_chsCompleteKey + _T("\\Linkage" ) ;

		if( ERROR_SUCCESS == t_oRegLinkage.Open( HKEY_LOCAL_MACHINE, t_csLinkageKey, KEY_READ ) )
		{
			CHStringArray t_chsRootDeviceArray ;

			if( ERROR_SUCCESS == t_oRegLinkage.GetCurrentKeyValue( _T("RootDevice"), t_chsRootDeviceArray ) )
			{
				// only one root device
				CHString t_chsRootDevice = t_chsRootDeviceArray.GetAt( 0 ) ;

				BOOL t_fIsRasIp = !t_chsRootDevice.CompareNoCase( L"NdisWanIp" ) ;

				// the RootDevice string is used to find the entry for the protocol
				// binding (TCP/IP)
				CHString t_csBindingKey ;
				t_csBindingKey = _T("SYSTEM\\CurrentControlSet\\Services\\tcpip\\Parameters\\Adapters\\" ) ;
				t_csBindingKey += t_chsRootDevice ;

				// IP interfaces
				CRegistry		t_RegBoundAdapter ;
				CRegistry		t_RegIpInterface ;
				CHString		t_chsIpInterfaceKey ;
				CHStringArray	t_chsaInterfaces ;
				DWORD			t_dwInterfaceCount = 0 ;

				if( ERROR_SUCCESS == t_RegBoundAdapter.Open( HKEY_LOCAL_MACHINE, t_csBindingKey, KEY_READ ) )
				{
					if( ERROR_SUCCESS == t_RegBoundAdapter.GetCurrentKeyValue( _T("IpConfig"), t_chsaInterfaces ) )
					{
						t_dwInterfaceCount = t_chsaInterfaces.GetSize() ;
					}
				}


				/* add this master adapter to the list
				*/

				// add an instance of one of these adapters
				if( !( t_pW2kInstance = new CW2kAdapterInstance ) )
				{
					throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
				}
				else
				{
					// add in the primary adapter
					t_pW2kInstance->dwIndex				= t_dwIndex ;
					t_pW2kInstance->chsPrimaryKey		= t_csAdapterKey ;
					t_pW2kInstance->chsCaption			= t_chsCaption ;
					t_pW2kInstance->chsDescription		= t_chsDescription ;
					t_pW2kInstance->chsCompleteKey		= t_chsCompleteKey ;
					t_pW2kInstance->chsService			= t_chsServiceName ;
					t_pW2kInstance->chsNetCfgInstanceID	= t_chsNetCfgInstanceID ;
					t_pW2kInstance->chsRootdevice		= t_chsRootDevice ;

					// indicate IpInterface for primary adapters not including RAS ( we'll handle RAS below )
					if( t_dwInterfaceCount && !t_fIsRasIp )
					{
						// Complete path to the nth bound adapter interface instance
						t_chsIpInterfaceKey = _T("SYSTEM\\CurrentControlSet\\Services\\" ) ;
						t_chsIpInterfaceKey += t_chsaInterfaces.GetAt( 0 ) ;

						t_pW2kInstance->chsIpInterfaceKey = t_chsIpInterfaceKey ;
					}

					Add( t_pW2kInstance ) ;
				}


				// Account for the RAS interfaces, which we add in addition to the primary interface.
				// Required to match the original implemenation under NT4 and the extentions to W2k.
				if( t_fIsRasIp )
				{
					// We use a bigger hammer to pound the large square peg of networking into
					// the small round hole of Win32_NetworkAdapterConfiguration and
					// it's associated class Win32_NetworkAdapter.

					DWORD t_dwInterfaceCount = t_chsaInterfaces.GetSize() ;

					// note all RAS interfaces that have a NTE context
					for( DWORD t_dw = 0; t_dw < t_dwInterfaceCount; t_dw++ )
					{
						// Complete path to the nth bound adapter interface instance
						t_chsIpInterfaceKey = _T("SYSTEM\\CurrentControlSet\\Services\\" ) ;
						t_chsIpInterfaceKey += t_chsaInterfaces.GetAt( t_dw ) ;

						CHString t_chsRasInterfaceGuid = t_chsNetCfgInstanceID;
					    WCHAR * pBegin = (WCHAR*)(LPCWSTR)t_chsaInterfaces.GetAt( t_dw );
                        WCHAR * pStrToParse = wcschr(pBegin,L'{');
                        if (pStrToParse && pStrToParse > pBegin)
                        {
                            t_chsRasInterfaceGuid = CHString(pStrToParse);
                        }
 

						// if a NTE context is present add in the interface
						if( ERROR_SUCCESS == t_RegIpInterface.Open( HKEY_LOCAL_MACHINE, t_chsIpInterfaceKey, KEY_READ ) )
						{

							BYTE  t_Buffer[ MAX_NTE_VALUE ] ;
							DWORD t_BufferLength = MAX_NTE_VALUE ;
							DWORD t_valueType ;

							// Does the stack know about this entry?
							if( ( ERROR_SUCCESS == RegQueryValueEx( t_RegIpInterface.GethKey(),
													_T("NTEContextList"),
													NULL,
													&t_valueType,
													&t_Buffer[0],
													&t_BufferLength ) ) &&
													(t_BufferLength > 2) ) // Wide NULL
							{
								// On the server side it is not sufficient to believe
								// ContextList is valid. RAS does not clean up after itself on this
								// end of the connection.
								// We'll test for the presence of an IP address which will confirm the
								// interface is active.
								if( IsIpPresent( t_RegIpInterface ) )
								{
									// add in the RAS interface
									if( !( t_pW2kInstance = new CW2kAdapterInstance ) )
									{
										throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
									}
									else
									{
										t_pW2kInstance->dwIndex				= (t_dwIndex << 16 ) | t_dw ;// allows for 65k of RAS interfaces
										t_pW2kInstance->chsPrimaryKey		= t_csAdapterKey ;
										t_pW2kInstance->chsCaption			= t_chsCaption ;
										t_pW2kInstance->chsDescription		= t_chsDescription ;
										t_pW2kInstance->chsCompleteKey		= t_chsCompleteKey ;
										t_pW2kInstance->chsService			= t_chsServiceName ;
										t_pW2kInstance->chsNetCfgInstanceID	= t_chsRasInterfaceGuid ;                     					
										t_pW2kInstance->chsRootdevice		= t_chsRootDevice ;
										t_pW2kInstance->chsIpInterfaceKey	= t_chsIpInterfaceKey ;
										Add( t_pW2kInstance ) ;
									}
								}
							}
						}
					}
				}
			}
		}
		t_NetReg.NextSubKey() ;

		t_fRet = TRUE ;
	}
	return t_fRet ;
}

//
BOOL CW2kAdapterEnum::IsIpPresent( CRegistry &a_RegIpInterface )
{
	CHString		t_chsDhcpIpAddress ;
	CHStringArray	t_achsIpAddresses ;

	// test dhcp ip for validity
	a_RegIpInterface.GetCurrentKeyValue( _T("DhcpIpAddress"), t_chsDhcpIpAddress ) ;

	// not empty and not 0.0.0.0
	if( !t_chsDhcpIpAddress.IsEmpty() &&
		 t_chsDhcpIpAddress.CompareNoCase( L"0.0.0.0" ) )
	{
		return TRUE ;
	}

	// test 1st ip for validity
	a_RegIpInterface.GetCurrentKeyValue( _T("IpAddress"), t_achsIpAddresses ) ;

	if( t_achsIpAddresses.GetSize() )
	{
		CHString t_chsIpAddress = t_achsIpAddresses.GetAt( 0 ) ;

		// not empty and not 0.0.0.0
		if( !t_chsIpAddress.IsEmpty() &&
			 t_chsIpAddress.CompareNoCase( L"0.0.0.0" ) )
		{
			return TRUE ;
		}
	}

	return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\videosettings.cpp ===
//=================================================================

//

// VideoSettings.CPP -- CodecFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//				 03/02/99    a-peterc		  added graceful exit on SEH and memory failures
//
//=================================================================

#include "precomp.h"
#include "VideoControllerResolution.h"
#include "VideoSettings.h"
#include <multimon.h>
#include <ProvExce.h>
#include "multimonitor.h"

// Property set declaration
//=========================

CWin32VideoSettings videoSettings(
	L"Win32_VideoSettings",
	IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoSettings::CWin32VideoSettings
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32VideoSettings::CWin32VideoSettings(
    LPCWSTR szName,
	LPCWSTR szNamespace) :
    Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoSettings::~CWin32VideoSettings
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32VideoSettings::~CWin32VideoSettings()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32VideoSettings::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32VideoSettings::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags /*= 0L*/)
{
    HRESULT         hResult = WBEM_S_NO_ERROR;
    CMultiMonitor   monitor;

    for (int i = 0; i < monitor.GetNumAdapters(); i++)
    {
        CHString strDeviceName;

        monitor.GetAdapterDisplayName(i, strDeviceName);

        EnumResolutions(
            pMethodContext,
            NULL,
            NULL,
            // If this OS doesn't support multi-monitor we'll have 'DISPLAY' as
            // the name, in which case we need to send NULL to the enum function.
            strDeviceName == L"DISPLAY" ? NULL : (LPCWSTR) strDeviceName,
            i);
    }

    return hResult;
}

typedef std::map<CHString, BOOL> STRING2BOOL;

HRESULT CWin32VideoSettings::EnumResolutions(
    MethodContext *pMethodContext,
    CInstance *pInstanceLookingFor,
    LPCWSTR szLookingForPath,
    LPCWSTR szDeviceName,
    int iAdapter)
{
    DEVMODE      devmode;
    HRESULT      hResult = pInstanceLookingFor ? WBEM_E_NOT_FOUND :
                                    WBEM_S_NO_ERROR;
	CInstancePtr pInst;
    STRING2BOOL  mapSettingID;

	// If doing a GetObject():
    // First see if this is the right adapter.  If not, get out.
    if (pInstanceLookingFor)
	{
        CHString strTemp;

        strTemp.Format(L"VIDEOCONTROLLER%d", iAdapter + 1);

		if (!wcsstr(szLookingForPath, strTemp))
            return WBEM_E_NOT_FOUND;
	}

	for (int i = 0;
         EnumDisplaySettings(TOBSTRT(szDeviceName), i, &devmode) &&
            (hResult == WBEM_S_NO_ERROR || hResult == WBEM_E_NOT_FOUND);
         i++)
	{
		CHString strID;

		// Convert the devmode to a string ID.
		CCIMVideoControllerResolution::DevModeToSettingID(&devmode, strID);

		// If we're doing a GetObject()...
		if (pInstanceLookingFor)
		{
			CHString    strCurrentPath,
                        strIDUpper;
            HRESULT     hresTemp;

            strIDUpper = strID;
            strIDUpper.MakeUpper();

            // If this ID has the setting ID we're looking for, try to
            // set the properties and verify the entire instance is correct.
            // This will help us throw out most of the entries
            // EnumDisplaySettings returns without having to SetProperties
            // on them all.
            if (wcsstr(szLookingForPath, strIDUpper))
            {
                hresTemp = SetProperties(pMethodContext, pInstanceLookingFor,
                                strID, iAdapter);

			    if (WBEM_S_NO_ERROR == hresTemp)
			    {
				    GetLocalInstancePath(pInstanceLookingFor, strCurrentPath);

				    // If this is the right setting id...
				    if (!strCurrentPath.CompareNoCase(szLookingForPath))
				    {
					    // We set the properties and found the right one, so get out.
					    hResult = WBEM_S_NO_ERROR;
					    break;
				    }
			    }
                else
                    hResult = hresTemp;
            }
		}
		// Must be doing an EnumerateInstances().
		else
		{
			// Have we seen this one yet?  We have to do this because some
            // dumb drivers will report the exact same resolution more than
            // once.
            if (mapSettingID.find(strID) == mapSettingID.end())
            {
                mapSettingID[strID] = true;

                pInst.Attach(CreateNewInstance(pMethodContext));

			    hResult = SetProperties(pMethodContext, pInst, strID, iAdapter);

			    if (WBEM_S_NO_ERROR == hResult)
				    hResult = pInst->Commit();
            }
		}
	}

	return hResult;
}

HRESULT CWin32VideoSettings::SetProperties(
    MethodContext *pMethodContext,
    CInstance *pInst,
    LPCWSTR szID,
    int iAdapter)
{
	HRESULT      hResult = WBEM_E_OUT_OF_MEMORY;
	CInstancePtr pinstVideoController,
				 pinstResolution;
	CHString     strTemp;

	CWbemProviderGlue::GetEmptyInstance(
		pMethodContext,
		L"Win32_VideoController",
		&pinstVideoController,
                GetNamespace());

	CWbemProviderGlue::GetEmptyInstance(
		pMethodContext,
		L"CIM_VideoControllerResolution",
		&pinstResolution,
                GetNamespace());

	if (pinstVideoController)
	{
		strTemp.Format(L"VideoController%d", iAdapter + 1);
		pinstVideoController->SetCHString(L"DeviceID", strTemp);

		GetLocalInstancePath(pinstVideoController, strTemp);
		pInst->SetCHString(L"Element", strTemp);

	    if (pinstResolution)
	    {
		    pinstResolution->SetCHString(L"SettingID", szID);

		    GetLocalInstancePath(pinstResolution, strTemp);
		    pInst->SetCHString (L"Setting", strTemp);

            hResult = WBEM_S_NO_ERROR;
	    }
    }

	return hResult;
}

HRESULT CWin32VideoSettings::GetObject(CInstance *pInstance, long lFlags)
{
    HRESULT         hResult = WBEM_E_NOT_FOUND;
    CMultiMonitor   monitor;
    CHStringList    listIDs;

    for (int i = 0; i < monitor.GetNumAdapters(); i++)
    {
        CHString    strDeviceName,
                    strLookingForPath;

        GetLocalInstancePath(pInstance, strLookingForPath);

        // Make search case insensitive.
        strLookingForPath.MakeUpper();

        monitor.GetAdapterDisplayName(i, strDeviceName);

        if (SUCCEEDED(hResult =
			EnumResolutions(
                pInstance->GetMethodContext(),
                pInstance,
                strLookingForPath,
                // If this OS doesn't support multi-monitor we'll have 'DISPLAY' as
                // the name, in which case we need to send NULL to the enum function.
                strDeviceName == L"DISPLAY" ? NULL : (LPCWSTR) strDeviceName,
                i)))
            break;
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\w2kenum.h ===
//=================================================================

//

// W2kEnum.h -- W2k enumeration support 

//

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/28/99            Created
//
//=================================================================
#ifndef _W2KENUM_H_
#define _W2KENUM_H_

class CW2kAdapterInstance
{
	public: 
		DWORD			dwIndex ;
		CHString		chsPrimaryKey ;
		CHString		chsCaption ;
		CHString		chsDescription ;	
		CHString		chsCompleteKey ;
		CHString		chsService ;
		CHString		chsNetCfgInstanceID ;
		CHString		chsRootdevice ;
		CHString		chsIpInterfaceKey ;
		
};

class CW2kAdapterEnum : public CHPtrArray
{
	private:
		BOOL GetW2kInstances() ;
		BOOL IsIpPresent( CRegistry &a_RegIpInterface ) ;

	public:        
		
		//=================================================
        // Constructors/destructor
        //=================================================
        CW2kAdapterEnum() ;
       ~CW2kAdapterEnum() ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\wbemtoolh.h ===
//============================================================

//

// WBEMToolH.h - ToolHelp.DLL access class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
//
//============================================================

#ifndef __WBEMTOOLHELP__
#define __WBEMTOOLHELP__

#include <tlhelp32.h>
#include "Kernel32Api.h"

typedef HANDLE (WINAPI *GETSNAPSHOT) (DWORD, DWORD) ;
typedef BOOL   (WINAPI *THREADWALK)  (HANDLE, LPTHREADENTRY32) ;
typedef BOOL   (WINAPI *PROCESSWALK) (HANDLE, LPPROCESSENTRY32) ;
typedef BOOL   (WINAPI *MODULEWALK)  (HANDLE, LPMODULEENTRY32) ;
typedef BOOL   (WINAPI *HEAPWALK)    (HANDLE, LPHEAPLIST32) ;


BOOL WINAPI Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);


class CToolHelp
{
    public :

        CToolHelp();
       ~CToolHelp();
        
        LONG Init();

        HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID) ;
		BOOL   Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte) ;
        BOOL   Thread32Next(HANDLE hSnapshot,  LPTHREADENTRY32 lpte) ;
        BOOL   Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe) ;
        BOOL   Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe) ;
        BOOL   Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme) ;
        BOOL   Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme) ;
        BOOL   Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl) ;

        DWORD  dwCookie ;
        
    private :

        //HMODULE     hLibHandle ;
        CKernel32Api *m_pkernel32;

        GETSNAPSHOT pCreateToolhelp32Snapshot ;
	    THREADWALK  pThread32First ;
        THREADWALK  pThread32Next ;
        PROCESSWALK pProcess32First ;
        PROCESSWALK pProcess32Next ;
        MODULEWALK  pModule32First ;
        MODULEWALK  pModule32Next ;
        HEAPWALK    pHeap32ListFirst ;
} ;

#endif // File inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\wbemntthread.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// WbemThread.h.cpp -- 

//                                                                  

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// 
// Revisions:    08/01/98    a-dpawar   Created                                                                 
//				 03/02/99	 a-peterc	Added graceful exit on SEH and memory failures,
//										clean up
//
///////////////////////////////////////////////////////////////////////

#ifndef WBEMNTThreadHelper_H_
#define WBEMNTThreadHelper_H_

class WbemThreadProvider;
class CThreadModel ;

class WbemNTThread : public CThreadModel
{
	private:
	
		enum eCOUNTERTYPES
		{
			e_IDThread = 0,
			e_IDProcess,
			e_ElapsedTime,
			e_PriorityBase,
			e_PriorityCurrent,
			e_StartAddr,
			e_ThreadState,
			e_ThreadWaitReason,
			e_ThreadObjectID,
			e_UserTime,
			e_PrivilegedTime
		} ;

		struct 
		{
			BOOL bInitialised ;
			DWORD aCounterIDs[11];
			TCHAR aCounterNames[11][255] ;
		} m_stCounterIDInfo ;

		CCritSec m_csInitReadOnlyData ;		

		WBEMSTATUS eGetThreadInstance( 
										DWORD a_dwPID,
										DWORD a_dwTID, 
										CInstance *a_pInst ) ;

		WBEMSTATUS eEnumerateThreads( 
										WbemThreadProvider *a_pProvider,
										MethodContext *a_pMethodContext ) ;

		WBEMSTATUS eSetStaticData() ;

		WBEMSTATUS eGetObjectData(
									DWORD a_dwObjectID,
									PPERF_DATA_BLOCK &a_rPerfData,
									PPERF_OBJECT_TYPE &a_rPerfObj ) ;

		WBEMSTATUS eGetAllData(
									PPERF_OBJECT_TYPE a_PerfObj, 
									PPERF_INSTANCE_DEFINITION a_PerfInst,
									CInstance *a_pInst ) ;

		WBEMSTATUS eGetData(
									PPERF_OBJECT_TYPE a_PerfObj,
									PPERF_COUNTER_BLOCK a_CntrData,
									PPERF_COUNTER_DEFINITION a_PerfCntrDefn, 
									PBYTE a_pVal ) ;

		WBEMSTATUS eGetCntrDefn(
									PPERF_OBJECT_TYPE a_PerfObj,
									DWORD a_dwTIDCntrID,
									PPERF_COUNTER_DEFINITION &a_rCntrDefn ) ;


		//helper fns. to traverse the perf. blob

		PPERF_OBJECT_TYPE			FirstObject( PPERF_DATA_BLOCK a_PerfData ) ;
		PPERF_OBJECT_TYPE			NextObject( PPERF_OBJECT_TYPE a_PerfObj ) ;
		PPERF_INSTANCE_DEFINITION	FirstInstance( PPERF_OBJECT_TYPE a_PerfObj ) ;
		PPERF_INSTANCE_DEFINITION	NextInstance(PPERF_INSTANCE_DEFINITION a_PerfInst ) ;

	public:


		WbemNTThread() ;
		~WbemNTThread() ;


		// overrides
		//==========
		virtual LONG fLoadResources() ;
		virtual LONG fUnLoadResources() ;
				
		// operations
		//=========== 
			
		// Pure implementations
		//================
		virtual WBEMSTATUS eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst ) ;
		virtual WBEMSTATUS eEnumerateThreadInstances( WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext );
} ;

#endif //WBEMNTThreadHelper_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\wbemntthread.cpp ===
//=======================================================================
//
// WbemNTThread.CPP --Contains class to processs NT Thread performance
// data form registry
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/98    a-dpawar        Created
//				 03/02/99	 a-peterc	Added graceful exit on SEH and memory failures,
//							 clean up
//=======================================================================

#include "precomp.h"
#include "perfdata.h"
#include "ThreadProv.h"
#include "WbemNTThread.h"

#include <tchar.h>
#include <ProvExce.h>
#include <LockWrap.h>

WbemNTThread::WbemNTThread()
{
	ZeroMemory ( &m_stCounterIDInfo , sizeof ( m_stCounterIDInfo ) ) ;
}

WbemNTThread::~WbemNTThread()
{
	// Because of performance issues with HKEY_PERFORMANCE_DATA, we close in the
	// destructor so we don't force all the performance counter dlls to get
	// unloaded from memory, and also to prevent an apparent memory leak
	// caused by calling RegCloseKey( HKEY_PERFORMANCE_DATA ).  We use the
	// class since it has its own internal synchronization.  Also, since
	// we are forcing synchronization, we get rid of the chance of an apparent
	// deadlock caused by one thread loading the performance counter dlls
	// and another thread unloading the performance counter dlls

    // Per raid 48395, we aren't going to shut this at all.
#ifdef NTONLY
//	CPerformanceData perfdata ;

//	perfdata.Close() ;
#endif
}


//Dummy ove-rides for fns in base CThreadModel class
//------------------------------------------------------------
// Support for resource allocation, initializations, DLL loads
//
//-----------------------------------------------------------
LONG WbemNTThread::fLoadResources()
{
	return ERROR_SUCCESS ;
}

//--------------------------------------------------
// Support for resource deallocation and DLL unloads
//
//--------------------------------------------------
LONG WbemNTThread::fUnLoadResources()
{
	return ERROR_SUCCESS ;
}


/*****************************************************************************
 *
 *  FUNCTION    : WbemNTThread::eGetThreadObject
 *
 *
 *  DESCRIPTION : Fills all the thread properties for the reqd. thread
 *				  in the passed CInstance ptr.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : WBEM_NO_ERROR on success
 *
 *  COMMENTS    :
 *
 *****************************************************************************/



WBEMSTATUS WbemNTThread::eGetThreadObject( WbemThreadProvider *a_pProvider, CInstance *a_pInst )
{
	WBEMSTATUS	t_eRetVal ;
	CHString	t_chsHandle;

	a_pInst->GetCHString( IDS_ProcessHandle, t_chsHandle ) ;
	DWORD t_dwProcessID = _wtol( t_chsHandle ) ;

	a_pInst->GetCHString( IDS_Handle, t_chsHandle ) ;
	DWORD t_dwThreadID = _wtol( t_chsHandle ) ;

	if ( SUCCEEDED ( eSetStaticData() ) )
	{
		//Get the thread specific properties
		t_eRetVal = eGetThreadInstance( t_dwProcessID, t_dwThreadID , a_pInst ) ;
	}
	else
	{
		t_eRetVal = WBEM_E_FAILED ;
	}

	if( SUCCEEDED( t_eRetVal ) )
	{
		// collect the common static properties
		return eLoadCommonThreadProperties( a_pProvider, a_pInst );
	}

	return t_eRetVal ;
}

/*****************************************************************************
 *
 *  FUNCTION    : WbemNTThread::eEnumerateThreadInstances
 *
 *
 *  DESCRIPTION : Creates CInstances & commits them for all threads in the system
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : WBEM_NO_ERROR on success
 *
 *  COMMENTS    :
 *
 *****************************************************************************/



WBEMSTATUS WbemNTThread::eEnumerateThreadInstances( WbemThreadProvider *a_pProvider,
													 MethodContext *a_pMethodContext )
{
	if ( SUCCEEDED ( eSetStaticData() ) )
	{
		return eEnumerateThreads( a_pProvider, a_pMethodContext ) ;
	}
	else
	{
		return WBEM_S_NO_ERROR ;
	}
}

/****************************************************************
 *                                                              *
 * Load the counter id's and names from the registry to the		*
 * class member struct stCounterIDInfo.							*
 *                                                              *
 ****************************************************************/

WBEMSTATUS WbemNTThread::eSetStaticData()
{
    HKEY	t_hKeyPerflib009 = NULL;	// handle to registry key
    DWORD	t_dwMaxValueLen	= 0;		// maximum size of key values
    DWORD	t_dwBuffer		= 0;        // bytes to allocate for buffers
    LPTSTR	t_lpCurrentString = NULL;	// pointer for enumerating data strings
    DWORD	t_dwCounter;				// current counter index
	LPTSTR	t_lpNameStrings = NULL;
	WBEMSTATUS t_eStatus = WBEM_E_FAILED ;
	try
	{
		// Open key containing counter and object names.
		CLockWrapper t_CSWrap ( m_csInitReadOnlyData ) ;

		if( m_stCounterIDInfo.bInitialised )
		{
			t_eStatus = WBEM_S_NO_ERROR ;
		}
		else
		{
			LONG t_lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
						_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009"),
						0,
						KEY_READ,
						&t_hKeyPerflib009 ) ;
			// Get the size of the largest value in the key (Counter or Help).
			if ( t_lRet == ERROR_SUCCESS )
			{
				t_lRet = RegQueryInfoKey( t_hKeyPerflib009,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										&t_dwMaxValueLen,
										NULL,
										NULL);

				// Allocate memory for the counter and object names.
				if ( t_lRet == ERROR_SUCCESS )
				{
					t_dwBuffer = ( t_dwMaxValueLen / sizeof ( TCHAR ) ) + 1 ;
					t_lpNameStrings = new TCHAR[ t_dwBuffer ] ;
					t_dwBuffer = t_dwBuffer * sizeof ( TCHAR ) ;

					if ( !t_lpNameStrings )
					{
						if ( t_hKeyPerflib009 )
						{
							RegCloseKey( t_hKeyPerflib009 ) ;
							t_hKeyPerflib009 = NULL ;
						}
        				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
					}

					DWORD t_Type = 0L;
					t_lRet = RegQueryValueEx(	t_hKeyPerflib009,
												_T("Counter"),
												NULL,
												&t_Type,
												(LPBYTE) t_lpNameStrings,
												&t_dwBuffer ) ;

					// Load id's & names into an array, by index.
					if ( t_lRet == ERROR_SUCCESS )
					{
						//
						// perform string check in
						//

						BOOL bContinue = TRUE;
						switch ( t_Type )
						{
							case REG_EXPAND_SZ:
							case REG_SZ:
							{
								if ( L'\0' != t_lpNameStrings [ ( ( t_dwBuffer ) / sizeof ( TCHAR ) ) - 1 ] )
								{
									bContinue = FALSE;
								}
								break;
							}
							case REG_MULTI_SZ:
							{
								if ( L'\0' != t_lpNameStrings [ ( ( t_dwBuffer ) / sizeof ( TCHAR ) ) - 2 ] &&
									 L'\0' != t_lpNameStrings [ ( ( t_dwBuffer ) / sizeof ( TCHAR ) ) - 1 ] )
								{
									bContinue = FALSE;
								}
								break;
							}
							default:
							{
								break;
							}
						}

						if ( bContinue )
						{
							DWORD t_dwCount = 0 ;
							for( t_lpCurrentString = t_lpNameStrings; *t_lpCurrentString && t_dwCount < 11 ;
								t_lpCurrentString += ( _tcslen( t_lpCurrentString ) + 1 ) )
							{
								t_dwCounter = _ttol( t_lpCurrentString ) ;

								t_lpCurrentString += ( _tcslen( t_lpCurrentString ) + 1 ) ;


								if( !_tcscmp( t_lpCurrentString, _T("ID Thread") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_IDThread ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_IDThread ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}

								else if ( !_tcscmp( t_lpCurrentString, _T("ID Process") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_IDProcess ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_IDProcess ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}

								else if ( !_tcscmp( t_lpCurrentString, _T("Elapsed Time") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_ElapsedTime ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_ElapsedTime ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}

								else if ( !_tcscmp( t_lpCurrentString, _T("Priority Base") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_PriorityBase ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_PriorityBase ] , t_lpCurrentString ) ;
									t_dwCount++ ;
								}

								else if ( !_tcscmp( t_lpCurrentString, _T("Priority Current") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_PriorityCurrent ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_PriorityCurrent ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}

								else if ( !_tcscmp( t_lpCurrentString, _T("Start Address") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_StartAddr ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_StartAddr ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}

								else if ( !_tcscmp( t_lpCurrentString, _T("Thread State") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_ThreadState ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_ThreadState ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}

								else if ( !_tcscmp( t_lpCurrentString, _T("Thread Wait Reason") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_ThreadWaitReason ] = t_dwCounter ;
									_tcscpy(m_stCounterIDInfo.aCounterNames[ e_ThreadWaitReason ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}

								else if ( !_tcscmp( t_lpCurrentString, _T("Thread") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_ThreadObjectID ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_ThreadObjectID ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}
								else if ( !_tcscmp( t_lpCurrentString, _T("% User Time") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_UserTime ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_UserTime ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}
								else if ( !_tcscmp( t_lpCurrentString, _T("% Privileged Time") ) )
								{
									m_stCounterIDInfo.aCounterIDs[ e_PrivilegedTime ] = t_dwCounter ;
									_tcscpy( m_stCounterIDInfo.aCounterNames[ e_PrivilegedTime ], t_lpCurrentString ) ;
									t_dwCount++ ;
								}
							}

							m_stCounterIDInfo.bInitialised = TRUE ;
							t_eStatus = WBEM_S_NO_ERROR ;
						}
					}
				}
			}
		}
	}
	catch( ... )
	{
		if( t_lpNameStrings )
		{
			delete[] t_lpNameStrings ;
			t_lpNameStrings = NULL ;
		}

		if ( t_hKeyPerflib009 )
		{
			RegCloseKey( t_hKeyPerflib009 ) ;
			t_hKeyPerflib009 = NULL ;
		}

		throw ;
	}

	if ( t_lpNameStrings )
	{
		delete[] t_lpNameStrings ;
		t_lpNameStrings = NULL ;
	}

	if ( t_hKeyPerflib009 )
	{
		RegCloseKey( t_hKeyPerflib009 ) ;
		t_hKeyPerflib009 = NULL ;
	}
	return t_eStatus ;
}

//
WBEMSTATUS WbemNTThread::eEnumerateThreads(WbemThreadProvider *a_pProvider, MethodContext *a_pMethodContext )
{
	PPERF_OBJECT_TYPE			t_PerfObj = 0;
	PPERF_INSTANCE_DEFINITION	t_PerfInst = 0;
	PPERF_DATA_BLOCK			t_PerfData = 0;

	DWORD t_dwObjectID = m_stCounterIDInfo.aCounterIDs[ e_ThreadObjectID ] ;

	WBEMSTATUS	t_eRetVal = WBEM_E_FAILED ;
	HRESULT		t_hResult = WBEM_S_NO_ERROR ;
	CInstancePtr t_pNewInst;

	try
	{
		// Get the Performance Data blob.
		// ===============================
		if( ( t_eRetVal = eGetObjectData( t_dwObjectID, t_PerfData, t_PerfObj ) ) != WBEM_NO_ERROR )
		{
            return t_eRetVal ;
		}

		// Get the first instance.
		// =======================

		t_PerfInst = FirstInstance( t_PerfObj ) ;

		// Retrieve all instances.
		// =======================
		//NOTE: The last instance is in fact the "_Total" (Threads) instance, so we disregard that.
		for( int t_i = 0; t_i < t_PerfObj->NumInstances - 1 && SUCCEEDED( t_hResult ); t_i++ )
		{
            t_pNewInst.Attach(a_pProvider->CreateNewInstance( a_pMethodContext ));

			//Get all possible properties for this instance

			t_eRetVal = eGetAllData( t_PerfObj, t_PerfInst, t_pNewInst ) ; //pass Cinstance here

			if( SUCCEEDED( t_eRetVal ) )
			{
                //load the non-instance specific properties for this thread
				t_eRetVal = eLoadCommonThreadProperties( a_pProvider, t_pNewInst ) ;
			}

			if( SUCCEEDED( t_eRetVal ) )
			{
            	t_hResult = t_pNewInst->Commit(  ) ;
			}

			//Get Next Instance

			t_PerfInst = NextInstance( t_PerfInst ) ;
		}

	}
	catch( ... )
	{
		if( (PBYTE) t_PerfData )
		{
			delete[] (PBYTE) t_PerfData ;
		}

		throw ;
	}

	//return eRetVal ; //some might return failure...so ??

	if( (PBYTE) t_PerfData )
	{
		delete[] (PBYTE) t_PerfData ;
		t_PerfData = NULL ;
	}

	//return eRetVal ; // some data might fail
	return WBEM_NO_ERROR;
}



/****************************************************************
 *                                                              *
 * Gets the performance blob from the registry
 *for the given Object (always Thread in this case)				*
 * class member struct m_stCounterIDInfo.						*
 *                                                              *
 ****************************************************************/


WBEMSTATUS WbemNTThread::eGetObjectData(
										DWORD a_dwObjectID,
										PPERF_DATA_BLOCK &a_rPerfData,
										PPERF_OBJECT_TYPE &a_rPerfObj )
{
	DWORD	t_dwBufSize	= 0 ;
    DWORD	t_dwType	= 0 ;
    LPBYTE	t_pBuf		= 0 ;
	TCHAR	t_szObjectID[255] ;
	WBEMSTATUS t_dwRetCode = WBEM_E_OUT_OF_MEMORY ;
    long t_lStatus = 0L;
	a_rPerfData = NULL;

	try
	{
		_ltot( a_dwObjectID, t_szObjectID, 10 ) ;

		for (;;)
		{
			t_dwBufSize += 0x20000;   // 128K

			t_pBuf = new BYTE[ t_dwBufSize ] ;

			if( !t_pBuf )
			{
            	throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			}

			t_lStatus = RegQueryValueEx(
											 HKEY_PERFORMANCE_DATA,
											 t_szObjectID, //"232"
											 0,
											 &t_dwType,
											 t_pBuf,
											 &t_dwBufSize
											);

			if ( t_lStatus == ERROR_MORE_DATA )
			{
				delete[] t_pBuf ;
				t_pBuf = NULL ;
				continue;
			}

			if ( t_lStatus )
			{
				//some failure has occured
                t_dwRetCode = (WBEMSTATUS) t_lStatus;
				break ;
			}

			//if we're here...we've got all the data
			t_dwRetCode = WBEM_NO_ERROR ;
			break ;

		}//for (;;)

		//	RegCloseKey(HKEY_PERFORMANCE_DATA);  See Dtor code

		if( t_dwRetCode == WBEM_NO_ERROR )
		{
			//we've got a valid blob..

			a_rPerfData = (PPERF_DATA_BLOCK) t_pBuf ;

			//check if the we've got data
			if ( a_rPerfData->NumObjectTypes > 0 )
			{
				//Skip the first object data as this is a Process Object
				a_rPerfObj = FirstObject( a_rPerfData ) ;

				//This Will be a Thread Object
				a_rPerfObj = NextObject( a_rPerfObj ) ;
			}
			else
			{
				a_rPerfData = NULL ;
				delete[] t_pBuf ;
				t_pBuf = NULL ;

				t_dwRetCode = WBEM_E_FAILED ;
			}
		}

		return t_dwRetCode ;
	}
	catch( ... )
	{
		if( t_pBuf )
		{
			delete[] t_pBuf ;
		}
		a_rPerfData = NULL ;

		throw ;
	}
}

/****************************************************************
 *                                                              *
 * Gets the performance data indicated by the current instance
 * block & fills it in the CInstance							*
 *																*
 *                                                              *
 ****************************************************************/

WBEMSTATUS WbemNTThread::eGetAllData(
									 PPERF_OBJECT_TYPE a_PerfObj,
									 PPERF_INSTANCE_DEFINITION a_PerfInst ,
									 CInstance *a_pInst )
{
	PPERF_COUNTER_DEFINITION	t_PerfCntrDefn = 0 ;
	PPERF_COUNTER_BLOCK			t_CntrData = 0 ;
	DWORD						t_dwProcessId = 0 ;
	WBEMSTATUS					t_eRetVal = WBEM_E_FAILED ;
	WCHAR						t_wcBuf2[255] ;

	//Buffer to get data values
	//Currently the max data size is __int64 (8 bytes)
	BYTE t_Val[ 8 ] ;

	t_CntrData = (PPERF_COUNTER_BLOCK) ( (PBYTE) a_PerfInst + a_PerfInst->ByteLength ) ;

	t_PerfCntrDefn = (PPERF_COUNTER_DEFINITION) ( (PBYTE) a_PerfObj + a_PerfObj->HeaderLength ) ;

	//any better ideas 4this?
/*
	pInstance->SetCHString(IDS_Name, (wchar_t*)((PBYTE)PerfInst + PerfInst->NameOffset) ) ;
	pInstance->SetCHString(IDS_Caption, (wchar_t*)((PBYTE)PerfInst + PerfInst->NameOffset) ) ;
	pInstance->SetCHString(IDS_Description, (wchar_t*)((PBYTE)PerfInst + PerfInst->NameOffset) ) ;
*/

	//Get Values for all possible counters

	for( DWORD t_i = 0; t_i < a_PerfObj->NumCounters ; t_i++ )
	{
		//Get Data for this Counter Defn
		if( ( t_eRetVal = eGetData( a_PerfObj, t_CntrData, t_PerfCntrDefn, t_Val) ) == WBEM_NO_ERROR )
		{
				if( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_IDThread ] )
				{
					//NOTE: On a dual processor, we get 2 instances of system-idle threads with tid = pid =0
					//		For each such occurance,we use the index value in the instance data as the tid.
					if ( t_dwProcessId == 0 )
					{
						if ( a_PerfInst->NameLength )
						{
                    		WCHAR * t_wcBuf = new WCHAR[ a_PerfInst->NameLength / sizeof ( WCHAR ) ] ;
							if ( t_wcBuf )
							{
								memcpy ( t_wcBuf, (PBYTE) a_PerfInst + a_PerfInst->NameOffset, a_PerfInst->NameLength ) ;
								a_pInst->SetWCHARSplat ( IDS_Handle, t_wcBuf ) ;

								delete [] t_wcBuf;
							}
							else
							{
								throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
							}
						}
					}
					else
					{
						_ltow( *( (LPDWORD) t_Val ), t_wcBuf2, 10 ) ;
						a_pInst->SetWCHARSplat( IDS_Handle, t_wcBuf2 ) ;
					}

				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_IDProcess ] )
				{
					_ltow( *( (LPDWORD) t_Val ), t_wcBuf2, 10 ) ;
					a_pInst->SetWCHARSplat( IDS_ProcessHandle, t_wcBuf2 ) ;
					t_dwProcessId = *( ( LPDWORD ) t_Val ) ;
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_ElapsedTime ] )
				{
					a_pInst->SetWBEMINT64( IDS_ElapsedTime, *( (__int64*) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_PriorityBase ])
				{
					a_pInst->SetDWORD( IDS_PriorityBase, *( (LPDWORD) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_PriorityCurrent ] )
				{
					a_pInst->SetDWORD( IDS_Priority, *( (LPDWORD) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_StartAddr ] )
				{
					a_pInst->SetDWORD( IDS_StartAddress, *( (LPDWORD) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_ThreadState ] )
				{
					a_pInst->SetDWORD( IDS_ThreadState, *( (LPDWORD) t_Val ) );
				}

				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_ThreadWaitReason ] )
				{
					a_pInst->SetDWORD( IDS_ThreadWaitReason, *( (LPDWORD) t_Val ) );
				}
				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_UserTime ] )
				{
					a_pInst->SetWBEMINT64( IDS_UserModeTime, *( (__int64*) t_Val ) );
				}
				else if ( t_PerfCntrDefn->CounterNameTitleIndex == m_stCounterIDInfo.aCounterIDs[ e_PrivilegedTime ] )
				{
					a_pInst->SetWBEMINT64( IDS_KernelModeTime, *( (__int64*) t_Val ) );
				}
		}
		else
		{

			//discontinue if error while seeking a desired counter

			for( int t_Count = 0 ; t_Count < 8 ; t_Count++ )
			{
				if( t_PerfCntrDefn->CounterType == m_stCounterIDInfo.aCounterIDs[ t_Count ] )
				{
					break ;
				}
			}
		}

		//Get Next Counter Defn
		t_PerfCntrDefn = (PPERF_COUNTER_DEFINITION) ( (PBYTE) t_PerfCntrDefn + t_PerfCntrDefn->ByteLength ) ;

	} //for

	return t_eRetVal ;
}



/****************************************************************
 *                                                              *
 * Gets the performance data indicated by the current instance
 * block & fills it in the passed in buffer						*
 *																*
 *                                                              *
 ****************************************************************/

 WBEMSTATUS WbemNTThread::eGetData(
									PPERF_OBJECT_TYPE a_PerfObj,
									PPERF_COUNTER_BLOCK a_CntrData,
									PPERF_COUNTER_DEFINITION a_PerfCntrDefn,
									PBYTE a_pVal )
{

    WBEMSTATUS	t_eRetVal = WBEM_E_FAILED ;
	__int64		t_PerfFreq,
				t_liDifference,
				t_PerfStartTime ;

	//Get the size in bytes of the data
	DWORD t_dwType = ( a_PerfCntrDefn->CounterType & 0x300 ) ;

	/////used for testing..
	DWORD t_SubType		= a_PerfCntrDefn->CounterType &  0x000f0000 ;
	DWORD t_dwx			= a_PerfCntrDefn->CounterType & 0x700 ;
  	DWORD t_TimerType	= a_PerfCntrDefn->CounterType &  0x00300000 ;
	int t_i				= ( t_TimerType == PERF_OBJECT_TIMER ) ;
	/////

	//Rt. now we check only for raw counters & elapsed counters & return error
	//for all other types

	switch( a_PerfCntrDefn->CounterType )
	{
		//case PERF_TYPE_NUMBER:
		case PERF_COUNTER_RAWCOUNT :

			if( t_dwType == PERF_SIZE_DWORD )
			{
				*( (LPDWORD) a_pVal ) = *( (LPDWORD) ( (PBYTE) a_CntrData + a_PerfCntrDefn->CounterOffset ) ) ;
				t_eRetVal = WBEM_NO_ERROR ;
			}

			break;
/*
 * On w2k, the counter for the startaddress is of this form
 */
		case PERF_COUNTER_RAWCOUNT_HEX :
			if( t_dwType == PERF_SIZE_DWORD )
			{
				*( (LPDWORD) a_pVal ) = *( (LPDWORD) ( (PBYTE) a_CntrData + a_PerfCntrDefn->CounterOffset ) ) ;
				t_eRetVal = WBEM_NO_ERROR ;
			}

			break;

		case PERF_ELAPSED_TIME :

			t_PerfFreq = *( (__int64 *) &( a_PerfObj->PerfFreq ) ) ;

			if( t_dwType == PERF_SIZE_LARGE )
			{
				t_PerfStartTime = *( (__int64 *) ( (PBYTE) a_CntrData + a_PerfCntrDefn->CounterOffset ) ) ;
				t_liDifference =  *( (__int64*) &a_PerfObj->PerfTime ) - t_PerfStartTime ;

				if( t_liDifference < ( (__int64) 0 ) )
				{
					*( (__int64*) a_pVal ) = (__int64) 0;
				}
				else
				{
					*( (__int64*) a_pVal ) = (t_liDifference / t_PerfFreq)*1000 ; //we're reporting elapsed time in milliseconds
				}

				t_eRetVal = WBEM_NO_ERROR ;
			}

			break;

/*
 * BobW-->The "%User Time" & "%Privileged Time" counters represent 100ns ticks.
 * We're not reporting the %age but the total time in ms so we don't need to take 2 samples as this counter type suggests.
 */
		case PERF_100NSEC_TIMER :
			if( t_dwType == PERF_SIZE_LARGE )
			{
				*( (__int64 *) a_pVal ) = *( (__int64 *) ( (PBYTE) a_CntrData + a_PerfCntrDefn->CounterOffset ) ) ;
				*( (__int64 *) a_pVal ) = (*( (__int64 *) a_pVal ) ) / 10000 ;
				t_eRetVal = WBEM_NO_ERROR ;
			}

			break;
	}

	return t_eRetVal ;

}



/****************************************************************
 *                                                              *
 * Gets the counter definition block indicated by the counter id*
 *																*
 *                                                              *
 ****************************************************************/

 WBEMSTATUS WbemNTThread::eGetCntrDefn(
										PPERF_OBJECT_TYPE a_PerfObj,
										DWORD a_dwCntrID,
										PPERF_COUNTER_DEFINITION &a_rCntrDefn )
{

	a_rCntrDefn = (PPERF_COUNTER_DEFINITION) ( (PBYTE) a_PerfObj + a_PerfObj->HeaderLength ) ;

	for( DWORD t_i = 0 ;t_i < a_PerfObj->NumCounters ; t_i++ )
	{
		//if found matching counter defn ...
		if( a_rCntrDefn->CounterNameTitleIndex == a_dwCntrID )
		{
			return WBEM_NO_ERROR ;
		}


		//get next counter defn.
		a_rCntrDefn = (PPERF_COUNTER_DEFINITION) ( (PBYTE) a_rCntrDefn + a_rCntrDefn->ByteLength ) ;
	}
	return WBEM_E_FAILED ;
}


WBEMSTATUS WbemNTThread::eGetThreadInstance(DWORD a_dwPID, DWORD a_dwTID, CInstance *a_pInst )
{
	WBEMSTATUS t_eRetVal = WBEM_E_FAILED ;

	DWORD t_dwPIDCntrID = m_stCounterIDInfo.aCounterIDs[ e_IDProcess ] ;
	DWORD t_dwTIDCntrID = m_stCounterIDInfo.aCounterIDs[ e_IDThread ] ;
	DWORD t_dwObjectID  = m_stCounterIDInfo.aCounterIDs[ e_ThreadObjectID ] ;

    PPERF_OBJECT_TYPE			t_PerfObj		= NULL ;
    PPERF_INSTANCE_DEFINITION	t_PerfInst		= 0 ;
    PPERF_COUNTER_DEFINITION	t_TIDCntrDefn	= 0,
								t_PIDCntrDefn	= 0 ;
    PPERF_COUNTER_BLOCK			t_CntrData		= 0 ;
    PPERF_DATA_BLOCK			t_PerfData		= 0 ;

	DWORD	t_dwPIDVal	= NULL,
			t_dwTIDVal	= NULL ;
	BOOL	t_bGotIt	= FALSE ;
	WCHAR	t_wcBuf[255] ;

	try
	{
		//Get Performance Blob for Threads
		if( ( t_eRetVal= eGetObjectData( t_dwObjectID, t_PerfData, t_PerfObj)) != WBEM_NO_ERROR )
		{
			return t_eRetVal ;
		}

		//Get "ID Process" Counter Defn
		t_eRetVal = eGetCntrDefn( t_PerfObj, t_dwPIDCntrID, t_PIDCntrDefn ) ;

		if( SUCCEEDED( t_eRetVal ) )
		{
			//Get "ID Thread" Counter Defn
			t_eRetVal = eGetCntrDefn( t_PerfObj, t_dwTIDCntrID, t_TIDCntrDefn ) ;
		}

		//check in all instances for matching PID & TID
		if( SUCCEEDED( t_eRetVal ) )
		{
			t_PerfInst = FirstInstance( t_PerfObj ) ;

			//NOTE: The last instance is in fact the "_Total" (Threads) instance, so we disregard that.
			for( int t_i = 0 ; t_i < t_PerfObj->NumInstances - 1; t_i++ )
			{
				t_CntrData = (PPERF_COUNTER_BLOCK) ( (PBYTE) t_PerfInst + t_PerfInst->ByteLength ) ;

				//check if PID matches
				if( ( t_eRetVal = eGetData( t_PerfObj, t_CntrData, t_PIDCntrDefn, (PBYTE) &t_dwPIDVal ) )
					== WBEM_NO_ERROR &&	t_dwPIDVal == a_dwPID )
				{
					//check if TID matches
					if( ( t_eRetVal = eGetData( t_PerfObj, t_CntrData, t_TIDCntrDefn, (PBYTE) &t_dwTIDVal ) )
						== WBEM_NO_ERROR )
					{
						//NOTE: On a dual processor, we get 2 instances of system-idle threads with tid = pid =0
						//		For each such occurance,we use the index value in the instance data as the tid.
						if ( a_dwPID == 0 )
						{
							ZeroMemory ( t_wcBuf, 255 * sizeof ( WCHAR ) ) ;
							memcpy ( t_wcBuf, (PBYTE) t_PerfInst + t_PerfInst->NameOffset, t_PerfInst->NameLength ) ;

							if ( a_dwTID == _wtoi ( t_wcBuf ) )
							{
								t_bGotIt = TRUE ;
								break ;
							}
						}
						else
						{
							if ( a_dwTID == t_dwTIDVal )
							{
								t_bGotIt = TRUE ;
								break ;
							}
						}
					}
				}

				t_PerfInst = (PPERF_INSTANCE_DEFINITION) ( (PBYTE) t_CntrData + t_CntrData->ByteLength ) ;

			} //check in all instances for matching PID & TID


			if( t_bGotIt )
			{
				//Get all the other properties for the matching Thread instance
				t_eRetVal = eGetAllData( t_PerfObj, t_PerfInst, a_pInst ) ; //pass Cinstance here
			}
			else
			{
				//failed to get matching instance
				if( SUCCEEDED( t_eRetVal ) )
				{
					t_eRetVal = WBEM_E_NOT_FOUND ;
				}
			}

		}  //if( (eRetVal == WBEM_NO_ERROR))

	}
	catch( ... )
	{
		if( t_PerfData )
		{
			delete[] (PBYTE) t_PerfData ;
		}

		throw ;
	}

	if( (PBYTE) t_PerfData )
	{
		delete[] (PBYTE) t_PerfData ;
		t_PerfData = NULL ;
	}

	return t_eRetVal ;
}



/*****************************************************************
 *                                                               *
 * Functions used to navigate through the performance data.      *
 *                                                               *
 *****************************************************************/

PPERF_OBJECT_TYPE WbemNTThread::FirstObject( PPERF_DATA_BLOCK a_PerfData )
{
    return ( (PPERF_OBJECT_TYPE)( (PBYTE) a_PerfData + a_PerfData->HeaderLength ) ) ;
}

PPERF_OBJECT_TYPE WbemNTThread::NextObject( PPERF_OBJECT_TYPE a_PerfObj )
{
    return ( (PPERF_OBJECT_TYPE) ( (PBYTE) a_PerfObj + a_PerfObj->TotalByteLength ) ) ;
}

PPERF_INSTANCE_DEFINITION WbemNTThread::FirstInstance( PPERF_OBJECT_TYPE a_PerfObj )
{
    return ( (PPERF_INSTANCE_DEFINITION) ( (PBYTE) a_PerfObj + a_PerfObj->DefinitionLength ) ) ;
}


PPERF_INSTANCE_DEFINITION WbemNTThread::NextInstance(PPERF_INSTANCE_DEFINITION a_PerfInst )
{
    PPERF_COUNTER_BLOCK t_PerfCntrBlk;

    t_PerfCntrBlk = (PPERF_COUNTER_BLOCK)( (PBYTE) a_PerfInst + a_PerfInst->ByteLength ) ;

    return ( (PPERF_INSTANCE_DEFINITION)( (PBYTE) t_PerfCntrBlk + t_PerfCntrBlk->ByteLength ) ) ;
}



/*
main()
{
	WbemNTThread t_my ;

	t_my.eSetStaticData() ;

	t_my.eGetThreadInstance( 784, 804, 48, 155, 232 ) ;

}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\wbemtoolh.cpp ===
//============================================================

//

// WBEMToolH.cpp - implementation of ToolHelp.DLL access class

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
// 07/05/97     a-peterc    modified, added thread support
//									, added addref(), release() functionality
//============================================================

#include "precomp.h"
#include <winerror.h>

#include "WBEMToolH.h"

/*****************************************************************************
 *
 *  FUNCTION    : CToolHelp::CToolHelp
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CToolHelp::CToolHelp()
    : m_pkernel32(NULL)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CToolHelp::~CToolHelp
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CToolHelp::~CToolHelp()
{
    if(m_pkernel32 != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, m_pkernel32);
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CToolHelp::Init
 *
 *  DESCRIPTION : Loads ToolHelp.DLL, locates entry points
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : ERROR_SUCCESS or windows error code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CToolHelp::Init() {

    LONG lRetCode = ERROR_SUCCESS ;
    SmartCloseHandle hSnapshot;
    HEAPLIST32 HeapInfo ;

    m_pkernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
    if(m_pkernel32 == NULL)
    {
        // Couldn't get one or more entry points
        //======================================
        lRetCode = ERROR_PROC_NOT_FOUND;
    }

    if(lRetCode == ERROR_SUCCESS)
    {
        if(m_pkernel32->CreateToolhelp32Snapshot(TH32CS_SNAPHEAPLIST, 0, &hSnapshot))
        {
            if(hSnapshot == INVALID_HANDLE_VALUE)
            {
                lRetCode = ERROR_PROC_NOT_FOUND ;
            }
            else
            {
                HeapInfo.dwSize = sizeof(HeapInfo) ;
                BOOL bRet = FALSE;
                if(m_pkernel32->Heap32ListFirst(hSnapshot, &HeapInfo, &bRet))
                {
                    if(!bRet)
                    {
                        lRetCode = ERROR_PROC_NOT_FOUND ;
                    }
                    else
                    {
                        dwCookie = DWORD(DWORD_PTR(GetProcessHeap())) ^ HeapInfo.th32HeapID ;
                    }
                }
            }
        }
    }

    return lRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CToolHelp::CreateToolhelp32Snapshot
 *                CToolHelp::Thread32First
 *                CToolHelp::Thread32Next
 *                CToolHelp::Process32First
 *                CToolHelp::Process32Next
 *                CToolHelp::Module32First
 *                CToolHelp::Module32Next
 *
 *  DESCRIPTION : ToolHelp function wrappers
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : ToolHelp return codes
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HANDLE CToolHelp::CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID) {

    HANDLE h = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->CreateToolhelp32Snapshot(dwFlags, th32ProcessID, &h) ;
    }
    return h;
}

BOOL CToolHelp::Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Thread32First(hSnapshot, lpte, &f) ;
    }
    return f;
}

BOOL CToolHelp::Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Thread32Next(hSnapshot, lpte, &f) ;
    }
    return f;
}

BOOL CToolHelp::Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Process32First(hSnapshot, lppe, &f) ;
    }
    return f;
}

BOOL CToolHelp::Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Process32Next(hSnapshot, lppe, &f) ;
    }
    return f;
}

BOOL CToolHelp::Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Module32First(hSnapshot, lpme, &f) ;
    }
    return f;
}

BOOL CToolHelp::Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme) {

    BOOL f = FALSE;
    if(m_pkernel32 != NULL)
    {
        m_pkernel32->Module32Next(hSnapshot, lpme, &f) ;
    }
    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32accountsid.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//
//	Win32AccountSID
//
//////////////////////////////////////////////////////
#ifndef __Win32ACCOUNTSID_H_
#define __Win32ACCOUNTSID_H_

#define  WIN32_ACCOUNT_SID_NAME L"Win32_AccountSID"

class Win32AccountSID : public Provider
{
private:
protected:
public:
	Win32AccountSID (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	~Win32AccountSID ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

};	// end class Win32LogicalFileSecuritySetting

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\wdmbase.cpp ===
//=================================================================

//

// WDMBase.cpp --

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08-Feb-1999	a-peterc        Created

//=================================================================

#include "precomp.h"

#include "WDMBase.h"
#include "wmiapi.h"



// Utilities

#define DEFAULT_MEM_SIZE 4096
//
//
CWdmInterface::CWdmInterface(){};
CWdmInterface::~CWdmInterface(){};

HRESULT CWdmInterface::hLoadBlock( CNodeAll& rNodeAll )
{
	HRESULT			hRes = WBEM_E_NOT_FOUND;
    WMIHANDLE		hCurrentWMIHandle = NULL;
	int				nRc;

    CWmiApi* pWmi = (CWmiApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWmiApi, NULL);
	__try
    {
        if(pWmi != NULL)
        {
            nRc = pWmi->WmiOpenBlock( &rNodeAll.GetGuid(), NULL, &hCurrentWMIHandle );

		    if( nRc != ERROR_SUCCESS )
			    __leave;

		    // make up to two passes at data retrieval
		    DWORD dwSize = DEFAULT_MEM_SIZE;
		    for( int i = 0; i < 2; i++ )
		    {
			    if( !rNodeAll.SetSize(dwSize) )
			    {
				    hRes = WBEM_E_OUT_OF_MEMORY;
				    __leave;
			    }

			    nRc = pWmi->WmiQueryAllData( hCurrentWMIHandle, &dwSize, rNodeAll.pGetBlock() );

			    if(ERROR_SUCCESS != nRc)
				    __leave;

			    if(dwSize <= DEFAULT_MEM_SIZE)
				    break;
		    }

		    if(!rNodeAll.pGetBlock()->WnodeHeader.BufferSize)
		    {
			    rNodeAll.FreeBlock();
			    __leave;
		    }

		    hRes = S_OK;
	    }
	}	// end __try


	__finally
    {
 		if(pWmi != NULL)
        {
			pWmi->WmiCloseBlock( hCurrentWMIHandle );
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWmiApi, pWmi);
            pWmi = NULL;
        }
    }

	return hRes;
}



//
CNodeAll::CNodeAll(  WCHAR * pwcsGuidString )
{
	m_pbDataBuffer = NULL;


	if( !SetGuid( pwcsGuidString ) )
		memset( &m_Guid, 0, sizeof(GUID) );

	vReset();
}

//
void CNodeAll::vReset()
{
	m_pAllWnode			= NULL;
	m_pbWorkingDataPtr	= NULL;
	m_pbCurrentDataPtr	= NULL;
	m_pMaxPtr			= NULL;
	m_dwAccumulativeSizeOfBlock = 0L;

	m_nCurrentInstance	= 0L;
	m_uInstanceSize		= 0L;
}

//
CNodeAll::~CNodeAll()
{
	FreeBlock();
}

GUID CNodeAll::GetGuid()
{
	return m_Guid;
}

/* ==========================================================================
 Function:  BOOL CNodeAll::SetGuid(TCHAR * pwcsGuidString)

 Description: Convert a string GUID to a CLSID

 Caveats:
 Raid:
 Notes:

 History:	a-peterc  08-Feb-1999     Created
 ========================================================================== */
BOOL CNodeAll::SetGuid(LPCWSTR pcsGuidString)
{
    CHString chsGuid(pcsGuidString);
    WCHAR wcsGuid[MAX_PATH+2];
	HRESULT hr;
    BOOL fRc = TRUE;

	swprintf(wcsGuid,L"{%s}", chsGuid );
    hr = CLSIDFromString(wcsGuid, &m_Guid);
    if (hr != S_OK){
	    hr = CLSIDFromString( chsGuid.GetBuffer(0), &m_Guid);
		if (hr != S_OK){
			fRc = FALSE;
		}
    }
    return fRc;
}

BOOL CNodeAll::SetSize( DWORD dwSize )
{
	FreeBlock();
	vReset();

	if( m_pbDataBuffer = (PWNODE_ALL_DATA)new BYTE[dwSize] )
	{
		memset(m_pbDataBuffer, 0, dwSize);
		return TRUE;
	}
	else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		return FALSE;
    }
}

PWNODE_ALL_DATA CNodeAll::pGetBlock()
{
	return m_pbDataBuffer;
}
//
void CNodeAll::FreeBlock()
{
	if(m_pbDataBuffer)	{
		delete m_pbDataBuffer;
		m_pbDataBuffer = NULL;
	}
}

//
bool CNodeAll::FirstInstance()
{
	if( !SetAllInstanceInfo() )
		return FALSE;

	if( !InitializeInstancePtr() )
		return FALSE;

	return TRUE;
}

//
bool CNodeAll::NextInstance()
{
	if( !GetNextNode() )
		return FALSE;

	if( !InitializeInstancePtr() )
		return FALSE;

    return TRUE;
}

//
bool CNodeAll::InitializeInstancePtr()
{
	m_nCurrentInstance++;
	m_dwAccumulativeSizeOfBlock = 0L;

	//================================================================
	//   Get pointer to the data offsets
	//================================================================

	if(m_pAllWnode->WnodeHeader.Flags &  WNODE_FLAG_FIXED_INSTANCE_SIZE)
	{
		//========================================================
	    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then
		// FixedInstanceSize specifies the size of each data block.
		//========================================================
		// traverse all instances of requested class
		//========================================================
        if( m_nCurrentInstance == 1 ){
            m_pbWorkingDataPtr = m_pbCurrentDataPtr;
        }
		else{
			// otherwise, we are going to calculate where it should go next
			m_pbWorkingDataPtr = (BYTE*) (ULONG *)OffsetToPtr(m_pbCurrentDataPtr, ( (m_nCurrentInstance -1) * m_pAllWnode->FixedInstanceSize ));
		}
	}
	else
	{
		//====================================================
		//
	    // If WMI_FLAG_FIXED_DATA_SIZE is not set then
		// OffsetInstanceData data is an array of ULONGS that
		// specifies the offsets to the data blocks for each
		// instance. In this case there is an array of
		// InstanceCount ULONGs followed by the data blocks.
		//
        // struct {
        //     ULONG OffsetInstanceData;
        //     ULONG LengthInstanceData;
        // } OffsetInstanceDataAndLength[]; /* [InstanceCount] */
		//====================================================
        ULONG uOffset;
		memcpy( &uOffset, m_pbCurrentDataPtr, sizeof(ULONG) );

		if( !uOffset )
		{
			return FALSE;
		}
        else
		{
		    m_pbCurrentDataPtr += sizeof( ULONG );

    		memcpy( &m_uInstanceSize, m_pbCurrentDataPtr, sizeof(ULONG) );
	    	m_pbCurrentDataPtr += sizeof( ULONG );
            m_pbWorkingDataPtr =(BYTE*) (ULONG *)OffsetToPtr(m_pAllWnode, uOffset);
        }
    }

    return TRUE;
}
//
BOOL CNodeAll::InitializeDataPtr()
{
    if ( !m_pAllWnode || !m_pAllWnode->WnodeHeader.BufferSize)
		return FALSE;

	//=====================================================
    //  Either the m_pAllWnode or m_pSingleNode is Null,
    //  which ever isn't, is the type we are working with
    //=====================================================
    if(m_pAllWnode){
		if( m_pAllWnode->WnodeHeader.Flags &  WNODE_FLAG_FIXED_INSTANCE_SIZE )
		{
			m_pbCurrentDataPtr =(BYTE*) (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->DataBlockOffset);
		}
		else{
            m_pbCurrentDataPtr =(BYTE*)(ULONG*) m_pAllWnode->OffsetInstanceDataAndLength;
		}
		m_pMaxPtr = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->WnodeHeader.BufferSize);
    }
/*    else{
        if( m_pSingleWnode ){
		    m_fFixedInstance = TRUE;
            m_pbCurrentDataPtr = (BYTE*)(ULONG *)OffsetToPtr(m_pSingleWnode, m_pSingleWnode->DataBlockOffset);
		    m_pMaxPtr = (ULONG *)OffsetToPtr(m_pSingleWnode, m_pHeaderWnode->WnodeHeader.BufferSize);
        }
    }
*/	if( (ULONG*)m_pbCurrentDataPtr > (ULONG*) m_pMaxPtr ){
		return FALSE;
	}
	if( (ULONG*) m_pbCurrentDataPtr < (ULONG*) m_pAllWnode ){
		return FALSE;
	}
	return TRUE;
}

//=============================================================
bool CNodeAll::GetNextNode()
{
    BOOL fRc = FALSE;

	if( !m_pAllWnode )
		return FALSE;

	if (m_pAllWnode->WnodeHeader.Linkage == 0){
        if( m_nCurrentInstance < m_nTotalInstances ){
			m_upNameOffsets++;
			fRc = TRUE;
        }
    }
    else{
        m_pAllWnode = (PWNODE_ALL_DATA)OffsetToPtr(m_pAllWnode, m_pAllWnode->WnodeHeader.Linkage);
        m_nCurrentInstance = 0;
		m_upNameOffsets = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->OffsetInstanceNameOffsets);
	   	fRc = TRUE;
	}

	if(fRc)
		fRc = InitializeDataPtr();

 	return fRc;
}

//=============================================================
// CIM_SINT8
bool CNodeAll::GetInt8(__int8& int8)
{
	if( !NaturallyAlignData( CIM_SINT8, TRUE ) )
		return FALSE;

	memcpy( &int8,m_pbWorkingDataPtr,sizeof(__int8));
	m_pbWorkingDataPtr += sizeof(__int8);
	return TRUE;
}

//=============================================================
// CIM_UINT8
bool CNodeAll::GetByte(BYTE & bByte)
{
	if( !NaturallyAlignData( CIM_UINT8, TRUE ) )
		return FALSE;

	memcpy( &bByte,m_pbWorkingDataPtr,sizeof(BYTE));
	m_pbWorkingDataPtr += sizeof(BYTE);
	return TRUE;
}

//=============================================================
// CIM_SINT16
bool CNodeAll::GetInt16(__int16 & int16)
{
    if( !NaturallyAlignData( CIM_SINT16, TRUE ) )
		return FALSE;

	memcpy( &int16,m_pbWorkingDataPtr,sizeof(__int16));
	m_pbWorkingDataPtr += sizeof(__int16);
	return TRUE;
}

//=============================================================
// CIM_UINT16
bool CNodeAll::GetWord(WORD & wWord)
{
    if( !NaturallyAlignData( CIM_UINT16, TRUE ) )
		return FALSE;

	memcpy( &wWord,m_pbWorkingDataPtr,sizeof(WORD));
	m_pbWorkingDataPtr += sizeof(WORD);
	return TRUE;
}

//=============================================================
// CIM_SINT32
bool CNodeAll::GetInt32(__int32 & int32)
{
	if( !NaturallyAlignData( CIM_SINT32, TRUE ) )
		return FALSE;

	memcpy( &int32,m_pbWorkingDataPtr,sizeof(__int32));
	m_pbWorkingDataPtr += sizeof(__int32);
	return TRUE;
}
//=============================================================
// CIM_UINT32
bool CNodeAll::GetDWORD(DWORD & dwWord)
{
    if( !NaturallyAlignData( CIM_UINT32, TRUE ) )
		return FALSE;

	memcpy( &dwWord,m_pbWorkingDataPtr,sizeof(DWORD));
	m_pbWorkingDataPtr += sizeof(DWORD);
	return TRUE;
}

//=============================================================
// CIM_SINT64
bool CNodeAll::GetSInt64(WCHAR * pwcsBuffer)
{
    if( !NaturallyAlignData( CIM_SINT64, TRUE ) )
		return FALSE;

	signed __int64 * pInt64;
	pInt64 = (__int64 *)m_pbWorkingDataPtr;
	swprintf(pwcsBuffer,L"%I64d",*pInt64);
	m_pbWorkingDataPtr += sizeof( signed __int64);
	return TRUE;
}
//=============================================================
// CIM_SINT64
bool CNodeAll::GetUInt64(WCHAR * pwcsBuffer)
{
    if( !NaturallyAlignData( CIM_SINT64, TRUE ) )
		return FALSE;

	unsigned __int64 * puInt64;
	puInt64 = (unsigned __int64 *)m_pbWorkingDataPtr;
	swprintf(pwcsBuffer,L"%I64u",*puInt64);
	m_pbWorkingDataPtr += sizeof(unsigned __int64);
	return TRUE;
}

//=============================================================
// CIM_REAL32
bool CNodeAll::GetFloat(float & fFloat)
{
    if( !NaturallyAlignData( CIM_REAL32, TRUE ) )
		return FALSE;

    memcpy( &fFloat,m_pbWorkingDataPtr,sizeof(float));
	m_pbWorkingDataPtr += sizeof(float);
	return TRUE;
}

//=============================================================
// CIM_REAL64
bool CNodeAll::GetDouble(DOUBLE & dDouble)
{
    if( !NaturallyAlignData( CIM_REAL64, TRUE ) )
		return FALSE;

    memcpy( &dDouble,m_pbWorkingDataPtr,sizeof(DOUBLE));
    m_pbWorkingDataPtr += sizeof(DOUBLE);
	return TRUE;
}

//=============================================================
// CIM_BOOLEAN
bool CNodeAll::GetBool(BYTE & bByte)
{
	return GetByte(bByte);
}

//=============================================================
// CIM_STRING
bool CNodeAll::GetString(CHString& rString)
{
    bool fBool = FALSE;
	WORD wCount = 0;

	// length of string
	GetWord(wCount);

	if( wCount > 0 )
	{
		if( CurrentPtrOk((ULONG)(wCount)) )
		{
			WCHAR * pBuffer = new WCHAR[wCount+4];
			if(pBuffer)
			{
                try
                {
				    memset(pBuffer,NULL,wCount+4);

				    vGetString(pBuffer, wCount);

				    rString = pBuffer;
                }
                catch ( ... )
                {
    				delete pBuffer;
                    throw ;
                }
				delete pBuffer;

				m_dwAccumulativeSizeOfBlock += wCount;
				fBool = TRUE;
			}
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

		}
	}
	else{
		rString = "";
	}

	return fBool;
}

//=============================================================
// CIM_STRING
void CNodeAll::vGetString(WCHAR * pwcsBuffer,WORD wCount)
{
    memset(pwcsBuffer,NULL,wCount);
	memcpy(pwcsBuffer,m_pbWorkingDataPtr, wCount);
	m_pbWorkingDataPtr += wCount;
}

//=============================================================
// CIM_DATETIME
bool CNodeAll::GetWbemTime(CHString& rString)
{
	if( !NaturallyAlignData( SIZEOFWBEMDATETIME, TRUE ) )
		return FALSE;

	WCHAR Buffer[SIZEOFWBEMDATETIME+2];
	memset( Buffer,NULL,SIZEOFWBEMDATETIME+2 );

	vGetString( Buffer, SIZEOFWBEMDATETIME );

	rString = Buffer;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////
bool CNodeAll::GetInstanceName( CHString& rInstanceName )
{
    bool fBool = FALSE;
    ULONG * upNameOffset = NULL;

	//=====================================================
	//  Either the m_pAllWnode or m_pSingleNode is Null,
	//  which ever isn't, is the type we are working with
	//=====================================================
	if( m_pAllWnode )
	{
		if( IsBadReadPtr( m_upNameOffsets, sizeof( ULONG *)) == 0 )
		{
			upNameOffset = ((ULONG *)OffsetToPtr(m_pAllWnode, *m_upNameOffsets));
		}
	}
	else{
		upNameOffset = m_upNameOffsets;
	}

	if( IsBadReadPtr( upNameOffset, sizeof( ULONG *)) == 0 )
	{
		if((ULONG *) (upNameOffset) < m_pMaxPtr )
		{
    		//================================================================
			//   Get pointer to the name offsets & point to next one
			//================================================================
			BYTE* pbData = (LPBYTE)upNameOffset;

			if( PtrOk((ULONG*)pbData,(ULONG)0) )
			{
				if( pbData )
				{
					SHORT NameLen = *(USHORT*)pbData;
					pbData += sizeof(USHORT);

					if( PtrOk((ULONG*)pbData,(ULONG)NameLen) )
					{
						WCHAR wName[NAME_SIZE+2];

						memset( wName, NULL, NAME_SIZE+2);
						memcpy( wName, pbData, min(NameLen, NAME_SIZE+2) );

						rInstanceName = wName;

						fBool = TRUE;
					}
				}
			}
		}
	}
    return fBool;
}

//////////////////////////////////////////////////////////////////////
int CNodeAll::GetWMISize(long lType)
{
	int nWMISize = 0;

    switch(lType){
		//	CIM_SINT8	= 16,
		//	CIM_UINT8	= 17,
		case VT_I1:
		case VT_UI1:
			nWMISize = sizeof(BYTE);
			break;

		//	CIM_SINT16	= 2,
		//	CIM_UINT16	= 18,
		case VT_I2:
		case CIM_CHAR16:
		case VT_UI2:
			nWMISize = sizeof(short);
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:
		case VT_UI4:
			nWMISize = sizeof(DWORD);
			break;

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		case VT_I8:
		case VT_UI8:
	        nWMISize = sizeof(__int64);
			break;

		//	CIM_REAL32	= 4,
		case VT_R4:
			nWMISize = sizeof(float);
			break;

	//	CIM_REAL64	= 5,
		case VT_R8:
			nWMISize = sizeof(double);
			break;

	//	CIM_BOOLEAN	= 11,
		case VT_BOOL:
	        nWMISize = sizeof(BYTE);
			break;

		case CIM_DATETIME:
			nWMISize = SIZEOFWBEMDATETIME;
			break;

		case CIM_STRING:
			nWMISize = 2;
			break;

		default:
			//	CIM_STRING	= 8,
			//	CIM_REFERENCE	= 102,
			//	CIM_OBJECT	= 13,
			//	CIM_FLAG_ARRAY	= 0x2000
 			nWMISize = 0;
	}

	return nWMISize;
}

//////////////////////////////////////////////////////////////////////
BOOL CNodeAll::NaturallyAlignData( long lType, BOOL fRead )
{
    BOOL fRc = FALSE;
	DWORD dwBytesToPad = 0;
	int nSize = GetWMISize( lType );

	if( m_dwAccumulativeSizeOfBlock != 0 ){

		DWORD dwMod;
		int nNewSize = nSize ? nSize : 1;

        if( nSize == SIZEOFWBEMDATETIME ){
			nNewSize = 2;
		}

		dwMod = (nNewSize != 0) ? m_dwAccumulativeSizeOfBlock % nNewSize : 0;

		if( dwMod > 0 ){
			dwBytesToPad = (DWORD)nNewSize - dwMod;
        }
	}
    if( fRead ){
   	    if( CurrentPtrOk((ULONG)(dwBytesToPad+nSize)) ){
            fRc = TRUE;
        }
        else{
            dwBytesToPad = 0;
        }
    }
	else{
		fRc = TRUE;
	}
    AddPadding(dwBytesToPad);
    m_dwAccumulativeSizeOfBlock += nSize + dwBytesToPad;

    return fRc;
}

//=============================================================
bool CNodeAll::SetAllInstanceInfo()
{
   bool bState = FALSE;
	if( m_pbDataBuffer ){
      	m_pAllWnode = (PWNODE_ALL_DATA)m_pbDataBuffer;
		m_upNameOffsets = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->OffsetInstanceNameOffsets);
	    m_nCurrentInstance = 1;
	    m_nTotalInstances = m_pAllWnode->InstanceCount;

		if( m_nTotalInstances > 0 ){
			if( InitializeDataPtr()){
				bState = TRUE;
			}
		}
		else{
			bState = FALSE;
		}
	}
    return bState;
}



//=============================================================
void CNodeAll::AddPadding(DWORD dwBytesToPad)
{
	m_pbWorkingDataPtr += dwBytesToPad;
}

//=============================================================
inline BOOL CNodeAll::PtrOk(ULONG * pPtr,ULONG uHowMany)
{
    ULONG * pNewPtr;
	pNewPtr = (ULONG *)OffsetToPtr(pPtr,uHowMany);
	if(pNewPtr <= m_pMaxPtr ){
		return TRUE;
	}
	return FALSE;
}
//=============================================================
BOOL CNodeAll::CurrentPtrOk(ULONG uHowMany)
{
    return(PtrOk((ULONG *)m_pbWorkingDataPtr,uHowMany));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32accountsid.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//	Win32AccountSid.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "sid.h"
#include "win32accountsid.h"

/*
    [Dynamic, description("The SID of an account.  Every account has "
        "a SID, but not every SID has an account")]
class Win32_AccountSID : CIM_ElementSetting
{
        [Description (
        ""
        ) , Read, Key]
    Win32_Account ref Element;

        [Description (
        ""
        ) , Read, Key]
    Win32_SID ref Setting;
};

*/

Win32AccountSID MyAccountSid( WIN32_ACCOUNT_SID_NAME, IDS_CimWin32Namespace );

Win32AccountSID::Win32AccountSID ( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/ )
: Provider (setName,pszNameSpace)
{
}

Win32AccountSID::~Win32AccountSID ()
{
}

HRESULT Win32AccountSID::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pInstance;

    // Collections
    TRefPointerCollection<CInstance>	accountList;

    // Perform queries
    //================

//    if (SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances(L"Win32_Account",
//        &accountList, pMethodContext, IDS_CimWin32Namespace)))

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"SELECT __RELPATH, SID FROM Win32_Account",
        &accountList, pMethodContext, GetNamespace())))
    {
        REFPTRCOLLECTION_POSITION	pos;

        CInstancePtr	pAccount;

        if ( accountList.BeginEnum( pos ) )
        {

            while (SUCCEEDED(hr)  && (pAccount.Attach(accountList.GetNext(pos)), pAccount != NULL))
            {
                //pAccount.Attach(accountList.GetNext(pos));
                //if(pAccount != NULL)
                {
                    CHString chsSid;
                    pAccount->GetCHString(IDS_SID, chsSid);

                    PSID pSid = StrToSID(chsSid);

                    CSid sid (pSid, NULL);

                    if (pSid != NULL)
                    {
                        FreeSid(pSid);
                    }

                    if (sid.IsValid())
                    {
                        pInstance.Attach(CreateNewInstance(pMethodContext));
					    if (NULL != pInstance)
					    {
	                        // set relpath to account
	                        CHString chsAccountPath;
	                        CHString chsFullAccountPath;
	                        pAccount->GetCHString(L"__RELPATH", chsAccountPath);
	                        chsFullAccountPath.Format(L"\\\\%s\\%s:%s", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, (LPCTSTR)chsAccountPath);
	                        pInstance->SetCHString(IDS_Element, chsFullAccountPath);

	                        // create a relpath for the sid
	                        CHString sidPath;
	                        sidPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, L"Win32_SID", IDS_SID, (LPCTSTR)chsSid);

	                        // and set the reference in the association
	                        pInstance->SetCHString(IDS_Setting, sidPath);
	                        // to that relpath.
	                        hr = pInstance->Commit();
					    }	// end if

                    }
                }	// WHILE GetNext
            } // pAccount not null

            accountList.EndEnum();

        }	// IF BeginEnum

    }
    return(hr);

}

HRESULT Win32AccountSID::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    // get the object for the Win32_Account Element
    CHString chsAccount;
    CInstancePtr pAccountInstance;
    pInstance->GetCHString(IDS_Element, chsAccount);
    MethodContext* pMethodContext = pInstance->GetMethodContext();

    hr = CWbemProviderGlue::GetInstanceByPath(chsAccount, &pAccountInstance, pMethodContext);
    if (SUCCEEDED(hr))
    {
        // we got the account.  Now, we can match it to the SID.
        // first, we have to generate a relpath with which to compare.
        CHString chsSid;
        CHString sidInstance;
        pAccountInstance->GetCHString(IDS_SID, chsSid);

        PSID pSid = NULL;
        try
        {
            pSid = StrToSID(chsSid);
        }
        catch(...)
        {
            if(pSid != NULL)
            {
                FreeSid(pSid);
                pSid = NULL;
            }
            throw;
        }

        CSid sid (pSid, NULL);
        if (pSid != NULL)
        {
            FreeSid(pSid);
            pSid = NULL;
        }


        if (sid.IsValid())
        {
            // create a relpath for the sid
            CHString sidPath;
            sidPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, L"Win32_SID", IDS_SID, (LPCTSTR)chsSid);

            // now, get the SID path from the instance
            pInstance->GetCHString(IDS_Setting, sidInstance);

            // compare it to our generated relpath
            if (0 != sidInstance.CompareNoCase(sidPath))
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\wdmbase.h ===
//=================================================================

//

// WDMBase.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08-Feb-1999	a-peterc        Created

//=================================================================

#include <wmium.h>


class CNodeAll;
class WdmInterface;

class CWdmInterface
{
    public:
	        
        //=================================================
        // Constructor/destructor
        //=================================================
		CWdmInterface();
		~CWdmInterface();
	
	   HRESULT hLoadBlock( CNodeAll& rNodeAll );
	  
	protected:
	private:
};

#define NAME_SIZE 256*2
#define SIZEOFWBEMDATETIME sizeof(WCHAR)*25
#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

class CNodeAll
{
    public:
	        
        //=================================================
        // Constructor/destructor
        //=================================================
      	CNodeAll( WCHAR * pwcsGuidString );
       ~CNodeAll();
	
		BOOL SetSize( DWORD dwSize );
		void FreeBlock();
		PWNODE_ALL_DATA pGetBlock();
		bool FirstInstance();
		bool NextInstance();
		GUID  GetGuid();

		bool GetInt8(__int8& int8);
		bool GetByte(BYTE & bByte);
		bool GetInt16(__int16 & int16);
		bool GetWord(WORD & wWord);
		bool GetInt32(__int32 & int32);
		bool GetDWORD(DWORD & dwWord);
		bool GetSInt64(WCHAR * pwcsBuffer);
		bool GetUInt64(WCHAR * pwcsBuffer);
		bool GetFloat(float & fFloat);
		bool GetDouble(DOUBLE & dDouble);
		bool GetBool(BYTE & bByte);
		bool GetString(CHString& rString);
		bool GetWbemTime(CHString& rString);
		bool GetInstanceName( CHString& rInstanceName );
		int  GetWMISize(long lType);

	protected:
	private:
		GUID	m_Guid;
		PWNODE_ALL_DATA m_pbDataBuffer;
		PWNODE_ALL_DATA m_pAllWnode;
		
		BYTE*	m_pbWorkingDataPtr;
		BYTE*	m_pbCurrentDataPtr;
		ULONG*	m_pMaxPtr;
		ULONG*	m_upNameOffsets;

		ULONG	m_uInstanceSize;
		int		m_nTotalInstances;
		int		m_nCurrentInstance;
		DWORD	m_dwAccumulativeSizeOfBlock;

		BOOL SetGuid(LPCWSTR pcsGuidString);
		void vReset();
		void vGetString(WCHAR * pwcsBuffer,WORD wCount);
	
		BOOL CurrentPtrOk(ULONG uHowMany);
		inline BOOL PtrOk(ULONG * pPtr,ULONG uHowMany);
		void AddPadding(DWORD dwBytesToPad);
		bool SetAllInstanceInfo();
		BOOL InitializeDataPtr();
		bool InitializeInstancePtr();
		bool GetNextNode();
		BOOL NaturallyAlignData( long lType, BOOL fRead );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32ace.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*******************************************************************
 *
 *    DESCRIPTION:	Win32ACE.H
 *
 *    AUTHOR:
 *
 *    HISTORY:    
 *
 *******************************************************************/

#ifndef __WIN32ACE_H_
#define __WIN32ACE_H_


#define  WIN32_ACE_NAME L"Win32_ACE" 

// provider provided for test provisions
class Win32Ace: public Provider
{
public:	
	Win32Ace(const CHString& setName, LPCTSTR pszNameSpace);
	~Win32Ace();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

	virtual HRESULT PutInstance(const CInstance& newInstance, long lFlags = 0L);
	virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

	HRESULT FillInstanceFromACE(CInstance* pInstance, CAccessEntry& ace);

protected:

	DWORD	m_dwPlatformID;

private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32ace.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*******************************************************************
 *
 *    DESCRIPTION: Win32Ace.cpp
 *
 *    AUTHOR:
 *
 *    HISTORY:
 *
 *******************************************************************/

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureregkey.h"
#include "securefile.h"
#include "win32ace.h"

/*
	THIS IS THE WIN32_ACE definition from the MOF

	[abstract,
	 description("Specifies an element of an access control")]
class Win32_ACE : Win32_MethodParameterClass
{
    Win32_Trustee Trustee;

        [Values("Access Allowed", "Access Denied", "Audit"]
    uint32 AceType;

        [description("Inheritance and such")]
    uint32 AceFlags;

        [description("Rights granted/denied/etc")]
    uint32 AccessMask;

    string GuidObjectType;

    string GuidInheritedObjectType;
};

*/

Win32Ace MyACE( WIN32_ACE_NAME, IDS_CimWin32Namespace );

Win32Ace::Win32Ace(const CHString& setName, LPCTSTR pszNameSpace)
: Provider(setName, pszNameSpace)
{
}

Win32Ace::~Win32Ace()
{
}

HRESULT Win32Ace::PutInstance(const CInstance& newInstance, long lFlags)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;
	return(hr);

}

HRESULT Win32Ace::DeleteInstance(const CInstance& newInstance, long lFlags)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;
	return(hr);

}

HRESULT Win32Ace::FillInstanceFromACE(CInstance* pInstance, CAccessEntry& ace)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	if (pInstance)
	{
		CInstance* pTrustee = NULL;
		// fill the Trustee
		if (SUCCEEDED( CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrustee, GetNamespace() ) ) )
		{
			// now, fill the instance with information for:
			//	SID -- Uint8 array
			//	Name -- simple string resolved from the SID
			//  Domain -- string also resolved from SID
			CSid sid;
			ace.GetSID(sid);

			// now set the embedded object
			IWbemClassObject* pClassObject;
			//IUnknown* pUnknown = NULL;

			pClassObject = pTrustee->GetClassObjectInterface();
			// create a variant of type VT_Unknown
			VARIANT vValue;
			//V_UNKNOWN(&vValue) = pUnknown;
            V_UNKNOWN(&vValue) = pClassObject;
			pInstance->SetVariant(IDS_Trustee, vValue);
			VariantClear(&vValue);
		}	// end if

		DWORD dwAceType = ace.GetACEType();
		DWORD dwAccessMask = ace.GetAccessMask();
		DWORD dwAceFlags = ace.GetACEFlags();

		// now set the remainder of the ACE information
		pInstance->SetDWORD(IDS_AceType, dwAceType);
		pInstance->SetDWORD(IDS_AccessMask, dwAccessMask);
		pInstance->SetDWORD(IDS_AceFlags, dwAceFlags);

		CHString chsInheritedObjGuid = L"";

		CHString chsObjectTypeGuid = L"";

		pInstance->SetCHString(IDS_InheritedObjectGUID, chsInheritedObjGuid);
		pInstance->SetCHString(IDS_ObjectTypeGUID, chsObjectTypeGuid);
	}	// end if
	return(hr);

}

HRESULT Win32Ace::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	return(hr);

}

HRESULT Win32Ace::GetObject ( CInstance* pInstance, long lFlags /* = 0L */ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32allocatedresource.h ===
//=================================================================

//

// WIN32AllocatedResource.h 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    1/26/99    a-kevhu         Created
//
// Comment: Relationship between Win32_PNPEntity and CIM_SystemResource
// 
// MOF:
//[dynamic: ToInstance, provider("CIMWin32"), Locale(1033), UUID("{8502C50D-5FBB-11D2-AAC1-006008C78BC7}")]
//class Win32_AllocatedResource : CIM_AllocatedResource
//{
//        [Override("Antecedent"): ToSubClass, key] CIM_SystemResource ref Antecedent = NULL;
//        [Override("Dependent"): ToSubClass, key] CIM_LogicalDevice ref Dependent = NULL;
//};
//
//=================================================================

#ifndef _WIN32ALLOCATEDRESOURCE_H_
#define _WIN32ALLOCATEDRESOURCE_H_


// Property set identification
//============================
#define PROPSET_NAME_WIN32SYSTEMDRIVER_PNPENTITY  L"Win32_PNPAllocatedResource"


class CW32PNPRes;

class CW32PNPRes : public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================
        CW32PNPRes(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32PNPRes() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long a_Flags = 0L);
//        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L); 

    protected:

        // Functions inherrited from CWin32PNPEntity
        //====================================
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        CHPtrArray m_ptrProperties;
};

// This derived class commits here, not in the base.
inline bool CW32PNPRes::ShouldBaseCommit(void* pvData) { return false; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32loggedonuser.h ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
*******************************************************************/

// Property set identification
//============================

#pragma once

#define PROVIDER_NAME_WIN32LOGGEDONUSER L"Win32_LoggedOnUser"

#define PROP_ALL_REQUIRED          0xFFFFFFFF
#define PROP_NONE_REQUIRED         0x00000000
#define PROP_ANTECEDENT            0x00000001
#define PROP_DEPENDENT             0x00000002

// Property name externs -- defined in MSJ_GroupMembership.cpp
//=================================================

class CWin32LoggedOnUser ;


_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class CWin32LoggedOnUser : public Provider 
{
    public:
        // Constructor/destructor
        //=======================

        CWin32LoggedOnUser(
            LPCWSTR lpwszClassName, 
            LPCWSTR lpwszNameSpace);

        virtual ~CWin32LoggedOnUser();

#ifdef NTONLY

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(
            MethodContext*  pMethodContext, 
            long lFlags = 0L);

        virtual HRESULT GetObject(
            CInstance* pInstance, 
            long lFlags, 
            CFrameworkQuery& Query);
        


    private:
        HRESULT Enumerate(
            MethodContext *pMethodContext, 
            DWORD dwPropsRequired);

        HRESULT LoadPropertyValues(
            CInstance* pInstance, 
            CUser& user, 
            CSession& ses, 
            DWORD dwPropsRequired);

        bool AreAssociated(
            const CInstance *pUserInst, 
             const CInstance *pGroupInst);

        HRESULT ValidateEndPoints(
            MethodContext *pMethodContext, 
            const CInstance *pInstance, 
            CInstancePtr &pAntUserActInst, 
            CInstancePtr &pDepSesInst);

        HRESULT EnumerateSessionsForUser(
            CUserSessionCollection& usc,
            CUser& user, 
            MethodContext *pMethodContext, 
            DWORD dwPropsRequired);

        DWORD GetRequestedProps(
            CFrameworkQuery& Query);

#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32idecontrollerdevice.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32IDEControllerDevice.cpp
//
//  Purpose: Relationship between CIM_IDEController and CIM_LogicalDevice
//
//***************************************************************************

#include "precomp.h"
#include <vector>
#include "IDE.h"
#include "PNPEntity.h"
#include "LPVParams.h"
#include <FRQueryEx.h>

#include "WIN32IDEControllerDevice.h"

// Property set declaration
//=========================
CW32IDECntrlDev MyCW32IDECntrlDev(PROPSET_NAME_WIN32IDECONTROLLERDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::CW32IDECntrlDev
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32IDECntrlDev::CW32IDECntrlDev
(
    LPCWSTR setName,
    LPCWSTR pszNamespace
)
: CWin32IDE(setName, pszNamespace),
  CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::~CW32IDECntrlDev
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32IDECntrlDev::~CW32IDECntrlDev()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::GetObject
(
    CInstance *pInstance,
    long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    if(pInstance != NULL)
    {
        CHString chstrAntecedent, chstrDependent;
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
        pInstance->GetCHString(IDS_Dependent, chstrDependent);

        // Obtain the antecedent's device id:
        CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
        chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
        CHString chstrAntecedentDevIDAdj;
        RemoveDoubleBackslashes(chstrAntecedentDevID,chstrAntecedentDevIDAdj);

        // Obtain the dependent's device id:
        CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
        chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
        CHString chstrDependentDevIDAdj;
        RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

        CConfigManager cfgmgr;

        // Now see if the dependent is visible to config manager...
        CConfigMgrDevicePtr pPNPDevice;
        if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, pPNPDevice))
        {
            // It is visible to config manager.  Is it a PNPDevice?
            if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
            {
                // It is. Is one of its ancestors an IDEController?
				while (hr != WBEM_S_NO_ERROR)
				{
					CConfigMgrDevicePtr pParentDevice;

					if (pPNPDevice->GetParent(pParentDevice))
					{
						if (CWin32IDE::IsOneOfMe(pParentDevice))
						{
							// It is. Is it's PNP ID the same as that which we were given?
							CHString chstrControllerPNPID;
							pParentDevice->GetDeviceID(chstrControllerPNPID);
							if(chstrAntecedentDevIDAdj.CompareNoCase(chstrControllerPNPID)==0)
							{
								hr = WBEM_S_NO_ERROR;
							}
							else
							{
    							// We ran out of IDE ancestors, so get out.
	    						break;
							}
						}
                        else
                        {
								// Set the current device to the parent so we can
								// continue up the tree.
								pPNPDevice = pParentDevice;
                        }
					}
					else
					{
						// We ran out of IDE ancestors, so get out.
						break;
					}
				}
            }
        }
		else
		{
			if ( ERROR_ACCESS_DENIED == ::GetLastError() )
			{
				hr = WBEM_E_ACCESS_DENIED;
			}
		}
    }
    return hr;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32IDECntrlDev::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CW32IDECntrlDev::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwReqProps;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwReqProps);

    std::vector<_bstr_t> vecDependents;
    pQuery.GetValuesForProp(IDS_Dependent, vecDependents);
    DWORD dwDependents = vecDependents.size();

    // Only will have one usbcontroller, so if the query asked for that
    // as the antecedent, do an enumeration.  If the query asked for a
    // specific device as the dependent, just get that one.
    if(dwDependents > 0)
    {
        for(LONG m = 0L; m < dwDependents; m++)
        {
            // Obtain the dependent's device id:
            CHString chstrDependent((LPCTSTR)vecDependents[m]);
            CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
            chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
            CHString chstrDependentDevIDAdj;
            RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

            CConfigManager cfgmgr;

            // Now see if the dependent is visible to config manager...
            CConfigMgrDevicePtr pPNPDevice;
            if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // It is. Is its parent an IDEController?
                    CConfigMgrDevicePtr pParentDevice;
                    bool bFound = false;

                    // or its parent?  Or its parent? Or...
                    while (pPNPDevice->GetParent(pParentDevice))
                    {
                        if(CWin32IDE::IsOneOfMe(pParentDevice))
                        {
                            bFound = true;
                            break;
                        }
                        else
                        {
                            pPNPDevice = pParentDevice;
                        }
                    }

                    if (bFound)
                    {
                        // It is, so create the association.
                        CHString chstrControllerPNPID;
                        pParentDevice->GetDeviceID(chstrControllerPNPID);
                        CHString chstrControllerPNPIDAdj;
                        EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                        CHString chstrControllerPATH;
                        chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                                   (LPCWSTR)GetLocalComputerName(),
                                                   IDS_CimWin32Namespace,
                                                   PROPSET_NAME_IDE,
                                                   IDS_DeviceID,
                                                   (LPCWSTR)chstrControllerPNPIDAdj);

                        CHString chstrDevicePATH;
                        chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                               (LPCWSTR)GetLocalComputerName(),
                                               IDS_CimWin32Namespace,
                                               PROPSET_NAME_PNPEntity,
                                               IDS_DeviceID,
                                               (LPCWSTR)chstrDependentDevID);

                        hr = CreateAssociation(pMethodContext,
                                               chstrControllerPATH,
                                               chstrDevicePATH,
                                               dwReqProps);
                    }
                }
            }
			else
			{
				if ( ERROR_ACCESS_DENIED == ::GetLastError() )
				{
					hr = WBEM_E_ACCESS_DENIED;
				}
			}
        }
    }
    else
    {
        CWin32IDE::Enumerate(pMethodContext, lFlags, dwReqProps);
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::EnumerateInstances
 *
 *  DESCRIPTION : Enumerate is present here to prevent ambiguous upcasting to
 *                functions of the same name from both base classes.  The
 *                logic in LoadPropertyValues works when CWin32IDE's (the
 *                IDEController class) version of EnumerateInstances is called,
 *                so that is what we call here.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags
)
{
    return CWin32IDE::Enumerate(pMethodContext, lFlags);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::LoadPropertyValues
(
    void* pv
)
{
    // Algorithm:
    // 1) Get all instances of CIM_IDEController
    // 2) For each in #1, using cfg mgr, get its children, their children, etc.
    // 3) For each in #2, obtain DeviceID from cfg mgr, and look for instances
    //    of CIM_LogicalDevice with PNPDeviceIDs that match.
    // 4) For matches from #3, create association instances

    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrControllerPNPID;
    CHString chstrControllerPATH;
    MethodContext* pMethodContext = NULL;

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance* pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);
    if(pInstance == NULL || pDevice == NULL) return WBEM_E_FAILED;

    if((pMethodContext = pInstance->GetMethodContext()) != NULL)
    {
        VECPCHSTR vecIDEDevices;

        pDevice->GetDeviceID(chstrControllerPNPID);

        try
        {
            hr = GenerateIDEDeviceList(chstrControllerPNPID, vecIDEDevices);
            if(SUCCEEDED(hr) && vecIDEDevices.size() > 0L)
            {
                CHString chstrControllerPNPIDAdj;
                EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                           (LPCWSTR)GetLocalComputerName(),
                                           IDS_CimWin32Namespace,
                                           PROPSET_NAME_IDE,
                                           IDS_DeviceID,
                                           (LPCWSTR)chstrControllerPNPIDAdj);
                hr = ProcessIDEDeviceList(pMethodContext,
                                          chstrControllerPATH,
                                          vecIDEDevices,
                                          dwReqProps);
            }
        }
        catch ( ... )
        {
            CleanPCHSTRVec(vecIDEDevices);
            throw ;
        }

        CleanPCHSTRVec(vecIDEDevices);
    }

    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::GenerateIDEDeviceList
 *
 *  DESCRIPTION : This helper creates a list of devices hanging off the passed
 *                in device.
 *
 *  INPUTS      : vecIDEDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPNPID, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::GenerateIDEDeviceList
(
    const CHString& chstrControllerPNPID,
    VECPCHSTR& vec
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CConfigManager cfgManager;
    CConfigMgrDevicePtr pController;
    if(cfgManager.LocateDevice(chstrControllerPNPID, pController))
    {
        if(pController != NULL)
        {
            hr = RecursiveFillDeviceBranch(pController, vec);
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::RecursiveFillDeviceBranch
 *
 *  DESCRIPTION : This helper obtains all down branch devices starting with,
 *                but not including, pDevice.
 *
 *  INPUTS      : pDevice, a device to populate the children of;
 *                vecIDEDevices, a list of devices to try to associate
 *                   to the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::RecursiveFillDeviceBranch
(
    CConfigMgrDevice* pDevice,
    VECPCHSTR& vecIDEDevices
)
{
    CConfigMgrDevicePtr pDeviceChild;
    CConfigMgrDevicePtr pDeviceSibling;
    CConfigMgrDevicePtr pDeviceSiblingNext;
    CHString* pchstrTemp = NULL;

    HRESULT hr = WBEM_S_NO_ERROR;
    if(pDevice != NULL)
    {
        if(pDevice->GetChild(pDeviceChild) )
        {
            // Need this child's PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                if(chstrChildPNPDeviceID.GetLength() > 0)
                {
                    // Record this child...
                    pchstrTemp = (CHString*) new CHString(chstrChildPNPDeviceID);
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            vecIDEDevices.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            pchstrTemp = NULL;
                            throw ;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }

                    // If we've hit another controller, add this one (done above), but don't go
                    // any deeper.
                    if (!CWin32IDE::IsOneOfMe(pDeviceChild))
                    {
                        // Now do its children...
                        hr = RecursiveFillDeviceBranch(pDeviceChild, vecIDEDevices);
                    }
                }
            }
            // Now call its brothers and sisters until none left (GetSibling
            // call will return FALSE):
            if(SUCCEEDED(hr))
            {
                if(pDeviceChild->GetSibling(pDeviceSibling))
                {
                    BOOL fContinue = TRUE;
                    CHString chstrSiblingPNPDeviceID;
                    while(SUCCEEDED(hr) && fContinue)
                    {
                        // Record the sibling now...
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            if(chstrSiblingPNPDeviceID.GetLength() > 0)
                            {
                                pchstrTemp = NULL;
                                pchstrTemp = (CHString*) new CHString(chstrSiblingPNPDeviceID);
                                if(pchstrTemp != NULL)
                                {
                                    try
                                    {
                                        vecIDEDevices.push_back(pchstrTemp);
                                    }
                                    catch ( ... )
                                    {
                                        delete pchstrTemp;
                                        pchstrTemp = NULL;
                                        throw ;
                                    }
                                }
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }
                        }

                        // If we've hit another controller, add this one (done above), but don't go
                        // any deeper.
                        if (!CWin32IDE::IsOneOfMe(pDeviceSibling))
                        {
                            // Then do the sibling's children...
                            hr = RecursiveFillDeviceBranch(pDeviceSibling, vecIDEDevices);
                        }

                        // Then get the next sibling...
                        pDeviceSiblingNext = NULL;
                        fContinue = pDeviceSibling->GetSibling(pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling = pDeviceSiblingNext;
                    }
                }
            }
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::ProcessIDEDeviceList
 *
 *  DESCRIPTION : This helper runs through the list, creating an association
 *                instance for each element in the list (vecIDEDevices) with
 *                the controller (chstrControllerPNPID).
 *
 *  INPUTS      : pMethodContext;
 *                vecIDEDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::ProcessIDEDeviceList
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    VECPCHSTR& vecIDEDevices,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    for(LONG m = 0L; m < vecIDEDevices.size() && SUCCEEDED(hr); m++)
    {
        // For each element of the vector, we need to see if there is an instance
        // of a win32_pnpentity that has the specified PNPDeviceID.
        CHString chstrDevicePATH, chstrDevPATHAdj;
        CConfigManager cfgmgr;

        // Let's see if config manager recognizes this device at all
        CConfigMgrDevicePtr pDevice;
        if(cfgmgr.LocateDevice(*vecIDEDevices[m], pDevice))
        {
            // Ok, it knows about it.  Is it a PNPDevice device?
            if(CWin32PNPEntity::IsOneOfMe(pDevice))
            {
                // It would appear that it is.  Create the association...
                EscapeBackslashes(*vecIDEDevices[m], chstrDevPATHAdj);
                chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_PNPEntity,
                                       IDS_DeviceID,
                                       (LPCWSTR)chstrDevPATHAdj);

                hr = CreateAssociation(pMethodContext,
                                       chstrControllerPATH,
                                       chstrDevicePATH,
                                       dwReqProps);
            }
        }
    }
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::CreateAssociation
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : pMethodContext;
 *                IDEDevice, a device to associate with the controller
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper actually creates the association instance and
 *                commits it.
 *
 *****************************************************************************/
HRESULT CW32IDECntrlDev::CreateAssociation
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    const CHString& chstrDevicePATH,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;
    if(pMethodContext != NULL)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            if(dwReqProps & IDECTL_PROP_Antecedent ||
               dwReqProps & IDECTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Antecedent, chstrControllerPATH);
            }
            if(dwReqProps & IDECTL_PROP_Dependent ||
               dwReqProps & IDECTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Dependent, chstrDevicePATH);
            }
            hr = pInstance->Commit();
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::FindInStringVector
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : chstrIDEDevicePNPID, device to look for
 *                vecIDEDevices, list of devices to look in
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG, number indicating 0 based offset into vecIDEDevices of
 *                the found device, or -1 if not found.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CW32IDECntrlDev::FindInStringVector
(
    const CHString& chstrIDEDevicePNPID,
    VECPCHSTR& vecIDEDevices
)
{
    LONG lPos = -1L;
    bool fFoundIt;
    for(LONG m = 0; m < vecIDEDevices.size(); m++)
    {
        if(chstrIDEDevicePNPID == *vecIDEDevices[m])
        {
            fFoundIt = true;
            break;
        }
    }
    if(fFoundIt) lPos = m;
    return lPos;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32IDECntrlDev::CleanPCHSTRVec
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : vec, a vector of CHString pointers
 *
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper deletes members of a vector that are pointers.
 *
 *****************************************************************************/
void CW32IDECntrlDev::CleanPCHSTRVec
(
    VECPCHSTR& vec
)
{
    for(LONG m = 0L; m < vec.size(); m++)
    {
        delete vec[m];
    }
    vec.clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32idecontrollerdevice.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32IDEControllerDevice.h 
//
//  Purpose: Relationship between CIM_IDEController and CIM_LogicalDevice
//
//***************************************************************************

#ifndef _WIN32IDECONTROLLERDEVICE_H_
#define _WIN32IDECONTROLLERDEVICE_H_


#define IDECTL_PROP_ALL_PROPS                    0xFFFFFFFF
#define IDECTL_PROP_ALL_PROPS_KEY_ONLY           0x00000003
#define IDECTL_PROP_Antecedent                   0x00000001
#define IDECTL_PROP_Dependent                    0x00000002



// Property set identification
//============================
#define PROPSET_NAME_WIN32IDECONTROLLERDEVICE  L"Win32_IDEControllerDevice"


typedef std::vector<CHString*> VECPCHSTR;

class CW32IDECntrlDev;

class CW32IDECntrlDev : public CWin32IDE, public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================
        CW32IDECntrlDev(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32IDECntrlDev() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long a_Flags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L); 

    protected:

        // Functions inherrited from CWin32IDE
        //====================================
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        CHPtrArray m_ptrProperties;
        void CleanPCHSTRVec(VECPCHSTR& vec);
        HRESULT GenerateIDEDeviceList(const CHString& chstrControllerPNPID, 
                                      VECPCHSTR& vec);
        HRESULT RecursiveFillDeviceBranch(CConfigMgrDevice* pRootDevice, 
                                          VECPCHSTR& vecIDEDevices); 
        HRESULT ProcessIDEDeviceList(MethodContext* pMethodContext, 
                                     const CHString& chstrControllerRELPATH, 
                                     VECPCHSTR& vecIDEDevices,
                                     const DWORD dwReqProps);
        HRESULT CreateAssociation(MethodContext* pMethodContext,
                                  const CHString& chstrControllerPATH, 
                                  const CHString& chstrIDEDevice,
                                  const DWORD dwReqProps);
        LONG FindInStringVector(const CHString& chstrIDEDevicePNPID, 
                                VECPCHSTR& vecIDEDevices);


};

// This derived class commits here, not in the base.
inline bool CW32IDECntrlDev::ShouldBaseCommit(void* pvData) { return false; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32allocatedresource.cpp ===
//=================================================================

//

// Win32AllocatedResource.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    2/23/99    davwoh  Created
//
// Comment: Relationship between Win32_PNPEntity and CIM_SystemResource
//
//=================================================================

#include "precomp.h"
#include <vector>
#include "PNPEntity.h"
#include "LPVParams.h"
#include <assertbreak.h>

#include "Win32AllocatedResource.h"

#define ALR_ALL_PROPERTIES 0xffffffff

// Property set declaration
//=========================
CW32PNPRes MyCW32PNPRes(PROPSET_NAME_WIN32SYSTEMDRIVER_PNPENTITY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32PNPRes::CW32PNPRes
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32PNPRes::CW32PNPRes(LPCWSTR setName, LPCWSTR pszNamespace)
: CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32PNPRes::~CW32PNPRes
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32PNPRes::~CW32PNPRes()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32PNPRes::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32PNPRes::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString    sResource,
        sDevice,
        sDeviceID,
        sClass;
    HRESULT     hRet = WBEM_E_NOT_FOUND;

    // Get the two paths
    pInstance->GetCHString(IDS_Antecedent, sResource);
    pInstance->GetCHString(IDS_Dependent, sDevice);

    // Parse the object path for the PNPEntity
    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;
    int nStatus = objpathParser.Parse( (LPWSTR)(LPCWSTR)sDevice,  &pParsedPath );

    // Did we successfully parse the PNPEntity path?
    if ( 0 == nStatus )
    {
        try
        {
            if ((pParsedPath->IsInstance()) &&                                         // Is the parsed object an instance?
                (_wcsicmp(pParsedPath->m_pClass, PROPSET_NAME_PNPEntity) == 0) &&      // Is this the class we expect (no, cimom didn't check)
                (pParsedPath->m_dwNumKeys == 1) &&                                     // Does it have exactly one key
                (pParsedPath->m_paKeys[0]) &&                                          // Is the keys pointer null (shouldn't happen)
                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                        // Check to see if the key name is not specified or
                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_DeviceID)) == 0) &&  // it is specified, and it's the right name
                                                                                       // (no, cimom doesn't do this for us).
                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&           // Check the variant type (no, cimom doesn't check this either)
                (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )                // And is there a value in it?
            {
                // Grab the pnpDevice
                sDeviceID = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
            }
        }
        catch ( ... )
        {
            objpathParser.Free( pParsedPath );
            pParsedPath = NULL;
            throw ;
        }

        // Clean up the Parsed Path
        objpathParser.Free( pParsedPath );

        CConfigManager	cfgManager;
        CConfigMgrDevicePtr pDevice(NULL);

        // Retrieve and validate the device
        if ((cfgManager.LocateDevice(sDeviceID, pDevice)) && (CWin32PNPEntity::IsOneOfMe(pDevice)))
        {
            hRet = WBEM_E_NOT_FOUND;

            // Parse the object path for the resource
            // ==========================================
            int nStatus = objpathParser.Parse( (LPWSTR)(LPCWSTR)sResource,  &pParsedPath );

            if (nStatus == 0)
            {
                try
                {
                    // Get the class of the resource they did a getobject on (irq, dma, etc)
                    sClass = pParsedPath->m_pClass;

                    REFPTR_POSITION pos;

                    // Ok, at this point we've verified the device part.  Now
                    // we need to see if the resource they passed us really
                    // exists.
                    //------------------------------
                    if (sClass.CompareNoCase(L"Win32_IRQResource") == 0)
                    {
                        CIRQCollection irqList;

                        // Get the IRQs
                        pDevice->GetIRQResources(irqList);

                        if (irqList.BeginEnum(pos))
                        {
                            if ((pParsedPath->IsInstance()) &&
                                (pParsedPath->m_dwNumKeys == 1) &&
                                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == VT_I4) &&
                                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||
                                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_IRQNumber) == 0))
                                )
                            {
                                CIRQDescriptorPtr pIRQ(NULL);
                                DWORD dwIRQSeeking = V_I4(&pParsedPath->m_paKeys[0]->m_vValue);

                                // Walk the irq's
                                for (pIRQ.Attach(irqList.GetNext(pos));
                                pIRQ != NULL;
                                pIRQ.Attach(irqList.GetNext(pos)))
                                {
                                    if (pIRQ->GetInterrupt() == dwIRQSeeking)
                                    {
                                        hRet = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //------------------------------
                    else if (sClass.CompareNoCase(L"Win32_DMAChannel") == 0)
                    {
                        CDMACollection dmaList;

                        // Get the DMAs
                        pDevice->GetDMAResources(dmaList);

                        if (dmaList.BeginEnum(pos))
                        {
                            if ((pParsedPath->IsInstance()) &&
                                (pParsedPath->m_dwNumKeys == 1) &&
                                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == VT_I4) &&
                                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||
                                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_DMAChannel) == 0))
                                )
                            {
                                CDMADescriptorPtr pDMA(NULL);
                                DWORD dwDMASeeking = V_I4(&pParsedPath->m_paKeys[0]->m_vValue);

                                // Walk the dma's
                                for (pDMA.Attach(dmaList.GetNext(pos)) ;
                                pDMA != NULL;
                                pDMA.Attach(dmaList.GetNext(pos)))
                                {
                                    if (pDMA->GetChannel() == dwDMASeeking)
                                    {
                                        hRet = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //------------------------------
                    else if (sClass.CompareNoCase(L"Win32_DeviceMemoryAddress") == 0)
                    {

                        CDeviceMemoryCollection DevMemList;

                        // Get the DeviceMemory
                        pDevice->GetDeviceMemoryResources( DevMemList );

                        if ( DevMemList.BeginEnum(pos))
                        {
                            if ((pParsedPath->IsInstance()) &&
                                (pParsedPath->m_dwNumKeys == 1) &&
                                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&
                                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||
                                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_StartingAddress) == 0))
                                )
                            {
                                CDeviceMemoryDescriptorPtr pDeviceMemory(NULL);
                                unsigned __int64 i64StartingAddress = _wtoi64(V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue));

                                // Walk the Device Memory
                                for (pDeviceMemory.Attach(DevMemList.GetNext(pos));
                                pDeviceMemory != NULL;
                                pDeviceMemory.Attach(DevMemList.GetNext(pos)))
                                {
                                    if (pDeviceMemory->GetBaseAddress() == i64StartingAddress)
                                    {
                                        hRet = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    //------------------------------
                    else if (sClass.CompareNoCase(L"Win32_PortResource") == 0)
                    {
                        CIOCollection ioList;

                        // Get the IRQs
                        pDevice->GetIOResources(ioList);

                        if ( ioList.BeginEnum(pos))
                        {
                            if ((pParsedPath->IsInstance()) &&
                                (pParsedPath->m_dwNumKeys == 1) &&
                                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&
                                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||
                                 (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_StartingAddress) == 0))
                                )
                            {
                                CIODescriptorPtr pIO(NULL);
                                unsigned __int64 i64StartingAddress = _wtoi64(V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue));

                                // Walk the dma's
                                for (pIO.Attach (ioList.GetNext(pos));
                                NULL != pIO;
                                pIO.Attach (ioList.GetNext(pos)))
                                {
                                    if (pIO->GetBaseAddress() == i64StartingAddress)
                                    {
                                        hRet = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        ASSERT_BREAK(0);  // Don't know what it is, so let the GetObject fail
                    }

                }
                catch ( ... )
                {
                    objpathParser.Free( pParsedPath );
                    pParsedPath = NULL;
                    throw ;
                }

                // Clean up the Parsed Path
                objpathParser.Free( pParsedPath );
            }

        }
		else
		{
			if ( ERROR_ACCESS_DENIED == ::GetLastError() )
			{
				hRet = WBEM_E_ACCESS_DENIED;
			}
		}
    }

    // There are no properties to set, if the endpoints exist, we be done

    return hRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32PNPRes::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CW32PNPRes::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags )
{
    CHStringArray saDevices;
    HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;

    pQuery.GetValuesForProp(IDS_Dependent, saDevices);

    if (saDevices.GetSize() > 0)
    {
        hr = WBEM_S_NO_ERROR;

        CObjectPathParser objpathParser;
        ParsedObjectPath *pParsedPath = NULL;

        CConfigManager	cfgManager;
        CConfigMgrDevicePtr pDevice;

        CHString sPNPId, sDevicePath, sPNPId2;

        for (int x=0; (x < saDevices.GetSize()) && SUCCEEDED(hr); x++)
        {

            // Parse the object path passed to us by CIMOM.
            int nStatus = objpathParser.Parse( bstr_t(saDevices[x]),  &pParsedPath );

            if ( 0 == nStatus )                                                 // Did the parse succeed?
            {
                if ((pParsedPath->IsInstance()) &&                              // Is the parsed object an instance?
                    (_wcsicmp(pParsedPath->m_pClass, L"Win32_PnPEntity") == 0) &&   // Is this the class we expect (no, cimom didn't check)
                    (pParsedPath->m_dwNumKeys == 1) &&                              // Does it have exactly one key
                    (pParsedPath->m_paKeys[0]) &&                                   // Is the keys pointer null (shouldn't happen)
                    ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                 // No key name specified or
                     (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_DeviceID) == 0)) &&  // the key name is the right value
                                                                                        // (no, cimom doesn't do this for us).
                    (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&    // Check the variant type (no, cimom doesn't check this either)
                    (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )         // And is there a value in it?
                {

                    // Find the device
                    sPNPId = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);

                    if ((cfgManager.LocateDevice(sPNPId, pDevice)) && (CWin32PNPEntity::IsOneOfMe(pDevice)) )
                    {
                        // LoadPropertyValues always releases this
                        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                        // Now, create instances for all the resources on that device.
                        hr = LoadPropertyValues(&CLPVParams(pInstance, pDevice, ALR_ALL_PROPERTIES));
                    }
					else
					{
						if ( ERROR_ACCESS_DENIED == ::GetLastError () )
						{
							hr = WBEM_E_ACCESS_DENIED;
						}
					}
                }

                objpathParser.Free( pParsedPath );
            }
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32PNPRes::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances or ExecQuery function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32PNPRes::LoadPropertyValues(void* pv)
{
    REFPTR_POSITION pos;
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR buff[MAXI64TOA];

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance* pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);
    MethodContext *pMethodContext = pInstance->GetMethodContext();

    if(pInstance == NULL || pDevice == NULL || pMethodContext == NULL)
    {
        // This would imply a coding failure and should never happen
        ASSERT_BREAK(FALSE);
        return WBEM_E_FAILED;
    }

    CHString sResourcePath, sDevicePath, sPNPId;
    bool bValidResource;

    // Format the PNP Device path
    if ((pDevice->GetDeviceID(sPNPId)) && (!sPNPId.IsEmpty()))
    {

        // Format to suit
        CHString sPNPIdAdj;
        EscapeBackslashes(sPNPId, sPNPIdAdj);

        sDevicePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                   (LPCWSTR)GetLocalComputerName(),
                                   IDS_CimWin32Namespace,
                                   PROPSET_NAME_PNPEntity,
                                   IDS_DeviceID,
                                   (LPCWSTR)sPNPIdAdj);
    }

    // Now walk all the resources for this device
    CResourceCollection resourceList;
    pDevice->GetResourceList(resourceList);
	CResourceDescriptorPtr pResource;

    if ( resourceList.BeginEnum( pos ) )
    {
		for( pResource.Attach(resourceList.GetNext( pos ));
			 NULL != pResource && SUCCEEDED(hr);
             pResource.Attach(resourceList.GetNext( pos )) )
        {
            // Resources can be marked to be ignored.  Device manager ignores them, so we
            // do too.
            if (!pResource->IsIgnored())
            {
                DWORD dwResourceType = pResource->GetResourceType();

                switch (dwResourceType)
                {
                    case ResType_IRQ:
                    {
						IRQ_DES *pIRQ = (IRQ_DES *)pResource->GetResource();
                        if (pIRQ != NULL)
                        {
                            sResourcePath.Format(L"\\\\%s\\%s:%s.%s=%u", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                                L"Win32_IRQResource", IDS_IRQNumber, pIRQ->IRQD_Alloc_Num);
                            bValidResource = true;
                        }
                        break;
                    }

                    case ResType_DMA:
                    {

                        DMA_DES *pDMA = (DMA_DES *)pResource->GetResource();
                        if (pDMA != NULL)
                        {
                            sResourcePath.Format(L"\\\\%s\\%s:%s.%s=%u", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                                L"Win32_DMAChannel", IDS_DMAChannel, pDMA->DD_Alloc_Chan);
                            bValidResource = true;
                        }
                        break;
                    }

                    case ResType_Mem:
                    {
                        MEM_DES *pDeviceMemory = (MEM_DES *)pResource->GetResource();
                        if (pDeviceMemory != NULL)
                        {
                            _ui64tow(pDeviceMemory->MD_Alloc_Base, buff, 10);

                            sResourcePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace, L"Win32_DeviceMemoryAddress",
                                IDS_StartingAddress, buff);
                            bValidResource = true;
                        }
                        break;
                    }

                    case ResType_IO:
                    {
                        IOWBEM_DES *pIO = (IOWBEM_DES *)pResource->GetResource();
                        if (pIO != NULL)
                        {
                            sResourcePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                                L"Win32_PortResource", IDS_StartingAddress, _ui64tow(pIO->IOD_Alloc_Base, buff, 10));
                            bValidResource = true;
                        }
                        break;
                    }

                    // Don't know what to do with these yet, but they exist in NT5. Device
                    // manager doesn't seem to show anything for them, so we won't either.
                    case ResType_BusNumber:
                    case ResType_None:
                    {
                        bValidResource = false;
                        break;
                    }

                    default:
                    {
                        bValidResource = false;
                        LogErrorMessage2(L"Unrecognized resource type: %x", dwResourceType);
                        break;
                    }
                }
            }
            else
            {
                bValidResource = false;
            }

            if (bValidResource)
            {
                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                pInstance->SetCHString(IDS_Antecedent, sResourcePath);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }	//// For EnumResources
		resourceList.EndEnum();
    }	// IF BeginEnum()

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32loggedonuser.cpp ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
******************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
//#include <ntlsa.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <frqueryex.h>

#include <Session.h>

#include "Win32LoggedOnUser.h"
#include "sid.h"

#include <computerAPI.h>

CWin32LoggedOnUser MyWin32_LogonSession(
    PROVIDER_NAME_WIN32LOGGEDONUSER, 
    IDS_CimWin32Namespace);


/*****************************************************************************
 *
 *  FUNCTION    :   CWin32LoggedOnUser::CWin32LoggedOnUser
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CWin32LoggedOnUser::CWin32LoggedOnUser(
    LPCWSTR lpwszName, 
    LPCWSTR lpwszNameSpace)
  :
    Provider(lpwszName, lpwszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CWin32LoggedOnUser::~CWin32LoggedOnUser
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CWin32LoggedOnUser::~CWin32LoggedOnUser ()
{
}



/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with 
*                   WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the 
*                   following flags are handled by (and filtered out by) 
*                   WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::EnumerateInstances(
    MethodContext* pMethodContext, 
    long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = Enumerate(
        pMethodContext, 
        PROP_ALL_REQUIRED);

    return hr;
}
#endif
/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key 
*                   properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    A valid HRESULT 
*
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::GetObject(
    CInstance* pInstance, 
    long lFlags,
    CFrameworkQuery& Query)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pAntUsrActInst, pDepSesInst;
    MethodContext *pMethodContext = pInstance->GetMethodContext();

    // The Antecedent property contains an object path that points to a user
    // account.  The Dependent property contains an object path that points 
    // to a session.  Let's do a GetObject on these two and make sure they 
    // point to valid users and sessions.

    hr = ValidateEndPoints(
        pMethodContext, 
        pInstance, 
        pAntUsrActInst, 
        pDepSesInst);

    if (SUCCEEDED(hr))
    {
        // Ok, the user and the session both exist.  Now, does this
        // session belong to this user?
        if (AreAssociated(
            pAntUsrActInst, 
            pDepSesInst))
        {
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::Enumerate
*
*  DESCRIPTION :    Internal helper function used to enumerate instances of
*                   this class.  All instances are enumerated, but only the
*                   properties specified are obtained.
*
*  INPUTS      :    A pointer to a the MethodContext for the call.
*                   A DWORD specifying which properties are requested.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::Enumerate(
    MethodContext *pMethodContext, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We will use the helper class CUserSessionCollection to get
    // a mapping of users and their associated sessions.
    CUserSessionCollection usc;

    USER_SESSION_ITERATOR usiter;
    SmartDelete<CUser> puser;

    puser = usc.GetFirstUser(usiter);
    while(puser != NULL)
    {
        hr = EnumerateSessionsForUser(
            usc,
            *puser,
            pMethodContext, 
            dwPropsRequired);

        puser = usc.GetNextUser(usiter);
    }

    return hr;
}
#endif

/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::EnumerateSessionsForUser
*
*  DESCRIPTION :    Called by Enumerate to enumerate the sessions of a given
*                   user. 
*
*  INPUTS      :    A mapping of users and their associated sessions,
*                   the user to enumerate sessions for, the methodcontext
*                   to communicate to winmgmt with, and a property bitmask of
*                   which properties to populate
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::EnumerateSessionsForUser(
    CUserSessionCollection& usc,
    CUser& user, 
    MethodContext *pMethodContext, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    USER_SESSION_ITERATOR usiter;
    SmartDelete<CSession> pses;

    pses = usc.GetFirstSessionOfUser(
        user,
        usiter);

    while(pses != NULL)
    {
        // Create a new instance based on the passed-in 
        // MethodContext.  Note that CreateNewInstance may 
        // throw, but will never return NULL.
        CInstancePtr pInstance(
            CreateNewInstance(
                pMethodContext), 
                false);

        hr = LoadPropertyValues(
            pInstance, 
            user, 
            *pses, 
            dwPropsRequired);

        if(SUCCEEDED(hr))
        {
            hr = pInstance->Commit();   
        }

        pses = usc.GetNextSessionOfUser(
            usiter);
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::LoadPropertyValues
*
*  DESCRIPTION :    Internal helper function used to fill in all unfilled
*                   property values.  At a minimum, it must fill in the key
*                   properties.
*
*  INPUTS      :    A pointer to a CInstance containing the instance we are
*                   attempting to locate and fill values for.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::LoadPropertyValues(
    CInstance* pInstance, 
    CUser& user, 
    CSession& ses, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chstrValue;

    WCHAR wstrBuff[MAXI64TOA];

    _i64tow(
        ses.GetLUIDint64(), 
        wstrBuff, 
        10);

    if (dwPropsRequired & PROP_ANTECEDENT)
    {
        // Need domain and name...
        CSid sidUser(user.GetPSID());
        SID_NAME_USE snu = sidUser.GetAccountType();
        if(snu == SidTypeWellKnownGroup)
        {
            chstrValue.Format(
                L"\\\\.\\%s:Win32_Account.Domain=\"%s\",Name=\"%s\"", 
                IDS_CimWin32Namespace, 
                (LPCWSTR)GetLocalComputerName(), 
                (LPCWSTR)(sidUser.GetAccountName()));
        }
        else
        {
            chstrValue.Format(
                L"\\\\.\\%s:Win32_Account.Domain=\"%s\",Name=\"%s\"", 
                IDS_CimWin32Namespace, 
                (LPCWSTR)(sidUser.GetDomainName()), 
                (LPCWSTR)(sidUser.GetAccountName()));    
        }

        pInstance->SetCHString(
            IDS_Antecedent, 
            chstrValue);
    }

    if (dwPropsRequired & PROP_DEPENDENT)
    {
        chstrValue.Format(
            L"\\\\.\\%s:Win32_LogonSession.LogonId=\"%s\"", 
            IDS_CimWin32Namespace, 
            (LPCWSTR)wstrBuff);

        pInstance->SetCHString(
            IDS_Dependent, 
            chstrValue);
    }

    return hr;
}
#endif



/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::ValidateEndPoints
*
*  DESCRIPTION :    Internal helper function used to determine whether the
*                   two object paths in the association currently point
*                   to valid users/sessions.
*
*
*  INPUTS      :    MethodContext to call back into winmgmt with, and
*                   the CInstance that is to be checked.
*
*  OUTPUTS     :    Pointers to CInstances that contain the actual objects
*                   from the endpoint classes.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32LoggedOnUser::ValidateEndPoints(
    MethodContext *pMethodContext, 
    const CInstance *pInstance, 
    CInstancePtr &pAntUserActInst, 
    CInstancePtr &pDepSesInst)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrUserPath;

    // See if the User specified exists
    pInstance->GetCHString(
        IDS_Antecedent, 
        chstrUserPath);

    hr = CWbemProviderGlue::GetInstanceKeysByPath(
        chstrUserPath, 
        &pAntUserActInst, 
        pMethodContext);

    if (SUCCEEDED(hr))
    {
        // The users exists.  Now, see if the session exists.
        CHString chstrSesPath;
        pInstance->GetCHString(
            IDS_Dependent, 
            chstrSesPath);

        hr = CWbemProviderGlue::GetInstanceKeysByPath(
            chstrSesPath, 
            &pDepSesInst, 
            pMethodContext);
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::AreAssociated
*
*  DESCRIPTION :    Internal helper function used to determine whether a
*                   specific session is associated to the specified user.
*
*  INPUTS      :    LOCALGROUP_MEMBERS_INFO_2
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
bool CWin32LoggedOnUser::AreAssociated(
    const CInstance *pUserInst, 
    const CInstance *pSesInst)
{
    bool fRet = false;

    CHString chstrUserName;
    CHString chstrUserDomain;
    CHString chstrSesLogonId;

    pUserInst->GetCHString(IDS_Name, chstrUserName);
    pUserInst->GetCHString(IDS_Domain, chstrUserDomain);
    pSesInst->GetCHString(IDS_LogonId, chstrSesLogonId);
    __int64 i64LogonID = _wtoi64(chstrSesLogonId);

    // We will use the helper class CUserSessionCollection to get
    // a mapping of users and their associated sessions.
    CUserSessionCollection usc; 
    USER_SESSION_ITERATOR pos;
    SmartDelete<CSession> pses;

	WCHAR t_wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH + 1 ] = { L'\0' };
    DWORD t_dwNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;

	if(ProviderGetComputerName( t_wstrLocalComputerName, &t_dwNameSize ) )
	{
		if ( wcsncmp	(
							t_wstrLocalComputerName,
							chstrUserDomain,
							( chstrUserDomain.GetLength() < t_dwNameSize ) ? chstrUserDomain.GetLength() : t_dwNameSize 
						)
						
						!= 0 )
		{
			CSid userSid(chstrUserDomain, chstrUserName, NULL);
			if(userSid.IsOK() &&
			userSid.IsValid())
			{
				CUser user(userSid.GetPSid());
				pses = usc.GetFirstSessionOfUser(
					user,
					pos);
			}
		}
		else
		{
			CSid userSid(chstrUserName, NULL);
			if(userSid.IsOK() &&
			userSid.IsValid())
			{
				CUser user(userSid.GetPSid());
				pses = usc.GetFirstSessionOfUser(
					user,
					pos);
			}
		}

		if ( pses != NULL ) 
		{
			while(pses != NULL &&
				!fRet)
			{
				// see if we find a session id match for this user...
				if(i64LogonID == pses->GetLUIDint64())
				{
					fRet = true;
				}
	            
				pses = usc.GetNextSessionOfUser(
					pos);
			}
		}   
	}

    return fRet;
}
#endif



/*****************************************************************************
*
*  FUNCTION    :    CWin32LoggedOnUser::GetRequestedProps
*
*  DESCRIPTION :    Internal helper function used to determine which
*                   properties are required to satisfy the GetObject or
*                   ExecQuery request.
*
*  INPUTS      :    A pointer to a CFrameworkQuery from which we can determine
*                   the required properties.
*
*  RETURNS     :    A DWORD bitmask that maps those properties that are
*                   required. 
*
*****************************************************************************/
#ifdef NTONLY
DWORD CWin32LoggedOnUser::GetRequestedProps(CFrameworkQuery& Query)
{
    DWORD dwReqProps = 0;

    if (Query.IsPropertyRequired(IDS_Antecedent)) dwReqProps |= PROP_ANTECEDENT;
    if (Query.IsPropertyRequired(IDS_Dependent)) dwReqProps |= PROP_DEPENDENT;

    return dwReqProps;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicaldiskrootwin32directory.h ===
//=================================================================

//

// Win32LogicalDiskCIMLogicalFile 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/09/98    a-kevhu         Created
//
// Comment: Relationship between Win32_LogicalDisk and Win32_Directory
//
//=================================================================

// Property set identification
//============================

#ifndef _WIN32LOGICALDISKROOTWIN32DIRECTORY_H_
#define _WIN32LOGICALDISKROOTWIN32DIRECTORY_H_

#define  PROPSET_NAME_WIN32LOGICALDISKROOT_WIN32DIRECTORY L"Win32_LogicalDiskRootDirectory"





class Win32LogDiskWin32Dir;

class Win32LogDiskWin32Dir : public CFileFile 
{
    public:
        // Constructor/destructor
        //=======================
        Win32LogDiskWin32Dir(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~Win32LogDiskWin32Dir() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicaldiskrootwin32directory.cpp ===
//=================================================================

//

// Win32LogicalDiskWin32Directory.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between win32_programgroup and contained cim_datafiles
//
//=================================================================

#include "precomp.h"

#include "FileFile.h"
#include "Win32LogicalDiskRootWin32Directory.h"
#include "implement_logicalfile.h"
#include "directory.h"

// Property set declaration
//=========================
Win32LogDiskWin32Dir MyWin32LogDiskWin32Dir(PROPSET_NAME_WIN32LOGICALDISKROOT_WIN32DIRECTORY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::Win32LogDiskWin32Dir
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32LogDiskWin32Dir::Win32LogDiskWin32Dir(LPCWSTR setName, LPCWSTR pszNamespace)
:CFileFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::~Win32LogDiskWin32Dir
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

Win32LogDiskWin32Dir::~Win32LogDiskWin32Dir()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32LogDiskWin32Dir::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrLogicalDisk;
    CHString chstrDir;
    HRESULT hr = WBEM_E_NOT_FOUND;
    CInstancePtr pinstLogicalDisk;
    CInstancePtr pinstDir;

    if(pInstance != NULL)
    {
        // Get the two paths
        pInstance->GetCHString(IDS_GroupComponent, chstrLogicalDisk);
        pInstance->GetCHString(IDS_PartComponent, chstrDir);

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrLogicalDisk, &pinstLogicalDisk, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDir, &pinstDir, pInstance->GetMethodContext())))
            {
                // Get the disk letter from the logical disk instance (antecedent):
                CHString chstrDiskLetterFromDisk;
                LONG lPos = chstrLogicalDisk.ReverseFind(_T(':'));
                chstrDiskLetterFromDisk = chstrLogicalDisk.Mid(lPos-1, 1);

                // Get the disk letter from the directory instance:
                CHString chstrDiskLetterFromDir;
                lPos = chstrDir.ReverseFind(_T(':'));
                chstrDiskLetterFromDir = chstrDir.Mid(lPos-1, 1);

                // If those two are the same, proceed:
                if(chstrDiskLetterFromDisk.CompareNoCase(chstrDiskLetterFromDir)==0)
                {
                    // Now confirm that we are looking at the root dir (this association
                    // only associates a disk with its root directory).
                    CHString chstrDirName = chstrDir.Mid(lPos+1);
                    chstrDirName = chstrDirName.Left(chstrDirName.GetLength() - 1);

                    if(chstrDirName == _T("\\\\"))
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            } //dir instancebypath
        } //logicaldisk instancebypath
    } // pinstance not null
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32LogDiskWin32Dir::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHStringArray achstrGroupComponent;
    DWORD dwGroupComponents;

    pQuery.GetValuesForProp(IDS_GroupComponent, achstrGroupComponent);
    dwGroupComponents = achstrGroupComponent.GetSize();
    if(dwGroupComponents == 1)
    {
        // Need to construct the path of the antecedent...
        CInstancePtr pInstance;
        if (SUCCEEDED(CWbemProviderGlue::GetInstanceKeysByPath(achstrGroupComponent[0], &pInstance, pMethodContext)))
        {
            CHString chstrLogicalDiskPATH;

//            chstrLogicalDiskPATH.Format(_T("\\\\%s\\%s:%s"), GetLocalComputerName(), IDS_CimWin32Namespace, achstrGroupComponent[0]);
            pInstance->GetCHString(IDS___Path, chstrLogicalDiskPATH);
            CHString chstrDiskLetter;
            LONG lPos = achstrGroupComponent[0].ReverseFind(_T(':'));
            chstrDiskLetter = achstrGroupComponent[0].Mid(lPos-1, 1);
            CHString chstrDirectoryPATH;
            chstrDirectoryPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s:\\\\\"",
                                              (LPCWSTR)GetLocalComputerName(),
                                              IDS_CimWin32Namespace,
                                              PROPSET_NAME_DIRECTORY,
                                              (LPCWSTR)chstrDiskLetter);
            hr = GetSingleSubItemAndCommit(chstrLogicalDiskPATH,
                                           chstrDirectoryPATH,
                                           pMethodContext);
        }
    }
    else
    {
        hr = EnumerateInstances(pMethodContext);
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogDiskWin32Dir::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32LogDiskWin32Dir::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LDisks;

//    if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(_T("Win32_LogicalDisk")),
//                                                    &LDisks,
//                                                    IDS_CimWin32Namespace,
//                                                    pMethodContext)))

    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(L"Select __Path, DeviceID From Win32_LogicalDisk",
                                                    &LDisks,
                                                    pMethodContext, GetNamespace())))
    {
        REFPTRCOLLECTION_POSITION pos;
        if(LDisks.BeginEnum(pos))
        {
            CInstancePtr pinstDisk;
            CHString chstrLogicalDisk;
            CHString chstrLogicalDiskPath;
            CHString chstrDiskLetter;
            CHString chstrDirectoryPATH;

            for (pinstDisk.Attach(LDisks.GetNext(pos)) ;
                (SUCCEEDED(hr)) && (pinstDisk != NULL) ;
                 pinstDisk.Attach(LDisks.GetNext(pos)) )
            {
                if(pinstDisk != NULL)
                {
                    // grab every directory hanging off of the root of that disk...
                    pinstDisk->GetCHString(L"__PATH", chstrLogicalDiskPath);
                    pinstDisk->GetCHString(IDS_DeviceID, chstrDiskLetter);
                    chstrDirectoryPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\\\\\"",
                                              (LPCWSTR)GetLocalComputerName(),
                                              IDS_CimWin32Namespace,
                                              PROPSET_NAME_DIRECTORY,
                                              (LPCWSTR)chstrDiskLetter);
                    hr = GetSingleSubItemAndCommit(chstrLogicalDiskPath,
                                                   chstrDirectoryPATH,
                                                   pMethodContext);
                }
            }
            LDisks.EndEnum();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32mappedlogicaldisk.h ===
//=================================================================

//

// MappedLogicalDisk.h -- Logical disk property set provider

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// Revisions:    04/12/00    khughes        Created
//
//=================================================================

#pragma once





_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

#define bool_FROM_STR(x) ( (_wcsicmp(x,L"TRUE")==0) ? true : false )
#define DWORD_FROM_STR(x) ( wcstoul(x,NULL,10) )


#define  PROPSET_NAME_MAPLOGDISK  L"Win32_MappedLogicalDisk"

class MappedLogicalDisk : public Provider
{
public:

    // Constructor/destructor
    //=======================

    MappedLogicalDisk(
        LPCWSTR name, 
        LPCWSTR pszNamespace);

   ~MappedLogicalDisk() ;


#if NTONLY == 5
    // Functions provide properties with current values
    //=================================================

	virtual HRESULT GetObject(
        CInstance* pInstance, 
        long lFlags, 
        CFrameworkQuery &pQuery);

	virtual HRESULT EnumerateInstances(
        MethodContext*  pMethodContext, 
        long lFlags = 0L);

	virtual HRESULT ExecQuery(
        MethodContext *pMethodContext, 
        CFrameworkQuery& pQuery, 
        long lFlags /*= 0L*/ );





private:

    HRESULT GetAllMappedDrives(
        MethodContext* pMethodContext,
         __int64 i44SessionID,
        DWORD dwPID,
        DWORD dwReqProps);

    HRESULT GetSingleMappedDrive(
        MethodContext* pMethodContext,
        __int64 i44SessionID,
        DWORD dwPID,
        CHString& chstrDeviceID,
        DWORD dwReqProps);

    HRESULT ProcessInstance(
        long lDriveIndex,
        __int64 i64SessionID,
        SAFEARRAY* psa,
        MethodContext* pMethodContext,
        DWORD dwReqProps);

    bool IsArrayValid(
        VARIANT* v);

#endif
    CHPtrArray m_ptrProperties;


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicalfilesecuritysetting.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//	Win32logicalFileSecSetting.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "securefile.h"
#include "win32logicalfilesecuritysetting.h"

#include "ImpLogonUser.h"

#include <accctrl.h>
#include "AccessRights.h"
#include "SecureShare.h"
#include "wbemnetapi32.h"

#include "SecUtils.h"

/*
	DEFENITION FROM THE MOF
    [description("security settings for a logical file")]
class Win32_LogicalFileSecuritySetting : Win32_SecuritySetting
{
    	[key]
    string Path;

        [implemented, description("Retrieves a structural representation of the object's "
         "security descriptor")]
    uint32 GetSecurityDescriptor([out] Win32_SecurityDescriptor);

        [implemented, description("Sets security descriptor to the specified structure")]
    uint32 SetSecurityDescriptor([in] Win32_SecurityDescriptor Descriptor)
};
*/



Win32LogicalFileSecuritySetting LogicalFileSecuritySetting( WIN32_LOGICAL_FILE_SECURITY_SETTING, IDS_CimWin32Namespace );

Win32LogicalFileSecuritySetting::Win32LogicalFileSecuritySetting ( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/ )
: CImplement_LogicalFile(setName, pszNameSpace)
{
}

Win32LogicalFileSecuritySetting::~Win32LogicalFileSecuritySetting ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32LogicalFileSecuritySetting::ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

	// Do we recognize the method?
	if (_wcsicmp(bstrMethodName, L"GetSecurityDescriptor") == 0)
	{
        hr = ExecGetSecurityDescriptor(pInstance, pInParams, pOutParams, lFlags);
   	}
   	else if (_wcsicmp(bstrMethodName, L"SetSecurityDescriptor") == 0)
   	{
   		// actually sets the security descriptor on the object by
		// taking the properties out of the Win32_SecurityDescriptor
		// and turning them into a CSecurityDescriptor object to apply
		// to the secure file.
   		hr = ExecSetSecurityDescriptor(pInstance, pInParams, pOutParams, lFlags);
   	}
	else
   	{
    	hr = WBEM_E_INVALID_METHOD;
	}
#endif

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalFileSecuritySetting::ExecGetSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalFileSecuritySetting::ExecGetSecurityDescriptor (
	const CInstance& pInstance,
	CInstance* pInParams,
	CInstance* pOutParams,
	long lFlags
)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	// converts the security descriptor from the file into a
	// Win32_Security object.
	if (pOutParams)
	{
		CHString chsPath;
		CSid sidOwner;
		CSid sidGroup;
		CDACL dacl;
		CSACL sacl;
		CInstancePtr pTrusteeOwner;
		CInstancePtr pTrusteeGroup;
		CInstancePtr pSecurityDescriptor;

		if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_SecurityDescriptor", &pSecurityDescriptor, GetNamespace())))
		{
			SECURITY_DESCRIPTOR_CONTROL control;
			pInstance.GetCHString(IDS_Path, chsPath);

			// check to see that it is of the right type?
			// get the secure file based on the path
			CSecureFile secFile ;
			DWORD dwRetVal = secFile.SetFileName(chsPath, TRUE) ;
			if ( dwRetVal == ERROR_ACCESS_DENIED )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_ACCESS_DENIED) ;
				return WBEM_E_ACCESS_DENIED;
			}
			else if ( dwRetVal == ERROR_PRIVILEGE_NOT_HELD )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_PRIVILEGE_NOT_HELD ) ;
                SetSinglePrivilegeStatusObject(pInstance.GetMethodContext(), SE_SECURITY_NAME);
				return WBEM_E_ACCESS_DENIED;
			}

			secFile.GetControl(&control);

			pSecurityDescriptor->SetDWORD(IDS_ControlFlags, control);

			// get the secure file's owner to create the Owner Trustee
			secFile.GetOwner(sidOwner);

			if ( sidOwner.IsValid() && SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_Trustee", &pTrusteeOwner, GetNamespace())))
			{
				FillTrusteeFromSid(pTrusteeOwner, sidOwner);
				pSecurityDescriptor->SetEmbeddedObject(IDS_Owner, *pTrusteeOwner);
			}

			// get the secure file's group to create the Group Trustee
			secFile.GetGroup(sidGroup);
		  	if (sidGroup.IsValid() && SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_Trustee", &pTrusteeGroup, GetNamespace())))
			{
				FillTrusteeFromSid(pTrusteeGroup, sidGroup);
				pSecurityDescriptor->SetEmbeddedObject(IDS_Group, *pTrusteeGroup);
			}

			// get the secure file's DACL and prepare for a walk.
			secFile.GetDACL(dacl);
			FillInstanceDACL(pSecurityDescriptor, dacl);

			// get the secure file's SACL and prepare for a walk.
			secFile.GetSACL(sacl);
			FillInstanceSACL(pSecurityDescriptor, sacl);
			pOutParams->SetEmbeddedObject(METHOD_ARG_NAME_DESCRIPTOR, *pSecurityDescriptor) ;
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE, STATUS_SUCCESS ) ;


		}	// end if
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE) ;
		}


		return WBEM_NO_ERROR ;
	}	// end if
	else
	{
		return WBEM_E_INVALID_PARAMETER ;
	}	// end if
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalFileSecuritySetting::ExecSetSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalFileSecuritySetting::ExecSetSecurityDescriptor (
	const CInstance& pInstance,
	CInstance* pInParams,
	CInstance* pOutParams,
	long lFlags
)
{

	HRESULT hr = WBEM_S_NO_ERROR ;
	DWORD dwStatus = STATUS_SUCCESS ;

	if ( pInParams && pOutParams )
	{
		hr = CheckSetSecurityDescriptor (	pInstance ,
											pInParams ,
											pOutParams ,
											dwStatus
										) ;

		if ( SUCCEEDED ( hr ) )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}

HRESULT Win32LogicalFileSecuritySetting::CheckSetSecurityDescriptor (
											const CInstance& pInstance,
											CInstance* pInParams,
											CInstance* pOutParams,
											DWORD& dwStatus
										)
{

	// takes the Win32_SecurityDescriptor object that is passed in
	// converts it to a CSecurityDescriptor/CSecureFile object
	// and applies it the the CSecureFile
	bool bExists ;
	VARTYPE eType ;
	HRESULT hr = WBEM_S_NO_ERROR ;
	dwStatus = STATUS_SUCCESS ;
	CInstancePtr pAccess;

	if ( pInParams->GetStatus ( METHOD_ARG_NAME_DESCRIPTOR , bExists , eType ) )
	{
		if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		{
			if ( eType == VT_NULL )
			{
				dwStatus = STATUS_INVALID_PARAMETER ;
				hr = WBEM_E_INVALID_PARAMETER ;
			}
			else
			{
				if (!pInParams->GetEmbeddedObject(METHOD_ARG_NAME_DESCRIPTOR , &pAccess , pInParams->GetMethodContext()))
				{
					dwStatus = STATUS_INVALID_PARAMETER ;
					hr = WBEM_E_INVALID_PARAMETER ;
				}
			}
		}
		else
		{
			dwStatus = STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		dwStatus = STATUS_INVALID_PARAMETER ;
		hr = WBEM_E_INVALID_PARAMETER ;
	}

    CInstancePtr pOwner;
    bool bOwnerSpecified = false ;
	if(SUCCEEDED(hr))
    {
	    if ( pAccess->GetStatus ( IDS_Owner , bExists , eType ) )
	    {
		    if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		    {
			    if ( eType == VT_NULL )
			    {
				    bOwnerSpecified = false ;
			    }
			    else
			    {
				    if ( pAccess->GetEmbeddedObject ( IDS_Owner , &pOwner , pAccess->GetMethodContext () ) )
				    {
					    bOwnerSpecified = true ;
				    }
				    else
				    {
					    dwStatus = STATUS_INVALID_PARAMETER ;
					    hr = WBEM_E_INVALID_PARAMETER ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = STATUS_INVALID_PARAMETER ;
			    hr =  WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = STATUS_INVALID_PARAMETER ;
		    hr =  WBEM_E_INVALID_PARAMETER ;
	    }
    }


    CInstancePtr pGroup ;
    bool bGroupSpecified = false ;
	if(SUCCEEDED(hr))
    {
	    if ( pAccess->GetStatus ( IDS_Group , bExists , eType ) )
	    {
		    if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		    {
			    if ( eType == VT_NULL )
			    {
				    bGroupSpecified = false ;
			    }
			    else
			    {
				    if ( pAccess->GetEmbeddedObject ( IDS_Group , &pGroup , pAccess->GetMethodContext () ) )
				    {
					    bGroupSpecified = true ;
				    }
				    else
				    {
					    dwStatus = STATUS_INVALID_PARAMETER ;
					    hr = WBEM_E_INVALID_PARAMETER ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = STATUS_INVALID_PARAMETER ;
		    hr = WBEM_E_INVALID_PARAMETER ;
	    }
    }


    SECURITY_DESCRIPTOR_CONTROL control;
    bool t_fDaclAutoInherited = false;
    bool t_fSaclAutoInherited = false;

    if(SUCCEEDED(hr))
    {
	    // Get the control flags...

	    if ( pAccess->GetStatus ( IDS_ControlFlags , bExists , eType ) )
	    {
		    if ( bExists &&  eType == VT_I4 )
		    {

			    if (!pAccess->GetDWORD(IDS_ControlFlags, (DWORD&)control))
			    {
				    dwStatus = STATUS_INVALID_PARAMETER ;
				    hr = WBEM_E_INVALID_PARAMETER ;
			    }
#ifdef NTONLY
#if NTONLY >= 5
                else
                {
                    if(control & SE_DACL_AUTO_INHERITED) t_fDaclAutoInherited = true;
                    if(control & SE_DACL_PROTECTED) t_fDaclAutoInherited = false; // this test comes second since this setting is supposed to override the first

                    if(control & SE_SACL_AUTO_INHERITED) t_fSaclAutoInherited = true;
                    if(control & SE_SACL_PROTECTED) t_fSaclAutoInherited = false; // this test comes second since this setting is supposed to override the first
                }
#endif
#endif
		    }
		    else
		    {
			    dwStatus = STATUS_INVALID_PARAMETER ;
			    hr =  WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = STATUS_INVALID_PARAMETER ;
		    hr =  WBEM_E_INVALID_PARAMETER ;
	    }
    }



	// Get the owner sid...
    CSid* psidOwner = NULL;
    bool fOwnerDefaulted = false;
    if(SUCCEEDED(hr))
    {
	    if(bOwnerSpecified)
	    {
            try
            {
                psidOwner = new CSid;
            }
            catch(...)
            {
                if(psidOwner != NULL)
                {
                    delete psidOwner;
                    psidOwner = NULL;
                }
                throw;
            }
            if(psidOwner != NULL)
            {
                if(FillSIDFromTrustee(pOwner, *psidOwner) == STATUS_SUCCESS)
		        {
			        fOwnerDefaulted = (control & SE_OWNER_DEFAULTED) ? true : false ;
                    if(!psidOwner->IsValid())
		            {
			            delete psidOwner;
                        dwStatus = STATUS_INVALID_PARAMETER ;
			            hr = WBEM_E_INVALID_PARAMETER ;
		            }
                }
				else
				{
                    dwStatus = STATUS_INVALID_PARAMETER;
                    hr = WBEM_E_INVALID_PARAMETER;
				}
            }
            else
            {
                dwStatus = E_FAIL ;
		        hr = WBEM_E_PROVIDER_FAILURE ;
            }
	    }
    }


    // Get the group sid...
    CSid* psidGroup = NULL;
    bool fGroupDefaulted = false;
    if(SUCCEEDED(hr))
    {
	    if(bGroupSpecified)
	    {
		    try
            {
                psidGroup = new CSid;
            }
            catch(...)
            {
                if(psidGroup != NULL)
                {
                    delete psidGroup;
                    psidGroup = NULL;
                }
                throw;
            }
            if(psidGroup != NULL)
            {
                if( FillSIDFromTrustee(pGroup, *psidGroup)  == STATUS_SUCCESS )
		        {
			        fGroupDefaulted = ( control & SE_GROUP_DEFAULTED ) ? true : false ;
			        //sid validity checked here as FillSIDFromTrustee returns success if null sid
                    if(!psidGroup->IsValid())
			        {
                        delete psidGroup;
                        dwStatus = STATUS_INVALID_PARAMETER ;
			            hr = WBEM_E_INVALID_PARAMETER ;
		            }
                }
                else
				{
                    dwStatus = STATUS_INVALID_PARAMETER;
                    hr = WBEM_E_INVALID_PARAMETER;
				}
            }
            else
            {
                dwStatus = E_FAIL ;
		        hr = WBEM_E_PROVIDER_FAILURE ;
            }
	    }
    }


    // Get the dacl...
    CDACL* pdacl = NULL;
    bool fDaclDefaulted = false;
    if(SUCCEEDED(hr))
    {
	    // Only bother with a dacl if we are going to be setting it, which is controled by the control flags specified...
        if(control & SE_DACL_PRESENT)
        {
            DWORD dwACLSize =0;
            try
            {
                pdacl = new CDACL;
            }
            catch(...)
            {
                if(pdacl != NULL)
                {
                    delete pdacl;
                    pdacl = NULL;
                }
                throw;
            }
            if(pdacl != NULL)
            {
	            if( (dwStatus = FillDACLFromInstance(pAccess, *pdacl, pAccess->GetMethodContext () ) ) != STATUS_SUCCESS )
	            {
                   if(dwStatus == STATUS_NULL_DACL)
                    {
                        // No dacl was specified - e.g., we have a NULL dacl.  Since we mimic a NULL dacl as a dacl with
                        // an Everyone ACCESS_ALLOWED entry, create that here:
                        if(!pdacl->CreateNullDACL())
                        {
                            delete pdacl;
                            pdacl = NULL;
                            dwStatus = E_FAIL ;
		                    hr = WBEM_E_PROVIDER_FAILURE ;
                        }
                    }
                    else if(dwStatus == STATUS_EMPTY_DACL)
                    {
                        pdacl->Clear(); // "creates" the empty dacl
                    }
                    else
                    {
                        delete pdacl;
                        pdacl = NULL;
                        dwStatus = STATUS_INVALID_PARAMETER ;
                        hr = WBEM_E_INVALID_PARAMETER;
                    }
                }
                if(SUCCEEDED(hr))
                {
                    fDaclDefaulted = (control & SE_DACL_DEFAULTED) ? true : false ;
                }
            }
            else
            {
                dwStatus = E_FAIL;
                hr = WBEM_E_PROVIDER_FAILURE;
            }
        }
    }


    // Create the sacl...
    CSACL* psacl = NULL;
    bool fSaclDefaulted = false;
    //bool bSaclSpecified = false;

    if(SUCCEEDED(hr))
    {
        // Only bother with a sacl if we are going to be setting it, which is controled by the control flags specified...
        if(control & SE_SACL_PRESENT)
        {
	        DWORD dwSACLSize = 0;
            try
            {
                psacl = new CSACL;
            }
            catch(...)
            {
                if(psacl != NULL)
                {
                    delete psacl;
                    psacl = NULL;
                }
                throw;
            }
            if(psacl != NULL)
            {
	            if( (dwStatus = FillSACLFromInstance(pAccess, *psacl, pAccess->GetMethodContext () ) ) == STATUS_SUCCESS )
	            {
		            if(!psacl->CalculateSACLSize( &dwSACLSize ) )
		            {
			            dwStatus = E_FAIL ;
                        hr = WBEM_E_PROVIDER_FAILURE;
		            }

                    if(SUCCEEDED(hr))
                    {
                        bool fSaclDefaulted = ( control & SE_SACL_DEFAULTED ) ? true : false ;
		                if(dwSACLSize < sizeof(ACL))
		                {
			                // If we are here, we have no SACL, so delete and set to NULL our SACL pointer...
                            delete psacl;
                            psacl = NULL;
		                }
                        else
                        {
                            //bSaclSpecified = true;
                        }
                    }
	            }
                else // Not a problem if we have no SACL, but we do need to delete the one we allocated
                {
                    if(psacl != NULL) // test just in case FillSACLFromInstance somehow deleted it
                    {
                        delete psacl;
                        psacl = NULL;
                    }
                }
            }
            else
            {
                dwStatus = E_FAIL;
                hr = WBEM_E_PROVIDER_FAILURE;
            }
        }
    }

    // Only proceed if all is well...
    if(SUCCEEDED(hr))
    {
	    CHString chsPath;
	    pInstance.GetCHString(IDS_Path, chsPath);
	    CSecureFile secFile(chsPath,
                            psidOwner,
                            fOwnerDefaulted,
                            psidGroup,
                            fGroupDefaulted,
                            pdacl,
                            fDaclDefaulted,
                            t_fDaclAutoInherited,
                            psacl,
                            fSaclDefaulted,
                            t_fSaclAutoInherited);

	    SECURITY_INFORMATION securityinfo = 0 ;
	    if(bOwnerSpecified)
	    {
		    securityinfo |= OWNER_SECURITY_INFORMATION ;
	    }
	    if(bGroupSpecified)
	    {
		    securityinfo |= GROUP_SECURITY_INFORMATION ;
	    }
	    if(control & SE_DACL_PRESENT) // if the control flag indicates that no dacl is present, that really means the user doesn't want to do anything to the dacl, not that the dacl is a NULL DACL.
	    {
            securityinfo |= DACL_SECURITY_INFORMATION ;
#if NTONLY >= 5
            if(!t_fDaclAutoInherited)
            {
                securityinfo |= PROTECTED_DACL_SECURITY_INFORMATION;
            }
            else
            {
                securityinfo |= UNPROTECTED_DACL_SECURITY_INFORMATION;
            }
#endif
	    }

	    //if(bSaclSpecified)
        if(control & SE_SACL_PRESENT)  // even if psacl is null, if the user specified that one was present, we need to say it was there, since this is the only way the user can remove a sacl (otherwise the rest of the descriptor is set, and whatever state a sacl might have been in, it stays in.
	    {
            securityinfo |= SACL_SECURITY_INFORMATION ;
#if NTONLY >= 5
            if(!t_fSaclAutoInherited)
            {
                securityinfo |= PROTECTED_SACL_SECURITY_INFORMATION;
            }
            else
            {
                securityinfo |= UNPROTECTED_SACL_SECURITY_INFORMATION;
            }
#endif
	    }

	    // Finally do all the work that everything else has been preparation for...
        dwStatus = secFile.ApplySecurity( securityinfo ) ;


	    if(dwStatus == ERROR_SUCCESS )
	    {
		    dwStatus = STATUS_SUCCESS ;
	    }

        // DON'T DO THIS! HIDES WHAT HAPPENED FOR NO GOOD REASON!
        //else
	    //{
		//    dwStatus = GetWin32ErrorToStatusCode( dwStatus ) ;
	    //}
    }

	if(psidOwner != NULL)
	{
		delete psidOwner;
        psidOwner = NULL;
	}
	if(psidGroup != NULL)
	{
		delete psidGroup;
        psidGroup = NULL;
	}
    if(pdacl != NULL)
	{
		delete pdacl;
        pdacl = NULL;
	}
    if(psacl != NULL)
	{
		delete psacl;
        psacl = NULL;
	}

    return hr ;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalFileSecuritySetting::EnumerateInstances
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalFileSecuritySetting::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY

	// let the callback do the real work


    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


//if (SUCCEEDED(hr = CWbemProviderGlue::ExecQueryAsync (L"CIM_LogicalFile", this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, NULL)))
	if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQueryAsynch(L"Select Name from CIM_LogicalFile" ,  this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, NULL)))
	{
	}

#endif

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


	return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32LogicalFileSecuritySetting::EnumerationCallback(CInstance* pFile, MethodContext* pMethodContext, void* pUserData)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// Start pumping out the instances
    CInstancePtr pInstance;
    pInstance.Attach(CreateNewInstance(pMethodContext));
	if (pInstance)
	{

		CHString chsPath;
		pFile->GetCHString(IDS_Name, chsPath);

	    // Do the puts, and that's it
		if (!chsPath.IsEmpty())
		{
			CSecureFile secFile;
            DWORD dwRet = secFile.SetFileName(chsPath, TRUE);
			if (ERROR_ACCESS_DENIED != dwRet)
			{
				if (dwRet == ERROR_PRIVILEGE_NOT_HELD)
                    SetSinglePrivilegeStatusObject(pInstance->GetMethodContext(), SE_SECURITY_NAME);

                SECURITY_DESCRIPTOR_CONTROL control;
				secFile.GetControl(&control);
				pInstance->SetDWORD(IDS_ControlFlags, control);
			}	// end if
			else
			{
				hr = WBEM_S_ACCESS_DENIED;
			}
		    pInstance->SetCHString(IDS_Path, chsPath);

            if(AmIAnOwner(chsPath, SE_FILE_OBJECT)) // secutils.cpp routine
            {
                pInstance->Setbool(IDS_OwnerPermissions, true);
            }
            else
            {
                pInstance->Setbool(IDS_OwnerPermissions, false);
            }

		}	// end if

        CHString chstrTemp;

        chstrTemp.Format(L"Security settings of %s", (LPCWSTR)chsPath);
        pInstance->SetCHString(IDS_Caption, chstrTemp);
        pInstance->SetCHString(IDS_Description, chstrTemp);

		if ( SUCCEEDED ( hr ) && hr != WBEM_S_ACCESS_DENIED )
		{
		    hr = pInstance->Commit();
		}	// end if

	}	// end if
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT WINAPI Win32LogicalFileSecuritySetting::StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData)
{
	Win32LogicalFileSecuritySetting* pThis;
	HRESULT hr;

	pThis = dynamic_cast<Win32LogicalFileSecuritySetting *>(pThat);
	ASSERT_BREAK(pThis != NULL);

	if (pThis)
	{
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
	}
	else
	{
    	hr = WBEM_E_FAILED;
	}
	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalFileSecuritySetting::GetObject
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalFileSecuritySetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery )
{
//	_bstr_t bstrtDrive;
//    _bstr_t bstrtPathName;
//    WCHAR wstrTemp[_MAX_PATH];
//    WCHAR* pwc = NULL;
//    WCHAR* pwcName = NULL;
    HRESULT hr;
	CHString chstrPathName;

//    ZeroMemory(wstrTemp,sizeof(wstrTemp));


    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif



#ifdef NTONLY

	if(pInstance != NULL)
	{
		pInstance->GetCHString(IDS_Path, chstrPathName);

        CHString chstrLFDrive;
        CHString chstrLFPath;
        CHString chstrLFName;
        CHString chstrLFExt;
        bool fRoot;

        RemoveDoubleBackslashes(chstrPathName, chstrPathName);

        CSecureFile secFile;
        DWORD dwRet = secFile.SetFileName(chstrPathName, TRUE);
		if(dwRet != ERROR_ACCESS_DENIED)
		{
		    if(dwRet == ERROR_PRIVILEGE_NOT_HELD) SetSinglePrivilegeStatusObject(pInstance->GetMethodContext(), SE_SECURITY_NAME);
			SECURITY_DESCRIPTOR_CONTROL control;
			secFile.GetControl(&control);
			//pInstance->SetDWORD(IDS_ControlFlags, control);


            // Break the directory into its constituent parts
            GetPathPieces(chstrPathName, chstrLFDrive, chstrLFPath, chstrLFName, chstrLFExt);

            // Find out if we are looking for the root directory
            if(chstrLFPath==L"\\" && chstrLFName==L"" && chstrLFExt==L"")
            {
                fRoot = true;
                // If we are looking for the root, our call to EnumDirs presumes that we specify
                // that we are looking for the root directory with "" as the path, not "\\".
                // Therefore...
                chstrLFPath = L"";
            }
            else
            {
                fRoot = false;
            }

            hr = EnumDirsNT(CNTEnumParm(pInstance->GetMethodContext(),
                            chstrLFDrive,   // drive letter and colon
                            chstrLFPath,    // use the given path
                            chstrLFName,    // filename
                            chstrLFExt,     // extension
                            false,          // no recursion desired
                            NULL,           // don't need the file system name
                            NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                            fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                            (void*)control));         // don't need to use the extra parameter to pass the Control Flags we got.

        }
		else
		{
			hr = WBEM_E_ACCESS_DENIED;
		}
	}	// end if(pInstance!=NULL)

#endif

	if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return(hr);

}


HRESULT Win32LogicalFileSecuritySetting::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    // Even though we are derived from cimplement_logicalfile, because the key field for this class
    // is Path, while the key for the logicalfile classes is Name, and Path for them refers to the path
    // component of the fully qualified pathname, we need to do some of the work here, then call on
    // EnumDirsNT to do the bulk of the work.

    HRESULT hr = WBEM_S_NO_ERROR;
#ifdef NTONLY
    std::vector<_bstr_t> vectorPaths;
    std::vector<CDriveInfo*> vecpDI;
    bool bRoot = false;
    bool fGotDrives = false;
    bool fNeedFS = false;
    DWORD dwPaths;
    LONG lDriveIndex;
    pQuery.GetValuesForProp(IDS_Path, vectorPaths);
    dwPaths = vectorPaths.size();



    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif



    // Determine whether certain other expensive properties are required:
    DWORD dwReqProps = PROP_NO_SPECIAL;
    DetermineReqProps(pQuery, &dwReqProps);

    // Get listing of drives and related info (only if the file system is needed):
    if(dwReqProps & PROP_FILE_SYSTEM)
    {
        GetDrivesAndFS(vecpDI, true);
        fGotDrives = true;
        fNeedFS = true;
    }

    if(dwPaths > 0)
    {


        // In this case we were given one or more fully qualified pathnames.
        // So we just need to look for those files.
        WCHAR* pwch;
        WCHAR* pwstrFS;
        // For all the specific files, get the info
        for(long x=0; x < dwPaths; x++)
        {
            CSecureFile secFile;
            DWORD dwRet = secFile.SetFileName(vectorPaths[x], TRUE);
		    if(dwRet != ERROR_ACCESS_DENIED)
		    {
		        if(dwRet == ERROR_PRIVILEGE_NOT_HELD) SetSinglePrivilegeStatusObject(pMethodContext, SE_SECURITY_NAME);
			    SECURITY_DESCRIPTOR_CONTROL control;
			    secFile.GetControl(&control);

                pwstrFS = NULL;
                // if the name contained a wildcard character, return WBEM_E_INVALID_QUERY:
                if(wcspbrk((wchar_t*)vectorPaths[x],L"?*") != NULL)
                {
                    if(fGotDrives)
                    {
                        FreeVector(vecpDI);
                    }
                    return WBEM_E_INVALID_QUERY;
                }

                pwch = NULL;
                _bstr_t bstrtTemp = vectorPaths[x];
                pwch = wcsstr((wchar_t*)bstrtTemp,L":");
                if(pwch != NULL)
                {
                    WCHAR wstrDrive[_MAX_PATH] = L"";
                    WCHAR wstrDir[_MAX_PATH] = L"";
                    WCHAR wstrFile[_MAX_PATH] = L"";
                    WCHAR wstrExt[_MAX_PATH] = L"";

                    _wsplitpath(bstrtTemp,wstrDrive,wstrDir,wstrFile,wstrExt);

                    if(fGotDrives)
                    {
                        if(!GetIndexOfDrive(wstrDrive, vecpDI, &lDriveIndex))
                        {
                            FreeVector(vecpDI);
                            return WBEM_E_NOT_FOUND;
                        }
                        else
                        {
                            pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                        }
                    }

                    // Find out if we are looking for the root directory
                    if(wcscmp(wstrDir,L"\\")==0 && wcslen(wstrFile)==0 && wcslen(wstrExt)==0)
                    {
                        bRoot = true;
                        // If we are looking for the root, our call to EnumDirs presumes that we specify
                        // that we are looking for the root directory with "" as the path, not "\\".
                        // Therefore...
                        wcscpy(wstrDir, L"");
                    }
                    else
                    {
                        bRoot = false;
                    }

                    // We should have been given the exact name of a file, with an extension.
                    // Therefore, the wstrDir now contains the path, filename, and extension.
                    // Thus, we can pass it into EnumDirsNT as the path, and an empty string
                    // as the completetionstring parameter, and still have a whole pathname
                    // for FindFirst (in EnumDirs) to work with.

                    //CInstance *pInstance = CreateNewInstance(pMethodContext);
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        wstrDrive,
                                        wstrDir,
                                        wstrFile,
                                        wstrExt,
                                        false,                 // no recursion desired
                                        NULL,             // don't need FS name
                                        NULL,             // don't need any of implement_logicalfile's props
                                        bRoot,
                                        (void*)control)); // use the extra param to pass control flags
			        }
                }
            }
        }
    }
    else  // let CIMOM handle filtering; we'll hand back everything!
    {
        EnumerateInstances(pMethodContext);
    }

    if(fGotDrives)
    {
        FreeVector(vecpDI);
    }

#endif

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif



    return(hr);
}



HRESULT Win32LogicalFileSecuritySetting::FindSpecificPathNT(CInstance *pInstance,
	const WCHAR* sDrive, const WCHAR* sDir)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	WIN32_FIND_DATAW
				stFindData,
				*pfdToLoadProp;
	SmartFindClose	hFind;
	WCHAR		szFSName[_MAX_PATH] = L"";
	BOOL		bIsRoot = !wcscmp(sDir, L"\\");
	_bstr_t	bstrFullPath,
				bstrRoot;

	bstrFullPath = sDrive;
	bstrFullPath += sDir;

	bstrRoot = sDrive;
	bstrRoot += L"\\";

	// if the directory contained a wildcard character, return WBEM_E_NOT_FOUND.
	if (wcspbrk(sDir,L"?*") != NULL)
		hr = WBEM_E_NOT_FOUND;

	if (SUCCEEDED(hr))
	{
		// FindFirstW doesn't work with root dirs (since they're not real dirs.)
		if (bIsRoot)
			pfdToLoadProp = NULL;
		else
		{
			pfdToLoadProp = &stFindData;
			ZeroMemory(&stFindData, sizeof(stFindData));

			hFind = FindFirstFileW((LPCWSTR) bstrFullPath, &stFindData);
			if (hFind == INVALID_HANDLE_VALUE)
				hr =  WBEM_E_NOT_FOUND;

		}
		if (SUCCEEDED(hr))
		{
			// If GetVolumeInformationW fails, only get out if we're trying
			// to get the root.
			if (!GetVolumeInformationW(bstrRoot, NULL, 0, NULL, NULL, NULL,
				szFSName, sizeof(szFSName)/sizeof(WCHAR)) && bIsRoot)
				hr = WBEM_E_NOT_FOUND;

			if (SUCCEEDED(hr))
			{
				if (bIsRoot)
			    {
	//		        LoadPropertyValuesNT(pInstance, sDrive, sDir, szFSName, NULL);
			    }
			    else
			    {
			        // sDir contains \\path\\morepath\\filename.exe at this point, instead
			        // of just \\path\\morepath\\, so need to hack of the last part.
			        WCHAR* wstrJustPath = NULL;
                    try
                    {
                        wstrJustPath = (WCHAR*) new WCHAR[wcslen(sDir) + 1];
			            WCHAR* pwc = NULL;
			            ZeroMemory(wstrJustPath,(wcslen(sDir) + 1)*sizeof(WCHAR));
			            wcscpy(wstrJustPath,sDir);
			            pwc = wcsrchr(wstrJustPath, L'\\');
			            if(pwc != NULL)
			            {
			                *(pwc+1) = L'\0';
			            }
		    //	        LoadPropertyValuesNT(pInstance, sDrive, wstrJustPath, szFSName, pfdToLoadProp)
                    }
                    catch(...)
                    {
                        if(wstrJustPath != NULL)
                        {
                            delete wstrJustPath;
                            wstrJustPath = NULL;
                        }
                        throw;
                    }

					delete wstrJustPath;
                    wstrJustPath = NULL;
			    }
			}	// end if
		}	// end if
	}	// end if
	return WBEM_S_NO_ERROR;
}

DWORD Win32LogicalFileSecuritySetting::GetWin32ErrorToStatusCode(DWORD dwWin32Error)
{
	DWORD dwStatus ;
	switch( dwWin32Error )
	{
	case ERROR_ACCESS_DENIED:
		dwStatus = STATUS_ACCESS_DENIED ;
		break ;
	default:
		dwStatus = STATUS_UNKNOWN_FAILURE ;
		break ;
	}

	return dwStatus ;
}




/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  Overridden here
 *                to return true always.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE can get security info, FALSE otherwise.
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL Win32LogicalFileSecuritySetting::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    return TRUE;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalFileSecuritySetting::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherrited from CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the Element and Setting
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT Win32LogicalFileSecuritySetting::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    WCHAR szBuff[_MAX_PATH * 2] = L"";
    bool bRoot = false;

    pInstance->SetDWORD(IDS_ControlFlags, (DWORD)((DWORD_PTR)pvMoreData));

    if(pstFindData == NULL)
    {
        bRoot = true;
    }
    if(!bRoot)
    {
        wsprintfW(szBuff,L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
        pInstance->SetWCHARSplat(IDS_Path, szBuff);
    }
    else
    {
        wsprintfW(szBuff,L"%s\\",pszDrive);
        pInstance->SetWCHARSplat(IDS_Path, szBuff);
    }

    CHString chstrTemp;
    chstrTemp.Format(L"Security settings of %s", szBuff);
    pInstance->SetCHString(IDS_Caption, chstrTemp);
    pInstance->SetCHString(IDS_Description, chstrTemp);

    if(AmIAnOwner(CHString(szBuff), SE_FILE_OBJECT))
    {
        pInstance->Setbool(IDS_OwnerPermissions, true);
    }
    else
    {
        pInstance->Setbool(IDS_OwnerPermissions, false);
    }

	return WBEM_S_NO_ERROR ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicalfilesecuritysetting.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//
//	Win32LogicalFileSecuritySetting
//
//////////////////////////////////////////////////////
#ifndef __LOGFILESECSETTING_H_
#define __LOGFILESECSETTING_H_

#undef  STATUS_SUCCESS								
#define STATUS_SUCCESS								0
#undef  STATUS_ACCESS_DENIED					
#define STATUS_ACCESS_DENIED						2

#define STATUS_UNKNOWN_FAILURE						8
#undef  STATUS_PRIVILEGE_NOT_HELD				
#define STATUS_PRIVILEGE_NOT_HELD					9

#undef  STATUS_INVALID_PARAMETER					
#define STATUS_INVALID_PARAMETER					21


#define METHOD_ARG_NAME_DESCRIPTOR					_T("Descriptor")
#define METHOD_ARG_NAME_RETURNVALUE					_T("ReturnValue")


#define  WIN32_LOGICAL_FILE_SECURITY_SETTING L"Win32_LogicalFileSecuritySetting"


#include "implement_logicalfile.h"


class Win32LogicalFileSecuritySetting : public CImplement_LogicalFile
{
    private:
    protected:



#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual HRESULT LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive,
                                          const WCHAR* pszPath,
                                          const WCHAR* pszFSName,
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

        virtual HRESULT ExecQuery(MethodContext* pMethodContext,
                                  CFrameworkQuery& pQuery,
                                  long lFlags = 0L);

        virtual HRESULT DeleteInstance(
            const CInstance& newInstance, 
            long lFlags = 0L) { return WBEM_E_PROVIDER_NOT_CAPABLE; }

    public:
	    Win32LogicalFileSecuritySetting (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	    ~Win32LogicalFileSecuritySetting ();

	    HRESULT ExecMethod
	    (
		    const CInstance& a_Instance,
		    const BSTR a_MethodName,
		    CInstance *a_InParams,
		    CInstance *a_OutParams,
		    long lFlags = 0L
	    );

	    HRESULT ExecGetSecurityDescriptor
	    (
		    const CInstance& pInstance,
		    CInstance* pInParams,
		    CInstance* pOutParams,
		    long lFlags
	    );

	    HRESULT ExecSetSecurityDescriptor
	    (
		    const CInstance& pInstance,
		    CInstance* pInParams,
		    CInstance* pOutParams,
		    long lFlags
	    );

	    HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);
	    HRESULT GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery );
	    HRESULT FindSpecificPathNT(CInstance *pInstance, const WCHAR* sDrive, const WCHAR* sDir);
	    HRESULT EnumerationCallback(CInstance* pFile, MethodContext* pMethodContext, void* pUserData);
	    static HRESULT WINAPI StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData);
	
	    DWORD Win32LogicalFileSecuritySetting::GetWin32ErrorToStatusCode(DWORD dwWin32Error) ;
	    HRESULT Win32LogicalFileSecuritySetting::CheckSetSecurityDescriptor (	
											    const CInstance& pInstance,
											    CInstance* pInParams,
											    CInstance* pOutParams,
											    DWORD& dwStatus
										    ) ;
	
};	// end class Win32LogicalFileSecuritySetting

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicalsharesecuritysetting.cpp ===
//

//	Win32logicalFileSecSetting.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>

#include "sid.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "win32logicalsharesecuritysetting.h"

#include <windef.h>
#include <lmcons.h>
#include <lmshare.h>
#include "wbemnetapi32.h"
#include "secureshare.h"
#include "SecUtils.h"

/*
	DEFENITION FROM THE MOF
    [Dynamic, Provider ("secrcw32") , Description("security settings for a logical file")]
class Win32_LogicalShareSecuritySetting : Win32_SecuritySetting
{
    	[key]
    string Name;

        [implemented, description("Retrieves a structural representation of the object's "
         "security descriptor")]
    uint32 GetSecurityDescriptor([out] Win32_SecurityDescriptor Descriptor);

        [implemented, description("Sets security descriptor to the specified structure")]
    uint32 SetSecurityDescriptor([in] Win32_SecurityDescriptor Descriptor);
};
*/


Win32LogicalShareSecuritySetting LogicalShareSecuritySetting( WIN32_LOGICAL_SHARE_SECURITY_SETTING, IDS_CimWin32Namespace );

Win32LogicalShareSecuritySetting::Win32LogicalShareSecuritySetting(LPCWSTR setName, LPCWSTR pszNameSpace /*=NULL*/ )
: Provider (setName, pszNameSpace)
{
}

Win32LogicalShareSecuritySetting::~Win32LogicalShareSecuritySetting()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalShareSecuritySetting::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32LogicalShareSecuritySetting::ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/)
{
	//this is supposed to be called only on NT

#ifdef NTONLY
	HRESULT hr = WBEM_NO_ERROR;
	// Do we recognize the method?

	if (_wcsicmp(bstrMethodName, L"GetSecurityDescriptor") == 0)
	{
		hr = ExecGetSecurityDescriptor(pInstance, pInParams, pOutParams, lFlags);
   	}
   	else if (_wcsicmp(bstrMethodName, L"SetSecurityDescriptor") == 0)
   	{
   		// actually sets the security descriptor on the object by
		// taking the properties out of the Win32_SecurityDescriptor
		// and turning them into a CSecurityDescriptor object to apply
		// to the secure file.
   		hr = ExecSetSecurityDescriptor(pInstance, pInParams, pOutParams, lFlags);
   	}
	else
   	{
    	hr = WBEM_E_INVALID_METHOD;
	}

	return hr;
#endif
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalShareSecuritySetting::ExecGetSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::ExecGetSecurityDescriptor (
	const CInstance& pInstance,
	CInstance* pInParams,
	CInstance* pOutParams,
	long lFlags
)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	CAdvApi32Api *t_pAdvApi32 = NULL;
	SHARE_INFO_502 *pShareInfo502 = NULL ;
	PSECURITY_DESCRIPTOR pSD = NULL ;
	CNetAPI32 NetAPI ;

	try
	{
		// converts the security descriptor from the file into a
		// Win32_Security object.
		if (pOutParams)
		{
			CHString chsShareName;
			CSid sidOwner;
			CSid sidGroup;
			CDACL dacl;
			CSACL sacl;
			CInstancePtr pTrusteeOwner;
			CInstancePtr pTrusteeGroup;
			CInstancePtr pSecurityDescriptor;
			SECURITY_DESCRIPTOR_CONTROL control;

			t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
			DWORD dwStatusCode = LSSS_STATUS_UNKNOWN_FAILURE ;

			pInstance.GetCHString(IDS_Name, chsShareName);

			DWORD dwVer = GetPlatformMajorVersion() ;

			if( dwVer >= 4 )
			{
				PACL pDacl = NULL ;
				if ( t_pAdvApi32 != NULL )
				{
					 _bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;

					 t_pAdvApi32->GetNamedSecurityInfoW(
																bstrName ,
																SE_LMSHARE,
																DACL_SECURITY_INFORMATION,
																NULL,
																NULL,
																&pDacl,
																NULL,
																&pSD, &dwStatusCode
															) ;
				}
			}
			else
			{
				_bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;
				if( ( dwStatusCode = NetAPI.Init() ) == ERROR_SUCCESS )
				{
					dwStatusCode = NetAPI.NetShareGetInfo(	NULL,
											(LPTSTR) bstrName,
											502,
											(LPBYTE *) &pShareInfo502)  ;
				}
			}

			if( dwStatusCode == NERR_Success || dwStatusCode == ERROR_SUCCESS )
			{
			   //Sec. Desc. is not returned for IPC$ ,C$ ...shares for Admin purposes
				if( !pSD && ( !pShareInfo502 || pShareInfo502->shi502_security_descriptor == NULL ) )
				{
					pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , LSSS_STATUS_DESCRIPTOR_NOT_AVAILABLE ) ;
				}
				else
				{
					if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_SecurityDescriptor", &pSecurityDescriptor, GetNamespace())))
					{
						CSecureShare SecShare(pSD ? pSD : pShareInfo502->shi502_security_descriptor) ;
						SecShare.GetControl(&control);
						pSecurityDescriptor->SetDWORD(IDS_ControlFlags, control);

						// get the secure file's owner to create the Owner Trustee
						SecShare.GetOwner(sidOwner);

						if ( sidOwner.IsValid() && SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_Trustee", &pTrusteeOwner, GetNamespace())))
						{
							FillTrusteeFromSid(pTrusteeOwner, sidOwner);
							pSecurityDescriptor->SetEmbeddedObject(IDS_Owner, *pTrusteeOwner);
						}

						// get the secure file's group to create the Group Trustee
						SecShare.GetGroup(sidGroup);
		  				if ( sidGroup.IsValid() && SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance.GetMethodContext(), L"Win32_Trustee", &pTrusteeGroup, GetNamespace())))
						{
							FillTrusteeFromSid(pTrusteeGroup, sidGroup);
							pSecurityDescriptor->SetEmbeddedObject(IDS_Group, *pTrusteeGroup);
						}

						// get the secure file's DACL and prepare for a walk.
						SecShare.GetDACL(dacl);
						FillInstanceDACL(pSecurityDescriptor, dacl);

						// get the secure file's SACL and prepare for a walk.
						SecShare.GetSACL(sacl);
						FillInstanceSACL(pSecurityDescriptor, sacl);

						//			pOutParams = pSecurityDescriptor;
						pOutParams->SetEmbeddedObject(METHOD_ARG_NAME_DESCRIPTOR, *pSecurityDescriptor) ;

						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE, LSSS_STATUS_SUCCESS ) ;

						//remove this line
	//					ExecSetSecurityDescriptor (pInstance,pSecurityDescriptor,pOutParams,0) ;

					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , LSSS_STATUS_UNKNOWN_FAILURE) ;
					}

				}
		   }
		   else //NetAPI.NetShareGetInfo call failed
		   {
				//dwStatusCode = GetStatusCode(dwStatusCode) ;
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatusCode ) ;
		   }
		} //if (pOutParams)
		else
		{
			return WBEM_E_INVALID_PARAMETER ;

		}	// end if
	}
	catch ( ... )
	{
		if(t_pAdvApi32 != NULL)
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
			t_pAdvApi32 = NULL;
		}

		if ( pShareInfo502 )
		{
			NetAPI.NetApiBufferFree(pShareInfo502);
			pShareInfo502 = NULL ;
		}
		if ( pSD )
		{
			LocalFree ( pSD ) ;
			pSD = NULL ;
		}
		throw ;
		return WBEM_E_FAILED; // To get rid of 64-bit compilation warnings
	}

	if(t_pAdvApi32 != NULL)
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
		t_pAdvApi32 = NULL;
	}

	if ( pShareInfo502 )
	{
		NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
		pShareInfo502 = NULL ;
	}
	if ( pSD )
	{
		LocalFree ( pSD ) ;
		pSD = NULL ;
	}


	 return WBEM_NO_ERROR ;
}
#endif

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalShareSecuritySetting::ExecSetSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::ExecSetSecurityDescriptor (
	const CInstance& pInstance,
	CInstance* pInParams,
	CInstance* pOutParams,
	long lFlags
)
{

	HRESULT hr = WBEM_S_NO_ERROR ;
	DWORD dwStatus = LSSS_STATUS_SUCCESS ;

	if ( pInParams && pOutParams )
	{
		hr = CheckSetSecurityDescriptor (	pInstance ,
											pInParams ,
											pOutParams ,
											dwStatus
										) ;

		if ( SUCCEEDED ( hr ) )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}
#endif


#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::CheckSetSecurityDescriptor (
											const CInstance& pInstance,
											CInstance* pInParams,
											CInstance* pOutParams,
											DWORD& dwStatus
										)
{

	bool bExists ;
	VARTYPE eType ;
	HRESULT hr = WBEM_S_NO_ERROR ;
	dwStatus = LSSS_STATUS_SUCCESS ;

	SECURITY_DESCRIPTOR absoluteSD;
	PSECURITY_DESCRIPTOR pRelativeSD = NULL;
	InitializeSecurityDescriptor((PVOID)&absoluteSD, SECURITY_DESCRIPTOR_REVISION) ;
	CInstancePtr pAccess;

	if ( pInParams->GetStatus ( METHOD_ARG_NAME_DESCRIPTOR , bExists , eType ) )
	{
		if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		{
			if ( eType == VT_NULL )
			{
				dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				hr = WBEM_E_INVALID_PARAMETER ;
			}
			else
			{
				if ( pInParams->GetEmbeddedObject ( METHOD_ARG_NAME_DESCRIPTOR , &pAccess , pInParams->GetMethodContext () ) )
				{
				}
				else
				{
					dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
					hr = WBEM_E_INVALID_PARAMETER ;
				}
			}
		}
		else
		{
			dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
		hr = WBEM_E_INVALID_PARAMETER ;
	}


	CInstancePtr pOwner;
    bool bOwnerSpecified = false ;
    if(SUCCEEDED(hr))
	{
		if ( pAccess->GetStatus ( IDS_Owner , bExists , eType ) )
		{
			if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
			{
				if ( eType == VT_NULL )
				{
					bOwnerSpecified = false ;
				}
				else
				{
					if ( pAccess->GetEmbeddedObject ( IDS_Owner , &pOwner , pAccess->GetMethodContext () ) )
					{
						bOwnerSpecified = true ;
					}
					else
					{
						dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
						hr = WBEM_E_INVALID_PARAMETER ;
					}
				}
			}
			else
			{
				dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				hr = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_INVALID_PARAMETER ;
		}
	}

    CInstancePtr pGroup;
    bool bGroupSpecified = false ;
    if(SUCCEEDED(hr))
    {
	    if ( pAccess->GetStatus ( IDS_Group , bExists , eType ) )
	    {
		    if ( bExists && ( eType == VT_UNKNOWN || eType == VT_NULL ) )
		    {
			    if ( eType == VT_NULL )
			    {
				    bGroupSpecified = false ;
			    }
			    else
			    {
				    if ( pAccess->GetEmbeddedObject ( IDS_Owner , &pGroup , pAccess->GetMethodContext () ) )
				    {
					    bGroupSpecified = true ;
				    }
				    else
				    {
					    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
					    hr = WBEM_E_INVALID_PARAMETER ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
		    hr = WBEM_E_INVALID_PARAMETER ;
	    }
    }

    SECURITY_DESCRIPTOR_CONTROL control;
    if(SUCCEEDED(hr))
    {
	    // get the control flags
	    if ( pAccess->GetStatus ( IDS_ControlFlags , bExists , eType ) )
	    {
		    if ( bExists &&  eType == VT_I4 )
		    {

			    if ( pAccess->GetDWORD ( IDS_ControlFlags , (DWORD&)control ) )
			    {
			    }
			    else
			    {
				    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				    hr = WBEM_E_INVALID_PARAMETER ;
			    }
		    }
		    else
		    {
			    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
	    else
	    {
		    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
		    hr = WBEM_E_INVALID_PARAMETER ;
	    }
    }

/*	//The function can set only the control bits that relate to automatic inheritance of ACEs
	if(!SetSecurityDescriptorControl(&absoluteSD, ???,control) )
	{
		dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
		return hr ;
	}
*/

	// now, take the Win32_Trustee instance and get the SID out of it
	// convert it to a CSid, and apply to the SecureFile
	CSid sidOwner ;

    if(SUCCEEDED(hr))
    {
	    if(bOwnerSpecified )
	    {
		    if(  FillSIDFromTrustee(pOwner, sidOwner)  == LSSS_STATUS_SUCCESS )
		    {

			    BOOL bOwnerDefaulted = ( control & SE_OWNER_DEFAULTED ) ? true : false ;

			    //sid validity checked here as FillSIDFromTrustee returns success if null sid
			    if ( sidOwner.IsValid() )
			    {
				    if(!SetSecurityDescriptorOwner(&absoluteSD, sidOwner.GetPSid(), bOwnerDefaulted) )
				    {
					    //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                        dwStatus = GetLastError();
					    hr = WBEM_E_PROVIDER_FAILURE ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
    }

	CSid sidGroup ;

    if(SUCCEEDED(hr))
    {
	    if( bGroupSpecified )
	    {
		    if( FillSIDFromTrustee(pGroup, sidGroup)  == LSSS_STATUS_SUCCESS )
		    {

			    BOOL bGroupDefaulted = ( control & SE_GROUP_DEFAULTED ) ? true : false ;

			    //sid validity checked here as FillSIDFromTrustee returns success if null sid
			    if ( sidGroup.IsValid() )
			    {
				    if(!SetSecurityDescriptorGroup(&absoluteSD, sidGroup.GetPSid(), bGroupDefaulted) )
				    {
					    //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                        dwStatus = GetLastError();
					    hr = WBEM_E_PROVIDER_FAILURE ;
				    }
			    }
		    }
		    else
		    {
			    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
			    hr = WBEM_E_INVALID_PARAMETER ;
		    }
	    }
    }

	CDACL *pdacl = NULL;
	PACL pDACL = NULL ;
	DWORD dwACLSize =0 ;
	CSACL *psacl = NULL;
	PACL pSACL = NULL ;
	DWORD dwSACLSize = 0 ;
	SHARE_INFO_502 *pShareInfo502 = NULL ;
	PSECURITY_DESCRIPTOR  pOldSD = NULL ;
	CNetAPI32 NetAPI ;
	if(SUCCEEDED(hr))
    {
        try
	    {
		    // Only bother with a dacl if we are going to be setting it, which is controled by the control flags specified...
            if(control & SE_DACL_PRESENT)
            {
                pdacl = new CDACL;
                if(pdacl != NULL)
                {
                    if( (dwStatus = FillDACLFromInstance(pAccess, *pdacl, pAccess->GetMethodContext () ) ) != LSSS_STATUS_SUCCESS )
		            {
			            if(dwStatus == STATUS_NULL_DACL)
                        {
                            // No dacl was specified - e.g., we have a NULL dacl.  Since we mimic a NULL dacl as a dacl with
                            // an Everyone ACCESS_ALLOWED entry, create that here:
                            if(!pdacl->CreateNullDACL())
                            {
                                dwStatus = E_FAIL ;
		                        hr = WBEM_E_PROVIDER_FAILURE ;
                            }
                        }
                        else if(dwStatus == STATUS_EMPTY_DACL)
                        {
                            pdacl->Clear(); // "creates" the empty dacl
                        }
                        else
                        {
                            dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
                            hr = WBEM_E_INVALID_PARAMETER;
                        }
                    }

                    if(!pdacl->CalculateDACLSize( &dwACLSize ) )
			        {
				        dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				        hr = WBEM_E_INVALID_PARAMETER ;
			        }

			        if(SUCCEEDED(hr))
                    {
                        if(dwACLSize >= sizeof(ACL) )
			            {
				            pDACL = (PACL) malloc(dwACLSize) ;
				            InitializeAcl(pDACL,dwACLSize,ACL_REVISION ) ;

				            BOOL bDaclDefaulted = ( control & SE_DACL_DEFAULTED ) ? true : false ;
				            if(pdacl->FillDACL( pDACL ) == ERROR_SUCCESS)
				            {
					            if(!SetSecurityDescriptorDacl(&absoluteSD, TRUE, pDACL, bDaclDefaulted) )
					            {
						            //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                                    dwStatus = GetLastError();
                                    hr = WBEM_E_INVALID_PARAMETER;
					            }
				            }
				            else
				            {
					            dwStatus = LSSS_STATUS_INVALID_PARAMETER;
                                hr = WBEM_E_INVALID_PARAMETER;
				            }
		                }
                    }
                }
            }

            // Only bother with a sacl if we are going to be setting it, which is controled by the control flags specified...
            if(control & SE_SACL_PRESENT)
            {
                if(SUCCEEDED(hr))
                {
                    psacl = new CSACL;
                    if(psacl != NULL)
                    {
		                if( (dwStatus = FillSACLFromInstance(pAccess, *psacl, pAccess->GetMethodContext () ) ) == LSSS_STATUS_SUCCESS )
		                {
			                if(!psacl->CalculateSACLSize( &dwSACLSize ) )
			                {
				                dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
                                hr = WBEM_E_INVALID_PARAMETER;
			                }

                            if(SUCCEEDED(hr))
                            {
			                    if( dwSACLSize > sizeof(ACL) )
			                    {
				                    pSACL = (PACL) malloc(dwSACLSize) ;
				                    InitializeAcl(pSACL,dwSACLSize,ACL_REVISION ) ;

				                    BOOL bSaclDefaulted = ( control & SE_SACL_DEFAULTED ) ? true : false ;
				                    if(psacl->FillSACL( pSACL ) == ERROR_SUCCESS)
				                    {
					                    if(!SetSecurityDescriptorSacl(&absoluteSD, TRUE, pSACL, bSaclDefaulted) )
					                    {
						                    //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                                            dwStatus = GetLastError();
                                            hr = WBEM_E_INVALID_PARAMETER;
					                    }
				                    }
				                    else
				                    {
					                    dwStatus = LSSS_STATUS_INVALID_PARAMETER ;
				                    }
			                    }
                            }
		                }
                    }
                    else
                    {
                        dwStatus = E_FAIL ;
		                hr = WBEM_E_PROVIDER_FAILURE ;
                    }
                }
            }

		    DWORD dwLength = 0 ;

            if(SUCCEEDED(hr))
            {
		        MakeSelfRelativeSD(&absoluteSD, NULL, &dwLength);
		        pRelativeSD= ( PSECURITY_DESCRIPTOR ) malloc( dwLength );

		        if (!MakeSelfRelativeSD(&absoluteSD, pRelativeSD, &dwLength))
		        {
			        //dwStatus = GetWin32ErrorToStatusCode(GetLastError() ) ;
                    dwStatus = GetLastError();
                    hr = WBEM_E_PROVIDER_FAILURE ;
		        }
            }

            if(pdacl != NULL)
            {
                delete pdacl;
                pdacl = NULL;
            }

            if(psacl != NULL)
            {
                delete psacl;
                psacl = NULL;
            }



		    if(SUCCEEDED(hr))
            {
		        CHString chsShareName ;
		        pInstance.GetCHString(IDS_Name, chsShareName) ;
		        bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;


		        if(	(dwStatus = NetAPI.Init() ) == ERROR_SUCCESS		&&
			        (dwStatus = NetAPI.NetShareGetInfo(	NULL,
												        (LPTSTR) bstrName,
												        502,
												        (LPBYTE *) &pShareInfo502) )== NERR_Success	)
		        {

			        //store old SD
			        pOldSD = pShareInfo502->shi502_security_descriptor ;

			        pShareInfo502->shi502_security_descriptor =  pRelativeSD ;

			        if( (dwStatus = NetAPI.NetShareSetInfo(	NULL,
									        (LPTSTR) bstrName,
									        502,
									        (LPBYTE ) pShareInfo502, NULL) ) != NERR_Success	)

			        {
				        //dwStatus = GetStatusCode(dwStatus) ;
			        }

					// Moved after Share
			        /*pShareInfo502->shi502_security_descriptor = pOldSD ;

			        NetAPI.NetApiBufferFree(pShareInfo502);
			        pShareInfo502 = NULL ;*/
		        }
		        else
		        {
			        //dwStatus = GetStatusCode(dwStatus) ;
		        }
            }

	    }

	    catch ( ... )
	    {
		    if ( pShareInfo502 )
		    {
			    if ( pOldSD )
			    {
				    pShareInfo502->shi502_security_descriptor = pOldSD ;
				    NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
				    pShareInfo502 = NULL ;
				    pOldSD = NULL ;
			    }
		    }
		    if ( pRelativeSD )
		    {
			    free ( pRelativeSD ) ;
			    pRelativeSD = NULL ;
		    }

		    if ( pDACL )
		    {
			    free ( pDACL ) ;
			    pDACL = NULL ;
		    }
		    if ( pSACL )
		    {
			    free ( pSACL ) ;
			    pSACL = NULL ;
		    }

		    throw ;
	    }
    }

	if ( pShareInfo502 )
	{
		if ( pOldSD )
		{
			pShareInfo502->shi502_security_descriptor = pOldSD ;
			NetAPI.NetApiBufferFree ( pShareInfo502 ) ;
			pShareInfo502 = NULL ;
			pOldSD = NULL ;
		}
	}
	if ( pRelativeSD )
	{
		free ( pRelativeSD ) ;
		pRelativeSD = NULL ;
	}

	if ( pDACL )
	{
		free ( pDACL ) ;
		pDACL = NULL ;
	}
	if ( pSACL )
	{
		free ( pSACL ) ;
		pSACL = NULL ;
	}
    // If we had an invalid  parameter, the status code will report it.  The method succeeded, however.
	// If we had another type of error (such as invalid parameter), the status code will show it, and the method failed.
    if(hr == WBEM_E_INVALID_PARAMETER)
    {
        hr = WBEM_S_NO_ERROR;
    }
	return hr ;
}
#endif




///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalShareSecuritySetting::EnumerateInstances
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalShareSecuritySetting::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{

#ifdef NTONLY
	HRESULT hr = WBEM_S_NO_ERROR;

	CAdvApi32Api *t_pAdvApi32 = NULL;
    t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);

    if(t_pAdvApi32 != NULL)
    {
        CHString chstrDllVer;
        if(t_pAdvApi32->GetDllVersion(chstrDllVer))
        {
            if(chstrDllVer >= _T("4.0"))
            {
                try
                {
                    hr = CWbemProviderGlue::GetInstancesByQueryAsynch(L"SELECT Name FROM Win32_Share",
                        this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, (void*)t_pAdvApi32 );
                }
                catch(...)
                {
                    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
                    t_pAdvApi32 = NULL;
                    throw;
                }
	        }
        }
	    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
        t_pAdvApi32 = NULL;
    }
	return(hr);
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalShareSecuritySetting::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::EnumerationCallback(CInstance* pShare, MethodContext* pMethodContext, void* pUserData)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	DWORD dwRetCode = ERROR_SUCCESS ;

	CHString chsShareName;
	pShare->GetCHString(IDS_Name, chsShareName);
	SHARE_INFO_502 *pShareInfo502 = NULL ;

    // Do the puts, and that's it
	if (!chsShareName.IsEmpty())
	{

		CNetAPI32 NetAPI ;

		bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;

		if(	NetAPI.Init() == ERROR_SUCCESS		&&
			( dwRetCode = NetAPI.NetShareGetInfo (	NULL,
													(LPTSTR) bstrName,
													502,
													(LPBYTE *) &pShareInfo502 ) ) == NERR_Success

		 )
		{
			try
			{
				// Start pumping out the instances
				CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
				if(pInstance != NULL)
				{
					PSECURITY_DESCRIPTOR pSD = NULL ;
					PACL pDacl = NULL ;
					if( pShareInfo502->shi502_security_descriptor == NULL && GetPlatformMajorVersion() >= 4 )
					{
						CAdvApi32Api *t_pAdvApi32 = NULL ;
						t_pAdvApi32 = ( CAdvApi32Api* ) pUserData ;
						if ( t_pAdvApi32 != NULL )
						{
							t_pAdvApi32->GetNamedSecurityInfoW(
													bstrName ,
													SE_LMSHARE,
													DACL_SECURITY_INFORMATION,
													NULL,
													NULL,
													&pDacl,
													NULL,
													&pSD,
                                                    NULL   // the real return value, which we don't care about
												) ;
						}
					}

					try
					{
						//Sec. Desc. is not returned for IPC$ ,C$ ...shares for Admin purposes
						if(pShareInfo502->shi502_security_descriptor != NULL || pSD )
						{
							CSecureShare SecShare(pSD ? pSD : pShareInfo502->shi502_security_descriptor) ;

							SECURITY_DESCRIPTOR_CONTROL control;
							SecShare.GetControl(&control);
							pInstance->SetDWORD(IDS_ControlFlags, control);
                            pInstance->SetCHString(IDS_Name, chsShareName);
                            CHString chstrTemp;
                            chstrTemp.Format(L"Security settings of %s", (LPCWSTR)chsShareName);
                            pInstance->SetCHString(IDS_Caption, chstrTemp);
                            pInstance->SetCHString(IDS_Description, chstrTemp);
							hr = pInstance->Commit () ;
						}
					}
					catch ( ... )
					{
						if( pSD )
						{
							LocalFree( pSD ) ;
							pSD = NULL ;
						}
						throw ;
					}

					if( pSD )
					{
						LocalFree( pSD ) ;
						pSD = NULL ;
					}
				}
				else // pInstance == NULL
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
			catch ( ... )
			{
				if ( pShareInfo502 )
				{
					NetAPI.NetApiBufferFree(pShareInfo502) ;
					pShareInfo502 = NULL ;
				}
				throw ;
			}
			if ( pShareInfo502 )
			{
				NetAPI.NetApiBufferFree(pShareInfo502) ;
				pShareInfo502 = NULL ;
			}
		}	// end if

	}

	return(hr);
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Win32LogicalShareSecuritySetting::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT WINAPI Win32LogicalShareSecuritySetting::StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData)
{
	Win32LogicalShareSecuritySetting* pThis;
	HRESULT hr;

	pThis = dynamic_cast<Win32LogicalShareSecuritySetting *>(pThat);
	ASSERT_BREAK(pThis != NULL);

	if (pThis)
	{
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
	}
	else
	{
    	hr = WBEM_E_FAILED;
	}
	return hr;
}
#endif

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32LogicalShareSecuritySetting::GetObject
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32LogicalShareSecuritySetting::GetObject ( CInstance* pInstance, long lFlags /* = 0L */ )
{

#ifdef NTONLY
    HRESULT hr = WBEM_E_NOT_FOUND;
	DWORD dwRetCode = ERROR_SUCCESS ;
    CHString chsShareName ;
	SHARE_INFO_502 *pShareInfo502 = NULL ;

	if ( pInstance )
	{
		pInstance->GetCHString(IDS_Name,chsShareName);
		_bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;

		CNetAPI32 NetAPI;

		if(	NetAPI.Init() == ERROR_SUCCESS )
		{
			dwRetCode =	NetAPI.NetShareGetInfo (	NULL,
													(LPTSTR) bstrName,
													502,
													(LPBYTE *) &pShareInfo502 ) ;
			if ( dwRetCode == NERR_Success )
			{
				try
				{
					PSECURITY_DESCRIPTOR pSD = NULL ;
					try
					{
						PACL pDacl = NULL ;
						if( pShareInfo502->shi502_security_descriptor == NULL && GetPlatformMajorVersion() >= 4 )
						{
							CAdvApi32Api *t_pAdvApi32 = NULL;
							t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
							if ( t_pAdvApi32 != NULL )
							{
								try
								{
									t_pAdvApi32->GetNamedSecurityInfoW(
																			bstrName ,
																			SE_LMSHARE,
																			DACL_SECURITY_INFORMATION,
																			NULL,
																			NULL,
																			&pDacl,
																			NULL,
																			&pSD , &dwRetCode
																		) ;
								}
								catch ( ... )
								{
									CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
									t_pAdvApi32 = NULL;
									throw ;
								}

								CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
								t_pAdvApi32 = NULL;
							}
						}

						//Sec. Desc. is not returned for IPC$ ,C$ ...shares for Admin purposes
						if(pShareInfo502->shi502_security_descriptor != NULL || (pSD != NULL && dwRetCode == ERROR_SUCCESS) )
						{

							CSecureShare SecShare( pSD ? pSD : pShareInfo502->shi502_security_descriptor ) ;

							SECURITY_DESCRIPTOR_CONTROL control;
							SecShare.GetControl(&control);
							pInstance->SetDWORD(IDS_ControlFlags, control);
                            CHString chstrTemp;
                            chstrTemp.Format(L"Security settings of %s", (LPCWSTR)chsShareName);
                            pInstance->SetCHString(IDS_Caption, chstrTemp);
                            pInstance->SetCHString(IDS_Description, chstrTemp);
							hr = WBEM_S_NO_ERROR ;
						}

					}
					catch ( ... )
					{
						if( pSD )
						{
							LocalFree( pSD ) ;
							pSD = NULL ;
						}
						throw ;
					}
					if( pSD )
					{
						LocalFree( pSD ) ;
						pSD = NULL ;
					}
				}
				catch ( ... )
				{
					if ( pShareInfo502 )
					{
						NetAPI.NetApiBufferFree(pShareInfo502);
						pShareInfo502 = NULL ;
					}
					throw ;
				}

				if ( pShareInfo502 )
				{
					NetAPI.NetApiBufferFree(pShareInfo502);
					pShareInfo502 = NULL ;
				}
			}
		}
		else
		{
			hr = WBEM_E_FAILED ;
		}
	}	//if (pInstance)

	return(hr);
#endif
}


/*
#ifdef NTONLY
HRESULT Win32LogicalShareSecuritySetting::GetEmptyInstanceHelper(CHString chsClassName, CInstance**ppInstance, MethodContext* pMethodContext )
{

	CHString chsServer ;
	CHString chsPath ;
	HRESULT hr = S_OK ;

	chsServer = GetLocalComputerName() ;

	chsPath = _T("\\\\") + chsServer + _T("\\") + IDS_CimWin32Namespace + _T(":") + chsClassName ;

	CInstancePtr  pClassInstance = NULL ;
	if(SUCCEEDED( hr = CWbemProviderGlue::GetInstanceByPath(chsPath, &pClassInstance, pMethodContext) ) )
	{
		IWbemClassObjectPtr pClassObject ( pClassInstance->GetClassObjectInterface(), false ) ;

		IWbemClassObjectPtr piClone = NULL ;
		if(SUCCEEDED(hr = pClassObject->SpawnInstance(0, &piClone) ) )
		{
			*ppInstance = new CInstance(piClone, pMethodContext ) ;
		}
	}

	return hr ;
}
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32logicalsharesecuritysetting.h ===
//=================================================================

//

// Win32LogicalShareSecuritySetting.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <aclapi.h>


#ifndef __LOGSHARESECSETTING_H_
#define __LOGSHARESECSETTING_H_

#define  WIN32_LOGICAL_SHARE_SECURITY_SETTING L"Win32_LogicalShareSecuritySetting"


#define LSSS_STATUS_SUCCESS								0
#define LSSS_STATUS_NOT_SUPPORTED						1
#define LSSS_STATUS_ACCESS_DENIED						2
#define LSSS_STATUS_UNKNOWN_FAILURE						8


#define LSSS_STATUS_DESCRIPTOR_NOT_AVAILABLE			9
#define LSSS_STATUS_INVALID_PARAMETER					21



#define METHOD_ARG_NAME_DESCRIPTOR					L"Descriptor"
#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"


typedef DWORD ( WINAPI *PFN_GETNAMEDSECURITYINFOW )(
				LPWSTR                 pObjectName,
                SE_OBJECT_TYPE         ObjectType,
                SECURITY_INFORMATION   SecurityInfo,
                PSID                 * ppsidOowner,
                PSID                 * ppsidGroup,
                PACL                 * ppDacl,
                PACL                 * ppSacl,
                PSECURITY_DESCRIPTOR * ppSecurityDescriptor );



class Win32LogicalShareSecuritySetting : public Provider
{
protected:
public:
	Win32LogicalShareSecuritySetting (LPCWSTR setName, LPCWSTR pszNameSpace =NULL);
	~Win32LogicalShareSecuritySetting ();

	HRESULT ExecMethod 
	(
		const CInstance& a_Instance, 
		const BSTR a_MethodName, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags = 0L
	);

	HRESULT ExecGetSecurityDescriptor 
	(
		const CInstance& pInstance, 
		CInstance* pInParams, 
		CInstance* pOutParams, 
		long lFlags
	);

	HRESULT ExecSetSecurityDescriptor 
	(
		const CInstance& pInstance, 
		CInstance* pInParams, 
		CInstance* pOutParams, 
		long lFlags
	);

HRESULT Win32LogicalShareSecuritySetting::CheckSetSecurityDescriptor (const CInstance& pInstance, CInstance* pInParams, CInstance* pOutParams, DWORD& dwStatus ) ;


	HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);
	HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

#ifdef NTONLY
	
	HRESULT EnumerationCallback(CInstance* pShare, MethodContext* pMethodContext, void* pUserData);
	static HRESULT WINAPI StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData);
	//DWORD GetStatusCode(DWORD dwError) ;
	//DWORD GetWin32ErrorToStatusCode(DWORD dwWin32Error) ;
	bool GetArray(IWbemClassObject *piClassObject, const CHString& name,  VARIANT& strArray, VARTYPE eVariantType) const ;

#endif

};	// end class Win32LogicalShareSecuritySetting

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32mappedlogicaldisk.cpp ===
//=================================================================

//

// MappedLogicalDisk.CPP -- Logical Disk property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    4/15/00    khughes        Created
//
//=================================================================


#include "precomp.h"
#include <map>
#include <vector>
#include <comdef.h>
#include "chstring.h"
#include "session.h"
#include <frqueryex.h>

#include "Win32MappedLogicalDisk.h"
#include <objbase.h>
#include <comdef.h>
#include <ntsecapi.h>

#include <vector>
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include <Sid.h>

#include <DskQuota.h>
#include <smartptr.h>
#include <ntioapi.h>
#include <CMDH.h>


// Property set declaration
//=========================
MappedLogicalDisk MyLogicalDiskSet ( PROPSET_NAME_MAPLOGDISK , IDS_CimWin32Namespace ) ;



/*****************************************************************************
 *
 *  FUNCTION    : LogicalDisk::LogicalDisk
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
MappedLogicalDisk :: MappedLogicalDisk (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
    m_ptrProperties.SetSize(23);

    m_ptrProperties[0] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[1] = ((LPVOID) IDS_ProviderName);
    m_ptrProperties[2] = ((LPVOID) IDS_VolumeName);
    m_ptrProperties[3] = ((LPVOID) IDS_FileSystem);
    m_ptrProperties[4] = ((LPVOID) IDS_VolumeSerialNumber);
    m_ptrProperties[5] = ((LPVOID) IDS_Compressed);
    m_ptrProperties[6] = ((LPVOID) IDS_SupportsFileBasedCompression);
    m_ptrProperties[7] = ((LPVOID) IDS_MaximumComponentLength);
    m_ptrProperties[8] = ((LPVOID) IDS_SupportsDiskQuotas);
    m_ptrProperties[9] = ((LPVOID) IDS_QuotasIncomplete);
    m_ptrProperties[10] = ((LPVOID) IDS_QuotasRebuilding);
    m_ptrProperties[11] = ((LPVOID) IDS_QuotasDisabled);
    m_ptrProperties[12] = ((LPVOID) IDS_VolumeDirty);
    m_ptrProperties[13] = ((LPVOID) IDS_FreeSpace);
    m_ptrProperties[14] = ((LPVOID) IDS_Size);

    m_ptrProperties[15] = ((LPVOID) IDS_Name);
    m_ptrProperties[16] = ((LPVOID) IDS_Caption);
    m_ptrProperties[17] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[18] = ((LPVOID) IDS_SessionID);
    m_ptrProperties[19] = ((LPVOID) IDS_Description);
    m_ptrProperties[20] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[21] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[22] = ((LPVOID) IDS_MediaType);
}

/*****************************************************************************
 *
 *  FUNCTION    : MappedLogicalDisk::~MappedLogicalDisk
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

MappedLogicalDisk :: ~MappedLogicalDisk ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : MappedLogicalDisk::ExecQuery
 *
 *  DESCRIPTION : 
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
#if NTONLY == 5
HRESULT MappedLogicalDisk::ExecQuery(
	MethodContext *pMethodContext,
	CFrameworkQuery &pQuery,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwNumDeviceIDs = 0L;
    DWORD dwNumSessionIDs = 0L;

    // Use the extended query type

    std::vector<int> vectorValues;
    DWORD dwTypeSize = 0;

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);

    // Find out what properties they asked for
    DWORD dwReqProps = 0;
    pQuery2->GetPropertyBitMask(
        m_ptrProperties, 
        &dwReqProps);

    CHStringArray rgchstrDeviceIDs;
    pQuery.GetValuesForProp(
        IDS_DeviceID, 
        rgchstrDeviceIDs);

    CHStringArray rgchstrSessionIDs;
    pQuery.GetValuesForProp(
        IDS_SessionID, 
        rgchstrSessionIDs);

    dwNumDeviceIDs = rgchstrDeviceIDs.GetSize();
    dwNumSessionIDs = rgchstrSessionIDs.GetSize();

    // Get the set of sessions.
    CUserSessionCollection usc;


    // Case 1: One or more sessions specified, no drives specified.
    // Enumerate all drives for each session.
    if(dwNumSessionIDs > 0 && 
       dwNumDeviceIDs == 0)
    {
        HRESULT hrTmp = WBEM_S_NO_ERROR;
                
        for(long m = 0;
            m < dwNumSessionIDs && SUCCEEDED(hr);
            m++)
        {
            __int64 i64SessionID = _wtoi64(rgchstrSessionIDs[m]);
            SmartDelete<CSession> sesPtr;
            sesPtr = usc.FindSession(i64SessionID);
            
            if(sesPtr)
            {
                // Get all of its mapped drives...
                // GetImpProcPID() specifies the
                // processid who's view of drive
                // mappings we want to report on.
                hrTmp = GetAllMappedDrives(
                    pMethodContext,
                    i64SessionID,
                    sesPtr->GetImpProcPID(),
                    dwReqProps);
        
                (hrTmp == WBEM_E_NOT_FOUND) ? 
                    hr = WBEM_S_PARTIAL_RESULTS :
                    hr = hrTmp; 
            }  
        }
    }
    // Case 2: No sessions specified, one or more drives specified.
    // Get specified drives for all sessions.
    else if(dwNumSessionIDs == 0 && 
       dwNumDeviceIDs > 0)
    {
        HRESULT hrTmp = WBEM_S_NO_ERROR;
        SmartDelete<CSession> sesPtr;
        USER_SESSION_ITERATOR sesIter;

        sesPtr = usc.GetFirstSession(sesIter);
        while(sesPtr)
        {
            {   // <-- Keep this brace! Need hCurImpTok to revert
                // for each iteration of the while loop, but we
                // want to keep the same impersonation for all 
                // iterations of the for loop.

                __int64 i64SessionID = sesPtr->GetLUIDint64();

                for(long m = 0;
                    m < dwNumDeviceIDs && SUCCEEDED(hr);
                    m++)
                {
                    // GetImpProcPID() specifies the
                    // processid who's view of drive
                    // mappings we want to report on.
                    hrTmp = GetSingleMappedDrive(
                        pMethodContext,
                        i64SessionID,
                        sesPtr->GetImpProcPID(),
                        rgchstrDeviceIDs[m],
                        dwReqProps);
        
                    (hrTmp == WBEM_E_NOT_FOUND) ? 
                        hr = WBEM_S_PARTIAL_RESULTS :
                        hr = hrTmp;
                }
            }
            // Get the next session...
            sesPtr = usc.GetNextSession(sesIter);
        }
    }
    // Case 3: Sessions and drives specified.
    else if(dwNumSessionIDs > 0 &&
        dwNumDeviceIDs > 0)
    {
        HRESULT hrTmp = WBEM_S_NO_ERROR;
                
        for(long m = 0;
            m < dwNumSessionIDs && SUCCEEDED(hr);
            m++)
        {
            __int64 i64SessionID = _wtoi64(rgchstrSessionIDs[m]);
            SmartDelete<CSession> sesPtr;
            sesPtr = usc.FindSession(i64SessionID);
            
            if(sesPtr)
            {
                // Get the specified mapped drives...
                for(long m = 0;
                    m < dwNumDeviceIDs && SUCCEEDED(hr);
                    m++)
                {
                    // The drives were specified in
                    // the query as .DeviceID="x:", but
                    // we look for them as "x:\", so convert...
                    CHString chstrTmp = rgchstrDeviceIDs[m];
                    chstrTmp += L"\\";

                    // GetImpProcPID() specifies the
                    // processid who's view of drive
                    // mappings we want to report on.
                    hrTmp = GetSingleMappedDrive(
                        pMethodContext,
                        i64SessionID,
                        sesPtr->GetImpProcPID(),
                        chstrTmp,
                        dwReqProps);
        
                    (hrTmp == WBEM_E_NOT_FOUND) ? 
                        hr = WBEM_S_PARTIAL_RESULTS :
                        hr = hrTmp;
                }
            }
        }    
    }
    // Case 4: We will return all instances;, get
    // data for all drives at once, for every session...
    else
    {
        HRESULT hrTmp = WBEM_S_NO_ERROR;
        SmartDelete<CSession> sesPtr;
        USER_SESSION_ITERATOR sesIter;

        sesPtr = usc.GetFirstSession(sesIter);
        while(sesPtr && SUCCEEDED(hr))
        {
            __int64 i64SessionID = sesPtr->GetLUIDint64();

            // Get all of its mapped drives...
            // GetImpProcPID() specifies the
            // processid who's view of drive
            // mappings we want to report on.
            hrTmp = GetAllMappedDrives(
                pMethodContext,
                i64SessionID,
                sesPtr->GetImpProcPID(),
                dwReqProps);

            (hrTmp == WBEM_E_NOT_FOUND) ? 
                        hr = WBEM_S_PARTIAL_RESULTS :
                        hr = hrTmp;
            
            // Get the next session...
            sesPtr = usc.GetNextSession(sesIter);
        }
    }

    return hr;
}
#endif
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#if NTONLY == 5
HRESULT MappedLogicalDisk::GetObject(
	CInstance *pInstance,
	long lFlags,
    CFrameworkQuery &pQuery)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chstrDeviceID;
    CHString chstrSessionID;
    DWORD dwReqProps = 0;

    // Find out what properties they asked for
    
    CFrameworkQueryEx *pQuery2 = 
        static_cast <CFrameworkQueryEx *>(&pQuery);
    pQuery2->GetPropertyBitMask(
        m_ptrProperties, 
        &dwReqProps);
	
    pInstance->GetCHString(
        IDS_DeviceID, 
        chstrDeviceID);

    pInstance->GetCHString(
        IDS_SessionID, 
        chstrSessionID);

    __int64 i64SessionID = _wtoi64(chstrSessionID);

    // Get the set of sessions.
    CUserSessionCollection usc;
    SmartDelete<CSession> sesPtr;

    sesPtr = usc.FindSession(i64SessionID);
    if(sesPtr)
    {
        MethodContext* pMethodContext = pInstance->GetMethodContext();
        SmartRevertTokenHANDLE hCurImpTok;

        // GetImpProcPID() specifies the
        // processid who's view of drive
        // mappings we want to report on.
        hr = GetSingleMappedDrive(
            pMethodContext,
            i64SessionID,
            sesPtr->GetImpProcPID(),
            chstrDeviceID,
            dwReqProps);
    }

    return hr ;
}
#endif
/*****************************************************************************
 *
 *  FUNCTION    : MappedLogicalDisk::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#if NTONLY == 5
HRESULT MappedLogicalDisk::EnumerateInstances(
	MethodContext* pMethodContext,
	long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Get the set of sessions.
    CUserSessionCollection usc;
    USER_SESSION_ITERATOR sesIter;
    SmartDelete<CSession> sesPtr;

    sesPtr = usc.GetFirstSession(sesIter);
    while(sesPtr)
    {
        __int64 i64SessionID = sesPtr->GetLUIDint64();

        // GetImpProcPID() specifies the
        // processid who's view of drive
        // mappings we want to report on.
        GetAllMappedDrives(
            pMethodContext,
            i64SessionID,
            sesPtr->GetImpProcPID(),
            0xFFFFFFFF);  // request all properties
        
        // Get next session...
        sesPtr = usc.GetNextSession(sesIter);
    }

    return hr;
}
#endif


#if NTONLY == 5
HRESULT MappedLogicalDisk::GetAllMappedDrives(
    MethodContext *pMethodContext,
    __int64 i64SessionID,
    DWORD dwPID,
    DWORD dwReqProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _variant_t v;
    bool fArrayIsGood = false;
    long lNumDrives = 0L;

    // Get the drive info...
    CMDH cmdh(dwPID);
    hr = cmdh.GetMDData(
        dwReqProps,
        &v);

    if(SUCCEEDED(hr))
    {
        fArrayIsGood = IsArrayValid(&v);    
    }

    if(SUCCEEDED(hr) && 
        fArrayIsGood)
    {
        // How many drives?  The array we are
        // working with has the different drives
        // in the first dimension (index 0) (think of 
        // that as columns in a table), and the 
        // properties of each drive in the second 
        // (index 1) dimension (think of that as rows
        // in a table).
        hr = ::SafeArrayGetUBound(
            V_ARRAY(&v),
            2,  // most significant dim contains drives
            &lNumDrives);
        
        if(SUCCEEDED(hr))
        {
            // If we have just one drive, the ubound
            // of the array will be 0 (the same as
            // the lbound).  True, we can't distinguish
            // this from no drives - that is why we
            // rely on the component to have set the 
            // variant to VT_EMPTY if we have no data.
            // That check was done in IsArrayValid.
            lNumDrives++;
        }            
    }

    if(SUCCEEDED(hr) &&
        fArrayIsGood &&
        lNumDrives > 0)
    {
        // Go through the drives extracting
        // the properties from the safearray,
        // placing them into a new CInstance,
        // and committing the instances...    
        for(long m = 0L;
            m < lNumDrives && SUCCEEDED(hr);
            m++)
        {
            hr = ProcessInstance(
                m,  // index of drive we are working with
                i64SessionID,
                V_ARRAY(&v),
                pMethodContext,
                dwReqProps);
        }
    }

    return hr;
}
#endif



#if NTONLY == 5
HRESULT MappedLogicalDisk::GetSingleMappedDrive(
    MethodContext *pMethodContext,
    __int64 i64SessionID,
    DWORD dwPID,
    CHString& chstrDeviceID,
    DWORD dwReqProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _variant_t v;
    bool fArrayIsGood = false;
    long lNumDrives = 0L;

    CMDH cmdh(dwPID);
    hr = cmdh.GetOneMDData(
        _bstr_t((LPCWSTR) chstrDeviceID),
        dwReqProps,
        &v);

    if(SUCCEEDED(hr))
    {
        fArrayIsGood = IsArrayValid(&v);    
    }

    if(SUCCEEDED(hr) && 
        fArrayIsGood)
    {
        // How many drives?  The array we are
        // working with has the different drives
        // in the first dimension (index 0) (think of 
        // that as columns in a table), and the 
        // properties of each drive in the second 
        // (index 1) dimension (think of that as rows
        // in a table).
        hr = ::SafeArrayGetUBound(
            V_ARRAY(&v),
            2,  // first dimension
            &lNumDrives);
        
        if(SUCCEEDED(hr))
        {
            // If we have just one drive, the ubound
            // of the array will be 0 (the same as
            // the lbound).  True, we can't distinguish
            // this from no drives - that is why we
            // rely on the component to have set the 
            // variant to VT_EMPTY if we have no data.
            // That check was done in IsArrayValid.
            //
            // In this case, if we have more than
            // one drive, we have an error, since
            // GetOneMDData should have only returned
            // a table with one column.
            if(lNumDrives == 0) fArrayIsGood = true;
        }            
    }

    if(SUCCEEDED(hr) &&
        fArrayIsGood)
    {
        // For the one drive we are examining, 
        // extract the properties from the 
        // safearray,place them into a new 
        // CInstance, and commit the instance...    
        hr = ProcessInstance(
            0,  // index of drive we are working with
            i64SessionID,
            V_ARRAY(&v),
            pMethodContext,
            dwReqProps);
    }

    if(!fArrayIsGood)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}
#endif



#if NTONLY == 5
bool MappedLogicalDisk::IsArrayValid(
    VARIANT* v)
{
    bool fArrayIsGood = false;
    long lNumProps = 0L;

    // Proceed if the array is not empty...
    if(V_VT(v) != VT_NULL &&
       V_VT(v) != VT_EMPTY &&
       V_VT(v) == (VT_ARRAY | VT_BSTR))
    {
        // Confirm that the array has
        // two dimensions...
        if(::SafeArrayGetDim(V_ARRAY(v)) == 2)
        {
            // Make sure the array has the
            // right number of properties
            // (second dimension - see comment
            // below).
            HRESULT hr = S_OK;
            hr = ::SafeArrayGetUBound(
                V_ARRAY(v),
                1,  // second dimension
                &lNumProps);
            if(SUCCEEDED(hr) &&
                lNumProps == PROP_COUNT - 1)
            {
                fArrayIsGood = true;
            }
        }
    }

    return fArrayIsGood;
}
#endif



#if NTONLY == 5
HRESULT MappedLogicalDisk::ProcessInstance(
    long lDriveIndex,
    __int64 i64SessionID,
    SAFEARRAY* psa,
    MethodContext* pMethodContext,
    DWORD dwReqProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BSTR bstrProp = NULL;

    long ix[2];
    ix[1] = lDriveIndex;

    CInstancePtr pInstance(
        CreateNewInstance(
            pMethodContext), 
            false);

    // Set fixed properties...
    pInstance->SetWCHARSplat(
        IDS_SystemCreationClassName, 
        L"Win32_ComputerSystem");

    pInstance->SetCHString(
        IDS_SystemName, 
        GetLocalComputerName());
        
    try
    {
        // Set DeviceID and those using its value...
        {
            ix[0] = PROP_DEVICEID;
            hr = ::SafeArrayGetElement(
                psa,
                ix,
                &bstrProp);

            if(SUCCEEDED(hr))
            {
                // Set device id and other properties
                // that use this value...
                CHString chstrTmp((LPCWSTR)bstrProp);
                ::SysFreeString(bstrProp);
				bstrProp = NULL;

                chstrTmp = chstrTmp.SpanExcluding(L"\\");

                pInstance->SetCHString(
                    IDS_Name, 
                    chstrTmp);

		        pInstance->SetCHString(
                    IDS_Caption, 
                    chstrTmp);

		        pInstance->SetCHString(
                    IDS_DeviceID, 
                    chstrTmp);
            }
        }

        // Set the session id...
        {
		    WCHAR wstrBuff[MAXI64TOA];

            _i64tow(
                i64SessionID, 
                wstrBuff, 
                10);

            pInstance->SetWCHARSplat(
                IDS_SessionID, 
                wstrBuff);
        }
    
        // Set the provider name, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_PROVIDER_NAME)
            {
                ix[0] = PROP_PROVIDER_NAME;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetCHString(
                        IDS_ProviderName, 
                        (LPCWSTR) bstrProp);

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }      

        // Set the volume name, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_VOLUME_NAME)
            {
                ix[0] = PROP_VOLUME_NAME;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetCHString(
                        IDS_VolumeName, 
                        (LPCWSTR) bstrProp);

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the file system, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_FILE_SYSTEM)
            {
                ix[0] = PROP_FILE_SYSTEM;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetCHString(
                        IDS_FileSystem, 
                        (LPCWSTR) bstrProp);

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the volume serial number, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_VOLUME_SERIAL_NUMBER)
            {
                ix[0] = PROP_VOLUME_SERIAL_NUMBER;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetCHString(
                        IDS_VolumeSerialNumber, 
                        (LPCWSTR) bstrProp);

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the compressed prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_COMPRESSED)
            {
                ix[0] = PROP_COMPRESSED;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_Compressed, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the sup file based comp prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_SUPPORTS_FILE_BASED_COMPRESSION)
            {
                ix[0] = PROP_SUPPORTS_FILE_BASED_COMPRESSION;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_SupportsFileBasedCompression, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the max comp length prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_MAXIMUM_COMPONENT_LENGTH)
            {
                ix[0] = PROP_MAXIMUM_COMPONENT_LENGTH;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetDWORD(
                        IDS_MaximumComponentLength, 
                        DWORD_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the supports disk quotas prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_SUPPORTS_DISK_QUOTAS)
            {
                ix[0] = PROP_SUPPORTS_DISK_QUOTAS;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_SupportsDiskQuotas, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the quotas incomplete prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_QUOTAS_INCOMPLETE)
            {
                ix[0] = PROP_QUOTAS_INCOMPLETE;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_QuotasIncomplete, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the quotas rebuilding prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_QUOTAS_REBUILDING)
            {
                ix[0] = PROP_QUOTAS_REBUILDING;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_QuotasRebuilding, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the quotas disabled prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_QUOTAS_DISABLED)
            {
                ix[0] = PROP_QUOTAS_DISABLED;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_QuotasDisabled, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the perform autocheck prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_PERFORM_AUTOCHECK)
            {
                ix[0] = PROP_PERFORM_AUTOCHECK;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->Setbool(
                        IDS_VolumeDirty, 
                        bool_FROM_STR(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the freespace prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_FREE_SPACE)
            {
                ix[0] = PROP_FREE_SPACE;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetWBEMINT64(
                        IDS_FreeSpace, 
                        _wtoi64(bstrProp));

                    ::SysFreeString(bstrProp);
					bstrProp = NULL;
                }
            }
        }

        // Set the size prop, if requested...
        if(SUCCEEDED(hr))
        {
            if(dwReqProps & GET_SIZE)
            {
                ix[0] = PROP_SIZE;
                hr = ::SafeArrayGetElement(
                    psa,
                    ix,
                    &bstrProp);

                if(SUCCEEDED(hr) &&
                    wcslen(bstrProp) > 0)
                {
                    pInstance->SetWBEMINT64(
                        IDS_Size, 
                        _wtoi64(bstrProp));
                }
            }
        }
    }
    catch(...)
    {
        if(bstrProp != NULL)
        {
            ::SysFreeString(bstrProp);
            bstrProp = NULL;
        }
        throw;
    }

    if(bstrProp != NULL)
    {
        ::SysFreeString(bstrProp);
        bstrProp = NULL;
    }
    // Commit ourselves...
    if(SUCCEEDED(hr))
    {
        hr = pInstance->Commit();
    }    

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32scsicontrollerdevice.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32SCSIControllerDevice.cpp
//
//  Purpose: Relationship between Win32_SCSIController and CIM_LogicalDevice
//
//***************************************************************************

#include "precomp.h"
#include <cregcls.h>
#include <vector>

#include "scsi.h"

#include "PNPEntity.h"
#include "LPVParams.h"
#include <FRQueryEx.h>

#include "WIN32SCSIControllerDevice.h"

// Property set declaration
//=========================
CW32SCSICntrlDev MyCW32SCSICntrlDev(PROPSET_NAME_WIN32SCSICONTROLLERDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::CW32SCSICntrlDev
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32SCSICntrlDev::CW32SCSICntrlDev
(
    LPCWSTR setName,
    LPCWSTR pszNamespace
)
: CWin32_ScsiController(setName, pszNamespace),
  CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::~CW32SCSICntrlDev
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32SCSICntrlDev::~CW32SCSICntrlDev()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::GetObject
(
    CInstance *pInstance,
    long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

#if (NTONLY >= 5)

    if(pInstance != NULL)
    {
        CHString chstrAntecedent, chstrDependent;
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
        pInstance->GetCHString(IDS_Dependent, chstrDependent);

        // Obtain the antecedent's device id:
        CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
        chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
        CHString chstrAntecedentDevIDAdj;
        RemoveDoubleBackslashes(chstrAntecedentDevID,chstrAntecedentDevIDAdj);

        // Obtain the dependent's device id:
        CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
        chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
        CHString chstrDependentDevIDAdj;
        RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

        CConfigManager cfgmgr;

        // Now see if the dependent is visible to config manager...
        CConfigMgrDevicePtr pPNPDevice;
        if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, pPNPDevice))
        {
            // It is visible to config manager.  Is it a PNPDevice?
            if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
            {
                // It is. Is its parent a SCSIController?
                CConfigMgrDevicePtr pParentDevice;
                bool bFound = false;

                // or its parent?  Or its parent? Or...
                while (pPNPDevice->GetParent(pParentDevice))
                {
                    if(CWin32_ScsiController::IsOneOfMe(pParentDevice))
                    {
                        bFound = true;
                        break;
                    }
                    else
                    {
                        pPNPDevice = pParentDevice;
                    }
                }

                if (bFound)
                {
                    // It is. Is it's PNP ID the same as that which we were given?
                    CHString chstrControllerPNPID;
                    pParentDevice->GetDeviceID(chstrControllerPNPID);
                    if(chstrAntecedentDevIDAdj.CompareNoCase(chstrControllerPNPID)==0)
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
        }
    }

#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32SCSICntrlDev::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CW32SCSICntrlDev::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if NTONLY >= 5
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwReqProps;

    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwReqProps);

    std::vector<_bstr_t> vecDependents;
    pQuery.GetValuesForProp(IDS_Dependent, vecDependents);
    DWORD dwDependents = vecDependents.size();

    // Only will have one SCSIcontroller, so if the query asked for that
    // as the antecedent, do an enumeration.  If the query asked for a
    // specific device as the dependent, just get that one.
    if(dwDependents > 0)
    {
        for(LONG m = 0L; m < dwDependents; m++)
        {
            // Obtain the dependent's device id:
            CHString chstrDependent((LPCTSTR)vecDependents[m]);
            CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
            chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
            CHString chstrDependentDevIDAdj;
            RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

            CConfigManager cfgmgr;

            // Now see if the dependent is visible to config manager...
            CConfigMgrDevicePtr pPNPDevice;
            if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // It is. Is its parent a SCSIController?
                    CConfigMgrDevicePtr pParentDevice;
                    bool bFound = false;

                    // or its parent?  Or its parent? Or...
                    while (pPNPDevice->GetParent(pParentDevice))
                    {
                        if(CWin32_ScsiController::IsOneOfMe(pParentDevice))
                        {
                            bFound = true;
                            break;
                        }
                        else
                        {
                            pPNPDevice = pParentDevice;
                        }
                    }

                    if (bFound)
                    {
                        // It is, so create the association.
                        CHString chstrControllerPNPID;
                        pParentDevice->GetDeviceID(chstrControllerPNPID);
                        CHString chstrControllerPNPIDAdj;
                        EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                        CHString chstrControllerPATH;
                        chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                                   (LPCWSTR)GetLocalComputerName(),
                                                   IDS_CimWin32Namespace,
                                                   PROPSET_NAME_SCSICONTROLLER,
                                                   IDS_DeviceID,
                                                   (LPCWSTR)chstrControllerPNPIDAdj);

                        CHString chstrDevicePATH;
                        chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                               (LPCWSTR)GetLocalComputerName(),
                                               IDS_CimWin32Namespace,
                                               PROPSET_NAME_PNPEntity,
                                               IDS_DeviceID,
                                               (LPCWSTR)chstrDependentDevID);

                        hr = CreateAssociation(pMethodContext, chstrControllerPATH, chstrDevicePATH, dwReqProps);
                    }
                }
            }
        }
    }
    else
    {
        hr = CWin32_ScsiController::Enumerate(pMethodContext, lFlags, dwReqProps);
    }
#endif

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::EnumerateInstances
 *
 *  DESCRIPTION : Enumerate is present here to prevent ambiguous upcasting to
 *                functions of the same name from both base classes.  The
 *                logic in LoadPropertyValues works when CWin32_ScsiController's (the
 *                SCSIController class) version of EnumerateInstances is called,
 *                so that is what we call here.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

#if ( NTONLY >= 5 )
    t_Result = CWin32_ScsiController::Enumerate(pMethodContext, SCSICTL_PROP_ALL_PROPS);
#endif

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::LoadPropertyValues
(
    void* pv
)
{

    // Algorithm:
    // 1) Get all instances of Win32_SCSIController
    // 2) For each in #1, using cfg mgr, get its children, their children, etc.
    // 3) For each in #2, obtain DeviceID from cfg mgr, and look for instances of
    //    CIM_LogicalDevice with PNPDeviceIDs that match.
    // 4) For matches from #3, create association instances

    HRESULT hr = WBEM_S_NO_ERROR;

#if (NTONLY >= 5) 

    CHString chstrControllerPNPID;
    CHString chstrControllerPATH;
    MethodContext* pMethodContext = NULL;

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance* pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);
    if(pInstance == NULL || pDevice == NULL) return WBEM_E_FAILED;

    if((pMethodContext = pInstance->GetMethodContext()) != NULL)
    {
        VECPCHSTR vecSCSIDevices;

        pDevice->GetDeviceID(chstrControllerPNPID);

        try
        {
            hr = GenerateSCSIDeviceList(chstrControllerPNPID, vecSCSIDevices);
            if(SUCCEEDED(hr) && vecSCSIDevices.size() > 0L)
            {
                CHString chstrControllerPNPIDAdj;
                EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                           (LPCWSTR)GetLocalComputerName(),
                                           IDS_CimWin32Namespace,
                                           L"Win32_SCSIController",
                                           IDS_DeviceID,
                                           (LPCWSTR)chstrControllerPNPIDAdj);
                hr = ProcessSCSIDeviceList(pMethodContext, chstrControllerPATH, vecSCSIDevices, dwReqProps);
            }
        }
        catch ( ... )
        {
            CleanPCHSTRVec(vecSCSIDevices);
            throw ;
        }
        CleanPCHSTRVec(vecSCSIDevices);
    }

#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::GenerateSCSIDeviceList
 *
 *  DESCRIPTION : This helper creates a list of devices hanging off the passed
 *                in device.
 *
 *  INPUTS      : vecSCSIDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPNPID, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::GenerateSCSIDeviceList
(
    const CHString& chstrControllerPNPID,
    VECPCHSTR& vec
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if (NTONLY >= 5) 

    CConfigManager cfgManager;
    CConfigMgrDevicePtr pController;
    if(cfgManager.LocateDevice(chstrControllerPNPID, pController))
    {
        if(pController != NULL)
        {
            hr = RecursiveFillDeviceBranch(pController, vec);
        }
    }

#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::RecursiveFillDeviceBranch
 *
 *  DESCRIPTION : This helper obtains all down branch devices starting with,
 *                but not including, pDevice.
 *
 *  INPUTS      : pDevice, a device to populate the children of;
 *                vecSCSIDevices, a list of devices to try to associate
 *                   to the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::RecursiveFillDeviceBranch
(
    CConfigMgrDevice* pDevice,
    VECPCHSTR& vecSCSIDevices
)
{

    HRESULT hr = WBEM_S_NO_ERROR;

#if (NTONLY >= 5) 

    CConfigMgrDevicePtr pDeviceChild;
    CConfigMgrDevicePtr pDeviceSibling;
    CConfigMgrDevicePtr pDeviceSiblingNext;
    CHString* pchstrTemp = NULL;

    if(pDevice != NULL)
    {
        if(pDevice->GetChild(pDeviceChild))
        {
            // Need this child's PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                if(chstrChildPNPDeviceID.GetLength() > 0)
                {
                    // Record this child...
                    pchstrTemp = NULL;
                    pchstrTemp = (CHString*) new CHString(chstrChildPNPDeviceID);
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            vecSCSIDevices.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            pchstrTemp = NULL;
                            throw ;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }

                    // If we've hit another controller, add this one (done above), but don't go
                    // any deeper.
                    if (!CWin32_ScsiController::IsOneOfMe(pDeviceChild))
                    {
                        hr = RecursiveFillDeviceBranch(pDeviceChild, vecSCSIDevices);
                    }
                }
            }
            // Now call its brothers and sisters until none left (GetSibling
            // call will return FALSE):
            if(SUCCEEDED(hr))
            {
                if(pDeviceChild->GetSibling(pDeviceSibling))
                {
                    BOOL fContinue = TRUE;
                    CHString chstrSiblingPNPDeviceID;
                    while(SUCCEEDED(hr) && fContinue)
                    {
                        // Record the sibling now...
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            if(chstrSiblingPNPDeviceID.GetLength() > 0)
                            {
                                pchstrTemp = NULL;
                                pchstrTemp = (CHString*) new CHString(chstrSiblingPNPDeviceID);
                                if(pchstrTemp != NULL)
                                {
                                    try
                                    {
                                        vecSCSIDevices.push_back(pchstrTemp);
                                    }
                                    catch ( ... )
                                    {
                                        delete pchstrTemp;
                                        pchstrTemp = NULL;
                                        throw ;
                                    }
                                }
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }
                        }

                        // If we've hit another controller, add this one (done above), but don't go
                        // any deeper.
                        if (!CWin32_ScsiController::IsOneOfMe(pDeviceSibling))
                        {
                            hr = RecursiveFillDeviceBranch(pDeviceSibling, vecSCSIDevices);
                        }

                        // Then get the next sibling...
                        pDeviceSiblingNext = NULL;
                        fContinue = pDeviceSibling->GetSibling(pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling = pDeviceSiblingNext;
                    }
                }
            }
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

#endif

    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::ProcessSCSIDeviceList
 *
 *  DESCRIPTION : This helper runs through the list, creating an association
 *                instance for each element in the list (vecSCSIDevices) with
 *                the controller (chstrControllerPNPID).
 *
 *  INPUTS      : pMethodContext;
 *                vecSCSIDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::ProcessSCSIDeviceList
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    VECPCHSTR& vecSCSIDevices,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#if (NTONLY >= 5) 

    for(LONG m = 0L; m < vecSCSIDevices.size() && SUCCEEDED(hr); m++)
    {
        // For each element of the vector, we need to see if there is an instance
        // of a win32_pnpentity that has the specified PNPDeviceID.
        CHString chstrDevicePATH, chstrDevPATHAdj;
        CConfigManager cfgmgr;

        // Let's see if config manager recognizes this device at all
        CConfigMgrDevicePtr pDevice;
        if(cfgmgr.LocateDevice(*vecSCSIDevices[m], pDevice))
        {
            // Ok, it knows about it.  Is it a PNPDevice device?
            if(CWin32PNPEntity::IsOneOfMe(pDevice))
            {
                // It would appear that it is.  Create the association...
                EscapeBackslashes(*vecSCSIDevices[m], chstrDevPATHAdj);
                chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_PNPEntity,
                                       IDS_DeviceID,
                                       (LPCWSTR)chstrDevPATHAdj);

                hr = CreateAssociation(pMethodContext, chstrControllerPATH, chstrDevicePATH, dwReqProps);
            }
        }
    }

#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::CreateAssociation
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : pMethodContext;
 *                SCSIDevice, a device to associate with the controller
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper actually creates the association instance and
 *                commits it.
 *
 *****************************************************************************/
HRESULT CW32SCSICntrlDev::CreateAssociation
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    const CHString& chstrDevicePATH,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;

#if (NTONLY >= 5) 

    if(pMethodContext != NULL)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            if(dwReqProps & SCSICTL_PROP_Antecedent || dwReqProps & SCSICTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Antecedent, chstrControllerPATH);
            }

            if(dwReqProps & SCSICTL_PROP_Dependent || dwReqProps & SCSICTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Dependent, chstrDevicePATH);
            }

            hr = pInstance->Commit();
        }
    }

#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::FindInStringVector
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : chstrSCSIDevicePNPID, device to look for
 *                vecSCSIDevices, list of devices to look in
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG, number indicating 0 based offset into vecSCSIDevices of
 *                the found device, or -1 if not found.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CW32SCSICntrlDev::FindInStringVector
(
    const CHString& chstrSCSIDevicePNPID,
    VECPCHSTR& vecSCSIDevices
)
{
    LONG lPos = -1L;

#if (NTONLY >= 5) 

    bool fFoundIt;
    for(LONG m = 0; m < vecSCSIDevices.size(); m++)
    {
        if(chstrSCSIDevicePNPID == *vecSCSIDevices[m])
        {
            fFoundIt = true;
            break;
        }
    }
    if(fFoundIt) lPos = m;

#endif

    return lPos;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SCSICntrlDev::CleanPCHSTRVec
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : vec, a vector of CHString pointers
 *
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper deletes members of a vector that are pointers.
 *
 *****************************************************************************/
void CW32SCSICntrlDev::CleanPCHSTRVec
(
    VECPCHSTR& vec
)
{
#if (NTONLY >= 5) 

    for(LONG m = 0L; m < vec.size(); m++)
    {
        delete vec[m];
    }
    vec.clear();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupcontents.h ===
//=================================================================

//

// Win32ProgramGroupContents.h -- Win32_ProgramGroup to Win32_ProgramGroupORItem

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/18/98    a-kevhu         Created
//
// Comment: Relationship between Win32_ProgramGroup and Win32_ProgramGroupORItem it contains
//
//=================================================================

// Property set identification
//============================
#define  PROPSET_NAME_WIN32PROGRAMGROUPCONTENTS L"Win32_ProgramGroupContents"

#define ID_FILEFLAG 0L
#define ID_DIRFLAG  1L

class CW32ProgGrpCont;

class CW32ProgGrpCont : public Provider 
{
    public:
        // Constructor/destructor
        //=======================
        CW32ProgGrpCont(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32ProgGrpCont() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

    private:
        VOID RemoveDoubleBackslashes(CHString& chstrIn);
        bool AreSimilarPaths(CHString& chstrPGCGroupComponent, CHString& chstrPGCPartComponent);

#ifdef NTONLY
        HRESULT QueryForSubItemsAndCommitNT(CHString& chstrAntecedentPATH,
                                          CHString& chstrQuery,
                                          MethodContext* pMethodContext);
#endif

        HRESULT DoesFileOrDirExist(WCHAR* wstrFullFileName, DWORD dwFileOrDirFlag);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupitemdatafile.h ===
//=================================================================

//

// Win32ProgramGroupItemDataFile.h -- Win32_LogicalProgramGroupItem to CIM_DataFile

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/98    a-kevhu         Created
//
// Comment: Relationship between Win32_LogicalProgramGroupItem and CIM_DataFile
//
//=================================================================

#ifndef _WIN32PROGRAMGROUPITEMDATAFILE_H
#define _WIN32PROGRAMGROUPITEMDATAFILE_H


// Property set identification
//============================
#define  PROPSET_NAME_WIN32LOGICALPROGRAMGROUPITEM_CIMDATAFILE L"Win32_LogicalProgramGroupItemDataFile"

#include "implement_logicalfile.h"

class CW32ProgGrpItemDataFile : public CImplement_LogicalFile 
{
    public:
        // Constructor/destructor
        //=======================
        CW32ProgGrpItemDataFile(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32ProgGrpItemDataFile() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

    protected:
       
       // Overridable function inherrited from CImplement_LogicalFile

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual HRESULT LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif


    private:
        
        HRESULT ExecQueryType1(MethodContext* pMethodContext, CHString& chstrProgGroupItemName);
        HRESULT ExecQueryType2(MethodContext* pMethodContext, CHString& chstrDF);

#ifdef NTONLY
        HRESULT EnumerateInstancesNT(MethodContext* pMethodContex);
        HRESULT AssociatePGIToDFNT(MethodContext* pMethodContext,
                                   CHString& chstrDF,
                                   CHString& chstrProgGrpItemPATH);
#endif

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupcontents.cpp ===
//=================================================================

//

// Win32ProgramCollectionProgramGroup.cpp -- Win32_ProgramGroup to Win32_ProgramGroupORItem

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/98    a-kevhu         Created
//
// Comment: Relationship between Win32_ProgramGroup and Win32_ProgramGroupORItem it contains
//
//=================================================================

#include "precomp.h"

#include "Win32ProgramGroupContents.h"
#include "LogicalProgramGroupItem.h"
#include "LogicalProgramGroup.h"
#include <frqueryex.h>
#include <utils.h>


// Property set declaration
//=========================
CW32ProgGrpCont MyCW32ProgGrpCont(PROPSET_NAME_WIN32PROGRAMGROUPCONTENTS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::CW32ProgGrpCont
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32ProgGrpCont::CW32ProgGrpCont(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::~CW32ProgGrpCont
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32ProgGrpCont::~CW32ProgGrpCont()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpCont::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    TRefPointerCollection<CInstance> GroupDirs;
    CHString chstrPGCGroupComponent;
    CHString chstrPGCPartComponent;

    if(pInstance == NULL)
    {
        return WBEM_E_FAILED;
    }

    pInstance->GetCHString(IDS_GroupComponent, chstrPGCGroupComponent);
    pInstance->GetCHString(IDS_PartComponent, chstrPGCPartComponent);

    if(AreSimilarPaths(chstrPGCGroupComponent, chstrPGCPartComponent))
    {
        CHString chstrPGCPartComponentFilenameOnly;
        chstrPGCPartComponentFilenameOnly = chstrPGCPartComponent.Mid(chstrPGCPartComponent.ReverseFind(_T('\\')));
        chstrPGCPartComponentFilenameOnly = chstrPGCPartComponentFilenameOnly.Left(chstrPGCPartComponentFilenameOnly.GetLength() - 1);

        // Need version of chstrPGCGroupComponent with escaped backslashes for the following query.
        CHString chstrPGCGroupComponentDblEsc;
        EscapeBackslashes(chstrPGCGroupComponent,chstrPGCGroupComponentDblEsc);
        // Also need to escape the quotes...
        CHString chstrPGCGroupComponentDblEscQuoteEsc;
        EscapeQuotes(chstrPGCGroupComponentDblEsc,chstrPGCGroupComponentDblEscQuoteEsc);
        CHString chstrProgGroupDirQuery;

        chstrProgGroupDirQuery.Format(L"SELECT * FROM Win32_LogicalProgramGroupDirectory WHERE Antecedent = \"%s\"", chstrPGCGroupComponentDblEscQuoteEsc);

        if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrProgGroupDirQuery,
                                                            &GroupDirs,
                                                            pInstance->GetMethodContext(),
                                                            IDS_CimWin32Namespace)))
        {
		    REFPTRCOLLECTION_POSITION pos;
		    CInstancePtr pProgramGroupDirInstance;

            // We'll need a normalized path for chstrPGCGroupComponent...
            CHString chstrPGCGroupComponentNorm;
            if(NormalizePath(chstrPGCGroupComponent, GetLocalComputerName(), IDS_CimWin32Namespace, NORMALIZE_NULL, chstrPGCGroupComponentNorm) == e_OK)
            {
		        if(GroupDirs.BeginEnum(pos))
		        {
                    CHString chstrPGDAntecedent;
                    CHString chstrPGDDependent;
                    CHString chstrPGDDependentFullFileName;
                    CHString chstrTemp;
                    CHString chstrLPGIClassName(PROPSET_NAME_LOGICALPRGGROUPITEM);

                    chstrLPGIClassName.MakeLower();
                    // Determine if the dependent (of this association class - PC) was a programgroup or a programgroupitem
                    chstrPGCPartComponent.MakeLower();
                    if(chstrPGCPartComponent.Find(chstrLPGIClassName) != -1)
                    {
                        // The dependent was a programgroupitem, so will look for matching file
                        // Go through PGD instances (should only be one) until find a PGDAntecedent that matches the PCAntecedent
                        for(pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos));
                            (pProgramGroupDirInstance != NULL) ;
                            pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos)))
			            {
				            pProgramGroupDirInstance->GetCHString(IDS_Antecedent, chstrPGDAntecedent);
                            pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrPGDDependent);

                            // Need a normalized version of the antecedent for the comparison below...
                            CHString chstrPGDAntecedentNorm;
                            if(NormalizePath(chstrPGDAntecedent, GetLocalComputerName(), IDS_CimWin32Namespace, NORMALIZE_NULL, chstrPGDAntecedentNorm) == e_OK)
                            {
                                // See if the PGDAntecedent matches the chstrPGCGroupComponentNorm
                                if(chstrPGDAntecedentNorm.CompareNoCase(chstrPGCGroupComponentNorm) == 0)
                                {
                                    // Got the proposed filename from the PCDependent at the beginning of GetObject.
                                    // Now Get the directory of the PGD (PGDDependent) associated with the PC antecedent
                                    chstrPGDDependentFullFileName = chstrPGDDependent.Mid(chstrPGDDependent.Find(_T('='))+2);
                                    chstrPGDDependentFullFileName = chstrPGDDependentFullFileName.Left(chstrPGDDependentFullFileName.GetLength() - 1);
                                    RemoveDoubleBackslashes(chstrPGDDependentFullFileName);
                                    chstrTemp.Format(L"%s%s",chstrPGDDependentFullFileName,chstrPGCPartComponentFilenameOnly);
                                    hr = DoesFileOrDirExist(_bstr_t(chstrTemp),ID_FILEFLAG);
                                    if(SUCCEEDED(hr))
                                    {
                                        hr = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            } // got normalized path for the antecedent
                        }
                    }
                    else
                    {
                        // The dependent was a programgroup, so will look for matching dir
                        // Go through PGD instances until find a PGDAntecedent that matches the PCAntecedent
                        for (pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos));
                             pProgramGroupDirInstance != NULL;
                             pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos)))
			            {
				            pProgramGroupDirInstance->GetCHString(IDS_Antecedent, chstrPGDAntecedent);
                            pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrPGDDependent);

                            // Need a normalized version of the antecedent for the comparison below...
                            CHString chstrPGDAntecedentNorm;
                            if(NormalizePath(chstrPGDAntecedent, GetLocalComputerName(), IDS_CimWin32Namespace, NORMALIZE_NULL, chstrPGDAntecedentNorm) == e_OK)
                            {
                                // See if the PGDAntecedent matches the PCAntecedent
                                if(chstrPGDAntecedentNorm.CompareNoCase(chstrPGCGroupComponentNorm) == 0)
                                {
                                    // Got the proposed filename (which is a directory name in this case) from the PCDependent at the beginning of GetObject.
                                    // Now Get the directory of the PGD (PGDDependent) associated with the PC antecedent
                                    chstrPGDDependentFullFileName = chstrPGDDependent.Mid(chstrPGDDependent.Find(_T('='))+2);
                                    chstrPGDDependentFullFileName = chstrPGDDependentFullFileName.Left(chstrPGDDependentFullFileName.GetLength() - 1);
                                    RemoveDoubleBackslashes(chstrPGDDependentFullFileName);
                                    chstrTemp.Format(L"%s\\%s",chstrPGDDependentFullFileName,chstrPGCPartComponentFilenameOnly);
                                    hr = DoesFileOrDirExist(_bstr_t(chstrTemp),ID_DIRFLAG);
                                    if(SUCCEEDED(hr))
                                    {
                                        hr = WBEM_S_NO_ERROR;
                                        break;
                                    }
                                }
                            } // got normalized path for the antecedent
                        }
                    }
			        GroupDirs.EndEnum();
		        }	// IF BeginEnum
            } // got a normalized path successfully
	    }
    }
	return hr;
}




/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpCont::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL f3TokenOREqualArgs = FALSE;
    BOOL fGroupCompIsGroup = FALSE;
    _bstr_t bstrtGroupComponent;
    _bstr_t bstrtPartComponent;

    // I'm only going to optimize queries that had Antecedent and Dependent arguements OR'd together
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);
    if (pQuery2 != NULL)
    {
        variant_t vGroupComponent;
        variant_t vPartComponent;
        if(pQuery2->Is3TokenOR(L"GroupComponent", L"PartComponent", vGroupComponent, vPartComponent))
        {
            bstrtGroupComponent = V_BSTR(&vGroupComponent);
            bstrtPartComponent = V_BSTR(&vPartComponent);
            // I'm also going to insist that the arguements of the dependent and the antecedent be the same
            if(bstrtGroupComponent == bstrtPartComponent)
            {
                f3TokenOREqualArgs = TRUE;
            }
        }
    }

    // Only want to proceed if the Antecedent was a program group (Dependent can be either group or item, however).
    if(f3TokenOREqualArgs)
    {
        if(wcsstr((wchar_t*)bstrtGroupComponent,(wchar_t*)_bstr_t(PROPSET_NAME_LOGICALPRGGROUP)))
        {
            fGroupCompIsGroup = TRUE;
        }
    }

    if(fGroupCompIsGroup)
    {
        CHString chstrPGCPartComponent((wchar_t*)bstrtPartComponent);
        CHString chstrPGCGroupComponent((wchar_t*)bstrtGroupComponent);

        // We will get here is someone had a particular program group and asked for its associations.  This
        // provider will give back program groups and program group items associated with (underneath) the
        // supplied program group.  The query will look like the following:
        // select * from Win32_ProgramGroupContents where (PartComponent = "Win32_LogicalProgramGroup.Name=\"Default User:Accessories\"" OR GroupComponent = "Win32_LogicalProgramGroup.Name=\"Default User:Accessories\"")

        // Step 1: Do a GetInstanceByQuery to obtain the specific directory associated with the program group
        //==================================================================================================

        // Need version of chstrPGCGroupComponent with escaped backslashes for the following query...
        CHString chstrPGCGroupComponentDblEsc;
        EscapeBackslashes(chstrPGCGroupComponent,chstrPGCGroupComponentDblEsc);
        // Also need to escape the quotes...
        CHString chstrPGCGroupComponentDblEscQuoteEsc;
        EscapeQuotes(chstrPGCGroupComponentDblEsc,chstrPGCGroupComponentDblEscQuoteEsc);
        CHString chstrProgGroupDirQuery;
        TRefPointerCollection<CInstance> GroupDirs;

        chstrProgGroupDirQuery.Format(L"SELECT * FROM Win32_LogicalProgramGroupDirectory WHERE Antecedent = \"%s\"", (LPCWSTR)chstrPGCGroupComponentDblEscQuoteEsc);

        if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrProgGroupDirQuery,
                                                            &GroupDirs,
                                                            pMethodContext,
                                                            IDS_CimWin32Namespace)))
        {
            // Step 2: Eunumerate all the program groups (dirs) and program group items (files) found underneath it
            //=====================================================================================================

            REFPTRCOLLECTION_POSITION pos;

	        if(GroupDirs.BeginEnum(pos))
	        {
                CHString chstrDependent;
                CHString chstrFullPathName;
                CHString chstrPath;
                CHString chstrDrive;
                CHString chstrAntecedent;
                CHString chstrSearchPath;

    	        CInstancePtr pProgramGroupDirInstance;

                for (pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos)) ;
                    (pProgramGroupDirInstance != NULL) && (SUCCEEDED(hr)) ;
                     pProgramGroupDirInstance.Attach(GroupDirs.GetNext(pos)) )
			    {
                    // For each program group, get the drive and path associated on disk with it:
                    pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrDependent);
                    chstrFullPathName = chstrDependent.Mid(chstrDependent.Find(_T('='))+1);
                    chstrDrive = chstrFullPathName.Mid(1,2);
                    chstrPath = chstrFullPathName.Mid(3);
                    chstrPath = chstrPath.Left(chstrPath.GetLength() - 1);
                    chstrPath += L"\\\\";

                    // Query that directory for all the **CIM_LogicalFile** instances (of any type) it contains:
                    chstrSearchPath.Format(L"%s%s",chstrDrive,chstrPath);

                    // The function QueryForSubItemsAndCommit needs a search string with single backslashes...
                    RemoveDoubleBackslashes(chstrSearchPath);
#ifdef NTONLY
                    hr = QueryForSubItemsAndCommitNT(chstrPGCGroupComponent, chstrSearchPath, pMethodContext);
#endif
			    }
                GroupDirs.EndEnum();
            }
        }  // GetInstancesByQuery succeeded
    }
    else
    {
        hr = EnumerateInstances(pMethodContext);
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpCont::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpCont::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> ProgGroupDirs;

    // Step 1: Get an enumeration of all the ProgramGroupDirectory association class instances
    if SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(L"Win32_LogicalProgramGroupDirectory", &ProgGroupDirs, IDS_CimWin32Namespace, pMethodContext))
    {
	    REFPTRCOLLECTION_POSITION pos;

	    if(ProgGroupDirs.BeginEnum(pos))
	    {
            CHString chstrDependent;
            CHString chstrFullPathName;
            CHString chstrPath;
            CHString chstrDrive;
            CHString chstrAntecedent;
            CHString chstrSearchPath;

    	    CInstancePtr pProgramGroupDirInstance;

            for (pProgramGroupDirInstance.Attach(ProgGroupDirs.GetNext(pos)) ;
                (pProgramGroupDirInstance != NULL) && (SUCCEEDED(hr)) ;
                 pProgramGroupDirInstance.Attach(ProgGroupDirs.GetNext(pos)) )
			{
                // Step 2: For each program group, get the drive and path associated on disk with it:
                pProgramGroupDirInstance->GetCHString(IDS_Dependent, chstrDependent);
                chstrFullPathName = chstrDependent.Mid(chstrDependent.Find(_T('='))+1);
                chstrDrive = chstrFullPathName.Mid(1,2);
                chstrPath = chstrFullPathName.Mid(3);
                chstrPath = chstrPath.Left(chstrPath.GetLength() - 1);
                chstrPath += _T("\\\\");

                // Step 3: For each program group, get the user account it is associated with:
                pProgramGroupDirInstance->GetCHString(IDS_Antecedent, chstrAntecedent);

                // Step 4: Query that directory for all the **CIM_LogicalFile** instances (of any type) it contains:
                chstrSearchPath.Format(L"%s%s",chstrDrive,chstrPath);

                // The function QueryForSubItemsAndCommit needs a search string with single backslashes...
                RemoveDoubleBackslashes(chstrSearchPath);
#ifdef NTONLY
                hr = QueryForSubItemsAndCommitNT(chstrAntecedent, chstrSearchPath, pMethodContext);
#endif
			}
            ProgGroupDirs.EndEnum();
        }
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : QueryForSubItemsAndCommit
 *
 *  DESCRIPTION : Helper to fill property and commit instances of progcollectionproggroup
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CW32ProgGrpCont::QueryForSubItemsAndCommitNT(CHString& chstrGroupComponentPATH,
                                                     CHString& chstrQuery,
                                                     MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WIN32_FIND_DATAW stFindData;
    ZeroMemory(&stFindData,sizeof(stFindData));
    SmartFindClose hFind;
    _bstr_t bstrtSearchString((LPCTSTR)chstrQuery);
    WCHAR wstrDriveAndPath[_MAX_PATH];
    CHString chstrUserAccountAndGroup;
    CHString chstrPartComponent;

    wcscpy(wstrDriveAndPath,(wchar_t*)bstrtSearchString);
    bstrtSearchString += L"*.*";

    hFind = FindFirstFileW((wchar_t*)bstrtSearchString, &stFindData);
    DWORD dw = GetLastError();
    if (hFind == INVALID_HANDLE_VALUE || dw != ERROR_SUCCESS)
    {
        hr = WinErrorToWBEMhResult(GetLastError());
    }

    if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
    {
        hr = WBEM_S_NO_ERROR;
    }

    if(hr == WBEM_E_NOT_FOUND)
    {
        return WBEM_S_NO_ERROR;   // didn't find any files, but don't want the calling routine to abort
    }

    do
    {
        if((wcscmp(stFindData.cFileName, L".") != 0) &&
          (wcscmp(stFindData.cFileName, L"..") != 0))
        {
            if(!(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                // It is a program group item (a file)
                CInstancePtr pInstance(CreateNewInstance(pMethodContext),false);
                if(pInstance != NULL)
                {
                    // Need to set antecedent and dependent.  Antecedent is the group we were passed
                    // in (in chstrGroupComponentPATH); dependent is the (in this case) a Win32_ProgramGroupItem,
                    // since we found a file.
                    chstrUserAccountAndGroup = chstrGroupComponentPATH.Mid(chstrGroupComponentPATH.Find(_T('='))+2);
                    chstrUserAccountAndGroup = chstrUserAccountAndGroup.Left(chstrUserAccountAndGroup.GetLength() - 1);

                    chstrPartComponent.Format(_T("\\\\%s\\%s:%s.Name=\"%s\\\\%s\""),
                                          (LPCTSTR)GetLocalComputerName(),
                                          IDS_CimWin32Namespace,
                                          _T("Win32_LogicalProgramGroupItem"),
                                          chstrUserAccountAndGroup,
                                          (LPCTSTR)CHString(stFindData.cFileName));
                    pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
                    pInstance->SetCHString(IDS_PartComponent, chstrPartComponent);
                    hr = pInstance->Commit();
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
            else if(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // It is a program group (a directory)
                CInstancePtr pInstance (CreateNewInstance(pMethodContext),false);
                if(pInstance != NULL)
                {
                    // Need to set antecedent and dependent.  Antecedent is the group we were passed
                    // in (in chstrGroupComponentPATH); dependent is the (in this case) a Win32_LogicalProgramGroup,
                    // since we found a directory.
                    chstrUserAccountAndGroup = chstrGroupComponentPATH.Mid(chstrGroupComponentPATH.Find(_T('='))+2);
                    chstrUserAccountAndGroup = chstrUserAccountAndGroup.Left(chstrUserAccountAndGroup.GetLength() - 1);

                    chstrPartComponent.Format(_T("\\\\%s\\%s:%s.Name=\"%s\\\\%s\""),
                                          (LPCTSTR)GetLocalComputerName(),
                                          IDS_CimWin32Namespace,
                                          _T("Win32_LogicalProgramGroup"),
                                          chstrUserAccountAndGroup,
                                          (LPCTSTR)CHString(stFindData.cFileName));
                    pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
                    pInstance->SetCHString(IDS_PartComponent, chstrPartComponent);
                    hr = pInstance->Commit();
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
        if(hr == WBEM_E_ACCESS_DENIED)  // keep going - might have access to others
        {
            hr = WBEM_S_NO_ERROR;
        }
    }while((FindNextFileW(hFind, &stFindData)) && (SUCCEEDED(hr)));

    return(hr);
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : RemoveDoubleBackslashes
 *
 *  DESCRIPTION : Helper to change double backslashes to single backslashes
 *
 *  INPUTS      : CHString& containing the string with double backslashes,
 *                which will be changed by this function to the new string.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

VOID CW32ProgGrpCont::RemoveDoubleBackslashes(CHString& chstrIn)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(L"\\\\");
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    chstrIn = chstrBuildString;
}


/*****************************************************************************
 *
 *  FUNCTION    : DoesFileOrDirExist
 *
 *  DESCRIPTION : Helper to determine if a file or a directory exists
 *
 *  INPUTS      : wstrFullFileName, the full path name of the file
 *                dwFileOrDirFlag, a flag indicating whether we want to check
 *                    for the existence of a file or a directory
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpCont::DoesFileOrDirExist(WCHAR* wstrFullFileName, DWORD dwFileOrDirFlag)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
    {
        WIN32_FIND_DATAW stFindData;
        //HANDLE hFind = NULL;
        SmartFindClose hFind;
        hFind = FindFirstFileW(wstrFullFileName, &stFindData);
        DWORD dw = GetLastError();
        if(hFind != INVALID_HANDLE_VALUE && dw == ERROR_SUCCESS)
        {
            if((stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (dwFileOrDirFlag == ID_DIRFLAG))
            {
                hr = S_OK;
            }
             if(!(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (dwFileOrDirFlag == ID_FILEFLAG))
            {
                hr = S_OK;
            }
        }
    }
#endif
    return hr;
}



bool CW32ProgGrpCont::AreSimilarPaths(CHString& chstrPGCGroupComponent, CHString& chstrPGCPartComponent)
{
    bool fRet = false;

    long EqualSign1 = -1L;
    long EqualSign2 = -1L;

    EqualSign1 = chstrPGCPartComponent.Find(L'=');
    EqualSign2 = chstrPGCGroupComponent.Find(L'=');

    if(EqualSign1 != -1L && EqualSign2 != -1L)
    {
        CHString chstrPartPath = chstrPGCPartComponent.Mid(EqualSign1+1);
        CHString chstrGroupPath = chstrPGCGroupComponent.Mid(EqualSign2+1);
        chstrGroupPath = chstrGroupPath.Left(chstrGroupPath.GetLength()-1);
        long lPosLastBackslash = chstrPartPath.ReverseFind(L'\\');
        if(lPosLastBackslash != -1L)
        {
            chstrPartPath = chstrPartPath.Left(lPosLastBackslash - 1);

            if(chstrPartPath.CompareNoCase(chstrGroupPath) == 0)
            {
                fRet = true;
            }
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupwin32directory.cpp ===
//=================================================================

//

// Win32ProgramGroupWin32Directory.cpp -- Win32_LogicalProgramGroup to Win32_Directory

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between win32_logicalprogramgroup and contained win32_directories
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "userhive.h"

#include "Win32ProgramGroupWin32Directory.h"
#include "directory.h"


// Property set declaration
//=========================
CW32ProgGrpW32Dir MyW32ProgGrpW32Dir(PROPSET_NAME_WIN32LOGICALPROGRAMGROUP_WIN32DIRECTORY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::CW32ProgGrpW32Dir
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32ProgGrpW32Dir::CW32ProgGrpW32Dir(LPCWSTR setName, LPCWSTR pszNamespace)
:CImplement_LogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::~CW32ProgGrpW32Dir
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32ProgGrpW32Dir::~CW32ProgGrpW32Dir()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpW32Dir::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrProgGroup;
    CHString chstrDataFile;
    HRESULT hr = WBEM_E_NOT_FOUND;
    CInstancePtr pProgGroup;
    CInstancePtr pDataFile;

    if(pInstance != NULL)
    {
        // Get the two paths
        pInstance->GetCHString(IDS_Antecedent, chstrProgGroup);
        pInstance->GetCHString(IDS_Dependent, chstrDataFile);

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrProgGroup, &pProgGroup, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDataFile, &pDataFile, pInstance->GetMethodContext())))
            {
                // Double check that the dependent instance really is a directory (or derived) instance...
                CHString chstrClass;
                if(pDataFile->GetCHString(IDS___Class, chstrClass) &&
                    CWbemProviderGlue::IsDerivedFrom(L"CIM_Directory", chstrClass, pDataFile->GetMethodContext(), IDS_CimWin32Namespace))
                {
                    // Make sure the group is still a group that is registered (not just left over directory)
                    CHString chstrUserPart;
                    CHString chstrPathPart;
#ifdef NTONLY
                    {
                        CHString chstrProgGroupName;
                        pProgGroup->GetCHString(IDS_Name,chstrProgGroupName);
                        chstrUserPart = chstrProgGroupName.SpanExcluding(L":");
                        chstrPathPart = chstrProgGroupName.Mid(chstrUserPart.GetLength() + 1);
                        if(chstrUserPart.CompareNoCase(IDS_Default_User) == 0)
                        {
                            // Default user and All Users are not part of the user hive, they just are.
                            // Since we got this far, we know that the file exists in the specified location
                            // within the program group directory by virtue of the two GetInstanceByPath calls
                            // which would not have succeeded had the file not existed.  So all is well.
                            hr = WBEM_S_NO_ERROR;
                        }
                        else if(chstrUserPart.CompareNoCase(IDS_All_Users) == 0)
                        {
                            hr = WBEM_S_NO_ERROR;
                        }
                        else
                        {
                            CUserHive cuhUser;
                            TCHAR szKeyName[_MAX_PATH];
                            ZeroMemory(szKeyName,sizeof(szKeyName));
                            if (cuhUser.Load(chstrUserPart, szKeyName, _MAX_PATH) == ERROR_SUCCESS)
		                    {
                                try
                                {
                                    CRegistry reg;
                                    CHString chstrTemp;
                                    CHString chstrProfileImagePath = L"ProfileImagePath";
                                    CHString chstrProfileImagePathValue;
                                    chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                                    chstrTemp += szKeyName;
                                    if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                                    {
                                        // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000"
                                        // Need to expand out the environment variable.
                                        TCHAR tstrProfilesDir[_MAX_PATH];
                                        ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
                                        DWORD dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfilesDir,_MAX_PATH);
                                        if(dw != 0 && dw < _MAX_PATH)
                                        {
                                            CHString chstrProgGroupDir;
                                            chstrProgGroupDir.Format(L"%s\\",
                                                                     (LPCWSTR)tstrProfilesDir);
                                            // Create a directory name based on what the registry says it should be
                                            CHString chstrDirectoryName;
                                            chstrDirectoryName.Format(L"%s%s", (LPCWSTR)chstrProgGroupDir, (LPCWSTR)chstrPathPart);
                                            EscapeBackslashes(chstrDirectoryName,chstrDirectoryName);
                                            // If the directory name above is a portion of chstrDataFile, we are valid.
                                            chstrDataFile.MakeUpper();
                                            chstrDirectoryName.MakeUpper();
                                            if(chstrDataFile.Find(chstrDirectoryName) > -1)
                                            {
                                                // Everything seems to actually exist.
                                                hr = WBEM_S_NO_ERROR;
                                            }
                                        } // expanded environment variable
                                        reg.Close();
                                    }  // could open registry key for profilelist
                                }
                                catch ( ... )
                                {
                                    cuhUser.Unload(szKeyName);
                                    throw ;
                                }

                                cuhUser.Unload(szKeyName);
                            } // userhive loaded
                        } // else a user-hive user account
                    } // was nt
#endif
                }
            } //datafile instancebypath
        } //progroup instancebypath
    } // pinstance not null
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::ExecQuery
 *
 *  DESCRIPTION : Returns only the specific association asked for
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpW32Dir::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    // We optimize on two types of queries only: those in which the antecedent was specified only (the programgroupitem),
    // or those in which the dependent was specified only (the datafile).  All others result in an enumeration.

    HRESULT hr = WBEM_E_NOT_FOUND;

    CHStringArray achstrAntecedent;
    CHStringArray achstrDependent;
    DWORD dwAntecedents = 0;
    DWORD dwDependents = 0;

    pQuery.GetValuesForProp(IDS_Antecedent, achstrAntecedent);
    dwAntecedents = achstrAntecedent.GetSize();
    pQuery.GetValuesForProp(IDS_Dependent, achstrDependent);
    dwDependents = achstrDependent.GetSize();

    if(dwAntecedents == 1 && dwDependents == 0)
    {
        hr = ExecQueryType1(pMethodContext, achstrAntecedent[0]);
    }
    else if(dwDependents == 1 && dwAntecedents == 0)
    {
        hr = ExecQueryType2(pMethodContext, achstrDependent[0]);
    }
    else // type of query we don't optimize on
    {
        hr = EnumerateInstances(pMethodContext);
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::ExecQueryType1
 *
 *  DESCRIPTION : Processes queries where we have a program group.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 ****************************************************************************/
HRESULT CW32ProgGrpW32Dir::ExecQueryType1(MethodContext* pMethodContext, CHString& chstrProgGroupNameIn)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Were given a programgroup.  Happens when hit associators on a programgroup.
    // Need the program group name extracted from the antecedent:
    CHString chstrProgGroupName(chstrProgGroupNameIn);
    chstrProgGroupName = chstrProgGroupName.Mid(chstrProgGroupName.Find(_T('=')) + 2);
    chstrProgGroupName = chstrProgGroupName.Left(chstrProgGroupName.GetLength() - 1);

    CHString chstrUserPart;
    CHString chstrPathPart;
    CHString chstrDirectory;
    CHString chstrProgGroupDir;
    CHString chstrQuery;
    chstrUserPart = chstrProgGroupName.SpanExcluding(L":");
    chstrPathPart = chstrProgGroupName.Mid(chstrUserPart.GetLength() + 1);  // already has escaped backslashes at this point
    RemoveDoubleBackslashes(chstrPathPart,chstrPathPart);

#ifdef NTONLY
    {
        TCHAR tstrProfilesDir[_MAX_PATH];
        ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
        CRegistry regProfilesDir;
        CHString chstrProfilesDirectory = L"";
        regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                       L"ProfilesDirectory",
                                                       chstrProfilesDirectory);

        // if that entry is not present, try %systemroot%\profiles instead
        if(chstrProfilesDirectory.GetLength() == 0)
        {
            chstrProfilesDirectory = L"%systemroot%\\Profiles";
        }

        if(chstrProfilesDirectory.GetLength() > 0)
        {
            // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
            // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
            DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,tstrProfilesDir,_MAX_PATH);
            if(dw != 0 && dw < _MAX_PATH)
            {
                if(chstrUserPart.CompareNoCase(IDS_Default_User)==0)
                {
                    chstrProgGroupDir.Format(L"%s\\%s\\", tstrProfilesDir, IDS_Default_User);
                    chstrDirectory = chstrProgGroupDir + chstrPathPart;
                    hr = AssociatePGToDirNT(pMethodContext, chstrDirectory, chstrProgGroupNameIn);
                }
                else if(chstrUserPart.CompareNoCase(IDS_All_Users)==0)
                {
                    chstrProgGroupDir.Format(L"%s\\%s\\", tstrProfilesDir, IDS_All_Users);
                    chstrDirectory = chstrProgGroupDir + chstrPathPart;
                    hr = AssociatePGToDirNT(pMethodContext, chstrDirectory, chstrProgGroupNameIn);
                }
                else
                {
                    CUserHive cuhUser;
                    TCHAR szKeyName[_MAX_PATH];
                    ZeroMemory(szKeyName,sizeof(szKeyName));
                    // chstrUserPart contains double backslashes; need singles for it to work, so...
                    if(cuhUser.Load(RemoveDoubleBackslashes(chstrUserPart), szKeyName, _MAX_PATH) == ERROR_SUCCESS)
		            {
                        try
                        {
                            CRegistry reg;
                            CHString chstrTemp;
                            CHString chstrProfileImagePath = L"ProfileImagePath";
                            CHString chstrProfileImagePathValue;
                            chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                            chstrTemp += szKeyName;
                            if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                            {
                                // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000". Expand it:
                                TCHAR tstrProfileImagePath[_MAX_PATH];
                                ZeroMemory(tstrProfileImagePath,sizeof(tstrProfileImagePath));
                                dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfileImagePath,_MAX_PATH);
                                if(dw != 0 && dw < _MAX_PATH)
                                {
                                    CHString chstrProgGroupDir;
                                    chstrProgGroupDir.Format(L"%s\\",
                                                             tstrProfileImagePath);
                                    // Create a directory name based on what the registry says it should be
                                    chstrDirectory = chstrProgGroupDir + chstrPathPart;
                                    hr = AssociatePGToDirNT(pMethodContext, chstrDirectory, chstrProgGroupNameIn);
                                }
                                reg.Close();
                            }  // could open registry key for profilelist
                        }
                        catch ( ... )
                        {
                            cuhUser.Unload(szKeyName);
                            throw ;
                        }

                        cuhUser.Unload(szKeyName);
                    }
                }
            } // expanded profiles directory successfully
        } // got profiles directory from registry
    }
#endif
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::ExecQueryType2
 *
 *  DESCRIPTION : Processes queries where we have a directory
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 ****************************************************************************/
HRESULT CW32ProgGrpW32Dir::ExecQueryType2(MethodContext* pMethodContext, CHString& chstrDependent)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // We were given a directory (happens when hit associators on a directory).
    // Need to find the corresponding programgroupitem and associate.
    CHString chstrModDependent(chstrDependent);

#ifdef NTONLY
    {
        CRegistry reg;
        BOOL fGotIt = FALSE;
        CHString chstrProfilesList = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
        if(reg.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
                                       chstrProfilesList,
                                       KEY_READ) == ERROR_SUCCESS)
        {
            CHString chstrSubKey;
            while(!fGotIt)
            {
                if(reg.GetCurrentSubKeyName(chstrSubKey) != ERROR_NO_MORE_ITEMS)
                {
                    CRegistry regUser;
                    CHString chstrUserSubKey;
                    chstrUserSubKey.Format(L"%s\\%s",(LPCWSTR)chstrProfilesList,(LPCWSTR)chstrSubKey);
                    if(regUser.Open(HKEY_LOCAL_MACHINE, chstrUserSubKey, KEY_READ) == ERROR_SUCCESS)
                    {
                        CHString chstrProfileImagePath;
                        if(regUser.GetCurrentKeyValue(L"ProfileImagePath", chstrProfileImagePath)
                                       == ERROR_SUCCESS)
                        {
                            WCHAR wstrProfilesDir[_MAX_PATH];
                            ZeroMemory(wstrProfilesDir,sizeof(wstrProfilesDir));
                            DWORD dw = ExpandEnvironmentStrings(chstrProfileImagePath,wstrProfilesDir,_MAX_PATH);
                            if(dw != 0 && dw < _MAX_PATH)
                            {
                                // Extract the directory pathname out of the dependent...
                                CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                                chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                                CHString chstrProfilesDirAdj;
                                EscapeBackslashes(CHString(wstrProfilesDir),chstrProfilesDirAdj);
                                chstrProfilesDirAdj += L"\\\\";
                                chstrProfilesDirAdj += IDS_Start_Menu;
                                CHString chstrDepPathNameUserPortion = chstrDepPathName.Left(chstrProfilesDirAdj.GetLength());
                                if(chstrDepPathNameUserPortion.CompareNoCase(chstrProfilesDirAdj) == 0)
                                {
                                    // This user profile matches that of the file we were given.  Don't need to continue while loop.
                                    fGotIt = TRUE;
                                    // Look up this user's account from the profile...
                                    CUserHive cuh;
                                    CHString chstrUserAccount;
                                    if(cuh.UserAccountFromProfile(regUser,chstrUserAccount) == ERROR_SUCCESS)
                                    {
                                        // Get the non-user portion out of the directory's pathname...
                                        CHString chstrDir = chstrDepPathName.Mid(chstrDepPathNameUserPortion.GetLength() + 2);
                                        // Assemble name of the logical program group...
                                        CHString chstrLPGName;
                                        EscapeBackslashes(chstrUserAccount, chstrUserAccount);
                                        chstrLPGName.Format(L"%s:%s",(LPCWSTR)chstrUserAccount, IDS_Start_Menu);
                                        if(chstrDir.GetLength() > 0)
                                        {
                                            chstrLPGName += L"\\\\";
                                            chstrLPGName += chstrDir;
                                        }

                                        // Construct a full PATH for the program group...
                                        CHString chstrLPGPATH;
                                        chstrLPGPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroup.Name=\"%s\"",
                                                             (LPCWSTR)GetLocalComputerName(),
                                                             IDS_CimWin32Namespace,
                                                             (LPCWSTR)chstrLPGName);

                                        // Can't just commit it here even though we have all the pieces, because
                                        // we never confirmed that such a directory exists.  We have only confirmed that
                                        // a directory matching the first pieces of the specified path exists.
                                        // Hence we call our friend...
                                        hr = AssociatePGToDirNT(pMethodContext, RemoveDoubleBackslashes(chstrDepPathName), chstrLPGPATH);
                                    }
                                }
                            }
                        }
                        regUser.Close();
                    }
                } // got subkey
                if(reg.NextSubKey() != ERROR_SUCCESS)
                {
                    break;
                }
            }
        }
        if(!fGotIt)
        {
            // Wasn't a match for any of the user hive entries, but could be default user or all users.
            CRegistry regProfilesDir;
            CHString chstrProfilesDirectory = L"";
            CHString chstrDefaultUserProfile;
            regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                           L"ProfilesDirectory",
                                           chstrProfilesDirectory);

            regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                           L"DefaultUserProfile",
                                           chstrDefaultUserProfile);
            if(chstrProfilesDirectory.GetLength() > 0)
            {
                // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
                // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
                WCHAR wstrProfilesDir[_MAX_PATH];
                ZeroMemory(wstrProfilesDir,sizeof(wstrProfilesDir));
                DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,wstrProfilesDir,_MAX_PATH);
                if((dw != 0) && (dw < _MAX_PATH) && (chstrDefaultUserProfile.GetLength() > 0))
                {
                    // First see if default user
                    CHString chstrTemp;
                    chstrTemp.Format(L"%s\\%s\\%s",wstrProfilesDir,(LPCWSTR)chstrDefaultUserProfile,IDS_Start_Menu);
                    // Extract the directory pathname out of the dependent...
                    CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                    chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                    EscapeBackslashes(chstrTemp,chstrTemp);
                    // Get the left lProfDirLen chars out of the file we were given...
                    CHString chstrProfDir = chstrDepPathName.Left(chstrTemp.GetLength());
                    // Get the directory portion out of the file's pathname...
                    CHString chstrDir = chstrDepPathName.Mid(chstrProfDir.GetLength() + 2);

                    if(chstrProfDir.CompareNoCase(chstrTemp)==0)
                    {
                        // it was the default user
                        fGotIt = TRUE;
                        // Construct a full PATH for the program group item...
                        CHString chstrLPGName;
                        chstrLPGName.Format(L"%s:%s", (LPCWSTR)chstrDefaultUserProfile, IDS_Start_Menu);
                        if(chstrDir.GetLength() > 0)
                        {
                            chstrLPGName += L"\\\\";
                            chstrLPGName += chstrDir;
                        }

                        CHString chstrLPGPATH;
                        chstrLPGPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroup.Name=\"%s\"",
                                             (LPCWSTR)GetLocalComputerName(),
                                             IDS_CimWin32Namespace,
                                             (LPCWSTR)chstrLPGName);

                        // Can't just commit it here even though we have all the pieces, because
                        // we never confirmed that such a directory exists.  We have only confirmed that
                        // a directory matching the first pieces of the specified path exists.
                        // Hence we call our friend...
                        // Need to remove the "Programs" dir for this path...
                        hr = AssociatePGToDirNT(pMethodContext, RemoveDoubleBackslashes(chstrDepPathName), chstrLPGPATH);
                    }
                    // Then see if it was All Users
                    if(!fGotIt)
                    {
                        CHString chstrAllUsersProfile;
                        regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                       L"AllUsersProfile",
                                                       chstrAllUsersProfile);
                        if(chstrAllUsersProfile.GetLength() > 0)
                        {
                            chstrTemp.Format(L"%s\\%s\\%s",wstrProfilesDir,(LPCWSTR)chstrAllUsersProfile,IDS_Start_Menu);
                            EscapeBackslashes(chstrTemp,chstrTemp);
                            chstrProfDir = chstrDepPathName.Left(chstrTemp.GetLength());
                            chstrDir = chstrDepPathName.Mid(chstrProfDir.GetLength() + 2);
                            if((chstrProfDir.CompareNoCase(chstrTemp)==0) && (chstrAllUsersProfile.GetLength() > 0))
                            {
                                // it was All Users
                                fGotIt = TRUE;
                                // Construct a full PATH for the program group item...
                                CHString chstrLPGName;
                                chstrLPGName.Format(L"%s:%s",chstrAllUsersProfile,IDS_Start_Menu);
                                if(chstrDir.GetLength() > 0)
                                {
                                    chstrLPGName += L"\\\\";
                                    chstrLPGName += chstrDir;
                                }
                            
                                //EscapeBackslashes(chstrLPGName,chstrTemp);
                                CHString chstrLPGPATH;
                                chstrLPGPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroup.Name=\"%s\"",
                                                     (LPCWSTR)GetLocalComputerName(),
                                                     IDS_CimWin32Namespace,
                                                     (LPCWSTR)chstrLPGName);

                                // Can't just commit it here even though we have all the pieces, because
                                // we never confirmed that such a directory exists.  We have only confirmed that
                                // a directory matching the first pieces of the specified path exists.
                                // Hence we call our friend...
                                hr = AssociatePGToDirNT(pMethodContext, RemoveDoubleBackslashes(chstrDepPathName), chstrLPGPATH);
                            }
                        }
                    }
                } // expanded env variables
            } //got profiles dir
        } // wasn't a userhive entry
    } // nt
#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpW32Dir::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
#ifdef NTONLY
        hr = EnumerateInstancesNT(pMethodContext);
#endif
    return hr;
}


#ifdef NTONLY
HRESULT CW32ProgGrpW32Dir::EnumerateInstancesNT(MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LProgGroups;

    // Obtain, from the registry, the directory where proifles are stored:
    TCHAR tstrProfilesDir[_MAX_PATH];
    ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
    CRegistry regProfilesDir;
    CHString chstrProfilesDirectory = L"";
    regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                   L"ProfilesDirectory",
                                                   chstrProfilesDirectory);
    // if that entry is not present, try %systemroot%\profiles instead
    if(chstrProfilesDirectory.GetLength() == 0)
    {
        chstrProfilesDirectory = L"%systemroot%\\Profiles";
    }

    if(chstrProfilesDirectory.GetLength() > 0)
    {
        // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
        // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
        DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,tstrProfilesDir,_MAX_PATH);
        if(dw != 0 && dw < _MAX_PATH)
        {
            // Get list of program groups
            if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(L"Win32_LogicalProgramGroup"),
                                                            &LProgGroups,
                                                            IDS_CimWin32Namespace,
                                                            pMethodContext)))
            {
                REFPTRCOLLECTION_POSITION pos;

                if(LProgGroups.BeginEnum(pos))
                {
                    CInstancePtr pProgGroup;
                    CHString chstrName;
                    CHString chstrProgGrpPath;
                    CHString chstrUserPart;
                    CHString chstrPathPart;
                    CHString chstrProgGroupDir;

                    // Walk through the proggroups
                    for (pProgGroup.Attach(LProgGroups.GetNext(pos));
                        SUCCEEDED(hr) && (pProgGroup != NULL) && SUCCEEDED(hr);
                        pProgGroup.Attach(LProgGroups.GetNext(pos)))
                    {
                        CHString chstrQueryPath;
                        CHString chstrQuery;

                        pProgGroup->GetCHString(IDS_Name, chstrName);     // looks like "Default User:Accessories\\Multimedia" for instance
                        pProgGroup->GetCHString(IDS___Path, chstrProgGrpPath); // goes back as 'Antecedent'
                        // On NT, under %systemdir%\\Profiles, various directories corresponding to users are
                        // listed.  Under each is Start Menu\\Programs, under which are the directories listed
                        // by Win32_LogicalProgramGroup.
                        chstrUserPart = chstrName.SpanExcluding(L":");
                        chstrPathPart = chstrName.Mid(chstrUserPart.GetLength() + 1);
                        if(chstrUserPart.CompareNoCase(IDS_Default_User)==0)
                        {
                            chstrProgGroupDir.Format(L"%s\\%s\\%s", tstrProfilesDir, IDS_Default_User, (LPCTSTR)chstrPathPart);
                            hr = AssociatePGToDirNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                        }
                        else if(chstrUserPart.CompareNoCase(IDS_All_Users)==0)
                        {
                            chstrProgGroupDir.Format(L"%s\\%s\\%s", tstrProfilesDir, IDS_All_Users, (LPCTSTR)chstrPathPart);
                            hr = AssociatePGToDirNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                        }
                        else // need to get the sid corresponding to that user to then look up ProfileImagePath under
                             // the registry key HKLM\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList
                        {
                            CUserHive cuhUser;
                            //CHString chstrKeyName;
                            TCHAR szKeyName[_MAX_PATH];
                            ZeroMemory(szKeyName,sizeof(szKeyName));
                            if(cuhUser.Load(chstrUserPart, szKeyName, _MAX_PATH) == ERROR_SUCCESS)
                            {
                                try
                                {
                                    CRegistry reg;
                                    CHString chstrTemp;
                                    CHString chstrProfileImagePath = L"ProfileImagePath";
                                    CHString chstrProfileImagePathValue;
                                    chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                                    chstrTemp += szKeyName;
                                    if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                                    {
                                        // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000". Expand it:
                                        TCHAR tstrProfileImagePath[_MAX_PATH];
                                        ZeroMemory(tstrProfileImagePath,sizeof(tstrProfileImagePath));
                                        dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfileImagePath,_MAX_PATH);
                                        if(dw != 0 && dw < _MAX_PATH)
                                        {
                                            CHString chstrProgGroupDir;
                                            chstrProgGroupDir.Format(L"%s\\%s",
                                                                     tstrProfileImagePath,
                                                                     (LPCTSTR)chstrPathPart);
                                            // Create a directory name based on what the registry says it should be
                                            hr = AssociatePGToDirNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                                        }
                                        reg.Close();
                                    }  // could open registry key for profilelist
                                }
                                catch ( ... )
                                {
                                    cuhUser.Unload(szKeyName);
                                    throw ;
                                }

                                cuhUser.Unload(szKeyName);
                            }  // if load worked; otherwise we skip that one
                        } // which user
                    } // while programgroups
                    LProgGroups.EndEnum();
                } // if BeginEnum of programgroup worked
            } // Got all instances of win32_logicalprogramgroup
        } // expanded environment strings contained in profiles directory
    } // Got profiles directory from registry
    return hr;
}
#endif

#ifdef NTONLY
HRESULT CW32ProgGrpW32Dir::AssociatePGToDirNT(MethodContext* pMethodContext,
                                              CHString& chstrDirectory,
                                              CHString& chstrProgGrpPATH)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrDirDrive;
    CHString chstrDirPath;
    CHString chstrDirName;
    CHString chstrDirExt;
    bool fRoot;

    // Break the directory into its constituent parts
    GetPathPieces(chstrDirectory, chstrDirDrive, chstrDirPath, chstrDirName, chstrDirExt);

    // Find out if we are looking for the root directory
    if(chstrDirPath==L"\\" && chstrDirName==L"" && chstrDirExt==L"")
    {
        fRoot = true;
        // If we are looking for the root, our call to EnumDirs presumes that we specify
        // that we are looking for the root directory with "" as the path, not "\\".
        // Therefore...
        chstrDirPath = L"";
    }
    else
    {
        fRoot = false;
    }

    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                    chstrDirDrive,  // drive letter and colon
                    chstrDirPath,   // use the given path
                    chstrDirName,   // filename
                    chstrDirExt,    // extension
                    false,          // no recursion desired
                    NULL,           // don't need the file system name
                    NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                    (void*)(LPCWSTR)chstrProgGrpPATH)); // use the extra parameter to pass in the path to the program group
    return hr;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  That class
 *                returns files or directories where this one should only
 *                return files, in response to queries, getobject commands,
 *                etc.  It is overridden here to return TRUE only if the file
 *                (the information for which is contained in the function
 *                arguement pstFindData) is of type file.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if a file or FALSE if a directory
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CW32ProgGrpW32Dir::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE);
    }
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpW32Dir::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherrited from CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the PartComponent and GroupComponent
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CW32ProgGrpW32Dir::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrDirName;
    CHString chstrDirPATH;

    // Get the dependent (the directory name) ready...
    chstrDirName.Format(L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
    EscapeBackslashes(chstrDirName, chstrDirName);
    chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_DIRECTORY,
                        (LPCWSTR)chstrDirName);

    pInstance->SetCHString(IDS_Dependent, chstrDirPATH);
    pInstance->SetWCHARSplat(IDS_Antecedent, (LPCWSTR)pvMoreData);

	return WBEM_S_NO_ERROR ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupitemdatafile.cpp ===
//=================================================================

//

// Win32ProgramGroupItemDataFile.cpp -- Win32_LogicalProgramGroupItem to CIM_DataFile

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/20/98    a-kevhu         Created
//
// Comment: Relationship between win32_logicalprogramgroupitem and contained cim_datafiles
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "userhive.h"

#include "Win32ProgramGroupItemDataFile.h"
#include "cimdatafile.h"
#include "shortcutfile.h"


// Property set declaration
//=========================
CW32ProgGrpItemDataFile MyW32ProgGrpItemDF(PROPSET_NAME_WIN32LOGICALPROGRAMGROUPITEM_CIMDATAFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::CW32ProgGrpItemDataFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32ProgGrpItemDataFile::CW32ProgGrpItemDataFile(LPCWSTR setName, LPCWSTR pszNamespace)
:CImplement_LogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::~CW32ProgGrpItemDataFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32ProgGrpItemDataFile::~CW32ProgGrpItemDataFile()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpItemDataFile::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrProgGroupItem;
    CHString chstrDataFile;
    HRESULT hr = WBEM_E_NOT_FOUND;
    CInstancePtr pProgGroupItem;
    CInstancePtr pDataFile;

    if(pInstance != NULL)
    {
        // Get the two paths
        pInstance->GetCHString(IDS_Antecedent, chstrProgGroupItem);
        pInstance->GetCHString(IDS_Dependent, chstrDataFile);

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrProgGroupItem, &pProgGroupItem, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDataFile, &pDataFile, pInstance->GetMethodContext())))
            {
                // Double check that the dependent instance really is a datafile (or derived) instance...
                CHString chstrClassName;
                if(pDataFile->GetCHString(IDS___Class, chstrClassName) &&
                    CWbemProviderGlue::IsDerivedFrom(L"CIM_LogicalFile", chstrClassName, pDataFile->GetMethodContext(), IDS_CimWin32Namespace))
                {
                    // Make sure the group is still a group that is registered (not just left over directory)
                    CHString chstrUserPart;
                    CHString chstrPathPart;
#ifdef NTONLY
                    {
                        CHString chstrProgGroupItemName;
                        pProgGroupItem->GetCHString(IDS_Name,chstrProgGroupItemName);
                        chstrUserPart = chstrProgGroupItemName.SpanExcluding(L":");
                        chstrPathPart = chstrProgGroupItemName.Mid(chstrUserPart.GetLength() + 1);
                        if(chstrUserPart.CompareNoCase(IDS_Default_User) == 0)
                        {
                            // Default user and All Users are not part of the user hive, they just are.
                            // Since we got this far, we know that the file exists in the specified location
                            // within the program group directory by virtue of the two GetInstanceByPath calls
                            // which would not have succeeded had the file not existed.  So all is well.
                            hr = WBEM_S_NO_ERROR;
                        }
                        else if(chstrUserPart.CompareNoCase(IDS_All_Users) == 0)
                        {
                            hr = WBEM_S_NO_ERROR;
                        }
                        else
                        {
                            CUserHive cuhUser;
                            TCHAR szKeyName[_MAX_PATH];
                            ZeroMemory(szKeyName,sizeof(szKeyName));
                            if (cuhUser.Load(chstrUserPart, szKeyName, _MAX_PATH) == ERROR_SUCCESS)
		                    {
                                try
                                {
                                    CRegistry reg;
                                    CHString chstrTemp;
                                    CHString chstrProfileImagePath = L"ProfileImagePath";
                                    CHString chstrProfileImagePathValue;
                                    chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                                    chstrTemp += szKeyName;
                                    if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                                    {
                                        // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000"
                                        // Need to expand out the environment variable.
                                        TCHAR tstrProfilesDir[_MAX_PATH];
                                        ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
                                        DWORD dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfilesDir,_MAX_PATH);
                                        if(dw != 0 && dw < _MAX_PATH)
                                        {
                                            CHString chstrProgGroupDir;
                                            chstrProgGroupDir.Format(L"%s\\",
                                                                     (LPCWSTR)tstrProfilesDir);
                                            // Create a directory name based on what the registry says it should be
                                            CHString chstrDirectoryName;
                                            chstrDirectoryName.Format(L"%s%s", (LPCWSTR)chstrProgGroupDir, (LPCWSTR)chstrPathPart);
                                            EscapeBackslashes(chstrDirectoryName,chstrDirectoryName);
                                            // If the directory name above is a portion of chstrDataFile, we are valid.
                                            chstrDataFile.MakeUpper();
                                            chstrDirectoryName.MakeUpper();
                                            if(chstrDataFile.Find(chstrDirectoryName) > -1)
                                            {
                                                // Everything seems to actually exist.
                                                hr = WBEM_S_NO_ERROR;
                                            }
                                        } // expanded environment variable
                                        reg.Close();
                                    }
                                }
                                catch ( ... )
                                {
                                    cuhUser.Unload(szKeyName);
                                    throw ;
                                }  // could open registry key for profilelist
                                cuhUser.Unload(szKeyName);
                            } // userhive loaded
                        } // else a user-hive user account
                    } // was nt
#endif
                }
            } //datafile instancebypath
        } //progroup instancebypath
    } // pinstance not null
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::ExecQuery
 *
 *  DESCRIPTION : Returns only the specific association asked for
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpItemDataFile::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/)
{
    // We optimize on two types of queries only: those in which the antecedent was specified only (the programgroupitem),
    // or those in which the dependent was specified only (the datafile).  All others result in an enumeration.

    HRESULT hr = WBEM_E_NOT_FOUND;

    CHStringArray achstrAntecedent;
    CHStringArray achstrDependent;
    DWORD dwAntecedents = 0;
    DWORD dwDependents = 0;

    pQuery.GetValuesForProp(IDS_Antecedent, achstrAntecedent);
    dwAntecedents = achstrAntecedent.GetSize();
    pQuery.GetValuesForProp(IDS_Dependent, achstrDependent);
    dwDependents = achstrDependent.GetSize();

    if(dwAntecedents == 1 && dwDependents == 0)
    {
        hr = ExecQueryType1(pMethodContext, achstrAntecedent[0]);
    }
    else if(dwDependents == 1 && dwAntecedents == 0)
    {
        hr = ExecQueryType2(pMethodContext, achstrDependent[0]);
    }
    else // type of query we don't optimize on
    {
        hr = EnumerateInstances(pMethodContext);
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::ExecQueryType1
 *
 *  DESCRIPTION : Processes queries where we have a program group item
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 ****************************************************************************/
HRESULT CW32ProgGrpItemDataFile::ExecQueryType1(MethodContext* pMethodContext, CHString& chstrProgGroupItemNameIn)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Were given a programgroupitem.  Happens when hit associators on a programgroupitem.
    // Need the program group name extracted from the antecedent:
    CHString chstrProgGroupItemName(chstrProgGroupItemNameIn);
    chstrProgGroupItemName = chstrProgGroupItemName.Mid(chstrProgGroupItemName.Find(_T('=')) + 2);
    chstrProgGroupItemName = chstrProgGroupItemName.Left(chstrProgGroupItemName.GetLength() - 1);

    CHString chstrUserPart;
    CHString chstrPathPart;
    CHString chstrDatafile;
    CHString chstrProgGroupDir;
    CHString chstrQuery;
    chstrUserPart = chstrProgGroupItemName.SpanExcluding(L":");
    chstrPathPart = chstrProgGroupItemName.Mid(chstrUserPart.GetLength() + 1);  // already has escaped backslashes at this point
    RemoveDoubleBackslashes(chstrPathPart,chstrPathPart);

#ifdef NTONLY
    {
        TCHAR tstrProfilesDir[_MAX_PATH];
        ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
        CRegistry regProfilesDir;
        CHString chstrProfilesDirectory = L"";
        regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                       L"ProfilesDirectory",
                                                       chstrProfilesDirectory);

        // if that entry is not present, try %systemroot%\profiles instead
        if(chstrProfilesDirectory.GetLength() == 0)
        {
            chstrProfilesDirectory = L"%systemroot%\\Profiles";
        }

        if(chstrProfilesDirectory.GetLength() > 0)
        {
            // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
            // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
            DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,tstrProfilesDir,_MAX_PATH);
            if(dw != 0 && dw < _MAX_PATH)
            {
                if(chstrUserPart.CompareNoCase(IDS_Default_User)==0)
                {
                    chstrProgGroupDir.Format(L"%s\\%s\\", tstrProfilesDir, IDS_Default_User);
                    chstrDatafile = chstrProgGroupDir + chstrPathPart;
                    hr = AssociatePGIToDFNT(pMethodContext, chstrDatafile, chstrProgGroupItemNameIn);
                }
                else if(chstrUserPart.CompareNoCase(IDS_All_Users)==0)
                {
                    chstrProgGroupDir.Format(L"%s\\%s\\", tstrProfilesDir, IDS_All_Users);
                    chstrDatafile = chstrProgGroupDir + chstrPathPart;
                    hr = AssociatePGIToDFNT(pMethodContext, chstrDatafile, chstrProgGroupItemNameIn);
                }
                else
                {
                    CUserHive cuhUser;
                    TCHAR szKeyName[_MAX_PATH];
                    ZeroMemory(szKeyName,sizeof(szKeyName));
                    // chstrUserPart contains double backslashes; need singles for it to work, so...
                    if(cuhUser.Load(RemoveDoubleBackslashes(chstrUserPart), szKeyName, _MAX_PATH) == ERROR_SUCCESS)
		            {
                        try
                        {
                            CRegistry reg;
                            CHString chstrTemp;
                            CHString chstrProfileImagePath = L"ProfileImagePath";
                            CHString chstrProfileImagePathValue;
                            chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                            chstrTemp += szKeyName;
                            if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                            {
                                // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000". Expand it:
                                TCHAR tstrProfileImagePath[_MAX_PATH];
                                ZeroMemory(tstrProfileImagePath,sizeof(tstrProfileImagePath));
                                dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfileImagePath,_MAX_PATH);
                                if(dw != 0 && dw < _MAX_PATH)
                                {
                                    CHString chstrProgGroupDir;
                                    chstrProgGroupDir.Format(L"%s\\",
                                                             tstrProfileImagePath);
                                    // Create a directory name based on what the registry says it should be
                                    chstrDatafile = chstrProgGroupDir + chstrPathPart;
                                    hr = AssociatePGIToDFNT(pMethodContext, chstrDatafile, chstrProgGroupItemNameIn);
                                }
                                reg.Close();
                            }
                        }
                        catch ( ... )
                        {
                            cuhUser.Unload(szKeyName);
                            throw;
                        }  // could open registry key for profilelist
                        cuhUser.Unload(szKeyName);
                    } // loaded user profile
                } // user part was...
            } // expanded profiles directory successfully
        } // got profiles directory from registry
    }
#endif
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::ExecQueryType2
 *
 *  DESCRIPTION : Processes queries where we have a datafile
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 ****************************************************************************/
HRESULT CW32ProgGrpItemDataFile::ExecQueryType2(MethodContext* pMethodContext, CHString& chstrDependent)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // We were given a datafile (happens when hit associators on a datafile).
    // Need to find the corresponding programgroupitem and associate.
    CHString chstrModDependent(RemoveDoubleBackslashes(chstrDependent));

#ifdef NTONLY
    {
        CRegistry reg;
        BOOL fGotIt = FALSE;
        CHString chstrProfilesList = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
        if(reg.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
                                       chstrProfilesList,
                                       KEY_READ) == ERROR_SUCCESS)
        {
            CHString chstrSubKey;
            while(!fGotIt)
            {
                if(reg.GetCurrentSubKeyName(chstrSubKey) != ERROR_NO_MORE_ITEMS)
                {
                    CRegistry regUser;
                    CHString chstrUserSubKey;
                    chstrUserSubKey.Format(L"%s\\%s",(LPCWSTR)chstrProfilesList,(LPCWSTR)chstrSubKey);
                    if(regUser.Open(HKEY_LOCAL_MACHINE, chstrUserSubKey, KEY_READ) == ERROR_SUCCESS)
                    {
                        CHString chstrProfileImagePath;
                        if(regUser.GetCurrentKeyValue(L"ProfileImagePath", chstrProfileImagePath)
                                       == ERROR_SUCCESS)
                        {
                            WCHAR wstrProfilesDir[_MAX_PATH];
                            ZeroMemory(wstrProfilesDir,sizeof(wstrProfilesDir));
                            DWORD dw = ExpandEnvironmentStrings(chstrProfileImagePath,wstrProfilesDir,_MAX_PATH);
                            if(dw != 0 && dw < _MAX_PATH)
                            {
                                // Extract the directory pathname out of the dependent...
                                CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                                chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                                CHString chstrDepPathNameUserPortion = chstrDepPathName.Left(wcslen(wstrProfilesDir));
                                if(chstrDepPathNameUserPortion.CompareNoCase(wstrProfilesDir) == 0)
                                {
                                    // This user profile matches that of the file we were given.  Don't need to continue while loop.
                                    fGotIt = TRUE;
                                    // Look up this user's account from the profile...
                                    CUserHive cuh;
                                    CHString chstrUserAccount;
                                    if(cuh.UserAccountFromProfile(regUser,chstrUserAccount) == ERROR_SUCCESS)
                                    {
                                        // Extract the datafile pathname portion out of the dependent...
                                        CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                                        chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);
                                        // Get the non-user portion out of the file's pathname...
                                        CHString chstrItem = chstrDepPathName.Mid(wcslen(wstrProfilesDir) + 1);
                                        // Assemble name of the logical program group item...
                                        CHString chstrLPGIName;
                                        chstrLPGIName.Format(L"%s:%s",(LPCWSTR)chstrUserAccount,IDS_Start_Menu);
                                        if(chstrItem.GetLength() > 0)
                                        {
                                            chstrLPGIName += L"\\";
                                            chstrLPGIName += chstrItem;
                                        }
                                        // Construct a full PATH for the program group item...
                                        CHString chstrTemp;
                                        EscapeBackslashes(chstrLPGIName,chstrTemp);

                                        CHString chstrLPGIPATH;
                                        chstrLPGIPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroupItem.Name=\"%s\"",
                                                             (LPCWSTR)GetLocalComputerName(),
                                                             IDS_CimWin32Namespace,
                                                             (LPCWSTR)chstrTemp);

                                          // Can't just commit it here even though we have all the pieces, because
                                          // we never confirmed that such a file exists.  We have only confirmed that
                                          // a directory matching the first pieces of the specified path exists.
                                          // Hence we call our friend...
                                          hr = AssociatePGIToDFNT(pMethodContext, chstrDepPathName, chstrLPGIPATH);
                                    }
                                }
                            }
                        }
                        regUser.Close();
                    }
                } // got subkey
                if(reg.NextSubKey() != ERROR_SUCCESS)
                {
                    break;
                }
            }
        }
        if(!fGotIt)
        {
            // Wasn't a match for any of the user hive entries, but could be default user or all users.
            CRegistry regProfilesDir;
            CHString chstrProfilesDirectory = L"";
            CHString chstrDefaultUserProfile;
            regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                           L"ProfilesDirectory",
                                           chstrProfilesDirectory);
            regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                           L"DefaultUserProfile",
                                           chstrDefaultUserProfile);
            if(chstrProfilesDirectory.GetLength() > 0)
            {
                // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
                // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
                WCHAR wstrProfilesDir[_MAX_PATH];
                ZeroMemory(wstrProfilesDir,sizeof(wstrProfilesDir));
                DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,wstrProfilesDir,_MAX_PATH);
                if(dw != 0 && dw < _MAX_PATH)
                {
                    // First see if default user
                    CHString chstrTemp;
                    chstrTemp.Format(L"%s\\%s\\%s",wstrProfilesDir,(LPCWSTR)chstrDefaultUserProfile,IDS_Start_Menu);
                    // Extract the file pathname out of the dependent...
                    CHString chstrDepPathName = chstrModDependent.Mid(chstrModDependent.Find(L"=") + 2);
                    chstrDepPathName = chstrDepPathName.Left(chstrDepPathName.GetLength() - 1);

                    // Get the left lProfDirLen chars out of the file we were given...
                    CHString chstrProfDF = chstrDepPathName.Left(chstrTemp.GetLength());
                    // Get the item portion out of the file's pathname...
                    CHString chstrItem = chstrDepPathName.Mid(chstrProfDF.GetLength() + 1);
                    if(chstrProfDF.CompareNoCase(chstrTemp)==0)
                    {
                        // it was the default user
                        fGotIt = TRUE;
                        // Construct a full PATH for the program group item...
                        CHString chstrLPGIName;
                        chstrLPGIName.Format(L"%s:%s", (LPCWSTR)chstrDefaultUserProfile, IDS_Start_Menu);
                        if(chstrItem.GetLength() > 0)
                        {
                            chstrLPGIName += L"\\";
                            chstrLPGIName += chstrItem;
                        }

                        EscapeBackslashes(chstrLPGIName,chstrTemp);
                        CHString chstrLPGIPATH;
                        chstrLPGIPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroupItem.Name=\"%s\"",
                                             (LPCWSTR)GetLocalComputerName(),
                                             IDS_CimWin32Namespace,
                                             (LPCWSTR)chstrTemp);

                        // Can't just commit it here even though we have all the pieces, because
                        // we never confirmed that such a file exists.  We have only confirmed that
                        // a directory matching the first pieces of the specified path exists.
                        // Hence we call our friend...
                        hr = AssociatePGIToDFNT(pMethodContext, chstrDepPathName, chstrLPGIPATH);

                    }
                    // Then see if it was All Users
                    if(!fGotIt)
                    {
                        CHString chstrAllUsersProfile;
                        regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                       L"AllUsersProfile",
                                                       chstrAllUsersProfile);
                        if(chstrAllUsersProfile.GetLength() > 0)
                        {
                            chstrTemp.Format(L"%s\\%s\\%s",wstrProfilesDir,(LPCWSTR)chstrAllUsersProfile,IDS_Start_Menu);
                            chstrProfDF = chstrDepPathName.Left(chstrTemp.GetLength());
                            chstrItem = chstrDepPathName.Mid(chstrProfDF.GetLength() + 1);
                            if(chstrProfDF.CompareNoCase(chstrTemp)==0)
                            {
                                // it was All Users
                                fGotIt = TRUE;
                                // Construct a full PATH for the program group item...
                                CHString chstrLPGIName;
                                chstrLPGIName.Format(L"%s::%s",wstrProfilesDir,(LPCWSTR)chstrAllUsersProfile);
                                if(chstrItem.GetLength() > 0)
                                {
                                    chstrLPGIName += L"\\\\";
                                    chstrLPGIName += chstrItem;
                                }

                                EscapeBackslashes(chstrLPGIName,chstrTemp);
                                CHString chstrLPGIPATH;
                                chstrLPGIPATH.Format(L"\\\\%s\\%s:Win32_LogicalProgramGroupItem.Name=\"%s\"",
                                                     (LPCWSTR)GetLocalComputerName(),
                                                     IDS_CimWin32Namespace,
                                                     (LPCWSTR)chstrTemp);

                                // Can't just commit it here even though we have all the pieces, because
                                // we never confirmed that such a file exists.  We have only confirmed that
                                // a directory matching the first pieces of the specified path exists.
                                // Hence we call our friend...
                                hr = AssociatePGIToDFNT(pMethodContext, chstrDepPathName, chstrLPGIPATH);
                            }
                        }
                    }
                } // expanded env variables
            } //got profiles dir
        } // wasn't a userhive entry
    } // nt
#endif

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32ProgGrpItemDataFile::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
#ifdef NTONLY
        hr = EnumerateInstancesNT(pMethodContext);
#endif
    return hr;
}


#ifdef NTONLY
HRESULT CW32ProgGrpItemDataFile::EnumerateInstancesNT(MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LProgGroupItems;

    // Obtain, from the registry, the directory where proifles are stored:
    TCHAR tstrProfilesDir[_MAX_PATH];
    ZeroMemory(tstrProfilesDir,sizeof(tstrProfilesDir));
    CRegistry regProfilesDir;
    CHString chstrProfilesDirectory = L"";
    regProfilesDir.OpenLocalMachineKeyAndReadValue(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                                   L"ProfilesDirectory",
                                                   chstrProfilesDirectory);
    // if that entry is not present, try %systemroot%\profiles instead
    if(chstrProfilesDirectory.GetLength() == 0)
    {
        chstrProfilesDirectory = L"%systemroot%\\Profiles";
    }

    if(chstrProfilesDirectory.GetLength() > 0)
    {
        // Need to transmorgrify the value in chstrProfilesDirectory from something like "%SystemRoot%\Profiles" or "%SystemDrive%\Documents and Settings" to
        // something like "c:\\winnt\\Profiles" or "c:\\Documents and Settings":
        DWORD dw = ExpandEnvironmentStrings(chstrProfilesDirectory,tstrProfilesDir,_MAX_PATH);
        if(dw != 0 && dw < _MAX_PATH)
        {
            // Get list of program groups
            if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(L"Win32_LogicalProgramGroupItem"),
                                                            &LProgGroupItems,
                                                            IDS_CimWin32Namespace,
                                                            pMethodContext)))
            {
                REFPTRCOLLECTION_POSITION pos;

                if(LProgGroupItems.BeginEnum(pos))
                {
                    CInstancePtr pProgGroupItem;
                    CHString chstrName;
                    CHString chstrProgGrpPath;
                    CHString chstrUserPart;
                    CHString chstrPathPart;
                    CHString chstrProgGroupDir;

                    // Walk through the proggroups
                    for (pProgGroupItem.Attach(LProgGroupItems.GetNext(pos));
                         SUCCEEDED(hr) && (pProgGroupItem != NULL);
                         pProgGroupItem.Attach(LProgGroupItems.GetNext(pos)))
                    {
                        if(pProgGroupItem != NULL)
                        {
                            CHString chstrQueryPath;
                            CHString chstrQuery;

                            pProgGroupItem->GetCHString(IDS_Name, chstrName);     // looks like "Default User:Accessories\\Multimedia" for instance
                            pProgGroupItem->GetCHString(IDS___Path, chstrProgGrpPath); // goes back as 'Antecedent'
                            // On NT, under %systemdir%\\Profiles, various directories corresponding to users are
                            // listed.  Under each is Start Menu\\Programs, under which are the directories listed
                            // by Win32_LogicalProgramGroup.
                            chstrUserPart = chstrName.SpanExcluding(L":");
                            chstrPathPart = chstrName.Mid(chstrUserPart.GetLength() + 1);
                            if(chstrUserPart.CompareNoCase(IDS_Default_User)==0)
                            {
                                chstrProgGroupDir.Format(L"%s\\%s\\%s", tstrProfilesDir, IDS_Default_User, (LPCTSTR)chstrPathPart);
                                hr = AssociatePGIToDFNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                            }
                            else if(chstrUserPart.CompareNoCase(IDS_All_Users)==0)
                            {
                                chstrProgGroupDir.Format(L"%s\\%s\\%s", tstrProfilesDir, IDS_All_Users, (LPCTSTR)chstrPathPart);
                                hr = AssociatePGIToDFNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                            }
                            else // need to get the sid corresponding to that user to then look up ProfileImagePath under
                                 // the registry key HKLM\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList
                            {
                                CUserHive cuhUser;
                                //CHString chstrKeyName;
                                TCHAR szKeyName[_MAX_PATH];
                                ZeroMemory(szKeyName,sizeof(szKeyName));
                                if(cuhUser.Load(chstrUserPart, szKeyName,_MAX_PATH) == ERROR_SUCCESS)
                                {
                                    try
                                    {
                                        CRegistry reg;
                                        CHString chstrTemp;
                                        CHString chstrProfileImagePath = L"ProfileImagePath";
                                        CHString chstrProfileImagePathValue;
                                        chstrTemp = L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\ProfileList\\";
                                        chstrTemp += szKeyName;
                                        if(reg.OpenLocalMachineKeyAndReadValue(chstrTemp,chstrProfileImagePath,chstrProfileImagePathValue) == ERROR_SUCCESS)
                                        {
                                            // Now chstrProfileImagePathValue contains something like "%systemroot%\\Profiles\\a-kevhu.000". Expand it:
                                            TCHAR tstrProfileImagePath[_MAX_PATH];
                                            ZeroMemory(tstrProfileImagePath,sizeof(tstrProfileImagePath));
                                            dw = ExpandEnvironmentStrings(chstrProfileImagePathValue,tstrProfileImagePath,_MAX_PATH);
                                            if(dw != 0 && dw < _MAX_PATH)
                                            {
                                                CHString chstrProgGroupDir;
                                                chstrProgGroupDir.Format(L"%s\\%s",
                                                                         tstrProfileImagePath,
                                                                         (LPCTSTR)chstrPathPart);
                                                // Create a directory name based on what the registry says it should be
                                                hr = AssociatePGIToDFNT(pMethodContext, chstrProgGroupDir, chstrProgGrpPath);
                                            }
                                            reg.Close();
                                        }
                                    }
                                    catch ( ... )
                                    {
                                        cuhUser.Unload(szKeyName);
                                        throw ;
                                    }  // could open registry key for profilelist
                                    cuhUser.Unload(szKeyName);
                                }  // if load worked; otherwise we skip that one
                            } // which user
                        } // pProgGroupItem != NULL
                    } // while programgroupitems
                    LProgGroupItems.EndEnum();
                } // if BeginEnum of programgroupitem worked
            } // Got all instances of win32_logicalprogramgroupitem
        } // expanded environment strings contained in profiles directory
    } // Got profiles directory from registry
    return hr;
}
#endif

#ifdef NTONLY
HRESULT CW32ProgGrpItemDataFile::AssociatePGIToDFNT(MethodContext* pMethodContext,
                                              CHString& chstrDF,
                                              CHString& chstrProgGrpItemPATH)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrDFDrive;
    CHString chstrDFPath;
    CHString chstrDFName;
    CHString chstrDFExt;
    bool fRoot;

    // Break the directory into its constituent parts
    GetPathPieces(chstrDF, chstrDFDrive, chstrDFPath, chstrDFName, chstrDFExt);

    // Find out if we are looking for the root directory
    if(chstrDFPath==L"\\" && chstrDFName==L"" && chstrDFExt==L"")
    {
        fRoot = true;
        // If we are looking for the root, our call to EnumDirs presumes that we specify
        // that we are looking for the root directory with "" as the path, not "\\".
        // Therefore...
        chstrDFPath = L"";
    }
    else
    {
        fRoot = false;
    }

    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                    chstrDFDrive,   // drive letter and colon
                    chstrDFPath,    // use the given path
                    chstrDFName,    // filename
                    chstrDFExt,     // extension
                    false,          // no recursion desired
                    NULL,           // don't need the file system name
                    NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                    (void*)(LPCWSTR)chstrProgGrpItemPATH)); // use the extra parameter to pass in the path to the program group
    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  That class
 *                returns files or directories where this one should only
 *                return files, in response to queries, getobject commands,
 *                etc.  It is overridden here to return TRUE only if the file
 *                (the information for which is contained in the function
 *                arguement pstFindData) is of type file.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if a file or FALSE if a directory
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CW32ProgGrpItemDataFile::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? FALSE : TRUE);
    }
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CW32ProgGrpItemDataFile::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherrited from CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the PartComponent and GroupComponent
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CW32ProgGrpItemDataFile::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrFileName;
    CHString chstrFilePATH;

    // Note: this routing will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    // Get the GroupComponent (the directory name) ready...
    chstrFileName.Format(L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
    EscapeBackslashes(chstrFileName, chstrFileName);
    chstrFilePATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_CIMDATAFILE,
                        (LPCWSTR)chstrFileName);

    pInstance->SetCHString(IDS_Dependent, chstrFilePATH);
    pInstance->SetWCHARSplat(IDS_Antecedent, (LPCWSTR)pvMoreData);

	return WBEM_S_NO_ERROR ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32programgroupwin32directory.h ===
//=================================================================

//

// Win32ProgramGroupWin32Directory.h -- Win32_LogicalProgramGroup to Win32_Directory

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between Win32_LogicalProgramGroup and Win32_Directory
//
//=================================================================

#ifndef _WIN32PROGRAMGROUPWIN32DIRECTORY_H_
#define _WIN32PROGRAMGROUPWIN32DIRECTORY_H_



// Property set identification
//============================
#define  PROPSET_NAME_WIN32LOGICALPROGRAMGROUP_WIN32DIRECTORY L"Win32_LogicalProgramGroupDirectory"

#include"implement_logicalfile.h"

class CW32ProgGrpW32Dir;

class CW32ProgGrpW32Dir : public CImplement_LogicalFile 
{
    public:
        // Constructor/destructor
        //=======================
        CW32ProgGrpW32Dir(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32ProgGrpW32Dir() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

    protected:
       
       // Overridable function inherrited from CImplement_LogicalFile

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual HRESULT LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

    private:
        HRESULT ExecQueryType1(MethodContext* pMethodContext, CHString& chstrProgGroupName);
        HRESULT ExecQueryType2(MethodContext* pMethodContext, CHString& chstrDirectory);

#ifdef NTONLY
        HRESULT EnumerateInstancesNT(MethodContext* pMethodContex);
        HRESULT AssociatePGToDirNT(MethodContext* pMethodContext,
                                   CHString& chstrDirectory,
                                   CHString& chstrProgGrpPATH);
#endif

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32scsicontrollerdevice.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32SCSIControllerDevice.h
//
//  Purpose: Relationship between Win32_SCSIController and CIM_LogicalDevice
//
//***************************************************************************

#ifndef _WIN32SCSICONTROLLERDEVICE_H_
#define _WIN32SCSICONTROLLERDEVICE_H_


#define SCSICTL_PROP_ALL_PROPS                    0xFFFFFFFF
#define SCSICTL_PROP_ALL_PROPS_KEY_ONLY           0x00000003
#define SCSICTL_PROP_Antecedent                   0x00000001
#define SCSICTL_PROP_Dependent                    0x00000002



// Property set identification
//============================
#define PROPSET_NAME_WIN32SCSICONTROLLERDEVICE  L"Win32_SCSIControllerDevice"


typedef std::vector<CHString*> VECPCHSTR;

class CW32SCSICntrlDev : public CWin32_ScsiController, public CWin32PNPEntity
{
    public:

        // Constructor/destructor
        //=======================
        CW32SCSICntrlDev(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32SCSICntrlDev() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags = 0L); 
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);

    protected:

        // Functions inherrited from CW32SCSICntrlDev
        //====================================
#if NTONLY == 4
        HRESULT LoadPropertyValues(void* pvData);
#else
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);
#endif

    private:

        CHPtrArray m_ptrProperties;
        void CleanPCHSTRVec(VECPCHSTR& vec);
        HRESULT GenerateSCSIDeviceList(const CHString& chstrControllerPNPID, 
                                      VECPCHSTR& vec);
        HRESULT RecursiveFillDeviceBranch(CConfigMgrDevice* pRootDevice, 
                                          VECPCHSTR& vecSCSIDevices); 
        HRESULT ProcessSCSIDeviceList(MethodContext* pMethodContext, 
                                     const CHString& chstrControllerRELPATH, 
                                     VECPCHSTR& vecSCSIDevices,
                                     const DWORD dwReqProps);
        HRESULT CreateAssociation(MethodContext* pMethodContext,
                                  const CHString& chstrControllerPATH, 
                                  const CHString& chstrSCSIDevice,
                                  const DWORD dwReqProps);
        LONG FindInStringVector(const CHString& chstrSCSIDevicePNPID, 
                                VECPCHSTR& vecSCSIDevices);


};

// This derived class commits here, not in the base.
#if ( NTONLY >= 5 )	
inline bool CW32SCSICntrlDev::ShouldBaseCommit(void* pvData) { return false; }
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitydescriptor.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*******************************************************************
 *
 *    DESCRIPTION:	Win32SecurityDescriptor.H
 *
 *    AUTHOR:
 *
 *    HISTORY:    
 *
 *******************************************************************/

#ifndef __WIN32SECURITY_H_
#define __WIN32SECURITY_H_
#include "accessentry.h"
#include "SACL.h"
#include "DACL.h"
#include "win32ace.h"


#define  WIN32_SECURITY_DESCRIPTOR_NAME L"Win32_SecurityDescriptor" 

// provider provided for test provisions
class Win32SecurityDescriptor : public Provider
{
public:	
	Win32SecurityDescriptor(const CHString &setName, LPCTSTR pszNameSpace);
	~Win32SecurityDescriptor();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

	void GetDescriptor ( CInstance* pInstance, 
							PSECURITY_DESCRIPTOR& pDescriptor,
							PSECURITY_DESCRIPTOR* pLocalSD = NULL);

	void SetDescriptor ( CInstance* pInstance, PSECURITY_DESCRIPTOR& pDescriptor, PSECURITY_INFORMATION& pSecurityInfo );

#ifdef NTONLY
	DWORD FillSACLFromInstance (CInstance* pInstance, CSACL& sacl, MethodContext* pMethodContext);

	DWORD FillDACLFromInstance (CInstance* pInstance, CDACL& dacl, MethodContext* pMethodContext);
#endif
	
	bool Win32SecurityDescriptor::GetArray(IWbemClassObject *piClassObject, const CHString& name,  VARIANT& v, VARTYPE eVariantType) const ;
	DWORD Win32SecurityDescriptor::FillSIDFromTrustee(CInstance *pTrustee, CSid& sid ) ;

	DWORD SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR psd,
                             SECURITY_DESCRIPTOR_CONTROL wControlMask,
                             SECURITY_DESCRIPTOR_CONTROL wControlBits);

#ifdef NTONLY
	HRESULT FillInstanceSACLFromSDSACL (CInstance* pInstance, CSACL& sacl);

	HRESULT FillInstanceDACLFromSDDACL (CInstance* pInstance, CDACL& dacl);
#endif

	void FillTrusteeFromSID (CInstance* pTrustee, CSid& Sid);

protected:

	DWORD	m_dwPlatformID;
	
private:

};

//
/*extern "C" POLARITY*/ void GetDescriptorFromMySecurityDescriptor(
	CInstance* pInstance, PSECURITY_DESCRIPTOR *ppDescriptor);

extern "C" POLARITY 
void GetSDFromWin32SecurityDescriptor( IWbemClassObject* pObject, 
						PSECURITY_DESCRIPTOR *ppDescriptor);

extern "C" POLARITY 
void SetWin32SecurityDescriptorFromSD(	PSECURITY_DESCRIPTOR pDescriptor,
											PSECURITY_INFORMATION pInformation,
											bstr_t lpszPath,
											IWbemClassObject **ppObject);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitysettingoflogicalfile.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//	Win32SecuritySettingOfLogicalFile.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>
#include "sid.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "Win32SecuritySettingOfLogicalFile.h"
#include "securefile.h"
#include "file.h"
#include "Win32LogicalFileSecuritySetting.h"

typedef std::vector<_bstr_t> BSTRTVEC;

/*
    [Dynamic, Provider, dscription("")]
class Win32_SecuritySettingOfLogicalFile : Win32_SecuritySettingOfObject
{
    	[key]
    CIM_LogicalFile ref Element;

    	[key]
    Win32_LogicalFileSecuritySetting ref Setting;
};

*/

Win32SecuritySettingOfLogicalFile MyWin32SecuritySettingOfLogicalFile( WIN32_SECURITY_SETTING_OF_LOGICAL_FILE_NAME, IDS_CimWin32Namespace );

Win32SecuritySettingOfLogicalFile::Win32SecuritySettingOfLogicalFile ( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/ )
: CImplement_LogicalFile(setName, pszNameSpace)
{
}

Win32SecuritySettingOfLogicalFile::~Win32SecuritySettingOfLogicalFile ()
{
}

HRESULT Win32SecuritySettingOfLogicalFile::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We might have been asked for the security settings for a specific set of files,
    // in which case we don't have to ask for all the instances of cim_logicalfile, of
    // which there might be a few.
    BSTRTVEC vectorElements;
    BSTRTVEC vectorSettings;
    pQuery.GetValuesForProp(IDS_Element, vectorElements);
    pQuery.GetValuesForProp(IDS_Setting, vectorSettings);
    DWORD dwElements = vectorElements.size();
    DWORD dwSettings = vectorSettings.size();
    // TYPE 1
    if(dwElements != 0 && dwSettings == 0)
    {
        // We have a list of the files the user is interested in.  Run through each:
        CHString chstrFileFullPathName;
        for(LONG m = 0L; m < dwElements; m++)
        {
            CHString chstrElement((WCHAR*)vectorElements[m]);

            chstrFileFullPathName = chstrElement.Mid(chstrElement.Find(_T('='))+2);
            chstrFileFullPathName = chstrFileFullPathName.Left(chstrFileFullPathName.GetLength() - 1);
            CHString chstrLFSSPATH;
            chstrLFSSPATH.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                     (LPCTSTR)GetLocalComputerName(),
                                     IDS_CimWin32Namespace,
                                     (LPCTSTR)chstrFileFullPathName);
            AssociateLFSSToLFNT(pMethodContext, chstrElement, chstrLFSSPATH, 1);

        }
    }
    // TYPE 2
    else if(dwSettings != 0 && dwElements == 0)
    {
        // We have a list of the LogicalFileSecuritySettings the user is interested in.  Run through each:
        CHString chstrFileFullPathName;
        for(LONG m = 0L; m < dwSettings; m++)
        {
            CHString chstrSetting((WCHAR*)vectorSettings[m]);;

            chstrFileFullPathName = chstrSetting.Mid(chstrSetting.Find(_T('='))+2);
            chstrFileFullPathName = chstrFileFullPathName.Left(chstrFileFullPathName.GetLength() - 1);
            CHString chstrLFSSPATH;
            chstrLFSSPATH.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                     (LPCTSTR)GetLocalComputerName(),
                                     IDS_CimWin32Namespace,
                                     (LPCTSTR)chstrFileFullPathName);
            AssociateLFSSToLFNT(pMethodContext, chstrSetting, chstrLFSSPATH, 2);
        }
    }
    else
    {
        EnumerateInstances(pMethodContext,lFlags);
    }
    return hr;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	Win32SecuritySettingOfLogicalFile::EnumerateInstances
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
HRESULT Win32SecuritySettingOfLogicalFile::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR;

			// let the callback do the real work
	if (SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstancesAsynch(L"CIM_LogicalFile", this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, NULL)))
	{

	}

	return(hr);

}

/*****************************************************************************
 *
 *  FUNCTION    : Win32SecuritySettingOfLogicalFile::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32SecuritySettingOfLogicalFile::EnumerationCallback(CInstance* pFile, MethodContext* pMethodContext, void* pUserData)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// Start pumping out the instances
    CInstancePtr pInstance;
    pInstance.Attach(CreateNewInstance(pMethodContext));
	if (NULL != pInstance)
	{
	    CHString chsNamePath;
	    CHString chsName;
		CHString chsFileName;
	    CHString chsFilePath;
	    CHString chsFileSecurityPath;

	    // take the file and make a path for the CIM_LogicalFIle part of the instance
	    pFile->GetCHString(L"__RELPATH", chsNamePath);
	    pFile->GetCHString(IDS_Name, chsName);
	    chsFilePath.Format(L"\\\\%s\\%s:%s", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, (LPCTSTR)chsNamePath);

	    // now, build a path for the LogicalFileSecuritySetting
		// but first, escape the chsName with backslashes
		int nLength;
		nLength = chsName.GetLength();
		for (int i = 0; i<nLength; i++)
		{
			chsFileName += chsName[i];
			if (chsName[i] == L'\\')
			{
				chsFileName += L"\\";
			}
		}

	    chsFileSecurityPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, L"Win32_LogicalFileSecuritySetting", IDS_Path, (LPCTSTR)chsFileName);

	    //  now set the elements of the actual instance
	    pInstance->SetCHString(IDS_Element, chsFilePath);
	    pInstance->SetCHString(IDS_Setting, chsFileSecurityPath);
	    hr = pInstance->Commit();
	}	// end if
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32SecuritySettingOfLogicalFile::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT WINAPI Win32SecuritySettingOfLogicalFile::StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData)
{
	Win32SecuritySettingOfLogicalFile* pThis;
	HRESULT hr;

	pThis = dynamic_cast<Win32SecuritySettingOfLogicalFile *>(pThat);
	ASSERT_BREAK(pThis != NULL);

	if (pThis)
	{
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
	}
	else
	{
    	hr = WBEM_E_FAILED;
	}
	return hr;
}


HRESULT Win32SecuritySettingOfLogicalFile::GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	if (pInstance)
	{
		CHString chsFilePath;
        CHString chstrTemp;
        CHString chstrElement;
        CHString chstrElementPathname;
        CHString chstrSetting;
        CHString chstrSettingPathname;
		pInstance->GetCHString(IDS_Element, chstrElement);
        pInstance->GetCHString(IDS_Setting, chstrSetting);

        // Get the file pathname portion from each:
        chstrElementPathname = chstrElement.Mid(chstrElement.Find(_T('='))+2);
        chstrElementPathname = chstrElementPathname.Left(chstrElementPathname.GetLength() - 1);
        chstrSettingPathname = chstrSetting.Mid(chstrSetting.Find(_T('='))+2);
        chstrSettingPathname = chstrSettingPathname.Left(chstrSettingPathname.GetLength() - 1);

        // they must be the same
        if(chstrElementPathname.CompareNoCase(chstrSettingPathname)==0)
        {
            // Now just confirm that the file exists and that we can get security from it:
            CHString chstrLFSSPATH;
            chstrLFSSPATH.Format(_T("\\\\%s\\%s:Win32_LogicalFileSecuritySetting.Path=\"%s\""),
                                     (LPCTSTR)GetLocalComputerName(),
                                     IDS_CimWin32Namespace,
                                     (LPCTSTR)chstrElementPathname);
            hr = AssociateLFSSToLFNT(pInstance->GetMethodContext(), chstrElement, chstrLFSSPATH, 1);
        }
    }
	return(hr);
}





#ifdef NTONLY
HRESULT Win32SecuritySettingOfLogicalFile::AssociateLFSSToLFNT(MethodContext* pMethodContext,
                                                               CHString& chstrLF,
                                                               CHString& chstrLFSSPATH,
                                                               short sQueryType)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrLFDrive;
    CHString chstrLFPath;
    CHString chstrLFName;
    CHString chstrLFExt;
    CHString chstrFullPathName;
    bool fRoot;

    // If we came from a TYPE 1 query (see above), the chstrLF arg will be a full
    // wbem path like \\1of1\root\cimv2:Win32_Directory.Name="x:\\temp" ; on the
    // other hand, if we came from a TYPE 2 query, chstrLF will  contain
    // \\1of1\root\cimv2:Win32_LogicalFileSecuritySetting.Name="x:\\temp" (which of
    // course isn't a logicalfile, but we just need the file name.

    // So to get the file name, extract it and remove the extra backslashes.
    chstrFullPathName = chstrLF.Mid(chstrLF.Find(_T('='))+2);
    chstrFullPathName = chstrFullPathName.Left(chstrFullPathName.GetLength() - 1);


    // Break the directory into its constituent parts
    GetPathPieces(RemoveDoubleBackslashes(chstrFullPathName), chstrLFDrive, chstrLFPath, chstrLFName, chstrLFExt);

    // Find out if we are looking for the root directory
    if(chstrLFPath==L"\\" && chstrLFName==L"" && chstrLFExt==L"")
    {
        fRoot = true;
        // If we are looking for the root, our call to EnumDirs presumes that we specify
        // that we are looking for the root directory with "" as the path, not "\\".
        // Therefore...
        chstrLFPath = L"";
    }
    else
    {
        fRoot = false;
    }

    // EnumDirsNT will call LoadPropertyValues in this class, and it needs the element and
    // setting entries, so populate here...
    ELSET elset;
    elset.pwstrElement = (LPCWSTR) chstrLF;
    elset.pwstrSetting = (LPCWSTR) chstrLFSSPATH;

    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                    chstrLFDrive,   // drive letter and colon
                    chstrLFPath,    // use the given path
                    chstrLFName,    // filename
                    chstrLFExt,     // extension
                    false,          // no recursion desired
                    NULL,           // don't need the file system name
                    NULL,           // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    fRoot,          // may or may not be the root (the root would be a VERY strange place for a program group, but ...)
                    (void*)&elset)); // use the extra parameter to pass in the path to the program group
    return hr;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : Win32SecuritySettingOfLogicalFile::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  Overridden here
 *                to return true only if we can get the security on the file,
 *                via the class CSecurFile.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE can get security info, FALSE otherwise.
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL Win32SecuritySettingOfLogicalFile::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    BOOL fRet = FALSE;
    if(wcslen(wstrFullPathName) < 2)
    {
        fRet = FALSE;
    }
    else
    {
        CSecureFile secFile;
        DWORD dwRet = secFile.SetFileName(wstrFullPathName, TRUE);
		if (ERROR_ACCESS_DENIED != dwRet)
		{
            fRet = TRUE;
		}	// end if
		else
		{
			fRet = FALSE;
		}
    }
    return fRet;
}
#endif



/*****************************************************************************
 *
 *  FUNCTION    : Win32SecuritySettingOfLogicalFile::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherrited from CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the Element and Setting
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT Win32SecuritySettingOfLogicalFile::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrFileName;
    CHString chstrFilePATH;

    // Note: this routine will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    PELSET pelset = (PELSET)pvMoreData;

    // It is possible (if we got here from a TYPE 2 query - see above), that the Element member of pelset
    // is actually the setting.  We need to convert one to the other.  So here is what we have and want:
    // Have:   \\1of1\\root\cimv2:Win32_LogicalFileSecuritySetting.Path="x:\\test"
    // Want:   \\1of1\\root\cimv2:CimLogicalFile.Name="x:\\test"
    CHString chstrElement;
    if(wcsstr(pelset->pwstrElement, WIN32_LOGICAL_FILE_SECURITY_SETTING))
    {
        // So it was from a TYPE 2, so need to convert.
        CHString chstrTmp2;
        CHString chstrTmp(pelset->pwstrElement);
        chstrTmp2 = chstrTmp.Mid(chstrTmp.Find(_T('='))+2);
        chstrTmp2 = chstrTmp2.Left(chstrTmp2.GetLength() - 1);
        chstrElement.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                            (LPCWSTR)GetLocalComputerName(),
                            IDS_CimWin32Namespace,
                            PROPSET_NAME_FILE,
                            (LPCWSTR)chstrTmp2);
    }
    else
    {
        chstrElement = pelset->pwstrElement;
    }
    pInstance->SetCHString(IDS_Element, chstrElement);
    pInstance->SetWCHARSplat(IDS_Setting, pelset->pwstrSetting);

	return WBEM_S_NO_ERROR ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitydescriptor.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*******************************************************************
 *
 *    DESCRIPTION:	Win32Security.CPP
 *
 *    AUTHOR:
 *
 *    HISTORY:
 *
 *******************************************************************/
#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureregkey.h"
#include "securefile.h"
//#include "logfilesec.h"
#include "win32ace.h"

// DON'T ADD ANY INCLUDES AFTER THIS POINT!
#undef POLARITY
#define POLARITY __declspec(dllexport)
#include "Win32securityDescriptor.h"


/*
	THIS IS THE SECURITY DESCRIUPTOR CLASS DECLARED IN THE MOF

	[abstract,
    description("Structural representation of a SECURITY_DESCRIPTOR")]
class Win32_SecurityDescriptor : Win32_MethodParameterClass
{
    Win32_Trustee Owner;

    Win32_Trustee Group;

    Win32_ACE DACL[];

    Win32_ACE SACL[];

    uint32 ControlFlags;
};
*/

POLARITY Win32SecurityDescriptor MySecurityDescriptor( WIN32_SECURITY_DESCRIPTOR_NAME, IDS_CimWin32Namespace );

Win32SecurityDescriptor::Win32SecurityDescriptor (const CHString& setName, LPCTSTR pszNameSpace)
: Provider (setName, pszNameSpace )
{
}

Win32SecurityDescriptor::~Win32SecurityDescriptor()
{
}



HRESULT Win32SecurityDescriptor::EnumerateInstances (MethodContext*  pMethodContext, long lFlags /* = 0L*/)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

HRESULT Win32SecurityDescriptor::GetObject ( CInstance* pInstance, long lFlags /* = 0L */ )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	return(hr);

}

void Win32SecurityDescriptor::GetDescriptor ( CInstance* pInstance,
											 PSECURITY_DESCRIPTOR& pDescriptor,
											 PSECURITY_DESCRIPTOR* pLocalSD)
{

 	// takes the Win32_SecurityDescriptor object that is passed in
	// converts it to a CSecurityDescriptor/CSecureFile object
	// and applies it the the CSecureFile
	pDescriptor = NULL ;
	CInstancePtr pTrusteeOwner;
	CInstancePtr pTrusteeGroup;
	SECURITY_DESCRIPTOR absoluteSD;
	InitializeSecurityDescriptor((PVOID)&absoluteSD, SECURITY_DESCRIPTOR_REVISION) ;

	PSECURITY_DESCRIPTOR pRelativeSD = NULL;
	DWORD dwLength = 0;
	bool bExists = false ;
	VARTYPE eType ;

	if (pInstance)
	{
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		// get the control flags
		SECURITY_DESCRIPTOR_CONTROL control;
        DWORD dwControlTemp;
		pInstance->GetDWORD(IDS_ControlFlags, dwControlTemp);
        control = (SECURITY_DESCRIPTOR_CONTROL)dwControlTemp;

		//SetSecurityDescriptorControl(&absoluteSD, control, control);

		CSid sidOwner ;
		// get the owner SID
		if( pInstance->GetStatus ( IDS_Owner , bExists , eType ) && bExists && eType != VT_NULL )
		{
 			if( pInstance->GetEmbeddedObject(IDS_Owner, &pTrusteeOwner, pMethodContext) && (pTrusteeOwner != NULL) )
			{
				// now, take the Win32_Trustee instance and get the SID out of it
				// convert it to a CSid, and apply to the SecureFile
				// get SID information out of the Trustee
				if( !FillSIDFromTrustee( pTrusteeOwner, sidOwner ) )
				{
					BOOL bOwnerDefaulted = ( control & SE_OWNER_DEFAULTED ) ? true : false ;

					//sid validity checked here as FillSIDFromTrustee returns success if null sid
					if ( sidOwner.IsValid() )
					{
						if( !SetSecurityDescriptorOwner( &absoluteSD, sidOwner.GetPSid(), bOwnerDefaulted ) )
						{
							return ;
						}
					}
				}
				else
				{
					return ;
				}
			}
			else
			{
				return ;
			}
		}

		CSid sidGroup ;
		// get the group SID
		if( pInstance->GetStatus ( IDS_Group , bExists , eType ) && bExists && eType != VT_NULL )
		{
			if( pInstance->GetEmbeddedObject( IDS_Group, &pTrusteeGroup, pMethodContext ) && (pTrusteeGroup != NULL))
			{
				// now, take the Win32_Trustee instance and get the SID out of it
				// get SID information out of the Trustee
				if( !FillSIDFromTrustee( pTrusteeGroup, sidGroup ) )
				{
					BOOL bGroupDefaulted = ( control & SE_GROUP_DEFAULTED ) ? true : false ;

					//sid validity checked here as FillSIDFromTrustee returns success if null sid
					if ( sidGroup.IsValid() )
					{
						if( !SetSecurityDescriptorGroup( &absoluteSD, sidGroup.GetPSid(), bGroupDefaulted ) )
						{
							return ;
						}
					}
				}
				else
				{
					return ;
				}
			}
			else
			{
				return ;
			}
		}

		// get the DACL
		CDACL dacl;
		PACL pDACL = NULL ;
		DWORD dwACLSize =0 ;

        if( FillDACLFromInstance( pInstance, dacl, pMethodContext ) == ERROR_SUCCESS )
		{
			if( dacl.CalculateDACLSize( &dwACLSize ) )
			{
				if( dwACLSize > sizeof(ACL) )
				{
                    pDACL = (PACL) malloc(dwACLSize) ;
					if (pDACL == NULL)
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;

                    }
					InitializeAcl(pDACL,dwACLSize,ACL_REVISION ) ;

					BOOL bDaclDefaulted = ( control & SE_DACL_DEFAULTED ) ? true : false ;
					if( dacl.FillDACL( pDACL ) == ERROR_SUCCESS )
					{
						if( !SetSecurityDescriptorDacl( &absoluteSD, TRUE, pDACL, bDaclDefaulted ) )
						{
							free(pDACL) ;
							return ;
						}
					}
					else
					{
						free(pDACL) ;
						return ;
					}
				}
		        else if(dwACLSize == 0)
		        {
                    pDACL = (PACL) malloc(sizeof(ACL)) ;
			    
					if (pDACL == NULL)
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
                    InitializeAcl(pDACL,sizeof(ACL),ACL_REVISION ) ;

			        BOOL bDaclDefaulted = ( control & SE_DACL_DEFAULTED ) ? true : false ;
			        if( dacl.FillDACL( pDACL ) == ERROR_SUCCESS )
			        {
				        if( !SetSecurityDescriptorDacl( &absoluteSD, TRUE, pDACL, bDaclDefaulted ) )
				        {
					        free(pDACL) ;
                            pDACL = NULL ;
					        return ;
				        }
			        }
			        else
			        {
				        free(pDACL) ;
                        pDACL = NULL ;
				        return ;
			        }
		        }
			}
		}

		// get the SACL
		CSACL sacl;
		PACL pSACL = NULL ;
		DWORD dwSACLSize =0 ;
		if( !FillSACLFromInstance( pInstance, sacl, pMethodContext ) )
		{
			if( sacl.CalculateSACLSize( &dwSACLSize ) )
			{
				if( dwSACLSize > sizeof(ACL) )
				{
                    pSACL = (PACL) malloc(dwSACLSize) ;
					if (pSACL == NULL)
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}

					InitializeAcl(pSACL,dwSACLSize,ACL_REVISION ) ;

					BOOL bSaclDefaulted = ( control & SE_SACL_DEFAULTED ) ? true : false ;
					if( sacl.FillSACL( pSACL ) == ERROR_SUCCESS )
					{
						if( SetSecurityDescriptorSacl( &absoluteSD, TRUE, pSACL, bSaclDefaulted ) )
						{
						}
						else
						{
							if(pDACL)
							{
								free(pDACL) ;
							}
							free(pSACL) ;
							return ;
						}
					}
					else
					{
						if(pDACL)
						{
							free(pDACL) ;
						}
						free(pSACL) ;
						return ;
					}
				}
			}
		}

		// allocate the selfrelative securitydescriptor based on sizes
		// from the absolute.

		// convert security descriptor to SelfRelative

		// get the size that the buffer has to be.
		// THIS CALL WILL ALWAYS FAIL
		MakeSelfRelativeSD(&absoluteSD, NULL, &dwLength);

	    pRelativeSD = (PSECURITY_DESCRIPTOR) malloc( dwLength );

		if (pRelativeSD == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		if (!MakeSelfRelativeSD(&absoluteSD, pRelativeSD, &dwLength))
		{
			free( pRelativeSD ) ;
			pRelativeSD = NULL ;
		}

		if(pDACL)
		{
			free(pDACL) ;
		}
		if(pSACL)
		{
			free(pSACL) ;
		}

		pDescriptor = pRelativeSD;

		// if the caller wants one allocated with LocalAlloc...
		if(pLocalSD)
		{
			// give him a copy.
            try
            {
			    *pLocalSD = LocalAlloc(LPTR, dwLength);

				if (*pLocalSD == NULL)
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

			    memcpy(*pLocalSD, pRelativeSD, dwLength);
            }
            catch(...)
            {
                if(*pLocalSD != NULL)
                {
                    LocalFree(*pLocalSD);
                    *pLocalSD = NULL;
                }
                throw;
            }
		}

	}
}

void Win32SecurityDescriptor::SetDescriptor ( CInstance* pInstance, PSECURITY_DESCRIPTOR& pDescriptor, PSECURITY_INFORMATION& pSecurityInfo )
{
	// the purpose of this function is to set the security stuff in the
	// instance so it matches what is in the security descriptor.
	if (pInstance && pDescriptor)
	{
		CSecureFile NullFile(NULL, pDescriptor);

//    Win32_Trustee Owner;
		CInstancePtr pTrusteeOwnerInstance;
		if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrusteeOwnerInstance, GetNamespace())))
		{
			CSid sidOwner;
			NullFile.GetOwner( sidOwner );
			FillTrusteeFromSID(pTrusteeOwnerInstance, sidOwner);
			pInstance->SetEmbeddedObject(L"Owner", *pTrusteeOwnerInstance);
		}	// end if

	//    Win32_Trustee Group;
		CInstancePtr pTrusteeGroupInstance;
		if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrusteeGroupInstance, GetNamespace())))
		{
			CSid sidGroup;
			NullFile.GetGroup( sidGroup );
			FillTrusteeFromSID(pTrusteeGroupInstance, sidGroup);
			pInstance->SetEmbeddedObject(L"Group", *pTrusteeGroupInstance);
		}	// end if

	//    Win32_ACE DACL[];
    	CDACL dacl;
		HRESULT hr;

		NullFile.GetDACL( dacl );
 		hr = FillInstanceDACLFromSDDACL(pInstance, dacl);

	//    Win32_ACE SACL[];
		CSACL sacl;
		NullFile.GetSACL( sacl );
 		hr = FillInstanceSACLFromSDSACL(pInstance, sacl);

	//    uint32 ControlFlags;
		SECURITY_DESCRIPTOR_CONTROL sdControl;
		NullFile.GetControl( &sdControl );

		pInstance->SetDWORD(L"ControlFlags", (DWORD)sdControl);
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32SecurityDescriptor::FillDACLFromInstance
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD Win32SecurityDescriptor::FillDACLFromInstance (CInstance* pInstance, CDACL& dacl, MethodContext* pMethodContext)
{
	IWbemClassObjectPtr piClassObject;
    piClassObject.Attach(pInstance->GetClassObjectInterface()) ;
	DWORD dwStatus = ERROR_SUCCESS ;

	if(piClassObject)
	{
		VARIANT vDacl ;
		if(GetArray(piClassObject,IDS_DACL, vDacl, VT_UNKNOWN|VT_ARRAY) )
		{

			if( vDacl.parray )
			{

				// walk DACL
				LONG lDimension = 1 ;
				LONG lLowerBound ;
				SafeArrayGetLBound ( vDacl.parray , lDimension , &lLowerBound ) ;
				LONG lUpperBound ;
				SafeArrayGetUBound ( vDacl.parray , lDimension , &lUpperBound ) ;

				for ( LONG lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex++ )
				{
					if( dwStatus != ERROR_SUCCESS )
					{
						break ;
					}
					IWbemClassObjectPtr pACEObject;
					SafeArrayGetElement ( vDacl.parray , &lIndex , &pACEObject ) ;
					// take out IWbemClassObject and cast it to a Win32_ACE object.
					if(pACEObject)
					{
						CInstance ACEInstance(pACEObject, pMethodContext);

						// create an AccessEntry object from the Win32_ACE object.

						bool bExists =false ;
						VARTYPE eType ;
						// get Win32_Trustee object from Win32_ACE ...& decipher the ACE
						if ( ACEInstance.GetStatus ( IDS_Trustee, bExists , eType ) && bExists && eType == VT_UNKNOWN )
						{

							CInstancePtr pTrustee;
							if ( ACEInstance.GetEmbeddedObject ( IDS_Trustee, &pTrustee, ACEInstance.GetMethodContext() ) )
							{

								CSid sid ;
								if(FillSIDFromTrustee(pTrustee, sid) == ERROR_SUCCESS)
								{

									DWORD dwAceType, dwAceFlags, dwAccessMask ;
									CHString chstrInhObjGuid;
                                    GUID *pguidInhObjGuid = NULL;
                                    CHString chstrObjGuid;
                                    GUID *pguidObjGuid = NULL;

									ACEInstance.GetDWORD(IDS_AceType, dwAceType);
									ACEInstance.GetDWORD(IDS_AceFlags, dwAceFlags);
									ACEInstance.GetDWORD(IDS_AccessMask, dwAccessMask);

									if(!(dwAceFlags & INHERITED_ACE))
                                    {
                                        switch (dwAceType)
									    {
									    case ACCESS_DENIED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_DENIED_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
											    break;
										    }
									    case ACCESS_ALLOWED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
											    break;
										    }
#if NTONLY >= 5
                                        // Not yet supported on W2K
                                        //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
										//    {
										//	    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
										//	    break;
										//    }
                                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                                ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid);
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidObjGuid;
											    break;
										    }
                                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                                ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid);
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidObjGuid;
											    break;
										    }
#endif
									    default:
										    {
											    dwStatus = ERROR_INVALID_PARAMETER ;
											    break ;
										    }
									    }
                                    }
                                    else
                                    {
                                        switch (dwAceType)
									    {
									    case ACCESS_DENIED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_DENIED_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
											    break;
										    }
									    case ACCESS_ALLOWED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
											    break;
										    }
#if NTONLY >= 5
                                        // Not yet supported on W2K
                                        //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
										//    {
										//	    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
										//	    break;
										//    }
                                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                                ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidObjGuid;
											    break;
										    }
                                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                                ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidObjGuid;
											    break;
										    }
#endif
									    default:
										    {
											    dwStatus = ERROR_INVALID_PARAMETER ;
											    break ;
										    }
									    }

                                    }
								}
                                pTrustee->Release();
                                pTrustee = NULL;
							}

						}  // get Win32_Trustee object from Win32_ACE ...& decipher the ACE

					}

				}
			}

			VariantClear( &vDacl ) ;
		}
		else
		{
			dwStatus = ERROR_INVALID_PARAMETER ;
		}

	}

	return dwStatus ;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	Win32SecurityDescriptor::FillSACLFromInstance
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD Win32SecurityDescriptor::FillSACLFromInstance (CInstance* pInstance, CSACL& sacl, MethodContext* pMethodContext)
{
	IWbemClassObjectPtr piClassObject;
    piClassObject.Attach(pInstance->GetClassObjectInterface()) ;
	DWORD dwStatus = ERROR_SUCCESS ;

	if(piClassObject)
	{
		VARIANT vSacl ;
		if(GetArray(piClassObject, IDS_SACL, vSacl, VT_UNKNOWN|VT_ARRAY ) )
		{

			if( vSacl.parray )
			{

				// walk DACL
				LONG lDimension = 1 ;
				LONG lLowerBound ;
				SafeArrayGetLBound ( vSacl.parray , lDimension , &lLowerBound ) ;
				LONG lUpperBound ;
				SafeArrayGetUBound ( vSacl.parray , lDimension , &lUpperBound ) ;

				for ( LONG lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex++ )
				{
					if( dwStatus != ERROR_SUCCESS )
					{
						break ;
					}
					IWbemClassObjectPtr pACEObject;
					SafeArrayGetElement ( vSacl.parray , &lIndex , &pACEObject ) ;
					// take out IWbemClassObject and cast it to a Win32_ACE object.
					if(pACEObject)
					{
						CInstance ACEInstance(pACEObject, pMethodContext);

						// create an AccessEntry object from the Win32_ACE object.

						bool bExists =false ;
						VARTYPE eType ;
						// get Win32_Trustee object from Win32_ACE ...& decipher the ACE
						if ( ACEInstance.GetStatus ( IDS_Trustee, bExists , eType ) && bExists && eType == VT_UNKNOWN )
						{

							CInstancePtr pTrustee;
							if ( ACEInstance.GetEmbeddedObject ( IDS_Trustee, &pTrustee, ACEInstance.GetMethodContext() ) )
							{

								CSid sid ;
								if(FillSIDFromTrustee(pTrustee, sid) == ERROR_SUCCESS)
								{

									DWORD dwAceType, dwAceFlags, dwAccessMask ;
									CHString chstrInhObjGuid;
                                    GUID *pguidInhObjGuid = NULL;
                                    CHString chstrObjGuid;
                                    GUID *pguidObjGuid = NULL;

									ACEInstance.GetDWORD(IDS_AceType, dwAceType);
									ACEInstance.GetDWORD(IDS_AceFlags, dwAceFlags);
									ACEInstance.GetDWORD(IDS_AccessMask, dwAccessMask);

                                    switch(dwAceType)
									{
                                    case SYSTEM_AUDIT_ACE_TYPE:
									    {
										    sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_AUDIT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            break;
									    }
#if NTONLY >= 5
                                    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
									    {
										    // Need to get the guids for this type...
                                            ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                            if(chstrObjGuid.GetLength() != 0)
                                            {
                                                try
                                                {
                                                    pguidObjGuid = new GUID;
                                                }
                                                catch(...)
                                                {
                                                    if(pguidObjGuid != NULL)
                                                    {
                                                        delete pguidObjGuid;
                                                        pguidObjGuid = NULL;
                                                    }
                                                }
                                                CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                            }
                                            ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                            if(chstrInhObjGuid.GetLength() != 0)
                                            {
                                                try
                                                {
                                                    pguidInhObjGuid = new GUID;
                                                }
                                                catch(...)
                                                {
                                                    if(pguidInhObjGuid != NULL)
                                                    {
                                                        delete pguidInhObjGuid;
                                                        pguidInhObjGuid = NULL;
                                                    }
                                                }
                                                CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                            }
                                            sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_AUDIT_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            if(pguidObjGuid != NULL) delete pguidObjGuid;
                                            if(pguidInhObjGuid != NULL) delete pguidObjGuid;
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************
                                    case SYSTEM_ALARM_ACE_TYPE:
									    {
										    sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_ALARM_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************/

/********************************* type not yet supported under w2k ********************************************
                                    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
									    {
										    // Need to get the guids for this type...
                                            ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid);
                                            if(chstrObjGuid.GetLength() != 0)
                                            {
                                                try
                                                {
                                                    pguidObjGuid = new GUID;
                                                }
                                                catch(...)
                                                {
                                                    if(pguidObjGuid != NULL)
                                                    {
                                                        delete pguidObjGuid;
                                                        pguidObjGuid = NULL;
                                                    }
                                                }
                                                CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                            }
                                            ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid);
                                            if(chstrInhObjGuid.GetLength() != 0)
                                            {
                                                try
                                                {
                                                    pguidInhObjGuid = new GUID;
                                                }
                                                catch(...)
                                                {
                                                    if(pguidInhObjGuid != NULL)
                                                    {
                                                        delete pguidInhObjGuid;
                                                        pguidInhObjGuid = NULL;
                                                    }
                                                }
                                                CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                            }
                                            sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_ALARM_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            if(pguidObjGuid != NULL) delete pguidObjGuid;
                                            if(pguidInhObjGuid != NULL) delete pguidObjGuid;
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************/

#endif
									default:
									    {
										    dwStatus = ERROR_INVALID_PARAMETER ;
                                            break;
									    }
                                    }
								}
                                pTrustee->Release();
                                pTrustee = NULL;
							}

						}  // get Win32_Trustee object from Win32_ACE ...& decipher the ACE

					} //if(pACEObject)

				} //for
			}	//if(pSACL)

			VariantClear( &vSacl ) ;
		}
		else
		{
			dwStatus = ERROR_INVALID_PARAMETER ;
		}

	}

	return dwStatus ;
}

bool Win32SecurityDescriptor::GetArray(IWbemClassObject *piClassObject, const CHString& name,  VARIANT& v, VARTYPE eVariantType) const
{
	bool bRet = FALSE;
	VariantInit(&v);

	if (piClassObject)
	{
		BSTR pName = NULL;
		try
        {
            pName = name.AllocSysString();

		    HRESULT hr;
		    hr = piClassObject->Get(pName, 0, &v, NULL, NULL);
		    ASSERT_BREAK((SUCCEEDED(hr)) && ((v.vt == VT_NULL) || (v.vt == eVariantType )));

		    if (bRet = (bool)SUCCEEDED(hr))
		    {
			    if ( v.vt != VT_NULL && v.parray != NULL )
			    {
                    if (v.vt == eVariantType )
                    {
					    bRet = TRUE ;
                    }
                    else
                    {
                        bRet = FALSE;
                    }
			    }
                else
			    {
				    bRet = FALSE;
			    }
		    }
        }
        catch(...)
        {
            if(pName != NULL)
            {
                SysFreeString(pName);
                pName = NULL;
            }
            throw;
        }

       if(pName != NULL)
       {
            SysFreeString(pName);
            pName = NULL;
       }
	}


	if (!bRet)
	{
		VariantClear(&v);
	}

	return bRet;
}


DWORD Win32SecurityDescriptor::FillSIDFromTrustee(CInstance *pTrustee, CSid& sid )
{

	IWbemClassObjectPtr m_piClassObject;
    m_piClassObject.Attach(pTrustee->GetClassObjectInterface());

	VARIANT vtmp ;
	DWORD dwStatus = ERROR_SUCCESS ;

	if(GetArray(m_piClassObject,IDS_SID,  vtmp, VT_UI1|VT_ARRAY ) )
	{

		if( vtmp.parray )
		{

			if ( SafeArrayGetDim ( vtmp.parray ) == 1 )
			{
				long lLowerBound , lUpperBound = 0 ;

				SafeArrayGetLBound ( vtmp.parray, 1, & lLowerBound ) ;
				SafeArrayGetUBound ( vtmp.parray, 1, & lUpperBound ) ;

				PSID pSid = NULL ;
				PVOID pTmp = NULL ;
				if(SUCCEEDED(SafeArrayAccessData(vtmp.parray, &pTmp) ) )
				{
					pSid = (PSID) malloc(lUpperBound - lLowerBound + 1) ;

					if (pSid == NULL)
					{
						SafeArrayUnaccessData(vtmp.parray) ;
						VariantClear( &vtmp ) ;
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}

					memcpy(pSid,pTmp,lUpperBound - lLowerBound + 1) ;
					SafeArrayUnaccessData(vtmp.parray) ;

					try
					{
						sid = CSid(pSid);
							//free(pSid) ;
					}
					catch (...)
					{
						if(pSid != NULL)
						{
							free(pSid);
							pSid = NULL;
						}

						VariantClear( &vtmp ) ;
						throw;
					}

					if(pSid != NULL)
                    {
                        free(pSid);
                        pSid = NULL;
                    }
				}
				else
				{
					dwStatus = ERROR_INVALID_PARAMETER ;
				}
			}
			else
			{
				dwStatus = ERROR_INVALID_PARAMETER ;
			}
		}
		VariantClear( &vtmp ) ;
	}
	else
	{
		dwStatus = ERROR_INVALID_PARAMETER ;
	}


	return dwStatus ;
}


void Win32SecurityDescriptor::FillTrusteeFromSID (CInstance* pTrustee, CSid& Sid)
{
	if (pTrustee)
	{
		PSID pSid = NULL;
		pSid = Sid.GetPSid();

		// get account name
		CHString chsAccount = Sid.GetAccountName();
		pTrustee->SetCHString(IDS_Name, chsAccount);

		// set the UINT8 array for the pSid
		DWORD dwSidLength = Sid.GetLength();
		SAFEARRAY* sa;
		SAFEARRAYBOUND rgsabound[1];
		VARIANT vValue;
		VariantInit(&vValue);

		rgsabound[0].cElements = dwSidLength;

		PSID pSidTrustee = NULL ;

		rgsabound[0].lLbound = 0;
		sa = SafeArrayCreate(VT_UI1, 1, rgsabound);

        if ( V_ARRAY ( &vValue ) == NULL )
		{
			if (pSid != NULL)
            {
                FreeSid(pSid);
            }
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		     // Get a pointer to read the data into
  		SafeArrayAccessData(sa, &pSidTrustee);
  		memcpy(pSidTrustee, pSid, rgsabound[0].cElements);
  		SafeArrayUnaccessData(sa);

		// Put the safearray into a variant, and send it off
		V_VT(&vValue) = VT_UI1 | VT_ARRAY; V_ARRAY(&vValue) = sa;
		pTrustee->SetVariant(L"SID", vValue);

		VariantClear(&vValue);

		FreeSid(pSid);

        pTrustee->SetDWORD(IDS_SidLength, dwSidLength);

        // Fill in the SIDString property...
        pTrustee->SetCHString(IDS_SIDString, Sid.GetSidString());
	}
}

HRESULT Win32SecurityDescriptor::FillInstanceDACLFromSDDACL (CInstance* pInstance, CDACL& dacl)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	SAFEARRAY* saDACL = NULL;
	SAFEARRAYBOUND rgsabound[1];

    // Need merged list..
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
	    DWORD dwLength = t_ael.NumEntries();
	    rgsabound[0].cElements = dwLength;
	    rgsabound[0].lLbound = 0;

	    saDACL = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		if ( NULL == saDACL )
		{
			hr = WBEM_E_OUT_OF_MEMORY ;
		}
		else
		{
			// walk DACL looking for the sid path passed in....
			ACLPOSITION aclPos;
			t_ael.BeginEnum(aclPos);
			CAccessEntry ACE;
			CInstancePtr pACEInstance;
			long ix[1];
			ix[0] = 0;

			while (t_ael.GetNext(aclPos, ACE ))
			{
				// take the AccessEntry and turn it into a Win32_ACE instance
				hr = CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_ACE", &pACEInstance, GetNamespace());
				if (SUCCEEDED(hr))
				{
					CSid TrusteeSid;
					PSID pSID = NULL;
					//Win32_Trustee Trustee;
					ACE.GetSID( TrusteeSid );

					CInstancePtr pTrusteeInstance;
					if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrusteeInstance, GetNamespace())))
					{
						FillTrusteeFromSID(pTrusteeInstance, TrusteeSid);
						pACEInstance->SetEmbeddedObject(L"Trustee", *pTrusteeInstance);
					}	// end if
					else
					{
						LogMessage(L"FillInstanceDACL - Failed to get an empty Win32_Trustee object");
						hr = WBEM_E_FAILED;
					}

					DWORD dwAccessMask = ACE.GetAccessMask();
					pACEInstance->SetDWORD(L"AccessMask", dwAccessMask);

					DWORD dwAceType = ACE.GetACEType( );
					pACEInstance->SetDWORD(L"AceType", dwAceType);

					DWORD dwAceFlags = ACE.GetACEFlags( );
					pACEInstance->SetDWORD(L"AceFlags", dwAceFlags);

					//string GuidObjectType;	-- NT 5 only

					//string GuidInheritedObjectType;	-- NT 5 only

					// Get the IUnknown of the Win32_ACE object.   Convert it to a
					// variant of type VT_UNKNOWN.  Then, add the variant to the
					// SafeArray.   Eventually, to add the list to the actual
					// Win32_SecurityDescriptor object, we will be using SetVariant
					IWbemClassObjectPtr pClassObject;
					pClassObject.Attach(pACEInstance->GetClassObjectInterface());
					if ( pClassObject != NULL )
					{

						VARIANT v;
						VariantInit(&v);

						v.vt   = VT_UNKNOWN;
						v.punkVal = pClassObject ;


						SafeArrayPutElement(saDACL, ix, pClassObject);

						VariantClear(&v);
					}	// end if

				}
				else
				{
					hr = WBEM_E_FAILED;
				}
			}	// end while loop

			t_ael.EndEnum(aclPos);
		}
    }

	if ( saDACL )
	{
		// now, set the DACL property in the Instance passed in.
		pInstance->SetStringArray(L"DACL", *saDACL);
	}

	return(hr);
}

HRESULT Win32SecurityDescriptor::FillInstanceSACLFromSDSACL (CInstance* pInstance, CSACL& sacl)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	SAFEARRAY* saSACL = NULL;
	SAFEARRAYBOUND rgsabound[1];

    // First need a merged list...
    CAccessEntryList t_ael;
    if(sacl.GetMergedACL(t_ael))
    {
	    DWORD dwLength = t_ael.NumEntries();
	    rgsabound[0].cElements = dwLength;
	    rgsabound[0].lLbound = 0;

	    saSACL = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		if ( NULL == saSACL )
		{
			hr = WBEM_E_OUT_OF_MEMORY ;
		}
		else
		{
			// walk DACL looking for the sid path passed in....
			ACLPOSITION aclPos;
			t_ael.BeginEnum(aclPos);
			CAccessEntry ACE;
			CInstancePtr pACEInstance;
			long ix[1];
			ix[0] = 0;

			while (t_ael.GetNext(aclPos, ACE ))
			{
				// take the AccessEntry and turn it into a Win32_ACE instance
				hr = CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_ACE", &pACEInstance, GetNamespace());
				if (SUCCEEDED(hr))
				{
					CSid TrusteeSid;
					PSID pSID = NULL;
					//Win32_Trustee Trustee;
					ACE.GetSID( TrusteeSid );

					CInstancePtr pTrusteeInstance;
					if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrusteeInstance, GetNamespace())))
					{
						FillTrusteeFromSID(pTrusteeInstance, TrusteeSid);
						pACEInstance->SetEmbeddedObject(L"Trustee", *pTrusteeInstance);
					}	// end if
					else
					{
						LogMessage(L"FillInstanceSACL - Failed to get an empty Win32_Trustee object");
						hr = WBEM_E_FAILED;
					}

					DWORD dwAccessMask = ACE.GetAccessMask();
					pACEInstance->SetDWORD(L"AccessMask", dwAccessMask);

					DWORD dwAceType = ACE.GetACEType( );
					pACEInstance->SetDWORD(L"AceType", dwAceType);

					DWORD dwAceFlags = ACE.GetACEFlags( );
					pACEInstance->SetDWORD(L"AceFlags", dwAceFlags);

					//string GuidObjectType;	-- NT 5 only

					//string GuidInheritedObjectType;	-- NT 5 only

					// Get the IUnknown of the Win32_ACE object.   Convert it to a
					// variant of type VT_UNKNOWN.  Then, add the variant to the
					// SafeArray.   Eventually, to add the list to the actual
					// Win32_SecurityDescriptor object, we will be using SetVariant
					IWbemClassObjectPtr pClassObject;
					pClassObject.Attach(pACEInstance->GetClassObjectInterface());
					if ( pClassObject )
					{

						VARIANT v;
						VariantInit(&v);

						v.vt   = VT_UNKNOWN;
						v.punkVal = pClassObject ;


						SafeArrayPutElement(saSACL, ix, pClassObject);

						VariantClear(&v);
					}	// end if

				}
				else
				{
					hr = WBEM_E_FAILED;
				}
			}	// end while loop

			t_ael.EndEnum(aclPos);
		}
    }

	if ( saSACL )
	{
		// now, set the DACL property in the Instance passed in.
		pInstance->SetStringArray(L"DACL", *saSACL);
	}

	return(hr);
}




// NT4 SP4 doesn't support SetSecurityDescriptorControl, so
// emulate it here
//
DWORD Win32SecurityDescriptor::SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR psd,
                             SECURITY_DESCRIPTOR_CONTROL wControlMask,
                             SECURITY_DESCRIPTOR_CONTROL wControlBits)
{
    DWORD dwErr = NOERROR;
    PISECURITY_DESCRIPTOR pSD = (PISECURITY_DESCRIPTOR)psd;

    if (pSD)
        pSD->Control = (pSD->Control & ~wControlMask) | wControlBits;
    else
        dwErr = ERROR_INVALID_PARAMETER;

    return dwErr;
}

//extern "C" POLARITY
void GetDescriptorFromMySecurityDescriptor( CInstance* pInstance,
											PSECURITY_DESCRIPTOR *ppDescriptor)
{
	PSECURITY_DESCRIPTOR pTempDescriptor;

	MySecurityDescriptor.GetDescriptor(pInstance, pTempDescriptor);

	*ppDescriptor = pTempDescriptor;
}

//extern "C" POLARITY
void SetSecurityDescriptorFromMyDescriptor(	PSECURITY_DESCRIPTOR pDescriptor,
											PSECURITY_INFORMATION pInformation,
											CInstance* pInstance)
{
	MySecurityDescriptor.SetDescriptor(pInstance, pDescriptor, pInformation);
}

//extern "C" POLARITY
void GetSDFromWin32SecurityDescriptor( IWbemClassObject* pObject,
											PSECURITY_DESCRIPTOR *ppDescriptor)
{
	PSECURITY_DESCRIPTOR pTempDescriptor, temp2 = NULL;

	CInstance Instance(pObject, NULL);
	try
    {
        MySecurityDescriptor.GetDescriptor(&Instance, pTempDescriptor, &temp2);
    }
    catch(...)
    {
        if(pTempDescriptor != NULL)
        {
            free(pTempDescriptor);
            pTempDescriptor = NULL;
        }
    }
	pObject = Instance.GetClassObjectInterface();

	// I dont want this copy.
	free(pTempDescriptor);

	*ppDescriptor = temp2;
}

//extern "C" POLARITY
void SetWin32SecurityDescriptorFromSD(	PSECURITY_DESCRIPTOR pDescriptor,
											PSECURITY_INFORMATION pInformation,
											bstr_t lpszPath,
											IWbemClassObject **ppObject)
{
	CInstance Instance(*ppObject, NULL);
	if (0 < lpszPath.length())
	{
		Instance.SetWCHARSplat(IDS_Path, (WCHAR*)lpszPath);
		MySecurityDescriptor.SetDescriptor(&Instance, pDescriptor, pInformation);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32sessionprocess.h ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
*******************************************************************/

// Property set identification
//============================

#pragma once

#define PROVIDER_NAME_WIN32SESSIONPROCESS L"Win32_SessionProcess"

#define PROP_ALL_REQUIRED          0xFFFFFFFF
#define PROP_NONE_REQUIRED         0x00000000
#define PROP_ANTECEDENT            0x00000001
#define PROP_DEPENDENT             0x00000002


class CWin32SessionProcess;


_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class CWin32SessionProcess : public Provider 
{
    public:
        // Constructor/destructor
        //=======================

        CWin32SessionProcess(
            LPCWSTR lpwszClassName, 
            LPCWSTR lpwszNameSpace);

        virtual ~CWin32SessionProcess();

#ifdef NTONLY

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(
            MethodContext*  pMethodContext, 
            long lFlags = 0L);

        virtual HRESULT GetObject(
            CInstance* pInstance, 
            long lFlags, 
            CFrameworkQuery& Query);
        


    private:
        HRESULT Enumerate(
            MethodContext *pMethodContext, 
            DWORD dwPropsRequired);

        HRESULT LoadPropertyValues(
            CInstance* pInstance, 
            CSession& user, 
            CProcess& proc, 
            DWORD dwPropsRequired);

        bool AreAssociated(
            const CInstance *pSesInst, 
             const CInstance *pProcInst);

        HRESULT ValidateEndPoints(
            MethodContext *pMethodContext, 
            const CInstance *pInstance, 
            CInstancePtr &pAntSesInst, 
            CInstancePtr &pDepProcInst);

        HRESULT EnumerateProcessesForSession(
            CSession& ses, 
            MethodContext *pMethodContext, 
            DWORD dwPropsRequired);

        DWORD GetRequestedProps(
            CFrameworkQuery& Query);

#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitysettingoflogicalfile.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//
//	Win32SecuritySettingOfLogicalFile
//
//////////////////////////////////////////////////////
#ifndef __Win32SecuritySettingOfLogicalFile_H_
#define __Win32SecuritySettingOfLogicalFile_H_

#define  WIN32_SECURITY_SETTING_OF_LOGICAL_FILE_NAME L"Win32_SecuritySettingOfLogicalFile"

#include "implement_logicalfile.h"


typedef struct _ELSET
{
    LPCWSTR pwstrElement;
    LPCWSTR pwstrSetting;
} ELSET, *PELSET;

class Win32SecuritySettingOfLogicalFile : public CImplement_LogicalFile
{        
    public:
	    Win32SecuritySettingOfLogicalFile (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	    ~Win32SecuritySettingOfLogicalFile ();

	    virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );
	    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);

	    HRESULT EnumerationCallback(CInstance* pFile, MethodContext* pMethodContext, void* pUserData);
	    static HRESULT WINAPI StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData);

    protected:

       // Overridable function inherrited from CImplement_LogicalFile

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual HRESULT LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif


    private:

#ifdef NTONLY
        HRESULT AssociateLFSSToLFNT(MethodContext* pMethodContext,
                                    CHString& chstrLF,
                                    CHString& chstrLFSSPATH,
                                    short sQueryType);
#endif

};	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitysettingoflogicalshare.cpp ===
//

//	Win32SecuritySettingOfLogicalShare.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////
#include "precomp.h"
//#include "helper.h"
#include "sid.h"
#include "Win32SecuritySettingOfLogicalShare.h"
/*
    [Dynamic, Provider("cimwin33"), dscription("")]
class Win32_SecuritySettingOfLogicalShare : Win32_SecuritySettingOfObject
{
    	[key]
    Win32_Share ref Element;

    	[key]
    Win32_LogicalShareSecuritySetting ref Setting;
};

*/

Win32SecuritySettingOfLogicalShare MyWin32SecuritySettingOfLogicalShare( WIN32_SECURITY_SETTING_OF_LOGICAL_SHARE_NAME, IDS_CimWin32Namespace );

Win32SecuritySettingOfLogicalShare::Win32SecuritySettingOfLogicalShare (LPCWSTR setName, LPCWSTR pszNameSpace /*=NULL*/ )
: Provider(setName, pszNameSpace)
{
}

Win32SecuritySettingOfLogicalShare::~Win32SecuritySettingOfLogicalShare ()
{
}

HRESULT Win32SecuritySettingOfLogicalShare::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	CInstancePtr pInstance ;

	// Collections
	TRefPointerCollection<CInstance>	shareList;

	// Perform queries
	//================

//	if (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_Share"),
//		&shareList, IDS_CimWin32Namespace, pMethodContext )))

	if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"SELECT Name FROM Win32_Share",
		&shareList, pMethodContext, GetNamespace() )))
	{
		REFPTRCOLLECTION_POSITION	sharePos;

		CInstancePtr pShare ;

		if ( shareList.BeginEnum( sharePos ) )
		{

			for (	pShare.Attach ( shareList.GetNext( sharePos ) ) ;
					( pShare != NULL ) && SUCCEEDED ( hr ) ;
					pShare.Attach ( shareList.GetNext( sharePos ) )
				)
			{
                CHString chsName;
				pShare->GetCHString(IDS_Name, chsName);

				if (!chsName.IsEmpty())
				{
					pInstance.Attach ( CreateNewInstance ( pMethodContext ) ) ;
                    if(pInstance != NULL)
                    {
					    // only proceed if we can get a corresponding instance of win32_logicalsharesecuritysetting
                        // (which we may not as we may not have security permissions to get that info)
                        CInstancePtr pTmpInst ;
                        CHString settingPath;
                        settingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                                L"Win32_LogicalShareSecuritySetting", IDS_Name, chsName);

                        if(SUCCEEDED(CWbemProviderGlue::GetInstanceKeysByPath(settingPath, &pTmpInst, pMethodContext )))
                        {
                            // set relpath to file
					        CHString chsSharePath;
					        GetLocalInstancePath(pShare, chsSharePath);
					        pInstance->SetCHString(IDS_Element, chsSharePath);

					        // and set the reference in the association
					        pInstance->SetCHString(IDS_Setting, settingPath);
					        // to that relpath.
					        hr = pInstance->Commit () ;
                        }
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
				}
			}	// WHILE GetNext

			shareList.EndEnum();
		}	// IF BeginEnum
	}
	return(hr);
}

HRESULT Win32SecuritySettingOfLogicalShare::GetObject ( CInstance* pInstance, long lFlags)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	if(pInstance)
	{
		CInstancePtr pLogicalShareInstance ;
		CInstancePtr pSecurityInstance ;

		// get instance by path on CIM_LogicalFile part
		CHString chsSharePath;
		pInstance->GetCHString(IDS_Element, chsSharePath);
		MethodContext* pMethodContext = pInstance->GetMethodContext();

		if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsSharePath, &pLogicalShareInstance, pMethodContext)))
		{
            CHString chstrElementName;
            pLogicalShareInstance->GetCHString(IDS_Name, chstrElementName);
            CHString chsSecurityPath;
			pInstance->GetCHString(IDS_Setting, chsSecurityPath);

			if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chsSecurityPath, &pSecurityInstance, pMethodContext)))
            {
                // endpoints exist... are they related?
                CHString chstrSettingName;
                pSecurityInstance->GetCHString(IDS_Name, chstrSettingName);
                if(chstrSettingName.CompareNoCase(chstrElementName) == 0)
                {
                    // they had the same name... good enough...
                    hr = WBEM_S_NO_ERROR;
                }
            }
		}
	}
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32securitysettingoflogicalshare.h ===
//

//

//	Win32SecuritySettingOfLogicalShare

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////
#ifndef __Win32SecuritySettingOfLogicalShare_H_
#define __Win32SecuritySettingOfLogicalShare_H_

#define  WIN32_SECURITY_SETTING_OF_LOGICAL_SHARE_NAME L"Win32_SecuritySettingOfLogicalShare"

class Win32SecuritySettingOfLogicalShare : public Provider
{
private:
protected:
public:
	Win32SecuritySettingOfLogicalShare (LPCWSTR setName, LPCWSTR pszNameSpace =NULL);
	~Win32SecuritySettingOfLogicalShare ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

};	// end class Win32SecuritySettingOfLogicalShare

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32sessionprocess.cpp ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
******************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
//#include <ntlsa.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <frqueryex.h>

#include <Session.h>

#include "Win32SessionProcess.h"

CWin32SessionProcess MyWin32_SessionProcess(
    PROVIDER_NAME_WIN32SESSIONPROCESS, 
    IDS_CimWin32Namespace);


/*****************************************************************************
 *
 *  FUNCTION    :   CWin32SessionProcess::CWin32SessionProcess
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CWin32SessionProcess::CWin32SessionProcess(
    LPCWSTR lpwszName, 
    LPCWSTR lpwszNameSpace)
  :
    Provider(lpwszName, lpwszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CWin32SessionProcess::~CWin32SessionProcess
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CWin32SessionProcess::~CWin32SessionProcess ()
{
}



/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with 
*                   WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the 
*                   following flags are handled by (and filtered out by) 
*                   WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::EnumerateInstances(
    MethodContext* pMethodContext, 
    long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = Enumerate(
        pMethodContext, 
        PROP_ALL_REQUIRED);

    return hr;
}
#endif
/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key 
*                   properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    A valid HRESULT 
*
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::GetObject(
    CInstance* pInstance, 
    long lFlags,
    CFrameworkQuery& Query)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pAntSesInst, pDepProcInst;
    MethodContext *pMethodContext = pInstance->GetMethodContext();

    // The Antecedent property contains an object path that points to a logon
    // session.  The Dependent property contains an object path that points 
    // to a process.  Let's do a GetObject on these two and make sure they 
    // point to valid sessions and processes.

    hr = ValidateEndPoints(
        pMethodContext, 
        pInstance, 
        pAntSesInst, 
        pDepProcInst);

    if (SUCCEEDED(hr))
    {
        // Ok, the session and the process both exist.  Now, does this
        // process belong to this session?
        if (AreAssociated(
            pAntSesInst, 
            pDepProcInst))
        {
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::Enumerate
*
*  DESCRIPTION :    Internal helper function used to enumerate instances of
*                   this class.  All instances are enumerated, but only the
*                   properties specified are obtained.
*
*  INPUTS      :    A pointer to a the MethodContext for the call.
*                   A DWORD specifying which properties are requested.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::Enumerate(
    MethodContext *pMethodContext, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We will use the helper class CUserSessionCollection to get
    // a mapping of users and their associated sessions.
    CUserSessionCollection usc;

    USER_SESSION_ITERATOR usiter;
    SmartDelete<CSession> pses;

    pses = usc.GetFirstSession(usiter);
    while(pses != NULL)
    {
        hr = EnumerateProcessesForSession(
            *pses,
            pMethodContext, 
            dwPropsRequired);

        pses = usc.GetNextSession(usiter);
    }

    return hr;
}
#endif

/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::EnumerateProcessesForSession
*
*  DESCRIPTION :    Called by Enumerate to enumerate the processes of a given
*                   session. 
*
*  INPUTS      :    The session to enumerate processes for, the methodcontext
*                   to communicate to winmgmt with, and a property bitmask of
*                   which properties to populate
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::EnumerateProcessesForSession(
    CSession& session, 
    MethodContext *pMethodContext, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    PROCESS_ITERATOR prociter;
    SmartDelete<CProcess> pproc;

    pproc = session.GetFirstProcess(
        prociter);

    while(pproc != NULL)
    {
        // Create a new instance based on the passed-in 
        // MethodContext.  Note that CreateNewInstance may 
        // throw, but will never return NULL.
        CInstancePtr pInstance(
            CreateNewInstance(
                pMethodContext), 
                false);

        hr = LoadPropertyValues(
            pInstance, 
            session, 
            *pproc, 
            dwPropsRequired);

        if(SUCCEEDED(hr))
        {
            hr = pInstance->Commit();   
        }

        pproc = session.GetNextProcess(
            prociter);
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::LoadPropertyValues
*
*  DESCRIPTION :    Internal helper function used to fill in all unfilled
*                   property values.  At a minimum, it must fill in the key
*                   properties.
*
*  INPUTS      :    A pointer to a CInstance containing the instance we are
*                   attempting to locate and fill values for.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::LoadPropertyValues(
    CInstance* pInstance, 
    CSession& session, 
    CProcess& proc, 
    DWORD dwPropsRequired)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chstrValue;

    WCHAR wstrBuff[MAXI64TOA];

    _i64tow(
        session.GetLUIDint64(), 
        wstrBuff, 
        10);

    if (dwPropsRequired & PROP_ANTECEDENT)
    {
        chstrValue.Format(
            L"\\\\.\\%s:Win32_LogonSession.LogonId=\"%s\"", 
            IDS_CimWin32Namespace, 
            (LPCWSTR)wstrBuff);

        pInstance->SetCHString(
            IDS_Antecedent, 
            chstrValue);
    }

    if (dwPropsRequired & PROP_DEPENDENT)
    {
        chstrValue.Format(
            L"\\\\.\\%s:Win32_Process.Handle=\"%d\"", 
            IDS_CimWin32Namespace, 
            proc.GetPID());

        pInstance->SetCHString(
            IDS_Dependent, 
            chstrValue);
    }

    return hr;
}
#endif



/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::ValidateEndPoints
*
*  DESCRIPTION :    Internal helper function used to determine whether the
*                   two object paths in the association currently point
*                   to valid users/sessions.
*
*
*  INPUTS      :    MethodContext to call back into winmgmt with, and
*                   the CInstance that is to be checked.
*
*  OUTPUTS     :    Pointers to CInstances that contain the actual objects
*                   from the endpoint classes.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
HRESULT CWin32SessionProcess::ValidateEndPoints(
    MethodContext *pMethodContext, 
    const CInstance *pInstance, 
    CInstancePtr &pAntSesInst, 
    CInstancePtr &pDepProcInst)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrSessionPath;

    // See if the session specified exists
    pInstance->GetCHString(
        IDS_Antecedent, 
        chstrSessionPath);

    hr = CWbemProviderGlue::GetInstanceKeysByPath(
        chstrSessionPath, 
        &pAntSesInst, 
        pMethodContext);

    if (SUCCEEDED(hr))
    {
        // The users exists.  Now, see if the session exists.
        CHString chstrProcessPath;
        pInstance->GetCHString(
            IDS_Dependent, 
            chstrProcessPath);

        hr = CWbemProviderGlue::GetInstanceKeysByPath(
            chstrProcessPath, 
            &pDepProcInst, 
            pMethodContext);
    }

    return hr;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::AreAssociated
*
*  DESCRIPTION :    Internal helper function used to determine whether a
*                   specific session is associated to the specified process.
*
*  INPUTS      :    
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
#ifdef NTONLY
bool CWin32SessionProcess::AreAssociated(
    const CInstance *pSesInst, 
    const CInstance *pProcInst)
{
    bool fRet = false;

    CHString chstrSesLogonId;
    CHString chstrProcessHandle;

    pSesInst->GetCHString(IDS_LogonId, chstrSesLogonId);
    pProcInst->GetCHString(IDS_Handle, chstrProcessHandle);
    
    CSession sesTmp;
    if(sesTmp.IsSessionIDValid(chstrSesLogonId))
    {
        __int64 i64LogonId = _wtoi64(chstrSesLogonId);
    
        WCHAR* pwchStop = NULL;
        DWORD dwHandle = wcstoul(
            chstrProcessHandle, 
            &pwchStop,
            10);


        // We will use the helper class CUserSessionCollection to get
        // a mapping of users and their associated sessions, and from
        // those sessions, their processes.
        CUserSessionCollection usc; 
        SmartDelete<CSession> pses;

        pses = usc.FindSession(
            i64LogonId);

        if(pses)
        {
            SmartDelete<CProcess> pproc;
            PROCESS_ITERATOR prociter;

            pproc = pses->GetFirstProcess(
                prociter);

            while(pproc && !fRet)
            {
                // see if we find a session id match for this user...
                if(dwHandle == pproc->GetPID())
                {
                    fRet = true;
                }
        
                pproc = pses->GetNextProcess(
                    prociter);
            }
        }
    }

    return fRet;
}
#endif



/*****************************************************************************
*
*  FUNCTION    :    CWin32SessionProcess::GetRequestedProps
*
*  DESCRIPTION :    Internal helper function used to determine which
*                   properties are required to satisfy the GetObject or
*                   ExecQuery request.
*
*  INPUTS      :    A pointer to a CFrameworkQuery from which we can determine
*                   the required properties.
*
*  RETURNS     :    A DWORD bitmask that maps those properties that are
*                   required. 
*
*****************************************************************************/
#ifdef NTONLY
DWORD CWin32SessionProcess::GetRequestedProps(CFrameworkQuery& Query)
{
    DWORD dwReqProps = 0;

    if (Query.IsPropertyRequired(IDS_Antecedent)) dwReqProps |= PROP_ANTECEDENT;
    if (Query.IsPropertyRequired(IDS_Dependent)) dwReqProps |= PROP_DEPENDENT;

    return dwReqProps;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32sid.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//
//	Win32SID
//
//////////////////////////////////////////////////////
#ifndef __Win32SID_H_
#define __Win32SID_H_

#define  WIN32_SID_NAME L"Win32_SID"

class Win32SID : public Provider
{
private:
	DWORD m_dwPlatformID;
protected:
public:
	Win32SID (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	~Win32SID ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

	HRESULT FillInstance(CInstance* pInstance, CHString& chsSID);
};	// end class Win32LogicalFileSecuritySetting

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32systemdriverpnpentity.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  win32SystemDriverPNPEntity.cpp
//
//  Purpose: Relationship between Win32_SystemDriver and Win32_PNPEntity
//
//***************************************************************************

#include "precomp.h"
#include <cregcls.h>
#include <vector>
#include "PNPEntity.h"
#include "bservice.h"

#include "DllWrapperBase.h"
#include "AdvApi32Api.h"

#include "systemdriver.h"
#include "LPVParams.h"
#include <FRQueryEx.h>
#include <assertbreak.h>

#include "WIN32SystemDriverPNPEntity.h"

#define BIT_ALL_PROPS  0xffffffff
#define BIT_Antecedent 0x00000001
#define BIT_Dependent  0x00000002

// Property set declaration
//=========================
CW32SysDrvPnp MyCW32SysDrvPnp(PROPSET_NAME_WIN32SYSTEMDRIVER_PNPENTITY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32SysDrvPnp::CW32SysDrvPnp
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32SysDrvPnp::CW32SysDrvPnp(LPCWSTR setName, LPCWSTR pszNamespace)
: CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SysDrvPnp::~CW32SysDrvPnp
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32SysDrvPnp::~CW32SysDrvPnp()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SysDrvPnp::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SysDrvPnp::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    if(pInstance != NULL)
    {
        // Get the key properties
        CHString chstrDependent, chstrAntecedent;
        pInstance->GetCHString(IDS_Dependent, chstrDependent);
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);

        // Obtain the Dependent's device id:
        CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
        chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
        CHString chstrDependentDevIDAdj;
        RemoveDoubleBackslashes(chstrDependentDevID, chstrDependentDevIDAdj);

        // Obtain the Antecedent's device id:
        CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
        chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
        CHString chstrAntecedentDevIDAdj;
        RemoveDoubleBackslashes(chstrAntecedentDevID, chstrAntecedentDevIDAdj);

        CConfigManager cfgmgr;
        CConfigMgrDevicePtr pPNPDevice(NULL);

        // Now see if the Antecedent is visible to config manager...
        if(cfgmgr.LocateDevice(chstrAntecedentDevIDAdj, pPNPDevice))
        {
            // It is visible to config manager.  Is it a PNPDevice?
            if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
            {

                CHString sServiceName;
                if (pPNPDevice->GetService(sServiceName))
                {
                    // It does. Is it's service name the same as that which we were given?
                    if(chstrDependentDevIDAdj.CompareNoCase(sServiceName)==0)
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                }
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32SysDrvPnp::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CW32SysDrvPnp::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwReqProps;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwReqProps);

    std::vector<_bstr_t> vecAntecedents;
    pQuery.GetValuesForProp(IDS_Antecedent, vecAntecedents);
    DWORD dwAntecedents = vecAntecedents.size();

    std::vector<_bstr_t> vecDependents;
    pQuery.GetValuesForProp(IDS_Dependent, vecDependents);
    DWORD dwDependents = vecDependents.size();

    // We don't have an efficient way to walk services, but we do have a way to walk
    // devices.
    if(dwAntecedents > 0)
    {
        for (DWORD x=0; x < dwAntecedents; x++)
        {
            // Obtain the Antecedent's device id:
            CHString chstrAntecedent((LPCTSTR)vecAntecedents[x]);
            CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
            chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
            CHString chstrAntecedentDevIDAdj;
            RemoveDoubleBackslashes(chstrAntecedentDevID, chstrAntecedentDevIDAdj);

            CConfigManager cfgmgr;
            CConfigMgrDevicePtr pPNPDevice(NULL);

            // Now see if the Antecedent is visible to config manager...
            if(cfgmgr.LocateDevice(chstrAntecedentDevIDAdj, pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // Let's make an instance
                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                    if(NULL != pInstance)
                    {
                        hr = LoadPropertyValues(&CLPVParams(pInstance, pPNPDevice, dwReqProps));
                    }
                }
            }
        }
    }
    else
    {
        CWin32PNPEntity::Enumerate(pMethodContext, lFlags, dwReqProps);
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SysDrvPnp::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances or ExecQuery function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32SysDrvPnp::LoadPropertyValues(void* pv)
{

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance *pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);

    if(pInstance == NULL || pDevice == NULL)
    {
        // This would imply a coding failure and should never happen
        ASSERT_BREAK(FALSE);
        return WBEM_E_FAILED;
    }

    HRESULT hr = WBEM_S_NO_ERROR;
    CHString sPNPId, sSystemDriver;
    CHString chstrControllerPATH;

    // Make sure we can retrieve the values and that they are non-blank
    if ((pDevice->GetDeviceID(sPNPId)) && (pDevice->GetService(sSystemDriver)) &&
        (!sPNPId.IsEmpty()) && (!sSystemDriver.IsEmpty()))
    {

        // Format to suit and commit
        if (dwReqProps & BIT_Antecedent)
        {
            CHString sPNPIdAdj;
            CHString sPNPIdPath;

            EscapeBackslashes(sPNPId, sPNPIdAdj);

            sPNPIdPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_PNPEntity,
                                       IDS_DeviceID,
                                       (LPCWSTR)sPNPIdAdj);
            pInstance->SetCHString(IDS_Antecedent, sPNPIdPath);
        }

        if (dwReqProps & BIT_Dependent)
        {
            CHString sSystemDriverAdj, sSystemDriverPath;

            EscapeBackslashes(sSystemDriver, sSystemDriverAdj);

            sSystemDriverPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_SYSTEM_DRIVER,
                                       IDS_Name,
                                       (LPCWSTR)sSystemDriverAdj);

            pInstance->SetCHString(IDS_Dependent, sSystemDriverPath);
        }

        hr = pInstance->Commit();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32systemdriverpnpentity.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  win32SystemDriverPNPEntity.h
//
//  Purpose: Relationship between Win32_SystemDriver and Win32_PNPEntity
//
//***************************************************************************

#ifndef _WIN32USBCONTROLLERDEVICE_H_
#define _WIN32USBCONTROLLERDEVICE_H_


// Property set identification
//============================
#define PROPSET_NAME_WIN32SYSTEMDRIVER_PNPENTITY  L"Win32_SystemDriverPNPEntity"


class CW32SysDrvPnp;

class CW32SysDrvPnp : public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================
        CW32SysDrvPnp(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32SysDrvPnp() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long a_Flags = 0L);
//        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L); 

    protected:

        // Functions inherrited from CWin32USB
        //====================================
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        CHPtrArray m_ptrProperties;
};

// This derived class commits here, not in the base.
inline bool CW32SysDrvPnp::ShouldBaseCommit(void* pvData) { return false; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32subdirectory.h ===
//=================================================================

//

// Win32SubDirectory 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/09/98    a-kevhu         Created
//
// Comment: Relationship between a Win32_Directory and its sub-directories
//
//=================================================================

// Property set identification
//============================

#ifndef _WIN32SUBDIRECTORY_H_
#define _WIN32SUBDIRECTORY_H_

#define  PROPSET_NAME_WIN32SUBDIRECTORY L"Win32_SubDirectory"


#include "implement_logicalfile.h"


class CW32SubDir;

class CW32SubDir : public CImplement_LogicalFile 
{
    public:
        // Constructor/destructor
        //=======================
        CW32SubDir(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32SubDir() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        //virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);
        
        // a parent implements this, but this class doesn't support it...
        virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L) { return WBEM_E_PROVIDER_NOT_CAPABLE; }

    protected:
       
       // Overridable function inherrited from CImplement_LogicalFile

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual HRESULT LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

    private:

        HRESULT AssociateSubDirectories(MethodContext *pMethodContext, const CHString &chstrCurrentDir, const CHString& chstrSubDirPath);
        HRESULT AssociateParentDirectory(MethodContext *pMethodContext, const CHString &chstrCurrentDir);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32subdirectory.cpp ===
//=================================================================

//

// Win32SubDirectory.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between win32_directory and its sub-directories
//
//=================================================================

#include "precomp.h"
#include <frqueryex.h>

#include "FileFile.h"
#include "Win32SubDirectory.h"
#include "directory.h"

// Property set declaration
//=========================
CW32SubDir MyCW32SubDir(PROPSET_NAME_WIN32SUBDIRECTORY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::CW32SubDir
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32SubDir::CW32SubDir(LPCWSTR setName, LPCWSTR pszNamespace)
:CImplement_LogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::~CW32SubDir
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32SubDir::~CW32SubDir()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32SubDir::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    if(pInstance != NULL)
    {
        CHString chstrParentDir;
        CHString chstrChildDir;

        // Get the two paths
        pInstance->GetCHString(IDS_GroupComponent, chstrParentDir);
        pInstance->GetCHString(IDS_PartComponent, chstrChildDir);

        CInstancePtr pinstParentDir;
        CInstancePtr pinstChildDir;

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrParentDir, &pinstParentDir, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrChildDir, &pinstChildDir, pInstance->GetMethodContext())))
            {
                // Both directories exist, but is one a subdirectory of the other?
                CHString chstrParentDirPathNameWhack;
                CHString chstrParentDirName;
                CHString chstrChildDirPath;
                LONG lPos;

                pinstParentDir->GetCHString(IDS_Name, chstrParentDirName);
                pinstChildDir->GetCHString(IDS_Path, chstrChildDirPath);

                lPos = chstrParentDirName.Find(L":");
                chstrParentDirPathNameWhack = chstrParentDirName.Mid(lPos+1);
                if(chstrParentDirPathNameWhack != _T("\\"))
                {
                    chstrParentDirPathNameWhack += _T("\\");
                }

                if(chstrChildDirPath == chstrParentDirPathNameWhack)
                {
                    // Yes, the child is a sub-directory of the parent
                    hr = WBEM_S_NO_ERROR;
                }

            } //childdir instancebypath
        } //parentdir instancebypath
    } // pinstance not null

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32SubDir::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    std::vector<_bstr_t> vecGroupComponents;
    std::vector<_bstr_t> vecPartComponents;
    DWORD dwNumGroupComponents;
    DWORD dwNumPartComponents;

    // Did they just ask for parent directories?
    pQuery.GetValuesForProp(IDS_GroupComponent, vecGroupComponents);
    dwNumGroupComponents = vecGroupComponents.size();

    // Did they just ask for subdirectories?
    pQuery.GetValuesForProp(IDS_PartComponent, vecPartComponents);
    dwNumPartComponents = vecPartComponents.size();

    // Find out what type of query it was.
    // Was it a 3TokenOR?
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);
    if (pQuery2 != NULL)
    {
        variant_t vCurrentDir;
        variant_t vSubDir;
        CHString chstrSubDirPath;
        CHString chstrCurrentDir;

        if ( (pQuery2->Is3TokenOR(IDS_GroupComponent, IDS_PartComponent, vCurrentDir, vSubDir)) &&
             ((V_BSTR(&vCurrentDir) != NULL) && (V_BSTR(&vSubDir) != NULL)) &&
             (wcscmp(V_BSTR(&vCurrentDir), V_BSTR(&vSubDir)) == 0) )
        {
            // It was indeed a three token or.  Also, the antecedent and decendent are equal as I expected.

            // 1) Associate this directory with its subdirectories:
            //======================================================
            ParsedObjectPath    *pParsedPath = NULL;
            CObjectPathParser	objpathParser;

            // Parse the path to get the domain/user
            int nStatus = objpathParser.Parse(V_BSTR(&vCurrentDir),  &pParsedPath);

            // Did we parse it and does it look reasonable?
            if (nStatus == 0)
            {
                try
                {
                    if ( (pParsedPath->m_dwNumKeys == 1) &&
                         (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) )
                    {

                        // This contains the complete object path
                        chstrCurrentDir = V_BSTR(&vCurrentDir);

                        // This contains just the 'value' part of the object path
                        chstrSubDirPath = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                        // Trim off the drive letter
                        CHString chstrDiskLetter = chstrSubDirPath.Left(2);
                        chstrSubDirPath = chstrSubDirPath.Mid(2);

                        if(chstrSubDirPath != _T("\\")) // it is not a root dir (proper syntax for root is just "\\", not "\\\\")
                        {
                            chstrSubDirPath += _T("\\"); // if not the root, need to tack on trailing pair of backslashes
                        }
                        hr = AssociateSubDirectories(pMethodContext, chstrDiskLetter, chstrSubDirPath);


                        // 2) This directory is also associated with its parent directory.  Manually create that
                        //    association here.  However, if this is the root dir, don't try to associate with
                        //    some non-existent parent!
                        //======================================================================================

                        if(chstrSubDirPath != _T("\\"))
                        {
                            hr = AssociateParentDirectory(pMethodContext, chstrCurrentDir);
                        }
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OBJECT_PATH;
                    }
                }
                catch ( ... )
                {
                    objpathParser.Free( pParsedPath );
                    throw;
                }

                objpathParser.Free( pParsedPath );
            }
            else
            {
                hr = WBEM_E_INVALID_OBJECT_PATH;
            }
        }
        else if(dwNumPartComponents > 0)
        {
            ParsedObjectPath    *pParsedPath = NULL;
            CObjectPathParser	objpathParser;

            for(LONG m = 0L; m < dwNumPartComponents; m++)
            {
                // Parse the path to get the domain/user
                int nStatus = objpathParser.Parse(vecPartComponents[m],  &pParsedPath);

                // Did we parse it?
                if (nStatus == 0)
                {
                    try
                    {
                        // Does it look reasonable
                        if ( (pParsedPath->m_dwNumKeys == 1) &&
                             (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) )
                        {
                            // This contains the complete object path
                            chstrCurrentDir = (wchar_t*)vecPartComponents[m];

                            // This contains just the 'value' part of the object path
                            chstrSubDirPath = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                            // Trim off the drive letter
                            chstrSubDirPath = chstrSubDirPath.Mid(2);

                            // Just want to associate to the parent directory (only if this isn't the root though)...
                            if(chstrSubDirPath != _T("\\"))
                            {   // Here the "current directory" is a subdirectory, and we want its parent
                                hr = AssociateParentDirectory(pMethodContext, chstrCurrentDir);
                            }
                        }
                    }
                    catch (...)
                    {
                        objpathParser.Free( pParsedPath );
                        throw;
                    }

                    // Clean up the Parsed Path
                    objpathParser.Free( pParsedPath );
                }
            }
        }
        else if(dwNumGroupComponents > 0)
        {
            ParsedObjectPath    *pParsedPath = NULL;
            CObjectPathParser	objpathParser;

            for(LONG m = 0L; m < dwNumGroupComponents; m++)
            {
                // Parse the path to get the domain/user
                int nStatus = objpathParser.Parse(vecGroupComponents[m],  &pParsedPath);

                // Did we parse it and does it look reasonable?
                if (nStatus == 0)
                {
                    try
                    {
                        if ( (pParsedPath->m_dwNumKeys == 1) &&
                             (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) )
                        {
                            // This contains the complete object path
                            chstrCurrentDir = (wchar_t*) vecGroupComponents[m];

                            // This contains just the 'value' part of the object path
                            chstrSubDirPath = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                            // Trim off the drive letter
                            CHString chstrDiskLetter = chstrSubDirPath.Left(2);
                            chstrSubDirPath = chstrSubDirPath.Mid(2);

                            if(chstrSubDirPath != _T("\\")) // it is not a root dir (proper syntax for root is just "\\", not "\\\\")
                            {
                                chstrSubDirPath += _T("\\"); // if not the root, need to tack on trailing pair of backslashes
                            }
                            // Just want to associate to subdirectories...
                            hr = AssociateSubDirectories(pMethodContext, chstrDiskLetter, chstrSubDirPath);
                        }
                    }
                    catch (...)
                    {
                        objpathParser.Free( pParsedPath );
                        throw;
                    }

                    // Clean up the Parsed Path
                    objpathParser.Free( pParsedPath );
                }
            }
        }
        else
        {
            // Don't have a clue, so return 'em all and let CIMOM sort it out...
            hr = EnumerateInstances(pMethodContext);
        }
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set. Let's hope nobody ever does
 *                this! It could take quite some time!!
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE
//
//WITH CHANGE TO MAKE THIS CLASS INHERRIT FROM CIMPLEMENTLOGICALFILE, NO NEED TO
//IMPLEMENT HERE AT ALL.  WHAT WILL HAPPEN IS ENUMINSTANCES FROM THE PARENT CLASS
//WILL BE CALLED, BUT ONLY DIRECTORIES WILL SATISFY THIS CLASS'S ISONEOFME (WHICH WILL
//BE THE VERSION OF THAT FUNCTION CALLED AS THIS IS THE MOST DERIVED VERSION),
//AND SIMILARLY THIS CLASS'S LOADPROPERTYVALUES WILL BE CALLED.
//
// NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE
//
//HRESULT CW32SubDir::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
//{
//    HRESULT hr = WBEM_S_NO_ERROR;
//    TRefPointerCollection<CInstance> LWin32Directories;
//
//    CHString chstrAllDirsQuery;
//    chstrAllDirsQuery.Format(_T("SELECT __PATH, %s, %s FROM Win32_Directory"), IDS_Drive, IDS_Name);
//    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrAllDirsQuery,
//                                                        &LWin32Directories,
//                                                        pMethodContext,
//                                                        IDS_CimWin32Namespace)))
//
//    {
//        REFPTRCOLLECTION_POSITION pos;
//        if(LWin32Directories.BeginEnum(pos))
//        {
//            CInstance* pinstWin32Directory = NULL;
//            CHString chstrQuery;
//            CHString chstrDrive;
//            CHString chstrDirPath;
//            CHString chstrDirName;
//            CHString chstrQueryPath;
//            CHString chstrParentDirPATH;
//            LONG lPos;
//
//           while((SUCCEEDED(hr)) && (pinstWin32Directory = LWin32Directories.GetNext(pos)))
//            {
//                if(pinstWin32Directory != NULL)
//                {
//                    pinstWin32Directory->GetCHString(_T("__PATH"), chstrParentDirPATH);
//                    pinstWin32Directory->GetCHString(IDS_Drive, chstrDrive);
//                    pinstWin32Directory->GetCHString(IDS_Name, chstrDirName);
//
//                    lPos = chstrDirName.Find(_T(":"));
//                   chstrDirPath = chstrDirName.Mid(lPos+1);
//                    if(chstrDirPath != _T("\\"))
//                    {
//                        chstrDirPath += _T("\\");
//                    }
//                    CHString chstrWbemizedPath;
//                    EscapeBackslashes(chstrDirPath, chstrWbemizedPath);
//                    chstrQuery.Format(_T("SELECT __PATH FROM Win32_Directory where Drive = \"%s\" and Path = \"%s\""), (LPCTSTR)chstrDrive, (LPCTSTR)chstrWbemizedPath);
//                    hr = QueryForSubItemsAndCommit(chstrParentDirPATH, chstrQuery, pMethodContext);
//
//                    pinstWin32Directory->elease();
//                }
//            }
//            LWin32Directories.EndEnum();
//        }
//    }
//    return hr;
//}

/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  That class
 *                returns files or directories where this one should only
 *                return directories, in response to queries, getobject commands,
 *                etc.  It is overridden here to return TRUE only if the file
 *                (the information for which is contained in the function
 *                arguement pstFindData) is of type directory.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if a file or FALSE if a directory
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CW32SubDir::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE);
    }
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CW32SubDir::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherritedfrom CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the PartComponent and GroupComponent
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CW32SubDir::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrDirName;
    CHString chstrDirNameAdj;
    CHString chstrDirPATH;

    CHString chstrSubDirName;
    CHString chstrSubDirNameAdj;
    CHString chstrSubDirPATH;

    // Note: this routing will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    // Get the GroupComponent (the directory name) ready...
    chstrDirName.Format(L"%s%s",pszDrive,pszPath);
    if(chstrDirName.GetLength() != 3)
    {   // it was not the root dir, so need to trim off trailing backslash.
        chstrDirName = chstrDirName.Left(chstrDirName.GetLength() - 1);
    }
    EscapeBackslashes(chstrDirName, chstrDirNameAdj);
    chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_DIRECTORY,
                        (LPCWSTR)chstrDirNameAdj);
    // Get the PartComponent (the subdirectory name) ready...
    chstrSubDirName.Format(L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
    EscapeBackslashes(chstrSubDirName, chstrSubDirNameAdj);
    chstrSubDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                          (LPCWSTR)GetLocalComputerName(),
                          IDS_CimWin32Namespace,
                          PROPSET_NAME_DIRECTORY,
                          (LPCWSTR)chstrSubDirNameAdj);
    // Set Properties...
    pInstance->SetCHString(IDS_GroupComponent, chstrDirPATH);
    pInstance->SetCHString(IDS_PartComponent, chstrSubDirPATH);

	return WBEM_S_NO_ERROR ;
}
#endif


HRESULT CW32SubDir::AssociateSubDirectories(MethodContext *pMethodContext, const CHString &chstrDiskLetter, const CHString& chstrSubDirPath)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                    chstrDiskLetter,
                    chstrSubDirPath, // use the given path
                    L"*",               // filename
                    L"*",               // extension
                    false,              // no recursion desired
                    NULL,               // don't need the file system name
                    NULL,               // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                    false,              // this association is not interested in calling LoadPropertyValues for the root, only for files off of it
                    NULL));             // no extra parms needed
#endif
    return hr;
}


HRESULT CW32SubDir::AssociateParentDirectory(MethodContext *pMethodContext, const CHString &chstrCurrentDir)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chstrParentDirPATH;

    if (chstrCurrentDir.Left(2) == L"\\\\")
    {
        chstrParentDirPATH = chstrCurrentDir;
    }
    else
    {
        chstrParentDirPATH.Format(L"\\\\%s\\%s:%s", GetLocalComputerName(), IDS_CimWin32Namespace, chstrCurrentDir);
    }

    CInstancePtr pEndPoint;
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceKeysByPath(chstrCurrentDir, &pEndPoint, pMethodContext)))
    {
        CInstancePtr pInstance( CreateNewInstance(pMethodContext), false);

        pInstance->SetCHString(IDS_PartComponent, chstrParentDirPATH);

        // Need the name of the directory above this one
        CHString chstrAboveParentDirName;

        chstrAboveParentDirName = chstrParentDirPATH.Left(chstrParentDirPATH.GetLength() - 1);
        LONG lPos = chstrParentDirPATH.ReverseFind(_T('\\'));
        chstrAboveParentDirName = chstrParentDirPATH.Left(lPos-1);

        lPos = chstrAboveParentDirName.Find(L"=");
        CHString chstrTemp = chstrAboveParentDirName.Mid(lPos+1);
        if(chstrTemp[chstrTemp.GetLength() - 1] == L':')
        {
            // our dir hangs off the root. We've stripped the only \\ from it, so need to put it back:
            chstrAboveParentDirName += _T("\\\\");
        }

        CHString chstrAboveParentDirPATH;
        chstrAboveParentDirPATH.Format(L"%s\"", (LPCWSTR)chstrAboveParentDirName);
        pInstance->SetCHString(IDS_GroupComponent, chstrAboveParentDirPATH);

        hr = pInstance->Commit();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32sid.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

//
//	Win32Sid.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "sid.h"
#include "Win32Sid.h"

/*
    [Dynamic,
    description("Represents an arbitrary SID -- CANNOT BE ENUMERATED")]
class Win32_SID : CIM_Setting
{
        [Description (
        ""
        ) , Read, Key]
    string SID;

        [Description (
        ""
        ) , Read]
    uint8 BinaryRepresentation[];

        [Description (
        ""
        ) , Read]
    string AccountName;

        [Description (
        ""
        ) , Read]
     string ReferencedDomainName;
};
*/
Win32SID MySid( WIN32_SID_NAME, IDS_CimWin32Namespace );

Win32SID::Win32SID ( const CHString& setName, LPCTSTR pszNameSpace /*=NULL*/ )
: Provider (setName, pszNameSpace)
{
}

Win32SID::~Win32SID ()
{
}

HRESULT Win32SID::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;
	return(hr);

}

HRESULT Win32SID::GetObject ( CInstance* pInstance, long lFlags)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	CHString chsSID;

	if (pInstance)
	{
		pInstance->GetCHString(IDS_SID, chsSID);
		// NOTE: a blank sid means the NT None group
		if (!chsSID.IsEmpty())
		{
			hr = FillInstance(pInstance, chsSID);
		}	// end if
		else
		{
			hr = WBEM_S_NO_ERROR;
		}
	}
	return(hr);
}

HRESULT Win32SID::FillInstance(CInstance* pInstance, CHString& chsSID)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	PSID pSid = NULL;
    try
    {
	    pSid = StrToSID(chsSID);
	    CSid sid(pSid);
	    if (sid.IsValid())
	    {
		    // get account name
		    CHString chsAccount = sid.GetAccountName();
		    pInstance->SetCHString(IDS_AccountName, chsAccount);
            pInstance->SetCHString(IDS_SID, chsSID);

		    // get domain name
		    CHString chsDomain = sid.GetDomainName();
		    pInstance->SetCHString(IDS_ReferencedDomainName, chsDomain);

		    // set the UINT8 array for the pSid
		    DWORD dwSidLength = sid.GetLength();
    //			BYTE bByte;
            pInstance->SetDWORD(IDS_SidLength, dwSidLength);
		    SAFEARRAY* sa;
		    SAFEARRAYBOUND rgsabound[1];
		    VARIANT vValue;
		    void* pVoid;

            VariantInit(&vValue);

		    rgsabound[0].cElements = dwSidLength;
    //		char Buf[100];

		    rgsabound[0].lLbound = 0;
		    sa = SafeArrayCreate(VT_UI1, 1, rgsabound);
            if ( sa == NULL )
		    {
			    if (pSid != NULL)
                {
                    FreeSid(pSid);
                }
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		    }

		         // Get a pointer to read the data into
  		    SafeArrayAccessData(sa, &pVoid);
  		    memcpy(pVoid, pSid, rgsabound[0].cElements);
  		    SafeArrayUnaccessData(sa);

		    // Put the safearray into a variant, and send it off
		    V_VT(&vValue) = VT_UI1 | VT_ARRAY; V_ARRAY(&vValue) = sa;
		    pInstance->SetVariant(_T("BinaryRepresentation"), vValue);

		    VariantClear(&vValue);
            hr = WBEM_S_NO_ERROR;

	    }	// end if

    }
    catch(...)
    {
        if(pSid != NULL)
        {
            FreeSid(pSid);
            pSid = NULL;
        }
        throw;
    }

    if(pSid != NULL)
    {
        FreeSid(pSid);
        pSid = NULL;
    }

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32systemusers.cpp ===
//=================================================================

//

// Win32SystemUsers.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    3/6/99    davwoh         Extracted from grouppart.cpp
//
// Comment:
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "wbemnetapi32.h"
#include <lmwksta.h>
#include "sid.h"
#include "Win32SystemUsers.h"

CWin32SystemUsers	MyLocalUser( PROPSET_NAME_SYSTEMUSER, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemUsers::CWin32SystemUsers
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : LPCWSTR strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32SystemUsers::CWin32SystemUsers( LPCWSTR strName, LPCWSTR pszNamespace )
:	Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32SystemUsers::~CWin32SystemUsers
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32SystemUsers::~CWin32SystemUsers()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SystemUsers::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32SystemUsers::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    HRESULT         hr = WBEM_E_FAILED;
    CInstancePtr    pLocInstance;
    CHString        systemPath,
                    userPath,
                    sOurDomain,
                    sReqDomain,
                    sReqName;
    CNetAPI32       NetAPI;

    // First, find out what domain we are in
    if (NetAPI.Init() == ERROR_SUCCESS)
    {
#ifdef NTONLY
    WKSTA_INFO_100  *pstInfo;
    NET_API_STATUS  dwStatus;

        {
            // Get the computer name and domain name
            if ((dwStatus = NetAPI.NetWkstaGetInfo(NULL, 100,
                (LPBYTE *) &pstInfo)) == NERR_Success)
            {
                try
                {
                    // If we are a domain controller, we want all the users in our
                    // domain, else all the users on our machine
                    if (NetAPI.IsDomainController(NULL))
                    {
                        sOurDomain = (WCHAR *)pstInfo->wki100_langroup;
                    }
                    else
                    {
                        sOurDomain = (WCHAR *)pstInfo->wki100_computername;
                    }
                }
                catch ( ... )
                {
                    NetAPI.NetApiBufferFree(pstInfo);
                    throw ;
                }

                NetAPI.NetApiBufferFree(pstInfo);
                hr = WBEM_S_NO_ERROR;
            }
            else
                hr = WinErrorToWBEMhResult(dwStatus);
        }
#endif

        if (SUCCEEDED(hr))
        {
            // Now, let's check the system part
            pInstance->GetCHString(IDS_GroupComponent, systemPath);
            hr = CWbemProviderGlue::GetInstanceByPath(systemPath,
                    &pLocInstance, pInstance->GetMethodContext());
        }
    }

    // Ok, system is ok (and we got the domain), what about the user?
    if (SUCCEEDED(hr))
    {
        // Let's just try getting the user from Win32_UserAccount
        pInstance->GetCHString(IDS_PartComponent, userPath);
        hr = CWbemProviderGlue::GetInstanceByPath(userPath, &pLocInstance, pInstance->GetMethodContext());

        if (SUCCEEDED(hr))
        {
            // Ok, we found it, but is it one of 'our' users?
            pLocInstance->GetCHString(IDS_Domain, sReqDomain);
            if (sReqDomain.CompareNoCase(sOurDomain) != 0)
            {
                // Nope, not ours.  Try the registry.
                hr = WBEM_E_NOT_FOUND;
            }
        }

        // Well, if that didn't work, let's check the registry
        if (hr == WBEM_E_NOT_FOUND)
        {
            ParsedObjectPath    *pParsedPath = 0;
            CObjectPathParser	objpathParser;

            hr = WBEM_E_INVALID_PARAMETER;

            // Parse the path to get the domain/user
            int nStatus = objpathParser.Parse(userPath,  &pParsedPath);

            // Did we parse it and does it look reasonable?
            if (nStatus == 0 && pParsedPath->m_dwNumKeys == 2)
            {
                // Get the value out (order is not guaranteed)
                for (int i = 0; i < 2; i++)
                {
                    if (_wcsicmp(pParsedPath->m_paKeys[i]->m_pName,
                        L"Name") == 0)
                    {
                        if (pParsedPath->m_paKeys[i]->m_vValue.vt == VT_BSTR)
                            sReqName = pParsedPath->m_paKeys[i]->m_vValue.bstrVal;
                    }
                    else if (_wcsicmp(pParsedPath->m_paKeys[i]->m_pName,
                        L"Domain") == 0)
                    {
                        if (pParsedPath->m_paKeys[i]->m_vValue.vt == VT_BSTR)
                            sReqDomain = pParsedPath->m_paKeys[i]->m_vValue.bstrVal;
                    }
                }
            }

            if(nStatus == 0)
            {
                objpathParser.Free(pParsedPath);
            }


            // If we got the names
            if (!sReqName.IsEmpty() && !sReqDomain.IsEmpty())
            {
                hr = WBEM_E_NOT_FOUND;

                // Only take this one if it is NOT from our machine's domain
                if (sOurDomain.CompareNoCase(sReqDomain) != 0)
                {
                    // Turn the domain/name into a sid
                    CSid sid(sReqDomain, sReqName, NULL);

                    if (sid.IsOK() && sid.IsAccountTypeValid())
                    {
                        CHString    sSid;
                        CRegistry   RegInfo;
                        HRESULT     hres;

                        // Turn the sid into a string
                        sid.StringFromSid(sid.GetPSid(), sSid);

                        // Use the string to open a registry key
                        sSid = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\"
                            + sSid;
                        if ((hres = RegInfo.Open(HKEY_LOCAL_MACHINE, sSid,
                            KEY_READ)) == ERROR_SUCCESS)
                        {
                            // If the key is there, we win!
                            hr = WBEM_S_NO_ERROR;
                        }
                        else if (hres == ERROR_ACCESS_DENIED)
                             hr = WBEM_E_ACCESS_DENIED;
                    }

                }
            }
        }
    }

	// an invalid namespace in the reference path constitutes a "NOT FOUND" for us
    if (hr == WBEM_E_INVALID_NAMESPACE)
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32SystemUsers::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32SystemUsers::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
   CNetAPI32 NetAPI;
   CHString sName, sDomain, sTemp, sOurDomain, strComputerName, sQuery1;
   HRESULT hr = WBEM_E_FAILED;
   CRegistry RegInfo1, RegInfo2;
   CInstancePtr pInstance;

   strComputerName = GetLocalComputerName();

   // Fire up the net api's
   if (NetAPI.Init() == ERROR_SUCCESS) {

#ifdef NTONLY
   WKSTA_INFO_100 *pstInfo;
   NET_API_STATUS dwStatus;

      {
         // Get the computer name and domain name
         if ((dwStatus = NetAPI.NetWkstaGetInfo(NULL, 100, (LPBYTE *)&pstInfo)) == NERR_Success)
         {
             try
             {
                 // If we are a domain controller, we want all the users in our domain, else all the users on our machine
                 if (NetAPI.IsDomainController(NULL))
                 {
                    sOurDomain = (WCHAR *)pstInfo->wki100_langroup;
                 }
                 else
                 {
                    sOurDomain = (WCHAR *)pstInfo->wki100_computername;
                 }
             }
             catch ( ... )
             {
                 NetAPI.NetApiBufferFree(pstInfo);
                 throw ;
             }

             NetAPI.NetApiBufferFree(pstInfo);
             hr = WBEM_S_NO_ERROR;
         }
         else
         {
             hr = WinErrorToWBEMhResult(GetLastError());
         }

      }
#endif

      CHString chstrNTAuth;
      GetNTAuthorityName(chstrNTAuth);

      if (SUCCEEDED(hr))
      {
          sTemp.Format(L"select name from win32_useraccount where domain = \"%s\"", sOurDomain);
          sQuery1 = L"SELECT __RELPATH FROM Win32_ComputerSystem";

          TRefPointerCollection<CInstance> Users;

          // get the path of the system
          CHString systemPath;
          TRefPointerCollection<CInstance> system;
          REFPTRCOLLECTION_POSITION posSystem;
//          if (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances("Win32_ComputerSystem", &system, NULL, pMethodContext)))
          if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &system, pMethodContext, IDS_CimWin32Namespace)))
          {
             // get the path of the system
             system.BeginEnum(posSystem);
             CInstancePtr pSystem(system.GetNext(posSystem), false);
             system.EndEnum();

             if (pSystem != NULL)
             {

                 if (GetLocalInstancePath(pSystem, systemPath)) {

                    // Now get all the users.  We use the query to allow win32_useraccount to optimize our request
                    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sTemp, &Users, pMethodContext, IDS_CimWin32Namespace))) {
                       REFPTRCOLLECTION_POSITION pos;
                       CInstancePtr pUser;

                       if (Users.BeginEnum(pos)) {
                          for (pUser.Attach(Users.GetNext( pos ));
                              (SUCCEEDED(hr)) && (pUser != NULL);
                              pUser.Attach(Users.GetNext( pos )))
                           {

                             // Match the user with the system and send it back
                             pInstance.Attach(CreateNewInstance(pMethodContext));
                             if (pInstance)
                             {
                                 pUser->GetCHString(IDS_Name, sName);
      //                         pUser->GetCHString(IDS_Domain, sDomain);

                                 // Note that this is an absolute path
                                 if(sOurDomain.CompareNoCase(chstrNTAuth) != 0)
                                 {
                                    sTemp.Format(
                                        L"\\\\%s\\%s:%s.%s=\"%s\",%s=\"%s\"", 
                                        strComputerName, 
                                        IDS_CimWin32Namespace, 
                                        L"Win32_UserAccount", 
                                        IDS_Name, 
                                        sName, 
                                        IDS_Domain, 
                                        sOurDomain);

                                     pInstance->SetCHString(IDS_PartComponent, sTemp);
                                     pInstance->SetCHString(IDS_GroupComponent, systemPath);

                                     hr = pInstance->Commit();
                                 }

                                
                             }
                             else
                             {
                                 hr = WBEM_E_OUT_OF_MEMORY;
                             }

                          }
                       }
                    }

                    // If we are on nt, let's get all the domain users that have logged in too
#ifdef NTONLY
                    if (SUCCEEDED(hr))
                    {
                       CHString strName;
                       CHString sSid;
                       HRESULT res;

                       // This is the list of users
                       if( (res = RegInfo1.Open(HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList", KEY_READ)) == ERROR_SUCCESS )	{

                          // Walk the keys
                          for( res = ERROR_SUCCESS ; (res == ERROR_SUCCESS) && SUCCEEDED(hr); res = RegInfo1.NextSubKey()) {

                             // Get the key name
                             // Open the child key under this key
                             // Get the SID property
                             if (((res = RegInfo1.GetCurrentSubKeyPath( strName )) == ERROR_SUCCESS ) &&
                                ((res = RegInfo2.Open(HKEY_LOCAL_MACHINE, strName, KEY_READ)) == ERROR_SUCCESS) &&
                                ((res = RegInfo2.GetCurrentKeyValue( L"Sid", sSid)) == ERROR_SUCCESS )) {

                                // Convert it to a CSid, since that will get us the UserName and Domain
                                CSid sid( (PSID) (LPCTSTR)sSid );

                                // If the conversion worked
                                if ( sid.IsOK() && sid.IsAccountTypeValid() ) {

                                   // Check the domain.  Don't need to do our domain, we got all those above
                                   sDomain = sid.GetDomainName();
                                   if (sDomain.CompareNoCase(sOurDomain) != 0) {

                                      // Ok, this looks like a goodie.  Pack it up and send it back
                                      sName = sid.GetAccountName();
                                      pInstance.Attach(CreateNewInstance( pMethodContext ));
                                      if (pInstance)
                                      {
                                          if(sDomain.CompareNoCase(chstrNTAuth) != 0)
                                          {
                                              sTemp.Format(
                                                L"\\\\%s\\%s:%s.%s=\"%s\",%s=\"%s\"", 
                                                strComputerName, 
                                                IDS_CimWin32Namespace, 
                                                L"Win32_UserAccount", 
                                                IDS_Name, 
                                                sName, 
                                                IDS_Domain, 
                                                sDomain);

                                              pInstance->SetCHString(IDS_PartComponent, sTemp);
                                              pInstance->SetCHString(IDS_GroupComponent, systemPath);

                                              hr = pInstance->Commit();
                                          }
                                      }
                                      else
                                          hr = WBEM_E_OUT_OF_MEMORY;
                                   }
                                }
                             } else if (res == ERROR_ACCESS_DENIED) {
                                 hr = WBEM_E_ACCESS_DENIED;
                             }
                          }
                       } else if (res == ERROR_ACCESS_DENIED) {
                                 hr = WBEM_E_ACCESS_DENIED;
                       }
                    }
#endif
                 }
             }
          }
      }
   }

   return hr;
}



// Need the string "NT AUTHORITY".  However, on non-english
// builds, this is something else.  Hence, get if from the
// sid.
void CWin32SystemUsers::GetNTAuthorityName(
    CHString& chstrNTAuth)
{
    PSID pSidNTAuthority = NULL;
	SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    CHString cstrAuthorityDomain;
	if (AllocateAndInitializeSid (&sia ,1,SECURITY_LOCAL_SYSTEM_RID,0,0,0,0,0,0,0,&pSidNTAuthority))
	{
		try
        {
            CSid sidNTAuth(pSidNTAuthority);
            chstrNTAuth = sidNTAuth.GetDomainName();
        }
        catch(...)
        {
            FreeSid(pSidNTAuthority);
            throw;
        }
		FreeSid(pSidNTAuthority);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32systemusers.h ===
//=================================================================

//

// Win32SystemUsers.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    3/6/99    davwoh         Extracted from grouppart.cpp
//
// Comment: 
//=================================================================

#define	PROPSET_NAME_SYSTEMUSER L"Win32_SystemUsers" 

class CWin32SystemUsers : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32SystemUsers( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32SystemUsers() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

    private:

        void GetNTAuthorityName(
            CHString& chstrNTAuth);


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomapplicationclasses.h ===
//=============================================================================================================

//

// Win32_ClassicCOMApplicationClasses.h -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#define  CLASSIC_COM_APP_CLASSES L"Win32_ClassicCOMApplicationClasses"

class Win32_ClassicCOMApplicationClasses : public Provider
{
public:
	Win32_ClassicCOMApplicationClasses (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_ClassicCOMApplicationClasses ();

	virtual HRESULT EnumerateInstances (MethodContext*  a_pMethodContext, long a_lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* a_pInstance, long a_lFlags = 0L );

private:	
	HRESULT Win32_ClassicCOMApplicationClasses::CreateInstances 
	( 
		
		CInstance* a_pComObject, 
		PSECURITY_DESCRIPTOR a_pSD, 
		MethodContext*  a_pMethodContext 
	) ;
	
	HRESULT Win32_ClassicCOMApplicationClasses::CheckInstance ( CInstance* a_pComObject, PSECURITY_DESCRIPTOR a_pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_1394controllerdevice.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN321394ControllerDevice.h
//
//  Purpose: Relationship between CIM_1394Controller and CIM_LogicalDevice
//
//***************************************************************************

#ifndef _WIN32_1394CONTROLLERDEVICE_H_
#define _WIN32_1394CONTROLLERDEVICE_H_


// Property set identification
//============================
#define PROPSET_NAME_WIN32_1394CONTROLLERDEVICE  L"Win32_1394ControllerDevice"

#include <vector>

typedef std::vector<CHString*> VECPCHSTR;

class CW32_1394CntrlDev;

class CW32_1394CntrlDev : public Provider 
{
    public:

        // Constructor/destructor
        //=======================
        CW32_1394CntrlDev(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32_1394CntrlDev() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);

    private:

        void CleanPCHSTRVec(VECPCHSTR& vec);
        HRESULT Generate1394DeviceList(const CHString& chstrControllerPNPID, 
                                      VECPCHSTR& vec);
        HRESULT RecursiveFillDeviceBranch(CConfigMgrDevice* pRootDevice, 
                                          VECPCHSTR& vec1394Devices); 
        HRESULT Process1394DeviceList(MethodContext* pMethodContext, 
                                     const CHString& chstrControllerRELPATH, 
                                     VECPCHSTR& vec1394Devices);
        HRESULT CreateAssociation(MethodContext* pMethodContext,
                                  const CHString& chstrControllerPATH, 
                                  const CHString& chstr1394Device);
        LONG FindInStringVector(const CHString& chstr1394DevicePNPID, 
                                VECPCHSTR& vec1394Devices);


//        HRESULT QueryForSubItemsAndCommit(CHString& chstrProgGrpPath,
//                                          CHString& chstrQuery,
//                                          MethodContext* pMethodContext);
//        HRESULT EnumerateInstancesNT(MethodContext* pMethodContex);
//        HRESULT EnumerateInstances9x(MethodContext* pMethodContext);
//
//        VOID RemoveDoubleBackslashes(CHString& chstrIn);



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclass.cpp ===
//=============================================================================================================

//

// Win32_ClassicCOMClass.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#include "precomp.h"
#include "Win32_ClassicCOMClass.h"
#include <cregcls.h>
#include <frqueryex.h>

// Property set declaration
//=========================

Win32_ClassicCOMClass MyWin32_ClassicCOMClass(PROPSET_NAME_CLASSIC_COM_CLASS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::Win32_ClassicCOMClass
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_ClassicCOMClass :: Win32_ClassicCOMClass (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::~Win32_ClassicCOMClass
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_ClassicCOMClass :: ~Win32_ClassicCOMClass ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::ExecQuery
 *
 *  DESCRIPTION : Creates an instance for each com class.  It only populates
 *                the requested properties.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClass :: ExecQuery(

    MethodContext *a_pMethodContext,
    CFrameworkQuery& a_pQuery,
    long a_lFlags /*= 0L*/
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR ;
	std::vector<_bstr_t> t_abstrtvectorClsids ;
	std::vector<_bstr_t>::iterator t_pbstrtTmpClsid ;
	CHString t_chsRegKeyPath = L"SOFTWARE\\Classes\\CLSID\\" ;
	t_hResult = a_pQuery.GetValuesForProp(L"ComponentId", t_abstrtvectorClsids ) ;
	if ( SUCCEEDED ( t_hResult ) && t_abstrtvectorClsids.size () )
	{
		for ( t_pbstrtTmpClsid = t_abstrtvectorClsids.begin (); t_pbstrtTmpClsid != t_abstrtvectorClsids.end (); t_pbstrtTmpClsid++ )
		{

			CRegistry t_RegInfo ;
			CHString t_chsClsid ( (PWCHAR)*t_pbstrtTmpClsid ) ;
			CInstancePtr t_pInstance  ;

			//Enumerate all the CLSID's present under HKEY_CLASSES_ROOT
			if ( t_RegInfo.Open (

									HKEY_LOCAL_MACHINE,
									t_chsRegKeyPath + (PWCHAR)*t_pbstrtTmpClsid,
									KEY_READ
								) == ERROR_SUCCESS
				)
			{
				t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;

				if ( t_pInstance != NULL )
				{
					t_pInstance->SetCHString ( IDS_ComponentId, t_chsClsid ) ;
					CHString t_chsTmp ;
					if ( t_RegInfo.GetCurrentKeyValue ( NULL, t_chsTmp ) == ERROR_SUCCESS )
					{
						t_pInstance->SetCHString ( IDS_Name, t_chsTmp ) ;
						t_pInstance->SetCHString ( IDS_Caption, t_chsTmp ) ;
						t_pInstance->SetCHString ( IDS_Description, t_chsTmp ) ;

						t_hResult = t_pInstance->Commit () ;
						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
					break ;
				}
			}
		}
	}
	else
	{
		t_hResult =  WBEM_E_PROVIDER_NOT_CAPABLE ;
	}

	return t_hResult ;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClass :: GetObject (

	CInstance *a_pInstance,
	long a_lFlags /*= 0L*/
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CHString t_chsClsid ;
	CRegistry t_RegInfo ;

	if ( a_pInstance->GetCHString ( IDS_ComponentId, t_chsClsid ) )
	{
		//check to see that the clsid is present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID
		if ( t_RegInfo.Open (
							HKEY_LOCAL_MACHINE,
							CHString ( _T("SOFTWARE\\Classes\\CLSID\\") ) + t_chsClsid,
							KEY_READ ) == ERROR_SUCCESS
						)
		{
			t_RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\CLSID", KEY_READ ) ;
			HKEY t_hParentKey = t_RegInfo.GethKey() ;

            DWORD t_dwBits = 0 ;

			t_hResult = FillInstanceWithProperites ( a_pInstance, t_hParentKey, t_chsClsid, &t_dwBits ) ;
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_INVALID_PARAMETER ;
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClass::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClass :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CRegistry t_RegInfo ;
	CHString t_chsClsid ;
	CInstancePtr t_pInstance  ;

	//Enumerate all the CLSID's present under HKEY_CLASSES_ROOT
	if ( t_RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\CLSID",
							KEY_READ ) == ERROR_SUCCESS  &&

		t_RegInfo.GetCurrentSubKeyCount() )
	{
		HKEY t_hTmpKey = t_RegInfo.GethKey() ;

		//skip the CLSID\CLSID subkey
		t_RegInfo.NextSubKey() ;
		do
		{
			if ( t_RegInfo.GetCurrentSubKeyName ( t_chsClsid ) == ERROR_SUCCESS )
			{
				t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;

				if ( t_pInstance != NULL )
				{
					DWORD t_dwBits = 0 ;

					t_hResult = FillInstanceWithProperites ( t_pInstance, t_hTmpKey, t_chsClsid, &t_dwBits ) ;
					if ( SUCCEEDED ( t_hResult ) )
					{
						t_hResult = t_pInstance->Commit () ;

						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( t_hResult == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					t_hResult = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( t_RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return t_hResult ;
}

HRESULT Win32_ClassicCOMClass :: FillInstanceWithProperites (

	CInstance *a_pInstance,
	HKEY a_hParentKey,
	CHString& a_rchsClsid,
    LPVOID a_dwProperties
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CRegistry t_ClsidRegInfo, t_TmpReg ;
	CHString t_chsTmp ;

	//open the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{clsid} key
	if ( t_ClsidRegInfo.Open ( a_hParentKey, a_rchsClsid, KEY_READ ) == ERROR_SUCCESS )
	{
		//set the clsid of the component
		a_pInstance->SetCHString ( IDS_ComponentId, a_rchsClsid ) ;

		//set the component name if present
		if ( t_ClsidRegInfo.GetCurrentKeyValue ( NULL, t_chsTmp ) == ERROR_SUCCESS )
		{
			a_pInstance->SetCHString ( IDS_Name, t_chsTmp ) ;
			a_pInstance->SetCHString ( IDS_Description, t_chsTmp ) ;
			a_pInstance->SetCHString ( IDS_Caption, t_chsTmp ) ;
		}

	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_1394controllerdevice.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN321394ControllerDevice.cpp
//
//  Purpose: Relationship between Win32_1394Controller and Win32_PNPEntity
//
//***************************************************************************

#include "precomp.h"

#include "WIN32_1394ControllerDevice.h"

// Property set declaration
//=========================
CW32_1394CntrlDev MyCW32_1394CntrlDev(PROPSET_NAME_WIN32_1394CONTROLLERDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::CW32_1394CntrlDev
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32_1394CntrlDev::CW32_1394CntrlDev(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::~CW32_1394CntrlDev
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32_1394CntrlDev::~CW32_1394CntrlDev()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32_1394CntrlDev::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString chstrAntecedent;
    CHString chstrDependent;
    if(pInstance != NULL)
    {
        CInstancePtr pinst1394Controller;
        CInstancePtr pinst1394Device;
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
        pInstance->GetCHString(IDS_Dependent, chstrDependent);
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrAntecedent, &pinst1394Controller, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDependent, &pinst1394Device, pInstance->GetMethodContext())))
            {
                // So there are instances in CIMOM of both.  Are they related?
                CHString chstr1394ControllerPNPID;
                CHString chstr1394DevicePNPID;
                pinst1394Controller->GetCHString(IDS_PNPDeviceID, chstr1394ControllerPNPID);
                pinst1394Device->GetCHString(IDS_PNPDeviceID, chstr1394DevicePNPID);
                if(chstr1394ControllerPNPID.GetLength() > 0 && chstr1394DevicePNPID.GetLength() > 0)
                {
                    VECPCHSTR vec1394Devices;
                    try
                    {
                        hr = Generate1394DeviceList(chstr1394ControllerPNPID, vec1394Devices);
                        if(SUCCEEDED(hr) && vec1394Devices.size() > 0L)
                        {
                            if(FindInStringVector(chstr1394DevicePNPID, vec1394Devices) > -1L)
                            {
                                // It would appear they are.
                                hr = WBEM_S_NO_ERROR;
                            }
                        }
                    }
                    catch ( ... )
                    {
                        CleanPCHSTRVec(vec1394Devices);
                        throw ;
                    }

                    CleanPCHSTRVec(vec1394Devices);
                }
            }
        }
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CW32_1394CntrlDev::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrControllersQuery(_T("SELECT __PATH, PNPDeviceID FROM Win32_1394Controller"));
    TRefPointerCollection<CInstance> ControllersList;
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrControllersQuery,
                                                        &ControllersList,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))
    {
        REFPTRCOLLECTION_POSITION pos;

        if(ControllersList.BeginEnum(pos))
        {
            CHString chstrControllerPNPID;
            CHString chstrControllerPATH;
            LONG lNum1394Devices = 0L;
            CInstancePtr pinstController;

            for (pinstController.Attach(ControllersList.GetNext(pos));
                 SUCCEEDED(hr) && (pinstController != NULL);
                 pinstController.Attach(ControllersList.GetNext(pos)))
            {
                pinstController->GetCHString(IDS_PNPDeviceID, chstrControllerPNPID);
                pinstController->GetCHString(IDS___Path, chstrControllerPATH);
                if(chstrControllerPNPID.GetLength() > 0 && chstrControllerPATH.GetLength() > 0)
                {
                    VECPCHSTR vec1394Devices;
                    try
                    {
                        hr = Generate1394DeviceList(chstrControllerPNPID, vec1394Devices);
                        if(SUCCEEDED(hr) && vec1394Devices.size() > 0L)
                        {
                            hr = Process1394DeviceList(pMethodContext, chstrControllerPATH, vec1394Devices);
                        }
                    }
                    catch ( ... )
                    {
                        CleanPCHSTRVec(vec1394Devices);
                        throw ;
                    }
                    CleanPCHSTRVec(vec1394Devices);
                }
                else
                {
                    hr = WBEM_E_FAILED; // PNPDeviceID and __RELPATH for 1394controller should never be empty
                }
            }
        }
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::Generate1394DeviceList
 *
 *  DESCRIPTION : This helper creates a list of devices hanging off the passed
 *                in device.
 *
 *  INPUTS      : vec1394Devices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPNPID, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32_1394CntrlDev::Generate1394DeviceList(const CHString& chstrControllerPNPID,
                                               VECPCHSTR& vec)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CConfigManager cfgManager;
    CConfigMgrDevicePtr pController;
    if(cfgManager.LocateDevice(chstrControllerPNPID, pController))
    {
        if(pController != NULL)
        {
            hr = RecursiveFillDeviceBranch(pController, vec);
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::RecursiveFillDeviceBranch
 *
 *  DESCRIPTION : This helper obtains all down branch devices starting with,
 *                but not including, pDevice.
 *
 *  INPUTS      : pDevice, a device to populate the children of;
 *                vec1394Devices, a list of devices to try to associate
 *                   to the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32_1394CntrlDev::RecursiveFillDeviceBranch(CConfigMgrDevice* pDevice,
                                                   VECPCHSTR& vec1394Devices)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(pDevice != NULL)
    {
        CConfigMgrDevicePtr pDeviceChild(NULL);
        if(pDevice->GetChild(pDeviceChild))
        {
            // Need this child's PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                if(chstrChildPNPDeviceID.GetLength() > 0)
                {
                    // Record this child...
                    CHString* pchstrTemp = NULL;
                    pchstrTemp = (CHString*) new CHString(chstrChildPNPDeviceID);
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            vec1394Devices.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            pchstrTemp = NULL;
                            throw ;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }

                    // Now do its children...
                    hr = RecursiveFillDeviceBranch(pDeviceChild, vec1394Devices);
                }
            }
            // Now call its brothers and sisters until none left (GetSibling
            // call will return FALSE):
            if(SUCCEEDED(hr))
            {
                CConfigMgrDevicePtr pDeviceSibling;
                if(pDeviceChild->GetSibling(pDeviceSibling))
                {
                    CConfigMgrDevicePtr pDeviceSiblingNext;
                    BOOL fContinue = TRUE;
                    CHString chstrSiblingPNPDeviceID;
                    while(SUCCEEDED(hr) && fContinue)
                    {
                        // Record the sibling now...
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            if(chstrSiblingPNPDeviceID.GetLength() > 0)
                            {
                                CHString* pchstrTemp = NULL;
                                pchstrTemp = (CHString*) new CHString(chstrSiblingPNPDeviceID);
                                if(pchstrTemp != NULL)
                                {
                                    try
                                    {
                                        vec1394Devices.push_back(pchstrTemp);
                                    }
                                    catch ( ... )
                                    {
                                        delete pchstrTemp;
                                        pchstrTemp = NULL;
                                        throw ;
                                    }
                                }
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }
                        }
                        // Then do the sibling's children...
                        hr = RecursiveFillDeviceBranch(pDeviceSibling, vec1394Devices);

                        // Then get the next sibling...
                        pDeviceSiblingNext = NULL;
                        fContinue = pDeviceSibling->GetSibling(pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling = pDeviceSiblingNext;
                    }
                }
            }
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::Process1394DeviceList
 *
 *  DESCRIPTION : This helper runs through the list, creating an association
 *                instance for each element in the list (vec1394Devices) with
 *                the controller (chstrControllerPNPID).
 *
 *  INPUTS      : pMethodContext;
 *                vec1394Devices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32_1394CntrlDev::Process1394DeviceList(MethodContext* pMethodContext,
                                              const CHString& chstrControllerPATH,
                                              VECPCHSTR& vec1394Devices)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrDevPATHAdj, chstrDevicePATH;

    for(LONG m = 0L; m < vec1394Devices.size() && SUCCEEDED(hr); m++)
    {

        EscapeBackslashes(*vec1394Devices[m], chstrDevPATHAdj);
        chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                               (LPCWSTR)GetLocalComputerName(),
                               IDS_CimWin32Namespace,
                               L"Win32_PNPEntity",
                               IDS_DeviceID,
                               (LPCWSTR)chstrDevPATHAdj);

        hr = CreateAssociation(pMethodContext, chstrControllerPATH, chstrDevicePATH);
    }
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::CreateAssociation
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : pMethodContext;
 *                1394Device, a device to associate with the controller
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper actually creates the association instance and
 *                commits it.
 *
 *****************************************************************************/
HRESULT CW32_1394CntrlDev::CreateAssociation(MethodContext* pMethodContext,
                                           const CHString& chstrControllerPATH,
                                           const CHString& chstrDevicePATH)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(pMethodContext != NULL)
    {

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            // Need to find an instance of the file
            pInstance->SetCHString(IDS_Antecedent, chstrControllerPATH);
            pInstance->SetCHString(IDS_Dependent, chstrDevicePATH);
            hr = pInstance->Commit();
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::FindInStringVector
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : chstr1394DevicePNPID, device to look for
 *                vec1394Devices, list of devices to look in
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG, number indicating 0 based offset into vec1394Devices of
 *                the found device, or -1 if not found.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CW32_1394CntrlDev::FindInStringVector(const CHString& chstr1394DevicePNPID,
                                         VECPCHSTR& vec1394Devices)
{
    LONG lPos = -1L;
    bool fFoundIt;
    for(LONG m = 0; m < vec1394Devices.size(); m++)
    {
        if(chstr1394DevicePNPID == *vec1394Devices[m])
        {
            fFoundIt = true;
            break;
        }
    }
    if(fFoundIt) lPos = m;
    return lPos;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32_1394CntrlDev::CleanPCHSTRVec
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : vec, a vector of CHString pointers
 *
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper deletes members of a vector that are pointers.
 *
 *****************************************************************************/
void CW32_1394CntrlDev::CleanPCHSTRVec(VECPCHSTR& vec)
{
    for(LONG m = 0L; m < vec.size(); m++)
    {
        delete vec[m];
    }
    vec.clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32usbcontrollerdevice.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32USBControllerDevice.cpp
//
//  Purpose: Relationship between CIM_USBController and CIM_LogicalDevice
//
//***************************************************************************

#include "precomp.h"
#include <vector>
#include "usb.h"
#include "PNPEntity.h"
#include "LPVParams.h"
#include <FRQueryEx.h>

#include "WIN32USBControllerDevice.h"

// Property set declaration
//=========================
CW32USBCntrlDev MyCW32USBCntrlDev(PROPSET_NAME_WIN32USBCONTROLLERDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::CW32USBCntrlDev
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CW32USBCntrlDev::CW32USBCntrlDev
(
    LPCWSTR setName,
    LPCWSTR pszNamespace
)
: CWin32USB(setName, pszNamespace),
  CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
    m_ptrProperties.SetSize(2);
    m_ptrProperties[0] = ((LPVOID) IDS_Antecedent);
    m_ptrProperties[1] = ((LPVOID) IDS_Dependent);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::~CW32USBCntrlDev
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CW32USBCntrlDev::~CW32USBCntrlDev()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::GetObject
(
    CInstance *pInstance,
    long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    if(pInstance != NULL)
    {
        CHString chstrAntecedent, chstrDependent;
        pInstance->GetCHString(IDS_Antecedent, chstrAntecedent);
        pInstance->GetCHString(IDS_Dependent, chstrDependent);

        // Obtain the antecedent's device id:
        CHString chstrAntecedentDevID = chstrAntecedent.Mid(chstrAntecedent.Find(_T('='))+2);
        chstrAntecedentDevID = chstrAntecedentDevID.Left(chstrAntecedentDevID.GetLength() - 1);
        CHString chstrAntecedentDevIDAdj;
        RemoveDoubleBackslashes(chstrAntecedentDevID,chstrAntecedentDevIDAdj);

        // Obtain the dependent's device id:
        CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
        chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
        CHString chstrDependentDevIDAdj;
        RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

        if(chstrAntecedentDevIDAdj.CompareNoCase(chstrDependentDevIDAdj))
        {
            CConfigManager cfgmgr;

            // Now see if the dependent is visible to config manager...
            CConfigMgrDevicePtr pPNPDevice;
            if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // It is. Does it exist at some level under a USBController?
                    CHString chstrControllerPNPID;
                    if(GetHighestUSBAncestor(pPNPDevice, chstrControllerPNPID))
                    {
                        // It does. Is it's PNP ID the same as that which we were given?
                        if(chstrAntecedentDevIDAdj.CompareNoCase(chstrControllerPNPID)==0)
                        {
                            hr = WBEM_S_NO_ERROR;
                        }
                    }
                }
            } 
        }
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CW32USBCntrlDev::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CW32USBCntrlDev::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwReqProps;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwReqProps);

    std::vector<_bstr_t> vecDependents;
    pQuery.GetValuesForProp(IDS_Dependent, vecDependents);
    DWORD dwDependents = vecDependents.size();

    if(dwDependents > 0)
    {
        for(LONG m = 0L; m < dwDependents; m++)
        {
            // Obtain the dependent's device id:
            CHString chstrDependent((LPCTSTR)vecDependents[m]);
            CHString chstrDependentDevID = chstrDependent.Mid(chstrDependent.Find(_T('='))+2);
            chstrDependentDevID = chstrDependentDevID.Left(chstrDependentDevID.GetLength() - 1);
            CHString chstrDependentDevIDAdj;
            RemoveDoubleBackslashes(chstrDependentDevID,chstrDependentDevIDAdj);

            CConfigManager cfgmgr;

            // Now see if the dependent is visible to config manager...
            CConfigMgrDevicePtr pPNPDevice;
            if(cfgmgr.LocateDevice(chstrDependentDevIDAdj, pPNPDevice))
            {
                // It is visible to config manager.  Is it a PNPDevice?
                if(CWin32PNPEntity::IsOneOfMe(pPNPDevice))
                {
                    // It is. Is its parent a USBController?
                    CHString chstrControllerPNPID;
                    if(GetHighestUSBAncestor(pPNPDevice, chstrControllerPNPID))
                    {
                        // It is, so create the association.
                        CHString chstrControllerPNPIDAdj;
                        EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                        CHString chstrControllerPATH;
                        chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                                   (LPCWSTR)GetLocalComputerName(),
                                                   IDS_CimWin32Namespace,
                                                   PROPSET_NAME_USB,
                                                   IDS_DeviceID,
                                                   (LPCWSTR)chstrControllerPNPIDAdj);

                        CHString chstrDevicePATH;
                        chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                               (LPCWSTR)GetLocalComputerName(),
                                               IDS_CimWin32Namespace,
                                               PROPSET_NAME_PNPEntity,
                                               IDS_DeviceID,
                                               (LPCWSTR)chstrDependentDevID);

                        hr = CreateAssociation(pMethodContext,
                                               chstrControllerPATH,
                                               chstrDevicePATH,
                                               dwReqProps);
                    }
                }
            }
        } // for
    }  // dwDependents > 0
    else
    {
        CWin32USB::Enumerate(pMethodContext, lFlags, dwReqProps);
    }
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::EnumerateInstances
 *
 *  DESCRIPTION : Enumerate is present here to prevent ambiguous upcasting to
 *                functions of the same name from both base classes.  The
 *                logic in LoadPropertyValues works when CWin32USB's (the
 *                USBController class) version of EnumerateInstances is called,
 *                so that is what we call here.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags
)
{
    return CWin32USB::Enumerate(pMethodContext, lFlags);
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework.  Called by the base class's
 *                EnumerateInstances function.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::LoadPropertyValues
(
    void* pv
)
{
    // Algorithm:
    // 1) Get all instances of CIM_USBController
    // 2) For each in #1, using cfg mgr, get its children, their children, etc.
    // 3) For each in #2, obtain DeviceID from cfg mgr, and look for instances of
    //    CIM_LogicalDevice with PNPDeviceIDs that match.
    // 4) For matches from #3, create association instances

    HRESULT hr = WBEM_S_NO_ERROR;
    CHString chstrControllerPNPID;
    CHString chstrControllerPATH;
    MethodContext* pMethodContext = NULL;

    // Unpack and confirm our parameters...
    CLPVParams* pData = (CLPVParams*)pv;
    CInstance* pInstance = (CInstance*)(pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pData->m_pDevice);
    DWORD dwReqProps = (DWORD)(pData->m_dwReqProps);
    if(pInstance == NULL || pDevice == NULL) return WBEM_E_FAILED;

    if((pMethodContext = pInstance->GetMethodContext()) != NULL)
    {
        VECPCHSTR vecUSBDevices;

        pDevice->GetDeviceID(chstrControllerPNPID);

        try
        {
            hr = GenerateUSBDeviceList(chstrControllerPNPID, vecUSBDevices);
            if(SUCCEEDED(hr) && vecUSBDevices.size() > 0L)
            {
                CHString chstrControllerPNPIDAdj;
                EscapeBackslashes(chstrControllerPNPID, chstrControllerPNPIDAdj);
                chstrControllerPATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                           (LPCWSTR)GetLocalComputerName(),
                                           IDS_CimWin32Namespace,
                                           PROPSET_NAME_USB,
                                           IDS_DeviceID,
                                           (LPCWSTR)chstrControllerPNPIDAdj);
                hr = ProcessUSBDeviceList(pMethodContext,
                                          chstrControllerPATH,
                                          vecUSBDevices,
                                          dwReqProps);
            }
        }
        catch ( ... )
        {
            CleanPCHSTRVec(vecUSBDevices);
            throw ;
        }

        CleanPCHSTRVec(vecUSBDevices);
    }

    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::GenerateUSBDeviceList
 *
 *  DESCRIPTION : This helper creates a list of devices hanging off the passed
 *                in device.
 *
 *  INPUTS      : vecUSBDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPNPID, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::GenerateUSBDeviceList
(
    const CHString& chstrControllerPNPID,
    VECPCHSTR& vec
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CConfigManager cfgManager;
    CConfigMgrDevicePtr pController;

    if(cfgManager.LocateDevice(chstrControllerPNPID, pController))
    {
        if(pController != NULL)
        {
            hr = RecursiveFillDeviceBranch(pController, vec);
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::RecursiveFillDeviceBranch
 *
 *  DESCRIPTION : This helper obtains all down branch devices starting with,
 *                but not including, pDevice.
 *
 *  INPUTS      : pDevice, a device to populate the children of;
 *                vecUSBDevices, a list of devices to try to associate
 *                   to the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::RecursiveFillDeviceBranch
(
    CConfigMgrDevice* pDevice,
    VECPCHSTR& vecUSBDevices
)
{
    CConfigMgrDevicePtr pDeviceChild;
    CConfigMgrDevicePtr pDeviceSibling;
    CConfigMgrDevicePtr pDeviceSiblingNext;
    CHString* pchstrTemp = NULL;

    HRESULT hr = WBEM_S_NO_ERROR;
    if(pDevice != NULL)
    {
        if(pDevice->GetChild(pDeviceChild))
        {
            // Need this child's PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                if(chstrChildPNPDeviceID.GetLength() > 0)
                {
                    // Record this child...
                    pchstrTemp = NULL;
                    pchstrTemp = (CHString*) new CHString(chstrChildPNPDeviceID);
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            vecUSBDevices.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            pchstrTemp = NULL;
                            throw ;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }

                    // If we've hit another controller, add this one (done above), but don't go
                    // any deeper.
                    if (!CWin32USB::IsOneOfMe(pDeviceChild))
                    {
                        hr = RecursiveFillDeviceBranch(pDeviceChild, vecUSBDevices);
                    }
                }
            }
            // Now call its brothers and sisters until none left (GetSibling
            // call will return FALSE):
            if(SUCCEEDED(hr))
            {
                if(pDeviceChild->GetSibling(pDeviceSibling))
                {
                    BOOL fContinue = TRUE;
                    CHString chstrSiblingPNPDeviceID;
                    while(SUCCEEDED(hr) && fContinue)
                    {
                        // Record the sibling now...
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            if(chstrSiblingPNPDeviceID.GetLength() > 0)
                            {
                                pchstrTemp = NULL;
                                pchstrTemp = (CHString*) new CHString(chstrSiblingPNPDeviceID);
                                if(pchstrTemp != NULL)
                                {
                                    try
                                    {
                                        vecUSBDevices.push_back(pchstrTemp);
                                    }
                                    catch ( ... )
                                    {
                                        delete pchstrTemp;
                                        pchstrTemp = NULL;
                                        throw ;
                                    }
                                }
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }
                        }

                        // If we've hit another controller, add this one (done above), but don't go
                        // any deeper.
                        if (!CWin32USB::IsOneOfMe(pDeviceSibling))
                        {
                            hr = RecursiveFillDeviceBranch(pDeviceSibling, vecUSBDevices);
                        }

                        // Then get the next sibling...
                        fContinue = pDeviceSibling->GetSibling(pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling = pDeviceSiblingNext;
                    }
                }
            }
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }
    return hr;
}



/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::ProcessUSBDeviceList
 *
 *  DESCRIPTION : This helper runs through the list, creating an association
 *                instance for each element in the list (vecUSBDevices) with
 *                the controller (chstrControllerPNPID).
 *
 *  INPUTS      : pMethodContext;
 *                vecUSBDevices, a list of devices to try to associate
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::ProcessUSBDeviceList
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    VECPCHSTR& vecUSBDevices,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    for(LONG m = 0L; m < vecUSBDevices.size() && SUCCEEDED(hr); m++)
    {
        // For each element of the vector, we need to see if there is an instance
        // of a win32_pnpentity that has the specified PNPDeviceID.
        CHString chstrDevicePATH, chstrDevPATHAdj;
        CConfigManager cfgmgr;

        // Let's see if config manager recognizes this device at all
        CConfigMgrDevicePtr pDevice;
        if(cfgmgr.LocateDevice(*vecUSBDevices[m], pDevice))
        {
            // Ok, it knows about it.  Is it a PNPDevice device?
            if(CWin32PNPEntity::IsOneOfMe(pDevice))
            {
                // It would appear that it is.  Create the association...
                EscapeBackslashes(*vecUSBDevices[m], chstrDevPATHAdj);
                chstrDevicePATH.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                                       (LPCWSTR)GetLocalComputerName(),
                                       IDS_CimWin32Namespace,
                                       PROPSET_NAME_PNPEntity,
                                       IDS_DeviceID,
                                       (LPCWSTR)chstrDevPATHAdj);

                hr = CreateAssociation(pMethodContext, chstrControllerPATH, chstrDevicePATH, dwReqProps);
            }
        }
    }
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::CreateAssociation
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : pMethodContext;
 *                USBDevice, a device to associate with the controller
 *                   to the device;
 *                chstrControllerPATH, the PNPDeviceID of the controller
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper actually creates the association instance and
 *                commits it.
 *
 *****************************************************************************/
HRESULT CW32USBCntrlDev::CreateAssociation
(
    MethodContext* pMethodContext,
    const CHString& chstrControllerPATH,
    const CHString& chstrDevicePATH,
    const DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;
    if(pMethodContext != NULL)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            if(dwReqProps & USBCTL_PROP_Antecedent ||
               dwReqProps & USBCTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Antecedent, chstrControllerPATH);
            }

            if(dwReqProps & USBCTL_PROP_Dependent ||
               dwReqProps & USBCTL_PROP_ALL_PROPS_KEY_ONLY)
            {
                pInstance->SetCHString(IDS_Dependent, chstrDevicePATH);
            }

            hr = pInstance->Commit();
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::FindInStringVector
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : chstrUSBDevicePNPID, device to look for
 *                vecUSBDevices, list of devices to look in
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG, number indicating 0 based offset into vecUSBDevices of
 *                the found device, or -1 if not found.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CW32USBCntrlDev::FindInStringVector
(
    const CHString& chstrUSBDevicePNPID,
    VECPCHSTR& vecUSBDevices
)
{
    LONG lPos = -1L;
    bool fFoundIt;
    for(LONG m = 0L; m < vecUSBDevices.size(); m++)
    {
        if(chstrUSBDevicePNPID == *vecUSBDevices[m])
        {
            fFoundIt = true;
            break;
        }
    }
    if(fFoundIt) lPos = m;
    return lPos;
}


/*****************************************************************************
 *
 *  FUNCTION    : CW32USBCntrlDev::CleanPCHSTRVec
 *
 *  DESCRIPTION : Creates a new association instance.
 *
 *  INPUTS      : vec, a vector of CHString pointers
 *
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : This helper deletes members of a vector that are pointers.
 *
 *****************************************************************************/
void CW32USBCntrlDev::CleanPCHSTRVec
(
    VECPCHSTR& vec
)
{
    for(LONG m = 0L; m < vec.size(); m++)
    {
        delete vec[m];
    }
    vec.clear();
}


// The highest USB ancestor of a given USB
// device should be the USB controller.
bool CW32USBCntrlDev::GetHighestUSBAncestor
(
    CConfigMgrDevice* pUSBDevice,
    CHString& chstrUSBControllerDeviceID
)
{  
    bool fRet = false;
    CConfigMgrDevicePtr pCurrent, pParent, pHighestUSB;

    if(pUSBDevice != NULL)
    {
        for(pCurrent = pUSBDevice, pHighestUSB = pUSBDevice; 
            pCurrent->GetParent(pParent); 
            pCurrent = pParent)
        {
            if(pParent->IsClass(L"USB"))
            {
                pHighestUSB = pParent;
            }
        }

        if((CConfigMgrDevice*)(pHighestUSB) != pUSBDevice)
        {
            // Exited loop because we couldn't get parent.  This
            // happens when we reach the top of the tree.
            // If we started out of class USB, and got this error,
            // it means we didn't have an ancestor of type USB
            // prior to reaching the base of the tree.  In such a
            // case, we are a USB controller, and are done.  
            fRet = (bool) pHighestUSB->GetDeviceID(chstrUSBControllerDeviceID);
        }
    }
    
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32usbcontrollerdevice.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  WIN32USBControllerDevice.h
//
//  Purpose: Relationship between CIM_USBController and CIM_LogicalDevice
//
//***************************************************************************

#ifndef _WIN32USBCONTROLLERDEVICE_H_
#define _WIN32USBCONTROLLERDEVICE_H_


#define USBCTL_PROP_ALL_PROPS                    0xFFFFFFFF
#define USBCTL_PROP_ALL_PROPS_KEY_ONLY           0x00000003
#define USBCTL_PROP_Antecedent                   0x00000001
#define USBCTL_PROP_Dependent                    0x00000002



// Property set identification
//============================
#define PROPSET_NAME_WIN32USBCONTROLLERDEVICE  L"Win32_USBControllerDevice"


typedef std::vector<CHString*> VECPCHSTR;

class CW32USBCntrlDev;

class CW32USBCntrlDev : public CWin32USB, public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================
        CW32USBCntrlDev(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CW32USBCntrlDev() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long a_Flags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L); 

    protected:

        // Functions inherrited from CWin32USB
        //====================================
        virtual HRESULT LoadPropertyValues(void* pvData);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        CHPtrArray m_ptrProperties;
        void CleanPCHSTRVec(VECPCHSTR& vec);
        HRESULT GenerateUSBDeviceList(const CHString& chstrControllerPNPID, 
                                      VECPCHSTR& vec);
        HRESULT RecursiveFillDeviceBranch(CConfigMgrDevice* pRootDevice, 
                                          VECPCHSTR& vecUSBDevices); 
        HRESULT ProcessUSBDeviceList(MethodContext* pMethodContext, 
                                     const CHString& chstrControllerRELPATH, 
                                     VECPCHSTR& vecUSBDevices,
                                     const DWORD dwReqProps);
        HRESULT CreateAssociation(MethodContext* pMethodContext,
                                  const CHString& chstrControllerPATH, 
                                  const CHString& chstrUSBDevice,
                                  const DWORD dwReqProps);
        LONG FindInStringVector(const CHString& chstrUSBDevicePNPID, 
                                VECPCHSTR& vecUSBDevices);
        bool GetHighestUSBAncestor(CConfigMgrDevice* pUSBDevice, CHString& chstrUSBControllerDeviceID);
};

// This derived class commits here, not in the base.
inline bool CW32USBCntrlDev::ShouldBaseCommit(void* pvData) { return false; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomapplicationclasses.cpp ===
//=============================================================================================================

//

// Win32_ClassicCOMApplicationClasses.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================
#include "precomp.h"
#include "Win32_ClassicCOMApplicationClasses.h"
#include <cregcls.h>

Win32_ClassicCOMApplicationClasses MyWin32_ClassicCOMApplicationClasses (

CLASSIC_COM_APP_CLASSES,
IDS_CimWin32Namespace
);


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMApplicationClasses::Win32_ClassicCOMApplicationClasses
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const WCHAR strName		- Name of the class
 *				  const WCHAR pszNameSpace	- CIM Namespace
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
Win32_ClassicCOMApplicationClasses::Win32_ClassicCOMApplicationClasses
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMApplicationClasses::~Win32_ClassicCOMApplicationClasses
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
Win32_ClassicCOMApplicationClasses::~Win32_ClassicCOMApplicationClasses ()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMApplicationClasses::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext* a_pMethodContext - Context to enum
 *													instance data in.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClassicCOMApplicationClasses::EnumerateInstances
(

	MethodContext *a_pMethodContext,
	long a_lFlags
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance> t_ComClassList ;
	CRegistry t_RegInfo ;
	CInstancePtr t_pComClassInstance  ;
	CInstancePtr t_pInstance  ;

	//get all instances of Win32_DCOMApplication
	if (
			t_RegInfo.Open (

				HKEY_LOCAL_MACHINE,
				CHString ( L"SOFTWARE\\Classes\\AppID" ),
				KEY_READ
				) == ERROR_SUCCESS
			&&

			SUCCEEDED (

				t_hResult = CWbemProviderGlue::GetInstancesByQuery (

										L"Select ComponentId, AppID FROM Win32_ClassicCOMClassSetting",
										&t_ComClassList, a_pMethodContext, GetNamespace()
									)
				)
		)
	{
		REFPTRCOLLECTION_POSITION	t_pos;

		if ( t_ComClassList.BeginEnum ( t_pos ) )
		{
			t_pComClassInstance.Attach ( t_ComClassList.GetNext( t_pos ) ) ;
			while ( t_pComClassInstance != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString t_chsComponentPath ;
				t_pComClassInstance->GetCHString ( IDS_ComponentId, t_chsComponentPath ) ;

				//get the AppID of the Win32_ClassicCOMClass
				VARIANT vAppid ;
				VariantInit ( &vAppid ) ;

				//check if the AppID entry is present
				if ( t_pComClassInstance->GetVariant( IDS_AppID, vAppid ) && V_VT ( &vAppid ) != VT_NULL )
				{
					_variant_t vartAppid ;
					vartAppid.Attach ( vAppid ) ;
					CHString t_chsAppid ( V_BSTR ( &vAppid ) ) ;
					CRegistry t_RegAppidInfo ;

					if ( t_RegAppidInfo.Open ( t_RegInfo.GethKey() , t_chsAppid, KEY_READ ) == ERROR_SUCCESS )
					{
						t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
						if ( t_pInstance != NULL )
						{
							CHString t_chsFullPath ;
							t_chsFullPath.Format (
													L"\\\\%s\\%s:%s.%s=\"%s\"",
													(LPCWSTR)GetLocalComputerName(),
													IDS_CimWin32Namespace,
													L"Win32_ClassicComClass",
													IDS_ComponentId,
													(LPCWSTR)t_chsComponentPath );
							t_pInstance->SetCHString ( IDS_PartComponent, t_chsFullPath ) ;

							t_chsFullPath.Format (
													L"\\\\%s\\%s:%s.%s=\"%s\"",
													(LPCWSTR)GetLocalComputerName(),
													IDS_CimWin32Namespace,
													L"Win32_DCOMApplication",
													IDS_AppID,
													( LPCWSTR ) t_chsAppid );
							t_pInstance->SetCHString ( IDS_GroupComponent, t_chsFullPath ) ;
							t_hResult =  t_pInstance->Commit ()  ;

							if ( SUCCEEDED ( t_hResult ) )
							{
							}
							else
							{
								break ;
							}
						}
						else
						{
							t_hResult = WBEM_E_OUT_OF_MEMORY ;
							break ;
						}
					}
				}

				t_pComClassInstance.Attach ( t_ComClassList.GetNext( t_pos ) ) ;
			}
			t_ComClassList.EndEnum () ;
		}
	}

	return t_hResult ;

}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMApplicationClasses::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance - Instance into which we
 *                                       retrieve data.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClassicCOMApplicationClasses::GetObject ( CInstance* a_pInstance, long a_lFlags )
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND;
    CHString t_chsClsid, t_chsApplication ;

	CInstancePtr t_pClassicCOMClass , t_pApplicationInstance ;

	a_pInstance->GetCHString ( IDS_PartComponent, t_chsClsid );
	a_pInstance->GetCHString ( IDS_GroupComponent, t_chsApplication );
	MethodContext *t_pMethodContext = a_pInstance->GetMethodContext();

	//check whether the end-pts. are present
	t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsClsid, &t_pClassicCOMClass, t_pMethodContext ) ;

	if ( SUCCEEDED ( t_hResult ) )
	{
		t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsApplication, &t_pApplicationInstance, t_pMethodContext ) ;
	}

	CRegistry t_RegInfo ;
	if ( SUCCEEDED ( t_hResult ) )
	{
		CHString t_chsAppID, t_chsTmp ;
		t_pApplicationInstance->GetCHString ( IDS_AppID, t_chsAppID ) ;
		t_pClassicCOMClass->GetCHString ( IDS_ComponentId, t_chsTmp ) ;

		if ( !t_chsAppID.IsEmpty () &&

			t_RegInfo.Open (

						HKEY_LOCAL_MACHINE,
						CHString ( L"SOFTWARE\\Classes\\CLSID\\" ) + t_chsTmp,
						KEY_READ
					) == ERROR_SUCCESS
			)
		{

			if (	t_RegInfo.GetCurrentKeyValue( L"AppID", t_chsTmp ) == ERROR_SUCCESS  &&
					! t_chsAppID.CompareNoCase ( t_chsTmp )
				)
				{
					t_hResult = WBEM_S_NO_ERROR ;
				}
				else
				{
					t_hResult = WBEM_E_NOT_FOUND ;
				}
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclass.h ===
//=============================================================================================================

//

// Win32_ClassicCOMClass.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

// Property set identification
//============================

#define PROPSET_NAME_CLASSIC_COM_CLASS L"Win32_ClassicCOMClass"


class Win32_ClassicCOMClass : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_ClassicCOMClass(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_ClassicCOMClass() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *a_pInstance, 
		long a_lFlags = 0L
	);

	HRESULT EnumerateInstances (

		MethodContext *a_pMethodContext, 
		long a_lFlags = 0L
	);

    HRESULT ExecQuery(
        
        MethodContext *a_pMethodContext, 
        CFrameworkQuery& a_pQuery, 
        long a_lFlags = 0L
    );

protected:
	
	HRESULT Win32_ClassicCOMClass :: FillInstanceWithProperites 
	( 
			CInstance *a_pInstance, 
			HKEY a_hParentKey, 
			CHString& a_rchsClsid, 
            LPVOID a_dwProperties
	) ;

private:

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_clientapplicationsetting.h ===
//=============================================================================================================

//

// Win32_ClientApplicationSetting.h

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#ifndef __Win32_ClientApplicationSetting_H_
#define __Win32_ClientApplicationSetting_H_

#define  DCOM_CLIENT_APP_SETTING L"Win32_ClientApplicationSetting"

class Win32_ClientApplicationSetting : public Provider
{
private:
protected:
public:
	Win32_ClientApplicationSetting (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_ClientApplicationSetting ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

	virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);


private:	
	HRESULT Win32_ClientApplicationSetting::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_ClientApplicationSetting::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
	PWCHAR Win32_ClientApplicationSetting::GetFileName ( bstr_t& bstrtTmp ) ;

	BOOL Win32_ClientApplicationSetting::FileNameExists ( CHString& file );
};	

#endif //__Win32_ClientApplicationSetting_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclasssettings.h ===
//=============================================================================================================

//

// Win32_ClassicCOMClassSettings.h -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#define  CLASSIC_COM_SETTING L"Win32_ClassicCOMClassSettings"

class Win32_ClassicCOMClassSettings : public Provider
{
public:
	Win32_ClassicCOMClassSettings (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_ClassicCOMClassSettings ();

	virtual HRESULT EnumerateInstances (MethodContext*  a_pMethodContext, long a_lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* a_pInstance, long a_lFlags = 0L );

private:	
	HRESULT Win32_ClassicCOMClassSettings::CreateInstances 
	( 
		
		CInstance* a_pComObject, 
		PSECURITY_DESCRIPTOR a_pSD, 
		MethodContext*  a_pMethodContext 
	) ;
	
	HRESULT Win32_ClassicCOMClassSettings::CheckInstance ( CInstance* a_pComObject, PSECURITY_DESCRIPTOR a_pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclasssettings.cpp ===
//=============================================================================================================

//

// Win32_ClassicCOMClassSettings.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================
#include "precomp.h"
#include "Win32_ClassicCOMClassSettings.h"

Win32_ClassicCOMClassSettings MyWin32_ClassicCOMClassSettings (

CLASSIC_COM_SETTING,
IDS_CimWin32Namespace
);


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSettings::Win32_ClassicCOMClassSettings
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const WCHAR strName		- Name of the class
 *				  const WCHAR pszNameSpace	- CIM Namespace
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
Win32_ClassicCOMClassSettings::Win32_ClassicCOMClassSettings
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSettings::~Win32_ClassicCOMClassSettings
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
Win32_ClassicCOMClassSettings::~Win32_ClassicCOMClassSettings ()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSettings::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext* a_pMethodContext - Context to enum
 *													instance data in.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClassicCOMClassSettings::EnumerateInstances
(

	MethodContext *a_pMethodContext,
	long a_lFlags
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance> t_ClassicComList ;

	CInstancePtr t_pClassicCOMClass  ;
	CInstancePtr t_pInstance  ;

	//get all instances of Win32_DCOMApplication
	if ( SUCCEEDED ( t_hResult = CWbemProviderGlue::GetInstancesByQuery ( L"Select __relpath, ComponentId FROM Win32_ClassicCOMClass",
		&t_ClassicComList, a_pMethodContext, GetNamespace() ) ) )
	{
		REFPTRCOLLECTION_POSITION	t_pos;

		if ( t_ClassicComList.BeginEnum ( t_pos ) )
		{
			t_pClassicCOMClass.Attach ( t_ClassicComList.GetNext( t_pos ) ) ;
			while ( t_pClassicCOMClass != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString t_chsComponentPath ;
				t_pClassicCOMClass->GetCHString ( L"__RELPATH", t_chsComponentPath ) ;

				//get the AppID of the Win32_ClassicCOMClass
				VARIANT vClsid ;
				VariantInit ( &vClsid ) ;

				//check if the AppID entry is present
				if ( t_pClassicCOMClass->GetVariant( IDS_ComponentId, vClsid ) && V_VT ( &vClsid ) != VT_NULL )
				{
					_variant_t vartClsid ;
					vartClsid.Attach ( vClsid ) ;
					CHString t_chsClsid ( V_BSTR ( &vClsid ) ) ;

					t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
					if ( t_pInstance != NULL )
					{
						CHString t_chsFullPath ;
						t_chsFullPath.Format (
												L"\\\\%s\\%s:%s",
												(LPCWSTR)GetLocalComputerName(),
												IDS_CimWin32Namespace,
												(LPCWSTR)t_chsComponentPath );
						t_pInstance->SetCHString ( IDS_Element, t_chsFullPath ) ;

						t_chsFullPath.Format (
												L"\\\\%s\\%s:%s.%s=\"%s\"",
												(LPCWSTR)GetLocalComputerName(),
												IDS_CimWin32Namespace,
												L"Win32_ClassicCOMClassSetting",
												IDS_ComponentId,
												( LPCWSTR ) t_chsClsid );
						t_pInstance->SetCHString ( IDS_Setting, t_chsFullPath ) ;
						t_hResult =  t_pInstance->Commit ()  ;

						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
					else
					{
						t_hResult = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}

				t_pClassicCOMClass.Attach ( t_ClassicComList.GetNext( t_pos ) ) ;
			}
			t_ClassicComList.EndEnum () ;
		}
	}

	return t_hResult ;

}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSettings::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance - Instance into which we
 *                                       retrieve data.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClassicCOMClassSettings::GetObject ( CInstance* a_pInstance, long a_lFlags )
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND;
    CHString t_chsClsid, t_chsSetting ;

	CInstancePtr t_pSettingInstance , t_pClsidInstance  ;

	a_pInstance->GetCHString ( IDS_Element, t_chsClsid );
	a_pInstance->GetCHString ( IDS_Setting, t_chsSetting );
	MethodContext *t_pMethodContext = a_pInstance->GetMethodContext();

	//check whether the end-pts. are present
	t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsClsid, &t_pClsidInstance, t_pMethodContext ) ;

	if ( SUCCEEDED ( t_hResult ) )
	{
		t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsSetting, &t_pSettingInstance, t_pMethodContext ) ;
	}

	if ( SUCCEEDED ( t_hResult ) )
	{
		CHString t_chsClsid, t_chsTmp ;
		t_pClsidInstance->GetCHString ( IDS_ComponentId, t_chsClsid ) ;
		t_pSettingInstance->GetCHString ( IDS_ComponentId, t_chsTmp ) ;

		if (	!t_chsClsid.IsEmpty () &&
				!t_chsClsid.CompareNoCase ( t_chsTmp )
			)
		{
			t_hResult = WBEM_S_NO_ERROR ;
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclasssetting.cpp ===
//=============================================================================================================

//

// Win32_ClassicCOMClassSetting.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#include "precomp.h"
#include "Win32_ClassicCOMClassSetting.h"
#include <cregcls.h>
#include <frqueryex.h>

// Property set declaration
//=========================

Win32_ClassicCOMClassSetting MyWin32_ClassicCOMClassSetting(PROPSET_NAME_CLASSIC_COM_CLASS_SETTING, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::Win32_ClassicCOMClassSetting
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_ClassicCOMClassSetting :: Win32_ClassicCOMClassSetting (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{

    m_ptrProperties.SetSize(24);

    m_ptrProperties[0] = ( (LPVOID) IDS_AppID );
    m_ptrProperties[1] = ( (LPVOID) IDS_AutoConvertToClsid );
    m_ptrProperties[2] = ( (LPVOID) IDS_AutoTreatAsClsid );
    m_ptrProperties[3] = ( (LPVOID) IDS_ComponentId );
    m_ptrProperties[4] = ( (LPVOID) IDS_Control );
    m_ptrProperties[5] = ( (LPVOID) IDS_DefaultIcon );
    m_ptrProperties[6] = ( (LPVOID) IDS_InprocServer );
    m_ptrProperties[7] = ( (LPVOID) IDS_InprocServer32 );
    m_ptrProperties[8] = ( (LPVOID) IDS_Insertable );
    m_ptrProperties[9] = ( (LPVOID) IDS_InprocHandler );
    m_ptrProperties[10] = ( (LPVOID) IDS_InprocHandler32 );
    m_ptrProperties[11] = ( (LPVOID) IDS_JavaClass );
    m_ptrProperties[12] = ( (LPVOID) IDS_LocalServer );
    m_ptrProperties[13] = ( (LPVOID) IDS_LocalServer32 );
    m_ptrProperties[14] = ( (LPVOID) IDS_LongDisplayName );
    m_ptrProperties[15] = ( (LPVOID) IDS_Name );
    m_ptrProperties[16] = ( (LPVOID) IDS_ProgId );
    m_ptrProperties[17] = ( (LPVOID) IDS_ShortDisplayName );
    m_ptrProperties[18] = ( (LPVOID) IDS_ThreadingModel );
    m_ptrProperties[19] = ( (LPVOID) IDS_ToolBoxBitmap32 );
    m_ptrProperties[20] = ( (LPVOID) IDS_TreatAsClsid );
    m_ptrProperties[21] = ( (LPVOID) IDS_TypeLibraryId );
    m_ptrProperties[22] = ( (LPVOID) IDS_Version );
    m_ptrProperties[23] = ( (LPVOID) IDS_VersionIndependentProgId  );

}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::~Win32_ClassicCOMClassSetting
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_ClassicCOMClassSetting :: ~Win32_ClassicCOMClassSetting ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::ExecQuery
 *
 *  DESCRIPTION : Creates an instance for each com class.  It only populates
 *                the requested properties.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClassSetting :: ExecQuery(

    MethodContext *a_pMethodContext,
    CFrameworkQuery& a_pQuery,
    long a_lFlags /*= 0L*/
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR ;
	DWORD t_dwBits[(BIT_LAST_ENTRY + 32)/32];

    CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx *>(&a_pQuery);  // for use far below to check IfNTokenAnd
    t_pQuery2->GetPropertyBitMask ( m_ptrProperties, &t_dwBits ) ;

	CRegistry t_RegInfo ;
	CHString t_chsClsid ;

	CInstancePtr t_pInstance  ;

	//Enumerate all the CLSID's present under HKEY_CLASSES_ROOT
	if ( t_RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\CLSID",
							KEY_READ ) == ERROR_SUCCESS  &&

		t_RegInfo.GetCurrentSubKeyCount() )
	{
		HKEY t_hTmpKey = t_RegInfo.GethKey() ;

		//skip the CLSID\CLSID subkey
		t_RegInfo.NextSubKey() ;
		do
		{
			if ( t_RegInfo.GetCurrentSubKeyName ( t_chsClsid ) == ERROR_SUCCESS )
			{
				t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;

				if ( t_pInstance != NULL )
				{
					t_hResult = FillInstanceWithProperites ( t_pInstance, t_hTmpKey, t_chsClsid, &t_dwBits ) ;
					if ( SUCCEEDED ( t_hResult ) )
					{
						t_hResult = t_pInstance->Commit () ;
						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( t_hResult == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					t_hResult = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( t_RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return t_hResult ;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClassSetting :: GetObject (

	CInstance *a_pInstance,
	long a_lFlags,
    CFrameworkQuery& a_pQuery

)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CHString t_chsClsid ;
	CRegistry t_RegInfo ;

	if ( a_pInstance->GetCHString ( IDS_ComponentId, t_chsClsid ) )
	{
		//check to see that the clsid is present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID
		if ( t_RegInfo.Open (
							HKEY_LOCAL_MACHINE,
							CHString ( _T("SOFTWARE\\Classes\\CLSID\\") ) + t_chsClsid,
							KEY_READ ) == ERROR_SUCCESS
						)
		{
			t_RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\CLSID", KEY_READ ) ;
			HKEY t_hParentKey = t_RegInfo.GethKey() ;

	        DWORD t_dwBits[(BIT_LAST_ENTRY + 32)/32];

            CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx *>(&a_pQuery);  // for use far below to check IfNTokenAnd
            t_pQuery2->GetPropertyBitMask ( m_ptrProperties, &t_dwBits ) ;

			t_hResult = FillInstanceWithProperites ( a_pInstance, t_hParentKey, t_chsClsid, &t_dwBits ) ;
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_INVALID_PARAMETER ;
	}

	return t_hResult ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClassicCOMClassSetting::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ClassicCOMClassSetting :: EnumerateInstances (

	MethodContext *a_pMethodContext,
	long a_lFlags /*= 0L*/
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CRegistry t_RegInfo ;
	CHString t_chsClsid ;
	CInstancePtr t_pInstance  ;

	//Enumerate all the CLSID's present under HKEY_CLASSES_ROOT
	if ( t_RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\CLSID",
							KEY_READ ) == ERROR_SUCCESS  &&

		t_RegInfo.GetCurrentSubKeyCount() )
	{
		HKEY t_hTmpKey = t_RegInfo.GethKey() ;

		//skip the CLSID\CLSID subkey
		t_RegInfo.NextSubKey() ;
		do
		{
			if ( t_RegInfo.GetCurrentSubKeyName ( t_chsClsid ) == ERROR_SUCCESS )
			{
				t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;

				if ( t_pInstance != NULL )
				{
					DWORD t_dwBits[(BIT_LAST_ENTRY + 32)/32];

					SetAllBits ( t_dwBits, BIT_LAST_ENTRY ) ;
					t_hResult = FillInstanceWithProperites ( t_pInstance, t_hTmpKey, t_chsClsid, t_dwBits ) ;
					if ( SUCCEEDED ( t_hResult ) )
					{
						t_hResult = t_pInstance->Commit () ;

						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( t_hResult == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					t_hResult = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( t_RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return t_hResult ;
}

HRESULT Win32_ClassicCOMClassSetting :: FillInstanceWithProperites (

	CInstance *a_pInstance,
	HKEY a_hParentKey,
	CHString& a_rchsClsid,
    LPVOID a_dwProperties
)
{
	HRESULT t_hResult = WBEM_S_NO_ERROR ;
	CRegistry t_ClsidRegInfo, t_TmpReg ;
	CHString t_chsTmp ;

	//open the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{clsid} key
	if ( t_ClsidRegInfo.Open ( a_hParentKey, a_rchsClsid, KEY_READ ) == ERROR_SUCCESS )
	{
		HKEY t_hClsidKey = t_ClsidRegInfo.GethKey() ;

		//set the clsid of the component
		a_pInstance->SetCHString ( IDS_ComponentId, a_rchsClsid ) ;

		//set the component name if present
		if ( t_ClsidRegInfo.GetCurrentKeyValue ( NULL, t_chsTmp ) == ERROR_SUCCESS )
		{
			a_pInstance->SetCHString ( IDS_Caption, t_chsTmp ) ;
			a_pInstance->SetCHString ( IDS_Description, t_chsTmp ) ;
		}

		//find if AppID is present
		if ( IsBitSet( a_dwProperties, BIT_AppID ) && ( t_ClsidRegInfo.GetCurrentKeyValue( L"AppID", t_chsTmp ) == ERROR_SUCCESS ) )
		{
			a_pInstance->SetCHString ( IDS_AppID, t_chsTmp ) ;
		}

		//find if the "Control" subkey is present
        if ( IsBitSet ( a_dwProperties, BIT_Control ))
        {
		    if ( t_TmpReg.Open ( t_hClsidKey, L"Control", KEY_READ ) == ERROR_SUCCESS )
		    {
			    a_pInstance->Setbool ( IDS_Control, true ) ;
		    }
		    else
		    {
			    a_pInstance->Setbool ( IDS_Control, false ) ;
		    }
        }

        if ( IsBitSet ( a_dwProperties, BIT_Insertable ))
        {
		    //find if the "Insertable" subkey is present
		    if ( t_TmpReg.Open ( t_hClsidKey, L"Insertable", KEY_READ ) == ERROR_SUCCESS )
		    {
			    a_pInstance->Setbool ( IDS_Insertable, true ) ;
		    }
		    else
		    {
			    a_pInstance->Setbool ( IDS_Insertable, false ) ;
		    }
        }

        if ( IsBitSet ( a_dwProperties, BIT_JavaClass ) ||
             IsBitSet ( a_dwProperties, BIT_InprocServer32) ||
             IsBitSet ( a_dwProperties, BIT_ThreadingModel ) )
        {
		    //find if the InProcServer32 subkey is present
		    if ( t_TmpReg.Open ( t_hClsidKey, L"InprocServer32", KEY_READ ) == ERROR_SUCCESS )
		    {
			    //check if the "JavaClass" named value is present
                if ( IsBitSet ( a_dwProperties, BIT_JavaClass)  || IsBitSet ( a_dwProperties, BIT_InprocServer32 ) )
                {
			        if ( t_TmpReg.GetCurrentKeyValue( L"JavaClass", t_chsTmp )  == ERROR_SUCCESS )
			        {
				        a_pInstance->Setbool ( IDS_JavaClass, true ) ;
				        a_pInstance->SetCHString ( IDS_InprocServer32, t_chsTmp ) ;
			        }
			        else
			        {
				        a_pInstance->Setbool ( IDS_JavaClass, false ) ;
				        if ( IsBitSet ( a_dwProperties, BIT_InprocServer32 ) && ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS ) )
				        {
					        a_pInstance->SetCHString ( IDS_InprocServer32, t_chsTmp ) ;
				        }
			        }
                }

			    //check the threading model
			    if ( IsBitSet ( a_dwProperties, BIT_ThreadingModel ) && ( t_TmpReg.GetCurrentKeyValue( L"ThreadingModel", t_chsTmp )  == ERROR_SUCCESS ) )
			    {
				    a_pInstance->SetCHString ( IDS_ThreadingModel, t_chsTmp ) ;
			    }
		    }
		    else
		    {
			    a_pInstance->Setbool ( IDS_JavaClass, false ) ;
		    }
        }

		//find if the InProcServer subkey is present
		if ( IsBitSet ( a_dwProperties,  BIT_InprocServer ) && ( t_TmpReg.Open ( t_hClsidKey, L"InprocServer", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_InprocServer, t_chsTmp ) ;
			}
		}

		//find if the LocalServer32 subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_LocalServer32 ) && ( t_TmpReg.Open ( t_hClsidKey, L"LocalServer32", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_LocalServer32, t_chsTmp ) ;
			}
		}

		//find if the LocalServer subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_LocalServer ) && ( t_TmpReg.Open ( t_hClsidKey, L"LocalServer", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_LocalServer, t_chsTmp ) ;
			}
		}

		//find if the InprocHandler32 subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_InprocHandler32 ) && ( t_TmpReg.Open ( t_hClsidKey, L"InprocHandler32", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_InprocHandler32, t_chsTmp ) ;
			}
		}

		//find if the InprocHandler subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_InprocHandler ) && ( t_TmpReg.Open ( t_hClsidKey, L"InprocHandler", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_InprocHandler, t_chsTmp ) ;
			}
		}

		//find if the TreatAs subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_TreatAsClsid ) && ( t_TmpReg.Open ( t_hClsidKey, L"TreatAs", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_TreatAsClsid, t_chsTmp ) ;
			}
		}

		//find if the AutoTreatAs subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_AutoTreatAsClsid ) && ( t_TmpReg.Open ( t_hClsidKey, L"AutoTreatAs", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_AutoTreatAsClsid, t_chsTmp ) ;
			}
		}

		//find if the ProgId subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_ProgId ) && ( t_TmpReg.Open ( t_hClsidKey, L"ProgID", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue ( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_ProgId, t_chsTmp ) ;
			}
		}

		//find if the VersionIndependentProgId subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_VersionIndependentProgId ) && ( t_TmpReg.Open ( t_hClsidKey, L"VersionIndependentProgId", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_VersionIndependentProgId, t_chsTmp ) ;
			}
		}

		//find if the TypeLib subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_TypeLibraryId ) && ( t_TmpReg.Open ( t_hClsidKey, L"TypeLib", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_TypeLibraryId, t_chsTmp ) ;
			}
		}

		//TODO:get hlp/tlb file

		//find if the Version subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_Version ) && ( t_TmpReg.Open ( t_hClsidKey, L"Version", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_Version, t_chsTmp ) ;
			}
		}

		//find if the AutoConvertTo subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_AutoConvertToClsid ) && ( t_TmpReg.Open ( t_hClsidKey, L"AutoConvertTo", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_AutoConvertToClsid, t_chsTmp ) ;
			}
		}

		//find if the DefaultIcon subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_DefaultIcon ) && ( t_TmpReg.Open ( t_hClsidKey, L"DefaultIcon", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_DefaultIcon, t_chsTmp ) ;
			}
		}

		//find if the ToolBoxBitmap32 subkey is present
		if ( IsBitSet ( a_dwProperties, BIT_ToolBoxBitmap32 ) && ( t_TmpReg.Open ( t_hClsidKey, L"ToolBoxBitmap32", KEY_READ ) == ERROR_SUCCESS ) )
		{
			if ( t_TmpReg.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
			{
				a_pInstance->SetCHString ( IDS_ToolBoxBitmap32, t_chsTmp ) ;
			}
		}

		// Find if the Short & Long display names are present
		// These are stored as :
		// 1.	HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\AuxUserType\2 = <ShortDisplayName>
		// 2.	HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\AuxUserType\3 = <ApplicationName>
        if ( IsBitSet ( a_dwProperties, BIT_ShortDisplayName ) || IsBitSet ( a_dwProperties, BIT_LongDisplayName ) )
        {
		    if ( t_TmpReg.Open ( t_hClsidKey, L"AuxUserType", KEY_READ ) == ERROR_SUCCESS )
		    {
			    CRegistry t_RegAuxUsrType ;
			    if ( IsBitSet ( a_dwProperties,  BIT_ShortDisplayName ) && ( t_RegAuxUsrType.Open ( t_TmpReg.GethKey (), L"2", KEY_READ ) == ERROR_SUCCESS ) )
			    {
				    if ( t_RegAuxUsrType.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
				    {
					    a_pInstance->SetCHString ( IDS_ShortDisplayName, t_chsTmp ) ;
				    }
			    }

			    if ( IsBitSet ( a_dwProperties,  BIT_LongDisplayName ) && ( t_RegAuxUsrType.Open ( t_TmpReg.GethKey (), L"3", KEY_READ ) == ERROR_SUCCESS ) )
			    {
				    if ( t_RegAuxUsrType.GetCurrentKeyValue( NULL, t_chsTmp )  == ERROR_SUCCESS )
				    {
					    a_pInstance->SetCHString ( IDS_LongDisplayName, t_chsTmp ) ;
				    }
			    }
		    }
        }
	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_classiccomclasssetting.h ===
//=============================================================================================================

//

// Win32_ClassicCOMClassSetting.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

// Property set identification
//============================

#define PROPSET_NAME_CLASSIC_COM_CLASS_SETTING L"Win32_ClassicCOMClassSetting"

#define BIT_AppID 0
#define BIT_AutoConvertToClsid 1
#define BIT_AutoTreatAsClsid 2
#define BIT_ComponentId 3
#define BIT_Control 4
#define BIT_DefaultIcon 5
#define BIT_InprocServer 6
#define BIT_InprocServer32 7
#define BIT_Insertable 8
#define BIT_InprocHandler 9
#define BIT_InprocHandler32 10
#define BIT_JavaClass 11
#define BIT_LocalServer 12
#define BIT_LocalServer32 13
#define BIT_LongDisplayName 14
#define BIT_Name 15
#define BIT_ProgId 16
#define BIT_ShortDisplayName 17
#define BIT_ThreadingModel 18
#define BIT_ToolBoxBitmap32 19
#define BIT_TreatAsClsid 20
#define BIT_TypeLibraryId 21
#define BIT_Version 22
#define BIT_VersionIndependentProgId 23

#define BIT_LAST_ENTRY BIT_VersionIndependentProgId

class Win32_ClassicCOMClassSetting : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_ClassicCOMClassSetting(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_ClassicCOMClassSetting() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *a_pInstance, 
		long a_lFlags,
        CFrameworkQuery& a_pQuery
	);

	HRESULT EnumerateInstances (

		MethodContext *a_pMethodContext, 
		long a_lFlags = 0L
	);

    HRESULT ExecQuery(
        
        MethodContext *a_pMethodContext, 
        CFrameworkQuery& a_pQuery, 
        long a_lFlags = 0L
    );

protected:
	
	HRESULT Win32_ClassicCOMClassSetting :: FillInstanceWithProperites 
	( 
			CInstance *a_pInstance, 
			HKEY a_hParentKey, 
			CHString& a_rchsClsid, 
            LPVOID a_dwProperties
	) ;

private:
    CHPtrArray m_ptrProperties;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comapplicationsettings.cpp ===
//=============================================================================================================

//

// Win32_COMApplicationSettings.CPP -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================
#include "precomp.h"
#include "Win32_COMApplicationSettings.h"

Win32_COMApplicationSettings MyWin32_COMApplicationSettings (

COM_APP_SETTING,
IDS_CimWin32Namespace
);


/*****************************************************************************
 *
 *  FUNCTION    : Win32_COMApplicationSettings::Win32_COMApplicationSettings
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const WCHAR strName		- Name of the class
 *				  const WCHAR pszNameSpace	- CIM Namespace
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
Win32_COMApplicationSettings::Win32_COMApplicationSettings
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_COMApplicationSettings::~Win32_COMApplicationSettings
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/
Win32_COMApplicationSettings::~Win32_COMApplicationSettings ()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_COMApplicationSettings::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext* a_pMethodContext - Context to enum
 *													instance data in.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_COMApplicationSettings::EnumerateInstances
(

	MethodContext *a_pMethodContext,
	long a_lFlags
)
{
    HRESULT t_hResult = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance> t_DCOMAppList ;

	CInstancePtr t_pDCOMAppInstance  ;
	CInstancePtr t_pInstance  ;

	//get all instances of Win32_DCOMApplication
	if ( SUCCEEDED ( t_hResult = CWbemProviderGlue::GetInstancesByQuery ( L"Select __relpath, AppID FROM Win32_DCOMApplication",
		&t_DCOMAppList, a_pMethodContext, GetNamespace() ) ) )
	{
		REFPTRCOLLECTION_POSITION	t_pos;

		if ( t_DCOMAppList.BeginEnum ( t_pos ) )
		{
			t_pDCOMAppInstance.Attach ( t_DCOMAppList.GetNext( t_pos ) ) ;
			while ( t_pDCOMAppInstance != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString t_chsComponentPath ;
				t_pDCOMAppInstance->GetCHString ( L"__RELPATH", t_chsComponentPath ) ;

				//get the AppID of the Win32_ClassicCOMClass
				VARIANT vAppid ;
				VariantInit ( &vAppid ) ;

				//check if the AppID entry is present
				if ( t_pDCOMAppInstance->GetVariant( IDS_AppID, vAppid ) && V_VT ( &vAppid ) != VT_NULL )
				{
					_variant_t vartAppid ;
					vartAppid.Attach ( vAppid ) ;
					CHString t_chsAppid ( V_BSTR ( &vAppid ) ) ;

					t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
					if ( t_pInstance != NULL )
					{
						CHString t_chsFullPath ;
						t_chsFullPath.Format (
												L"\\\\%s\\%s:%s",
												(LPCWSTR)GetLocalComputerName(),
												IDS_CimWin32Namespace,
												(LPCWSTR)t_chsComponentPath );
						t_pInstance->SetCHString ( IDS_Element, t_chsFullPath ) ;

						t_chsFullPath.Format (
												L"\\\\%s\\%s:%s.%s=\"%s\"",
												(LPCWSTR)GetLocalComputerName(),
												IDS_CimWin32Namespace,
												L"Win32_DCOMApplicationSetting",
												IDS_AppID,
												( LPCWSTR ) t_chsAppid );
						t_pInstance->SetCHString ( IDS_Setting, t_chsFullPath ) ;
						t_hResult =  t_pInstance->Commit ()  ;

						if ( SUCCEEDED ( t_hResult ) )
						{
						}
						else
						{
							break ;
						}
					}
					else
					{
						t_hResult = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}

				t_pDCOMAppInstance.Attach ( t_DCOMAppList.GetNext( t_pos ) ) ;
			}
			t_DCOMAppList.EndEnum () ;
		}
	}

	return t_hResult ;

}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_COMApplicationSettings::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance - Instance into which we
 *                                       retrieve data.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_COMApplicationSettings::GetObject ( CInstance* a_pInstance, long a_lFlags )
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND;
    CHString t_chsAppid, t_chsSetting ;

	CInstancePtr t_pSettingInstance , t_pApplicationInstance ;

	a_pInstance->GetCHString ( IDS_Element, t_chsAppid );
	a_pInstance->GetCHString ( IDS_Setting, t_chsSetting );
	MethodContext *t_pMethodContext = a_pInstance->GetMethodContext();

	//check whether the end-pts. are present
	t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsAppid, &t_pApplicationInstance, t_pMethodContext ) ;

	if ( SUCCEEDED ( t_hResult ) )
	{
		t_hResult = CWbemProviderGlue::GetInstanceByPath ( t_chsSetting, &t_pSettingInstance, t_pMethodContext ) ;
	}

	if ( SUCCEEDED ( t_hResult ) )
	{
		CHString t_chsAppID, t_chsTmp ;
		t_pApplicationInstance->GetCHString ( IDS_AppID, t_chsAppID ) ;
		t_pSettingInstance->GetCHString ( IDS_AppID, t_chsTmp ) ;

		if (	!t_chsAppID.IsEmpty () &&
				!t_chsAppID.CompareNoCase ( t_chsTmp )
			)
		{
			t_hResult = WBEM_S_NO_ERROR ;
		}
		else
		{
			t_hResult = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_clientapplicationsetting.cpp ===
//=============================================================================================================

//

// Win32_ClientApplicationSetting.CPP

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#include "precomp.h"
#include <cregcls.h>
#include "Win32_ClientApplicationSetting.h"

#include "NtDllApi.h"

//MOF Definition
/*
	[Association:  ToInstance, Dynamic, Provider("cimw32ex")]
class Win32_ClientApplicationSetting
{
	[key]
	CIM_DataFile ref Client ;


	Win32_DCOMApplication ref Application ;
};

*/

/*
 *NOTE:		Instances of this class can be obtained only by doing Associators of given Cim_DataFile.
 *			Instances cannot be obtained by calling Associators of Win32_DCOMApplication.This is because
 *			Given an AppID, we do not get the complete path to the .exe under the AppID hive in the registry
 *
 */

Win32_ClientApplicationSetting MyWin32_ClientApplicationSetting (
																		DCOM_CLIENT_APP_SETTING,
																		IDS_CimWin32Namespace );


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::Win32_ClientApplicationSetting
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/
Win32_ClientApplicationSetting::Win32_ClientApplicationSetting
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::~Win32_ClientApplicationSetting
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/
Win32_ClientApplicationSetting::~Win32_ClientApplicationSetting ()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::ExecQuery
 *
 *  DESCRIPTION :
 *
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClientApplicationSetting::ExecQuery(

	MethodContext *a_pMethodContext,
	CFrameworkQuery& a_pQuery,
	long a_lFlags /* = 0L*/
)
{
	HRESULT t_hResult;
	CHStringArray t_achsNames ;

	CInstancePtr t_pInstance ;

	t_hResult = a_pQuery.GetValuesForProp(L"Client", t_achsNames );
	if ( SUCCEEDED ( t_hResult ) )
	{
		DWORD t_dwSize = t_achsNames.GetSize();
		if ( t_dwSize == 1 )
		{
			if ( FileNameExists ( t_achsNames[0] ) )
			{
				//Get the Name of the Client .Exe. Format will be Cim_DataFile.Name="{path}\Filename"
				bstr_t t_bstrtTmp = t_achsNames[0] ;
				PWCHAR t_pwcExecutable = GetFileName ( t_bstrtTmp ) ;

				if ( t_pwcExecutable )
				{
					CHString t_chsExe = t_pwcExecutable ;
					CRegistry t_RegInfo ;

					//check if there is an entry for the executable under HKLM\SOFTWARE\Classes\AppID
					if ( t_RegInfo.Open (
										HKEY_LOCAL_MACHINE,
										CHString ( L"SOFTWARE\\Classes\\AppID\\" ) + t_chsExe,
										KEY_READ ) == ERROR_SUCCESS
									)
					{
						CHString t_chsTmp ;
						if ( t_RegInfo.GetCurrentKeyValue( L"AppID", t_chsTmp ) == ERROR_SUCCESS && !t_chsTmp.IsEmpty () )
						{
							t_pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
							if ( t_pInstance != NULL )
							{
								CHString t_chsReferencePath ;

								t_chsReferencePath.Format (

														L"\\\\%s\\%s:%s",
														(LPCWSTR) GetLocalComputerName(),
														IDS_CimWin32Namespace,
														t_achsNames[0] ) ;

								t_pInstance->SetCHString ( IDS_Client, t_chsReferencePath ) ;

								t_chsReferencePath.Format(

														L"\\\\%s\\%s:%s.%s=\"%s\"",
														(LPCWSTR) GetLocalComputerName(),
														IDS_CimWin32Namespace,
														L"Win32_DCOMApplication",
														IDS_AppID,
														t_chsTmp );

								t_pInstance->SetCHString ( IDS_Application, t_chsReferencePath ) ;
								t_hResult = t_pInstance->Commit () ;
							}
							else
							{
								t_hResult = WBEM_E_OUT_OF_MEMORY ;
							}
						}
					}
					else
					{
//						t_hResult = WBEM_E_NOT_FOUND ;
						t_hResult = WBEM_S_NO_ERROR ;
					}
				}
				else
				{
//					t_hResult = WBEM_E_PROVIDER_NOT_CAPABLE ;
					t_hResult = WBEM_S_NO_ERROR ;
				}
			}
			else
			{
//				t_hResult = WBEM_E_NOT_FOUND ;
				t_hResult = WBEM_S_NO_ERROR ;
			}
		}
		else
		{
			//we can't handle this query
//			t_hResult = WBEM_E_PROVIDER_NOT_CAPABLE ;
			t_hResult = WBEM_S_NO_ERROR ;
		}
	}
	else
	{
//		t_hResult = WBEM_E_PROVIDER_NOT_CAPABLE ;
		t_hResult = WBEM_S_NO_ERROR ;
	}

	return t_hResult ;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : MethodContext* a_pMethodContext - Context to enum
 *													instance data in.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    : Instances of this class cannot be obtained.This is because
 *				  given an AppID, we do not get the complete path to the .exe under the AppID hive in the registry
 *
 *****************************************************************************/
HRESULT Win32_ClientApplicationSetting::EnumerateInstances
(
	MethodContext*  a_pMethodContext,
	long a_lFlags
)
{
	return WBEM_E_NOT_SUPPORTED;
}


/*****************************************************************************
 *
 *  FUNCTION    : Win32_ClientApplicationSetting::GetObject
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance - Instance into which we
 *                                       retrieve data.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT         Success/Failure code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Win32_ClientApplicationSetting::GetObject (

CInstance* a_pInstance,
long a_lFlags
)
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND;
	CHString t_chsClient ;
	PWCHAR t_pwcColon = L":" ;
	a_pInstance->GetCHString ( IDS_Client, t_chsClient ) ;
	if ( !t_chsClient.IsEmpty() )
	{
		if ( FileNameExists ( t_chsClient ) )
		{
			bstr_t t_bstrtClient = t_chsClient ;
			PWCHAR t_pwcTmp = t_bstrtClient ;

			if ( t_pwcTmp = GetFileName ( t_bstrtClient ) )
			{
				//check if there is an entry for the executable under HKLM\SOFTWARE\Classes\AppID
				CHString t_chsExe ( t_pwcTmp ) ;
				CRegistry t_RegInfo ;
				if ( t_RegInfo.Open (
									HKEY_LOCAL_MACHINE,
									CHString ( _T("SOFTWARE\\Classes\\AppID\\") ) + t_chsExe,
									KEY_READ ) == ERROR_SUCCESS
								)
				{
					CHString t_chsTmp ;
					if ( t_RegInfo.GetCurrentKeyValue( L"AppID", t_chsTmp ) == ERROR_SUCCESS && !t_chsTmp.IsEmpty () )
					{
						CHString t_chsReferencePath ;
						t_chsReferencePath.Format(

												L"\\\\%s\\%s:%s.%s=\"%s\"",
												GetLocalComputerName(),
												IDS_CimWin32Namespace,
												L"Win32_DCOMApplication",
												IDS_AppID,
												t_chsTmp );

						a_pInstance->SetCHString ( IDS_Application, t_chsReferencePath ) ;
						t_hResult = WBEM_S_NO_ERROR ;
					}
					else
					{
						t_hResult = WBEM_E_NOT_FOUND ;
					}
				}
				else
				{
					t_hResult = WBEM_E_NOT_FOUND ;
				}
			}
			else
			{
				t_hResult = WBEM_E_INVALID_OBJECT_PATH ;
			}
		}
	}
	else
	{
		t_hResult = WBEM_E_INVALID_PARAMETER ;
	}

	return t_hResult ;
}


PWCHAR Win32_ClientApplicationSetting::GetFileName ( bstr_t& a_bstrtTmp )
{

	//Remove the complete path & get only the filename as that's what is stored in the registry
	PWCHAR t_pwcKey = NULL;
	PWCHAR t_pwcCompletePath = a_bstrtTmp ;

	if (t_pwcCompletePath)
	{
		UCHAR t_wack = L'\\' ;
		t_pwcKey = wcsrchr ( t_pwcCompletePath, t_wack ) ;

		if ( t_pwcKey != NULL )
		{
			t_pwcKey += 1 ;

			if ( t_pwcKey != NULL )
			{
				PWCHAR t_pwcQuote = L"\"" ;

				//remove the final quote from the filename
				PWCHAR t_pwcTmp = wcsstr ( t_pwcKey, t_pwcQuote ) ;
				if ( t_pwcTmp )
				{
					*t_pwcTmp = 0 ;
				}
			}
		}
	}

	return t_pwcKey ;
}


BOOL Win32_ClientApplicationSetting::FileNameExists ( CHString& file )
{
	BOOL bResult = FALSE;

	if( ! file.IsEmpty () )
	{
		BOOL bContinue = TRUE;

		PWCHAR t_pwcFile	= NULL;
		PWCHAR t_pwcQuote	= L"\"" ;
		PWCHAR t_pwcTmp		= wcsstr ( static_cast < LPCWSTR > ( file ), t_pwcQuote ) ;

		if ( t_pwcTmp )
		{
			// remove first quote
			t_pwcTmp++;

			try
			{
				if ( ( t_pwcFile = new WCHAR [ lstrlenW ( t_pwcTmp ) ] ) != NULL )
				{
					memcpy ( t_pwcFile, t_pwcTmp, ( lstrlenW ( t_pwcTmp ) - 1 ) * sizeof ( WCHAR ) );
					t_pwcFile [ lstrlenW ( t_pwcTmp ) - 1 ] = L'\0';
				}
				else
				{
					bContinue = FALSE;
				}
			}
			catch ( ... )
			{
				if ( t_pwcFile )
				{
					delete [] t_pwcFile;
					t_pwcFile = NULL;
				}

				bContinue = FALSE;
			}
		}
		else
		{
			bContinue = FALSE;
		}

		if ( bContinue )
		{
			PWCHAR t_pwcFileTmp = NULL;

			try
			{
				if ( ( t_pwcFileTmp = new WCHAR [ lstrlenW ( t_pwcFile ) + 4 + 1 ] ) != NULL )
				{
					wcscpy ( t_pwcFileTmp, L"\\??\\" );

					PWCHAR t_pwc  = NULL;
					PWCHAR t_pwc1 = NULL;

					t_pwc  = t_pwcFile;
					t_pwc1 = t_pwcFileTmp;

					t_pwcFileTmp = t_pwcFileTmp + 4;

					DWORD dw = 4L;

					BOOL bEscape  = TRUE;
					BOOL bProceed = TRUE;

					while ( *t_pwc )
					{
						if ( *t_pwc == L'\\' )
						{
							if ( bEscape )
							{
								bEscape  = FALSE;
								bProceed = FALSE;
							}
							else
							{
								bEscape  = TRUE;
								bProceed = TRUE;
							}
						}
						else
						{
							bProceed = TRUE;
						}

						if ( bProceed )
						{
							*t_pwcFileTmp = *t_pwc;

							t_pwcFileTmp++;
							dw++;
						}

						t_pwc++;
					}

					t_pwcFileTmp = t_pwc1;
					t_pwcFileTmp [ dw ] = L'\0';

					if ( t_pwcFile )
					{
						delete [] t_pwcFile;
						t_pwcFile = NULL;
					}

					t_pwcFile = t_pwcFileTmp;
				}
				else
				{
					if ( t_pwcFile )
					{
						delete [] t_pwcFile;
						t_pwcFile = NULL;
					}

					bContinue = FALSE;
				}
			}
			catch ( ... )
			{
				if ( t_pwcFileTmp )
				{
					delete [] t_pwcFileTmp;
					t_pwcFileTmp = NULL;
				}

				if ( t_pwcFile )
				{
					delete [] t_pwcFile;
					t_pwcFile = NULL;
				}

				bContinue = FALSE;
			}
		}

		if ( bContinue )
		{
			CNtDllApi *pNtDllApi = NULL;
			pNtDllApi = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);

			if ( pNtDllApi != NULL )
			{
				HANDLE hFileHandle = 0L;

				UNICODE_STRING ustrNtFileName = { 0 };

				OBJECT_ATTRIBUTES oaAttributes;
				IO_STATUS_BLOCK IoStatusBlock;

				try
				{
					ustrNtFileName.Length			= lstrlenW ( t_pwcFile ) * sizeof(WCHAR);
					ustrNtFileName.MaximumLength	= ustrNtFileName.Length;
					ustrNtFileName.Buffer			= t_pwcFile;

					InitializeObjectAttributes	(	&oaAttributes,
													&ustrNtFileName,
													OBJ_CASE_INSENSITIVE,
													NULL,
													NULL
												);

					NTSTATUS ntstat = -1L;
					ntstat = pNtDllApi->NtOpenFile	(	&hFileHandle,
														GENERIC_READ,
														&oaAttributes,
														&IoStatusBlock,
														FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
														0
													);

					if ( NT_SUCCESS ( ntstat ) || ntstat == STATUS_PRIVILEGE_NOT_HELD )
					{
						if ( hFileHandle )
						{
							pNtDllApi->NtClose ( hFileHandle );
							hFileHandle = 0L;
						}

						bResult = TRUE;
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtDllApi );
					pNtDllApi = NULL;
				}
				catch ( ... )
				{
					if ( hFileHandle )
					{
						pNtDllApi->NtClose ( hFileHandle );
						hFileHandle = 0L;
					}

					if ( t_pwcFile )
					{
						delete [] t_pwcFile;
						t_pwcFile = NULL;
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtDllApi );
					pNtDllApi = NULL;

					throw;
				}
			}

			if ( t_pwcFile )
			{
				delete [] t_pwcFile;
				t_pwcFile = NULL;
			}
		}
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comapplicationsettings.h ===
//=============================================================================================================

//

// Win32_COMApplicationSettings.h -- COM Application property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 03/04/99    a-dpawar		Added graceful exit on SEH and memory failures, syntactic clean up
//
//==============================================================================================================

#define  COM_APP_SETTING L"Win32_COMApplicationSettings"

class Win32_COMApplicationSettings : public Provider
{
public:
	Win32_COMApplicationSettings (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_COMApplicationSettings ();

	virtual HRESULT EnumerateInstances (MethodContext*  a_pMethodContext, long a_lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* a_pInstance, long a_lFlags = 0L );

private:	
	HRESULT Win32_COMApplicationSettings::CreateInstances 
	( 
		
		CInstance* a_pComObject, 
		PSECURITY_DESCRIPTOR a_pSD, 
		MethodContext*  a_pMethodContext 
	) ;
	
	HRESULT Win32_COMApplicationSettings::CheckInstance ( CInstance* a_pComObject, PSECURITY_DESCRIPTOR a_pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comclassemulator.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_COMClassEmulator
//
//////////////////////////////////////////////////////

#define  Win32_COM_CLASS_EMULATOR L"Win32_COMClassEmulator"

class Win32_COMClassEmulator : public Provider
{
private:
protected:
public:
	Win32_COMClassEmulator (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_COMClassEmulator ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

private:	
	HRESULT Win32_COMClassEmulator::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_COMClassEmulator::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comclassautoemulator.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_COMClassAutoEmulator
//
//////////////////////////////////////////////////////

#define  Win32_COM_CLASS_AUTO_EMULATOR L"Win32_COMClassAutoEmulator"

class Win32_COMClassAutoEmulator : public Provider
{
private:
protected:
public:
	Win32_COMClassAutoEmulator (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_COMClassAutoEmulator ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

private:	
	HRESULT Win32_COMClassAutoEmulator::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_COMClassAutoEmulator::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comclassautoemulator.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_COMClassAutoEmulator.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "Win32_COMClassAutoEmulator.h"
#include <cregcls.h>

Win32_COMClassAutoEmulator MyWin32_COMClassAutoEmulator ( Win32_COM_CLASS_AUTO_EMULATOR, IDS_CimWin32Namespace );

Win32_COMClassAutoEmulator::Win32_COMClassAutoEmulator
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_COMClassAutoEmulator::~Win32_COMClassAutoEmulator ()
{
}

HRESULT Win32_COMClassAutoEmulator::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance>	ComClassList ;
	CRegistry t_RegInfo ;
	//get all instances of Win32_DCOMApplication
//	if ( SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances ( _T("Win32_ClassicCOMClass"),
//		&ComClassList, pMethodContext, IDS_CimWin32Namespace ) ) )

	if (
			t_RegInfo.Open (

			HKEY_LOCAL_MACHINE,
			CHString ( L"SOFTWARE\\Classes\\CLSID" ),
			KEY_READ
			) == ERROR_SUCCESS

			&&

			SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery ( L"SELECT ComponentId, AutoTreatAsClsid  FROM Win32_ClassicCOMClassSetting WHERE AutoTreatAsClsid <> NULL and AutoTreatAsClsid <> \"\"",
			&ComClassList, pMethodContext, GetNamespace() ) ) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		CInstancePtr pComClassInstance  ;

		if ( ComClassList.BeginEnum( pos ) )
		{
			pComClassInstance.Attach ( ComClassList.GetNext( pos ) ) ;
			while ( pComClassInstance  != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString chsComponentPath ;
				pComClassInstance->GetCHString ( IDS_ComponentId, chsComponentPath ) ;

				//get the AutoTreatAsClsid of the Win32_ClassicCOMClass
				CHString chsAutoTreatAs ;
				pComClassInstance->GetCHString ( IDS_AutoTreatAsClsid, chsAutoTreatAs ) ;
				CRegistry t_RegClsidInfo ;
				//check if the AutoTreatAs entry is present
				if ( t_RegClsidInfo.Open ( t_RegInfo.GethKey() , chsAutoTreatAs, KEY_READ ) == ERROR_SUCCESS )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
					if ( pInstance )
					{
						CHString chsFullPath ;
						chsFullPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
											(LPCWSTR)GetLocalComputerName(),
											IDS_CimWin32Namespace,
											L"Win32_ClassicCOMClass",
											IDS_ComponentId,
											(LPCWSTR)chsComponentPath );
						pInstance->SetCHString ( IDS_OldVersion, chsFullPath ) ;

						chsFullPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
											(LPCWSTR)GetLocalComputerName(),
											IDS_CimWin32Namespace,
											L"Win32_ClassicCOMClass",
											IDS_ComponentId,
											(LPCWSTR)chsAutoTreatAs );
						pInstance->SetCHString ( IDS_NewVersion, chsFullPath ) ;
						hr = pInstance->Commit () ;
						if ( SUCCEEDED ( hr ) )
						{
						}
						else
						{
							break ;
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}

				pComClassInstance.Attach ( ComClassList.GetNext( pos ) ) ;
			}
			ComClassList.EndEnum () ;
		}
	}

	return hr ;
}

HRESULT Win32_COMClassAutoEmulator::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chsClsid, chsAutoEmulator ;
    CInstancePtr pClassicCOMClass , pAutoEmulatorInstance  ;
    pInstance->GetCHString ( IDS_OldVersion, chsClsid );
	pInstance->GetCHString ( IDS_NewVersion, chsAutoEmulator );
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsClsid, &pClassicCOMClass, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsAutoEmulator, &pAutoEmulatorInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
        CRegistry t_RegInfo, t_TmpReg ;
        CHString chsAutoTreatAs, chsTmp ;
		pAutoEmulatorInstance->GetCHString ( IDS_ComponentId, chsAutoTreatAs ) ;
		pClassicCOMClass->GetCHString ( IDS_ComponentId, chsTmp ) ;

		if (	!chsAutoTreatAs.IsEmpty () &&

				t_RegInfo.Open (

				HKEY_LOCAL_MACHINE,
				CHString ( L"SOFTWARE\\Classes\\CLSID\\" ) + chsTmp,
				KEY_READ
				) == ERROR_SUCCESS
			)
		{
			if (	t_TmpReg.Open ( t_RegInfo.GethKey (), L"AutoTreatAs", KEY_READ ) == ERROR_SUCCESS	&&
					t_TmpReg.GetCurrentKeyValue( NULL, chsTmp ) == ERROR_SUCCESS					&&
					!chsAutoTreatAs.CompareNoCase ( chsTmp )
				)
			{
				hr = WBEM_S_NO_ERROR ;
			}
			else
			{
				hr  = WBEM_E_NOT_FOUND ;
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_comclassemulator.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_COMClassEmulator.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "Win32_COMClassEmulator.h"
#include <cregcls.h>

Win32_COMClassEmulator MyWin32_COMClassEmulator ( Win32_COM_CLASS_EMULATOR, IDS_CimWin32Namespace );

Win32_COMClassEmulator::Win32_COMClassEmulator
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_COMClassEmulator::~Win32_COMClassEmulator ()
{
}

HRESULT Win32_COMClassEmulator::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
	TRefPointerCollection<CInstance>	ComClassList ;
	CRegistry t_RegInfo ;
	//get all instances of Win32_DCOMApplication
	if (
			t_RegInfo.Open (

				HKEY_LOCAL_MACHINE,
				CHString ( L"SOFTWARE\\Classes\\CLSID" ),
				KEY_READ
				) == ERROR_SUCCESS
			&&

			SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery ( L"SELECT ComponentId, TreatAsClsid FROM Win32_ClassicCOMClassSetting "
                                                                 L"WHERE TreatAsClsid <> NULL and TreatAsClsid <> \"\"",
		&ComClassList, pMethodContext, GetNamespace()) ) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		CInstancePtr	pComClassInstance ;

		if ( ComClassList.BeginEnum( pos ) )
		{
			pComClassInstance.Attach ( ComClassList.GetNext( pos ) ) ;
			while ( pComClassInstance != NULL )
			{
				//get the relative path to the Win32_ClassicCOMClass
				CHString chsComponentPath ;
				pComClassInstance->GetCHString ( IDS_ComponentId, chsComponentPath ) ;

				//get the TreatAsClsid of the Win32_ClassicCOMClass
				CHString chsTreatAs ;
				pComClassInstance->GetCHString ( IDS_TreatAsClsid, chsTreatAs ) ;
				CRegistry t_RegClsidInfo ;
				//check if the TreatAs entry is present
				if ( t_RegClsidInfo.Open ( t_RegInfo.GethKey() , chsTreatAs, KEY_READ ) == ERROR_SUCCESS )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
					if ( pInstance != NULL )
					{
						CHString chsFullPath ;
						chsFullPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
											(LPCWSTR)GetLocalComputerName(),
											IDS_CimWin32Namespace,
											L"Win32_ClassicCOMClass",
											IDS_ComponentId,
											(LPCWSTR)chsComponentPath );
						pInstance->SetCHString ( IDS_OldVersion, chsFullPath ) ;

						chsFullPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
											(LPCWSTR)GetLocalComputerName(),
											IDS_CimWin32Namespace,
											L"Win32_ClassicCOMClass",
											IDS_ComponentId,
											(LPCWSTR)chsTreatAs );
						pInstance->SetCHString ( IDS_NewVersion, chsFullPath ) ;
						hr = pInstance->Commit () ;
						if ( SUCCEEDED ( hr ) )
						{
						}
						else
						{
							break ;
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}

				pComClassInstance.Attach ( ComClassList.GetNext( pos ) ) ;
			}
			ComClassList.EndEnum () ;
		}
	}

	return hr ;
}

HRESULT Win32_COMClassEmulator::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chsClsid, chsEmulator ;
    CInstancePtr pClassicCOMClass , pEmulatorInstance ;
    pInstance->GetCHString ( IDS_OldVersion, chsClsid );
	pInstance->GetCHString ( IDS_NewVersion, chsEmulator );
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsClsid, &pClassicCOMClass, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsEmulator, &pEmulatorInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
        CRegistry t_RegInfo, t_TmpReg ;
		CHString chsTreatAs, chsTmp ;
		pEmulatorInstance->GetCHString ( IDS_ComponentId, chsTreatAs ) ;
		pClassicCOMClass->GetCHString ( IDS_ComponentId, chsTmp ) ;

		if (	!chsTreatAs.IsEmpty () &&

				t_RegInfo.Open (

				HKEY_LOCAL_MACHINE,
				CHString ( L"SOFTWARE\\Classes\\CLSID\\" ) + chsTmp,
				KEY_READ
				) == ERROR_SUCCESS
			)
		{
			if (	t_TmpReg.Open ( t_RegInfo.GethKey (), L"TreatAs", KEY_READ ) == ERROR_SUCCESS	&&
					t_TmpReg.GetCurrentKeyValue( NULL, chsTmp ) == ERROR_SUCCESS					&&
					!chsTreatAs.CompareNoCase ( chsTmp )
				)
			{
				hr = WBEM_S_NO_ERROR ;
			}
			else
			{
				hr  = WBEM_E_NOT_FOUND ;
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_componentcategory.h ===
//=================================================================

//

// Win32_ComponentCategory.h -- Registered COM Application property set provider 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

// Property set identification
//============================
#include <comcat.h>

#define PROPSET_NAME_COMPONENT_CATEGORY L"Win32_ComponentCategory"


class Win32_ComponentCategory : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_ComponentCategory(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_ComponentCategory() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags = 0L
	);

	HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

protected:
	
	HRESULT Win32_ComponentCategory :: FillInstanceWithProperites ( 

		CInstance *pInstance, 
		CATEGORYINFO stCatInfo
	) ;

	HRESULT Win32_ComponentCategory :: GetAllOrRequiredCaregory ( 
		
		bool a_bAllCategories , 
		CATID & a_rCatid ,
		CInstance *a_pInstance ,
		MethodContext *a_pMethodContext

	) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_componentcategory.cpp ===
//=================================================================

//

// Win32_ComponentCategory.CPP -- Registered AppID Object property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

#include "precomp.h"
#include "Win32_ComponentCategory.h"
#include <winnls.h>

// Property set declaration
//=========================

Win32_ComponentCategory MyWin32_ComponentCategory( PROPSET_NAME_COMPONENT_CATEGORY, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ComponentCategory::Win32_ComponentCategory
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_ComponentCategory :: Win32_ComponentCategory (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ComponentCategory::~Win32_ComponentCategory
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_ComponentCategory :: ~Win32_ComponentCategory ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ComponentCategory::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ComponentCategory :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_NOT_FOUND ;
	CHString chsCatid ;

	if ( pInstance->GetCHString ( IDS_CategoryId, chsCatid ) && !chsCatid.IsEmpty () )
	{
		bstr_t bstrtCatId = (LPCWSTR) chsCatid ;
		CATID CatId ;
		hr = CLSIDFromString( bstrtCatId, &CatId ) ;
		if ( SUCCEEDED ( hr ) )
		{
			hr = GetAllOrRequiredCaregory ( false , CatId , pInstance , NULL ) ;
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}
	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_ComponentCategory::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_ComponentCategory :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	CATID t_DummyCatid ;
	return GetAllOrRequiredCaregory ( true , t_DummyCatid , NULL , pMethodContext ) ;
}


HRESULT Win32_ComponentCategory :: GetAllOrRequiredCaregory
(
	bool a_bAllCategories ,
	CATID & a_rCatid ,
	CInstance *a_pInstance ,
	MethodContext *a_pMethodContext
)
{

	HRESULT hr ;
	if ( a_bAllCategories )
	{
		hr = WBEM_S_NO_ERROR ;
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	ICatInformationPtr pCatInfo ;

	hr = CoCreateInstance(

							CLSID_StdComponentCategoriesMgr,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_ICatInformation,
							(LPVOID*) &pCatInfo );

	if ( SUCCEEDED ( hr ) )
	{
		IEnumCATEGORYINFOPtr pEnumCatInfo ;
		hr  = pCatInfo->EnumCategories (

										GetUserDefaultLCID () ,
										&pEnumCatInfo );

		CATEGORYINFO stCatInfo ;
		ULONG ulFetched ;
		if ( SUCCEEDED ( hr ) )
		{
			bool t_bFound = false ;
			while ( SUCCEEDED ( pEnumCatInfo->Next (
															1,
															&stCatInfo,
															&ulFetched ) ) && ulFetched > 0 )
			{
				if ( ( !a_bAllCategories && IsEqualCLSID ( stCatInfo.catid , a_rCatid ) ) || a_bAllCategories )
				{
					CInstancePtr pInstance ( a_pInstance ) ;
					if ( a_bAllCategories )
					{
						pInstance.Attach ( CreateNewInstance ( a_pMethodContext ) ) ;
					}

					if ( pInstance != NULL )
					{
						hr = FillInstanceWithProperites ( pInstance, stCatInfo ) ;
						if ( SUCCEEDED ( hr ) )
						{
							hr = pInstance->Commit () ;
							if ( SUCCEEDED ( hr ) )
							{
								t_bFound = true ;
							}
							else
							{
								break ;
							}
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY ;
					}

					//stop EnumInstances only if we're out of memory
					if ( hr == WBEM_E_OUT_OF_MEMORY )
					{
						break ;
					}
					else
					{
						hr = WBEM_S_NO_ERROR ;
					}
					if ( !a_bAllCategories )
					{
						break ;
					}
				}
			}
			if ( !a_bAllCategories && !t_bFound )
			{
				hr = WBEM_E_NOT_FOUND ;
			}
		}
		else
		{
			hr = WBEM_E_FAILED ;
		}
	}
	else
	{
		hr = WBEM_E_FAILED ;
	}
	return hr ;

}

HRESULT Win32_ComponentCategory :: FillInstanceWithProperites (

	CInstance *pInstance,
	CATEGORYINFO stCatInfo
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	LPOLESTR pwcTmp = NULL ;
	hr = StringFromCLSID ( stCatInfo.catid, &pwcTmp ) ;

	if ( hr == E_OUTOFMEMORY )
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	try
	{

		if ( SUCCEEDED ( hr ) )
		{
			CHString chsTmp ( pwcTmp ) ;
			pInstance->SetCHString ( IDS_CategoryId, chsTmp ) ;

			//there might not be a description for the selected locale
			if ( stCatInfo.szDescription != NULL )
			{
				chsTmp = stCatInfo.szDescription ;
				pInstance->SetCHString ( IDS_Name, chsTmp ) ;
				pInstance->SetCHString ( IDS_Caption, chsTmp ) ;
				pInstance->SetCHString ( IDS_Description, chsTmp ) ;
			}
		}

		if ( hr == E_OUTOFMEMORY )
		{
			hr = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	catch ( ... )
	{
		if ( pwcTmp )
		{
			CoTaskMemFree ( pwcTmp ) ;
		}

		throw ;
		return WBEM_E_FAILED; // To get rid of compiler warning
	}

	//NOTE//TODO:: If we're not using the default OLE task memory allocator , get the right IMalloc .
	if ( pwcTmp )
	{
		CoTaskMemFree ( pwcTmp ) ;
	}
	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplication.h ===
//=================================================================

//

// Win32_DCOMApplication.h -- Registered COM Application property set provider 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_DCOM_APPLICATION L"Win32_DCOMApplication"


class Win32_DCOMApplication : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_DCOMApplication(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_DCOMApplication() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags = 0L
	);

	HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

protected:
	
	HRESULT Win32_DCOMApplication :: FillInstanceWithProperites ( 

		CInstance *pInstance, 
		HKEY hAppIdKey,
		CHString& rchsAppid
	) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplication.cpp ===
//=================================================================

//

// Win32_DCOMApplication.CPP -- Registered AppID Object property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

#include "precomp.h"
#include "Win32_DCOMApplication.h"
#include <cregcls.h>

// Property set declaration
//=========================

Win32_DCOMApplication MyWin32_DCOMApplication(PROPSET_NAME_DCOM_APPLICATION, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplication::Win32_DCOMApplication
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_DCOMApplication :: Win32_DCOMApplication (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplication::~Win32_DCOMApplication
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_DCOMApplication :: ~Win32_DCOMApplication ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplication::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_DCOMApplication :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CHString chsAppid ;
	CRegistry RegInfo ;
	HKEY hAppIdKey = NULL ;

	if ( pInstance->GetCHString ( IDS_AppID, chsAppid ) )
	{
		//check to see that the appid is present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
		if ( RegInfo.Open (
							HKEY_LOCAL_MACHINE,
							CHString ( L"SOFTWARE\\Classes\\AppID\\" ) + chsAppid,
							KEY_READ ) == ERROR_SUCCESS
			)
		{
			if ( RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\AppID", KEY_READ ) == ERROR_SUCCESS )
			{
				HKEY hAppIdKey = RegInfo.GethKey() ;

				hr = FillInstanceWithProperites ( pInstance, hAppIdKey, chsAppid ) ;
			}
			else
			{
				hr = WBEM_E_FAILED ;
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplication::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_DCOMApplication :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CRegistry RegInfo ;
	CHString chsAppid ;
	CInstancePtr pInstance ;

	//Enumerate all the AppID's present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
	if ( RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\AppID",
							KEY_READ ) == ERROR_SUCCESS  &&

			RegInfo.GetCurrentSubKeyCount()
		)
	{
		HKEY hAppIdKey = RegInfo.GethKey() ;

		do
		{
			if ( RegInfo.GetCurrentSubKeyName ( chsAppid ) == ERROR_SUCCESS )
			{
				pInstance.Attach ( CreateNewInstance ( pMethodContext ) ) ;
				if ( pInstance != NULL )
				{

					hr = FillInstanceWithProperites ( pInstance, hAppIdKey, chsAppid ) ;
					if ( SUCCEEDED ( hr ) )
					{
						hr = pInstance->Commit () ;
						if ( SUCCEEDED ( hr ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					//we're out of memory
					hr = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( hr == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					hr = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return hr ;
}


HRESULT Win32_DCOMApplication :: FillInstanceWithProperites (

	CInstance *pInstance,
	HKEY hAppIdKey,
	CHString& rchsAppid
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CRegistry AppidRegInfo ;
	CHString chsTmp ;
	CLSID t_clsid ;

	//NOTE: Executables are registered under the AppID key in a named-value indicating the module name
	//		such as "MYOLDAPP.EXE". This named-value is of type REG_SZ and contains the stringized AppID
	//		associated with the executable. We want to skip these duplicate AppID entries.
	if ( CLSIDFromString( _bstr_t ( rchsAppid ) , &t_clsid ) != NOERROR )
	{
		//found an execuatble, so don't process the entry
		return WBEM_E_NOT_FOUND ;
	}

	//open the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID\{appid} key
	if ( AppidRegInfo.Open ( hAppIdKey, rchsAppid, KEY_READ ) == ERROR_SUCCESS )
	{
		pInstance->SetCHString ( IDS_AppID, rchsAppid ) ;

		if ( AppidRegInfo.GetCurrentKeyValue ( NULL, chsTmp ) == ERROR_SUCCESS )
		{
			pInstance->SetCHString ( IDS_Name, chsTmp ) ;
			pInstance->SetCHString ( IDS_Caption, chsTmp ) ;
			pInstance->SetCHString ( IDS_Description, chsTmp ) ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationaccessallowedsetting.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	Win32_DCOMApplicationAccessAllowedSetting
//
//////////////////////////////////////////////////////
#ifndef __Win32_DCOMApplicationAccessAllowedSetting_H_
#define __Win32_DCOMApplicationAccessAllowedSetting_H_

#define  DCOM_APP_ACCESS_SETTING L"Win32_DCOMApplicationAccessAllowedSetting"

class Win32_DCOMApplicationAccessAllowedSetting : public Provider
{
private:
protected:
public:
	Win32_DCOMApplicationAccessAllowedSetting (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_DCOMApplicationAccessAllowedSetting ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

private:	
	HRESULT Win32_DCOMApplicationAccessAllowedSetting::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_DCOMApplicationAccessAllowedSetting::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
};	

#endif //__Win32_DCOMApplicationAccessAllowedSetting_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationlaunchallowedsetting.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	Win32_DCOMApplicationLaunchAllowedSetting
//
//////////////////////////////////////////////////////
#ifndef __Win32_DCOMApplicationLaunchAllowedSetting_H_
#define __Win32_DCOMApplicationLaunchAllowedSetting_H_

#define  DCOM_APP_LAUNCH_ACCESS_SETTING L"Win32_DCOMApplicationLaunchAllowedSetting"

class Win32_DCOMApplicationLaunchAllowedSetting : public Provider
{
private:
protected:
public:
	Win32_DCOMApplicationLaunchAllowedSetting (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_DCOMApplicationLaunchAllowedSetting ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );

private:	
	HRESULT Win32_DCOMApplicationLaunchAllowedSetting::CreateInstances 
	( 
		
		CInstance* pComObject, 
		PSECURITY_DESCRIPTOR pSD, 
		MethodContext*  pMethodContext 
	) ;
	
	HRESULT Win32_DCOMApplicationLaunchAllowedSetting::CheckInstance ( CInstance* pComObject, PSECURITY_DESCRIPTOR pSD ) ;
	
};	

#endif //__Win32_DCOMApplicationLaunchAllowedSetting_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationaccessallowedsetting.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	CIM_COMObjectAccessSetting.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "COMObjSecRegKey.h"
#include "Win32_DCOMApplicationAccessAllowedSetting.h"

Win32_DCOMApplicationAccessAllowedSetting MyWin32_DCOMApplicationAccessAllowedSetting (
																		DCOM_APP_ACCESS_SETTING,
																		IDS_CimWin32Namespace );

Win32_DCOMApplicationAccessAllowedSetting::Win32_DCOMApplicationAccessAllowedSetting
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_DCOMApplicationAccessAllowedSetting::~Win32_DCOMApplicationAccessAllowedSetting ()
{
}

HRESULT Win32_DCOMApplicationAccessAllowedSetting::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	//open the HKEY_LOCAL\MACHINE\SOFTWARE\Classes\AppID key
	CRegistry TmpReg, AppidRegInfo ;

	if ( AppidRegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\AppID", KEY_READ ) == ERROR_SUCCESS )
	{
		// Collections
		TRefPointerCollection<CInstance>	DcomAppList ;

		// Perform queries
		//================

		//get all instances of Win32_DCOMApplication
//		if ( SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances ( _T("Win32_DCOMApplication"),
//			&DcomAppList, pMethodContext, IDS_CimWin32Namespace ) ) )

		if ( SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery ( L"SELECT AppID FROM Win32_DCOMApplication",
			&DcomAppList, pMethodContext, GetNamespace() ) ) )
		{
			REFPTRCOLLECTION_POSITION	pos;
			CInstancePtr pDcomApplication;

			if ( DcomAppList.BeginEnum( pos ) )
			{
				pDcomApplication.Attach ( DcomAppList.GetNext( pos ) ) ;
				while ( pDcomApplication != NULL )
				{
					CHString chsAppID ;

					//get the Appid of the Win32_DCOMApplication
					pDcomApplication->GetCHString ( IDS_AppID, chsAppID ) ;
					if ( ! chsAppID.IsEmpty() && TmpReg.Open ( AppidRegInfo.GethKey(), chsAppID, KEY_READ )
													== ERROR_SUCCESS
						)
					{
						DWORD dwSize = 0 ;
						if ( TmpReg.GetCurrentBinaryKeyValue( L"AccessPermission", NULL ,&dwSize )
								== ERROR_SUCCESS
							)
						{
							PSECURITY_DESCRIPTOR pSD = ( PSECURITY_DESCRIPTOR ) new BYTE[dwSize] ;
							if ( pSD )
							{
								try
								{
									if ( TmpReg.GetCurrentBinaryKeyValue( L"AccessPermission", ( PBYTE ) pSD ,&dwSize )
											== ERROR_SUCCESS
										)
									{
										hr = CreateInstances ( pDcomApplication, pSD, pMethodContext ) ;
									}
									if ( SUCCEEDED ( hr ) )
									{
									}
									else
									{
										break ;
									}
								}
								catch ( ... )
								{
									if ( pSD )
									{
										delete[] (PBYTE) pSD ;
										pSD = NULL ;
									}

									throw ;
								}

								delete[] (PBYTE) pSD ;
								pSD = NULL ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
						else
						{
							//getit from default
						}
					}
					if ( hr == WBEM_E_OUT_OF_MEMORY )
					{
						break ;
					}

					pDcomApplication.Attach ( DcomAppList.GetNext( pos ) ) ;
				}

				DcomAppList.EndEnum();
			}
		}
	}
    return hr ;
}


HRESULT Win32_DCOMApplicationAccessAllowedSetting::CreateInstances ( CInstance* pDcomApplication, PSECURITY_DESCRIPTOR pSD, MethodContext*  pMethodContext )
{
	HRESULT hr = S_OK ;
#ifdef NTONLY
	CCOMObjectSecurityRegistryKey tp ( pSD ) ;
	CHString chsSid;

	// create relpath for cim_comobject
	CHString chsDcomApplicationPath ;
	CHString chsFullDcomApplicationPath ;
	pDcomApplication->GetCHString( _T( "__RELPATH" ), chsDcomApplicationPath );
	chsFullDcomApplicationPath.Format(_T("\\\\%s\\%s:%s"), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, (LPCTSTR)chsDcomApplicationPath );

	CDACL dacl;
	tp.GetDACL(dacl);

	// walk DACL & create new instance for each ACE....
	ACLPOSITION aclPos;
	// Need merged list...
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
        t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CSid sidTrustee;

	    while ( t_ael.GetNext(aclPos, ACE ) && SUCCEEDED ( hr ) )
	    {
		    ACE.GetSID(sidTrustee);

		    if ( sidTrustee.IsValid() && ACE.IsAllowed () )
		    {
			    CInstancePtr pInstance ( CreateNewInstance( pMethodContext ), false ) ;
			    if ( pInstance != NULL )
			    {
				    pInstance->SetCHString ( IDS_Element, chsFullDcomApplicationPath );
				    chsSid.Format(_T("\\\\%s\\%s:%s.%s=\"%s\""), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
							    _T("Win32_SID"), IDS_SID, (LPCTSTR)sidTrustee.GetSidString() );

				    pInstance->SetCHString ( IDS_Setting, chsSid );
				    hr = pInstance->Commit () ;
				    if ( SUCCEEDED ( hr ) )
				    {
				    }
				    else
				    {
					    break ;
				    }
			    }
			    else
			    {
				    hr = WBEM_E_OUT_OF_MEMORY ;
			    }
		    }
	    }

	    t_ael.EndEnum(aclPos);
    }
#endif

	return hr ;
}



HRESULT Win32_DCOMApplicationAccessAllowedSetting::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
    CRegistry Reg ;
    CHString chsSid, chsApplication ;
    CInstancePtr pSidInstance , pDcomApplicationInstance ;
    pInstance->GetCHString ( IDS_Element, chsApplication );
	pInstance->GetCHString( IDS_Setting, chsSid);
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsApplication, &pDcomApplicationInstance, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsSid, &pSidInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
        CHString chsAppID ;
		pDcomApplicationInstance->GetCHString ( IDS_AppID, chsAppID ) ;

		//if appid is present & configured...
		if ( ! chsAppID.IsEmpty() && Reg.Open ( HKEY_LOCAL_MACHINE,
												CHString ( _T("SOFTWARE\\Classes\\AppID\\")) + chsAppID ,
												KEY_READ
											  ) == ERROR_SUCCESS
			)
		{
			DWORD dwSize = 0 ;
			if ( Reg.GetCurrentBinaryKeyValue( _T("AccessPermission"), NULL ,&dwSize )
					== ERROR_SUCCESS
				)
			{
				PSECURITY_DESCRIPTOR pSD = ( PSECURITY_DESCRIPTOR ) new BYTE[dwSize] ;
				if ( pSD )
				{
					try
					{
						if ( Reg.GetCurrentBinaryKeyValue( _T("AccessPermission"), ( PBYTE ) pSD ,&dwSize )
								== ERROR_SUCCESS
							)
						{
							hr = CheckInstance ( pInstance, pSD ) ;
						}
					}
					catch ( ... )
					{
						if ( pSD )
						{
							delete[] (PBYTE) pSD ;
						}

						throw ;
					}

					delete[] (PBYTE) pSD ;
					pSD = NULL ;
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			else
			{
				//getit from default
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}
#endif

	return hr ;
}


HRESULT Win32_DCOMApplicationAccessAllowedSetting::CheckInstance ( CInstance* pInstance, PSECURITY_DESCRIPTOR pSD )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
	CCOMObjectSecurityRegistryKey tp ( pSD ) ;
	CHString chsSid, chsSettingSid ;
	pInstance->GetCHString(IDS_Setting, chsSettingSid );

	CDACL dacl;
	tp.GetDACL(dacl);

	// walk DACL & create new instance for each ACE....
	ACLPOSITION aclPos;
    // Need merged list...
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
	    t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CSid sidTrustee;

	    while ( t_ael.GetNext(aclPos, ACE ) )
	    {
		    ACE.GetSID(sidTrustee);
		    if ( sidTrustee.IsValid() && ACE.IsAllowed () )
		    {
			    chsSid.Format (_T("\\\\%s\\%s:%s.%s=\"%s\""), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
						     _T("Win32_SID"), IDS_SID, (LPCTSTR)sidTrustee.GetSidString() );

			    //check if the sid is in the dacl for the object
			    if ( ! chsSid.CompareNoCase ( chsSettingSid ) )
			    {
				    hr = WBEM_S_NO_ERROR ;
				    break ;
			    }
		    }
	    }
        t_ael.EndEnum(aclPos);
    }
#endif
	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_implementedcategory.h ===
//////////////////////////////////////////////////////

//	Win32_ImplementedCategory

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//////////////////////////////////////////////////////

#define  Win32_IMPLEMENTED_CATEGORIES L"Win32_ImplementedCategory"

class Win32_ImplementedCategory : public Provider
{
public:
	Win32_ImplementedCategory (LPCWSTR strName, LPCWSTR pszNameSpace =NULL);
	~Win32_ImplementedCategory ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags = 0L );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationsetting.cpp ===
//=================================================================

//

// Win32_DCOMApplicationSetting.CPP -- Registered AppID Object property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

#include "precomp.h"
#include "Win32_DCOMApplicationSetting.h"
#include <cregcls.h>

// Property set declaration
//=========================

Win32_DCOMApplicationSetting MyWin32_DCOMApplicationSetting(PROPSET_NAME_DCOM_APPLICATION_SETTING, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplicationSetting::Win32_DCOMApplicationSetting
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_DCOMApplicationSetting :: Win32_DCOMApplicationSetting (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplicationSetting::~Win32_DCOMApplicationSetting
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_DCOMApplicationSetting :: ~Win32_DCOMApplicationSetting ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplicationSetting::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_DCOMApplicationSetting :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CHString chsAppid ;
	CRegistry RegInfo ;
	HKEY hAppIdKey = NULL ;

	if ( pInstance->GetCHString ( IDS_AppID, chsAppid ) )
	{
		//check to see that the appid is present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
		if ( RegInfo.Open (
							HKEY_LOCAL_MACHINE,
							CHString ( L"SOFTWARE\\Classes\\AppID\\" ) + chsAppid,
							KEY_READ ) == ERROR_SUCCESS
			)
		{
			if ( RegInfo.Open ( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\AppID", KEY_READ ) == ERROR_SUCCESS )
			{
				HKEY hAppIdKey = RegInfo.GethKey() ;

				hr = FillInstanceWithProperites ( pInstance, hAppIdKey, chsAppid ) ;
			}
			else
			{
				hr = WBEM_E_FAILED ;
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_DCOMApplicationSetting::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each Driver
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_DCOMApplicationSetting :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CRegistry RegInfo ;
	CHString chsAppid ;
	CInstancePtr pInstance ;

	//Enumerate all the AppID's present under HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID
	if ( RegInfo.OpenAndEnumerateSubKeys (

							HKEY_LOCAL_MACHINE,
							L"SOFTWARE\\Classes\\AppID",
							KEY_READ ) == ERROR_SUCCESS  &&

			RegInfo.GetCurrentSubKeyCount()
		)
	{
		HKEY hAppIdKey = RegInfo.GethKey() ;

		do
		{
			if ( RegInfo.GetCurrentSubKeyName ( chsAppid ) == ERROR_SUCCESS )
			{
				pInstance.Attach ( CreateNewInstance ( pMethodContext ) ) ;
				if ( pInstance != NULL )
				{

					hr = FillInstanceWithProperites ( pInstance, hAppIdKey, chsAppid ) ;
					if ( SUCCEEDED ( hr ) )
					{
						hr = pInstance->Commit () ;
						if ( SUCCEEDED ( hr ) )
						{
						}
						else
						{
							break ;
						}
					}
				}
				else
				{
					//we're out of memory
					hr = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( hr == WBEM_E_OUT_OF_MEMORY )
				{
					break ;
				}
				else
				{
					//if we fail to get info. for an instance continue to get other instances
					hr = WBEM_S_NO_ERROR ;
				}
			}
		}  while ( RegInfo.NextSubKey() == ERROR_SUCCESS ) ;
	}

	return hr ;
}


HRESULT Win32_DCOMApplicationSetting :: FillInstanceWithProperites (

	CInstance *pInstance,
	HKEY hAppIdKey,
	CHString& rchsAppid
)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	CRegistry AppidRegInfo ;
	CHString chsTmp ;
	CLSID t_clsid ;
	//NOTE: Executables are registered under the AppID key in a named-value indicating the module name
	//		such as "MYOLDAPP.EXE". This named-value is of type REG_SZ and contains the stringized AppID
	//		associated with the executable. We want to skip these duplicate AppID entries.
	if ( CLSIDFromString( _bstr_t ( rchsAppid ) , &t_clsid ) != NOERROR )
	{
		//found an execuatble, so don't process the entry
		return WBEM_E_NOT_FOUND ;
	}

	//open the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID\{appid} key
	if ( AppidRegInfo.Open ( hAppIdKey, rchsAppid, KEY_READ ) == ERROR_SUCCESS )
	{
		pInstance->SetCHString ( IDS_AppID, rchsAppid ) ;

		//see if other DCOM configuration settings are present
		if ( AppidRegInfo.GetCurrentKeyValue ( NULL, chsTmp ) == ERROR_SUCCESS )
		{
			pInstance->SetCHString ( IDS_Caption, chsTmp ) ;
			pInstance->SetCHString ( IDS_Description, chsTmp ) ;
		}

		//check if the DllSurrogate value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"DllSurrogate", chsTmp )  == ERROR_SUCCESS )
		{
			pInstance->Setbool ( IDS_UseSurrogate, true ) ;

			//if the DllSurrogate value contains data , then custom surrogate is used
			if(! chsTmp.IsEmpty() )
			{
				pInstance->SetCHString ( IDS_CustomSurrogate, chsTmp ) ;
			}
		}
		else
		{
			pInstance->Setbool ( IDS_UseSurrogate, false ) ;
		}

		//check if the RemoteServerName value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"RemoteServerName", chsTmp )  == ERROR_SUCCESS &&
			 ! chsTmp.IsEmpty() )
		{
			pInstance->SetCHString ( IDS_RemoteServerName, chsTmp ) ;
		}

		//check if the RunAs value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"RunAs", chsTmp )  == ERROR_SUCCESS &&
			 ! chsTmp.IsEmpty() )
		{
			pInstance->SetCHString ( IDS_RunAsUser, chsTmp ) ;
		}

		//check if ActivateAtStorage value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"ActivateAtStorage", chsTmp )  == ERROR_SUCCESS )
		{
			if ( (! chsTmp.IsEmpty() ) && !chsTmp.CompareNoCase ( L"Y" ) )
			{
				pInstance->Setbool ( IDS_EnableAtStorageActivation, true ) ;
			}
			else
			{
				pInstance->Setbool ( IDS_EnableAtStorageActivation, false ) ;
			}
		}
		else
		{
			pInstance->Setbool ( IDS_EnableAtStorageActivation, false ) ;
		}

		//check if the AuthenticationLevel value is present
		DWORD dwAuthenticationLevel ;
		if ( AppidRegInfo.GetCurrentKeyValue( L"AuthenticationLevel", dwAuthenticationLevel )  == ERROR_SUCCESS )
		{
			pInstance->SetDWORD ( IDS_AuthenticationLevel, dwAuthenticationLevel ) ;
		}

		//check if the LocalService value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"LocalService", chsTmp )  == ERROR_SUCCESS )
		{
			pInstance->SetCHString ( IDS_LocalService, chsTmp ) ;
		}

		//check if the ServiceParameters value is present
		if ( AppidRegInfo.GetCurrentKeyValue( L"ServiceParameters", chsTmp )  == ERROR_SUCCESS )
		{
			pInstance->SetCHString ( IDS_ServiceParameters, chsTmp ) ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationlaunchallowedsetting.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	CIM_COMObjectAccessSetting.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "COMObjSecRegKey.h"
#include "Win32_DCOMApplicationLaunchAllowedSetting.h"

Win32_DCOMApplicationLaunchAllowedSetting MyWin32_DCOMApplicationLaunchAllowedSetting (
																		DCOM_APP_LAUNCH_ACCESS_SETTING,
																		IDS_CimWin32Namespace );

Win32_DCOMApplicationLaunchAllowedSetting::Win32_DCOMApplicationLaunchAllowedSetting
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_DCOMApplicationLaunchAllowedSetting::~Win32_DCOMApplicationLaunchAllowedSetting ()
{
}

//NOTE: The Security Descriptor obtained from the registry contains owner & group information.
//		But the Sid present as the owner & group can't be mapped to a valid domain/account name and we
//		get a assert because of this.
//		Same behaviour is repro'ed in DCOMCnfg.exe which reports "Account Unknown" as the owner.


HRESULT Win32_DCOMApplicationLaunchAllowedSetting::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
	//open the HKEY_LOCAL\MACHINE\SOFTWARE\Classes\AppID key
	CRegistry TmpReg, AppidRegInfo ;

	if ( AppidRegInfo.Open ( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Classes\\AppID"), KEY_READ ) == ERROR_SUCCESS )
	{
		// Collections
		TRefPointerCollection<CInstance>	DcomAppList ;

		// Perform queries
		//================

		//get all instances of Win32_DCOMApplication
//		if ( SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances ( _T("Win32_DCOMApplication"),
//			&DcomAppList, pMethodContext, IDS_CimWin32Namespace ) ) )

		if ( SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery ( L"SELECT AppID FROM Win32_DCOMApplication",
			&DcomAppList, pMethodContext, GetNamespace() ) ) )
		{
			REFPTRCOLLECTION_POSITION	pos;
			CInstancePtr pDcomApplication ;

			if ( DcomAppList.BeginEnum( pos ) )
			{
				pDcomApplication.Attach ( DcomAppList.GetNext( pos ) ) ;
				while ( pDcomApplication != NULL )
				{
					CHString chsAppID ;

					//get the Appid of the Win32_DCOMApplication
					pDcomApplication->GetCHString ( IDS_AppID, chsAppID ) ;
					if ( ! chsAppID.IsEmpty() && TmpReg.Open ( AppidRegInfo.GethKey(), chsAppID, KEY_READ )
													== ERROR_SUCCESS
						)
					{
						DWORD dwSize = 0 ;
						if ( TmpReg.GetCurrentBinaryKeyValue( _T("LaunchPermission"), NULL ,&dwSize )
								== ERROR_SUCCESS
							)
						{
							PSECURITY_DESCRIPTOR pSD = ( PSECURITY_DESCRIPTOR ) new BYTE[dwSize] ;
							if ( pSD )
							{
								try
								{
									if ( TmpReg.GetCurrentBinaryKeyValue( _T("LaunchPermission"), ( PBYTE ) pSD ,&dwSize )
											== ERROR_SUCCESS
										)
									{
										hr = CreateInstances ( pDcomApplication, pSD, pMethodContext ) ;
									}

									if ( SUCCEEDED ( hr ) )
									{
									}
									else
									{
										break ;
									}
								}
								catch ( ... )
								{
									if ( pSD )
									{
										delete[] (PBYTE) pSD ;
										pSD = NULL ;
									}

									throw ;
								}

								delete[] (PBYTE) pSD ;
								pSD = NULL ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
						else
						{
							//getit from default
						}
					}

					if ( hr == WBEM_E_OUT_OF_MEMORY )
					{
						break ;
					}

					pDcomApplication.Attach ( DcomAppList.GetNext( pos ) ) ;
				}

				DcomAppList.EndEnum();
			}
		}
	}
#endif
    return hr ;
}


HRESULT Win32_DCOMApplicationLaunchAllowedSetting::CreateInstances ( CInstance* pDcomApplication, PSECURITY_DESCRIPTOR pSD, MethodContext*  pMethodContext )
{
	HRESULT hr = S_OK ;
#ifdef NTONLY
	CCOMObjectSecurityRegistryKey tp ( pSD ) ;
	CHString chsSid;

	// create relpath for cim_comobject
	CHString chsDcomApplicationPath ;
	CHString chsFullDcomApplicationPath ;
	pDcomApplication->GetCHString( _T( "__RELPATH" ), chsDcomApplicationPath );
	chsFullDcomApplicationPath.Format(_T("\\\\%s\\%s:%s"), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace, (LPCTSTR)chsDcomApplicationPath );

	CDACL dacl;
	tp.GetDACL(dacl);

	// walk DACL & create new instance for each ACE....
	ACLPOSITION aclPos;
    // Need merged list...
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
    	t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CSid sidTrustee;

	    while ( t_ael.GetNext(aclPos, ACE ) && SUCCEEDED ( hr ) )
	    {
		    ACE.GetSID(sidTrustee);

		    if ( sidTrustee.IsValid() && ACE.IsAllowed () )
		    {
			    CInstancePtr pInstance ( CreateNewInstance( pMethodContext ), false ) ;
			    if ( pInstance != NULL )
			    {
				    pInstance->SetCHString ( IDS_Element, chsFullDcomApplicationPath );
				    chsSid.Format(_T("\\\\%s\\%s:%s.%s=\"%s\""), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
							    _T("Win32_SID"), IDS_SID, (LPCTSTR)sidTrustee.GetSidString() );

				    pInstance->SetCHString ( IDS_Setting, chsSid );
				    hr = pInstance->Commit () ;
				    if ( SUCCEEDED ( hr ) )
				    {
				    }
				    else
				    {
					    break ;
				    }
			    }
			    else
			    {
				    hr = WBEM_E_OUT_OF_MEMORY ;
			    }
		    }
	    }
	    t_ael.EndEnum(aclPos);
    }
#endif

	return hr ;
}



HRESULT Win32_DCOMApplicationLaunchAllowedSetting::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CRegistry Reg ;
    CHString chsSid, chsApplication ;
    CInstancePtr pSidInstance , pDcomApplicationInstance ;
    pInstance->GetCHString ( IDS_Element, chsApplication );
	pInstance->GetCHString( IDS_Setting, chsSid);
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsApplication, &pDcomApplicationInstance, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsSid, &pSidInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
        CHString chsAppID ;
		pDcomApplicationInstance->GetCHString ( IDS_AppID, chsAppID ) ;

		//if appid is present & configured...
		if ( ! chsAppID.IsEmpty() && Reg.Open ( HKEY_LOCAL_MACHINE,
												CHString ( L"SOFTWARE\\Classes\\AppID\\") + chsAppID ,
												KEY_READ
											  ) == ERROR_SUCCESS
			)
		{
			DWORD dwSize = 0 ;
			if ( Reg.GetCurrentBinaryKeyValue( L"LaunchPermission", NULL ,&dwSize )
					== ERROR_SUCCESS
				)
			{
				PSECURITY_DESCRIPTOR pSD = ( PSECURITY_DESCRIPTOR ) new BYTE[dwSize] ;
				if ( pSD )
				{
					try
					{
						if ( Reg.GetCurrentBinaryKeyValue( L"LaunchPermission", ( PBYTE ) pSD ,&dwSize )
								== ERROR_SUCCESS
							)
						{
							hr = CheckInstance ( pInstance, pSD ) ;
						}

					}
					catch ( ... )
					{
						if ( pSD )
						{
							delete[] (PBYTE) pSD ;
							pSD = NULL ;
						}

						throw ;
					}

					delete[] (PBYTE) pSD ;
					pSD = NULL ;
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			else
			{
				//getit from default
			}
		}
		else
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr ;
}


HRESULT Win32_DCOMApplicationLaunchAllowedSetting::CheckInstance ( CInstance* pInstance, PSECURITY_DESCRIPTOR pSD )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
#ifdef NTONLY
	CCOMObjectSecurityRegistryKey tp ( pSD ) ;
	CHString chsSid, chsSettingSid ;
	pInstance->GetCHString(IDS_Setting, chsSettingSid );

	CDACL dacl;
	tp.GetDACL(dacl);

	// walk DACL & create new instance for each ACE....
	ACLPOSITION aclPos;
    // Need merged list...
    CAccessEntryList t_ael;
    if(dacl.GetMergedACL(t_ael))
    {
	    t_ael.BeginEnum(aclPos);
	    CAccessEntry ACE;
	    CSid sidTrustee;

	    while ( t_ael.GetNext(aclPos, ACE ) )
	    {
		    ACE.GetSID(sidTrustee);
		    if ( sidTrustee.IsValid() && ACE.IsAllowed () )
		    {
			    chsSid.Format (_T("\\\\%s\\%s:%s.%s=\"%s\""), (LPCTSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
						     _T("Win32_SID"), IDS_SID, (LPCTSTR)sidTrustee.GetSidString() );

			    //check if the sid is in the dacl for the object
			    if ( ! chsSid.CompareNoCase ( chsSettingSid ) )
			    {
				    hr = WBEM_S_NO_ERROR ;
				    break ;
			    }
		    }
	    }
        t_ael.EndEnum(aclPos);
    }
#endif
	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_implementedcategory.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	CIM_COMObjectAccessSetting.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "Win32_ImplementedCategory.h"
#include <comcat.h>


Win32_ImplementedCategory MyWin32_ImplementedCategory (
														Win32_IMPLEMENTED_CATEGORIES,
														IDS_CimWin32Namespace );

Win32_ImplementedCategory::Win32_ImplementedCategory
(

 LPCWSTR strName,
 LPCWSTR pszNameSpace /*=NULL*/
)
: Provider( strName, pszNameSpace )
{
}

Win32_ImplementedCategory::~Win32_ImplementedCategory ()
{
}

HRESULT Win32_ImplementedCategory::EnumerateInstances
(
	MethodContext*  pMethodContext,
	long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	// Collections
	TRefPointerCollection<CInstance>	CatIdList ;

	//get all instances of Category-id's present
	if ( SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances ( L"Win32_ComponentCategory",
		&CatIdList, pMethodContext, IDS_CimWin32Namespace ) ) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		CInstancePtr pCatIdInstance;
		ICatInformationPtr pCatInfo = NULL ;
		hr = CoCreateInstance(
								CLSID_StdComponentCategoriesMgr,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_ICatInformation,
								(LPVOID*) &pCatInfo );
		if ( SUCCEEDED ( hr ) )
		{
			if ( CatIdList.BeginEnum( pos ) )
			{
				pCatIdInstance.Attach ( CatIdList.GetNext( pos ) ) ;
				while ( pCatIdInstance != NULL )
				{
					CHString chsCatid ;

					//get the Catid from the instance
					pCatIdInstance->GetCHString ( IDS_CategoryId, chsCatid ) ;
					bstr_t bstrtCatId = chsCatid ;
					CATID CatId ;
					hr = CLSIDFromString( bstrtCatId, &CatId ) ;

					//check if we got a valid cat-id
					if ( SUCCEEDED ( hr ) )
					{
						IEnumGUIDPtr pEnumCLSID ;
						hr = pCatInfo->EnumClassesOfCategories( 1,
																&CatId,
																((ULONG) -1),
																NULL,
																&pEnumCLSID ) ;
						//Got the Clsid enumerator....
						if ( SUCCEEDED ( hr ) )
						{
							CLSID clsid ;
							ULONG ulFetched ;
							CHString chsRef1,chsCatRef ;
							pCatIdInstance->GetCHString( L"__RELPATH", chsRef1 );
							chsCatRef.Format(L"\\\\%s\\%s:%s", (LPCWSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
															(LPCWSTR)chsRef1 );
							//get all the clsid's which support this category...
							while ( SUCCEEDED ( pEnumCLSID->Next ( 1, &clsid, &ulFetched ) ) &&
									ulFetched > 0 )
							{
								PWCHAR pwcTmp = NULL ;
								hr = StringFromCLSID ( clsid, &pwcTmp ) ;

								if ( hr == E_OUTOFMEMORY )
								{
									throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
								}

								try
								{
									//see if it's a valid clsid
									if ( SUCCEEDED ( hr ) )
									{
										CHString chsTmp ( pwcTmp ) ;
										CoTaskMemFree ( pwcTmp ) ;
										pwcTmp = NULL ;

										CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), false ) ;
										if ( pInstance != NULL )
										{
											//set the 2 reference properties
											pInstance->SetCHString ( IDS_Category, chsCatRef ) ;
											CHString chsComponentPath ;
											chsComponentPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
																	(LPCWSTR)GetLocalComputerName(),
																	IDS_CimWin32Namespace,
																	L"Win32_ClassicCOMClass",
																	IDS_ComponentId,
																	(LPCWSTR) chsTmp );

											pInstance->SetCHString ( IDS_Component, chsComponentPath ) ;
											hr = pInstance->Commit () ;

											if ( SUCCEEDED ( hr ) )
											{
											}
											else
											{
												break ;
											}
										}
										else
										{
											hr = WBEM_E_OUT_OF_MEMORY ;
										}

										if ( hr == WBEM_E_OUT_OF_MEMORY )
										{
											break ;
										}
									}
								}
								catch ( ... )
								{
									if ( pwcTmp )
									{
										CoTaskMemFree ( pwcTmp ) ;
										pwcTmp = NULL ;
									}

									throw ;
								}

								if ( pwcTmp )
								{
									CoTaskMemFree ( pwcTmp ) ;
									pwcTmp = NULL ;
								}
							}
						}
					}

					pCatIdInstance.Attach ( CatIdList.GetNext( pos ) ) ;
				}
				CatIdList.EndEnum() ;
			}
		}
	}
	return hr ;
}


HRESULT Win32_ImplementedCategory::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CInstancePtr pComponentInstance, pCategoryInstance ;
    CHString chsComponent, chsCategory ;
	pInstance->GetCHString ( IDS_Component, chsComponent );
	pInstance->GetCHString ( IDS_Category, chsCategory );
    MethodContext* pMethodContext = pInstance->GetMethodContext();

	//check whether the end-pts. are present
	hr = CWbemProviderGlue::GetInstanceByPath ( chsCategory, &pCategoryInstance, pMethodContext ) ;

	if ( SUCCEEDED ( hr ) )
	{
		hr = CWbemProviderGlue::GetInstanceByPath ( chsComponent, &pComponentInstance, pMethodContext ) ;
	}

	if ( SUCCEEDED ( hr ) )
	{
		ICatInformationPtr pCatInfo = NULL ;
		CHString chsComponentId, chsCategoryId ;
		pComponentInstance->GetCHString ( IDS_ComponentId, chsComponentId ) ;
		pCategoryInstance->GetCHString ( IDS_CategoryId, chsCategoryId ) ;
		bstr_t bstrtClsId = chsComponentId ;
		bstr_t t_bstrtCatId = chsCategoryId ;
		CLSID ClsId ;
		hr = CLSIDFromString ( bstrtClsId, &ClsId ) ;
		CLSID t_CatId ;
		if ( SUCCEEDED ( hr ) )
		{
			hr = CLSIDFromString ( t_bstrtCatId, &t_CatId ) ;
		}

		if ( SUCCEEDED ( hr ) )
		{
			hr = CoCreateInstance (
									CLSID_StdComponentCategoriesMgr,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_ICatInformation,
									(LPVOID*) &pCatInfo );
			if ( SUCCEEDED ( hr ) )
			{

				hr = pCatInfo->IsClassOfCategories (

												ClsId,
												1 ,
												&t_CatId,
												((ULONG) -1),    //Number of category IDs in the rgcatidReq
												NULL
											) ;
				if ( hr == S_OK )
				{
					hr = WBEM_S_NO_ERROR ;
				}
				else
				{
					hr = WBEM_E_NOT_FOUND ;
				}
			}
			else
			{
				hr = WBEM_E_FAILED ;
			}
		}
		else
		{
			hr = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}
	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\win32_dcomapplicationsetting.h ===
//=================================================================

//

// Win32_DCOMApplicationSetting.h -- Registered COM Application property set provider 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_DCOM_APPLICATION_SETTING L"Win32_DCOMApplicationSetting"


class Win32_DCOMApplicationSetting : public Provider
{
public:

        // Constructor/destructor
        //=======================

	Win32_DCOMApplicationSetting(LPCWSTR name, LPCWSTR pszNamespace) ;
	~Win32_DCOMApplicationSetting() ;

        // Funcitons provide properties with current values
        //=================================================

	HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags = 0L
	);

	HRESULT EnumerateInstances (

		MethodContext *pMethodContext, 
		long lFlags = 0L
	);

protected:
	
	HRESULT Win32_DCOMApplicationSetting :: FillInstanceWithProperites ( 

		CInstance *pInstance, 
		HKEY hAppIdKey,
		CHString& rchsAppid
	) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\amd64\docpuid.asm ===
title  "Processor Type and Stepping Detection"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;    docpuid.asm
;
; Abstract:
;
;    This module implements the code necessary to determine cpu information.
;
; Author:
;
;    David N. Cutler (davec) 26-Feb-2002
;
; Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

;++
;
; VOID
; DoCPUID (
;     ULONG Function,
;     DWORD *Eax,
;     DWORD *Ebx,
;     DWORD *Ecx,
;     DWORD *Edx
;     );
;
; Routine Description:
;
;   Executes the cpuid instruction and returns the resultant register
;   values.
;
; Arguments:
;
;   ecx - Supplies the cpuid function value.
;
;   rdx - Supplies a pointer to a variable to store the information returned
;       in eax.
;
;   r8 - Supplies a pointer to a variable to store the information returned
;       in ebx.
;
;   r9 - Supplies a pointer to a variable to store the information returned
;       in ecx.
;
;   40[rsp] - Supplies a pointer to a variable to store the information returned
;       in edx.
;
; Return Value:
;
;   The return values from the cpuid instruction are stored in the specified
;   variables.
;
;--

CiFrame struct
        SavedRbx dq ?                   ; saved register RBX
CiFrame ends

        NESTED_ENTRY DoCPUID, _TEXT$00

        push_reg rbx                    ; save nonvolatile register

        END_PROLOGUE

        mov     eax, ecx                ; set cpuid function
        mov     r10, rdx                ; save EAX variable address
        mov     r11, 48[rsp]            ; get EDX variable address
        cpuid                           ; get cpu information
        mov     [r10], eax              ; save cpu information in structure
        mov     [r8], ebx               ;
        mov     [r9], ecx               ;
        mov     [r11], edx              ;
        pop     rbx                     ; restore nonvolatile registeer
        ret                             ; return

        NESTED_END DoCPUID, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\connectiontosession.cpp ===
/******************************************************************

   ConnectionToSession.CPP -- C provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Association between Connection To Session  
   

******************************************************************/

#include "precomp.h"
#include "ConnectionToSession.h"

CConnectionToSession MyCConnectionToSession ( 

	PROVIDER_NAME_CONNECTIONTOSESSION , 
	Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CConnectionToSession::CConnectionToSession
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CConnectionToSession :: CConnectionToSession (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CConnectionToSession::~CConnectionToSession
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CConnectionToSession :: ~CConnectionToSession ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CConnectionToSession :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{	
 	HRESULT hRes = WBEM_S_NO_ERROR ;
	DWORD dwPropertiesReq = CONNECTIONSTOSESSION_ALL_PROPS;

	hRes = EnumConnectionInfo ( 
				L"",
				L"",
				pMethodContext,
				dwPropertiesReq
			);

    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CConnectionToSession :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CHString t_Connection ;
	CHString t_Session;


    if  ( pInstance->GetCHString ( IDS_Connection , t_Connection ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_Session , t_Session ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}
   
	if ( SUCCEEDED ( hRes ) )
	{
		CHString t_ConnComputerName;
		CHString t_ConnShareName;
		CHString t_ConnUserName;

		hRes = GetConnectionsKeyVal ( t_Connection, t_ConnComputerName, t_ConnShareName, t_ConnUserName );

		if ( SUCCEEDED ( hRes ) )
		{
			CHString t_SessComputerName;
			CHString t_SessUserName;

			hRes = GetSessionKeyVal ( t_Session, t_SessComputerName, t_SessUserName );

			if ( SUCCEEDED ( hRes ) )
			{
				// now check the shares in t_Connection and t_Session  should match
				hRes = _wcsicmp ( t_ConnComputerName, t_SessComputerName ) == 0 ? hRes : WBEM_E_NOT_FOUND;

				if ( SUCCEEDED ( hRes ) )
				{
					hRes = _wcsicmp ( t_ConnUserName, t_SessUserName ) == 0 ? hRes : WBEM_E_NOT_FOUND;

					if ( SUCCEEDED ( hRes ) )
					{
#ifdef NTONLY
						hRes = FindAndSetNTConnection ( t_ConnShareName.GetBuffer(0), t_ConnComputerName, t_ConnUserName, 
										0, pInstance, NoOp );
#endif

#if 0
#ifdef WIN9XONLY
						hRes = FindAndSet9XConnection ( t_ConnShareName, t_ConnComputerName, t_ConnUserName, 
										0, pInstance, NoOp );
#endif
#endif
					}
				}
			}
		}
	}

    return hRes ;
}

#ifdef NTONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::EnumNTConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/
HRESULT  CConnectionToSession :: EnumNTConnectionsFromComputerToShare ( 

	LPWSTR a_ComputerName,
	LPWSTR a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;
	DWORD   dwResumeHandle = 0;	

	CONNECTION_INFO  *pBuf = NULL;
	CONNECTION_INFO  *pTmpBuf = NULL;
	LPWSTR t_ComputerName = NULL;

	if ( a_ComputerName && a_ComputerName[0] != L'\0' )
	{
		//let's skip the \\ chars
		t_ComputerName = a_ComputerName + 2;
	}
	
    // ShareName and Computer Name both cannot be null at the same time
	while ( TRUE )
	{
		if ( a_ShareName[0] != L'\0' )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ShareName, 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
				
		}
		else
		if ( a_ComputerName[0] != L'\0' )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ComputerName, 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
		}

		if ( t_Status == NERR_Success )
		{
			if ( dwNoOfEntriesRead == 0 )
			{
				break;
			}
			else if ( dwNoOfEntriesRead > 0 )
			{
				try
				{
					pTmpBuf = pBuf;
		
					for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf++ )
					{
						if (pTmpBuf->coni1_netname && pBuf->coni1_username)
						{
							CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );				
							hRes = LoadInstance ( pInstance, a_ShareName, t_ComputerName ? t_ComputerName : a_ComputerName, pTmpBuf, dwPropertiesReq );

							if ( SUCCEEDED ( hRes ) )
							{
								hRes = pInstance->Commit();
								if ( FAILED ( hRes ) )
								{
									break;
								}
							}
							else
							{
								break;
							}
						}
					}
				}
				catch ( ... )
				{
					NetApiBufferFree ( pBuf );
					pBuf = NULL;
					throw;
				}
				NetApiBufferFree ( pBuf );
				pBuf = NULL;
			}
		}
		else
		{
			if ( t_Status != ERROR_MORE_DATA )
			{
				if ( t_Status == ERROR_ACCESS_DENIED )
				{
					hRes = WBEM_E_ACCESS_DENIED;
				}
				else
				{
					if ( t_Status == ERROR_NOT_ENOUGH_MEMORY )
					{
						hRes = WBEM_E_OUT_OF_MEMORY;
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}

				break;
			}
		}
	}

	return hRes;
}
#endif

#if 0
#ifdef WIN9XONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::Enum9XConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/
HRESULT  CConnectionToSession :: Enum9XConnectionsFromComputerToShare ( 

	LPWSTR a_ComputerName,
	LPWSTR a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;

	BOOL bFound = FALSE;

    CONNECTION_INFO * pBuf = NULL;
    CONNECTION_INFO * pTmpBuf = NULL;

    DWORD dwBufferSize =   MAX_ENTRIES * sizeof( CONNECTION_INFO  );

    pBuf = ( CONNECTION_INFO  *) malloc(dwBufferSize);

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = 	NetConnectionEnum( 
								NULL, 
								(char FAR *) ( a_ShareName ),  // ShareName
								1, 
								(char *) pBuf, 
								( unsigned short )dwBufferSize, 
								( unsigned short *) &dwNoOfEntriesRead, 
								( unsigned short *) &dwTotalConnections 
						);	
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}
		// otherwise we are not to frr the buffer, we have use it and then free the buffer.
		if ( ( dwNoOfEntriesRead < dwTotalConnections ) && ( t_Status == ERROR_MORE_DATA ) )
		{
			free ( pBuf );
			pBuf = NULL;

			pBuf = ( CONNECTION_INFO  *) malloc( dwTotalConnections );

			if ( pBuf != NULL ) 
			{
				try
				{
					t_Status = 	NetConnectionEnum( 
									NULL, 
									(char FAR *) ( a_ShareName ),  // ShareName
									1, 
									(char *) pBuf, 
									( unsigned short )dwBufferSize, 
									( unsigned short *) &dwNoOfEntriesRead, 
									( unsigned short *) &dwTotalConnections 
								);	
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;				
				}
				// We need to use the buffer before we free it
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		// The buffer  is yet to be used
		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == dwTotalConnections ) )
		{
			// use the buffer first and then free 
			if ( pBuf != NULL )
			{
				try
				{
					pTmpBuf = pBuf;
					for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf ++)
					{
						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
					
						hRes = LoadInstance ( pInstance, a_ShareName, a_ComputerName, pTmpBuf, dwPropertiesReq );

						if ( SUCCEEDED ( hRes ) )
						{
							hRes = pInstance->Commit();
							if ( FAILED ( hRes ) )
							{
								break;
							}
						}
					}
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;
				}
				// finally free the buffer
				free (pBuf );
				pBuf = NULL;
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return hRes;
}
#endif
#endif

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession:: LoadInstance
*
*  DESCRIPTION :    Loading an instance with the connection to Session info 
*
*****************************************************************************/
HRESULT CConnectionToSession :: LoadInstance ( 
																				
	CInstance *pInstance,
	LPCWSTR a_Share, 
	LPCWSTR a_Computer,
	CONNECTION_INFO *pBuf, 
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	LPWSTR ObjPath = NULL;
	LPWSTR SessObjPath = NULL;

	try
	{
		CHString t_NetName ( pBuf->coni1_netname );

		if ( a_Share[0] != L'\0' )
		{	
			hRes = MakeObjectPath ( ObjPath,  PROVIDER_NAME_CONNECTION, 	IDS_ComputerName, t_NetName );
			if ( SUCCEEDED ( hRes ) )
			{
				hRes = AddToObjectPath ( ObjPath, IDS_ShareName, a_Share );
			}
			if ( SUCCEEDED ( hRes ) )
			{
				hRes = MakeObjectPath ( SessObjPath, PROVIDER_NAME_SESSION, IDS_ComputerName, t_NetName );
			}
		}
		else
		{
			hRes = MakeObjectPath ( ObjPath,  PROVIDER_NAME_CONNECTION, 	IDS_ComputerName, a_Computer  );
			if ( SUCCEEDED ( hRes ) )
			{
				hRes = AddToObjectPath ( ObjPath, IDS_ShareName, t_NetName );
			}
			if ( SUCCEEDED ( hRes ) )
			{
				MakeObjectPath ( SessObjPath, PROVIDER_NAME_SESSION, IDS_ComputerName, a_Computer);
			}
		}

		CHString t_UserName ( pBuf->coni1_username );

		if ( SUCCEEDED ( hRes ) )
		{
			hRes = AddToObjectPath ( ObjPath, IDS_UserName, t_UserName );
		}

		if ( SUCCEEDED ( hRes ) )
		{
			hRes = AddToObjectPath ( SessObjPath, IDS_UserName, t_UserName );
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( pInstance->SetCHString ( IDS_Connection, ObjPath ) == FALSE )
			{
				hRes =  WBEM_E_PROVIDER_FAILURE ;
			}
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( pInstance->SetCHString ( IDS_Session, SessObjPath ) == FALSE )
			{
				hRes = WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}
	catch (...)
	{
		if (SessObjPath)
		{
			delete [] SessObjPath;
			SessObjPath = NULL;
		}

		if (ObjPath)
		{
			delete [] ObjPath;
			ObjPath = NULL;
		}

		throw;
	}

	if (SessObjPath)
	{
		delete [] SessObjPath;
		SessObjPath = NULL;
	}

	if (ObjPath)
	{
		delete [] ObjPath;
		ObjPath = NULL;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToSession::GetSessionKeyVal
*
*  DESCRIPTION :    Parsing the key to get Connection Key Value
*
*****************************************************************************/
HRESULT CConnectionToSession::GetSessionKeyVal ( 
												 
	LPCWSTR a_Key, 
	CHString &a_ComputerName, 
	CHString &a_UserName 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	ParsedObjectPath *t_ObjPath;
	CObjectPathParser t_PathParser;

	DWORD dwAllKeys = 0;

    if ( t_PathParser.Parse( a_Key, &t_ObjPath ) == t_PathParser.NoError )
	{
		try
		{
			hRes  = t_ObjPath->m_dwNumKeys != 2 ? WBEM_E_INVALID_PARAMETER : hRes;

			if ( SUCCEEDED ( hRes ) )
			{
				hRes = _wcsicmp ( t_ObjPath->m_pClass, PROVIDER_NAME_SESSION ) != 0 ? WBEM_E_INVALID_PARAMETER : hRes;

				if ( SUCCEEDED ( hRes ) )
				{
					for ( int i = 0; i < 2; i++ )
					{
                        if (V_VT(&t_ObjPath->m_paKeys[i]->m_vValue) == VT_BSTR)
                        {
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_ComputerName ) == 0 )
						    {
							    a_ComputerName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 1;							
						    }
						    else
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_UserName ) == 0 )
						    {
							    a_UserName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 2;
						    }
                        }
					}
					if ( dwAllKeys != 3 )
					{
						hRes = WBEM_E_INVALID_PARAMETER;
					}
				}
				else
				{
					hRes = WBEM_E_INVALID_PARAMETER;
				}
			}
		}
		catch ( ... )
		{
			delete t_ObjPath;
			throw;
		}
		delete t_ObjPath;
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\connection.cpp ===
/******************************************************************

   Connection.CPP -- C provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description:  Connection Provider
  
******************************************************************/

//#include <windows.h>
#include "precomp.h"
#include "Connection.h"

CConnection MyCConnection ( 

	PROVIDER_NAME_CONNECTION , 
	Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CConnection::CConnection
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CConnection :: CConnection (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CConnection::~CConnection
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CConnection :: ~CConnection ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CConnection::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CConnection :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
 	HRESULT hRes = WBEM_S_NO_ERROR;

	DWORD dwPropertiesReq = CONNECTIONS_ALL_PROPS;

	// Passing empty string to indicate no NULL computer name and shareName
	hRes = EnumConnectionInfo ( 
						L"",
						L"",
						pMethodContext,
						dwPropertiesReq
				 );

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnection::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CConnection :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ShareName ;
	CHString t_ComputerName;
	CHString t_UserName;

    if  ( pInstance->GetCHString ( IDS_ShareName , t_ShareName ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_ComputerName , t_ComputerName ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_UserName , t_UserName ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		DWORD dwPropertiesReq;

		hRes = WBEM_E_NOT_FOUND;

		if ( Query.AllPropertiesAreRequired() )
		{
			dwPropertiesReq = CONNECTIONS_ALL_PROPS;
		}
		else
		{
			SetPropertiesReq ( Query, dwPropertiesReq );
		}

#ifdef NTONLY
		hRes = FindAndSetNTConnection ( t_ShareName.GetBuffer(0), t_ComputerName, t_UserName, dwPropertiesReq, pInstance, Get );
#endif

#if 0
#ifdef WIN9XONLY
		hRes = FindAndSet9XConnection ( t_ShareName, t_ComputerName, t_UserName, dwPropertiesReq, pInstance, Get );
#endif
#endif

	}
    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    :    CConnection::ExecQuery
*
*  DESCRIPTION :    Optimization of a query only on one of the key values
*
*****************************************************************************/

HRESULT CConnection :: ExecQuery ( 

	MethodContext *pMethodContext, 
	CFrameworkQuery &Query, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwPropertiesReq;
	DWORD t_Size;

	if ( Query.AllPropertiesAreRequired() )
	{
		dwPropertiesReq = CONNECTIONS_ALL_PROPS;
	}
	else
	{
		SetPropertiesReq ( Query, dwPropertiesReq );
	}

	CHStringArray t_ShareValues;
	CHStringArray t_ComputerValues;

	// Connections can be enumerated to the shares or the connections made from the computer only on one key value we can optimize
	// Otherwise we will need to take both the set of instances, take the union of the two sets and then commit.
	// Implmenting only if one of the two keyvalues Sharename or Computername is specified.
	hRes = Query.GetValuesForProp(
			 IDS_ShareName,
			 t_ShareValues
		   );

	hRes = Query.GetValuesForProp(
			 IDS_ComputerName,
			 t_ComputerValues
		   );

	if ( SUCCEEDED ( hRes ) )
	{
		hRes = OptimizeQuery ( t_ShareValues, t_ComputerValues, pMethodContext, dwPropertiesReq );
	}

	return hRes;
}

#ifdef NTONLY

/*****************************************************************************
*
*  FUNCTION    :    CConnection::EnumNTConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/
HRESULT  CConnection :: EnumNTConnectionsFromComputerToShare ( 

	LPWSTR a_ComputerName,
	LPWSTR a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;
	DWORD   dwResumeHandle = 0;	

	CONNECTION_INFO  *pBuf = NULL;
	CONNECTION_INFO  *pTmpBuf = NULL;
	LPWSTR t_ComputerName = NULL;

	if ( a_ComputerName && a_ComputerName[0] != L'\0' )
	{
		//let's skip the \\ chars
		t_ComputerName = a_ComputerName + 2;
	}
	
    // ShareName and COmputer Name both cannot be null at the same time
	while ( TRUE )
	{
		if ( a_ShareName[0] != L'\0' )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ShareName, 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
				
		}
		else
		if ( a_ComputerName[0] != L'\0' )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ComputerName, 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
		}

		if ( t_Status == NERR_Success )
		{
			if ( dwNoOfEntriesRead == 0 )
			{
				break;
			}
			else if ( dwNoOfEntriesRead > 0 )
			{
				try
				{
					pTmpBuf = pBuf;
		
					for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf++ )
					{
						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
					
						hRes = LoadInstance ( pInstance, a_ShareName, t_ComputerName ? t_ComputerName : a_ComputerName, pTmpBuf, dwPropertiesReq );

						if ( SUCCEEDED ( hRes ) )
						{
							hRes = pInstance->Commit();
							if ( FAILED ( hRes ) )
							{
								break;
							}
						}
						else
						{
							break;
						}
					}
				}
				catch ( ... )
				{
					NetApiBufferFree ( pBuf );
					pBuf = NULL;
					throw;
				}
				NetApiBufferFree ( pBuf );
				pBuf = NULL;
			}
		}
		else
		{
			if ( t_Status != ERROR_MORE_DATA )
			{
				if ( t_Status == ERROR_ACCESS_DENIED )
				{
					hRes = WBEM_E_ACCESS_DENIED;
				}
				else
				{
					if ( t_Status == ERROR_NOT_ENOUGH_MEMORY )
					{
						hRes = WBEM_E_OUT_OF_MEMORY;
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}

				break;
			}
		}
	}

	return hRes;
}

#endif //NTONLY

#if 0
#ifdef WIN9XONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnection::Enum9XConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/

Coonnections on win9x is broken, since it cannot return a sharename and it is a part of the 
key.

HRESULT  CConnection :: Enum9XConnectionsFromComputerToShare ( 

	LPWSTR a_ComputerName,
	LPWSTR a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	USHORT dwNoOfEntriesRead = 0;
	USHORT dwTotalConnections = 0;

	BOOL bFound = FALSE;

    CONNECTION_INFO * pBuf = NULL;
    CONNECTION_INFO * pTmpBuf = NULL;

    unsigned short dwBufferSize =   MAX_ENTRIES * sizeof( CONNECTION_INFO  );

    pBuf =  ( CONNECTION_INFO *) malloc(dwBufferSize);

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = 	NetConnectionEnum( 
								NULL, 
								TOBSTRT ( a_ShareName ),  // ShareName
								( short ) 1, 
								(char FAR *) pBuf, 
								dwBufferSize, 
								&dwNoOfEntriesRead, 
								&dwTotalConnections 
						);	
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}
		// otherwise we are not to frr the buffer, we have use it and then free the buffer.
		if ( ( dwNoOfEntriesRead < dwTotalConnections ) && ( t_Status == ERROR_MORE_DATA ) )
		{
			free ( pBuf );
			pBuf = NULL;

			dwBufferSize = dwTotalConnections * sizeof( CONNECTION_INFO  );
			pBuf = ( CONNECTION_INFO *) malloc( dwBufferSize );
			
			if ( pBuf != NULL ) 
			{
				try
				{
					t_Status = 	NetConnectionEnum( 
									NULL, 
									TOBSTRT( a_ShareName),  // ShareName
									( short ) 1, 
									(char FAR *) pBuf, 
									dwBufferSize, 
									&dwNoOfEntriesRead, 
									&dwTotalConnections 
								);	
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;
				}
				// We need to use the buffer before we free it
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );;
			}
		}

		// The buffer  is yet to be used
		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == dwTotalConnections ) )
		{
			// use the buffer first and then free 
			if ( pBuf != NULL )
			{
				try
				{
					pTmpBuf = pBuf;
					for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf ++)
					{
						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
					
						hRes = LoadInstance ( pInstance, a_ShareName, a_ComputerName, pTmpBuf, dwPropertiesReq );

						if ( SUCCEEDED ( hRes ) )
						{
							hRes = pInstance->Commit();
					
							if ( FAILED ( hRes ) )
							{
								break;
							}
						}
						else
						{
							break;
						}
					}
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;
				}
				// finally free the buffer
				free (pBuf );
				pBuf = NULL;
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
	}

	return hRes;
}
#endif
#endif

/*****************************************************************************
*
*  FUNCTION    :    CConnection:: LoadInstance
*
*  DESCRIPTION :    Loading an instance with the connection info 
*
*****************************************************************************/

HRESULT CConnection :: LoadInstance ( 
										  
	CInstance *pInstance, 
	LPCWSTR a_Share, 
	LPCWSTR a_Computer, 
	CONNECTION_INFO *pBuf, 
	DWORD dwPropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;	

	if ( a_Share[0] != L'\0' )
	{	
		if ( dwPropertiesReq & CONNECTIONS_PROP_ShareName ) 
		{
			if ( pInstance->SetCharSplat ( IDS_ShareName, a_Share ) == FALSE )
			{
				hRes = WBEM_E_PROVIDER_FAILURE;
			}
		}

		if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ComputerName ) )
		{
			if ( pInstance->SetCharSplat ( IDS_ComputerName, pBuf->coni1_netname ) == FALSE )
			{
				hRes = WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}
	else
	{
		if ( dwPropertiesReq & CONNECTIONS_PROP_ComputerName ) 
		{
			if ( pInstance->SetCharSplat ( IDS_ComputerName, a_Computer ) == FALSE )
			{
				hRes =  WBEM_E_PROVIDER_FAILURE ;
			}
		}

		if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ShareName ) )
		{
			if ( pInstance->SetCharSplat ( IDS_ShareName, pBuf->coni1_netname ) == FALSE )
			{
				hRes =  WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}

	if ( SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_UserName ) )
	{
		if ( pInstance->SetCharSplat ( IDS_UserName, pBuf->coni1_username ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}

/*	if ( SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ConnectionType	 ) )
	{
		DWORD dwConnectionType;
		switch ( pBuf->coni1_type )
		{
			case STYPE_DISKTREE:	dwConnectionType = 0; break;
			case STYPE_PRINTQ:		dwConnectionType = 1; break;
			case STYPE_DEVICE:		dwConnectionType = 2; break;
			case STYPE_IPC:			dwConnectionType = 3; break;
			default:				dwConnectionType = 4; break;
		}

		if ( pInstance->SetWORD ( ConnectionType,  dwConnectionType ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}

	}
*/
	if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ConnectionID ) )
	{
		if ( pInstance->SetWORD ( IDS_ConnectionID,  pBuf->coni1_id ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}

	if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_NumberOfUsers ) )
	{
		if ( pInstance->SetWORD ( IDS_NumberOfUsers,  pBuf->coni1_num_users ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}


	if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_NumberOfFiles ) )
	{
		if ( pInstance->SetWORD ( IDS_NumberOfFiles,  pBuf->coni1_num_opens ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}

	if (  SUCCEEDED ( hRes ) && ( dwPropertiesReq & CONNECTIONS_PROP_ActiveTime	 ) )
	{
		if ( pInstance->SetWORD ( IDS_ActiveTime,  pBuf->coni1_time ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnection::OptimizeQuery
*
*  DESCRIPTION :    Optimizes a query based on the Key Values.
*
*****************************************************************************/

HRESULT CConnection::OptimizeQuery ( 
									  
	CHStringArray& a_ShareValues, 
	CHStringArray& a_ComputerValues, 
	MethodContext *pMethodContext, 
	DWORD dwPropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	if ( ( a_ShareValues.GetSize() == 0 ) && ( a_ComputerValues.GetSize() == 0 ) )
	{
		// This is a query for which there is no where clause, so it means only a few Properties are requested
		// hence we need to deliver only those properties of instances to the WinMgmt while enumerating connecctions
		hRes = EnumConnectionInfo ( 
						L"",
						L"",
						pMethodContext,
						dwPropertiesReq
					);
	}
	else
	if  ( a_ComputerValues.GetSize() != 0 ) 
	{
		CHString t_ComputerName; 
		for ( int i = 0; i < a_ComputerValues.GetSize(); i++ )
		{
			t_ComputerName.Format ( L"%s%s", L"\\\\", (LPCWSTR)a_ComputerValues.GetAt(i) );
	
			hRes = EnumConnectionInfo ( 
							t_ComputerName.GetBuffer(0),
							L"", // Share name is empty
							pMethodContext,
							dwPropertiesReq
					   );


			if ( FAILED ( hRes ) )
			{
				break;
			}	
		}
	}
	else
	if  ( a_ShareValues.GetSize() != 0 )  
	{
		for ( int i = 0; i < a_ShareValues.GetSize(); i++ )
		{
			hRes = EnumConnectionInfo ( 
							L"", 
							a_ShareValues.GetAt(i).GetBuffer(0),
							pMethodContext,
							dwPropertiesReq
					   );


			if ( FAILED ( hRes ) )
			{
				break;
			}	
		}
	}
	else
		hRes = WBEM_E_PROVIDER_NOT_CAPABLE;

	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    CConnection::SetPropertiesReq
*
*  DESCRIPTION :    Setting a bitmap for the required properties
*
*****************************************************************************/

void CConnection :: SetPropertiesReq ( CFrameworkQuery &Query, DWORD &dwPropertiesReq )
{
	dwPropertiesReq = 0;

	if ( Query.IsPropertyRequired ( IDS_ComputerName ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_ComputerName;
	}

	if ( Query.IsPropertyRequired ( IDS_ShareName ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_ShareName;
	}

	if ( Query.IsPropertyRequired ( IDS_UserName ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_UserName;
	}

	if ( Query.IsPropertyRequired ( IDS_ActiveTime ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_ActiveTime;
	}
	
	if ( Query.IsPropertyRequired ( IDS_NumberOfUsers ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_NumberOfUsers;
	}

	if ( Query.IsPropertyRequired ( IDS_NumberOfFiles ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_NumberOfFiles;
	}

	if ( Query.IsPropertyRequired ( IDS_ConnectionID ) )
	{
		dwPropertiesReq |= CONNECTIONS_PROP_ConnectionID;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\providers\wnaspi32.h ===
/****************************************************************************

*                                                                           *

* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *

* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *

* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *

* PURPOSE.                                                                  *

*                                                                           *

* Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved *
*                                                                           *
****************************************************************************/

//***************************************************************************
//
// Name: 	      WNASPI32.H
//
// Description:	ASPI for Win32 definitions ('C' Language)
//
//***************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

typedef void *LPSRB;
typedef void (*PFNPOST)();

DWORD SendASPI32Command    (LPSRB);
DWORD GetASPI32SupportInfo (VOID);

#define SENSE_LEN					14			// Default sense buffer length
#define SRB_DIR_SCSI				0x00		// Direction determined by SCSI 															// command
#define SRB_DIR_IN					0x08		// Transfer from SCSI target to 															// host
#define SRB_DIR_OUT					0x10		// Transfer from host to SCSI 															// target
#define SRB_POSTING					0x01		// Enable ASPI posting
#define SRB_EVENT_NOTIFY            0x40        // Enable ASPI event notification
#define SRB_ENABLE_RESIDUAL_COUNT	0x04		// Enable residual byte count 															// reporting
#define SRB_DATA_SG_LIST			0x02		// Data buffer points to 																	// scatter-gather list
#define WM_ASPIPOST					0x4D42		// ASPI Post message
//***************************************************************************
//						 %%% ASPI Command Definitions %%%
//***************************************************************************
#define SC_HA_INQUIRY				0x00		// Host adapter inquiry
#define SC_GET_DEV_TYPE				0x01		// Get device type
#define SC_EXEC_SCSI_CMD			0x02		// Execute SCSI command
#define SC_ABORT_SRB				0x03		// Abort an SRB
#define SC_RESET_DEV				0x04		// SCSI bus device reset
#define SC_GET_DISK_INFO			0x06		// Get Disk information

//***************************************************************************
//								  %%% SRB Status %%%
//***************************************************************************
#define SS_PENDING			0x00		// SRB being processed
#define SS_COMP				0x01		// SRB completed without error
#define SS_ABORTED			0x02		// SRB aborted
#define SS_ABORT_FAIL		0x03		// Unable to abort SRB
#define SS_ERR 				0x04		// SRB completed with error

#define SS_INVALID_CMD		0x80		// Invalid ASPI command
#define SS_INVALID_HA		0x81		// Invalid host adapter number
#define SS_NO_DEVICE		0x82		// SCSI device not installed
							
#define SS_INVALID_SRB		0xE0		// Invalid parameter set in SRB
#define SS_FAILED_INIT		0xE4		// ASPI for windows failed init
#define SS_ASPI_IS_BUSY		0xE5		// No resources available to execute cmd
#define SS_BUFFER_TO_BIG	0xE6		// Buffer size to big to handle!

//***************************************************************************
//							%%% Host Adapter Status %%%
//***************************************************************************
#define HASTAT_OK					0x00	// Host adapter did not detect an 															// error
#define HASTAT_SEL_TO				0x11	// Selection Timeout
#define HASTAT_DO_DU				0x12	// Data overrun data underrun
#define HASTAT_BUS_FREE				0x13	// Unexpected bus free
#define HASTAT_PHASE_ERR			0x14	// Target bus phase sequence 																// failure
#define HASTAT_TIMEOUT				0x09	// Timed out while SRB was 																	waiting to beprocessed.
#define HASTAT_COMMAND_TIMEOUT 		0x0B	// While processing the SRB, the
															// adapter timed out.
#define HASTAT_MESSAGE_REJECT		0x0D	// While processing SRB, the 																// adapter received a MESSAGE 															// REJECT.
#define HASTAT_BUS_RESET			0x0E	// A bus reset was detected.
#define HASTAT_PARITY_ERROR			0x0F	// A parity error was detected.
#define HASTAT_REQUEST_SENSE_FAILED	0x10	// The adapter failed in issuing
														//   REQUEST SENSE.

//***************************************************************************
//			 %%% SRB - HOST ADAPTER INQUIRY - SC_HA_INQUIRY %%%
//***************************************************************************
typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_HA_INQUIRY
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved, MUST = 0
	BYTE	HA_Count;				// Number of host adapters present
	BYTE	HA_SCSI_ID;				// SCSI ID of host adapter
	BYTE	HA_ManagerId[16];		// String describing the manager
	BYTE	HA_Identifier[16];		// String describing the host adapter
	BYTE	HA_Unique[16];			// Host Adapter Unique parameters
	WORD	HA_Rsvd1;

} SRB_HAInquiry, *PSRB_HAInquiry;

//***************************************************************************
//			  %%% SRB - GET DEVICE TYPE - SC_GET_DEV_TYPE %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_GET_DEV_TYPE
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE	SRB_DeviceType;			// Target's peripheral device type
	BYTE	SRB_Rsvd1;

} SRB_GDEVBlock, *PSRB_GDEVBlock;

//***************************************************************************
//		  %%% SRB - EXECUTE SCSI COMMAND - SC_EXEC_SCSI_CMD %%%
//***************************************************************************

typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	WORD 	SRB_Rsvd1;				// Reserved for Alignment
	DWORD	SRB_BufLen;				// Data Allocation Length
	BYTE	*SRB_BufPointer;		// Data Buffer Pointer
	BYTE	SRB_SenseLen;			// Sense Allocation Length 	
	BYTE	SRB_CDBLen;				// CDB Length
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved for alignment
	BYTE	CDBByte[16];			// SCSI CDB
	BYTE	SenseArea[SENSE_LEN+2];	// Request Sense buffer

} SRB_ExecSCSICmd, *PSRB_ExecSCSICmd;

//***************************************************************************
//				  %%% SRB - ABORT AN SRB - SC_ABORT_SRB %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	void	*SRB_ToAbort;			// Pointer to SRB to abort

} SRB_Abort, *PSRB_Abort;

//***************************************************************************
//				%%% SRB - BUS DEVICE RESET - SC_RESET_DEV %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_Rsvd1[12];			// Reserved for Alignment
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void 	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved
	BYTE	CDBByte[16];			// SCSI CDB

} SRB_BusDeviceReset, *PSRB_BusDeviceReset;

//***************************************************************************
//				%%% SRB - GET DISK INFORMATION - SC_GET_DISK_INFO %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_DriveFlags;			// Driver flags
	BYTE	SRB_Int13HDriveInfo;	// Host Adapter Status
	BYTE	SRB_Heads;				// Preferred number of heads translation
	BYTE	SRB_Sectors;			// Preferred number of sectors translation
	BYTE	SRB_Rsvd1[10];			// Reserved
} SRB_GetDiskInfo, *PSRB_GetDiskInfo;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\precomp.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

// Description:  Precompiled headers for Sessions and connections

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <initguid.h>
#include <fwcommon.h>
#include <smartptr.h>
#include <sessionConnectionCommon.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WMI Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <brodcast.h>
#include <initguid.h>

HMODULE ghModule;

// {6E78DAD9-E187-4d6e-BA63-760256D6F405}
DEFINE_GUID( CLSID_WMISESSION, 
0x6e78dad9, 0xe187, 0x4d6e, 0xba, 0x63, 0x76, 0x2, 0x56, 0xd6, 0xf4, 0x5);

#define PROVIDER_NAME L"WMIPSESS"

//Count number of objects and number of locks.
long g_cLock = 0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    
    try
    {
        if ( CLSID_WMISESSION == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow()
{
    SCODE sc = S_FALSE;

    try
    {
        sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("Microsoft Session And Connection Provider"), CLSID_WMISESSION ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_WMISESSION ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;

    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\connshare.cpp ===
/******************************************************************



 ConnShare.cpp-- Implementation of base class from which ConnectionToShare

			   ConnectionToSession and Connection classes are derived



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#include "precomp.h"
#include "connshare.h"


/*****************************************************************************
*
*  FUNCTION    :    CConnShare::CConnShare
*
*  DESCRIPTION :    Constructor
*
*****************************************************************************/
CConnShare ::  CConnShare ( )
{
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::~CConnShare
*
*  DESCRIPTION :    Destructor
*
*****************************************************************************/
CConnShare :: ~ CConnShare ( ) 
{
}

#ifdef NTONLY

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::GetNTShares
*
*  DESCRIPTION :    Enumerates all the  Shares on NT
*
*****************************************************************************/
HRESULT CConnShare :: GetNTShares ( CHStringArray &t_Shares )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;

	DWORD dwNoOfEntriesRead = 0;
	DWORD dwTotalEntries = 0;

	DWORD dwResumeHandle = 0;
	PSHARE_INFO_0 pBuf, pTempBuf;

	while ( true ) 
	{
		t_Status = NetShareEnum ( 
						NULL,  //Server
						0,		//level
						(LPBYTE *) &pBuf, 
						-1,  // Preferred Max Length
						&dwNoOfEntriesRead, 
						&dwTotalEntries, 
						&dwResumeHandle 
				   );

		if (( t_Status == NERR_Success ) || (t_Status == ERROR_MORE_DATA))
		{
			try
			{
				pTempBuf = pBuf;

				for( DWORD i = 0; i < dwNoOfEntriesRead; i++, pTempBuf++ )
				{ 
					t_Shares.Add ( pTempBuf->shi0_netname ); 
				}
			}
			catch ( ... )
			{
				NetApiBufferFree( pBuf );
				pBuf = NULL;
				throw;
			}

			NetApiBufferFree( pBuf );
			pBuf = NULL;
		}

		if ( t_Status != ERROR_MORE_DATA )
		{
			if ( t_Status == NERR_Success )
			{
				hRes = WBEM_S_NO_ERROR;
			}
			else
			{
				if ( t_Status == ERROR_ACCESS_DENIED )
				{
					hRes = WBEM_E_ACCESS_DENIED;
				}
				else
				{
					if ( t_Status == ERROR_NOT_ENOUGH_MEMORY )
					{
						hRes = WBEM_E_OUT_OF_MEMORY;
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}
			}

			break;
		}
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::FindAndSetNTConnection
*
*  DESCRIPTION :    Finds the instance and if presnt does an appropriate operation.
*
*****************************************************************************/
HRESULT CConnShare :: FindAndSetNTConnection ( 
											   
	LPWSTR t_ShareName, 
	LPCWSTR t_NetName, 
	LPCWSTR t_UserName, 
	DWORD dwPropertiesReq, 
	CInstance *pInstance, 
	DWORD eOperation 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;
	DWORD   dwResumeHandle = 0;

	CONNECTION_INFO  *pBuf = NULL;
	CONNECTION_INFO  *pTempBuf = NULL;
		
	while ( true )
	{
		t_Status = 	NetConnectionEnum( 
						NULL, 
						t_ShareName,  // ShareName
						1, 
						(LPBYTE *) &pBuf, 
						-1, 
						&dwNoOfEntriesRead, 
						&dwTotalConnections, 
						&dwResumeHandle
					);

		if ( ( ( t_Status == NERR_Success )  && ( dwNoOfEntriesRead == 0 ) ) ||
			( ( t_Status != NERR_Success ) && ( t_Status != ERROR_MORE_DATA ) ) )
		{
			hRes = WBEM_E_NOT_FOUND;
			break;
		}

		try
		{
			pTempBuf = pBuf;
			BOOL bFound = FALSE;
			for ( DWORD dwConnIndex = 0 ; dwConnIndex < dwNoOfEntriesRead ; dwConnIndex ++, pTempBuf++ )
			{
				if ( pTempBuf->coni1_netname && 
                     pTempBuf->coni1_username &&
                     ( _wcsicmp ( t_NetName, pTempBuf->coni1_netname ) == 0 ) && 
					 ( _wcsicmp (t_UserName, pTempBuf->coni1_username ) == 0 ) )
				{
					bFound = TRUE;
					break ;
				}
			}

			if ( bFound ) 
			{
				// We are not to free the buff in this loop, but free it after using this buffer
				break;
			}

			if ( t_Status != ERROR_MORE_DATA )
			{
				hRes = WBEM_E_NOT_FOUND;
				NetApiBufferFree ( pBuf );
				pBuf = NULL;

				break;
			}
		}
		catch ( ... )
		{
			NetApiBufferFree ( pBuf );
			pBuf = NULL;
			throw;
		}
		NetApiBufferFree ( pBuf );
		pBuf = NULL;
	}
			
	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			switch ( eOperation )
			{
			case Get:		hRes = LoadInstance ( 
										pInstance,
										t_ShareName,
										t_NetName,
										pTempBuf, 
										dwPropertiesReq 
								   );
			case NoOp:		break; //do nothing

			default:		hRes = WBEM_E_INVALID_PARAMETER; break;

			}
		}
		catch ( ... )
		{
			NetApiBufferFree( pBuf );
			pBuf = NULL;
			throw;
		}

		NetApiBufferFree( pBuf );
		pBuf = NULL;
	}
	return hRes;
}
#endif

#if 0
#ifdef WIN9XONLY
	
/*****************************************************************************
*
*  FUNCTION    :    CConnShare::Get9XShares
*
*  DESCRIPTION :    Enumerates all the  Shares on WIN9X
*
*****************************************************************************/

HRESULT CConnShare :: Get9XShares ( CHStringArray &t_Shares )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD t_Status = NERR_Success;

	DWORD dwNoOfEntriesRead = 0;
	DWORD dwTotalEntries = 0;

    struct share_info_1* pBuf = NULL;
    struct share_info_1* pTmpBuf = NULL;

    DWORD dwBufferSize =   MAX_ENTRIES * sizeof( struct share_info_0 );

    pBuf = ( struct share_info_1 *) malloc ( dwBufferSize );

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = NetShareEnum (
								NULL,
								1,
								(char FAR *)pBuf,
								 ( unsigned short ) dwBufferSize,
								 ( unsigned short *) &dwNoOfEntriesRead,
								 ( unsigned short *) &dwTotalEntries
					   );


			if ( dwNoOfEntriesRead > 0 ) 
			{
				pTmpBuf = pBuf;
                CHString t_NetName;

				for( DWORD i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf++ )
				{ 
					t_NetName = pTmpBuf->shi1_netname;
					t_Shares.Add ( t_NetName ); 
				}
			}
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}
		free ( pBuf );
		pBuf = NULL;
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	if ( ( dwNoOfEntriesRead < dwTotalEntries ) || ( t_Status == ERROR_MORE_DATA ) )
	{ 
		DWORD oldENtriesRead = dwNoOfEntriesRead;

		pBuf = ( struct share_info_1 *) malloc ( dwTotalEntries );

		if ( pBuf != NULL )
		{
			try
			{
				t_Status = NetShareEnum (
									NULL,
									1,
									(char FAR *)pBuf,
									 ( unsigned short ) dwBufferSize,
									 ( unsigned short *) &dwNoOfEntriesRead,
									 ( unsigned short *) &dwTotalEntries
						   );


				if ( t_Status == NERR_Success ) 
				{
					pTmpBuf = pBuf;
                    CHString t_NetName;

					for( DWORD i = oldENtriesRead; i < dwNoOfEntriesRead; i++, pTmpBuf )
					{ 
						t_NetName = pTmpBuf->shi1_netname;
						t_Shares.Add ( t_NetName ); 
					}
				}
				else
				{
					hRes = WBEM_E_FAILED;
				}
			}
			catch ( ... )
			{
				free ( pBuf );
				pBuf = NULL;
				throw;
			}
			free ( pBuf );
			pBuf = NULL;
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::FindAndSet9XConnection
*
*  DESCRIPTION :    Finds the instance and if presnt does an appropriate operation.
*
*****************************************************************************/
HRESULT CConnShare :: FindAndSet9XConnection ( 
											   
	LPWSTR t_ShareName, 
	LPCWSTR t_NetName, 
	LPCWSTR t_UserName, 
	DWORD dwPropertiesReq, 
	CInstance *pInstance, 
	DWORD eOperation 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;

	BOOL bFound = FALSE;

    CONNECTION_INFO * pBuf = NULL;
    CONNECTION_INFO * pTmpBuf = NULL;

    DWORD dwBufferSize =   MAX_ENTRIES * sizeof( CONNECTION_INFO  );

    pBuf = ( CONNECTION_INFO *) malloc(dwBufferSize);

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = 	NetConnectionEnum( 
								NULL, 
								(char FAR *) ( t_ShareName ),  // ShareName
								1, 
								(char *) pBuf, 
								( unsigned short )dwBufferSize, 
								( unsigned short *) &dwNoOfEntriesRead, 
								( unsigned short *) &dwTotalConnections 
							);


			if ( dwNoOfEntriesRead > 0 ) 
			{
				pTmpBuf = pBuf;
                CHString t_TempNetNameStr, t_UserName ;

				for ( DWORD dwConnIndex = 0 ; dwConnIndex < dwNoOfEntriesRead ; dwConnIndex ++, pTmpBuf++ )
				{
					t_TempNetNameStr = pTmpBuf->coni1_netname;
					t_UserName = pTmpBuf->coni1_username;

					if ( ( _wcsicmp ( t_NetName, t_TempNetNameStr ) == 0 ) && 
									( t_UserName.CompareNoCase ( t_UserName ) == 0 ) )
					{
						bFound = TRUE;
						break ;
					}
				}
			}
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}

		if ( bFound == FALSE )
		{
			// if found is TRUE pBuf is not to be freed since the found entry is yet to be used
			free ( pBuf );
			pBuf = NULL;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	if ( ! bFound && ( dwNoOfEntriesRead < dwTotalConnections ) && ( t_Status == ERROR_MORE_DATA ) )
	{
		DWORD dwOldNoOfEntries = dwNoOfEntriesRead;
		dwBufferSize =   dwTotalConnections * sizeof( CONNECTION_INFO );

		pBuf = ( CONNECTION_INFO  *) malloc(dwBufferSize);

		if ( pBuf != NULL )
		{
			try
			{
				t_Status = 	NetConnectionEnum( 
								NULL, 
								(char FAR *) ( t_ShareName ),  // ShareName
								1, 
								(char *) pBuf, 
								( unsigned short )dwBufferSize, 
								( unsigned short *) &dwNoOfEntriesRead, 
								( unsigned short *) &dwTotalConnections 
							);

				if ( dwNoOfEntriesRead > 0 ) 
				{
					pTmpBuf = pBuf;
                    CHString t_TempNetNameStr, t_UserName;
					for ( DWORD dwConnIndex = dwOldNoOfEntries ; dwConnIndex < dwNoOfEntriesRead ; dwConnIndex ++, pTmpBuf++ )
					{
						t_TempNetNameStr = pTmpBuf->coni1_netname;
						t_UserName = pTmpBuf->coni1_username;

						if ( ( _wcsicmp ( t_NetName, t_TempNetNameStr ) == 0 ) && 
										( _wcsicmp (t_UserName, t_UserName ) == 0 ) )
						{
							bFound = TRUE;
							break ;
						}
					}
				}
			}
			catch ( ... )
			{
				free ( pBuf );
				pBuf = NULL;
				throw;
			}
			if ( ! bFound )
			{
				// Free the buffer only if not found, otherwise it needs to be freed after using this found entry
				free ( pBuf );						
				pBuf = NULL;
			}
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	if ( bFound == FALSE ) 
	{
		hRes = WBEM_E_NOT_FOUND;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			switch ( eOperation )
			{
			case Get:		hRes = LoadInstance ( 
										pInstance,
										t_ShareName,
										t_NetName,
										pTmpBuf, 
										dwPropertiesReq 
								   );
			case NoOp:		break; //do nothing

			default:		hRes = WBEM_E_INVALID_PARAMETER; break;

			}
		}
		catch ( ... )
		{
			free( pBuf );
			pBuf = NULL;
			throw;
		}

		free( pBuf );
		pBuf = NULL;
	}
	return hRes;
}
#endif
#endif // #if 0

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::EnumConnectionInfo
*
*  DESCRIPTION :    Enumerates all the NT connections information
*
*****************************************************************************/

HRESULT CConnShare :: EnumConnectionInfo (
	
	LPWSTR  a_ComputerName,
	LPWSTR  a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	if ( ( a_ComputerName[0] != L'\0' ) || ( a_ShareName[0] != L'\0' ) )
	{
#ifdef NTONLY
		hRes = EnumNTConnectionsFromComputerToShare ( 

					a_ComputerName,
					a_ShareName,
					pMethodContext,
					dwPropertiesReq
				 );	
#endif

#if 0
#ifdef WIN9XONLY
		hRes = Enum9XConnectionsFromComputerToShare ( 

						a_ComputerName,
						a_ShareName,
						pMethodContext,
						dwPropertiesReq
					);
#endif
#endif // #if 0
	}	
	else
	if ( ( a_ComputerName[0] == L'\0' ) && (  a_ShareName[0] == L'\0' ) )
	{	
		CHStringArray t_Shares;

#ifdef NTONLY
		hRes = GetNTShares ( t_Shares );
#endif

#if 0
#ifdef WIN9XONLY
		hRes = Get9XShares ( t_Shares );
#endif
#endif // #if 0

		if  ( SUCCEEDED ( hRes ) )
		{
			for ( int i = 0; i < t_Shares.GetSize() ; i++ )
			{
#ifdef NTONLY
				hRes = EnumNTConnectionsFromComputerToShare ( 

								a_ComputerName,
								t_Shares.GetAt ( i ).GetBuffer(0),
								pMethodContext,
								dwPropertiesReq
							);
#endif

#if 0
#ifdef WIN9XONLY
				hRes = Enum9XConnectionsFromComputerToShare ( 

								a_ComputerName,
								t_Shares.GetAt ( i ),
								pMethodContext,
								dwPropertiesReq
							);
#endif
#endif // #if 0
			}
		}	
	}

	return hRes;;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::GetConnectionsKeyVal
*
*  DESCRIPTION :    Parsing the key to get Connection Key Value
*
*****************************************************************************/
HRESULT CConnShare::GetConnectionsKeyVal ( 
												 
	LPCWSTR a_Key, 
	CHString &a_ComputerName, 
	CHString &a_ShareName, 
	CHString &a_UserName 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	ParsedObjectPath *t_ObjPath;
	CObjectPathParser t_PathParser;

	DWORD dwAllKeys = 0;

    if ( t_PathParser.Parse( a_Key, &t_ObjPath ) == t_PathParser.NoError )
	{
		try
		{
			hRes  = t_ObjPath->m_dwNumKeys != 3 ? WBEM_E_INVALID_PARAMETER : hRes;

			if ( SUCCEEDED ( hRes ) )
			{
                hRes = (t_ObjPath->m_pClass) && _wcsicmp ( t_ObjPath->m_pClass, PROVIDER_NAME_CONNECTION ) == 0 ? WBEM_S_NO_ERROR: WBEM_E_INVALID_PARAMETER;

				if ( SUCCEEDED ( hRes ) )
				{
					for ( int i = 0; i < 3; i++ )
					{
                        if (V_VT(&t_ObjPath->m_paKeys[i]->m_vValue) == VT_BSTR)
                        {
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_ComputerName ) == 0 )
						    {
							    a_ComputerName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 1;							
						    }
						    else
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_ShareName ) == 0 )
						    {
							    a_ShareName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 2;

						    }
						    if ( _wcsicmp ( t_ObjPath->m_paKeys[i]->m_pName, IDS_UserName ) == 0 )
						    {
							    a_UserName = t_ObjPath->m_paKeys[i]->m_vValue.bstrVal;
							    dwAllKeys |= 4;

						    }
                        }
                        else
                        {
                            break;
                        }
					}
					if ( dwAllKeys != 7 )
					{
						hRes = WBEM_E_INVALID_PARAMETER;
					}
				}
				else
				{
					hRes = WBEM_E_INVALID_PARAMETER;
				}
			}
		}
		catch ( ... )
		{
			delete t_ObjPath;
			throw;
		}
		delete t_ObjPath;
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::MakeObjectPath
*
*  DESCRIPTION :    Makes the Object Path Given given a class name, a key Name 
*					and a key value
*
*****************************************************************************/

HRESULT CConnShare::MakeObjectPath (
										   
	 LPWSTR &a_ObjPathString,  
	 LPCWSTR a_ClassName, 
	 LPCWSTR a_AttributeName, 
	 LPCWSTR a_AttributeVal 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	ParsedObjectPath t_ObjPath;
	variant_t t_Path;

	t_Path = a_AttributeVal;

	hRes = t_ObjPath.SetClassName ( a_ClassName ) ? hRes : WBEM_E_INVALID_PARAMETER;
	
	if ( SUCCEEDED ( hRes ) )
	{
		hRes = t_ObjPath.AddKeyRef ( a_AttributeName, &t_Path ) ? hRes : WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		CObjectPathParser t_PathParser;

		hRes = t_PathParser.Unparse( &t_ObjPath, &a_ObjPathString ) == t_PathParser.NoError ? hRes : WBEM_E_INVALID_PARAMETER;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnShare::AddToObjectPath
*
*  DESCRIPTION :    Adds a key name and a value to the existing Object path
*
*****************************************************************************/

HRESULT CConnShare::AddToObjectPath ( 

	 LPWSTR &a_ObjPathString,  
	 LPCWSTR a_AttributeName, 
	 LPCWSTR  a_AttributeVal 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	ParsedObjectPath *t_ObjPath;
	variant_t t_Path;
	CObjectPathParser t_PathParser;

    if ( t_PathParser.Parse( a_ObjPathString, &t_ObjPath ) == t_PathParser.NoError )
	{
		try
		{
			t_Path = a_AttributeVal;
			if ( t_ObjPath->AddKeyRef ( a_AttributeName, &t_Path ) )
			{
				// delete the oldpath string
				if ( a_ObjPathString != NULL )
				{
					delete [] a_ObjPathString;
					a_ObjPathString = NULL;
				}
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER;
			}

			hRes = t_PathParser.Unparse( t_ObjPath, &a_ObjPathString ) == t_PathParser.NoError ? hRes : WBEM_E_INVALID_PARAMETER;
		}
		catch ( ... )
		{
			delete t_ObjPath;
			throw;
		}
		delete t_ObjPath;		
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\connectiontoshare.cpp ===
/******************************************************************

   ConnectionToShare.CPP -- C provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Association between Connection and Share class
  
******************************************************************/

#include "precomp.h"

#include "ConnectionToShare.h"

CConnectionToShare MyCConnectionToShare ( 

	PROVIDER_NAME_CONNECTIONTOSHARE , 
	Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CConnectionToShare::CConnectionToShare
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CConnectionToShare :: CConnectionToShare (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CConnectionToShare::~CConnectionToShare
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CConnectionToShare :: ~CConnectionToShare ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CConnectionToShare :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{	
 	HRESULT hRes = WBEM_S_NO_ERROR ;
	DWORD dwPropertiesReq = CONNECTIONSTOSHARE_ALL_PROPS;
	CHString t_ComputerName;
	CHString t_ShareName;

	hRes = EnumConnectionInfo ( 
				t_ComputerName,
				t_ShareName,
				pMethodContext,
				dwPropertiesReq
			 ) ;

    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CConnectionToShare :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CHString t_Key1 ;
	CHString t_Key2;

    if  ( pInstance->GetCHString ( IDS_Connection , t_Key1 ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_Resource , t_Key2 ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}
	// here we will need to unparse the keys and check if the instance exist
	// We can take the resource (share) key and enumerate all  the shares, 
	// check if the share exists, if the share exists only for that share enumerate connections
	// and if the connection user and computer enumerate the connections, if it is found set the keys
	// otherwise return not found
	CHString t_Share;
	hRes = GetShareKeyVal ( t_Key2, t_Share );
	
	if ( SUCCEEDED ( hRes ) )
	{
		CHString t_ComputerName;
		CHString t_ShareName;
		CHString t_UserName;

		hRes = GetConnectionsKeyVal ( t_Key1, t_ComputerName, t_ShareName, t_UserName );
		if ( SUCCEEDED ( hRes ) )
		{
			// now check the shares in t_key1 and t_key  should match
			if ( _wcsicmp ( t_Key2, t_ShareName ) == 0 )
			{
#ifdef NTONLY
				hRes = FindAndSetNTConnection ( t_ShareName, t_ComputerName, t_UserName, 
										0, pInstance, NoOp );
#endif

#if 0
#ifdef WIN9XONLY
				hRes = FindAndSet9XConnection ( t_ShareName, t_ComputerName, t_UserName, 
										0, pInstance, NoOp );
#endif
#endif
			}
		}
	}

    return hRes ;
}

#ifdef NTONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::EnumNTConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerates all Connections from a computer to share
*
*****************************************************************************/

HRESULT CConnectionToShare :: EnumNTConnectionsFromComputerToShare ( 

	CHString a_ComputerName,
	CHString a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;
	DWORD   dwResumeHandle = 0;	

	CONNECTION_INFO  *pBuf = NULL;
	CONNECTION_INFO  *pTmpBuf = NULL;
	LPWSTR t_ComputerName = NULL;

	if ( a_ComputerName && a_ComputerName[0] != L'\0' )
	{
		//let's skip the \\ chars
		t_ComputerName = a_ComputerName + 2;
	}
	
    // ShareName and COmputer Name both cannot be null at the same time
	while ( TRUE )
	{
		if ( ! a_ShareName.IsEmpty())
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ShareName.GetBuffer ( a_ShareName.GetLength() + 1), 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
				
		}
		else
		if ( ! a_ComputerName.IsEmpty() )
		{
			t_Status = 	NetConnectionEnum( 
							NULL, 
							a_ComputerName.GetBuffer ( a_ShareName.GetLength() + 1 ), 
							1, 
							(LPBYTE *) &pBuf, 
							-1, 
							&dwNoOfEntriesRead, 
							&dwTotalConnections, 
							&dwResumeHandle
						);
		}

		if ( t_Status == NERR_Success )
		{
			if ( dwNoOfEntriesRead == 0 )
			{
				break;
			}
			else if ( dwNoOfEntriesRead > 0 )
			{
				try
				{
					pTmpBuf = pBuf;
		
					for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf++ )
					{
						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
					
						hRes = LoadInstance ( pInstance, a_ShareName, t_ComputerName ? t_ComputerName : a_ComputerName, pTmpBuf, dwPropertiesReq );

						if ( SUCCEEDED ( hRes ) )
						{
							hRes = pInstance->Commit();
							if ( FAILED ( hRes ) )
							{
								break;
							}
						}
						else
						{
							break;
						}
					}
				}
				catch ( ... )
				{
					NetApiBufferFree ( pBuf );
					pBuf = NULL;
					throw;
				}
				NetApiBufferFree ( pBuf );
				pBuf = NULL;
			}
		}
		else
		{
			if ( t_Status != ERROR_MORE_DATA )
			{
				if ( t_Status == ERROR_ACCESS_DENIED )
				{
					hRes = WBEM_E_ACCESS_DENIED;
				}
				else
				{
					if ( t_Status == ERROR_NOT_ENOUGH_MEMORY )
					{
						hRes = WBEM_E_OUT_OF_MEMORY;
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}

				break;
			}
		}
	}
	return hRes;
}
#endif

#if 0 
#ifdef WIN9XONLY
/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::Enum9XConnectionsFromComputerToShare
*
*  DESCRIPTION :    Enumerating all the connections made from a computer to 
*					a given share
*
*****************************************************************************/
HRESULT  CConnectionToShare :: Enum9XConnectionsFromComputerToShare ( 

	CHString a_ComputerName,
	CHString a_ShareName,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalConnections = 0;

	BOOL bFound = FALSE;

    CONNECTION_INFO * pBuf = NULL;
    CONNECTION_INFO * pTmpBuf = NULL;

    DWORD dwBufferSize =   MAX_ENTRIES * sizeof( CONNECTION_INFO  );

    pBuf = ( CONNECTION_INFO  *) malloc(dwBufferSize);

    if ( pBuf != NULL )
	{
		try
		{
			t_Status = 	NetConnectionEnum( 
								NULL, 
								(char FAR *) ( a_ShareName.GetBuffer ( a_ShareName.GetLength () + 1 )),  // ShareName
								1, 
								(char *) pBuf, 
								( unsigned short )dwBufferSize, 
								( unsigned short *) &dwNoOfEntriesRead, 
								( unsigned short *) &dwTotalConnections 
						);	
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;
			throw;
		}
		// otherwise we are not to frr the buffer, we have use it and then free the buffer.
		if ( ( dwNoOfEntriesRead < dwTotalConnections ) && ( t_Status == ERROR_MORE_DATA ) )
		{
			free ( pBuf );
			pBuf = NULL;

			pBuf = ( CONNECTION_INFO  *) malloc( dwTotalConnections );

			if ( pBuf != NULL ) 
			{
				try
				{
					t_Status = 	NetConnectionEnum( 
									NULL, 
									(char FAR *) ( a_ShareName.GetBuffer ( a_ShareName.GetLength () + 1 )),  // ShareName
									1, 
									(char *) pBuf, 
									( unsigned short )dwBufferSize, 
									( unsigned short *) &dwNoOfEntriesRead, 
									( unsigned short *) &dwTotalConnections 
								);	
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;				
				}
				// We need to use the buffer before we free it
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		// The buffer  is yet to be used
		if ( ( t_Status == NERR_Success ) && ( dwNoOfEntriesRead == dwTotalConnections ) )
		{
			// use the buffer first and then free 
			if ( pBuf != NULL )
			{
				try
				{
					pTmpBuf = pBuf;
					for ( int i = 0; i < dwNoOfEntriesRead; i++, pTmpBuf ++)
					{
						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
					
						hRes = LoadInstance ( pInstance, a_ShareName, a_ComputerName, pTmpBuf, dwPropertiesReq );

						if ( SUCCEEDED ( hRes ) )
						{
							hRes = pInstance->Commit();
						}
					}
				}
				catch ( ... )
				{
					free ( pBuf );
					pBuf = NULL;
					throw;
				}
				// finally free the buffer
				free (pBuf );
				pBuf = NULL;
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return hRes;
}
#endif
#endif

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::LoadInstance
*
*  DESCRIPTION :    Loads the Given Instance
*
*****************************************************************************/

HRESULT CConnectionToShare :: LoadInstance ( 
											
	CInstance *pInstance,
	CHString a_Share, 
	CHString a_Computer,
	CONNECTION_INFO *pBuf, 
	DWORD dwPropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	LPWSTR ObjPath;
	LPWSTR ResObjPath;

	CHString t_NetName ( pBuf->coni1_netname );
	if ( ! a_Share.IsEmpty() )
	{	
		hRes = MakeObjectPath ( ObjPath,  PROVIDER_NAME_CONNECTION, IDS_ComputerName, t_NetName.GetBuffer ( t_NetName.GetLength () + 1) );
		if ( SUCCEEDED ( hRes ) )
		{
			hRes = AddToObjectPath ( ObjPath, IDS_ShareName, a_Share.GetBuffer (a_Share.GetLength () + 1)  );
		}
		
		if ( SUCCEEDED ( hRes ) )
		{
			hRes = MakeObjectPath ( ResObjPath, PROVIDER_SHARE, IDS_ShareKeyName, a_Share.GetBuffer (a_Share.GetLength () + 1) );
		}
	}
	else
	{
		hRes = MakeObjectPath ( ObjPath,  PROVIDER_NAME_CONNECTION, IDS_ComputerName, a_Computer.GetBuffer ( a_Computer.GetLength () +1));
		if ( SUCCEEDED ( hRes ) )
		{
			hRes = AddToObjectPath ( ObjPath, IDS_ShareName, t_NetName.GetBuffer ( t_NetName.GetLength () + 1) );
		}

		if ( SUCCEEDED ( hRes ) )
		{
			MakeObjectPath ( ResObjPath, PROVIDER_SHARE, IDS_ShareKeyName, t_NetName.GetBuffer ( t_NetName.GetLength () + 1) );
		}
	}

	CHString t_UserName ( pBuf->coni1_username );

	if ( SUCCEEDED ( hRes ) )
	{
		hRes = AddToObjectPath ( ObjPath, IDS_UserName, t_UserName.GetBuffer ( t_UserName.GetLength () + 1 ) );
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( pInstance->SetCHString ( IDS_Connection, ObjPath ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE;
		}	
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( pInstance->SetCHString ( IDS_Resource, ResObjPath ) == FALSE )
		{
			hRes = WBEM_E_PROVIDER_FAILURE;
		}
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CConnectionToShare::GetShareKeyVal
*
*  DESCRIPTION :    Parsing the key to get the share key value
*
*****************************************************************************/

HRESULT CConnectionToShare::GetShareKeyVal ( CHString a_Key, CHString &a_Share )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	ParsedObjectPath *t_ShareObjPath;
	CObjectPathParser t_PathParser;

    if ( t_PathParser.Parse( a_Key.GetBuffer ( a_Key.GetLength () + 1 ), &t_ShareObjPath ) == t_PathParser.NoError )
	{
		try
		{
			if ( t_ShareObjPath->m_dwNumKeys == 1 )
			{
				a_Share = t_ShareObjPath->GetKeyString();
				if ( ! a_Share.IsEmpty() )
				{
					CHStringArray t_aShares;

#ifdef NTONLY
					hRes = GetNTShares ( t_aShares );
#endif
#if 0
#ifdef WIN9XONLY
					hRes = Get9XShares ( t_aShares );
#endif
#endif
					if ( SUCCEEDED ( hRes ) )
					{
						int i = 0;
						for ( i = 0; i < t_aShares.GetSize(); i++ )
						{
							if ( _wcsicmp ( a_Share, t_aShares.GetAt(i) ) == 0 )
							{	
								break;
							}
						}
						
						if ( i >= t_aShares.GetSize() )
						{
							hRes = WBEM_E_NOT_FOUND;
						}
					}
				}
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER;
			}
		}
		catch ( ... )
		{
			delete t_ShareObjPath;
			throw;
		}
		delete t_ShareObjPath;
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <Binding.h>

CBinding Win32_ConnectionShare(
    L"Win32_ConnectionShare",
    Namespace,
    L"Win32_ServerConnection",
    L"Win32_Share",
    L"Dependent",
    L"Antecedent",
    L"ShareName",
    L"Name"
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\connection.h ===
/******************************************************************





 Connection.h-- 



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/
#ifndef  _CONNECTION_H_
#define  _CONNECTION_H_

#include "Connshare.h"


class CConnection : public Provider, public CConnShare
{

private:

#ifdef NTONLY
	HRESULT  EnumNTConnectionsFromComputerToShare ( 

		LPWSTR a_ComputerName,
		LPWSTR a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif

#if 0
#ifdef WIN9XONLY
	HRESULT  Enum9XConnectionsFromComputerToShare ( 

		LPWSTR a_ComputerName,
		LPWSTR a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif 
#endif // #if 0
// for this method only the type of the connection structure parameter changes based on the OS.
	HRESULT LoadInstance ( 
		CInstance *pInstance,
		LPCWSTR a_Share, 
		LPCWSTR a_Computer, 
		CONNECTION_INFO *pBuf, 
		DWORD PropertiesReq
	);

	HRESULT OptimizeQuery ( 
										  
		CHStringArray& a_ShareValues, 
		CHStringArray& a_ComputerValues, 
		MethodContext *pMethodContext, 
		DWORD dwPropertiesReq 
	);

	void SetPropertiesReq ( 
		
		CFrameworkQuery &Query,
		DWORD &PropertiesReq
	);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;
		

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0
		) ;

public:
  
        CConnection (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CConnection () ;

private:

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\dll\session.cpp ===
/******************************************************************

   Session.CPP -- C provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Session Provider 
   
******************************************************************/

#include "precomp.h"

#include "Session.h"

CSession MyCSession ( 

	PROVIDER_NAME_SESSION , 
	Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CSession::CSession
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CSession :: CSession (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CSession::~CSession
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CSession :: ~CSession ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CSession :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
 	HRESULT hRes = WBEM_S_NO_ERROR ;

	DWORD dwPropertiesReq = SESSION_ALL_PROPS;

#ifdef NTONLY
	hRes = EnumNTSessionInfo ( 
					NULL,
					NULL,
					502,
					pMethodContext,
					dwPropertiesReq
			 );
#endif

#if 0
#ifdef WIN9XONLY

	hRes = Enum9XSessionInfo ( 

					50,
					pMethodContext,
					dwPropertiesReq
			 );
#endif
#endif // #if 0

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CSession :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ComputerName ;
	CHString t_UserName;

    if  ( pInstance->GetCHString ( IDS_ComputerName , t_ComputerName ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED  ( hRes ) )
	{
		if  ( pInstance->GetCHString ( IDS_UserName , t_UserName ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED  ( hRes ) )
	{
		DWORD dwPropertiesReq = 0;

		if ( Query.AllPropertiesAreRequired () )
		{
			dwPropertiesReq = SESSION_ALL_PROPS;
		}
		else
		{
			SetPropertiesReq ( Query,dwPropertiesReq );
		}

		short t_Level;

#ifdef NTONLY
		GetNTLevelInfo ( dwPropertiesReq, &t_Level );
		hRes = FindAndSetNTSession ( t_ComputerName, t_UserName.GetBuffer(0), t_Level, dwPropertiesReq, pInstance, Get );
#endif

#if 0
#ifdef WIN9XONLY
		Get9XLevelInfo ( dwPropertiesReq, &t_Level );
		hRes = FindAndSet9XSession ( t_ComputerName, t_UserName, t_Level, dwPropertiesReq, pInstance, Get );
#endif
#endif // #if 0
	}

    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    :    CSession:: DeleteInstance
*
*  DESCRIPTION :    Deletes an Session if it exists
*
*****************************************************************************/

HRESULT CSession :: DeleteInstance (

	const CInstance &Instance, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_ComputerName ;
	CHString t_UserName;

    if  ( Instance.GetCHString ( IDS_ComputerName , t_ComputerName ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED  ( hRes ) )
	{
		if  ( Instance.GetCHString ( IDS_UserName , t_UserName ) == FALSE )
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED  ( hRes ) )
	{
		CInstancePtr pInstance;		// This will not be used in this method.
#ifdef NTONLY
		hRes = FindAndSetNTSession ( t_ComputerName, t_UserName.GetBuffer(0), 10, 0, pInstance, Delete );
#endif

#if 0
#ifdef WIN9XONLY
		hRes = FindAndSet9XSession ( t_ComputerName, t_UserName, 50, 0, pInstance, Delete );
#endif
#endif // #if 0

	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::ExecQuery
*
*  DESCRIPTION :    Optimizing a query  on filtering Properties and the Key value
*
*****************************************************************************/

HRESULT CSession :: ExecQuery ( 

	MethodContext *pMethodContext, 
	CFrameworkQuery &Query, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwPropertiesReq;
	short t_Level;

	if ( Query.AllPropertiesAreRequired () )
	{
		dwPropertiesReq = SESSION_ALL_PROPS;
	}
	else
	{
		SetPropertiesReq ( Query,dwPropertiesReq );
	}

#ifdef NTONLY
	GetNTLevelInfo ( dwPropertiesReq, &t_Level );
#endif
#if 0
#ifdef WIN9XONLY
	Get9XLevelInfo ( dwPropertiesReq, &t_Level );
#endif
#endif // #if 0

	CHStringArray t_ComputerValues;
	CHStringArray  t_UserValues;

	hRes = Query.GetValuesForProp(
				IDS_ComputerName,
				t_ComputerValues
		   );

	hRes = Query.GetValuesForProp(
				IDS_UserName,
				t_UserValues
		   );

	if ( SUCCEEDED ( hRes ) )
	{
		short t_Level;

#ifdef NTONLY
		GetNTLevelInfo ( dwPropertiesReq, &t_Level );
		hRes = OptimizeNTQuery ( t_ComputerValues, t_UserValues, t_Level, pMethodContext, dwPropertiesReq );
#endif

#if 0
#ifdef WIN9XONLY 
		Get9XLevelInfo ( dwPropertiesReq, &t_Level );
		hRes = Optimize9XQuery ( t_ComputerValues, t_UserValues, t_Level, pMethodContext, dwPropertiesReq );
#endif
#endif // #if 0
	}

	return hRes;
}

#ifdef NTONLY
/*****************************************************************************
*
*  FUNCTION    :    CSession::EnumNTSessionInfo
*
*  DESCRIPTION :    Enumerating all the Sessions 
*
*****************************************************************************/

HRESULT CSession :: EnumNTSessionInfo (

	LPWSTR lpComputerName,
	LPWSTR lpUserName,
	short a_Level,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	NET_API_STATUS t_Status = NERR_Success;
	HRESULT hRes = WBEM_S_NO_ERROR;

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalSessions = 0;
	DWORD   dwResumeHandle = 0;

	void *pBuf = NULL;
	void *pTmpBuf = NULL;

	while ( ( t_Status == NERR_Success ) || ( t_Status == ERROR_MORE_DATA ) )
	{
		t_Status =  NetSessionEnum(
						NULL,     
						lpComputerName,  
						lpUserName,       
						a_Level,           
						(LPBYTE *) &pBuf,        
						-1,      
						&dwNoOfEntriesRead,   
						&dwTotalSessions,  
						&dwResumeHandle  
				    );

		if ( t_Status == NERR_Success )
		{
			if ( dwNoOfEntriesRead == 0 )
			{
				break;
			}
			else
			{
				try
				{
					pTmpBuf = pBuf;

					for ( int i = 0; i < dwNoOfEntriesRead; i++ )
					{
						CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
					
						hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );

						if ( SUCCEEDED ( hRes ) )
						{
							hRes = pInstance->Commit();

							if ( FAILED ( hRes ) )
							{
								break;
							}
						}
		
						// here need to go to the next structure based on the level, we will typecast with the apropriate structure
						// and then increment by one
						switch ( a_Level )
						{
						case 502 :  SESSION_INFO_502 *pTmpTmpBuf502;
									pTmpTmpBuf502 = ( SESSION_INFO_502 *) pTmpBuf;
									pTmpTmpBuf502 ++;
									pTmpBuf = ( void * ) pTmpTmpBuf502;
									break;
						case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
									pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
									pTmpTmpBuf2 ++;
									pTmpBuf = ( void * ) pTmpTmpBuf2;
									break;
						case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
									pTmpTmpBuf1 = ( SESSION_INFO_1 *) pTmpBuf;
									pTmpTmpBuf1 ++;
									pTmpBuf = ( void * ) pTmpTmpBuf1;
									break;
						case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
									pTmpTmpBuf10 = ( SESSION_INFO_10 *) pTmpBuf;
									pTmpTmpBuf10 ++;
									pTmpBuf = ( void * ) pTmpTmpBuf10;
									break;
						}
					}

					if ( FAILED ( hRes ) )
					{
						break;
					}
				}
				catch ( ... )
				{
					NetApiBufferFree ( pBuf );
					pBuf = NULL;
					throw;
				}
				NetApiBufferFree ( pBuf );
				pBuf = NULL;
			}
		}
		else
		{
			if ( t_Status == ERROR_ACCESS_DENIED )
			{
				hRes = WBEM_E_ACCESS_DENIED;
			}
			else
			{
				if ( t_Status == ERROR_NOT_ENOUGH_MEMORY )
				{
					hRes = WBEM_E_OUT_OF_MEMORY;
				}
				else
				{
					hRes = WBEM_E_FAILED;
				}
			}
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::FindAndSetNTSession
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CSession::FindAndSetNTSession ( LPCWSTR a_ComputerName, LPWSTR a_UserName, short a_Level, DWORD dwPropertiesReq, 
								CInstance *pInstance, DWORD eOperation )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;		
	CHString t_TempKey;

	t_TempKey.Format ( L"%s%s",L"\\\\", a_ComputerName );

	DWORD	dwNoOfEntriesRead = 0;
	DWORD   dwTotalSessions = 0;
	DWORD   dwResumeHandle = 0;

	void *pBuf = NULL;

	// since it will be only one structure 
	t_Status =  NetSessionEnum(
					NULL,     
					t_TempKey.GetBuffer ( 0 ),  
					a_UserName,   
					a_Level,           
					(LPBYTE *) &pBuf,        
					-1,      
					&dwNoOfEntriesRead,   
					&dwTotalSessions,  
					&dwResumeHandle  
			  );


	hRes = ( t_Status != NERR_Success ) && ( dwNoOfEntriesRead == 0 ) ? WBEM_E_NOT_FOUND : hRes;

	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			switch ( eOperation )
			{
			case Get:	hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );
						break;
			case Delete:	hRes = t_Status = NetSessionDel	( 
																NULL,
																t_TempKey.GetBuffer ( 0 ), 
																a_UserName
															);

							if ( t_Status == NERR_Success )
							{
								hRes = WBEM_S_NO_ERROR;
							}
							else
							{
								if ( t_Status == ERROR_ACCESS_DENIED )
								{
									hRes = WBEM_E_ACCESS_DENIED;
								}
								else
								{
									if ( t_Status == ERROR_NOT_ENOUGH_MEMORY )
									{
										hRes = WBEM_E_OUT_OF_MEMORY;
									}
									else
									{
										hRes = WBEM_E_FAILED;
									}
								}
							}
							break;

			default:	hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
						break;
			}
		}
		catch ( ... )
		{
			if ( pBuf != NULL )
			{
				NetApiBufferFree(pBuf);
				pBuf = NULL;
			}
			throw;
		}
		if ( pBuf != NULL )
		{
			NetApiBufferFree(pBuf);
			pBuf = NULL;
		}
	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    Session::OptimizeNTQuery
*
*  DESCRIPTION :    Optimizes a query based on the key values.
*
*****************************************************************************/

HRESULT CSession::OptimizeNTQuery ( 
									  
	CHStringArray& a_ComputerValues, 
	CHStringArray& a_UserValues,
	short a_Level,
	MethodContext *pMethodContext, 
	DWORD dwPropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	if ( ( a_ComputerValues.GetSize() == 0 ) && ( a_UserValues.GetSize() == 0 ) )
	{
		// This is a query for which there is no where clause, so it means only a few Properties are requested
		// hence we need to deliver only those properties of instances to the WinMgmt while enumerating Sessions
		hRes = EnumNTSessionInfo ( 
						NULL,
						NULL,
						a_Level,
						pMethodContext,
						dwPropertiesReq
					);
	}
	else
	if  ( a_UserValues.GetSize() != 0 ) 
	{
		for ( int i = 0; i < a_UserValues.GetSize(); i++ )
		{
			hRes = EnumNTSessionInfo ( 
							NULL,
							a_UserValues.GetAt( i ).GetBuffer ( 0 ),
							a_Level,
							pMethodContext,
							dwPropertiesReq
						);
		}
	}
	else
	if  ( a_ComputerValues.GetSize() != 0 ) 
	{
		CHString t_ComputerName;
		for ( int i = 0; i < a_ComputerValues.GetSize(); i++ )
		{
			t_ComputerName.Format ( L"%s%s", L"\\\\", (LPCWSTR)a_ComputerValues.GetAt(i) );

			hRes = EnumNTSessionInfo ( 
							t_ComputerName.GetBuffer(0),
							NULL,
							a_Level,
							pMethodContext,
							dwPropertiesReq
					   );
		}
	}
	else
	{
		hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::GetNTLevelInfo
*
*  DESCRIPTION :    Getting the level info, so that the appropriate structure
*					Can be passed to make a call.
*
*****************************************************************************/

void CSession :: GetNTLevelInfo ( 

	DWORD dwPropertiesReq,
	short *a_Level 
)
{
	//
	// enuminstances uses level 502
	//
	// as NetSessionEnum is going to fail for non-admin user for level 502
	// we cannot be specific about level as ordinary user can obtain some
	// values for some properties when using downgrading level
	//
	// decision was taken to make all call with 502 level then !
	//

	*a_Level = 502;

	/*
	if ( ( dwPropertiesReq == SESSION_ALL_PROPS )  || 
		 ( (dwPropertiesReq & SESSION_PROP_TransportName) == SESSION_PROP_TransportName )
	   )
	{
		*a_Level = 502;
	}
	else
	if ( (dwPropertiesReq & SESSION_PROP_ClientType) == SESSION_PROP_ClientType )
	{
		*a_Level = 2;
	}
	else
	if ( ( (dwPropertiesReq & SESSION_PROP_NumOpens) == SESSION_PROP_NumOpens ) ||  
		 ( (dwPropertiesReq & SESSION_PROP_SessionType) == SESSION_PROP_SessionType )
	   )
	{
		*a_Level = 1;
	}
	else
	{
		// Since keys will be always required we need to atleast use Level 10 structure and level 0 cannot be used since,
		// it gives only username, where as computername is also a key.
		*a_Level = 10;
	}
	*/
} 
#endif

/*****************************************************************************
*
*  FUNCTION    :    CSession::LoadData
*  DESCRIPTION :    Loading an instance with the obtained information
*
*****************************************************************************/

HRESULT CSession :: LoadData ( 
						
	short a_Level,
	void *pTmpBuf,
	DWORD dwPropertiesReq ,
	CInstance *pInstance
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	// every property is to be set based on the level and then typecasting that buffer with that level.
	if ( dwPropertiesReq & SESSION_PROP_Computer) 
	{
		CHString  t_ComputerName;
		switch ( a_Level )
		{
#ifdef NTONLY
		case 502 :  t_ComputerName = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_cname;
					break;
#endif
		case 2:		t_ComputerName = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_cname;
					break;
		case 1:		t_ComputerName = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_cname;
					break;
		case 10:	t_ComputerName = ( (SESSION_INFO_10 *) pTmpBuf )->sesi10_cname;
					break;
#if 0
#ifdef WIN9XONLY
		case 50:	t_ComputerName = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_cname;
					break;
#endif
#endif // #if 0
		}

		if ( SUCCEEDED ( hRes ) )
		{
			if ( pInstance->SetCHString ( IDS_ComputerName, t_ComputerName ) == FALSE )
			{
				hRes = WBEM_E_PROVIDER_FAILURE ;
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_User )
		{
			CHString  t_User;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_User = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_username;
						break;
#endif
			case 2:		t_User = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_username;
						break;
			case 1:		t_User = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_username;
						break;
			case 10:	t_User = ( (SESSION_INFO_10 *) pTmpBuf )->sesi10_username;
						break;
#if 0
#ifdef WIN9XONLY
			case 50:	t_User = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_username;
						break;
#endif
#endif // #if 0
			}
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetCHString ( IDS_UserName, t_User ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_ActiveTime ) 
		{
			DWORD  t_ActiveTime;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_ActiveTime = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_time;
						break;
#endif
			case 2:		t_ActiveTime = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_time;
						break;
			case 1:		t_ActiveTime = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_time;
						break;
			case 10:	t_ActiveTime = ( (SESSION_INFO_10 *) pTmpBuf )->sesi10_time;
						break;
#if 0
#ifdef WIN9XONLY
			case 50:	t_ActiveTime = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_time;
						break;
#endif
#endif // #if 0
			}
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetWORD ( IDS_ActiveTime, t_ActiveTime ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_IdleTime ) 
		{
			DWORD  t_IdleTime;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_IdleTime = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_idle_time;
						break;
#endif
			case 2:		t_IdleTime = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_idle_time;
						break;
			case 1:		t_IdleTime = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_idle_time;
						break;
			case 10:	t_IdleTime = ( (SESSION_INFO_10 *) pTmpBuf )->sesi10_idle_time;
						break;
#if 0
#ifdef WIN9XONLY
			case 50:	t_IdleTime = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_idle_time;
						break;
#endif
#endif
			}

			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetWORD ( IDS_IdleTime, t_IdleTime ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_NumOpens ) 
		{
			DWORD  t_NumOpens;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_NumOpens = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_num_opens;
						break;
#endif
			case 2:		t_NumOpens = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_num_opens;
						break;
			case 1:		t_NumOpens = ( (SESSION_INFO_1 *) pTmpBuf )->sesi1_num_opens;
						break;
#if 0
#ifdef WIN9XONLY
			case 50:	t_NumOpens = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_num_opens;
						break;
#endif
#endif
			}
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetWORD ( IDS_ResourcesOpened, t_NumOpens ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{	
		if ( dwPropertiesReq & SESSION_PROP_TransportName ) 
		{
			CHString  t_TransportName;
#ifdef NTONLY
			if  ( a_Level == 502 )
			{
				t_TransportName = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_transport;
			}
#endif

#if 0
#ifdef WIN9XONLY
			if  ( a_Level == 50 )
			{
				WCHAR w_TName[100];
				w_TName[0] = ( (SESSION_INFO_50 *) pTmpBuf )->sesi50_protocol;
				w_TName [ 1 ] = _T('\0');
				t_TransportName = w_TName;
			}
#endif
#endif
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetCHString ( IDS_TransportName, t_TransportName ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_ClientType ) 
		{
			CHString  t_ClientType;
			switch ( a_Level )
			{
#ifdef NTONLY
			case 502 :  t_ClientType = ( (SESSION_INFO_502 *) pTmpBuf)->sesi502_cltype_name;
						break;
#endif

#if 0
#ifdef WIN9XONLY 
			case 2:		t_ClientType = ( (SESSION_INFO_2 *) pTmpBuf )->sesi2_cltype_name;
						break;
#endif
#endif // #if 0
			}
			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetCHString ( IDS_ClientType, t_ClientType ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

#ifdef NTONLY
	if ( SUCCEEDED ( hRes ) )
	{
		if ( dwPropertiesReq & SESSION_PROP_SessionType ) 
		{
			DWORD dwflags;
			DWORD dwSessionType;

			switch ( a_Level )
			{
			case 502 :  dwflags = ( (SESSION_INFO_502 *) pTmpBuf )->sesi502_user_flags;
						break;
			}

			switch ( dwflags )
			{
			case SESS_GUEST:	dwSessionType =  0;
								break;

			case SESS_NOENCRYPTION: dwSessionType = 1;
									break;

			default : dwSessionType =  dwSessionType = 2;
			}

			if ( SUCCEEDED ( hRes ) )
			{
				if ( pInstance->SetDWORD ( IDS_SessionType, dwSessionType ) == FALSE )
				{
					hRes = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}
#endif

	return hRes;
}

#if 0
#ifdef WIN9XONLY

/*****************************************************************************
*
*  FUNCTION    :    CSession::Enum9XSessionInfo
*
*  DESCRIPTION :    Enumerating all the Sessions on 9X
*
*****************************************************************************/

HRESULT CSession :: Enum9XSessionInfo (

	short  a_Level,
	MethodContext *pMethodContext,
	DWORD dwPropertiesReq
)
{
	NET_API_STATUS t_Status = NERR_Success;
	HRESULT hRes = WBEM_S_NO_ERROR;

	unsigned short dwNoOfEntriesRead = 0;
	unsigned short dwTotalSessions = 0;

	void *pBuf = NULL;
	void *pTmpBuf = NULL;
	DWORD dwSize = 0;

	// Determine the size of the structure, for the level passed.
	switch ( a_Level )
	{
		case 1:  dwSize = sizeof ( SESSION_INFO_1 );
				 break;
        case 2:  dwSize = sizeof ( SESSION_INFO_2 );
				 break;
		case 10: dwSize = sizeof ( SESSION_INFO_10 );
				 break;
		case 50:  dwSize = sizeof ( SESSION_INFO_50 );
				 break;
	}

	unsigned short  cbBuffer = MAX_ENTRIES * dwSize;

	pBuf = ( char FAR * )  malloc ( cbBuffer );

	if ( pBuf != NULL )
	{
		try
		{
			t_Status =  NetSessionEnum(
							NULL,      
							a_Level,                       
							(char FAR *) pBuf,                
							cbBuffer,           
							&dwNoOfEntriesRead, 
							&dwTotalSessions   
						);

			if ( ( t_Status == ERROR_MORE_DATA ) || ( dwTotalSessions > dwNoOfEntriesRead ) )
			{
				// Free the buffer and make a API call again by allocating a buffer of the required size.
				free ( pBuf );
				pBuf = NULL;

				cbBuffer = ( dwTotalSessions * dwSize );

				pBuf = ( char FAR * )  malloc ( cbBuffer );

				if ( pBuf != NULL )
				{
					try
					{
						t_Status =  NetSessionEnum(
										NULL,      
										a_Level,                       
										( char FAR *) pBuf,                
										cbBuffer,           
										&dwNoOfEntriesRead, 
										&dwTotalSessions   
						);

						if ( t_Status != NERR_Success )
						{
							hRes = WBEM_E_FAILED;
						}
					}
					catch ( ... )
					{
						if ( pBuf != NULL )
						{
							free ( pBuf );
						}
						pBuf = NULL;
					}
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
		}
		catch ( ... )
		{
			if ( pBuf != NULL )
			{
				free ( pBuf );
				pBuf = NULL;
			}
			throw;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}
	
	if ( SUCCEEDED ( hRes ) )
	{
		if ( ( dwNoOfEntriesRead > 0 ) && ( pBuf != NULL ) )
		{
			try
			{
				pTmpBuf = pBuf;

				for ( int i = 0; i < dwNoOfEntriesRead; i++ )
				{
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
				
					hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );

					if ( SUCCEEDED ( hRes ) )
					{
						hRes = pInstance->Commit();
				
						if ( FAILED ( hRes ) )
						{
							break;
						}
					}
	
					// here need to go to the next structure based on the level, we will typecast with the apropriate structure
					// and then increment by one
					switch ( a_Level )
					{
					case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
								pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
								pTmpTmpBuf2 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf2;
								break;
					case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
								pTmpTmpBuf1 = ( SESSION_INFO_1 *) pTmpBuf;
								pTmpTmpBuf1 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf1;
								break;
					case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
								pTmpTmpBuf10 = ( SESSION_INFO_10 *) pTmpBuf;
								pTmpTmpBuf10 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf10;
								break;
					case 50:	SESSION_INFO_50 *pTmpTmpBuf50;
								pTmpTmpBuf50 = ( SESSION_INFO_50 *) pTmpBuf;
								pTmpTmpBuf50 ++;
								pTmpBuf = ( void * ) pTmpTmpBuf50;
								break;
					default:	hRes = WBEM_E_FAILED; 
					}
				}
			}
			catch ( ... )
			{
				free ( pBuf );
				pBuf = NULL;
				throw;
			}
			free ( pBuf );
			pBuf = NULL;
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::FindAndSet9XSession
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CSession::FindAndSet9XSession ( 
									   
	LPCWSTR a_ComputerName, 
	LPWSTR a_UserName, 
	short a_Level, 
	DWORD dwPropertiesReq, 								
	CInstance *pInstance, 
	DWORD eOperation 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	NET_API_STATUS t_Status = NERR_Success;		
	CHString t_TempKey;

	t_TempKey.Format ( L"%s%s",L"\\\\", a_ComputerName );

	unsigned short dwNoOfEntriesRead = 0;
	unsigned short dwTotalSessions = 0;

	void *pBuf = NULL;
	void *pTmpBuf = NULL;
	DWORD dwSize = 0;

	// Determine the size of the structure, for the level passed.
	switch ( a_Level )
	{
		case 1:  dwSize = sizeof ( SESSION_INFO_1 );
				 break;
        case 2:  dwSize = sizeof ( SESSION_INFO_2 );
				 break;
		case 10: dwSize = sizeof ( SESSION_INFO_10 );
				 break;
		case 50: dwSize = sizeof ( SESSION_INFO_50 );
				 break;
	}

	unsigned short  cbBuffer = 0; 

	t_Status =  NetSessionGetInfo(
					NULL,
					(const char FAR *) ( a_UserName.GetBuffer ( 0 ) ),    
					a_Level,                      
					( char FAR * ) pBuf,               
					cbBuffer,          
					&dwTotalSessions 
				);

	hRes =  dwTotalSessions == 0 ? WBEM_E_NOT_FOUND : hRes;

	if ( SUCCEEDED ( hRes ) )
	{
		// here we need to read all the entries associated with the user, and then 
		// search from this list for a given computer
		if ( t_Status != NERR_BufTooSmall )
		{

			cbBuffer = dwTotalSessions * dwSize;

			pBuf = ( char FAR * )  malloc ( cbBuffer );

			if ( pBuf != NULL )
			{
				t_Status =  NetSessionGetInfo(
								NULL,
								(const char FAR *) ( a_UserName.GetBuffer ( 0 ) ),    
								a_Level,                      
								( char FAR * ) pBuf,               
								cbBuffer,          
								&dwTotalSessions 
							);
				try 
				{
					// now search for a given computer
					void *pTempBuf = pBuf;
					int i = 0;
					for ( i = 0; i < dwTotalSessions; i ++ )
					{
						CHString t_CompName;

						switch ( a_Level )
						{
						case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
									pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
									t_CompName = pTmpTmpBuf2->sesi2_cname;
									break;

						case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
									pTmpTmpBuf1 = (SESSION_INFO_1 *) pTmpBuf;
									t_CompName = pTmpTmpBuf1->sesi1_cname;
									break;

						case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
									pTmpTmpBuf10 = (SESSION_INFO_10 *) pTmpBuf;
									t_CompName = pTmpTmpBuf10->sesi10_cname;
									break;
						case 50:	SESSION_INFO_50 *pTmpTmpBuf50;
										pTmpTmpBuf50 = (SESSION_INFO_50 *) pTmpBuf;
										t_CompName = pTmpTmpBuf50->sesi50_cname;
										break;
						}

						if ( a_ComputerName.CompareNoCase ( t_TempKey ) == 0 )
						{
							break;
						}
						// otherwise need to go to the next entry;
						switch ( a_Level )
						{
						case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
									pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
									pTmpTmpBuf2++;
									pTmpBuf = ( void * ) pTmpTmpBuf2;
									break;

						case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
									pTmpTmpBuf1 = (SESSION_INFO_1 *) pTmpBuf;
									pTmpTmpBuf1++;
									pTmpBuf = ( void * ) pTmpTmpBuf1;
									break;

						case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
									pTmpTmpBuf10 = (SESSION_INFO_10 *) pTmpBuf;
									pTmpTmpBuf10++;
									pTmpBuf = ( void * ) pTmpTmpBuf10;
									break;
						case 50:	SESSION_INFO_50 *pTmpTmpBuf50;
									pTmpTmpBuf50 = (SESSION_INFO_50 *) pTmpBuf;
									pTmpTmpBuf50++;
									pTmpBuf = ( void * ) pTmpTmpBuf50;
									break;
						}
					}
					if ( i >= dwTotalSessions )
					{
						hRes = WBEM_E_NOT_FOUND;
					}
				}
				catch ( ... )
				{
					free ( pBuf );
					throw;
				}
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		try
		{
			switch ( eOperation )
			{
			case Get:	hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );
						break;
			// Expects  a Session Key as a parameter and as a result we need to read more than one structure for every instance.
			// but the documents say it requires a sharename.
		/*	case Delete: hRes =  t_Status = NetSessionDel( 
										NULL,
										(LPTSTR) t_TempKey.GetBuffer ( 0 ), 
										(LPTSTR) a_UserName.GetBuffer ( 0 ) ;
								 );
								 hRes = t_Status == NERR_Success ? hRes : WBEM_E_FAILED;
								 break;*/
		

			default:	hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
						break;
			}
		}
		catch ( ... )
		{
			free ( pBuf );
			pBuf = NULL;

			throw;
		}
		free ( pBuf );
		pBuf = NULL;
	}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    Session::Optimize9XQuery
*
*  DESCRIPTION :    Optimizes a query based on the key values.
*
*****************************************************************************/

HRESULT CSession::Optimize9XQuery ( 
									  
	CHStringArray &a_ComputerValues, 
	CHStringArray &a_UserValues,
	short a_Level,
	MethodContext *pMethodContext, 
	DWORD dwPropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	NET_API_STATUS t_Status = NERR_Success;

	if  ( a_ComputerValues.GetSize() == 0 ) 
	{
		// This is a query for which there is no where clause, so it means only a few Properties are requested
		// hence we need to deliver only those properties of instances to the WinMgmt while enumerating Sessions
		hRes = Enum9XSessionInfo ( 

						a_Level,
						pMethodContext,
						dwPropertiesReq
					);
	}
	else
	if  ( a_UserValues.GetSize() != 0 ) 
	{
		DWORD	dwNoOfEntriesRead = 0;
		DWORD   dwTotalSessions = 0;
		void *pBuf = NULL;
		void *pTmpBuf = NULL;
		DWORD dwSize = 0;
		BOOL bNoMoreEnums = FALSE;
		// Determine the size of the structure, for the level passed.
		switch ( a_Level )
		{
			case 1:  dwSize = sizeof ( SESSION_INFO_1 );
					 break;
			case 2:  dwSize = sizeof ( SESSION_INFO_2 );
					 break;
			case 10: dwSize = sizeof ( SESSION_INFO_10 );
					 break;
			case 50: dwSize = sizeof ( SESSION_INFO_50 );
					 break;
		}

		for ( int i = 0; i < a_UserValues.GetSize(); i++ )
		{
			unsigned short  cbBuffer = 0; 

			t_Status =  NetSessionGetInfo(
							NULL,
							(const char FAR *) ( a_UserValues.GetAt ( i ).GetBuffer ( 0 ) ),    
							a_Level,                      
							( char FAR * ) pBuf,               
							cbBuffer,          
							(unsigned short FAR *) dwTotalSessions 
						);

			if ( dwTotalSessions == 0 )
			{
				continue;
			}

			if ( SUCCEEDED ( hRes ) )
			{
				// here we need to read all the entries associated with the user, and then 
				// search from this list for a given computer
				if ( t_Status != NERR_BufTooSmall )
				{

					cbBuffer = dwTotalSessions * dwSize;

					pBuf = ( char FAR * )  malloc ( cbBuffer );

					if ( pBuf != NULL )
					{
						t_Status =  NetSessionGetInfo(
										NULL,
										(const char FAR *) ( a_UserValues.GetAt ( i ).GetBuffer ( 0 ) ),    
										a_Level,                      
										( char FAR * ) pBuf,               
										cbBuffer,          
										(unsigned short FAR *) dwTotalSessions 
									);
						try 
						{
							void *pTempBuf = pBuf;
							int i = 0;
							for ( i = 0; i < dwTotalSessions; i ++ )
							{
								CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
							
								hRes = LoadData ( a_Level, pBuf, dwPropertiesReq, pInstance );

								if ( SUCCEEDED ( hRes ) )
								{
									hRes = pInstance->Commit();
							
									if ( FAILED ( hRes ) )
									{
										bNoMoreEnums = TRUE;
										break;
									}
								}

								if ( bNoMoreEnums )
								{
									break;
								}

								// otherwise need to go to the next entry;
								switch ( a_Level )
								{
								case 2:		SESSION_INFO_2 *pTmpTmpBuf2;
											pTmpTmpBuf2 = (SESSION_INFO_2 *) pTmpBuf;
											pTmpTmpBuf2++;
											pTmpBuf = ( void * ) pTmpTmpBuf2;
											break;

								case 1:		SESSION_INFO_1 *pTmpTmpBuf1;
											pTmpTmpBuf1 = (SESSION_INFO_1 *) pTmpBuf;
											pTmpTmpBuf1++;
											pTmpBuf = ( void * ) pTmpTmpBuf1;
											break;

								case 10:	SESSION_INFO_10 *pTmpTmpBuf10;
											pTmpTmpBuf10 = (SESSION_INFO_10 *) pTmpBuf;
											pTmpTmpBuf10++;
											pTmpBuf = ( void * ) pTmpTmpBuf10;
											break;
								case 50:	SESSION_INFO_50 *pTmpTmpBuf50;
											pTmpTmpBuf50 = (SESSION_INFO_50 *) pTmpBuf;
											pTmpTmpBuf50++;
											pTmpBuf = ( void * ) pTmpTmpBuf50;
											break;
								}
							}
						}
						catch ( ... )
						{
							free ( pBuf );
							pBuf = NULL;
							throw;
						}
						free ( pBuf );
						pBuf = NULL;
					}
					else
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}
			}
		}
	}
	else
	{
		hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CSession::Get9XLevelInfo
*
*  DESCRIPTION :    Getting the level info, so that the appropriate structure
*					Can be passed to make a call.
*
*****************************************************************************/

void CSession :: Get9XLevelInfo ( 

	DWORD dwPropertiesReq,
	short *a_Level 
)
{
	// Right now making an assumption that Transport/Protocol name is not required 
	// as otherwise we will need to make 2 api calls if we need to get Protocol and Clienttype.
	// There is no support for the other levels other than level 50.

	*a_Level = 50;
	/*if ( dwPropertiesReq == SESSION_ALL_PROPS )  
	{
		*a_Level = 2;
	}
	else
	if (dwPropertiesReq & SESSION_PROP_NumOpens)
	{
		*a_Level = 1;
	}
	else
	{
		*a_Level = 10;
	}*/
} 

#endif 
#endif // #if 0

/*****************************************************************************
*
*  FUNCTION    :    CSession::SetPropertiesReq
*
*  DESCRIPTION :    Setting a bitmap for the required properties
*
*****************************************************************************/

void CSession :: SetPropertiesReq ( 
									 
	CFrameworkQuery &Query,
	DWORD &dwPropertiesReq
)
{
	dwPropertiesReq = 0;

	if ( Query.IsPropertyRequired ( IDS_ComputerName ) )
	{
		dwPropertiesReq |= SESSION_PROP_Computer;
	}
	if ( Query.IsPropertyRequired ( IDS_UserName ) )
	{
		dwPropertiesReq |= SESSION_PROP_User;
	}
	if ( Query.IsPropertyRequired ( IDS_SessionType ) )
	{
		dwPropertiesReq |= SESSION_PROP_SessionType;
	}
	if ( Query.IsPropertyRequired ( IDS_ClientType ) )
	{
		dwPropertiesReq |= SESSION_PROP_ClientType;
	}
	if ( Query.IsPropertyRequired ( IDS_TransportName ) )
	{
		dwPropertiesReq |= SESSION_PROP_TransportName;
	}
	if ( Query.IsPropertyRequired ( IDS_ResourcesOpened ) )
	{
		dwPropertiesReq |= SESSION_PROP_NumOpens;
	}
	if ( Query.IsPropertyRequired ( IDS_ActiveTime ) )
	{
		dwPropertiesReq |= SESSION_PROP_ActiveTime;
	}
	if ( Query.IsPropertyRequired ( IDS_IdleTime ) )
	{
		dwPropertiesReq |= SESSION_PROP_IdleTime;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\connectiontosession.h ===
/******************************************************************



 ConnectionToSession.h -- 



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#ifndef  _CONNTOSESSION_H_
#define  _CONNTOSESSION_H_

#include "Connshare.h"

class CConnectionToSession : public Provider , public CConnShare
{

private:

#ifdef NTONLY
	HRESULT EnumNTConnectionsFromComputerToShare ( 

		LPWSTR a_ComputerName,
		LPWSTR a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif

#if 0
#ifdef WIN9XONLY
	HRESULT Enum9XConnectionsFromComputerToShare ( 

		LPWSTR a_ComputerName,
		LPWSTR a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif
#endif

	HRESULT GetSessionKeyVal ( 
													 
		LPCWSTR a_Key, 
		CHString &a_ComputerName, 
		CHString &a_UserName 
	);

	HRESULT LoadInstance ( 
												
		CInstance *pInstance,
		LPCWSTR a_ComputerName, 
		LPCWSTR a_ShareName,
		CONNECTION_INFO *pBuf, 
		DWORD dwPropertiesReq
	);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;
		

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

public:

        CConnectionToSession (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CConnectionToSession () ;

private:

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\connshare.h ===
/******************************************************************



 ConnShare.h-- Definition of base class from which ConnectionToShare

			   ConnectionToSession and Connection classes are derived



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#ifndef _CCONNSHARE_
#define _CCONNSHARE_

#ifdef UNICODE
#define TOBSTRT(x)        x
#else
#define TOBSTRT(x)        _bstr_t(x)
#endif

#if 0
#ifdef WIN9XONLY
#include "svrapi.h"
// max entries of the structure that can be read at a time.		#define		MAX_ENTRIES						50 
#define	MAX_ENTRIES							50

	// Typedefinition of the structures
	typedef struct connection_info_1	CONNECTION_INFO;
	typedef struct session_info_1		SESSION_INFO_1;
	typedef struct session_info_2		SESSION_INFO_2;
	typedef struct session_info_10		SESSION_INFO_10;
	typedef struct session_info_50		SESSION_INFO_50;
#endif
#endif // #if 0

#ifdef NTONLY
#include <lm.h>
#include <LMShare.h>
	// COnnection INfo Structure Type defininition
	typedef CONNECTION_INFO_1			CONNECTION_INFO;
#endif

class CConnShare
{
public:
    CConnShare ( ) ;

    virtual ~CConnShare () ;

#ifdef NTONLY
	HRESULT FindAndSetNTConnection ( LPWSTR t_ShareName, LPCWSTR t_NetName, LPCWSTR t_UserName, 
													DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation );
	HRESULT GetNTShares ( CHStringArray &t_Shares );
	virtual HRESULT EnumNTConnectionsFromComputerToShare ( LPWSTR a_ComputerName, LPWSTR a_ShareName, 
													MethodContext *pMethodContext, DWORD dwPropertiesReq ) = 0;
#endif

#if 0
#ifdef WIN9XONLY
	HRESULT FindAndSet9XConnection ( LPWSTR t_ShareName, LPCWSTR t_NetName, LPCWSTR t_UserName, 
													DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation );
	virtual HRESULT Enum9XConnectionsFromComputerToShare ( LPWSTR a_ComputerName, LPWSTR a_ShareName, 
													MethodContext *pMethodContext, DWORD dwPropertiesReq ) = 0;
	HRESULT Get9XShares ( CHStringArray &t_Shares );
#endif
#endif // #if 0

	// These are common methods irrespective of OS
	virtual HRESULT LoadInstance ( CInstance *pInstance, LPCWSTR a_Share, LPCWSTR a_Computer, CONNECTION_INFO *pBuf, 
										DWORD dwPropertiesReq ) = 0;
	HRESULT EnumConnectionInfo ( LPWSTR a_ComputerName, LPWSTR a_ShareName, MethodContext *pMethodContext, 
													DWORD dwPropertiesReq );
	HRESULT GetConnectionsKeyVal ( LPCWSTR a_Key, CHString &a_ComputerName, CHString &a_ShareName, CHString &a_UserName );
	HRESULT AddToObjectPath ( LPWSTR &a_ObjPathString, LPCWSTR a_AttributeName, LPCWSTR  a_AttributeVal );
	HRESULT MakeObjectPath ( LPWSTR &a_ObjPathString, LPCWSTR a_ClassName, LPCWSTR a_AttributeName, LPCWSTR  a_AttributeVal );
private:

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\connectiontoshare.h ===
/******************************************************************



 ConnectionToShare.h -- 



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#include "Connshare.h"

#ifndef  _CONNTOSHARE_H_
#define  _CONNTOSHARE_H_

class CConnectionToShare : public Provider, public CConnShare
{
private:

#ifdef NTONLY
	HRESULT  EnumNTConnectionsFromComputerToShare ( 

		CHString a_ComputerName,
		CHString a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif

#if 0
#ifdef WIN9XONLY
	HRESULT  Enum9XConnectionsFromComputerToShare ( 

		CHString a_ComputerName,
		CHString a_ShareName,
		MethodContext *pMethodContext,
		DWORD PropertiesReq
	);
#endif
#endif // 0
	HRESULT LoadInstance ( 
												
		CInstance *pInstance,
		CHString a_ComputerName, 
		CHString a_ShareName,
		CONNECTION_INFO *pBuf, 
		DWORD dwPropertiesReq
	);


	HRESULT GetShareKeyVal ( 
		
		CHString a_Key, 
		CHString &a_Share 
	);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;
		

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

public:

        CConnectionToShare (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CConnectionToShare () ;

private:

} ;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\session.h ===
/******************************************************************



 Session.h--



// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

#ifndef  _SESSION_H_
#define  _SESSION_H_

#ifdef NTONLY
#include <lm.h>
#endif

#if 0
#ifdef WIN9XONLY
#include "Connshare.h"
#endif
#endif // #if 0
class CSession : public Provider 
{

private:

#ifdef NTONLY
	HRESULT EnumNTSessionInfo (
	
		LPWSTR lpComputerName,
		LPWSTR lpUserName,
		short a_Level,
		MethodContext *pMethodContext,
		DWORD dwPropertiesReq
	);

	HRESULT FindAndSetNTSession ( 
												   
		LPCWSTR t_ComputerName,
		LPWSTR t_UserName,
		short t_Level,
		DWORD dwPropertiesReq, 
		CInstance *pInstance, 
		DWORD eOperation 
	);

	HRESULT OptimizeNTQuery ( 
										  
		CHStringArray& a_ComputerValues, 
		CHStringArray& a_UserValues,
		short a_Level,
		MethodContext *pMethodContext, 
		DWORD dwPropertiesReq 
	);

	void GetNTLevelInfo ( 
		
		DWORD dwPropertiesReq,
		short *a_Level
	);

#endif

#if 0
#ifdef WIN9XONLY
	HRESULT Enum9XSessionInfo (
	
		short a_Level,
		MethodContext *pMethodContext,
		DWORD dwPropertiesReq
	);

	HRESULT FindAndSet9XSession ( 
												   
		CHString &t_ComputerName,
		CHString &_UserName,
		short t_Level,
		DWORD dwPropertiesReq, 
		CInstance *pInstance, 
		DWORD eOperation 
	);

	HRESULT Optimize9XQuery ( 
										  
		CHStringArray &a_ComputerValues, 
		CHStringArray &a_UserValues,
		short a_Level,
		MethodContext *pMethodContext, 
		DWORD dwPropertiesReq 
	);

	void Get9XLevelInfo ( 
		
		DWORD dwPropertiesReq,
		short *a_Level
	);

#endif
#endif // #if 0

	HRESULT LoadData ( 
						
		short a_Level,
		void *pTmpBuf,
		DWORD dwPropertiesReq,
		CInstance *pInstance
	);

	void SetPropertiesReq ( 

		CFrameworkQuery &Query,  
		DWORD &dwPropertiesReq
	);

protected:
   
    HRESULT EnumerateInstances ( 

		MethodContext *pMethodContext, 
		long lFlags = 0L
	) ;
	
    HRESULT GetObject (

		CInstance *pInstance, 
		long lFlags,
		CFrameworkQuery &Query
	) ;

    HRESULT ExecQuery ( 

		MethodContext *pMethodContext, 
		CFrameworkQuery& Query, 
		long lFlags = 0
	) ;

    HRESULT DeleteInstance (

		const CInstance& Instance, 
		long lFlags = 0L
	) ;

public:

	CSession (

		LPCWSTR lpwszClassName, 
		LPCWSTR lpwszNameSpace
	) ;

    virtual ~CSession () ;

private:
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\win32provider\sessionandconnections\inc\sessionconnectioncommon.h ===
/******************************************************************

   SessionConnectionCommon.h -- 



   Description:  Definition of the headers

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/
// Common routines required for Session and connection  Provider

//#ifndef UNICODE
//#define UNICODE
//#endif

#ifndef  _CSESSIONCONNECTIONCOMMON_H
#define  _CSESSIONCONNECTIONCOMMON_H

#define	NTONLY
//#define WIN9XONLY

#define	Namespace								L"root\\cimv2"

// Provider Classess
#define PROVIDER_NAME_CONNECTION				L"Win32_ServerConnection"
#define PROVIDER_NAME_SESSION					L"Win32_ServerSession"
#define PROVIDER_NAME_CONNECTIONTOSHARE			L"Win32_ConnectionShare"
#define PROVIDER_SHARE							L"Win32_Share"
#define PROVIDER_NAME_CONNECTIONTOSESSION		L"Win32_SessionConnection"

// Property names for Connection
const static WCHAR *IDS_ShareName					= L"sharename" ;	
const static WCHAR *IDS_ComputerName				= L"computername" ;
const static WCHAR *IDS_UserName					= L"UserName" ;
const static WCHAR *IDS_NumberOfFiles				= L"NumberOfFiles" ;
const static WCHAR *IDS_ActiveTime					= L"ActiveTime" ;
const static WCHAR *IDS_ConnectionID				= L"ConnectionID" ;
const static WCHAR *IDS_NumberOfUsers				= L"NumberOfUsers" ;

// for session in addition to ComputerName, ShareName  and ActiveTime
const static WCHAR *IDS_ResourcesOpened				= L"resourcesopened" ;
const static WCHAR *IDS_IdleTime					= L"idletime" ;
const static WCHAR *IDS_SessionType					= L"sessiontype" ;
const static WCHAR *IDS_ClientType					= L"clienttype" ;
const static WCHAR *IDS_TransportName				= L"transportname" ;

// for Connection to Share 
const static WCHAR *IDS_Connection					= L"Dependent" ;
const static WCHAR *IDS_Resource					= L"Antecedent" ;

// property for ConnectionToSession
const static WCHAR *IDS_Session						= L"Antecedent" ;

// Win32_Share Key name
const static WCHAR *IDS_ShareKeyName				= L"Name" ;

// Defining bit values for the property, which will be used for defining the bitmap of properties required connections
#define CONNECTIONS_ALL_PROPS							0xFFFFFFFF
#define CONNECTIONS_PROP_ShareName						0x00000001
#define CONNECTIONS_PROP_ComputerName					0x00000002
#define CONNECTIONS_PROP_UserName						0x00000004
#define CONNECTIONS_PROP_NumberOfFiles					0x00000008
#define CONNECTIONS_PROP_ConnectionID					0x00000010
#define CONNECTIONS_PROP_NumberOfUsers					0x00000020
#define CONNECTIONS_PROP_ConnectionType					0x00000040
#define CONNECTIONS_PROP_ActiveTime						0x00000080

// Defining bit values for the property, which will be used for defining the bitmap of properties required for sessions
#define SESSION_ALL_PROPS								0xFFFFFFFF
#define SESSION_PROP_Computer							0x00000001
#define SESSION_PROP_User								0x00000002
#define SESSION_PROP_NumOpens							0x00000004
#define SESSION_PROP_ActiveTime							0x00000008
#define SESSION_PROP_IdleTime							0x00000010
#define SESSION_PROP_SessionType						0x00000020
#define SESSION_PROP_ClientType							0x00000040
#define SESSION_PROP_TransportName						0x00000080
#define SESSION_PROP_SessionKey							0x00000100
#define SESSION_PROP_NumOfConnections					0x00000200

// Property Bit Map for Connection To Share Association class
#define CONNECTIONSTOSHARE_ALL_PROPS					0xFFFFFFFF

// Property Bit Map for Connection To Session Association class
#define CONNECTIONSTOSESSION_ALL_PROPS					0xFFFFFFFF


enum { Get, Delete, NoOp };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\asynserv.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  SERVICES.CPP
//
//  rogerbo  26-May-98   Created.
//
//  Defines the implementation of ISWbemServicesEx
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"


//***************************************************************************
//
//  SCODE CSWbemServices::ExecQueryAsync
//
//  DESCRIPTION:
//
//  Execute an asynchronous query
//
//  PARAMETERS:
//
//		bsQuery				The query strimg
//		pAsyncNotify		The notification sink
//		bsQueryLanguage		The query language descriptor (e.g."WQL")
//		lFlags				Flags
//		pContext			Any context information
//		pAsyncContext		asynchronous context information
//		ppEnum				Returns the sink
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CSWbemServices::ExecQueryAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR Query,
	/* [defaultvalue][optional][in] */ BSTR QueryLanguage,
	/* [defaultvalue][optional][in] */ long lFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				/* 
				 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to 
				 * guarantee that the returned objects have the __RELPATH
				 * property included.  This is in case anyone calls a 
				 * method subsequently on such an object, as the "."
				 * notation requires that the __RELPATH property be present.
				 */
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecQueryAsync 
							(QueryLanguage, Query, 
							lFlags | WBEM_FLAG_ENSURE_LOCATABLE, 
							pIContext, 
							pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
				
				// Restore original privileges on this thread
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemServices::GetAsync
(
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ BSTR strObjectPath,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->GetObjectAsync (
						(strObjectPath && (0 < wcslen(strObjectPath))) ? strObjectPath : NULL, 
						iFlags, 
						pIContext,
						pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				// Restore original privileges on this thread
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::DeleteAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strObjectPath,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		CComPtr<IWbemServices> pIWbemServices;
		pIWbemServices.Attach(GetIWbemServices());

		if (pIWbemServices)
		{
			CWbemPathCracker pathCracker (strObjectPath);

			if ((pathCracker.GetType () != CWbemPathCracker::WbemPathType::wbemPathTypeError) &&
				pathCracker.IsClassOrInstance ())
			{
				// Create the sink
				CWbemObjectSink *pWbemObjectSink;
				IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
				if (pSink)
				{
					// Get the context
					IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																				m_pIServiceProvider);

					bool needToResetSecurity = false;
					HANDLE hThreadToken = NULL;
				
					if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					{
						if (pathCracker.IsInstance ())
							hr = pIWbemServices->DeleteInstanceAsync (strObjectPath, iFlags, pIContext, pSink);
						else
							hr = pIWbemServices->DeleteClassAsync (strObjectPath, iFlags, pIContext, pSink);
					}
						
					// Check to see if we need to release the stub (either we failed locally
					// or via a re-entrant call to SetStatus
					pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

					// Restore original privileges on this thread
					if (needToResetSecurity)
						m_SecurityInfo->ResetSecurity (hThreadToken);

					SetWbemError (this);
					
					if (pIContext)
						pIContext->Release ();
				} else
					hr = wbemErrInvalidParameter;
			}
			else
				hr = wbemErrInvalidParameter;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::InstancesOfAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strClass,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->CreateInstanceEnumAsync 
									(strClass, iFlags, pIContext, pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				// Restore original privileges on this thread
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::SubclassesOfAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ BSTR strSuperclass,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->CreateClassEnumAsync 
							(strSuperclass, iFlags, pIContext, pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				// Restore original privileges on this thread
				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::AssociatorsOfAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strObjectPath,
	/* [defaultvalue][optional][in] */ BSTR strAssocClass,
	/* [defaultvalue][optional][in] */ BSTR strResultClass,
	/* [defaultvalue][optional][in] */ BSTR strResultRole,
	/* [defaultvalue][optional][in] */ BSTR strRole,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
	/* [defaultvalue][optional][in] */ BSTR strRequiredAssocQualifier,
	/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == strObjectPath)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				// Format the query string
				BSTR bsQueryLanguage = SysAllocString (OLESTR("WQL"));

				BSTR bsQuery = FormatAssociatorsQuery (strObjectPath, strAssocClass, strResultClass, strResultRole,
								strRole, bClassesOnly, bSchemaOnly, strRequiredAssocQualifier, strRequiredQualifier);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				/* 
				 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to 
				 * guarantee that the returned objects have the __RELPATH
				 * property included.  This is in case anyone calls a 
				 * method subsequently on such an object, as the "."
				 * notation requires that the __RELPATH property be present.
				 */
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecQueryAsync 
							(bsQueryLanguage, bsQuery, 
							iFlags | WBEM_FLAG_ENSURE_LOCATABLE, 
							pIContext, 
							pSink); 

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				SysFreeString (bsQuery);
				SysFreeString (bsQueryLanguage);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::ReferencesToAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strObjectPath,
	/* [defaultvalue][optional][in] */ BSTR strResultClass,
	/* [defaultvalue][optional][in] */ BSTR strRole,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
	/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == strObjectPath)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				// Format the query string
				CComBSTR bsQueryLanguage = SysAllocString (OLESTR("WQL"));
				CComBSTR bsQuery = FormatReferencesQuery (strObjectPath, strResultClass, strRole,
								bClassesOnly, bSchemaOnly, strRequiredQualifier);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				/* 
				 * We OR in the WBEM_FLAG_ENSURE_LOCATABLE flag to 
				 * guarantee that the returned objects have the __RELPATH
				 * property included.  This is in case anyone calls a 
				 * method subsequently on such an object, as the "."
				 * notation requires that the __RELPATH property be present.
				 */
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecQueryAsync 
							(bsQueryLanguage, bsQuery, 
							iFlags | WBEM_FLAG_ENSURE_LOCATABLE, 
							pIContext,
							pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::ExecNotificationQueryAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR Query,
	/* [defaultvalue][optional][in] */ BSTR strQueryLanguage,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
															this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{
				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
				
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecNotificationQueryAsync 
							(strQueryLanguage, Query, iFlags, pIContext, pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemServices::ExecMethodAsync
( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strObjectPath,
	/* [in] */ BSTR strMethodName,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objInParams,
		/* [defaultvalue][optional][in] */ long iFlags,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
		/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			// Create the sink
			CWbemObjectSink *pWbemObjectSink;
			IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext);
			if (pSink)
			{

				IWbemClassObject *pIInParams = CSWbemObject::GetIWbemClassObject (objInParams);

				// Get the context
				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
			
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIWbemServices->ExecMethodAsync 
							(strObjectPath, strMethodName, iFlags, pIContext, pIInParams, pSink);

				// Check to see if we need to release the stub (either we failed locally
				// or via a re-entrant call to SetStatus
				pWbemObjectSink->ReleaseTheStubIfNecessary(hr);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				SetWbemError (this);

				if (pIContext)
					pIContext->Release ();
			
				if (pIInParams)
					pIInParams->Release ();
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemServices::PutAsync
( 
	/* [in] */ ISWbemSink *pAsyncNotify,
	/* [in] */ ISWbemObjectEx *objObject,
    /* [in] */ long iFlags,
	/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *objContext,
	/* [in] */ /*ISWbemNamedValueSet*/ IDispatch *pAsyncContext
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			if (pAsyncNotify)
			{
				IWbemClassObject *pWbemClassObject = CSWbemObject::GetIWbemClassObject (objObject);

				if (pWbemClassObject)
				{
					// Figure out whether this is a class or instance
					VARIANT var;
					VariantInit (&var);

					if (WBEM_S_NO_ERROR == pWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
					{

						IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																					m_pIServiceProvider);
						if (WBEM_GENUS_CLASS  == var.lVal)
						{
							// Save the class name for later
							VARIANT nameVar;
							VariantInit (&nameVar);

							/*
							 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
							 * the __CLASS property has not yet been set.
							 */
							if ((WBEM_S_NO_ERROR == pWbemClassObject->Get (WBEMS_SP_CLASS, 0, &nameVar, NULL, NULL))
								&& (VT_BSTR == V_VT(&nameVar)))
							{
								// Create the sink
								CWbemObjectSink *pWbemObjectSink;
								IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
											this, pAsyncNotify, pAsyncContext, true, nameVar.bstrVal);
								if (pSink)
								{
									bool needToResetSecurity = false;
									HANDLE hThreadToken = NULL;
					
									if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
										hr = pIWbemServices->PutClassAsync (pWbemClassObject, iFlags, 
																					pIContext, pSink);

									// Check to see if we need to release the stub (either we failed locally
									// or via a re-entrant call to SetStatus
									pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
							
									if (needToResetSecurity)
										m_SecurityInfo->ResetSecurity (hThreadToken);
								}
							}

							VariantClear (&nameVar);
						}
						else
						{
							// Create the sink
							CWbemObjectSink *pWbemObjectSink;
							IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
														this, pAsyncNotify, pAsyncContext, true);
							if (pSink)
							{
								bool needToResetSecurity = false;
								HANDLE hThreadToken = NULL;
						
								if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
									hr = pIWbemServices->PutInstanceAsync (pWbemClassObject, iFlags, pIContext, pSink);

								// Check to see if we need to release the stub (either we failed locally
								// or via a re-entrant call to SetStatus
								pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
						
								// Restore original privileges on this thread
								if (needToResetSecurity)
										m_SecurityInfo->ResetSecurity (hThreadToken);
							}
						}

						SetWbemError (this);

						if (pIContext)
							pIContext->Release ();
					}

					pWbemClassObject->Release ();
					VariantClear (&var);
				}
			} else
				hr = wbemErrInvalidParameter;

			pIWbemServices->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
        
HRESULT CSWbemServices::CancelAsyncCall(IWbemObjectSink *pSink)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IWbemServices *pIWbemServices = (IWbemServices *) m_SecurityInfo->GetProxy ();

		if (pIWbemServices)
		{
			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIWbemServices->CancelAsyncCall(pSink); 

			pIWbemServices->Release ();

			// Restore original privileges on this thread
			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);
		}
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\classfac.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  classfac.h
//
//  alanbos  13-Feb-98   Created.
//
//  Genral purpose include file.
//
//***************************************************************************

#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern ULONG       g_cLock;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemFactory
//
//  DESCRIPTION:
//
//  Class factory for the CSWbemLocator and CSWbemNamedValueBag classes.
//
//***************************************************************************

class CSWbemFactory : public IClassFactory
{
protected:
	long			m_cRef;
	int				m_iType;

public:

    CSWbemFactory(int iType);
    ~CSWbemFactory(void);
    
	enum {LOCATOR, CONTEXT, OBJECTPATH, PARSEDN, LASTERROR, SINK, DATETIME,
			REFRESHER};

    //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\classfac.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  CLASSFAC.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Contains the class factory.
//
//***************************************************************************

#include "precomp.h"

extern CWbemErrorCache *g_pErrorCache;
extern CRITICAL_SECTION g_csErrorCache;

//***************************************************************************
//
// CSWbemFactory::CSWbemFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CSWbemFactory::CSWbemFactory(int iType)
{
    m_cRef=0L;
	m_iType = iType;
	return;
}

//***************************************************************************
//
// CSWbemFactory::~CSWbemFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CSWbemFactory::~CSWbemFactory(void)
{
	return;
}

//***************************************************************************
//
// CSWbemFactory::QueryInterface
// CSWbemFactory::AddRef
// CSWbemFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CSWbemFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemFactory::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemFactory::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CSWbemFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a Translator object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSWbemFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj = NULL;
    HRESULT      hr = E_FAIL;

	// A good place to ensure everything is initialized OK
	EnsureGlobalsInitialized () ;

    *ppvObj=NULL;
    
    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

	if (m_iType == LOCATOR)
	    pObj = (ISWbemLocator *) new CSWbemLocator;
	else if (m_iType == SINK)
	{
		CSWbemSink *pSWbemSink = new CSWbemSink;

		if(pSWbemSink == NULL)
			return E_OUTOFMEMORY;

		// QueryInterface probably for IID_IUNKNOWN
		return pSWbemSink->QueryInterface(riid, ppvObj);

	}
	else if (m_iType == CONTEXT)
		pObj = (ISWbemNamedValueSet *) new CSWbemNamedValueSet;
	else if (m_iType == OBJECTPATH)
		pObj = (ISWbemObjectPath *) new CSWbemObjectPath;
	else if (m_iType == PARSEDN)
		pObj = new CWbemParseDN;
	else if (m_iType == DATETIME)
		pObj = (ISWbemDateTime *) new CSWbemDateTime;
	else if (m_iType == REFRESHER)
		pObj = (ISWbemRefresher *) new CSWbemRefresher;
	else if (m_iType == LASTERROR)
	{
		EnterCriticalSection (&g_csErrorCache);

		if (g_pErrorCache)
			pObj = (ISWbemObject* ) g_pErrorCache->GetAndResetCurrentThreadError ();

		LeaveCriticalSection (&g_csErrorCache);
	}
	
    if (NULL == pObj)
        return hr;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if ( FAILED(hr) )
        delete pObj;
    return hr;
}

//***************************************************************************
//
//  SCODE CSWbemFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CSWbemFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\context.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  CONTEXT.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemNamedValueSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemNamedValueSet::CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemNamedValueSet::CSWbemNamedValueSet()
	: m_pCWbemPathCracker (NULL),
	  m_bMutable (true),
	  m_cRef (0),
	  m_pIWbemContext (NULL),
	  m_pSWbemServices (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemNamedValueSet, 
						CLSID_SWbemNamedValueSet, L"SWbemNamedValueSet");
    
	// Create a context
	CoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemContext, (LPVOID *) &m_pIWbemContext);
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemNamedValueSet::CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemNamedValueSet::CSWbemNamedValueSet(
	CSWbemServices	*pService, 
	IWbemContext	*pContext
)
	: m_pCWbemPathCracker (NULL),
	  m_bMutable (true),
	  m_cRef (0),
	  m_pIWbemContext (pContext),
	  m_pSWbemServices (pService)
{
	m_Dispatch.SetObj (this, IID_ISWbemNamedValueSet, 
						CLSID_SWbemNamedValueSet,  L"SWbemNamedValueSet");
	
	if (m_pIWbemContext)
		m_pIWbemContext->AddRef ();
	
	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemNamedValueSet::CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemNamedValueSet::CSWbemNamedValueSet(
	CWbemPathCracker *pCWbemPathCracker,
	bool			bMutable
)
	: m_pCWbemPathCracker (pCWbemPathCracker),
	  m_bMutable (bMutable),
	  m_cRef (0),
	  m_pIWbemContext (NULL),
	  m_pSWbemServices (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemNamedValueSet, 
						CLSID_SWbemNamedValueSet,  L"SWbemNamedValueSet");
    
	// Create a context
	CoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemContext, (LPVOID *) &m_pIWbemContext);

	if (m_pCWbemPathCracker)
	{
		m_pCWbemPathCracker->AddRef ();

		// Artificial refcount hike as the following may do an AddRef/Release 
		// pair on this
		m_cRef++;
		BuildContextFromKeyList ();
		m_cRef--;
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemNamedValueSet::~CSWbemNamedValueSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemNamedValueSet::~CSWbemNamedValueSet(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemContext)
	{
		m_pIWbemContext->EndEnumeration ();
		m_pIWbemContext->Release ();
		m_pIWbemContext = NULL;
	}

	RELEASEANDNULL(m_pSWbemServices)
	RELEASEANDNULL(m_pCWbemPathCracker)
}

//***************************************************************************
// HRESULT CSWbemNamedValueSet::QueryInterface
// long CSWbemNamedValueSet::AddRef
// long CSWbemNamedValueSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValueSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISWbemNamedValueSet==riid)
		*ppv = (ISWbemNamedValueSet *)this;
	else if (IID_ISWbemInternalContext==riid)
        *ppv = (ISWbemInternalContext *) this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *) this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *) this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemNamedValueSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemNamedValueSet::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemNamedValueSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValueSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemNamedValueSet == riid) ? S_OK : S_FALSE;
}

void CSWbemNamedValueSet::BuildContextFromKeyList ()
{
	if (m_pCWbemPathCracker)
	{
		ULONG lKeyCount = 0;

		if (m_pCWbemPathCracker->GetKeyCount (lKeyCount))
		{
			for (ULONG i = 0; i <lKeyCount; i++)
			{
				VARIANT var;
				VariantInit (&var);
				CComBSTR bsName;
				WbemCimtypeEnum cimType;
				
				if (m_pCWbemPathCracker->GetKey (i, bsName, var, cimType))
				{
					SetValueIntoContext (bsName, &var, 0);
				}

				VariantClear (&var);
			}
		}
	}
}

//***************************************************************************
//
//  CSWbemNamedValueSet::GetIWbemContext
//
//  DESCRIPTION:
//
//  Return the IWbemContext interface corresponding to this scriptable wrapper.
//
//  PARAMETERS:
//		ppContext		holds the IWbemContext pointer on return
//
//  RETURN VALUES:
//		S_OK	success
//		E_FAIL	otherwise
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************

STDMETHODIMP CSWbemNamedValueSet::GetIWbemContext (IWbemContext **ppContext)
{
	HRESULT hr = S_OK;  // By default if we have no context to copy

	if (ppContext)
	{
		*ppContext = NULL;

		if (m_pIWbemContext)
		{
			/*
			 * Before returning a context, we ensure that coercion is performed
			 * to render the type down to either an IUnknown or a Qualifier
			 * type.  This is done for the benefit of imposing a fixed typing
			 * system for provider context, rather than have providers take
			 * the burden of using VariantChangeType etc. themselves.
			 */

			if (SUCCEEDED (hr = m_pIWbemContext->Clone (ppContext)))
			{
				if (SUCCEEDED (hr = (*ppContext)->BeginEnumeration (0)))
				{
					BSTR	bsName = NULL;
					VARIANT	var;
					VariantInit (&var);

					while (WBEM_S_NO_ERROR == (*ppContext)->Next(0, &bsName, &var))
					{
						VARIANT vTemp;
						VariantInit (&vTemp);

						// Stage 1 of transformation involves homogenisation of 
						// arrays, transformation of JScript arrays, and weedling 
						// out of IWbemClassObject's
						//
						// If successful hr will be a a success code and vTemp will
						// hold the value, which will either be a VT_UNKNOWN or a 
						// "simple" (non-object) type, or array thereof.

						if((VT_ARRAY | VT_VARIANT) == V_VT(&var))
						{
							// A classical dispatch-style array of variants - map them
							// down to a homogeneous array of primitive values
						
							if (SUCCEEDED(hr = ConvertArray(&vTemp, &var)))
							{
								// Now check if we should map any VT_DISPATCH's inside 
								// the array
								hr = MapToCIMOMObject(&vTemp);
							}
						}
						else if (VT_DISPATCH == V_VT(&var))
						{
							// First try a JScript array - if this succeeds it
							// will map to a regular SAFEARRAY.  If not, we try
							// to map to an IWbem interface
							if (FAILED(ConvertDispatchToArray (&vTemp, &var)))
							{
								if (SUCCEEDED (hr = VariantCopy (&vTemp, &var)))
									hr = MapToCIMOMObject(&vTemp);
							}
						}
						else
						{
							// Just copy so we have the result in vTemp in all cases
							hr = VariantCopy (&vTemp, &var);
						}

						// Stage 2 of the transformation involves casting of simple
						// (non-VT_UNKNOWN) types to a qualifier type.

						if (SUCCEEDED (hr))
						{
							if (VT_UNKNOWN != (V_VT(&vTemp) & ~(VT_ARRAY|VT_BYREF)))
							{
								// Not a VT_UNKNOWN so try to cast to a qualifier type
				
								VARIANT vFinal;
								VariantInit (&vFinal);

								VARTYPE vtOK = GetAcceptableQualType(V_VT(&vTemp));

 								if (vtOK != V_VT(&vTemp))
								{
									// Need to coerce
									if (SUCCEEDED(hr = QualifierVariantChangeType (&vFinal, &vTemp, vtOK)))
										hr = (*ppContext)->SetValue (bsName, 0, &vFinal);
								}
								else
									hr = (*ppContext)->SetValue (bsName, 0, &vTemp);

								VariantClear (&vFinal);
							}
							else
								hr = (*ppContext)->SetValue (bsName, 0, &vTemp);
						}

						VariantClear (&vTemp);
						SysFreeString (bsName);
						bsName = NULL;
						VariantClear (&var);
					}

					(*ppContext)->EndEnumeration ();
				}
			}
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Clone
//
//  DESCRIPTION:
//
//  Clone object
//
//  PARAMETERS:
//		ppCopy		On successful return addresses the copy
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Clone (
	ISWbemNamedValueSet **ppCopy
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppCopy)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemContext)
	{
		IWbemContext *pWObject = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemContext->Clone (&pWObject)))
		{
			// NB: the cloned set is always mutable
			CSWbemNamedValueSet *pCopy = 
					new CSWbemNamedValueSet (m_pSWbemServices, pWObject);

			if (!pCopy)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pCopy->QueryInterface (IID_ISWbemNamedValueSet, 
										(PPVOID) ppCopy)))
				delete pCopy;

			pWObject->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::BeginEnumeration
//
//  DESCRIPTION:
//
//  Kick off a value enumeration
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::BeginEnumeration (
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemContext)
	{
		// Preface with an end enumeration just in case
		hr = m_pIWbemContext->EndEnumeration ();
		hr = m_pIWbemContext->BeginEnumeration (0);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Next
//
//  DESCRIPTION:
//
//  Iterate through value enumeration
//
//  PARAMETERS:
//		lFlags				Flags
//		ppNamedValue		The next named value (or NULL if at end)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Next (
	long lFlags,
	ISWbemNamedValue	**ppNamedValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNamedValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppNamedValue = NULL;

		if (m_pIWbemContext)
		{
			BSTR	name = NULL;
			VARIANT	var;
			VariantInit (&var);
			
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemContext->Next (lFlags, 
											&name, &var)))
			{
				*ppNamedValue = new CSWbemNamedValue (m_pSWbemServices, 
										this, m_bMutable);

				if (!(*ppNamedValue))
					hr = WBEM_E_OUT_OF_MEMORY;
				else		// Bug ID 572567
				{
					hr = ((CSWbemNamedValue*)(*ppNamedValue))->SetName(name);
					if(FAILED(hr))
					{
						delete (*ppNamedValue);
						*ppNamedValue = NULL;
					}
				}

				SysFreeString (name);
			}

			VariantClear (&var);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Add
//
//  DESCRIPTION:
//
//  Add named value to set
//
//  PARAMETERS:
//
//		bsName			The property to update/create
//		pVal			The value
//		lFlags			Flags
//		ppNamedValue	The named value created
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Add (
	BSTR bsName,
	VARIANT *pVal,
	long lFlags,
	ISWbemNamedValue **ppNamedValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppNamedValue) || (NULL == bsName) || (NULL == pVal))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pIWbemContext)
	{
		*ppNamedValue = NULL;

		if (VT_BYREF & V_VT(pVal))
		{
			// We must dereference all byref's
			VARIANT var;
			VariantInit (&var);

			if (VT_ARRAY & V_VT(pVal))
			{
				var.vt = V_VT(pVal) & ~VT_BYREF;
				hr = SafeArrayCopy (*(pVal->pparray), &(var.parray));
			}
			else
				hr = VariantChangeType(&var, pVal, 0, V_VT(pVal) & ~VT_BYREF);

			if (SUCCEEDED(hr))
					hr = m_pIWbemContext->SetValue (bsName, lFlags, &var);
			
			VariantClear (&var);
		}
		else if ((VT_ERROR == V_VT(pVal)) && (DISP_E_PARAMNOTFOUND == pVal->scode))
		{
			// Treat as NULL assignment
			pVal->vt = VT_NULL;
			hr = m_pIWbemContext->SetValue (bsName, lFlags, pVal);
		}
		else
			hr = m_pIWbemContext->SetValue (bsName, lFlags, pVal);

		if (SUCCEEDED (hr))
		{
			WbemCimtypeEnum cimtype = MapVariantTypeToCimType(pVal);
			
			// Add to the path key list if we have one - note this MAY fail
			if (m_pCWbemPathCracker)
			{
				if (!m_pCWbemPathCracker->SetKey (bsName, cimtype, *pVal))
				{
					// Rats - delete it
					m_pIWbemContext->DeleteValue (bsName, 0);
					hr = WBEM_E_FAILED;
				}
			}

			if (SUCCEEDED(hr))
			{
				*ppNamedValue = new CSWbemNamedValue (m_pSWbemServices, 
										this);

				if (!(*ppNamedValue))
					hr = WBEM_E_OUT_OF_MEMORY;
				else	// Bug ID 572567
				{
					hr = ((CSWbemNamedValue*)(*ppNamedValue))->SetName(bsName);
					if(FAILED(hr))
					{
						delete (*ppNamedValue);
						*ppNamedValue = NULL;
					}
				}
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
		
	return hr;
}


HRESULT CSWbemNamedValueSet::SetValueIntoContext (
	BSTR		bsName,
	VARIANT		*pVal,
	ULONG		lFlags
)
{
	HRESULT hr = WBEM_E_FAILED;

	if (m_pIWbemContext)
	{
		if (VT_BYREF & V_VT(pVal))
		{
			// We must dereference all byref's
			VARIANT var;
			VariantInit (&var);

			if (VT_ARRAY & V_VT(pVal))
			{
				var.vt = V_VT(pVal) & ~VT_BYREF;
				hr = SafeArrayCopy (*(pVal->pparray), &(var.parray));
			}
			else
				hr = VariantChangeType(&var, pVal, 0, V_VT(pVal) & ~VT_BYREF);

			if (SUCCEEDED(hr))
					hr = m_pIWbemContext->SetValue (bsName, lFlags, &var);
			
			VariantClear (&var);
		}
		else if ((VT_ERROR == V_VT(pVal)) && (DISP_E_PARAMNOTFOUND == pVal->scode))
		{
			// Treat as NULL assignment
			pVal->vt = VT_NULL;
			hr = m_pIWbemContext->SetValue (bsName, lFlags, pVal);
		}
		else
			hr = m_pIWbemContext->SetValue (bsName, lFlags, pVal);
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Item
//
//  DESCRIPTION:
//
//  Get named value
//
//  PARAMETERS:
//
//		bsName			The value to retrieve
//		lFlags			Flags
//		ppNamedValue	On successful return addresses the value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Item (
	BSTR bsName,
	long lFlags,
    ISWbemNamedValue **ppNamedValue
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNamedValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemContext)
	{
		VARIANT var;
		VariantInit (&var);

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemContext->GetValue (bsName, lFlags, &var)))
		{
			*ppNamedValue = new CSWbemNamedValue (m_pSWbemServices, 
									this,  m_bMutable);

			if (!(*ppNamedValue))
				hr = WBEM_E_OUT_OF_MEMORY;
			else	// Bug ID 572567
			{
					hr = ((CSWbemNamedValue*)(*ppNamedValue))->SetName(bsName);
				if(FAILED(hr))
				{
					delete (*ppNamedValue);
					*ppNamedValue = NULL;
				}
			}
		}

		VariantClear (&var);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::Remove
//
//  DESCRIPTION:
//
//  Delete named value
//
//  PARAMETERS:
//
//		bsName		The value to delete
//		lFlags		Flags
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::Remove (
	BSTR bsName,
	long lFlags
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pIWbemContext)
		hr = m_pIWbemContext->DeleteValue (bsName, lFlags);

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Remove from our key list if we have one
		if (m_pCWbemPathCracker)
		{
			if(TRUE == m_pCWbemPathCracker->RemoveKey (bsName))
			  hr = WBEM_S_NO_ERROR;
			else
			  hr = WBEM_E_FAILED;
	    }
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::DeleteAll
//
//  DESCRIPTION:
//
//  Empty the bag
//
//  PARAMETERS:
//		None
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::DeleteAll (
)
{
	HRESULT hr = WBEM_E_FAILED;
	ResetLastErrors ();

	if (!m_bMutable)
		hr = WBEM_E_READ_ONLY;
	else if (m_pIWbemContext)
		hr = m_pIWbemContext->DeleteAll ();

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
	else
	{
		// Empty the key list
		if (m_pCWbemPathCracker)
			m_pCWbemPathCracker->RemoveAllKeys ();	
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CContextEnumVar *pEnum = new CContextEnumVar (this, 0);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = 0;

		if (m_pIWbemContext)
		{
			/*
			 * This is not the most efficient way of obtaining the count,
			 * but it is the only way that is:
			 *	(a) Supported by the underlying interface
			 *	(b) Does not require access to any other interface
			 *	(c) Does not affect the current enumeration position
			 */
	
			SAFEARRAY	*pArray = NULL;

			if (WBEM_S_NO_ERROR == m_pIWbemContext->GetNames (0, &pArray))
			{
				long lUBound = 0, lLBound = 0;
				SafeArrayGetUBound (pArray, 1, &lUBound);
				SafeArrayGetLBound (pArray, 1, &lLBound);
				*plCount = lUBound - lLBound + 1;
				SafeArrayDestroy (pArray);
				hr = S_OK;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  CSWbemNamedValueSet::GetIWbemContext
//
//  DESCRIPTION:
//
//  Given an IDispatch interface which we hope is also an ISWbemNamedValueSet
//	interface, return the underlying IWbemContext interface.
//
//  PARAMETERS:
//		pDispatch		the IDispatch in question
//
//  RETURN VALUES:
//		The underlying IWbemContext interface, or NULL.
//
//	NOTES:
//		If successful, the returned interface is AddRef'd; the caller is
//		responsible for release.
//
//***************************************************************************


/* 
 * THIS FUNCTION NEEDS FIXING
 * Currently this function returns the context from the service provider
 * obtained from the host, if there is one.  If there isn't one then it uses
 * the one passed in from the user.  The correct behaviour is to _add_ the 
 * context from the user to the one provided by the service provider if there
 * is one, if not just use the one from the user
 */
IWbemContext	*CSWbemNamedValueSet::GetIWbemContext (
	IDispatch *pDispatch,
	IServiceProvider *pServiceProvider
)
{
	_RD(static char *me = "CSWbemNamedValueSet::GetIWbemContext";)
	IWbemContext *pContext = NULL;
	ISWbemInternalContext *pIContext = NULL;

	_RPrint(me, "Called", 0, "");
	if (pServiceProvider) {
		if (FAILED(pServiceProvider->QueryService(IID_IWbemContext, 
										IID_IWbemContext, (LPVOID *)&pContext))) {
			_RPrint(me, "Failed to get context from services", 0, "");
			pContext = NULL;
		} else {
			_RPrint(me, "Got context from services", 0, "");
			;
		}
	}

	if (pDispatch && !pContext)
	{
		if (SUCCEEDED (pDispatch->QueryInterface 
								(IID_ISWbemInternalContext, (PPVOID) &pIContext)))
		{
			pIContext->GetIWbemContext (&pContext);
			pIContext->Release ();
		}
	}

	return pContext;
}

/*
 * Call GetIWbemContext to get the service context if there is one. 
 * Then wrap the result with an SWbemContext and return
 */
IDispatch *CSWbemNamedValueSet::GetSWbemContext(IDispatch *pDispatch, 
									IServiceProvider *pServiceProvider, CSWbemServices *pServices)
{
	_RD(static char *me = "CSWbemNamedValueSet::GetSWbemContext";)
	IDispatch *pDispatchOut = NULL;

	IWbemContext *pContext = GetIWbemContext(pDispatch, pServiceProvider);

	if (pContext) {

		CSWbemNamedValueSet *pCSWbemNamedValueSet = new CSWbemNamedValueSet(pServices, pContext);

		if (pCSWbemNamedValueSet)
		{
			if (FAILED(pCSWbemNamedValueSet->QueryInterface 
									(IID_IDispatch, (PPVOID) &pDispatchOut))) {
				delete pCSWbemNamedValueSet;
				pDispatchOut = NULL;
			}
		}

		pContext->Release();
	}

	_RPrint(me, "Returning with context: ", (long)pDispatchOut, "");

	return pDispatchOut;
}

//***************************************************************************
//
//  SCODE CSWbemNamedValueSet::CContextDispatchHelp::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemNamedValueSet::CContextDispatchHelp::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for calls on the default member (the Item method) which
	 * are PUTs that supplied an argument.  These are triggered by attempts
	 * to set a value of a named value (Item) in the collection.
	 * The first argument should be the new value for the item, and the second
	 * argument should be the name of the item.
	 */
	if ((DISPID_VALUE == dispidMember) && (DISP_E_MEMBERNOTFOUND == hr) && (2 == pdispparams->cArgs)
		&& (DISPATCH_PROPERTYPUT == wFlags))
	{
		// Looks promising - get the object to try and resolve this
		ISWbemNamedValueSet *pContext = NULL;

		if (SUCCEEDED (m_pObj->QueryInterface (IID_ISWbemNamedValueSet, (PPVOID) &pContext)))
		{
			VARIANT valueVar;
			VariantInit (&valueVar);

			if (SUCCEEDED(VariantCopy(&valueVar, &pdispparams->rgvarg[0])))
			{
				VARIANT nameVar;
				VariantInit (&nameVar);

				if (SUCCEEDED(VariantCopy(&nameVar, &pdispparams->rgvarg[1])))
				{
					// Check name is a BSTR and use it to get the item
					if (VT_BSTR == V_VT(&nameVar))
					{
						ISWbemNamedValue *pNamedValue = NULL;

						if (SUCCEEDED (pContext->Item (V_BSTR(&nameVar), 0, &pNamedValue)))
						{
							// Try and put the value
							if (SUCCEEDED (pNamedValue->put_Value (&valueVar)))
								hr = S_OK;
							else
							{
								hr = DISP_E_TYPEMISMATCH;
								if (puArgErr)
									*puArgErr = 0;
							}

							pNamedValue->Release ();
						}
					}
					else
					{
						hr = DISP_E_TYPEMISMATCH;
						if (puArgErr)
							*puArgErr = 1;
					}

					VariantClear (&nameVar);
				}

				VariantClear (&valueVar);
			}

			pContext->Release ();
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\asyncobj.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  OBJECT.CPP
//
//  rogerbo  19-June-98   Created.
//
//  Defines the async implementation of ISWbemObjectEx
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"

HRESULT STDMETHODCALLTYPE CSWbemObject::PutAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		if (pAsyncNotify)
		{
			// Figure out whether this is a class or instance
			VARIANT var;
			VariantInit (&var);

			if (WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL))
			{

				IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (objContext, 
																			m_pIServiceProvider);
				IWbemServices	*pIService = m_pSWbemServices->GetIWbemServices ();

				if (WBEM_GENUS_CLASS  == var.lVal)
				{
					// Save the class name for later
					VARIANT nameVar;
					VariantInit (&nameVar);

					/*
					 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
					 * the __CLASS property has not yet been set.
					 */
					if ((WBEM_S_NO_ERROR == m_pIWbemClassObject->Get (WBEMS_SP_CLASS, 0, &nameVar, NULL, NULL))
						&& (VT_BSTR == V_VT(&nameVar)))
					{

						if (pIService)
						{
							// Create the sink
							CWbemObjectSink *pWbemObjectSink;
							IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
										m_pSWbemServices, pAsyncNotify, pAsyncContext, true, nameVar.bstrVal);
							if (pSink)
							{
								CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

								if (pSecurity)
								{
									bool needToResetSecurity = false;
									HANDLE hThreadToken = NULL;
					
									if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
										hr = pIService->PutClassAsync (m_pIWbemClassObject, iFlags, 
																					pIContext, pSink);

									// Check to see if we need to release the stub (either we failed locally
									// or via a re-entrant call to SetStatus
									pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
							
									if (needToResetSecurity)
										pSecurity->ResetSecurity (hThreadToken);

									pSecurity->Release ();
								}
							}
						}
					}

					VariantClear (&nameVar);
				}
				else
				{

					if (pIService)
					{
						// Create the sink
						CWbemObjectSink *pWbemObjectSink;
						IWbemObjectSink *pSink = CWbemObjectSink::CreateObjectSink(&pWbemObjectSink,
													m_pSWbemServices, pAsyncNotify, pAsyncContext, true);
						if (pSink)
						{
							CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

							if (pSecurity)
							{
								bool needToResetSecurity = false;
								HANDLE hThreadToken = NULL;
						
								if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
									hr = pIService->PutInstanceAsync (m_pIWbemClassObject, iFlags, pIContext, pSink);

								// Check to see if we need to release the stub (either we failed locally
								// or via a re-entrant call to SetStatus
								pWbemObjectSink->ReleaseTheStubIfNecessary(hr);
						
								// Restore original privileges on this thread
								if (needToResetSecurity)
									pSecurity->ResetSecurity (hThreadToken);
							
								pSecurity->Release ();
							}
						}
					}
				}


				SetWbemError (m_pSWbemServices);

				if (pIService)
					pIService->Release ();

				if (pIContext)
					pIContext->Release ();
			}

			VariantClear (&var);
		} else
			hr = wbemErrInvalidParameter;
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::DeleteAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices)
	{
		if (m_pIWbemClassObject)
		{
			// Get the object path to pass to the IWbemServices call
			CComBSTR bsPath;
			
			if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
				hr = m_pSWbemServices->DeleteAsync (pAsyncNotify, bsPath, iFlags, 
									objContext, pAsyncContext);
		}
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::InstancesAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->InstancesOfAsync (pAsyncNotify, bsPath, 
								iFlags, objContext, pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::SubclassesAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->SubclassesOfAsync (pAsyncNotify, bsPath, iFlags, 
								objContext,	pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::AssociatorsAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ BSTR strAssocClass,
	/* [defaultvalue][optional][in] */ BSTR strResultClass,
	/* [defaultvalue][optional][in] */ BSTR strResultRole,
	/* [defaultvalue][optional][in] */ BSTR strRole,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
	/* [defaultvalue][optional][in] */ BSTR strRequiredAssocQualifier,
	/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->AssociatorsOfAsync (pAsyncNotify, bsPath, strAssocClass, strResultClass,
						strResultRole, strRole, bClassesOnly, bSchemaOnly, 
						strRequiredAssocQualifier, strRequiredQualifier, iFlags, 
						objContext, pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::ReferencesAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [defaultvalue][optional][in] */ BSTR strResultClass,
	/* [defaultvalue][optional][in] */ BSTR strRole,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bClassesOnly,
	/* [defaultvalue][optional][in] */ VARIANT_BOOL bSchemaOnly,
	/* [defaultvalue][optional][in] */ BSTR strRequiredQualifier,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->ReferencesToAsync (pAsyncNotify, bsPath, 
						strResultClass,	strRole, bClassesOnly, bSchemaOnly, 
						strRequiredQualifier, iFlags, objContext, pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
        
HRESULT STDMETHODCALLTYPE CSWbemObject::ExecMethodAsync_( 
	/* [in] */ IDispatch __RPC_FAR *pAsyncNotify,
	/* [in] */ BSTR strMethodName,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objInParams,
	/* [defaultvalue][optional][in] */ long iFlags,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *objContext,
	/* [defaultvalue][optional][in] */ IDispatch __RPC_FAR *pAsyncContext)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pSWbemServices && m_pIWbemClassObject)
	{
		// Get the object path to pass to the IWbemServices call
		CComBSTR bsPath;
			
		if (CSWbemObjectPath::GetObjectPath (m_pIWbemClassObject, bsPath))
			hr = m_pSWbemServices->ExecMethodAsync (pAsyncNotify, bsPath, strMethodName,
							objInParams, iFlags, objContext, pAsyncContext);
	}

	if (FAILED(hr) && m_pDispatch)
		m_pDispatch->RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\contvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  CONTVAR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of IEnumVARIANT for iterators over 
//	ISWbemNamedValueSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CContextEnumVar::CContextEnumVar
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CContextEnumVar::CContextEnumVar(CSWbemNamedValueSet *pContext, ULONG initialPos)
{
	m_cRef = 0;
	m_pos = initialPos;
	m_pContext = pContext;
	m_pContext->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CContextEnumVar::~CContextEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CContextEnumVar::~CContextEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pContext)
		m_pContext->Release ();
}

//***************************************************************************
// HRESULT CContextEnumVar::QueryInterface
// long CContextEnumVar::AddRef
// long CContextEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CContextEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CContextEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CContextEnumVar::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CContextEnumVar::Reset ()
{
	m_pos = 0;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CContextEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		if (m_pContext)
		{
			// Retrieve the next cElements elements.  
			if (SeekCurrentPosition ())
			{
				for (l2 = 0; l2 < cElements; l2++)
				{
					ISWbemNamedValue *pObject = NULL;
					
					if (SUCCEEDED(m_pContext->Next (0, &pObject)))
					{
						if (NULL == pObject)
						{
							break;
						}
						else
						{
							// Set the object into the variant array; note that pObject
							// has been addref'd as a result of the Next() call above
							pVar[l2].vt = VT_DISPATCH;
							pVar[l2].pdispVal = pObject;
							m_pos++;
						}
					}
					else
						break;
				}
				if (NULL != pcElementFetched)
					*pcElementFetched = l2;
			}
		}
	}
	
	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CContextEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pContext)
		{
			CContextEnumVar *pEnum = new CContextEnumVar (m_pContext, m_pos);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::Skip
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CContextEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;
	long count = 0;
	m_pContext->get_Count (&count);

	if (((ULONG) count) >= cElements + m_pos)
	{
		hr = S_OK;
		m_pos += cElements;
	}
	else
		m_pos = count;

	return hr;
}

//***************************************************************************
//
//  SCODE CContextEnumVar::SeekCurrentPosition
//
//  DESCRIPTION:
//
//  Iterate to current position.  Somewhat painful as there is no
//	underlying iterator so we have to reset and then step. Note that we
//	assume that the access to this iterator is apartment-threaded.
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

bool CContextEnumVar::SeekCurrentPosition ()
{
	ISWbemNamedValue *pDummyObject = NULL;
	m_pContext->BeginEnumeration ();

	// Traverse to the current position
	ULONG i = 0;

	for (; i < m_pos; i++)
	{
		if (WBEM_S_NO_ERROR != m_pContext->Next (0, &pDummyObject))
			break;
		else
			pDummyObject->Release ();
	}

	return (i == m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\contvar.h ===
//***************************************************************************
//
//  contvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CContextEnumVar object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _CONTVAR_H_
#define _CONTVAR_H_

// This class implements the IEnumVARIANT interface

class CContextEnumVar : public IEnumVARIANT
{
private:
	long			m_cRef;
	CSWbemNamedValueSet	*m_pContext;
	ULONG			m_pos;

	bool			SeekCurrentPosition ();

public:
	CContextEnumVar (CSWbemNamedValueSet *pContext, ULONG initialPos = 0);
	~CContextEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\cwbemdsp.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation.
//
//  File:  cwbemdsp.cpp
//
//	Description :
//				Implementation of the IDispatch interface for Wbem Objects.
//				This is mostly standard, except for the additional support for
//				specifying the name of a Wbem class property/method directly as if it
//				was a property/method of the actual CWbemObject class ("dot notation")
//
//	Part of :	WBEM automation interface layer
//
//  History:	
//		corinaf			4/3/98		Created
//
//***************************************************************************

#include "precomp.h"

const unsigned long		CWbemDispID::s_wmiDispIdTypeMask = 0x03000000;
const unsigned long		CWbemDispID::s_wmiDispIdTypeStatic = 0x00000000;
const unsigned long		CWbemDispID::s_wmiDispIdTypeSchema = 0x01000000;
const unsigned long		CWbemDispID::s_wmiDispIdSchemaTypeMask = 0x00800000;
const unsigned long		CWbemDispID::s_wmiDispIdSchemaTypeProperty = 0x00800000;
const unsigned long		CWbemDispID::s_wmiDispIdSchemaTypeMethod = 0x00000000;
const unsigned long		CWbemDispID::s_wmiDispIdSchemaElementIDMask = 0x007FFFFF;

//Forward declaration

HRESULT assignArrayElementToVariant(SAFEARRAY *psa, VARTYPE vt, long inx, VARIANT *pvResult);
void assignVariantToArrayElement(SAFEARRAY *psa, VARTYPE vt, long inx, VARIANT *pvNewVal);
VARTYPE CimTypeToVtType(CIMTYPE lType);
HRESULT VariantChangeByValToByRef(VARIANT *dest, VARIANT *source, VARTYPE destType);

class CWbemSchemaIDCache
{
private:
	typedef map<CComBSTR, CWbemDispID, BSTRless, CWbemAllocator<CWbemDispID> > DispIDNameMap;

	unsigned long				m_nextId;
	DispIDNameMap				m_cache;
	CWbemDispatchMgr			*m_pDispatchMgr;

	bool	FindPropertyName (BSTR bsName);
	bool	GetMethod (BSTR bstrMethodName, SAFEARRAY **ppsaInParams, SAFEARRAY **ppsaOutParams,
						CComPtr<IWbemClassObject> & pInParams, CComPtr<IWbemClassObject> & pOutParams);
	bool	GetIdOfMethodParameter(BSTR bstrParamName, CComPtr<IWbemClassObject> & pParams, long *pId);

	static bool FindMemberInArray(BSTR bstrName, SAFEARRAY *psaNames);

public:
	CWbemSchemaIDCache (CWbemDispatchMgr *pDispMgr) :
				m_nextId (0),
				m_pDispatchMgr (pDispMgr) {}
	virtual ~CWbemSchemaIDCache ();

	HRESULT	GetDispID (LPWSTR FAR* rgszNames, unsigned int cNames, DISPID FAR* rgdispid); 
	bool	GetName (DISPID dispId, CComBSTR & bsName);
};


CWbemDispatchMgr::CWbemDispatchMgr(CSWbemServices *pWbemServices,
								   CSWbemObject *pSWbemObject) :
			m_pWbemServices (pWbemServices),
			m_pSWbemObject (pSWbemObject),	// Backpointer to parent (not AddRef'd)
			m_pWbemClass (NULL),
			m_pTypeInfo (NULL),
			m_pCTypeInfo (NULL),
			m_hResult (S_OK)
{
	m_pSchemaCache = new CWbemSchemaIDCache (this);

	if (m_pWbemServices)
		m_pWbemServices->AddRef ();

	m_pWbemObject = pSWbemObject->GetIWbemClassObject ();
}

CWbemDispatchMgr::~CWbemDispatchMgr()
{
	RELEASEANDNULL(m_pWbemServices)
	RELEASEANDNULL(m_pWbemObject)
	RELEASEANDNULL(m_pWbemClass)
	RELEASEANDNULL(m_pTypeInfo)
	RELEASEANDNULL(m_pCTypeInfo)
	DELETEANDNULL(m_pSchemaCache)
}

void	CWbemDispatchMgr::SetNewObject (IWbemClassObject *pNewObject)
{
	if (m_pWbemObject && pNewObject)
	{
		m_pWbemObject->Release ();
		m_pWbemObject = pNewObject;
		m_pWbemObject->AddRef ();

		CComVariant var;

		if (SUCCEEDED(pNewObject->Get (WBEMS_SP_GENUS, 0, &var, NULL, NULL)) &&
			(WBEM_GENUS_CLASS == var.lVal))
		{
			// This is a class, so update the class object too
			if (m_pWbemClass)
				m_pWbemClass->Release ();

			m_pWbemClass = pNewObject;
			m_pWbemClass->AddRef ();
		}

		// Clear out the caches
		if (m_pSchemaCache)
		{
			delete m_pSchemaCache;
			m_pSchemaCache = new CWbemSchemaIDCache (this);
		}
	}
}

STDMETHODIMP
CWbemDispatchMgr::GetTypeInfoCount(unsigned int FAR* pctinfo)
{
    *pctinfo = 1;
	return NOERROR;
}


STDMETHODIMP CWbemDispatchMgr::GetTypeInfo(unsigned int itinfo, 
							  LCID lcid,
							  ITypeInfo FAR* FAR* pptinfo)
{
	HRESULT hr;
	ITypeLib *pTypeLib = NULL;

	//If Type Info is not cached already - load the library and 
	//get the Type Info, then cache it for further access
	if (!m_pTypeInfo)
	{

		// Load Type Library. 
		hr = LoadRegTypeLib(LIBID_WbemScripting, 1, 0, lcid, &pTypeLib);
		if (FAILED(hr)) 
		{   
			// if it wasn't registered, try to load it from the path
			// if this succeeds, it will have registered the type library for us
			// for the next time.  
			hr = LoadTypeLib(OLESTR("wbemdisp.tlb"), &pTypeLib); 
			if(FAILED(hr))        
				return hr;   
		}
    
		// Get type information for interface of the object.  
		hr = pTypeLib->GetTypeInfoOfGuid(IID_ISWbemObjectEx, &m_pTypeInfo);
		pTypeLib->Release();
		if (FAILED(hr))  
			return hr;

	}

	//AddRef whenever returning another pointer to this
	m_pTypeInfo->AddRef();
	*pptinfo = m_pTypeInfo;

    return NOERROR;
}

STDMETHODIMP CWbemDispatchMgr::GetClassInfo(ITypeInfo FAR* FAR* pptinfo)
{
	HRESULT hr;
	ITypeLib *pTypeLib = NULL;

	//If Type Info is not cached already - load the library and 
	//get the Type Info, then cache it for further access
	if (!m_pCTypeInfo)
	{

		// Load Type Library. 
		hr = LoadRegTypeLib(LIBID_WbemScripting, 1, 0, 0, &pTypeLib);
		if (FAILED(hr)) 
		{   
			// if it wasn't registered, try to load it from the path
			// if this succeeds, it will have registered the type library for us
			// for the next time.  
			hr = LoadTypeLib(OLESTR("wbemdisp.tlb"), &pTypeLib); 
			if(FAILED(hr))        
				return hr;   
		}
    
		// Get type information for coclass of the object.  
		hr = pTypeLib->GetTypeInfoOfGuid(CLSID_SWbemObjectEx, &m_pCTypeInfo);
		pTypeLib->Release();
		if (FAILED(hr))  
			return hr;

	}

	//AddRef whenever returning another pointer to this
	m_pCTypeInfo->AddRef();
	*pptinfo = m_pCTypeInfo;

    return NOERROR;
}

STDMETHODIMP
CWbemDispatchMgr::GetIDsOfNames(REFIID iid,  //always IID_NULL
								LPWSTR FAR* rgszNames,
								unsigned int cNames, 
								LCID lcid, 
								DISPID FAR* rgdispid)
{
    HRESULT hr = E_FAIL;
	CComPtr<ITypeInfo> pITypeInfo;

	if (SUCCEEDED(hr = GetTypeInfo(0, lcid, &pITypeInfo)))
	{
		// See if this is a static property or method
		if (FAILED(hr = DispGetIDsOfNames(pITypeInfo,
							   rgszNames,
							   cNames,
							   rgdispid)))
		{
			// Not static - try schema
			if (m_pSchemaCache && FAILED(hr = m_pSchemaCache->GetDispID (rgszNames, cNames, rgdispid)))
			{
				rgdispid[0] = DISPID_UNKNOWN;
				hr = DISP_E_UNKNOWNNAME;
			}
		}
	}

	return hr;

}


STDMETHODIMP CWbemDispatchMgr::Invoke(DISPID dispidMember, 
						 REFIID iid, LCID lcid,
						 unsigned short wFlags, 
						 DISPPARAMS FAR* pdispparams,
						 VARIANT FAR* pvarResult, 
						 EXCEPINFO FAR* pexcepinfo,
						 unsigned int FAR* puArgErr)
{
	HRESULT hr;
	ITypeInfo *pTypeInfo = NULL;

	//Get the type info
	hr = GetTypeInfo(0, lcid, &pTypeInfo);
	if (FAILED(hr))
		return hr;

	m_hResult = S_OK;

	CWbemDispID dispId (dispidMember);

	// Is this a regular dispId
	if (dispId.IsStatic ())
	{
		// Check for inbound NULLs masquerading as defaulted parameters
		if (wFlags & DISPATCH_METHOD)
			MapNulls (pdispparams);

		hr = DispInvoke((IDispatch *) ((ISWbemObjectEx *)m_pSWbemObject),
				        pTypeInfo,
						dispidMember,
						wFlags,
						pdispparams,
						pvarResult,
						pexcepinfo,
						puArgErr
						);

		if (FAILED(hr))
		{
			// Try the error handler for this object in case it can handle this
			hr = HandleError (dispidMember, wFlags, pdispparams, pvarResult, puArgErr, hr);
		}
	}
	else if (dispId.IsSchema ())
	{
		//Otherwise - this is a WBEM property or method, so we implement
		//the invocation ourselves...

		ResetLastErrors ();
	
		if (dispId.IsSchemaMethod ()) //WBEM method
			hr = InvokeWbemMethod(dispidMember, 
								  pdispparams,
								  pvarResult);
		else if (dispId.IsSchemaProperty ()) //WBEM property
			hr = InvokeWbemProperty(dispidMember, 
									wFlags, 
									pdispparams, 
									pvarResult,
									pexcepinfo,
									puArgErr);
		else
			hr = DISP_E_MEMBERNOTFOUND;

		if (FAILED(hr))
			RaiseException (hr);
	}

	if (FAILED (m_hResult))
	{
		if (NULL != pexcepinfo)
			SetException (pexcepinfo, m_hResult, L"SWbemObjectEx");

		hr = DISP_E_EXCEPTION;
	}

	if (pTypeInfo)
		pTypeInfo->Release();

	return hr;
}

HRESULT
CWbemDispatchMgr::InvokeWbemProperty(DISPID dispid, 
									 unsigned short wFlags, 
								     DISPPARAMS FAR* pdispparams, 
									 VARIANT FAR* pvarResult,
									 EXCEPINFO FAR* pexcepinfo,
									 unsigned int FAR* puArgErr)
{
	HRESULT hr = E_FAIL;

	if (m_pSchemaCache)
	{
		BOOL bIsGetOperation = (DISPATCH_PROPERTYGET & wFlags);

		if (bIsGetOperation)
		{
			//Check that the output parameter is valid
			if (pvarResult == NULL)
				return E_INVALIDARG;
		}
		else
		{
			//Check input parameters
			if ((pdispparams->cArgs < 1) || (pdispparams->cArgs > 2)) 
				return DISP_E_BADPARAMCOUNT;

			if ((pdispparams->cNamedArgs != 1) ||
				(pdispparams->cNamedArgs == 1 && 
				 pdispparams->rgdispidNamedArgs[0] != DISPID_PROPERTYPUT))
				return DISP_E_PARAMNOTOPTIONAL;
		}	

		//For both get & put, we need to first get the property 
		//             (for put we need to validate the syntax)
		CComBSTR bsPropertyName;

		if (m_pSchemaCache->GetName (dispid, bsPropertyName))
		{
			SAFEARRAY *psaNames = NULL;
			long inx;
			VARIANT vPropVal;
			long lArrayPropInx;
			CIMTYPE lPropType;

			//Get the value of this property
			//-------------------------------------
			VariantInit(&vPropVal);
			if (FAILED (hr = m_pWbemObject->Get(bsPropertyName, 0, &vPropVal, &lPropType, NULL)))
			{
				return hr;
			}

			// The expected VT type for the proposed property value
			VARTYPE expectedVarType =  CimTypeToVtType (lPropType & ~CIM_FLAG_ARRAY);

			//If we are in a get operation
			//----------------------------------
			if (bIsGetOperation)
			{
				//If the property is an embedded object, we might need to convert it from 
				//a VT_UNKNOWN to a VT_DISPATCH
				if (SUCCEEDED(hr = MapFromCIMOMObject(m_pWbemServices, &vPropVal, 
										m_pSWbemObject, bsPropertyName)))
				{
					//If the property is an array, need to check for index and get that element
					if ((lPropType & CIM_FLAG_ARRAY) && (pdispparams->cArgs > 0))
					{
						//Note: currently we support single dimension arrays only, so we only
						//      look for one index
						VARIANT indexVar;
						VariantInit (&indexVar);
						// Attempt to coerce the index argument into a value suitable for an array index
						if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[0], 0, VT_I4)) 
						{
							lArrayPropInx = V_I4(&indexVar);

							//Fill in the result variant with the requested array element
							hr = assignArrayElementToVariant(vPropVal.parray, (V_VT(&vPropVal) & ~VT_ARRAY),
													lArrayPropInx, pvarResult);
						}
						else
							hr = DISP_E_TYPEMISMATCH;

						VariantClear (&indexVar);
					}
					else //If it's not an array index - copy to output param and we're done
					{
						// Check if it's an array value and convert as necessary
						if (V_ISARRAY(&vPropVal))
							hr = ConvertArrayRev(pvarResult, &vPropVal);
           				else
							hr = VariantCopy (pvarResult, &vPropVal);
					}
				}
			} //Property Get

			//Otherwise (put operation)
			//---------------------------------
			else
			{
				/*
				 * Need to translate this into a call to SWbemProperty.put_Value: easiest way
				 * to do this is to 
				 * (A) get the SWbemProperty object for this property
				 * (B) Call IDispatch::Invoke on that object, passing in the value
				 * This way we get the error handling behavior too.
				 */

				CComPtr<ISWbemPropertySet> pISWbemPropertySet;

				if (SUCCEEDED(hr = m_pSWbemObject->get_Properties_ (&pISWbemPropertySet)))
				{
					CComPtr<ISWbemProperty> pISWbemProperty;

					if (SUCCEEDED(hr = pISWbemPropertySet->Item (bsPropertyName, 0, &pISWbemProperty)))
					{
						// NB: The Value property of ISWbemProperty is the "default" automation property
						hr = pISWbemProperty->Invoke (
										DISPID_VALUE,
										IID_NULL, 
										0,
										wFlags,
										pdispparams, 
										pvarResult,
										pexcepinfo,
										puArgErr);

						// Use our more specific error here if we have one
						if (FAILED(hr) && pexcepinfo)
							hr = pexcepinfo->scode;
					}
				}

			} //Property Put

			VariantClear(&vPropVal);
		}
	}

	return hr;

} 

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::InvokeWbemMethod
//
//  DESCRIPTION:
//
//  Invoke the method via direct access.  
//
//  PARAMETERS:
//
//		dispid			The dispid od the method
//		pdispparams		Pointer to DISPPARAMS for this invocation
//		pvarResult		On successful return holds return value (if any)
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::InvokeWbemMethod(
	DISPID dispid, 
	DISPPARAMS FAR* pdispparams, 
	VARIANT FAR* pvarResult
)
{
	HRESULT hr = E_FAIL;

	if (m_pWbemServices && m_pSchemaCache)
	{
		//Currently we don't support named arguments
		if (pdispparams->cNamedArgs > 0)
			return DISP_E_NONAMEDARGS;

		//Map the dispid to a method name
		CComBSTR bsMethodName;

		if (m_pSchemaCache->GetName (dispid, bsMethodName))
		{
			// Build up the inparameters (if any)
			CComPtr<IWbemClassObject> pInParameters;
			CComPtr<IWbemClassObject> pOutParameters;

			//Get the input parameters object of the method (may be NULL)
			if (SUCCEEDED (hr = m_pWbemClass->GetMethod(bsMethodName, 0, &pInParameters, 
															&pOutParameters)))
			{
				CComPtr<IWbemClassObject> pInParamsInstance;

				if (pInParameters)
					hr = MapInParameters (pdispparams, pInParameters, &pInParamsInstance);
				
				if (SUCCEEDED (hr))
				{
					CComPtr<IWbemServices> pService;
					pService.Attach(m_pWbemServices->GetIWbemServices());

					if (pService)
					{
						// Need the RELPATH to specify the target class or instance
						VARIANT vObjectPathVal;
						VariantInit(&vObjectPathVal);
			
						if (SUCCEEDED (hr = m_pWbemObject->Get
											(WBEMS_SP_RELPATH, 0, &vObjectPathVal, NULL, NULL)))
						{
							/*
							 * If a "keyless" object slips through the net its __RELPATH
							 * value will be VT_NULL.  At this point we should fail gracefully.
							 */
							if 	(VT_BSTR == V_VT(&vObjectPathVal))
							{
								// Execute the CIMOM method 
								CComPtr<IWbemClassObject> pOutParamsInstance;
									
								bool needToResetSecurity = false;
								HANDLE hThreadToken = NULL;
								CSWbemSecurity *pSecurityInfo = m_pWbemServices->GetSecurityInfo ();
			
								if (pSecurityInfo && pSecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
								{
			
									if (SUCCEEDED(hr = pService->ExecMethod(V_BSTR(&vObjectPathVal), 
											bsMethodName, 0, NULL,
											pInParamsInstance, &pOutParamsInstance, NULL)))
										hr = MapOutParameters (pdispparams, pOutParameters,
																pOutParamsInstance,	pvarResult);

									SetWbemError (m_pWbemServices);
								}

								if (pSecurityInfo)
								{
									// Restore original privileges on this thread
									if (needToResetSecurity)
										pSecurityInfo->ResetSecurity (hThreadToken);

									pSecurityInfo->Release ();
								}
							}
							else
								hr = WBEM_E_FAILED;
						}

						VariantClear (&vObjectPathVal);
					}
				}		
			}
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapOutParameters
//
//  DESCRIPTION:
//
//  Invoke the method via direct access.  
//
//  PARAMETERS:
//
//		dispparams			Pointer to DISPPARAMS for this invocation
//		pOutParameters		Class template for out parameters
//		pOutParamsInstance	Addresses the IWbemClassObject to hold the
//							out parameters (if any) - may be NULL
//		pvarResult			On successful return holds return value (if any)
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapOutParameters (
	DISPPARAMS FAR* pdispparams,
	IWbemClassObject *pOutParameters,
	IWbemClassObject *pOutParamsInstance,
	VARIANT FAR* pvarResult
)
{
	HRESULT hr = S_OK;

	//For each "out" parameter in the output parameters object (if there is one), 
	//find it's id, then look for the parameter with this id in the arguments array
	//and set the return parameter value accordingly
	//----------------------------------------------------------------------------

	if (pOutParameters && pOutParamsInstance)
	{
		//Start an enumeration through the "out" parameters class template
		if (SUCCEEDED (hr = pOutParameters->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
		{
			BSTR bstrId = SysAllocString(L"id");
			BSTR bstrParamName = NULL;
						
			/*
			 * For each property in the outparams class template, get the [id]
			 * to map the relevant posistional value in the pdispparams.
			 */
			while (WBEM_S_NO_ERROR == 
				(hr != pOutParameters->Next(0, &bstrParamName, NULL, NULL, NULL)))
			{
				// Get the returned parameter value from the instance
				VARIANT vParamVal;
				VariantInit(&vParamVal);
				
				if (SUCCEEDED (pOutParamsInstance->Get (bstrParamName, 0, &vParamVal, NULL, NULL)))
				{
					//If this is the return value, set it separately
					if (!_wcsicmp(bstrParamName, L"ReturnValue"))
					{
						if (pvarResult)
							hr = MapReturnValue (pvarResult, &vParamVal);
					}
					//Otherwise - regular out parameter
					else
					{
						IWbemQualifierSet *pQualSet = NULL;
						
						//Get the id of this parameter (it's the "id" qualifier)
						if (SUCCEEDED (hr = pOutParameters->GetPropertyQualifierSet
													(bstrParamName, &pQualSet)))
						{
							VARIANT vIdVal;
							VariantInit(&vIdVal);

							if (SUCCEEDED (hr = pQualSet->Get(bstrId, 0, &vIdVal, NULL)))
							{
								//Calculate the position of this id in the arguments array
								long pos = (pdispparams->cArgs - 1) - V_I4(&vIdVal);

								// If its out of range, too bad
								if ((0 <= pos) && (pos < (long) pdispparams->cArgs))
									hr = MapOutParameter (&pdispparams->rgvarg[pos], &vParamVal);
							}

							VariantClear(&vIdVal);
							pQualSet->Release();	
						}
					}
				}

				VariantClear (&vParamVal);
				SysFreeString (bstrParamName);
				bstrParamName = NULL;
			} //while

			SysFreeString (bstrId);
		}
	} //if pOutParameters
		
	return hr;
} 

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapReturnValue
//
//  DESCRIPTION:
//
//  Map the method return value
//
//  PARAMETERS:
//
//		pDest	On successful return holds return value (if any)
//		pSrc	The variant value to map	
//		
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapReturnValue (
	VARIANT FAR* pDest,
	VARIANT FAR* pSrc
)
{
	HRESULT hr = S_OK;

	//If the return value is a VT_UNKNOWN, we need to wrap into a 
	//VT_DISPATCH before passing it back
	if (SUCCEEDED (hr = MapFromCIMOMObject(m_pWbemServices, pSrc)))
	{
		// Handle arrays correctly (must always be VT_ARRAY|VT_VARIANT)
		if(V_VT(pSrc) & VT_ARRAY)
			hr = ConvertArrayRev(pDest, pSrc);
		else
			hr = VariantCopy (pDest, pSrc);
	}
		
	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapOutParameter
//
//  DESCRIPTION:
//
//  Map a (possibly by reference) out parameter
//
//  PARAMETERS:
//
//		pDest	On successful return holds return value (if any)
//		pVal	The variant value to map	
//		
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapOutParameter (
	VARIANT FAR* pDest,
	VARIANT FAR* pSrc
)
{
	HRESULT hr = S_OK;

	//If the return value is a VT_UNKNOWN, we need to wrap into a 
	//VT_DISPATCH before passing it back
	if (SUCCEEDED (hr = MapFromCIMOMObject(m_pWbemServices, pSrc)))
	{
		VARIANT tempVal;
		VariantInit (&tempVal);
		
		// Handle arrays correctly (must always be VT_ARRAY|VT_VARIANT)
		if(V_VT(pSrc) & VT_ARRAY)
			hr = ConvertArrayRev(&tempVal, pSrc);
		else
			hr = VariantCopy (&tempVal, pSrc);
		
		// Finally take care of ensuring we produce BYREFs if necessary
		if (SUCCEEDED (hr))
			 hr = VariantChangeByValToByRef(pDest, &tempVal, V_VT(pDest));

		VariantClear (&tempVal);
	}

	return hr;
}

								
//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapInParameters
//
//  DESCRIPTION:
//
//  Map the in parameters to a method
//
//  PARAMETERS:
//
//		pdispparams			DISPPARAMS containing the in parameters
//		pInParameters		Class template for method input parameters
//		ppInParamsInstance	On successful return holds the mapped parameters
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapInParameters (
	DISPPARAMS FAR* pdispparams, 
	IWbemClassObject *pInParameters,
	IWbemClassObject **ppInParamsInstance
)
{
	HRESULT hr = S_OK;
	*ppInParamsInstance = NULL;

	//Spawn an instance to fill in with values
	if (SUCCEEDED (hr = pInParameters->SpawnInstance(0, ppInParamsInstance)))
	{
		/*
		 * Iterate through the "in" parameters object properties in the class to find the
		 * ID positional qualifier.  Note we do this in the InParams class rather than
		 * the spawned instance to protect ourselves against the case where the [id]
		 * qualifier has been declared without the "propagate to instance" flavor setting,
		 */
		if (SUCCEEDED (hr = pInParameters->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
		{
			BSTR bstrParamName = NULL;
			BSTR bstrId = SysAllocString(L"id");
			CIMTYPE lType;

			//For each property in the inparams object
			while (WBEM_S_NO_ERROR == 
						(hr = pInParameters->Next(0, &bstrParamName, NULL, &lType, NULL)))
			{
				IWbemQualifierSet *pQualSet = NULL;
			
				//Get the id of this parameter (it's the "id" qualifier)
				if (SUCCEEDED(hr = 
						pInParameters->GetPropertyQualifierSet(bstrParamName, &pQualSet)))
				{
					VARIANT vIdVal;
					VariantInit(&vIdVal);
				
					if (SUCCEEDED(hr = pQualSet->Get(bstrId, 0, &vIdVal, NULL)))
					{
						//Calculate the position of this id in the arguments array
						long pos = (pdispparams->cArgs - 1) - V_I4(&vIdVal);

						// If no argument specified, we won't set it in ppInParamsInstance
						// and just assume it will be defaulted
						if ((0 <= pos) && (pos < (long) pdispparams->cArgs))
						{
							VARIANT vParamVal;
							VariantInit (&vParamVal);
							
							if (SUCCEEDED (hr = MapInParameter 
										(&vParamVal, &pdispparams->rgvarg[pos], lType)))
							{
								// If we have a VT_ERROR with DISP_E_PARAMNOTFOUND this
								// is a "missing" parameter - we just fail to set it and 
								// let it default in the instance

								if ((VT_ERROR == V_VT(&vParamVal)) && (DISP_E_PARAMNOTFOUND == vParamVal.scode))
								{
									// Let it default
								}
								else
								{
									//Copy the value for this parameter from the argument array
									//into the inparamsinstance object property
									hr = (*ppInParamsInstance)->Put(bstrParamName, 0, &vParamVal, NULL);
								}
							}

							VariantClear (&vParamVal);
						}
					}

					VariantClear(&vIdVal);
					pQualSet->Release();
					pQualSet = NULL;
				}

				SysFreeString (bstrParamName);						
				bstrParamName = NULL;

				if (FAILED(hr))
					break;
			} //while

			SysFreeString (bstrId);
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::MapInParameter
//
//  DESCRIPTION:
//
//  Map a in parameter
//
//  PARAMETERS:
//
//		pDest	On successful return holds return value
//		pVal	The variant value to map	
//		lType	CIMTYPE of target property value
//		
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemDispatchMgr::MapInParameter (
	VARIANT FAR* pDest,
	VARIANT FAR* pSrc,
	CIMTYPE		 lType
)
{
	HRESULT hr = S_OK;

	if ((NULL == pSrc) || (VT_EMPTY == V_VT(pSrc)) 
							|| (VT_NULL == V_VT(pSrc)))
	{
		// Map all of these to a VT_NULL
		pDest->vt = VT_NULL;
	}
	else if (((VT_ARRAY | VT_VARIANT) == V_VT(pSrc)) ||
			 ((VT_ARRAY | VT_VARIANT | VT_BYREF) == V_VT(pSrc)))
	{
		// Arrays need to be mapped "down" to their raw form (and watch out
		// for embedded objects!)
		if (SUCCEEDED(hr = ConvertArray(pDest, pSrc)))
            hr = MapToCIMOMObject(pDest);
	}
	else if ((CIM_FLAG_ARRAY & lType) && 
			((VT_DISPATCH == V_VT(pSrc)) 
			 || ((VT_DISPATCH|VT_BYREF) == V_VT(pSrc))))
	{
		// Look for a JScript-style IDispatch that needs to be mapped to an array
		hr = ConvertDispatchToArray (pDest, pSrc, lType & ~CIM_FLAG_ARRAY);
	}
	else if ((VT_BYREF | VT_VARIANT) == V_VT(pSrc))
	{
		// May be used if the scripting language supports functions that can change
		// the type of a reference.  CIMOM won't do this, wo we unwrap the
		// variant before proceeding
		hr = MapInParameter (pDest, pSrc->pvarVal, lType);
	}
	else
	{
		// A "straightforward" value - all we have to watch for is an embedded object
		// and a possible byRef
		if (SUCCEEDED(hr = VariantCopy (pDest, pSrc)))
		{
			hr = MapToCIMOMObject(pDest);

			// Is it byref - if so remove the indirection
			if (VT_BYREF & V_VT(pDest))
				hr = VariantChangeType(pDest, pDest, 0, V_VT(pDest) & ~VT_BYREF);
		}
	}			

	return hr;
}

//-------------------------------------------------------------
// CWbemDispatchMgr::RaiseException
//
// Description : signal exception to automation client
//
// Parameters : hr - HRESULT
//-------------------------------------------------------------
void CWbemDispatchMgr::RaiseException (HRESULT hr)
{
	// Store the HRESULT for processing in the Invoke routine
	m_hResult = hr;

	// Set a WMI scripting error on this thread for the client
	ICreateErrorInfo *pCreateErrorInfo = NULL;

	if (SUCCEEDED (CreateErrorInfo (&pCreateErrorInfo)))
	{
		BSTR bsDescr = MapHresultToWmiDescription (hr);
		pCreateErrorInfo->SetDescription (bsDescr);
		SysFreeString (bsDescr);
		pCreateErrorInfo->SetGUID (IID_ISWbemObjectEx);
		pCreateErrorInfo->SetSource (L"SWbemObjectEx");
	
		IErrorInfo *pErrorInfo = NULL;

		if (SUCCEEDED (pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void**) &pErrorInfo)))
		{
			SetErrorInfo (0, pErrorInfo);
			pErrorInfo->Release ();
		}

		pCreateErrorInfo->Release ();
	}
}					

//-------------------------------------------------------------
// Name : assignArrayElementToVariant
//
// Description : According to the type of the array elements,
//			     retrieves the requested element from the array
//				 into a variant
//
// Parameters : psa - pointer to the SAFEARRAY
//				vt -  vartype of array elements
//				inx - index of the element in the array
//				pvResult - resulting variant
//-------------------------------------------------------------
HRESULT assignArrayElementToVariant(SAFEARRAY *psa, VARTYPE vt, long inx, VARIANT *pvResult)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	switch (vt)
	{
		case VT_I2 :
			V_VT(pvResult) = VT_I2;
			hr = SafeArrayGetElement(psa, &inx, &V_I2(pvResult));		// Bug ID 566345
			break;
		case VT_I4 :
			V_VT(pvResult) = VT_I4;
			hr = SafeArrayGetElement(psa, &inx, &V_I4(pvResult));		// Bug ID 566345
			break;
		case VT_R4 :
			V_VT(pvResult) = VT_R4;
			hr = SafeArrayGetElement(psa, &inx, &V_R4(pvResult));		// Bug ID 566345
			break;
		case VT_R8 :
			V_VT(pvResult) = VT_R8;
			hr = SafeArrayGetElement(psa, &inx, &V_R8(pvResult));		// Bug ID 566345
			break;
		case VT_DATE :
			V_VT(pvResult) = VT_DATE;
			hr = SafeArrayGetElement(psa, &inx, &V_DATE(pvResult));		// Bug ID 566345
			break;
		case VT_BSTR : 
			V_VT(pvResult) = VT_BSTR;
			hr = SafeArrayGetElement(psa, &inx, &V_BSTR(pvResult));		// Bug ID 566345
			break;
		case VT_DISPATCH :
			V_VT(pvResult) = VT_DISPATCH;
			hr = SafeArrayGetElement(psa, &inx, &V_DISPATCH(pvResult));		// Bug ID 566345
			break;
		case VT_UNKNOWN :
			V_VT(pvResult) = VT_UNKNOWN;
			hr = SafeArrayGetElement(psa, &inx, &V_UNKNOWN(pvResult));		// Bug ID 566345
			break;
		case VT_BOOL :
			V_VT(pvResult) = VT_BOOL;
			hr = SafeArrayGetElement(psa, &inx, &V_BOOL(pvResult));		// Bug ID 566345
			break;
		case VT_VARIANT :
		{
			V_VT(pvResult) = VT_BYREF | VT_VARIANT;
			VARIANT *pVar = new VARIANT;

			if (pVar)
			{
				VariantInit (pVar);
				hr = SafeArrayGetElement(psa, &inx, pVar);		// Bug ID 566345
				V_VARIANTREF(pvResult) = pVar;
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
		}
			break;
		case VT_UI1 : 
			V_VT(pvResult) = VT_UI1;
			hr = SafeArrayGetElement(psa, &inx, &V_UI1(pvResult));		// Bug ID 566345
			break;
		default :
			V_VT(pvResult) = VT_ERROR;
			break;
	}

	return hr;
}

//-------------------------------------------------------------
// Name : CheckArrayBounds
//
// Description : Check that index is within bounds and if not
//				 Redim the array
//
// Parameters : psa - pointer to the SAFEARRAY
//				inx - putative index
//-------------------------------------------------------------
void CheckArrayBounds(SAFEARRAY *psa, long inx)
{
	long lBound, uBound;
        lBound = uBound = 0;
	SafeArrayGetUBound (psa, 1, &uBound);
	SafeArrayGetLBound (psa, 1, &lBound);

	if ((inx < lBound) || (inx > uBound))
	{
		// Need to redim
		SAFEARRAYBOUND psaBound;
	
		psaBound.cElements = ((inx < lBound) ? 
			(uBound + 1 - inx) : (inx + 1 - lBound));

		psaBound.lLbound = (inx < lBound) ? inx : lBound;
		SafeArrayRedim (psa, &psaBound);
	}
}
	
//-------------------------------------------------------------
// Name : assignVariantToArrayElement
//
// Description : According to the type of the array elements,
//			     puts the new value from the variant into the
//				 requested element of the array
//
// Parameters : psa - pointer to the SAFEARRAY
//				vt -  vartype of array elements
//				inx - index of the element in the array
//				pvNewVal - variant containing the new value
//-------------------------------------------------------------
void assignVariantToArrayElement(SAFEARRAY *psa, VARTYPE vt, long inx, VARIANT *pvNewVal)
{
	HRESULT hr = E_FAIL;

	// Firstly check for out-of-bounds case and grow accordingly
	CheckArrayBounds (psa, inx);
	
	switch (vt)
	{
		case VT_I2 :
			hr = SafeArrayPutElement(psa, &inx, &V_I2(pvNewVal));
			break;
		case VT_I4 :
			hr = SafeArrayPutElement(psa, &inx, &V_I4(pvNewVal));
			break;
		case VT_R4 :
			hr = SafeArrayPutElement(psa, &inx, &V_R4(pvNewVal));
			break;
		case VT_R8 :
			hr = SafeArrayPutElement(psa, &inx, &V_R8(pvNewVal));
			break;
		case VT_DATE :
			hr = SafeArrayPutElement(psa, &inx, &V_DATE(pvNewVal));
			break;
		case VT_BSTR : 
			hr = SafeArrayPutElement(psa, &inx, V_BSTR(pvNewVal));
			break;
		case VT_DISPATCH :
			hr = SafeArrayPutElement(psa, &inx, V_DISPATCH(pvNewVal));
			break;
		case VT_UNKNOWN:
			hr = SafeArrayPutElement(psa, &inx, V_UNKNOWN(pvNewVal));
			break;
		case VT_BOOL :
			hr = SafeArrayPutElement(psa, &inx, &V_BOOL(pvNewVal));
			break;
		case VT_VARIANT :
			hr = SafeArrayPutElement(psa, &inx, V_VARIANTREF(pvNewVal));
			break;
		case VT_UI1 : 
			hr = SafeArrayPutElement(psa, &inx, &V_UI1(pvNewVal));
			break;
		default :
			//????????????
			break;
	} //switch
}


//-------------------------------------------------------------
// Name : CimTypeToVtType
//
// Description : Returns the coresponding VARTYPE for
//				 a given CIMTYPE
// Parameters : lType - the CIMTYPE we want to convert
//-------------------------------------------------------------
VARTYPE CimTypeToVtType(CIMTYPE lType)
{
	VARTYPE ret = VT_EMPTY;

	if (lType & CIM_FLAG_ARRAY)
		ret = VT_ARRAY;

	switch(lType & ~CIM_FLAG_ARRAY)
	{
		case CIM_EMPTY :	ret = (ret | VT_EMPTY); break;
		case CIM_SINT8 :	ret = (ret | VT_I2); break;
		case CIM_UINT8 :	ret = (ret | VT_UI1); break;
		case CIM_SINT16 :	ret = (ret | VT_I2); break;
		case CIM_UINT16 :	ret = (ret | VT_I4); break;
		case CIM_SINT32 :	ret = (ret | VT_I4); break;
		case CIM_UINT32 :	ret = (ret | VT_I4); break;
		case CIM_SINT64 :	ret = (ret | VT_BSTR); break;
		case CIM_UINT64 :	ret = (ret | VT_BSTR); break;
		case CIM_REAL32 :	ret = (ret | VT_R4); break;
		case CIM_REAL64 :	ret = (ret | VT_R8); break;
		case CIM_BOOLEAN :	ret = (ret | VT_BOOL); break;
		case CIM_STRING :	ret = (ret | VT_BSTR); break;
		case CIM_DATETIME :	ret = (ret | VT_BSTR); break;
		case CIM_REFERENCE :ret = (ret | VT_BSTR); break;
		case CIM_CHAR16 :	ret = (ret | VT_I2); break;
		case CIM_OBJECT :	ret = (ret | VT_UNKNOWN); break;
		default : ret = VT_ERROR;
	}

	return ret;
}


//-------------------------------------------------------------
// Name : VariantChangeByValToByRef
//
// Description : Copies a variant, while converting a "byval" to a 
//				 "byref" if the destination type requires it
//
// Parameters : dest - destination variant to hold the result
//				source - source variant to be copied
//				destType - the VARTYPE required for the result.
//					       when this type is a BY_REF, the appropriate
//						   conversion is made from the source.
//-------------------------------------------------------------
HRESULT VariantChangeByValToByRef(VARIANT *dest, VARIANT *source, VARTYPE destType)
{
	HRESULT hr = S_OK;

	if (!(destType & VT_BYREF)) //the destination is not by ref. we can do a straight copy
	{
		VariantInit(dest);
		hr = VariantCopy(dest, source); 
	}
	else
	{
		if ((destType & ~VT_BYREF) & VT_ARRAY)
		{
			// Fix for bug 732681
			if(V_VT(source) == VT_NULL)
			{
				if(NULL != *(V_ARRAYREF(dest)))
				{
					SafeArrayDestroy(*(V_ARRAYREF(dest)));
					*(V_ARRAYREF(dest)) = NULL;
				}
			}
			else
			{
				hr = SafeArrayCopy(V_ARRAY(source), V_ARRAYREF(dest));
			}
		}
		else
		{
			switch (destType & ~VT_BYREF)
			{
				case VT_UI1 :  *V_UI1REF(dest) = V_UI1(source); break;
				case VT_I2 :   *V_I2REF(dest) = V_I2(source); break;
				case VT_I4 :   *V_I4REF(dest) = V_I4(source); break;
				case VT_R4 :   *V_R4REF(dest) = V_R4(source); break;
				case VT_R8 :   *V_R8REF(dest) = V_R8(source); break;
				case VT_CY :   *V_CYREF(dest) = V_CY(source); break;
				case VT_BSTR : SysReAllocString(V_BSTRREF(dest), V_BSTR(source)); break;
				case VT_BOOL : *V_BOOLREF(dest) = V_BOOL(source); break;
				case VT_DATE : *V_DATEREF(dest) = V_DATE(source); break;
				case VT_DISPATCH : 
						//I need to addref the object behind this interface so
						//that it doesn't get released when we release the original VARIANT
						//that's holding it
						V_DISPATCH(source)->AddRef();
						*V_DISPATCHREF(dest) = V_DISPATCH(source); 
						break;
				case VT_UNKNOWN : 
						//Again, need to addref so that the object doesn't get released
						V_UNKNOWN(source)->AddRef();
						*V_UNKNOWNREF(dest) = V_UNKNOWN(source); break;
						break;
				case VT_VARIANT : 
						hr = VariantChangeByValToByRef(V_VARIANTREF(dest),source,V_VT(V_VARIANTREF(dest)) ); break;						
				default : hr = DISP_E_TYPEMISMATCH;
			}
		}
	}

	return hr;

}

//***************************************************************************
//
//  void CWbemDispatchMgr::EnsureClassRetrieved
//
//  DESCRIPTION:
//
//  Make sure we have a class pointer
//
//***************************************************************************

void CWbemDispatchMgr::EnsureClassRetrieved ()
{
	if (!m_pWbemClass)
	{
		CComVariant vGenusVal, vClassName;
		bool bIsClass;

		if (SUCCEEDED(m_pWbemObject->Get(WBEMS_SP_GENUS, 0, &vGenusVal, NULL, NULL)))
		{
			bIsClass = (WBEM_GENUS_CLASS == vGenusVal.lVal);

			//If the object is a class, point the class pointer to it as well
			if (bIsClass)
			{
				m_pWbemClass = m_pWbemObject;
				m_pWbemClass->AddRef () ;
			}
			//Otherwise (it's an instance) we need to get the class
			else
			{
				// Check we have an IWbemServices pointer

				if (m_pWbemServices)
				{
					/*
					 * Note we must check that returned value is a BSTR - it could be a VT_NULL if
					 * the __CLASS property has not yet been set.
					 */
							
					if (SUCCEEDED(m_pWbemObject->Get(WBEMS_SP_CLASS, 0, &vClassName, NULL, NULL)) 
						&& (VT_BSTR == V_VT(&vClassName)))
					{
						CComPtr<IWbemServices> pIWbemServices;
						pIWbemServices.Attach( m_pWbemServices->GetIWbemServices ());

						if (pIWbemServices)
						{
							CSWbemSecurity *pSecurity = m_pWbemServices->GetSecurityInfo ();

							if (pSecurity)
							{
								bool needToResetSecurity = false;
								HANDLE hThreadToken = NULL;
						
								if (pSecurity->SetSecurity (needToResetSecurity, hThreadToken))
									pIWbemServices->GetObject (vClassName.bstrVal, 0, NULL, &m_pWbemClass, NULL);
												
								// Restore original privileges on this thread
								if (needToResetSecurity)
									pSecurity->ResetSecurity (hThreadToken);
										
								pSecurity->Release ();
							}
						}
					}
				}
			}
		}
	}
}

//***************************************************************************
//
//  SCODE CWbemDispatchMgr::HandleError
//
//  DESCRIPTION:
//
//  Provide bespoke handling of error conditions in the bolierplate
//	Dispatch implementation.
//
//  PARAMETERS:
//
//		dispidMember, wFlags,
//		pdispparams, pvarResult,
//		puArgErr,					All passed directly from IDispatch::Invoke
//		hr							The return code from the bolierplate invoke
//
//  RETURN VALUES:
//		The new return code (to be ultimately returned from Invoke)
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemDispatchMgr::HandleError (
	DISPID dispidMember,
	unsigned short wFlags,
	DISPPARAMS FAR* pdispparams,
	VARIANT FAR* pvarResult,
	UINT FAR* puArgErr,
	HRESULT hr
)
{
	/*
	 * We are looking for GET calls on the Derivation_ property which
	 * supplied an argument.  Since this property returns a SAFEARRAY, this may
	 * be legal but undetectable by the standard Dispatch mechanism. It is meaningful 
	 * to pass an index (the interpretation is that the index specifies an offset in
	 * the SAFEARRAY structure that represents the derivation value).
	 */
	if ((dispidMember == WBEMS_DISPID_DERIVATION) && (DISP_E_NOTACOLLECTION == hr) && (1 == pdispparams->cArgs)
		&& (DISPATCH_PROPERTYGET & wFlags))
	{
		// Looks promising - get the __DERIVATION property to try and resolve this
		if (m_pWbemObject)
		{
			VARIANT var;
			VariantInit (&var);
			
			if (WBEM_S_NO_ERROR == m_pWbemObject->Get (WBEMS_SP_DERIVATION, 0, &var, NULL, NULL))
			{
				/* The value should be a VT_BSTR|VT_ARRAY */
				if (((VT_ARRAY | VT_BSTR) == var.vt) && (NULL != var.parray))
				{
					VARIANT indexVar;
					VariantInit (&indexVar);

					// Attempt to coerce the index argument into a value suitable for an array index
					if (S_OK == VariantChangeType (&indexVar, &pdispparams->rgvarg[0], 0, VT_I4)) 
					{
						long lArrayPropInx = V_I4(&indexVar);

						// We should have a VT_ARRAY|VT_BSTR value at this point; extract the
						// BSTR and set it into the VARIANT
						VariantInit (pvarResult);
						BSTR nameValue = NULL;
						if (SUCCEEDED(hr = SafeArrayGetElement (var.parray, &lArrayPropInx, &nameValue)))
						{
							VariantInit (pvarResult);
							pvarResult->vt = VT_BSTR;
							pvarResult->bstrVal = nameValue;
						}
					}
					else
					{
							hr = DISP_E_TYPEMISMATCH;
							if (puArgErr)
								*puArgErr = 0;
					}

					VariantClear (&indexVar);
				}
			}

			VariantClear (&var);
		}
	}
	
	return hr;
}


// IDispatchEx methods
HRESULT STDMETHODCALLTYPE CWbemDispatchMgr::GetDispID( 
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	return GetIDsOfNames(IID_NULL, &((OLECHAR *)bstrName), 1, ENGLISH_LOCALE, pid);
}

//***************************************************************************
//
//  SCODE CWbemSchemaIDCache::~CWbemSchemaIDCache
//
//  DESCRIPTION:
//
//		Destructor
//
//***************************************************************************

CWbemSchemaIDCache::~CWbemSchemaIDCache ()
{
	DispIDNameMap::iterator next; 

	while ((next = m_cache.begin ()) != m_cache.end ())
		next = m_cache.erase (next);
}

//***************************************************************************
//
//  SCODE CWbemSchemaIDCache::GetDispID
//
//  DESCRIPTION:
//
//  Attempts to resolves a set of names to DISP IDs based on WMI schema.
//
//  PARAMETERS:
//
//		rgszNames				Array of names
//		cNames					Length of above array
//		rgdispid				Pointer to array to hold resolved DISPIDs
//
//  RETURN VALUES:
//
//***************************************************************************

HRESULT CWbemSchemaIDCache::GetDispID (
	LPWSTR* rgszNames, 
	unsigned int cNames, 
	DISPID* rgdispid
)
{
	HRESULT hr = E_FAIL;	

	if (0 < cNames)
	{
		DispIDNameMap::iterator theIterator = m_cache.find (rgszNames [0]);

		if (theIterator != m_cache.end ())
		{
			hr = S_OK;
			rgdispid [0] = (*theIterator).second;
		}
		else
		{
			if ((1 == cNames) && FindPropertyName (rgszNames [0]))
			{
				// Get a new dispid and add it to the cache
				CWbemDispID dispId;
		
				if (dispId.SetAsSchemaID (++m_nextId))
				{
					rgdispid [0] = dispId;
					m_cache.insert (DispIDNameMap::value_type (rgszNames [0], 
											dispId));
					hr = S_OK;
				}
			}
			else
			{
				//If no property name matches, go on to methods
				SAFEARRAY *psaInParams = NULL;	//array of in parameters names
				SAFEARRAY *psaOutParams = NULL; //array of out parameter names
				CComPtr<IWbemClassObject> pInParams;
				CComPtr<IWbemClassObject> pOutParams;
				bool bMethodFound = false;
				long id = 0;
				bool bUnknownParameterFound = false;

				//Get the names of all method parameters (in and out)
				if (GetMethod (rgszNames[0], &psaInParams, &psaOutParams,
											pInParams, pOutParams))
				{	
					bMethodFound = true;
					unsigned long ulParamCount;
					bool ok = true;
		
					//For each named parameter, search for it in the method parameters
					for (ulParamCount=1; ok && (ulParamCount < cNames); ulParamCount++)
					{
						//If we find this name in the "in" parameters list, attach the id and go on
						if (psaInParams && FindMemberInArray(rgszNames[ulParamCount], psaInParams))
						{
							if (GetIdOfMethodParameter(rgszNames[ulParamCount], //param name
														pInParams, 
														&id))
								rgdispid[ulParamCount] = id;
							else
								ok = false;
						}
						//If it's not in the "in" parameters, check the "out" parameters list
						else if (psaOutParams && FindMemberInArray(rgszNames[ulParamCount], psaOutParams))
						{
							if (GetIdOfMethodParameter(rgszNames[ulParamCount], //param name
														pOutParams, 
														&id))
								rgdispid[ulParamCount] = id;
							else 
								ok = false;
						}
						//If it's not there either - we can't find it
						else
						{
							rgdispid[ulParamCount] = DISPID_UNKNOWN;
							bUnknownParameterFound = true;
						}
					} //walk parameters

					if (!ok)
						bMethodFound = false;
				}

				if (psaInParams)
					SafeArrayDestroy(psaInParams);

				if (psaOutParams)
					SafeArrayDestroy(psaOutParams);

				if (!bMethodFound)
					hr = E_FAIL;
				else if (bUnknownParameterFound) 
					hr = DISP_E_UNKNOWNNAME;
				else
					hr = S_OK;

				// Finally, if this all worked add it to the cache as a method
				if (SUCCEEDED(hr))
				{
					CWbemDispID dispId;
					
					if (dispId.SetAsSchemaID (++m_nextId, false))
					{
						rgdispid [0] = dispId;
						m_cache.insert (DispIDNameMap::value_type (rgszNames [0], 
									dispId));
					}
					else
						hr = E_FAIL;
				}
			}
		}
	}

	return hr;
}


//***************************************************************************
//
//  bool CWbemSchemaIDCache::FindPropertyName
//
//  DESCRIPTION:
//
//  Determine whether the property exists for this object and is not 
//	a system property
//
//  PARAMETERS:
//
//		bsName - name of specified property
//
//  RETURN VALUES:
//
//***************************************************************************

bool CWbemSchemaIDCache::FindPropertyName(
	BSTR bsName
)
{
	bool result = false;;

	if (m_pDispatchMgr)
	{
	    //
	    // beware that ->GetObject() DOES NOT Addref, so this one is OK
	    //
		CComPtr<IWbemClassObject> pIWbemClassObject = m_pDispatchMgr->GetObject ();

		if (pIWbemClassObject)
		{
			//Note : This limits the support to non-system properties only !!! 
			LONG lFlavor = 0;

			if (SUCCEEDED(pIWbemClassObject->Get(bsName, 0, NULL, NULL, &lFlavor))
				&& !(WBEM_FLAVOR_ORIGIN_SYSTEM & lFlavor))
				result = true;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemSchemaIDCache::GetMethod
//
//  DESCRIPTION:
//
//  returns the parameter names of a method in two
//				 safearrays - one for in and one for out
//
//  PARAMETERS:
//
//		bstrMethodName - name of method requested
//		ppsaInParams -   pointer to safearray to return
//								  in parameters
//		ppsaOutParams -  pointer to safearray to return
//								  out parameters
//
//  RETURN VALUES:
//
//***************************************************************************

bool CWbemSchemaIDCache::GetMethod(
	BSTR bstrMethodName, 
	SAFEARRAY **ppsaInParams, 
	SAFEARRAY **ppsaOutParams,
	CComPtr<IWbemClassObject> & pInParamsObject,
	CComPtr<IWbemClassObject> & pOutParamsObject
)
{
	bool result = false;
	//
	// Beware, GetClassObejct DOES NOT Addref, so this one is OK
	//
	CComPtr<IWbemClassObject> pIWbemClassObject = m_pDispatchMgr->GetClassObject ();

	if (pIWbemClassObject)
	{
		if (SUCCEEDED(pIWbemClassObject->GetMethod(bstrMethodName, 0, &pInParamsObject, &pOutParamsObject)))
		{
			*ppsaInParams = NULL;
			*ppsaOutParams = NULL;
			bool ok = true;

			if (pInParamsObject)
			{
				if (FAILED(pInParamsObject->GetNames(NULL, 0, NULL, ppsaInParams)))
					ok = false;
			}

			if (ok && pOutParamsObject)
			{
				if (FAILED(pOutParamsObject->GetNames(NULL, 0, NULL, ppsaOutParams)))
					ok = false;
			}

			result = ok;
		}
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemSchemaIDCache::GetIdOfMethodParameter
//
//  DESCRIPTION:
//
//  gets the id of a given parameter for a given method
//	(this is a qualifier on the parameter property in the
//				  InParameters/OutParameters object)
//
//  PARAMETERS:
//
//		bstrParamName	-  parameter name
//		pParams			-  IWbemClassObject containing parameters
//		pId				-  pointer to long to receive the ID for this
//						   parameter of this method
//
//  RETURN VALUES:
//
//***************************************************************************

bool CWbemSchemaIDCache::GetIdOfMethodParameter(
	BSTR bstrParamName, 
	CComPtr<IWbemClassObject> &pParams, 
	long *pId
)
{
	bool result = false;

	if (pParams)
	{
		CComPtr<IWbemQualifierSet> pQualSet;
	
		//Get qualifier set for the required parameter property
		if (SUCCEEDED(pParams->GetPropertyQualifierSet(bstrParamName, &pQualSet)))
		{
			CComVariant vIdVal;
	
			//Get the "id" qualifier value
			if (SUCCEEDED(pQualSet->Get(L"id", 0, &vIdVal, NULL)))
			{
				result = true;
				*pId = vIdVal.lVal;
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemSchemaIDCache::GetName
//
//  DESCRIPTION:
//
//  gets the name of the item given a DISPID
//
//  PARAMETERS:
//
//		dispId			- id whose name we require
//		bsName			- the name (on successful return)
//
//  RETURN VALUES:
//
//***************************************************************************

bool	CWbemSchemaIDCache::GetName (
	DISPID dispId, 
	CComBSTR & bsName
)
{
	bool result = false;

	DispIDNameMap::iterator theIterator = m_cache.begin ();

	while (theIterator != m_cache.end ())
	{
		if (dispId == (*theIterator).second)
		{
			bsName = (*theIterator).first;
			result = true;
			break;
		}
		else
			theIterator++;
	}

	return result;
}

//***************************************************************************
//
//  bool CWbemSchemaIDCache::FindMemberInArray
//
//  DESCRIPTION:
//
//		determine whether a name is present in a SAFEARRAY
//
//  PARAMETERS:
//
//		bstrName			- the name we're looking for
//		psaNames			- SAFEARRAY we're looking in
//
//  RETURN VALUES:
//		true if found, false o/w
//
//***************************************************************************

bool CWbemSchemaIDCache::FindMemberInArray(BSTR bstrName, SAFEARRAY *psaNames)
{
	long lUBound = -1;
	long i;
	
	//Walk the array and check if the requested name exists
	SafeArrayGetUBound(psaNames, 1, &lUBound);

	for (i=0; i <= lUBound; i++)
	{
		CComBSTR bstrMemberName;
		if(SUCCEEDED(SafeArrayGetElement(psaNames, &i, &bstrMemberName)))		// Bug ID 566345
		{
			if (!_wcsicmp(bstrMemberName, bstrName)) //found the property
				break;
		}
		else
		{
			return false;
		}
	}

	return (i <= lUBound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\dispdefs.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  dispdefs.h
//
//  alanbos  22-May-98   Created.
//
//  Definitions for the IDL file
//
//***************************************************************************

#ifndef _DISPDEFS_H_
#define _DISPDEFS_H_


#define WBEMS_DISPID_DERIVATION			0x11
#define WBEMS_DISPID_OBJECT_FILTER		0x1E

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\disphlp.h ===
//***************************************************************************
//
//  cdisphlp.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CDispatchHelper object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _disphlp_H_
#define _disphlp_H_

// This class implements the IDispatch interface using a type library.

class CDispatchHelp
{
private:
	BSTR				m_objectName;
	HRESULT				m_hResult;	// Last HRESULT returned from CIMOM call

protected:
        ITypeInfo      *m_pITINeutral;      //Type information for interface
		ITypeInfo	   *m_pCITINeutral;		//Type information for class
        IDispatch      *m_pObj;
        GUID            m_iGUID;			// Interface GUID
		GUID            m_cGUID;			// Class GUID
		
		/*
		 * May be overriden in subclass to provide bespoke 
		 * handling of exceptions.
		 */
		virtual HRESULT HandleError (
							DISPID dispidMember,
							unsigned short wFlags,
							DISPPARAMS FAR* pdispparams,
							VARIANT FAR* pvarResult,
							UINT FAR* puArgErr,
							HRESULT hRes)
		{
			return hRes;
		}

		/*
		 * May be overriden in subclass to provide
		 * bespoke handling of VT_NULL dispparams.
		 */
		virtual bool HandleNulls (
							DISPID dispidMember,
							unsigned short wFlags)
		{
			// By default treat a VT_NULL as a default
			// value in all methods.
			return 	(wFlags & DISPATCH_METHOD);
		}

public:
        CDispatchHelp();
        virtual ~CDispatchHelp(void);
        void SetObj(IDispatch * pObj, GUID interfaceGuid, 
						GUID classGuid, LPWSTR objectName);
	STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo);

    	STDMETHOD(GetTypeInfo)(
      		THIS_
		UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

	// IDispatchEx methods
        HRESULT STDMETHODCALLTYPE GetDispID( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid);
        
        /* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
		{ 
			UINT uArgErr;
			return Invoke(id, IID_NULL, lcid, wFlags, pdp, pvarRes, pei, &uArgErr); 
		}
        
        HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
            /* [in] */ BSTR bstr,
            /* [in] */ DWORD grfdex)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
            /* [in] */ DISPID id)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetMemberProperties( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetMemberName( 
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetNextDispID( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
		{ return S_FALSE; }

    // IProvideClassInfo methods
		HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI);


	// Other methods
	void RaiseException (HRESULT hr);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\datetime.cpp ===
//***************************************************************************
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  DATETIME.CPP
//
//  alanbos  20-Jan-00   Created.
//
//  Defines the implementation of ISWbemDateTime
//
//***************************************************************************

#include <sys/timeb.h>
#include <math.h>
#include <time.h> 
#include <float.h>
#include "precomp.h"

#ifdef UTILLIB
#include <assertbreak.h>
#else
#define ASSERT_BREAK(a)
#endif //UTILLIB

#define ISWILD(c)		(L'*' == c)
#define ISINTERVAL(c)	(L':' == c)
#define ISMINUS(c)		(L'-' == c)
#define ISPLUS(c)		(L'+' == c)
#define	ISDOT(c)		(L'.' == c)

#define	WILD2			L"**"
#define	WILD3			L"***"
#define	WILD4			L"****"
#define	WILD6			L"******"

static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft);

//***************************************************************************
//
//  CSWbemDateTime::CSWbemDateTime
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemDateTime::CSWbemDateTime() :
		m_dwSafetyOptions (INTERFACESAFE_FOR_UNTRUSTED_DATA|
						   INTERFACESAFE_FOR_UNTRUSTED_CALLER),
		m_bYearSpecified (VARIANT_TRUE),
		m_bMonthSpecified (VARIANT_TRUE),
		m_bDaySpecified (VARIANT_TRUE),
		m_bHoursSpecified (VARIANT_TRUE),
		m_bMinutesSpecified (VARIANT_TRUE),
		m_bSecondsSpecified (VARIANT_TRUE),
		m_bMicrosecondsSpecified (VARIANT_TRUE),
		m_bUTCSpecified (VARIANT_TRUE),
		m_bIsInterval (VARIANT_FALSE),
		m_iYear (0),
		m_iMonth (1),
		m_iDay (1),
		m_iHours (0),
		m_iMinutes (0),
		m_iSeconds (0),
		m_iMicroseconds (0),
		m_iUTC (0),
		m_dw100nsOverflow (0)
{
	InterlockedIncrement(&g_cObj);	
	
	m_Dispatch.SetObj (this, IID_ISWbemDateTime, 
						CLSID_SWbemDateTime, L"SWbemDateTime");
    m_cRef=0;
}

//***************************************************************************
//
//  CSWbemDateTime::~CSWbemDateTime
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemDateTime::~CSWbemDateTime(void)
{
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemDateTime::QueryInterface
// long CSWbemDateTime::AddRef
// long CSWbemDateTime::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemDateTime::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemDateTime==riid)
		*ppv = (ISWbemDateTime *)this;
	else if (IID_IDispatch==riid)
        *ppv= (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemDateTime::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemDateTime::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::get_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		pbsValue		pointer to BSTR to hold value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::get_Value( 
        OUT BSTR *pbsValue) 
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == pbsValue)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		wchar_t	dmtfValue [WBEMDT_DMTF_LEN + 1];
		dmtfValue [WBEMDT_DMTF_LEN] = NULL;

		if (m_bIsInterval)
		{
			// Intervals are easy
			swprintf (dmtfValue, L"%08d%02d%02d%02d.%06d:000", m_iDay, 
						m_iHours, m_iMinutes, m_iSeconds, m_iMicroseconds);
		}
		else
		{
			if (m_bYearSpecified)
				swprintf (dmtfValue, L"%04d", m_iYear);
			else
				wcscpy (dmtfValue, WILD4);

			if (m_bMonthSpecified)
				swprintf (dmtfValue + 4, L"%02d", m_iMonth);
			else
				wcscat (dmtfValue + 4, WILD2);

			if (m_bDaySpecified)
				swprintf (dmtfValue + 6, L"%02d", m_iDay);
			else
				wcscat (dmtfValue + 6, WILD2);

			if (m_bHoursSpecified)
				swprintf (dmtfValue + 8, L"%02d", m_iHours);
			else
				wcscat (dmtfValue + 8, WILD2);

			if (m_bMinutesSpecified)
				swprintf (dmtfValue + 10, L"%02d", m_iMinutes);
			else
				wcscat (dmtfValue + 10, WILD2);

			if (m_bSecondsSpecified)
				swprintf (dmtfValue + 12, L"%02d.", m_iSeconds);
			else
			{
				wcscat (dmtfValue + 12, WILD2);
				wcscat (dmtfValue + 14, L".");
			}

			if (m_bMicrosecondsSpecified)
				swprintf (dmtfValue + 15, L"%06d", m_iMicroseconds);
			else
				wcscat (dmtfValue + 15, WILD6);

			if (m_bUTCSpecified)
				swprintf (dmtfValue + 21, L"%C%03d", (0 <= m_iUTC) ? L'+' : L'-', 
							(0 <= m_iUTC) ? m_iUTC : -m_iUTC);
			else
			{
				wcscat (dmtfValue + 21, L"+");
				wcscat (dmtfValue + 22, WILD3);
			}
		}

		*pbsValue = SysAllocString (dmtfValue);
		hr = WBEM_S_NO_ERROR;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;

}


//***************************************************************************
//
//  SCODE CSWbemDateTime::put_Value
//
//  DESCRIPTION:
//
//  Retrieve the DMTF datetime value
//
//  PARAMETERS:
//
//		bsValue		new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::put_Value( 
        IN BSTR bsValue) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();

	// First check that the value is the right length
	if (bsValue && (WBEMDT_DMTF_LEN == wcslen (bsValue)))
	{
		bool err = false;
		long iYear = 0, iMonth = 1, iDay = 1, iHours = 0, iMinutes = 0, 
		iSeconds = 0, iMicroseconds = 0, iUTC = 0;
		VARIANT_BOOL bYearSpecified = VARIANT_TRUE, 
		bMonthSpecified = VARIANT_TRUE, 
		bDaySpecified = VARIANT_TRUE, 
		bHoursSpecified = VARIANT_TRUE, 
		bMinutesSpecified = VARIANT_TRUE, 
		bSecondsSpecified = VARIANT_TRUE, 
		bMicrosecondsSpecified = VARIANT_TRUE, 
		bUTCSpecified = VARIANT_TRUE, 
		bIsInterval = VARIANT_TRUE;

		LPWSTR pValue = (LPWSTR) bsValue;
		
		// Check whether its an interval
		if (ISINTERVAL(pValue [WBEMDT_DMTF_UPOS]))
		{
			// Check that everything is a digit apart from
			// the interval separator
			for (int i = 0; i < WBEMDT_DMTF_LEN; i++)
			{
				if ((WBEMDT_DMTF_UPOS != i) && 
					(WBEMDT_DMTF_SPOS != i) && !iswdigit (pValue [i]))
				{
					err = true;
					break;
				}
			}

			if (!err)
			{
				// Now check all is within bounds
				err = !(CheckField (pValue, 8, bDaySpecified, iDay, WBEMDT_MAX_DAYINT, WBEMDT_MIN_DAYINT) &&
					(VARIANT_TRUE == bDaySpecified) &&
					CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
					(VARIANT_TRUE == bHoursSpecified) &&
					CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
					(VARIANT_TRUE == bMinutesSpecified) &&
					CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
					(VARIANT_TRUE == bSecondsSpecified) &&
					(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
					CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
					(VARIANT_TRUE == bMicrosecondsSpecified) &&
					CheckUTC (pValue+21, bUTCSpecified, iUTC, false));
				
			}
		}
		else
		{
			// assume it's a datetime
			bIsInterval = VARIANT_FALSE;

			err = !(CheckField (pValue, 4, bYearSpecified, iYear, WBEMDT_MAX_YEAR, WBEMDT_MIN_YEAR) &&
				CheckField (pValue+4, 2, bMonthSpecified, iMonth, WBEMDT_MAX_MONTH, WBEMDT_MIN_MONTH) &&
				CheckField (pValue+6, 2, bDaySpecified, iDay, WBEMDT_MAX_DAY, WBEMDT_MIN_DAY) &&
				CheckField (pValue+8, 2, bHoursSpecified, iHours, WBEMDT_MAX_HOURS, WBEMDT_MIN_HOURS) &&
				CheckField (pValue+10, 2, bMinutesSpecified, iMinutes, WBEMDT_MAX_MINUTES, WBEMDT_MIN_MINUTES) &&
				CheckField (pValue+12, 2, bSecondsSpecified, iSeconds, WBEMDT_MAX_SECONDS, WBEMDT_MIN_SECONDS) &&
				(ISDOT(pValue [WBEMDT_DMTF_SPOS])) &&
				CheckField (pValue+15, 6, bMicrosecondsSpecified, iMicroseconds, WBEMDT_MAX_MICROSEC, WBEMDT_MIN_MICROSEC) &&
				CheckUTC (pValue+21, bUTCSpecified, iUTC));
		}

		if (!err)
		{
			m_iYear = iYear;
			m_iMonth = iMonth;
			m_iDay = iDay;
			m_iHours = iHours;
			m_iMinutes = iMinutes;
			m_iSeconds = iSeconds;
			m_iMicroseconds = iMicroseconds;
			m_iUTC = iUTC;
			m_bYearSpecified = bYearSpecified;
			m_bMonthSpecified = bMonthSpecified;
			m_bDaySpecified = bDaySpecified;
			m_bHoursSpecified = bHoursSpecified;
			m_bMinutesSpecified = bMinutesSpecified;
			m_bSecondsSpecified = bSecondsSpecified;
			m_bMicrosecondsSpecified = bMicrosecondsSpecified;
			m_bUTCSpecified = bUTCSpecified;
			m_bIsInterval = bIsInterval;
			m_dw100nsOverflow = 0;
			hr = S_OK;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::CheckField
//
//  DESCRIPTION:
//
//  Check a string-based datetime field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		len				number of characters in the value
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		maxValue		maximum numeric value allowed for this field
//		minValue		minimum numeric value allowed for this field
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CSWbemDateTime::CheckField (
		LPWSTR			pValue,
		ULONG			len,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		long			maxValue,
		long			minValue
	)
{
	bool status = true;
	bIsSpecified = VARIANT_FALSE;

	for (int i = 0; i < len; i++)
	{
		if (ISWILD(pValue [i]))
		{
			if (VARIANT_TRUE == bIsSpecified)
			{
				status = false;
				break;
			}
		}
		else if (!iswdigit (pValue [i]))
		{
			status = false;
			break;
		}
		else
			bIsSpecified = VARIANT_TRUE;
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [9];
			
			wcsncpy (temp, pValue, len);
			temp [len] = NULL;
			iValue = wcstol (temp, &dummy, 10);
		}
	}
	
	return status;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::CheckUTC
//
//  DESCRIPTION:
//
//  Check a string-based UTC field for correctness
//
//  PARAMETERS:
//
//		pValue			pointer to the value to check
//		bIsSpecified	on return defines whether value is wildcard
//		iValue			on return specifies integer value (if not wildcard)
//		bParseSign		whether first character should be a sign (+/-) or
//						a : (for intervals)
//
//  RETURN VALUES:
//
//		true if value parsed ok, false otherwise
//
//***************************************************************************
bool CSWbemDateTime::CheckUTC (
		LPWSTR			pValue,
		VARIANT_BOOL	&bIsSpecified,
		long			&iValue,
		bool			bParseSign
	)
{
	bool status = true;
	bool lessThanZero = false;
	bIsSpecified = VARIANT_FALSE;

	// Check if we have a signed offset
	if (bParseSign)
	{
		if (ISMINUS(pValue [0]))
			lessThanZero = true;
		else if (!ISPLUS(pValue [0]))
			status = false;
	}
	else
	{
		if (!ISINTERVAL(pValue[0]))
			status = false;
	}

	if (status)
	{
		// Check remaining are digits or wildcars
		for (int i = 1; i < 4; i++)
		{
			if (ISWILD(pValue [i]))
			{
				if (VARIANT_TRUE == bIsSpecified)
				{
					status = false;
					break;
				}
			}
			else if (!iswdigit (pValue [i]))
			{
				status = false;
				break;
			}
			else
				bIsSpecified = VARIANT_TRUE;
		}
	}

	if (status)
	{
		if (VARIANT_TRUE == bIsSpecified)
		{
			wchar_t *dummy = NULL;
			wchar_t temp [4];
			
			wcsncpy (temp, pValue+1, 3);
			temp [3] = NULL;
			iValue = wcstol (temp, &dummy, 10);

			if (lessThanZero)
				iValue = -iValue;
		}
	}
	
	return status;
}


//***************************************************************************
//
//  SCODE CSWbemDateTime::GetVarDate
//
//  DESCRIPTION:
//
//  Retrieve the value in Variant form 
//
//  PARAMETERS:
//
//		bIsLocal		whether to return a local or UTC value
//		pVarDate		holds result on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::GetVarDate( 
        IN VARIANT_BOOL bIsLocal,
		OUT DATE *pVarDate) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();
	
	if (NULL == pVarDate)
		hr = wbemErrInvalidParameter;
	else
	{
		// We cannot perform this operation for interval
		// or wildcarded values
		if ((VARIANT_TRUE == m_bIsInterval) ||
			(VARIANT_FALSE == m_bYearSpecified) ||
			(VARIANT_FALSE == m_bMonthSpecified) ||
			(VARIANT_FALSE == m_bDaySpecified) ||
			(VARIANT_FALSE == m_bHoursSpecified) ||
			(VARIANT_FALSE == m_bMinutesSpecified) ||
			(VARIANT_FALSE == m_bSecondsSpecified) ||
			(VARIANT_FALSE == m_bMicrosecondsSpecified) ||
			(VARIANT_FALSE == m_bUTCSpecified))
		{ 
			hr = wbemErrFailed;
		}
		else
		{	
			SYSTEMTIME sysTime; long offset;
			sysTime.wYear = m_iYear;
			sysTime.wMonth = m_iMonth;
			sysTime.wDay = m_iDay;
			sysTime.wHour = m_iHours;
			sysTime.wMinute = m_iMinutes;
			sysTime.wSecond = m_iSeconds;
			sysTime.wMilliseconds = m_iMicroseconds/1000;
				
			//if the user requested local time, we need to convert
			//we need to do this whether m_iUTC is 0 or not, because the time may be local to a different timezone 
			//than the current one...
			if (VARIANT_TRUE == bIsLocal)
			{
				/* This note used to be here - however it seems to rely on the fact that wbemTime always coerces to GMT,
				   which doesn't seem to be true - it doesn't know whether what it's getting is GMT or local...
				// Need to convert this to a local DATE value
				// This requires that we switch the currently stored
				// time to one for the appropriate timezone, lop off
				// the UTC and set the rest in a variant.
				*/

				//If it's not in GMT, first turn it into GMT
				if (m_iUTC != 0)
				{
					WBEMTime wbemTime(sysTime); long offset = m_iUTC;
					if (!wbemTime.GetDMTF(sysTime, offset)) //non-GMT to GMT using the specified offset
						return wbemErrInvalidSyntax;
				}

				//Now turn it into current local
				WBEMTime currentWbemTime(sysTime);
				if (!currentWbemTime.GetDMTF(sysTime)) //GMT to current local
					return wbemErrInvalidSyntax;

			}
			//or if the user requested GMT and we have non-GMT - need to convert
			else if ((VARIANT_FALSE == bIsLocal) && (m_iUTC != 0))
			{
				long offset = m_iUTC;
				WBEMTime wbemTime(sysTime);
				if (!wbemTime.GetDMTF(sysTime, offset)) //non-GMT to GMT using the specified offset
					return wbemErrInvalidSyntax;
			}

			double dVarDate;

			if (SystemTimeToVariantTime (&sysTime, &dVarDate))
			{
				*pVarDate = dVarDate;
				hr = S_OK;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
    
//***************************************************************************
//
//  SCODE CSWbemDateTime::GetFileTime
//
//  DESCRIPTION:
//
//  Retrieve the value in FILETIME form 
//
//  PARAMETERS:
//
//		bIsLocal		whether to return a local or UTC value
//		pbsFileTime	holds result on successful return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::GetFileTime( 
        IN VARIANT_BOOL bIsLocal,
		OUT BSTR *pbsFileTime) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();
	
	if (NULL == pbsFileTime)
		hr = wbemErrInvalidParameter;
	else
	{
		// We cannot perform this operation for interval
		// or wildcarded values
		if ((VARIANT_TRUE == m_bIsInterval) ||
			(VARIANT_FALSE == m_bYearSpecified) ||
			(VARIANT_FALSE == m_bMonthSpecified) ||
			(VARIANT_FALSE == m_bDaySpecified) ||
			(VARIANT_FALSE == m_bHoursSpecified) ||
			(VARIANT_FALSE == m_bMinutesSpecified) ||
			(VARIANT_FALSE == m_bSecondsSpecified) ||
			(VARIANT_FALSE == m_bMicrosecondsSpecified) ||
			(VARIANT_FALSE == m_bUTCSpecified))
		{ 
			hr = wbemErrFailed;
		}
		else
		{	
			SYSTEMTIME sysTime;
			sysTime.wYear = m_iYear;
			sysTime.wMonth = m_iMonth;
			sysTime.wDay = m_iDay;
			sysTime.wHour = m_iHours;
			sysTime.wMinute = m_iMinutes;
			sysTime.wSecond = m_iSeconds;
			sysTime.wMilliseconds = m_iMicroseconds/1000;
				
			//if the user requested local time, we need to convert
			//we need to do this whether m_iUTC is 0 or not, because the time may be local to a different timezone 
			//than the current one...
			if (VARIANT_TRUE == bIsLocal)
			{
				/* This note used to be here - however it seems to rely on the fact that wbemTime always coerces to GMT,
				   which doesn't seem to be true - it doesn't know whether what it's getting is GMT or local...
				// Need to convert this to a local DATE value
				// This requires that we switch the currently stored
				// time to one for the appropriate timezone, lop off
				// the UTC and set the rest in a variant.
				*/

				//If it's not in GMT, first turn it into GMT
				if (m_iUTC != 0)
				{
					WBEMTime wbemTime(sysTime); long offset = m_iUTC;
					if (!wbemTime.GetDMTF(sysTime, offset)) //non-GMT to GMT using the specified offset
						return wbemErrInvalidSyntax;
				}

				//Now turn it into current local
				WBEMTime currentWbemTime(sysTime);
				if (!currentWbemTime.GetDMTF(sysTime)) //GMT to current local
					return wbemErrInvalidSyntax;

			}
			//or if the user requested GMT and we have non-GMT - need to convert
			else if ((VARIANT_FALSE == bIsLocal) && (m_iUTC != 0))
			{
				long offset = m_iUTC;
				WBEMTime wbemTime(sysTime);
				if (!wbemTime.GetDMTF(sysTime, offset)) //non-GMT to GMT using the specified offset
					return wbemErrInvalidSyntax;
			}

			FILETIME fileTime;

			if (SystemTimeToFileTime (&sysTime, &fileTime))
			{
				wchar_t wcBuf [30];
				unsigned __int64 ui64 = fileTime.dwHighDateTime;
				ui64 = ui64 << 32;
				ui64 += fileTime.dwLowDateTime;

				/*
				 * In converting to SYSTEMTIME we lost sub-millisecond
				 * precision from our DMTF value, so let's add it back,
				 * remembering that FILETIME is in 10ns units.
				 */
				ui64 += ((m_iMicroseconds % 1000) * 10);

				// Finally add the LSB
				ui64 += m_dw100nsOverflow;

				_ui64tow (ui64, wcBuf, 10);

				*pbsFileTime = SysAllocString (wcBuf);
				hr = S_OK;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::SetVarDate
//
//  DESCRIPTION:
//
//  Set the value in Variant form 
//
//  PARAMETERS:
//
//		dVarDate		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::SetVarDate( 
        /*[in]*/ DATE dVarDate,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();

	SYSTEMTIME	sysTime;
	
	if (TRUE == VariantTimeToSystemTime (dVarDate, &sysTime))
	{
		long offset = 0;

		if (VARIANT_TRUE == bIsLocal)
		{
			WBEMTime wbemTime (sysTime);
//			We don't need to convert anything, just to get the offset and store it as local with the offset.
//			if (!wbemTime.GetDMTF (sysTime, offset))
//				return wbemErrInvalidSyntax;
			offset = wbemTime.GetLocalOffsetForDate(&sysTime);
		}

		m_iYear = sysTime.wYear;
		m_iMonth = sysTime.wMonth;
		m_iDay = sysTime.wDay;
		m_iHours = sysTime.wHour;
		m_iMinutes = sysTime.wMinute;
		m_iSeconds = sysTime.wSecond;
		m_iMicroseconds = sysTime.wMilliseconds * 1000;
		m_iUTC = offset;
		m_dw100nsOverflow = 0;

		m_bYearSpecified = VARIANT_TRUE,	
		m_bMonthSpecified = VARIANT_TRUE, 
		m_bDaySpecified = VARIANT_TRUE, 
		m_bHoursSpecified = VARIANT_TRUE, 
		m_bMinutesSpecified = VARIANT_TRUE, 
		m_bSecondsSpecified = VARIANT_TRUE, 
		m_bMicrosecondsSpecified = VARIANT_TRUE, 
		m_bUTCSpecified = VARIANT_TRUE, 
		m_bIsInterval = VARIANT_FALSE;			

		hr = S_OK;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemDateTime::SetFileTime
//
//  DESCRIPTION:
//
//  Set the value from a string representation of a FILETIME
//
//  PARAMETERS:
//
//		bsFileTime		the new value
//		bIsLocal		whether to treat as local or UTC value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_SYNTAX		input value is bad
//
//***************************************************************************
STDMETHODIMP CSWbemDateTime::SetFileTime( 
        /*[in]*/ BSTR bsFileTime,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) 
{
	HRESULT hr = wbemErrInvalidSyntax;

	ResetLastErrors ();

	// Convert string to 64-bit
	unsigned __int64 ri64;
	
	if (ReadUI64(bsFileTime, ri64))
	{
		// Now convert 64-bit to FILETIME
		FILETIME fileTime;
		fileTime.dwHighDateTime = (DWORD)(ri64 >> 32);
		fileTime.dwLowDateTime = (DWORD)(ri64 & 0xFFFFFFFF); 
	
		// Now turn it into a SYSTEMTIME
		SYSTEMTIME	sysTime;
		
		if (TRUE == FileTimeToSystemTime (&fileTime, &sysTime))
		{
			long offset = 0;

			if (VARIANT_TRUE == bIsLocal)
			{
				WBEMTime wbemTime (sysTime);
//				We don't need to convert anything, just to get the offset and store it as local with the offset.
//				if (!wbemTime.GetDMTF (sysTime, offset))
//					return wbemErrInvalidSyntax;
				offset = wbemTime.GetLocalOffsetForDate(&sysTime);
			}

			m_iYear = sysTime.wYear;
			m_iMonth = sysTime.wMonth;
			m_iDay = sysTime.wDay;
			m_iHours = sysTime.wHour;
			m_iMinutes = sysTime.wMinute;
			m_iSeconds = sysTime.wSecond;

			/*
			 * SYSTEMTIME has only 1 millisecond precision. Since
			 * a FILETIME has 100 nanosecond precision and a DMTF
			 * datetime has 1 microsecond, you can see the point
			 * of the following.
			 */
			m_iMicroseconds = sysTime.wMilliseconds * 1000 +
							((ri64 % (10000)) / 10);

			// Record our LSB in case we need it later
			m_dw100nsOverflow = ri64 % 10;

			// The FILETIME hs 1ns precision
			m_iUTC = offset;

			m_bYearSpecified = VARIANT_TRUE,	
			m_bMonthSpecified = VARIANT_TRUE, 
			m_bDaySpecified = VARIANT_TRUE, 
			m_bHoursSpecified = VARIANT_TRUE, 
			m_bMinutesSpecified = VARIANT_TRUE, 
			m_bSecondsSpecified = VARIANT_TRUE, 
			m_bMicrosecondsSpecified = VARIANT_TRUE, 
			m_bUTCSpecified = VARIANT_TRUE, 
			m_bIsInterval = VARIANT_FALSE;			

			hr = S_OK;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

// These are here rather than wbemtime.h so we don't have to doc/support
#define INVALID_TIME_FORMAT 0
#define INVALID_TIME_ARITHMETIC 0
#define BAD_TIMEZONE 0

//***************************************************************************
//
//  FileTimeToui64 
//  ui64ToFileTime
//
//  Description:  Conversion routines for going between FILETIME structures
//  and __int64.
//
//***************************************************************************

static void FileTimeToui64(const FILETIME *pft, ULONGLONG *p64)
{
    *p64 = pft->dwHighDateTime;
    *p64 = *p64 << 32;
    *p64 |=  pft->dwLowDateTime;
}

static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft)
{
    unsigned __int64 uTemp = *p64;
    pft->dwLowDateTime = (DWORD)uTemp;
    uTemp = uTemp >> 32;
    pft->dwHighDateTime = (DWORD)uTemp; 
}

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

// This function is used to convert the relative values that come
// back from GetTimeZoneInformation into an actual date for the year
// in question.  The system time structure that is passed in is updated
// to contain the absolute values.
static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
    
}

// **************************************************************************
// These are static to WBEMTIME, which means they CAN be called from outside
// wbemtime

LONG CSWbemDateTime::WBEMTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}

///////////////////////////////////////////////////////////////////////////
// WBEMTime - This class holds time values. 

//***************************************************************************
//
//  WBEMTime::operator+(const WBEMTimeSpan &uAdd)
//
//  Description:  dummy function for adding two WBEMTime.  It doesnt really
//  make sense to add two date, but this is here for Tomas's template.
//
//  Return: WBEMTime object.
//
//***************************************************************************

CSWbemDateTime::WBEMTime CSWbemDateTime::WBEMTime::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTime ret;

    if (IsOk())
    {
        ret.m_uTime = m_uTime + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::operator=(const SYSTEMTIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 SYSTEMTIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const	CSWbemDateTime::WBEMTime & CSWbemDateTime::WBEMTime::operator=(const SYSTEMTIME & st)
{
    Clear();   // set when properly assigned
	FILETIME t_ft;

    if ( SystemTimeToFileTime(&st, &t_ft) )
	{
		// now assign using a FILETIME.
		*this = t_ft;
	}
    else
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(const FILETIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 FILETIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const CSWbemDateTime::WBEMTime & CSWbemDateTime::WBEMTime::operator=(const FILETIME & ft)
{
	FileTimeToui64(&ft, &m_uTime);
    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator-(const WBEMTime & sub)
//
//  Description:  returns a WBEMTimeSpan object as the difference between 
//  two WBEMTime objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

CSWbemDateTime::WBEMTime CSWbemDateTime::WBEMTime::operator-(const WBEMTimeSpan & sub) const
{
    WBEMTime ret;

    if (IsOk() && (m_uTime >= sub.m_Time))
    {
        ret.m_uTime = m_uTime - sub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

//***************************************************************************
//
//  WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CSWbemDateTime::WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{
	if ((pst == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	FILETIME t_ft;

	if (GetFILETIME(&t_ft))
	{
		if (!FileTimeToSystemTime(&t_ft, pst))
		{
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

    return TRUE;
}

//***************************************************************************
//
//  WBEMTime::GetFILETIME(FILETIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL CSWbemDateTime::WBEMTime::GetFILETIME(FILETIME * pft) const
{
	if ((pft == NULL) || (!IsOk()))
	{
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
		return FALSE;
	}

	ui64ToFileTime(&m_uTime, pft);

    return TRUE;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset)
//
//  Description:  Gets the time in DMTF string local datetime format as a 
//	SYSTEMTIME. If offset is specified as non-zero, it uses the specified offset
//  to calculate UTC. Otherwise if it's 0, it gets the local offset on the machine
//  and uses to calculate.
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CSWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st, long &offset) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
			if (offset == 0)
				offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this - WBEMTimeSpan(offset);
            else
               wt = *this + WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(SYSTEMTIME &st)
//
//  Description:  Gets the time in as local SYSTEMTIME. 
//
//  Return: NULL if not OK.
//
//***************************************************************************


BOOL CSWbemDateTime::WBEMTime::GetDMTF(SYSTEMTIME &st) const
{
    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
	ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
	t_ConversionZone = t_ConversionZone * 10000000L ;

	if ( m_uTime < t_ConversionZone ) 
	{
		if(!GetSYSTEMTIME(&st))
			return FALSE;
	}
	else
	{
		if (GetSYSTEMTIME(&st))
		{
            long offset = GetLocalOffsetForDate(&st);

            WBEMTime wt;
            if (offset >= 0)
               wt = *this + WBEMTimeSpan(offset);
            else
               wt = *this - WBEMTimeSpan(-offset);
            wt.GetSYSTEMTIME(&st);
		}
		else
			return FALSE;
	}

	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\disphlp.cpp ===
//***************************************************************************
//
//  cdisphlp.CPP
//
//  Module: Client side of WBEM marshalling.
//
//  Purpose: Defines dispatch helper object
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  a-davj    6-feb-97   Created.
//
//***************************************************************************


#include "precomp.h"

//***************************************************************************
//  CDispatchHelp::CDispatchHelp()
//  CDispatchHelp::~CDispatchHelp()
//
//  Purpose: constructor and destructor
//
//***************************************************************************

CDispatchHelp::CDispatchHelp()
{
    m_pITINeutral = NULL;      //Type information
	m_pCITINeutral = NULL;
    m_pObj = NULL;
	m_objectName = NULL;
	m_hResult = S_OK;
}

CDispatchHelp::~CDispatchHelp(void)
{
    RELEASEANDNULL(m_pITINeutral)
	RELEASEANDNULL(m_pCITINeutral)

	SysFreeString (m_objectName);
}

void CDispatchHelp::SetObj(IDispatch * pObj, GUID iGuid, 
						   GUID cGuid, LPWSTR objectName)
{
    m_pObj = pObj;
    m_iGUID = iGuid;
	m_cGUID = cGuid;
	m_objectName = SysAllocString (objectName);
}

SCODE CDispatchHelp::GetTypeInfoCount(UINT FAR* pctinfo)
{
    //We implement GetTypeInfo so return 1
    *pctinfo=1;
    return NOERROR;
}

SCODE CDispatchHelp::GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* ppITypeInfo)
{
    HRESULT     hr;
    
    if (0!=itinfo)
        return TYPE_E_ELEMENTNOTFOUND;

    if (NULL==ppITypeInfo)
        return E_POINTER;

    *ppITypeInfo=NULL;
    
    //Load a type lib if we don't have the information already.
    if (NULL==m_pITINeutral)
    {
		ITypeLib   *pITypeLib = NULL;
        hr=LoadRegTypeLib(LIBID_WbemScripting, 1, 0, lcid, &pITypeLib);

        if (FAILED(hr))
			return hr;

        //Got the type lib, get type info for the interface we want
        hr=pITypeLib->GetTypeInfoOfGuid(m_iGUID, &m_pITINeutral);
        pITypeLib->Release();

        if (FAILED(hr))
            return hr;
    }

    /*
     * Note:  the type library is still loaded since we have
     * an ITypeInfo from it.
     */

    m_pITINeutral->AddRef();
    *ppITypeInfo = m_pITINeutral;
    return NOERROR; 
}

SCODE CDispatchHelp::GetClassInfo(
      ITypeInfo FAR* FAR* ppITypeInfo)
{
    HRESULT     hr;
    
    if (NULL==ppITypeInfo)
        return E_POINTER;

    *ppITypeInfo=NULL;
    
    //Load a type lib if we don't have the information already.
    if (NULL==m_pCITINeutral)
    {
		ITypeLib   *pITypeLib = NULL;
        hr=LoadRegTypeLib(LIBID_WbemScripting, 1, 0, 0, &pITypeLib);

        if (FAILED(hr))
			return hr;

        //Got the type lib, get type info for the interface we want
        hr=pITypeLib->GetTypeInfoOfGuid(m_cGUID, &m_pCITINeutral);
        pITypeLib->Release();

        if (FAILED(hr))
            return hr;
    }

    /*
     * Note:  the type library is still loaded since we have
     * an ITypeInfo from it.
     */

    m_pCITINeutral->AddRef();
    *ppITypeInfo = m_pCITINeutral;
    return NOERROR; 
}

SCODE CDispatchHelp::GetIDsOfNames(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid)
{
    HRESULT     hr;
    ITypeInfo  *pTI;

    if (IID_NULL!=riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the right ITypeInfo for lcid.
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        hr=DispGetIDsOfNames(pTI, rgszNames, cNames, rgdispid);
        pTI->Release();
    }

    return hr;
}


void ParseDispArgs (DISPPARAMS FAR * dispparams)
{
	if (dispparams)
	{
		int argCount = dispparams->cArgs;

		for (int i = 0; i < argCount; i++)
		{
			VARIANTARG &v = dispparams->rgvarg [i];
		}

		int nargCount = dispparams->cNamedArgs;
	}
}

SCODE CDispatchHelp::Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr)
{

    HRESULT     hr;
    ITypeInfo  *pTI;
	m_hResult = S_OK;

    if(m_pObj == NULL)
        return WBEM_E_FAILED;

    //riid is supposed to be IID_NULL always
    if (IID_NULL!=riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the ITypeInfo for lcid
    hr=GetTypeInfo(0, lcid, &pTI);

    if (FAILED(hr))
        return hr;

	//ParseDispArgs (pdispparams);

	// Reinterpret inbound VT_NULLs as VT_ERRORs
	if (HandleNulls (dispidMember, wFlags))
		MapNulls (pdispparams);

	hr=pTI->Invoke(m_pObj, dispidMember, wFlags,
              pdispparams, pvarResult,
              pexcepinfo, puArgErr);

	if (FAILED(hr))
	{
		// Try the error handler for this object in case it can handle this
		hr = HandleError (dispidMember, wFlags, pdispparams, pvarResult, puArgErr, hr);
	}

	pTI->Release();
	
	if (FAILED(m_hResult))
	{
		if (NULL != pexcepinfo)
			SetException (pexcepinfo, m_hResult, m_objectName);

		hr = DISP_E_EXCEPTION;
	}

    return hr;
}


void CDispatchHelp::RaiseException (HRESULT hr)
{
	// Store the HRESULT for processing in the Invoke routine
	m_hResult = hr;

	// Set a WMI scripting error on this thread for the client
	ICreateErrorInfo *pCreateErrorInfo = NULL;

	if (SUCCEEDED (CreateErrorInfo (&pCreateErrorInfo)))
	{
		BSTR bsDescr = MapHresultToWmiDescription (hr);
		pCreateErrorInfo->SetDescription (bsDescr);
		SysFreeString (bsDescr);
		pCreateErrorInfo->SetGUID (m_cGUID);
		pCreateErrorInfo->SetSource (m_objectName);

		IErrorInfo *pErrorInfo = NULL;

		if (SUCCEEDED (pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void**) &pErrorInfo)))
		{
			SetErrorInfo (0, pErrorInfo);
			pErrorInfo->Release ();
		}

		pCreateErrorInfo->Release ();
	}
}


// IDispatchEx methods
HRESULT STDMETHODCALLTYPE CDispatchHelp::GetDispID( 
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CDispatchHelp::GetDispID()";)
	_RPrint(me, "Called name:", 0, "");

	return GetIDsOfNames(IID_NULL, &((OLECHAR *)bstrName), 1, ENGLISH_LOCALE, pid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\cwbemdsp.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       cwbemdsp.h
//
//	Description :
//				Defines the CWbemDispatchMgr class, which implements the IDispatch
//				interfaces for Wbem Objects. The implementation is similar to a 
//				standard IDispatch, but there is an additional functionality ("dot notation") that allows
//				users to call into GetIDsOfNames() & Invoke() using an Wbem property name
//				or method name directly (although this is not a property or method of the CWbemObject class).
//
//	Part of :	WBEM automation interface layer
//
//  History:	
//		corinaf			4/3/98		Created
//		alanbos			03/21/00	Revised for Whistler
//
//***************************************************************************

#ifndef _CWBEMDISPMGR_H_
#define _CWBEMDISPMGR_H_

class CSWbemServices;
class CSWbemSecurity;
class CSWbemObject;
class CWbemSchemaIDCache;

//***************************************************************************
//
//  Class :	CWbemDispID
//
//  Description :
//			An encoded Dispatch ID for handling typelib, WMI schema
//			and custom interface DispId's.
//
//***************************************************************************
typedef unsigned long classCookie;

class CWbemDispID
{
private:
	DISPID		m_dispId;

	static unsigned long			s_dispIdCounter;

	// Static constants
	static const unsigned long		s_wmiDispIdTypeMask;
	static const unsigned long		s_wmiDispIdTypeStatic;
	static const unsigned long		s_wmiDispIdTypeSchema;

	static const unsigned long		s_wmiDispIdSchemaTypeMask;
	static const unsigned long		s_wmiDispIdSchemaTypeProperty;
	static const unsigned long		s_wmiDispIdSchemaTypeMethod;

	static const unsigned long		s_wmiDispIdSchemaElementIDMask;

public:
	CWbemDispID (void) : m_dispId (0) {}
	CWbemDispID (DISPID dispId) : m_dispId (dispId) {}
	CWbemDispID (const CWbemDispID & obj) : m_dispId (obj.m_dispId) {}

	virtual ~CWbemDispID (void) {}

	bool SetAsSchemaID (DISPID dispId, bool bIsProperty = true)
	{
		bool result = false;

		if (dispId <= s_wmiDispIdSchemaElementIDMask)
		{
			result = true;
			m_dispId = dispId;

			// Add the bits to identify as static
			m_dispId |= s_wmiDispIdTypeSchema;

			// Add a bit for the property
			if (bIsProperty)
				m_dispId |= s_wmiDispIdSchemaTypeMask;
		}

		return result;
	}

	bool IsStatic () const
	{ 
		return ((DISPID_NEWENUM == m_dispId) ||
				(DISPID_VALUE == m_dispId) ||
			s_wmiDispIdTypeStatic == (s_wmiDispIdTypeMask & m_dispId)); 
	}

	bool IsSchema () const
	{ 
		return (s_wmiDispIdTypeSchema == (s_wmiDispIdTypeMask & m_dispId)); 
	}

	bool IsSchemaProperty () const
	{
		return (s_wmiDispIdSchemaTypeProperty == (s_wmiDispIdSchemaTypeMask & m_dispId));
	}

	bool IsSchemaMethod () const
	{
		return (s_wmiDispIdSchemaTypeMethod == (s_wmiDispIdSchemaTypeMask & m_dispId));
	}

	DISPID GetStaticElementID () const
	{
		return m_dispId;
	}

	DISPID GetSchemaElementID () const
	{
		return m_dispId & s_wmiDispIdSchemaElementIDMask;
	}

	operator DISPID () const
	{
		return m_dispId;
	}

	bool operator < (const CWbemDispID & dispId) const
	{
		return (m_dispId < dispId.m_dispId);
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  BSTRless
//
//  DESCRIPTION:
//
//  Simple utility struct that provides an operator for use in a map based
//	on CComBSTR.  
//
//***************************************************************************

struct BSTRless : std::binary_function<CComBSTR, CComBSTR, bool>
{
	bool operator () (const CComBSTR& _X, const CComBSTR& _Y) const
	{
		bool result = false;

		if (_X.m_str && _Y.m_str)
			result = (_wcsicmp (_X.m_str, _Y.m_str) > 0);
		else 
		{
			// Treat any string as greater than NULL
			if (_X.m_str && !_Y.m_str)
				result = true;
		}

		return result;
	}
};

//***************************************************************************
//
//  CLASS NAME:
//
//  IIDless
//
//  DESCRIPTION:
//
//  Simple utility struct that provides an operator for use in a map based
//	on IID.  
//
//***************************************************************************

struct GUIDless : std::binary_function<GUID, GUID, bool>
{
	bool operator () (const GUID& _X, const GUID& _Y) const
	{
		RPC_STATUS rpcStatus;
		return (UuidCompare ((GUID*)&_X, (GUID*)&_Y, &rpcStatus) > 0);
	}
};

//***************************************************************************
//
//  Class :	CWbemAllocException
//
//  Description :
//			Represents an exception thrown when an allocation fails.
//
//***************************************************************************
class CWbemAllocException
{
};

//***************************************************************************
//
//  FUNCTION NAME:
//
//  _Allocate
//
//  DESCRIPTION:
//
//  Custom allocator used in the STL map classes to throw exception in cases when
//  the allocation fails.
//
//***************************************************************************

template<class _Ty>
	class CWbemAllocator {
public:
	typedef _SIZT size_type;
	typedef _PDFT difference_type;
	typedef _Ty _FARQ *pointer;
	typedef const _Ty _FARQ *const_pointer;
	typedef _Ty _FARQ& reference;
	typedef const _Ty _FARQ& const_reference;
	typedef _Ty value_type;
	pointer address(reference _X) const
		{return (&_X); }
	const_pointer address(const_reference _X) const
		{return (&_X); }
	pointer allocate(size_type _N, const void *)
		{
//			//BUGBUG : This is only to test that we hit all the cases... - should remove eventually !!
//			throw CWbemAllocException();

			_Ty _FARQ *result = 0;

			if (0 == (result = _Allocate((difference_type)_N, (pointer)0)))
				throw CWbemAllocException();

			return result;
		}

	char _FARQ *_Charalloc(size_type _N)
		{
//			//BUGBUG : This is only to test that we hit all the cases... - should remove eventually !!
//			throw CWbemAllocException();

			char _FARQ *result = 0;

			if (0 == (result = _Allocate((difference_type)_N, (char _FARQ *)0)))
				throw CWbemAllocException();

			return result;
		}

	void deallocate(void _FARQ *_P, size_type)
		{operator delete(_P); }
	void construct(pointer _P, const _Ty& _V)
		{_Construct(_P, _V); }
	void destroy(pointer _P)
		{_Destroy(_P); }
	_SIZT max_size() const
		{_SIZT _N = (_SIZT)(-1) / sizeof (_Ty);
		return (0 < _N ? _N : 1); }
	};

// return that all specializations of this allocator are interchangeable
//
// Note: we need these operators bacause they are called by swap friend function
//
template <class T1, class T2>
bool operator== (const CWbemAllocator<T1>&,
	const CWbemAllocator<T2>&){
	return true;
}
template <class T1, class T2>
bool operator!= (const CWbemAllocator<T1>&,
	const CWbemAllocator<T2>&){
	return false;
}

	
//***************************************************************************
//
//  Class :	CWbemDispatchMgr
//
//  Description :
//			Implements IDispatch for Wbem objects
//
//  Public Methods :
//			Constructor, Destructor
//			IDispatch Methods
//			
//	Public Data Members :
//
//***************************************************************************

class CWbemDispatchMgr
{
public:

    CWbemDispatchMgr(CSWbemServices *pWbemServices, 
					 CSWbemObject *pSWbemObject);

    ~CWbemDispatchMgr();

	//Dispatch methods

	STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, 
								 LCID lcid, 
								 ITypeInfo FAR* FAR* pptinfo);

	STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, 
								   OLECHAR FAR* FAR* rgszNames, 
								   UINT cNames,
								   LCID lcid,
								   DISPID FAR* rgdispid);
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember,
							REFIID riid,
							LCID lcid,
							WORD wFlags,
							DISPPARAMS FAR* pdispparams,
							VARIANT FAR* pvarResult,
							EXCEPINFO FAR* pexcepinfo,
							UINT FAR* puArgErr);

	// IDispatchEx methods
	HRESULT STDMETHODCALLTYPE GetDispID( 
		/* [in] */ BSTR bstrName,
		/* [in] */ DWORD grfdex,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	/* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
		/* [in] */ DISPID id,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [in] */ DISPPARAMS __RPC_FAR *pdp,
		/* [out] */ VARIANT __RPC_FAR *pvarRes,
		/* [out] */ EXCEPINFO __RPC_FAR *pei,
		/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
	{ 
		UINT uArgErr;
		return Invoke(id, IID_NULL, lcid, wFlags, pdp, pvarRes, pei, &uArgErr); 
	}
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
		/* [in] */ BSTR bstr,
		/* [in] */ DWORD grfdex)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
		/* [in] */ DISPID id)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE GetMemberProperties( 
		/* [in] */ DISPID id,
		/* [in] */ DWORD grfdexFetch,
		/* [out] */ DWORD __RPC_FAR *pgrfdex)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE GetMemberName( 
		/* [in] */ DISPID id,
		/* [out] */ BSTR __RPC_FAR *pbstrName)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE GetNextDispID( 
		/* [in] */ DWORD grfdex,
		/* [in] */ DISPID id,
		/* [out] */ DISPID __RPC_FAR *pid)
	{ return S_FALSE; }
	
	HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
	{ return S_FALSE; }
    
    // IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo (
		/* [out] */ ITypeInfo **ppTI 
	);

	// Other Methods
	void	RaiseException (HRESULT hr);
	void	SetNewObject (IWbemClassObject *pNewObject);

	IWbemClassObject	*GetObject ()
	{
		return m_pWbemObject;
	}

	IWbemClassObject	*GetClassObject ()
	{
		EnsureClassRetrieved ();
		return m_pWbemClass;
	}

	ISWbemObject		*GetSWbemObject ()
	{
		return (ISWbemObject *)m_pSWbemObject;
	}

private:

	HRESULT				m_hResult;
	
	IWbemClassObject	*m_pWbemObject;			//pointer to represented WBEM object
	CSWbemObject		*m_pSWbemObject;		//pointer to represented Scripting WBEM object 
	CSWbemServices		*m_pWbemServices;		//pointer to WBEM services
	IWbemClassObject	*m_pWbemClass;			//used when m_pWbemObject is an instance, to hold the
												//class definition for browsing method signatures
	ITypeInfo			*m_pTypeInfo;			//caches the type info pointer for the interface
	ITypeInfo			*m_pCTypeInfo;			//caches the type info pointer for the coclass

	CWbemSchemaIDCache	*m_pSchemaCache;		// cache of DISPID-Name bindings for WMI schema

	//Invokes a WBEM property get or put
	HRESULT InvokeWbemProperty(DISPID dispid, unsigned short wFlags, 
								  DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, 
								  EXCEPINFO FAR* pexcepinfo, unsigned int FAR* puArgErr);

	//Invokes a WBEM method
	HRESULT InvokeWbemMethod(DISPID dispid, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult);

	//Helpers for WBEM method out parameter mapping
	HRESULT	MapReturnValue (VARIANT *pDest, VARIANT *pSrc);
	HRESULT	MapOutParameter (VARIANT *pDest, VARIANT *pSrc);
	HRESULT MapOutParameters (DISPPARAMS FAR* pdispparams, IWbemClassObject *pOutParameters,
								IWbemClassObject *pOutParamsInstance, VARIANT FAR* pvarResult);

	// Helpers for WBEM method in parameter mapping
	HRESULT MapInParameters (DISPPARAMS FAR* pdispparams, IWbemClassObject *pInParameters,
								IWbemClassObject **ppInParamsInstance);
	HRESULT MapInParameter (VARIANT FAR* pDest,	VARIANT FAR* pSrc, CIMTYPE lType);


	//Error handling
	HRESULT HandleError (DISPID dispidMember, unsigned short wFlags, DISPPARAMS FAR* pdispparams,
						 VARIANT FAR* pvarResult,UINT FAR* puArgErr,HRESULT hr);

	// Class retrieval
	void	EnsureClassRetrieved ();
};


#endif //_CWBEMDISPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\datetime.h ===
//***************************************************************************
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  datetime.h
//
//  alanbos  20-Jan-00   Created.
//
//  Datetime helper implementation.
//
//***************************************************************************

#ifndef _DATETIME_H_
#define _DATETIME_H_

#define WBEMDT_DMTF_LEN		25
#define WBEMDT_DMTF_SPOS	14
#define WBEMDT_DMTF_UPOS	21

#define	WBEMDT_MIN_YEAR		0
#define	WBEMDT_MAX_YEAR		9999
#define WBEMDT_MIN_MONTH	1
#define WBEMDT_MAX_MONTH	12
#define WBEMDT_MIN_DAY		1
#define WBEMDT_MAX_DAY		31
#define WBEMDT_MIN_DAYINT	0
#define WBEMDT_MAX_DAYINT	99999999
#define	WBEMDT_MIN_HOURS	0
#define	WBEMDT_MAX_HOURS	23
#define	WBEMDT_MIN_MINUTES	0
#define	WBEMDT_MAX_MINUTES	59
#define	WBEMDT_MIN_SECONDS	0
#define	WBEMDT_MAX_SECONDS	59
#define	WBEMDT_MIN_MICROSEC	0
#define	WBEMDT_MAX_MICROSEC	999999
#define	WBEMDT_MIN_UTC		-720
#define	WBEMDT_MAX_UTC		720

#define INVALID_TIME 0xffffffffffffffff

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemDateTime
//
//  DESCRIPTION:
//
//  Implements the ISWbemDateTime interface.  
//
//***************************************************************************

class CSWbemDateTime : public ISWbemDateTime,
						 public IObjectSafety,
						 public ISupportErrorInfo,
						 public IProvideClassInfo
{
private:
	// Private helper class for all the messy business
	class WBEMTime 
	{
		private:
			class WBEMTimeSpan 
			{
				private:

					ULONGLONG m_Time;
					friend class WBEMTime;

				public:

					WBEMTimeSpan ( 
						int iMinutes 
					) 
					{
						m_Time = iMinutes * 60;
						m_Time *= 10000000;
				}
			};

		public:

			WBEMTime ()													{ m_uTime = INVALID_TIME ; }
			WBEMTime ( const SYSTEMTIME &st )							{ *this = st ; }

			const WBEMTime &operator= ( const SYSTEMTIME &st ) ;
			const WBEMTime &operator= ( const FILETIME &ft ) ;

			WBEMTime    operator+ ( const WBEMTimeSpan &ts ) const;
			WBEMTime    operator- ( const WBEMTimeSpan &sub ) const;

			BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
			BOOL GetFILETIME ( FILETIME *pst ) const;

			BOOL GetDMTF ( SYSTEMTIME &st, long &offset ) const;
			BOOL GetDMTF ( SYSTEMTIME &st ) const;

			void Clear ( void )											{ m_uTime = INVALID_TIME ; }

			bool IsOk () const											{ return m_uTime != INVALID_TIME ? true : false; }
			
			static LONG WINAPI GetLocalOffsetForDate(const SYSTEMTIME *pst);

		private:
			ULONGLONG m_uTime;
	};

	CDispatchHelp		m_Dispatch;

	VARIANT_BOOL		m_bYearSpecified;
	VARIANT_BOOL		m_bMonthSpecified;
	VARIANT_BOOL		m_bDaySpecified;
	VARIANT_BOOL		m_bHoursSpecified;
	VARIANT_BOOL		m_bMinutesSpecified;
	VARIANT_BOOL		m_bSecondsSpecified;
	VARIANT_BOOL		m_bMicrosecondsSpecified;
	VARIANT_BOOL		m_bUTCSpecified;
	VARIANT_BOOL		m_bIsInterval;
	
	long				m_iYear;
	long				m_iMonth;
	long				m_iDay;
	long				m_iHours;
	long				m_iMinutes;
	long				m_iSeconds;
	long				m_iMicroseconds;
	long				m_iUTC;

	bool				CheckField (
								LPWSTR			pValue,
								ULONG			len,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								long			maxValue,
								long			minValue
						);

	bool				CheckUTC (
								LPWSTR			pValue,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								bool			bParseSign = true
						);

	DWORD				m_dwSafetyOptions;

	// Records the least significant bit of a filetime
	DWORD				m_dw100nsOverflow;

protected:

	long            m_cRef;         //Object reference count

public:
    
    CSWbemDateTime(void);
    virtual ~CSWbemDateTime(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
    
	// ISWbemDateTime methods

    HRESULT STDMETHODCALLTYPE get_Value( 
        /* [retval][out] */ BSTR __RPC_FAR *value) ;
    
    HRESULT STDMETHODCALLTYPE put_Value( 
        /* [in] */ BSTR __RPC_FAR value) ;

    HRESULT STDMETHODCALLTYPE get_Year( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iYear;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Year( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_YEAR) || (value < WBEMDT_MIN_YEAR))
			hr = wbemErrValueOutOfRange;
		else
			m_iYear = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

    HRESULT STDMETHODCALLTYPE get_Month( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iMonth;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Month( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_MONTH) || (value < WBEMDT_MIN_MONTH))
			hr = wbemErrValueOutOfRange;
		else
			m_iMonth = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		


	HRESULT STDMETHODCALLTYPE get_Day( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iDay;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Day( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if (((VARIANT_TRUE == m_bIsInterval) && ((value > WBEMDT_MAX_DAYINT) || (value < WBEMDT_MIN_DAYINT))) ||
			((VARIANT_FALSE == m_bIsInterval) &&((value > WBEMDT_MAX_DAY) || (value < WBEMDT_MIN_DAY))))
			hr = wbemErrValueOutOfRange;
		else
			m_iDay = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

	HRESULT STDMETHODCALLTYPE get_Hours( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iHours;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Hours( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_HOURS) || (value < WBEMDT_MIN_HOURS))
			hr = wbemErrValueOutOfRange;
		else
			m_iHours = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

		
	HRESULT STDMETHODCALLTYPE get_Minutes( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iMinutes;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Minutes( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_MINUTES) || (value < WBEMDT_MIN_MINUTES))
			hr = wbemErrValueOutOfRange;
		else
			m_iMinutes = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

	HRESULT STDMETHODCALLTYPE get_Seconds( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iSeconds;
		return S_OK;
	}
        
    HRESULT STDMETHODCALLTYPE put_Seconds( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_SECONDS) || (value < WBEMDT_MIN_SECONDS))
			hr = wbemErrValueOutOfRange;
		else
			m_iSeconds = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		


	HRESULT STDMETHODCALLTYPE get_Microseconds( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iMicroseconds;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_Microseconds( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_MICROSEC) || (value < WBEMDT_MIN_MICROSEC))
			hr = wbemErrValueOutOfRange;
		else
			m_iMicroseconds = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		

	HRESULT STDMETHODCALLTYPE get_UTC( 
        /* [retval][out] */ long __RPC_FAR *value) 
	{
		ResetLastErrors ();
		*value = m_iUTC;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_UTC( 
        /* [in] */ long __RPC_FAR value) 
	{
		HRESULT hr = S_OK;
		ResetLastErrors ();

		if ((value > WBEMDT_MAX_UTC) || (value < WBEMDT_MIN_UTC))
			hr = wbemErrValueOutOfRange;
		else
			m_iUTC = value;

		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);

		return hr;
	}		


	HRESULT STDMETHODCALLTYPE get_YearSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bYearSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_YearSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bYearSpecified = value;
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE get_MonthSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bMonthSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_MonthSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bMonthSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_DaySpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bDaySpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_DaySpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bDaySpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_HoursSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bHoursSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_HoursSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bHoursSpecified = value;
		return S_OK;
	}
		
	HRESULT STDMETHODCALLTYPE get_MinutesSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bMinutesSpecified; 
		return S_OK;
	}
        
    HRESULT STDMETHODCALLTYPE put_MinutesSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bMinutesSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_SecondsSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bSecondsSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_SecondsSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bSecondsSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_MicrosecondsSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bMicrosecondsSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_MicrosecondsSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bMicrosecondsSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_UTCSpecified( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bUTCSpecified; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_UTCSpecified( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();
		m_bUTCSpecified = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_IsInterval( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *value) 
	{ 
		ResetLastErrors ();
		*value = m_bIsInterval; 
		return S_OK;
	}
    
    HRESULT STDMETHODCALLTYPE put_IsInterval( 
        /* [in] */ VARIANT_BOOL __RPC_FAR value) 
	{ 
		ResetLastErrors ();

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_FALSE == value))
		{
			if (0 == m_iDay)
				m_iDay = 1;
			else if (WBEMDT_MAX_DAY < m_iDay)
				m_iDay = WBEMDT_MAX_DAY;
		}

		m_bIsInterval = value;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE GetVarDate( 
        /*[in]*/ VARIANT_BOOL bIsLocal,
		/*[out, retval]*/ DATE *dVarDate) ;
    
    HRESULT STDMETHODCALLTYPE SetVarDate( 
        /*[in]*/ DATE dVarDate,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal) ;

	HRESULT STDMETHODCALLTYPE GetFileTime (
		/*[in, optional]*/ VARIANT_BOOL bIsLocal,
		/*[out, retval]*/ BSTR *strFileTime
	);
	
	HRESULT STDMETHODCALLTYPE SetFileTime (
		/*[in]*/ BSTR strFileTime,
		/*[in, optional]*/ VARIANT_BOOL bIsLocal
	);

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		if ((IID_IDispatch != riid) && (IID_ISWbemDateTime != riid))
			return E_NOINTERFACE;

		if (dwOptionSetMask & 
				~(INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACESAFE_FOR_UNTRUSTED_CALLER))
			return E_FAIL;

		m_dwSafetyOptions = (dwEnabledOptions & dwOptionSetMask);

		return S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if ((IID_IDispatch != riid) && (IID_ISWbemDateTime != riid))
			return E_NOINTERFACE;

		if (pdwSupportedOptions) *pdwSupportedOptions = 
				(INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACESAFE_FOR_UNTRUSTED_CALLER);
		if (pdwEnabledOptions) *pdwEnabledOptions = m_dwSafetyOptions;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_ISWbemDateTime == riid) ? S_OK : S_FALSE;
	}

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

#endif // _DATETIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\enumobj.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ENUMOBJ.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemObjectSet::CSWbemObjectSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemObjectSet::CSWbemObjectSet(CSWbemServices *pService, 
								 IEnumWbemClassObject *pIEnumWbemClassObject,
								 CSWbemSecurity *pSecurity)
				: m_SecurityInfo (NULL),
				  m_bIsEmpty (false)
{
	m_Dispatch.SetObj (this, IID_ISWbemObjectSet, 
						CLSID_SWbemObjectSet, L"SWbemObjectSet");
    m_cRef=0;
	m_firstEnumerator = true;
	m_pSWbemServices = pService;

	if (m_pSWbemServices)
	{
		m_pSWbemServices->AddRef ();

		if (pSecurity)
			m_SecurityInfo = new CSWbemSecurity (pIEnumWbemClassObject, pSecurity);
		else
		{
			pSecurity = m_pSWbemServices->GetSecurityInfo ();
			m_SecurityInfo = new CSWbemSecurity (pIEnumWbemClassObject, pSecurity);

			if (pSecurity)
				pSecurity->Release ();
		}
	}

	InterlockedIncrement(&g_cObj);
}

CSWbemObjectSet::CSWbemObjectSet (void)
				: m_SecurityInfo (NULL),
				  m_cRef (0),
				  m_firstEnumerator (true),
				  m_bIsEmpty (true),
				  m_pSWbemServices (NULL)
{
	m_Dispatch.SetObj (this, IID_ISWbemObjectSet, 
						CLSID_SWbemObjectSet, L"SWbemObjectSet");
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemObjectSet::~CSWbemObjectSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemObjectSet::~CSWbemObjectSet(void)
{
    InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_pSWbemServices)
	RELEASEANDNULL(m_SecurityInfo)
}

//***************************************************************************
// HRESULT CSWbemObjectSet::QueryInterface
// long CSWbemObjectSet::AddRef
// long CSWbemObjectSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemObjectSet==riid)
		*ppv = (ISWbemObjectSet *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemObjectSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemObjectSet::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemObjectSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemObjectSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemObjectSet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Reset ()
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

		if (pIEnumWbemClassObject)
		{
			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIEnumWbemClassObject->Reset ();

			pIEnumWbemClassObject->Release ();

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Next (
	long lTimeout, 
	ISWbemObject **ppObject
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppObject)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

		if (pIEnumWbemClassObject)
		{
			*ppObject = NULL;

			IWbemClassObject *pIWbemClassObject = NULL;
			ULONG returned = 0;

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIEnumWbemClassObject->Next (lTimeout, 1, &pIWbemClassObject, &returned);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (SUCCEEDED(hr) && (0 < returned) && pIWbemClassObject)
			{
				CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pIWbemClassObject,
															m_SecurityInfo);

				if (!pObject)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject, 
										(PPVOID) ppObject)))
					delete pObject;

				pIWbemClassObject->Release ();
			}
			else if (WBEM_S_TIMEDOUT == hr)
			{
				/*
				 * Since a timeout would be indistinguishable from an end-of-enumeration
				 * we flag it as a real error rather than an S-CODE.
				 */
				
				hr = wbemErrTimedout;
			}

			SetWbemError (m_pSWbemServices);
			pIEnumWbemClassObject->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Clone (
	ISWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_SecurityInfo)
	{
		IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

		if (pIEnumWbemClassObject)
		{
			*ppEnum = NULL;
			IEnumWbemClassObject *pIWbemEnum = NULL;

			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIEnumWbemClassObject->Clone (&pIWbemEnum);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			if (WBEM_S_NO_ERROR == hr)
			{
				CSWbemObjectSet *pEnum = new CSWbemObjectSet (m_pSWbemServices, pIWbemEnum,
																m_SecurityInfo);

				if (!pEnum)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnum->QueryInterface (IID_ISWbemObjectSet, (PPVOID) ppEnum)))
					delete pEnum;

				pIWbemEnum->Release ();
			}
			
			SetWbemError (m_pSWbemServices);
			pIEnumWbemClassObject->Release ();
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::Skip
//
//  DESCRIPTION:
//
//  Skip over some objects in the enumeration
//
//  PARAMETERS:
//
//		lElements	Number of elements to skip
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Skip (
	ULONG lElements,
	long lTimeout
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_SecurityInfo)
	{
		IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

		if (pIEnumWbemClassObject)
		{
			bool needToResetSecurity = false;
			HANDLE hThreadToken = NULL;
			
			if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				hr = pIEnumWbemClassObject->Skip (lTimeout, lElements);

			if (needToResetSecurity)
				m_SecurityInfo->ResetSecurity (hThreadToken);

			/*
			 * Since a timeout would be indistinguishable from an end-of-enumeration
			 * we flag it as a real error rather than an S-CODE.
			 */
			if (WBEM_S_TIMEDOUT == hr)
				hr = wbemErrTimedout;

			SetWbemError (m_pSWbemServices);
			pIEnumWbemClassObject->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
//***************************************************************************
//
//  SCODE CSWbemObjectSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumVar	*pEnumVar = NULL;

		if (m_bIsEmpty)
		{
			if (!(pEnumVar = new CEnumVar ()))
				hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
		{
			/*
			 * If this is the first enumerator, use ourselves as the underlying
			 * iterator.  Otherwise clone a copy and use that.
			 */

			if (m_firstEnumerator)
			{
				if (!(pEnumVar = new CEnumVar (this)))
					hr = WBEM_E_OUT_OF_MEMORY;
				else
					m_firstEnumerator = false;
			}
			else
			{
				CSWbemObjectSet *pNewEnum = NULL;

				/*
				 * Try to reset the cloned enumerator.  This may not always
				 * succeed, as some IEnumWbemClassObject's may not be
				 * rewindable.
				 */
				if (SUCCEEDED (CloneObjectSet (&pNewEnum)))
				{
					HRESULT hr2 = pNewEnum->Reset ();
	
					if (!(pEnumVar = new CEnumVar (pNewEnum)))
						hr = WBEM_E_OUT_OF_MEMORY;
	
					pNewEnum->Release ();
				}
			}
		}

		if (pEnumVar)
			if (FAILED(hr = pEnumVar->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
				delete pEnumVar;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = 0;

		if (m_bIsEmpty)
			hr = WBEM_S_NO_ERROR;
		else if (m_SecurityInfo)
		{
			IEnumWbemClassObject *pIEnumWbemClassObject = 
							(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

			if (pIEnumWbemClassObject)
			{
				/* 
				 * Work out the current count - clone the object to avoid messing
				 * with the iterator.
				 */

				IEnumWbemClassObject *pNewEnum = NULL;

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
			
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
				{
					if (WBEM_S_NO_ERROR == pIEnumWbemClassObject->Clone (&pNewEnum))
					{
						// Secure the enumerator
						m_SecurityInfo->SecureInterface (pNewEnum);

						/*
						 * This will fail if the enumerator was created with the
						 * WBEM_FLAG_FORWARD_ONLY option.
						 */

						if (WBEM_S_NO_ERROR == pNewEnum->Reset ())
						{
							IWbemClassObject *pObject = NULL;
							ULONG lReturned = 0;
							HRESULT hrEnum;
						
							// Iterate through the enumerator to count the elements
							while (SUCCEEDED(hrEnum = pNewEnum->Next (INFINITE, 1, &pObject, &lReturned)))
							{
								if (0 == lReturned)
									break;			// We are done

								// Getting here means we have at least one object returned
								(*plCount) ++;
								pObject->Release ();
							}

							if (SUCCEEDED(hrEnum))
								hr = S_OK;
							else
								hr = hrEnum;
						}

						pNewEnum->Release ();
					}
				}

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				pIEnumWbemClassObject->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemObjectSet::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by path.  
//
//  PARAMETERS:
//
//		bsObjectPath	The path of the object to retrieve
//		lFlags			Flags
//		ppNamedObject	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::Item (
	BSTR bsObjectPath,
	long lFlags,
    ISWbemObject **ppObject
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if ((NULL == ppObject) || (NULL == bsObjectPath))
		hr = WBEM_E_INVALID_PARAMETER;
	else if (!m_bIsEmpty)
	{
		CWbemPathCracker objectPath;

		if (objectPath = bsObjectPath)
		{
			if (m_SecurityInfo)
			{
				IEnumWbemClassObject *pIEnumWbemClassObject = 
									(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

				if (pIEnumWbemClassObject)
				{
					/* 
					 * Try to find the object - clone the object to avoid messing
					 * with the iterator.
					 */
					IEnumWbemClassObject *pNewEnum = NULL;

					bool needToResetSecurity = false;
					HANDLE hThreadToken = NULL;
			
					if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					{
						if (WBEM_S_NO_ERROR == pIEnumWbemClassObject->Clone (&pNewEnum))
						{
							// Secure the enumerator
							m_SecurityInfo->SecureInterface (pNewEnum);

							/*
							 * This will fail if the enumerator was created with the
							 * WBEM_FLAG_FORWARD_ONLY option.
							 */

							if (WBEM_S_NO_ERROR == pNewEnum->Reset ())
							{
								CComPtr<IWbemClassObject> pIWbemClassObject;
								ULONG lReturned = 0;
								bool found = false;
								hr = WBEM_E_NOT_FOUND;
								
								// Iterate through the enumerator to try to find the element with the
								// specified path.
								while (!found && 
										(WBEM_S_NO_ERROR == pNewEnum->Next (INFINITE, 1, &pIWbemClassObject, &lReturned)))
								{
									// Getting here means we have at least one object returned; check the
									// path

									if (CSWbemObjectPath::CompareObjectPaths (pIWbemClassObject, objectPath))
									{
										// Found it - assign to passed interface and break out
										found = true;
										CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, 
														pIWbemClassObject, m_SecurityInfo);

										if (!pObject)
											hr = WBEM_E_OUT_OF_MEMORY;
										else if (FAILED(pObject->QueryInterface (IID_ISWbemObject, 
												(PPVOID) ppObject)))
										{
											hr = WBEM_E_FAILED;
											delete pObject;
										}
									}

                                    pIWbemClassObject.Release();

								}

								if (found)
									hr = S_OK;
							}
							
							pNewEnum->Release ();
						}
					}

					// Restore original privileges on this thread
					if (needToResetSecurity)
						m_SecurityInfo->ResetSecurity (hThreadToken);

					pIEnumWbemClassObject->Release ();
				}
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	else		// Bug ID 566345
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			*ppSecurity = m_SecurityInfo;
			(*ppSecurity)->AddRef ();
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemObjectSet::CloneObjectSet
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration, returning a coclass not an interface
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemObjectSet::CloneObjectSet (
	CSWbemObjectSet **ppEnum
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppEnum)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppEnum = NULL;

		if (m_SecurityInfo)
		{
			IEnumWbemClassObject *pIEnumWbemClassObject = 
								(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

			if (pIEnumWbemClassObject)
			{
				IEnumWbemClassObject *pIWbemEnum = NULL;

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
			
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIEnumWbemClassObject->Clone (&pIWbemEnum);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);
				
				if (WBEM_S_NO_ERROR == hr)
				{
					*ppEnum = new CSWbemObjectSet (m_pSWbemServices, pIWbemEnum,
																	m_SecurityInfo);

					if (!(*ppEnum))
						hr = WBEM_E_OUT_OF_MEMORY;
					else
						(*ppEnum)->AddRef ();

					pIWbemEnum->Release ();
				}

				SetWbemError (m_pSWbemServices);

				pIEnumWbemClassObject->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\enumpriv.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ENUMOBJ.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemPrivilegeSet::CSWbemPrivilegeSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemPrivilegeSet::CSWbemPrivilegeSet()
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilegeSet, 
						CLSID_SWbemPrivilegeSet, L"SWbemPrivilegeSet");
    m_cRef=1;
	m_bMutable = true;
	InterlockedIncrement(&g_cObj);
}

CSWbemPrivilegeSet::CSWbemPrivilegeSet(
	const CSWbemPrivilegeSet &privSet,
	bool bMutable
)
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilegeSet, 
						CLSID_SWbemPrivilegeSet, L"SWbemPrivilegeSet");
    m_cRef=1;
	m_bMutable = bMutable;

	// Copy the contents of the supplied Privilege set to this set
	PrivilegeMap::const_iterator next = privSet.m_PrivilegeMap.begin ();

	while (next != privSet.m_PrivilegeMap.end ())
	{
		WbemPrivilegeEnum iPrivilege = (*next).first;
		CSWbemPrivilege *pPrivilege = (*next).second;
		pPrivilege->AddRef ();

		m_PrivilegeMap.insert 
			(PrivilegeMap::value_type(iPrivilege, pPrivilege));

		next++;
	}

	InterlockedIncrement(&g_cObj);
}

CSWbemPrivilegeSet::CSWbemPrivilegeSet(
	ISWbemPrivilegeSet *pPrivilegeSet
)
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilegeSet, 
						CLSID_SWbemPrivilegeSet, L"SWbemPrivilegeSet");
    m_cRef=1;
	m_bMutable = true;

	// Copy the contents of the supplied Privilege set to this set
	if (pPrivilegeSet)
	{
		IUnknown *pUnk = NULL;

		if (SUCCEEDED(pPrivilegeSet->get__NewEnum (&pUnk)))
		{
			IEnumVARIANT	*pNewEnum = NULL;

			if (SUCCEEDED(pUnk->QueryInterface(IID_IEnumVARIANT, (void**) &pNewEnum)))
			{
				VARIANT var;
				VariantInit (&var);
				ULONG lFetched = 0;

				while (S_OK == pNewEnum->Next(1, &var, &lFetched))
				{
					if (VT_DISPATCH == V_VT(&var))
					{
						ISWbemPrivilege *pISWbemPrivilege = NULL;

						if (SUCCEEDED((var.pdispVal)->QueryInterface (IID_ISWbemPrivilege, 
										(void**) &pISWbemPrivilege)))
						{
							WbemPrivilegeEnum iPrivilege;
							VARIANT_BOOL	bIsEnabled;
							ISWbemPrivilege *pDummy = NULL;

							pISWbemPrivilege->get_Identifier (&iPrivilege);
							pISWbemPrivilege->get_IsEnabled (&bIsEnabled);

							if (SUCCEEDED (Add (iPrivilege, bIsEnabled, &pDummy)))
								pDummy->Release ();
							
							pISWbemPrivilege->Release ();
						}
					}

					VariantClear (&var);
				}

				VariantClear (&var);
				pNewEnum->Release ();
			}

			pUnk->Release ();
		}
	}
	InterlockedIncrement(&g_cObj);
}


//***************************************************************************
//
//  CSWbemPrivilegeSet::~CSWbemPrivilegeSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemPrivilegeSet::~CSWbemPrivilegeSet(void)
{
	PrivilegeMap::iterator next; 
	
	while ((next = m_PrivilegeMap.begin ()) != m_PrivilegeMap.end ())
	{
		CSWbemPrivilege *pPrivilege = (*next).second;
		next = m_PrivilegeMap.erase (next);
		pPrivilege->Release ();
	}

	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemPrivilegeSet::QueryInterface
// long CSWbemPrivilegeSet::AddRef
// long CSWbemPrivilegeSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilegeSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemPrivilegeSet==riid)
		*ppv = (ISWbemPrivilegeSet *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemPrivilegeSet::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemPrivilegeSet::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemPrivilegeSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilegeSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemPrivilegeSet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumPrivilegeSet *pEnum = new CEnumPrivilegeSet (this);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = m_PrivilegeMap.size ();
		hr = S_OK;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by path.  
//
//  PARAMETERS:
//
//		bsObjectPath	The path of the object to retrieve
//		lFlags			Flags
//		ppNamedObject	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::Item (
	WbemPrivilegeEnum iPrivilege,
    ISWbemPrivilege **ppPrivilege
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	ResetLastErrors ();

	if (NULL == ppPrivilege)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppPrivilege = NULL;
		PrivilegeMap::iterator theIterator;
		theIterator = m_PrivilegeMap.find (iPrivilege);

		if (theIterator != m_PrivilegeMap.end ())
		{
			CSWbemPrivilege *pPrivilege = (*theIterator).second;

			if (SUCCEEDED(pPrivilege->QueryInterface 
					(IID_ISWbemPrivilege, (PPVOID) ppPrivilege)))
			{
				hr = WBEM_S_NO_ERROR;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::DeleteAll
//
//  DESCRIPTION:
//
//  Remove all items in the collection 
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::DeleteAll ()
{
	HRESULT hr = S_OK;

	ResetLastErrors ();

	if (m_bMutable)
	{
		PrivilegeMap::iterator next; 
		
		while ((next = m_PrivilegeMap.begin ()) != m_PrivilegeMap.end ())
		{
			CSWbemPrivilege *pPrivilege = (*next).second;
			next = m_PrivilegeMap.erase (next);
			pPrivilege->Release ();
		}
	}
	else
		hr = WBEM_E_READ_ONLY;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Remove
//
//  DESCRIPTION:
//
//  Remove the named item in the collection
//
//	PARAMETERS
//		bsName			Name of item to remove
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::Remove (
	WbemPrivilegeEnum	iPrivilege
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	ResetLastErrors ();

	if (m_bMutable)
	{
		PrivilegeMap::iterator theIterator = m_PrivilegeMap.find (iPrivilege);

		if (theIterator != m_PrivilegeMap.end ())
		{
			// Found it - release and remove

			CSWbemPrivilege *pPrivilege = (*theIterator).second;
			m_PrivilegeMap.erase (theIterator);
			pPrivilege->Release ();
			hr = S_OK;
		}
	}
	else
		hr = WBEM_E_READ_ONLY;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Add
//
//  DESCRIPTION:
//
//  Add a new item to the collection
//
//  RETURN VALUES:
//
//  S_OK				success
//	wbemErrInvalidParameter		privilege name not recognized by OS
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::Add (
	WbemPrivilegeEnum iPrivilege,
	VARIANT_BOOL bIsEnabled,
	ISWbemPrivilege **ppPrivilege
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL == ppPrivilege)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_bMutable)
	{
		CSWbemPrivilege *pPrivilege = NULL;

		PrivilegeMap::iterator theIterator = m_PrivilegeMap.find (iPrivilege);

		if (theIterator != m_PrivilegeMap.end ())
		{
			// Already there, so modify setting
			pPrivilege = (*theIterator).second;
			if (SUCCEEDED(hr = pPrivilege->QueryInterface (IID_ISWbemPrivilege, 
																	(PPVOID) ppPrivilege)))
			{
				pPrivilege->put_IsEnabled (bIsEnabled);
			}
		}
		else
		{
			/*
			 * Potential new element - first check it's 
			 * a valid Privilege name by getting it's LUID.
			 */
			LUID luid;
			TCHAR *tName = CSWbemPrivilege::GetNameFromId (iPrivilege);

			if (tName && CSWbemSecurity::LookupPrivilegeValue(tName, &luid))
			{
				// Super. Now add it to the map (note that constructor AddRef's)
				pPrivilege = new CSWbemPrivilege (iPrivilege, luid, 
					(bIsEnabled) ? true : false);

				if (!pPrivilege)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (SUCCEEDED(hr = pPrivilege->QueryInterface (IID_ISWbemPrivilege, 
																		(PPVOID)ppPrivilege)))
				{
					m_PrivilegeMap.insert 
						(PrivilegeMap::value_type(iPrivilege, pPrivilege));
				}
				else
				{
					delete pPrivilege;
				}
			}
			else
			{
				DWORD dwLastError = GetLastError ();
				hr = wbemErrInvalidParameter;
			}
		}
	}
	else
		hr = WBEM_E_READ_ONLY;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::AddAsString
//
//  DESCRIPTION:
//
//  Add a new item to the collection; the privilege is specified by
//	an NT privilege string rather than a WbemPrivilegeEnum id.
//
//  RETURN VALUES:
//
//  S_OK				success
//	wbemErrInvalidParameter		privilege name not recognized by OS
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::AddAsString (
	BSTR bsPrivilege,
	VARIANT_BOOL bIsEnabled,
	ISWbemPrivilege **ppPrivilege
)
{
	HRESULT hr = wbemErrInvalidParameter;

	ResetLastErrors ();

	// Map the string into a Privilege id
	WbemPrivilegeEnum	iPrivilege;

	if (CSWbemPrivilege::GetIdFromName (bsPrivilege, iPrivilege))
		hr = Add (iPrivilege, bIsEnabled, ppPrivilege);
	else
	{
		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::GetNumberOfDisabledElements
//
//  DESCRIPTION:
//
//  Add a new item to the collection
//
//  RETURN VALUES:
//
//  S_OK				success
//	wbemErrInvalidParameter		privilege name not recognized by OS
//  E_FAIL				otherwise
//
//***************************************************************************

ULONG CSWbemPrivilegeSet::GetNumberOfDisabledElements ()
{
	ULONG lNum = 0;

	PrivilegeMap::iterator next = m_PrivilegeMap.begin ();

	while (next != m_PrivilegeMap.end ())
	{
		CSWbemPrivilege *pPrivilege = (*next).second;
		VARIANT_BOOL bValue;

		if (SUCCEEDED(pPrivilege->get_IsEnabled (&bValue)) && (VARIANT_FALSE == bValue))
			lNum++;
	
		next++;
	}

	return lNum;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Reset
//
//  DESCRIPTION:
//
//  Remove all items from the set and reinstantiate with 
//	a copy of the items in the input privilege set
//
//***************************************************************************

void CSWbemPrivilegeSet::Reset (CSWbemPrivilegeSet &privSet)
{
	DeleteAll ();

	PrivilegeMap::iterator next = privSet.m_PrivilegeMap.begin ();

	while (next != privSet.m_PrivilegeMap.end ())
	{
		VARIANT_BOOL bIsEnabled;
		CSWbemPrivilege *pPrivilege = (*next).second;
		pPrivilege->get_IsEnabled (&bIsEnabled);

		ISWbemPrivilege *pDummy = NULL;

		if (SUCCEEDED (Add ((*next).first, bIsEnabled, &pDummy)))
			pDummy->Release ();

		next++;
	}
}


// CEnumPrivilegeSet Methods

//***************************************************************************
//
//  CEnumPrivilegeSet::CEnumPrivilegeSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumPrivilegeSet::CEnumPrivilegeSet(CSWbemPrivilegeSet *pPrivilegeSet)
{
	m_cRef=0;
	m_pPrivilegeSet = pPrivilegeSet;

	if (m_pPrivilegeSet)
	{
		m_pPrivilegeSet->AddRef ();
		m_Iterator = m_pPrivilegeSet->m_PrivilegeMap.begin ();
	}

	InterlockedIncrement(&g_cObj);
}

CEnumPrivilegeSet::CEnumPrivilegeSet(CSWbemPrivilegeSet *pPrivilegeSet,
							 PrivilegeMap::iterator iterator) :
		m_Iterator (iterator)
{
	m_cRef=0;
	m_pPrivilegeSet = pPrivilegeSet;

	if (m_pPrivilegeSet)
	{
		m_pPrivilegeSet->AddRef ();
	}
	
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumPrivilegeSet::~CEnumPrivilegeSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumPrivilegeSet::~CEnumPrivilegeSet(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pPrivilegeSet)
		m_pPrivilegeSet->Release ();
}

//***************************************************************************
// HRESULT CEnumPrivilegeSet::QueryInterface
// long CEnumPrivilegeSet::AddRef
// long CEnumPrivilegeSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumPrivilegeSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumPrivilegeSet::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CEnumPrivilegeSet::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Reset ()
{
	HRESULT hr = S_FALSE;

	if (m_pPrivilegeSet)
	{
		m_Iterator = m_pPrivilegeSet->m_PrivilegeMap.begin ();
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if ((NULL != pVar) && (m_pPrivilegeSet))
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pPrivilegeSet->m_PrivilegeMap.end ())
			{
				CSWbemPrivilege *pSWbemPrivilege = (*m_Iterator).second;
				m_Iterator++;

				ISWbemPrivilege *pISWbemPrivilege = NULL;

				if (SUCCEEDED(pSWbemPrivilege->QueryInterface 
						(IID_ISWbemPrivilege, (PPVOID) &pISWbemPrivilege)))
				{
					// Set the object into the variant array; note that pObject
					// has been addref'd as a result of the QI() call above
					pVar[l2].vt = VT_DISPATCH;
					pVar[l2].pdispVal = pISWbemPrivilege;
				}
			}
			else
				break;
		}
		if (NULL != pcElementFetched)
			*pcElementFetched = l2;
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pPrivilegeSet)
		{
			CEnumPrivilegeSet *pEnum = new CEnumPrivilegeSet (m_pPrivilegeSet, m_Iterator);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Skip
//
//  DESCRIPTION:
//
//  Skip specified number of elements
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_pPrivilegeSet)
	{
		ULONG l2;

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pPrivilegeSet->m_PrivilegeMap.end ())
				m_Iterator++;
			else
				break;
		}

		if (l2 == cElements)
			hr = S_OK;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\error.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  error.h
//
//  alanbos  29-Jun-98   Created.
//
//  Error record handling object
//
//***************************************************************************

#ifndef _ERROR_H_
#define _ERROR_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemErrorCache
//
//  DESCRIPTION:
//
//  Holds WBEM-style "last errors" on threads
//
//***************************************************************************

class CWbemErrorCache 
{
private:

	CRITICAL_SECTION		m_cs;

	typedef struct ThreadError
	{
		ThreadError			*pNext;
		ThreadError			*pPrev;
		DWORD				dwThreadId;	
		COAUTHIDENTITY		*pCoAuthIdentity;
		BSTR				strAuthority;
		BSTR				strPrincipal;
		BSTR				strNamespacePath;
		IWbemServices		*pService;
		IWbemClassObject	*pErrorObject;
	} ThreadError;


	ThreadError				*headPtr;
		
public:

    CWbemErrorCache ();
    virtual ~CWbemErrorCache ();
    
	CSWbemObject	*GetAndResetCurrentThreadError ();
	void			SetCurrentThreadError (CSWbemServices *pService);
	void			ResetCurrentThreadError ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\enumvar.h ===
//***************************************************************************
//
//  enumvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CEnumVariant object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _ENUMVAR_H_
#define _ENUMVAR_H_

// This class implements the IEnumVARIANT interface

class CEnumVar : public IEnumVARIANT
{
private:
	long				m_cRef;
	CSWbemObjectSet	*m_pEnumObject;

public:
	CEnumVar (CSWbemObjectSet *pEnumObject);
	CEnumVar (void);		// Empty enumerator
	virtual ~CEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\events.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  events.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemEventSource definition
//
//***************************************************************************

#ifndef _EVENTS_H_
#define _EVENTS_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemEventSource
//
//  DESCRIPTION:
//
//  Implements the ISWbemEventSource interface.  
//
//***************************************************************************

class CSWbemEventSource : public ISWbemEventSource,
						  public ISupportErrorInfo,
						  public IProvideClassInfo
{
private:
	CSWbemServices			*m_pSWbemServices;
	CDispatchHelp			m_Dispatch;
	CSWbemSecurity			*m_SecurityInfo;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemEventSource (CSWbemServices *pService, IEnumWbemClassObject *pEnum);
    ~CSWbemEventSource (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemEventSource methods

	HRESULT STDMETHODCALLTYPE NextEvent 
	(
		/* [in]  */ long iTimeout,
		/* [out] */ ISWbemObject **objEvent
	);

	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\enumvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ENUMVAR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of IEnumVARIANT
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CEnumVar::CEnumVar
//
//  DESCRIPTION:
//
//  Constructors.
//
//***************************************************************************

CEnumVar::CEnumVar(CSWbemObjectSet *pObject)
{
	m_cRef=0;
	m_pEnumObject = pObject;
	m_pEnumObject->AddRef ();
	InterlockedIncrement(&g_cObj);
}

CEnumVar::CEnumVar(void)
{
	m_cRef=0;
	m_pEnumObject = NULL;
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumVar::~CEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumVar::~CEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_pEnumObject)
}

//***************************************************************************
// HRESULT CEnumVar::QueryInterface
// long CEnumVar::AddRef
// long CEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumVar::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CEnumVar::Reset ()
{
	HRESULT hr = S_FALSE;

	if (m_pEnumObject)
	{
		if (WBEM_S_NO_ERROR == m_pEnumObject->Reset ())
			hr = S_OK;

		SetWbemError (m_pEnumObject->GetSWbemServices ());
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if ((NULL != pVar) && (m_pEnumObject))
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			ISWbemObject *pObject = NULL;
			
			if (SUCCEEDED(hr = m_pEnumObject->Next (INFINITE, &pObject)))
			{
				if (NULL == pObject)
				{
					break;
				}
				else
				{
					// Set the object into the variant array; note that pObject
					// has been addref'd as a result of the Next() call above
					pVar[l2].vt = VT_DISPATCH;
					pVar[l2].pdispVal = pObject;
				}
			}
			else
				break;
		}
		if (NULL != pcElementFetched)
			*pcElementFetched = l2;

		SetWbemError (m_pEnumObject->GetSWbemServices ());
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pEnumObject)
		{
			CSWbemObjectSet *pEnum = NULL;
			if (WBEM_S_NO_ERROR == (hr = m_pEnumObject->CloneObjectSet (&pEnum)))
			{
				CEnumVar *pEnumVar = new CEnumVar (pEnum);

				if (!pEnumVar)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pEnumVar->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
					delete pEnumVar;

				pEnum->Release ();
			}

			SetWbemError (m_pEnumObject->GetSWbemServices ());
		}
		else
		{
			CEnumVar *pEnumVar = new CEnumVar;

			if (!pEnumVar)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnumVar->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
					delete pEnumVar;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumVar::Skip
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_pEnumObject)
	{
		hr = m_pEnumObject->Skip (cElements, INFINITE);
		SetWbemError (m_pEnumObject->GetSWbemServices ());
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\events.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ENUMOBJ.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemEventSource::CSWbemEventSource
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemEventSource::CSWbemEventSource(
	CSWbemServices *pService, 
	IEnumWbemClassObject *pIEnumWbemClassObject)
{
	m_Dispatch.SetObj (this, IID_ISWbemEventSource, 
					CLSID_SWbemEventSource, L"SWbemEventSource");
    m_cRef=0;
	m_pSWbemServices = pService;

	if (m_pSWbemServices)
	{
		m_pSWbemServices->AddRef ();

		CSWbemSecurity *pSecurity = m_pSWbemServices->GetSecurityInfo ();

		if (pSecurity)
		{
			m_SecurityInfo = new CSWbemSecurity (pIEnumWbemClassObject, 
									pSecurity);
			pSecurity->Release ();
		}
	}

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemEventSource::~CSWbemEventSource
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemEventSource::~CSWbemEventSource(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	if (m_SecurityInfo)
		m_SecurityInfo->Release ();
}

//***************************************************************************
// HRESULT CSWbemEventSource::QueryInterface
// long CSWbemEventSource::AddRef
// long CSWbemEventSource::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemEventSource::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemEventSource==riid)
		*ppv = (ISWbemEventSource*)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
        *ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemEventSource::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemEventSource::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemEventSource::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemEventSource::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemEventSource == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemEventSource::NextEvent
//
//  DESCRIPTION:
//
//  Get the next event, or timeout
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or wbemTimeoutInfinite for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemEventSource::NextEvent (
	long lTimeout, 
	ISWbemObject **ppObject
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppObject)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppObject = NULL;

		if (m_SecurityInfo)
		{
			IEnumWbemClassObject *pIEnumWbemClassObject = 
								(IEnumWbemClassObject *) m_SecurityInfo->GetProxy ();

			if (pIEnumWbemClassObject)
			{
				IWbemClassObject *pIWbemClassObject = NULL;
				ULONG returned = 0;

				bool needToResetSecurity = false;
				HANDLE hThreadToken = NULL;
			
				if (m_SecurityInfo->SetSecurity (needToResetSecurity, hThreadToken))
					hr = pIEnumWbemClassObject->Next (lTimeout, 1, &pIWbemClassObject, &returned);

				if (needToResetSecurity)
					m_SecurityInfo->ResetSecurity (hThreadToken);

				if (SUCCEEDED(hr) && (0 < returned) && pIWbemClassObject)
				{
					CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pIWbemClassObject,
													m_SecurityInfo);

					if (!pObject)
						hr = WBEM_E_OUT_OF_MEMORY;
					else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject, 
											(PPVOID) ppObject)))
						delete pObject;

					pIWbemClassObject->Release ();
				}
				else if (WBEM_S_TIMEDOUT == hr)
				{
					/*
					 * Since a timeout would be indistinguishable from an end-of-enumeration
					 * in automation terms we flag it as a real error rather than an S-CODE.
					 */
					
					hr = wbemErrTimedout;
				}

				SetWbemError (m_pSWbemServices);
				pIEnumWbemClassObject->Release ();
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemEventSource::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemEventSource::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	else		// Bug ID 566345
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			*ppSecurity = m_SecurityInfo;
			(*ppSecurity)->AddRef ();
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);
			
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\error.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ERROR.CPP
//
//  alanbos  28-Jun-98   Created.
//
//  Defines the WBEM error cache implementation
//
//***************************************************************************

#include "precomp.h"

#define NULLBSTR(x) \
		SysFreeString (x);\
		x = NULL;

#define FREECOAUTH(x) \
		if (x)\
		{\
			WbemFreeAuthIdentity (x);\
			x = NULL;\
		}


//***************************************************************************
//
// CWbemErrorCache::CWbemErrorCache
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWbemErrorCache::CWbemErrorCache ()
{
	InitializeCriticalSection (&m_cs);
	headPtr = NULL;
}

//***************************************************************************
//
// CWbemErrorCache::~CWbemErrorCache
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWbemErrorCache::~CWbemErrorCache ()
{
	EnterCriticalSection (&m_cs);
	
	ThreadError	*pPtr = headPtr;

	while (pPtr)
	{
		// This is in case we re-enter here on the same thread.
		// This can happen when in an STA since the message loop may be invoked by the COM calls below.
		headPtr = pPtr->pNext;

		if (pPtr->pErrorObject)
		{
			pPtr->pErrorObject->Release ();
			pPtr->pErrorObject = NULL;
		}

		if (pPtr->pService)
		{
			pPtr->pService->Release ();
			pPtr->pService = NULL;
		}

		NULLBSTR (pPtr->strNamespacePath);
		NULLBSTR (pPtr->strAuthority);
		NULLBSTR (pPtr->strPrincipal);
		FREECOAUTH (pPtr->pCoAuthIdentity)
		
		ThreadError *pTmp = pPtr;
		pPtr = headPtr;				// Bug ID 472474
		delete pTmp;
	}

	headPtr = NULL;

	LeaveCriticalSection (&m_cs);
	DeleteCriticalSection (&m_cs);
}

//***************************************************************************
//
// CWbemErrorCache::GetAndResetCurrentThreadError
//
// DESCRIPTION:
//
// Extract the WBEM error object (if any) from the current thread.  This
// is a once-only operation as the entry for that thread is cleared by this
// read.
//
//***************************************************************************

CSWbemObject *CWbemErrorCache::GetAndResetCurrentThreadError ()
{
	CSWbemObject *pObject = NULL;
	DWORD threadId = GetCurrentThreadId ();
	
	EnterCriticalSection (&m_cs);

	ThreadError	*pPtr = headPtr;

	while (pPtr)
	{
		if (threadId == pPtr->dwThreadId)
		{
			if (pPtr->pErrorObject)
			{
				// Unhook ThreadError prior to cleanup in case this is re-entered on the same thread 
				// This can happen when in an STA since the message loop may be invoked by the COM calls below.
				if (pPtr == headPtr)
					headPtr = pPtr->pNext;

				if (pPtr->pNext)
					pPtr->pNext->pPrev = pPtr->pPrev;

				if (pPtr->pPrev)
					pPtr->pPrev->pNext = pPtr->pNext;

				CSWbemServices *pService = NULL;

				// Try and create a services object
				if (pPtr->pService)
				{
					pService = new CSWbemServices (pPtr->pService, pPtr->strNamespacePath,
											pPtr->pCoAuthIdentity, pPtr->strPrincipal,
											pPtr->strAuthority);

					if (pService)
						pService->AddRef ();
				}

				if (pPtr->pService)
				{
					pPtr->pService->Release ();
					pPtr->pService = NULL;
				}

				NULLBSTR (pPtr->strNamespacePath);
				NULLBSTR (pPtr->strAuthority);
				NULLBSTR (pPtr->strPrincipal);
				FREECOAUTH (pPtr->pCoAuthIdentity)

				pObject = new CSWbemObject (pService, pPtr->pErrorObject, NULL, true);
				pPtr->pErrorObject->Release ();
				pPtr->pErrorObject = NULL;

				if (pService)
					pService->Release ();

				// and finally delete the ThreadError...
				delete pPtr;
			}

			break;
		}

		pPtr = pPtr->pNext;
	}


	LeaveCriticalSection (&m_cs);

	return pObject;
}

//***************************************************************************
//
// CWbemErrorCache::SetCurrentThreadError
//
// DESCRIPTION:
//
// Set the WBEM error object (if any) for the current thread.
//
//***************************************************************************

void CWbemErrorCache::SetCurrentThreadError (CSWbemServices *pService)
{
	IErrorInfo * pInfo = NULL;
    
	if(SUCCEEDED(GetErrorInfo(0, &pInfo)) && pInfo)
	{
		// Is this a WBEM Error Object?
		IWbemClassObject * pObj = NULL;
			
		if(SUCCEEDED(pInfo->QueryInterface(IID_IWbemClassObject, (void **)&pObj)) && pObj)
		{
			EnterCriticalSection (&m_cs);

			//Remove the current one if present...
			ResetCurrentThreadError();
			
			DWORD threadId = GetCurrentThreadId ();

			// No entry for this thread anymore - create one at the head
			ThreadError *pTmp = headPtr;
			headPtr = new ThreadError;
			if (headPtr)
			{
				headPtr->pPrev = NULL;
				headPtr->pNext = pTmp;

				if (pTmp)
					pTmp->pPrev = headPtr;

				headPtr->dwThreadId = threadId;
				headPtr->pErrorObject = pObj;
				headPtr->pService = NULL;
				headPtr->strAuthority = NULL;
				headPtr->strPrincipal = NULL;
				headPtr->pCoAuthIdentity = NULL;
				headPtr->strNamespacePath = NULL;

				if (pService)
				{
					headPtr->pService = pService->GetIWbemServices ();
					CSWbemSecurity *pSecurity = pService->GetSecurityInfo ();

					if (pSecurity)
					{
						headPtr->strAuthority = SysAllocString (pSecurity->GetAuthority ());
						headPtr->strPrincipal = SysAllocString (pSecurity->GetPrincipal ());
						headPtr->pCoAuthIdentity = pSecurity->GetCoAuthIdentity ();
						pSecurity->Release ();
					}

					headPtr->strNamespacePath = SysAllocString(pService->GetPath ());
				}
            } else {

                headPtr = pTmp; // copy back the pointer to headPtr

            }

			LeaveCriticalSection (&m_cs);
		}

		pInfo->Release ();				// To balance the GetErrorInfo call
	}
}

//***************************************************************************
//
// CWbemErrorCache::ResetCurrentThreadError
//
// DESCRIPTION:
//
// If there is an entry for the current thread then remove it
//
//***************************************************************************

void CWbemErrorCache::ResetCurrentThreadError ()
{
	DWORD threadId = GetCurrentThreadId ();
	EnterCriticalSection (&m_cs);

	ThreadError	*pPtr = headPtr;

	// Find the current entry (if any)

	while (pPtr)
	{
		if (threadId == pPtr->dwThreadId)
			break;
		
		pPtr = pPtr->pNext;
	}

	if (pPtr)
	{
		// Unhook ThreadError prior to cleanup in case this is re-entered on the same thread 
		// This can happen when in an STA since the message loop may be invoked by the COM calls below.
		if (pPtr == headPtr)
			headPtr = pPtr->pNext;

		if (pPtr->pNext)
			pPtr->pNext->pPrev = pPtr->pPrev;

		if (pPtr->pPrev)
			pPtr->pPrev->pNext = pPtr->pNext;

		// pPtr addresses the current entry for the thread
		if (pPtr->pErrorObject)
		{
			pPtr->pErrorObject->Release ();
			pPtr->pErrorObject = NULL;
		}
		

		if (pPtr->pService)
		{
			pPtr->pService->Release ();
			pPtr->pService = NULL;
		}

		NULLBSTR (pPtr->strNamespacePath);
		NULLBSTR (pPtr->strAuthority);
		NULLBSTR (pPtr->strPrincipal);
		FREECOAUTH (pPtr->pCoAuthIdentity)

		// Finally delete the ErrorInfo
		delete pPtr;
	}


	LeaveCriticalSection (&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\locator.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  LOCATOR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemLocator
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"

#define WBEMS_DEFAULT_SERVER	L"."

extern CRITICAL_SECTION g_csErrorCache;
wchar_t *CSWbemLocator::s_pDefaultNamespace = NULL;

//***************************************************************************
//
//  CSWbemLocator::CSWbemLocator
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemLocator::CSWbemLocator(CSWbemPrivilegeSet *pPrivilegeSet) :
		m_pUnsecuredApartment (NULL),
		m_pIServiceProvider (NULL),	
		m_cRef (0)
{
	// Initialize the underlying locators
	HRESULT result = CoCreateInstance(CLSID_WbemLocator, 0,
				CLSCTX_INPROC_SERVER, IID_IWbemLocator,
				(LPVOID *) &m_pIWbemLocator);

	EnsureGlobalsInitialized () ;

	m_Dispatch.SetObj((ISWbemLocator *)this, IID_ISWbemLocator,
						CLSID_SWbemLocator, L"SWbemLocator");

	m_SecurityInfo = new CWbemLocatorSecurity (pPrivilegeSet);

	if (m_SecurityInfo)
	{
		// Set the impersonation level by default in the locator - note
		// that this must be done after EnsureGlobalsInitialized is called
		m_SecurityInfo->put_ImpersonationLevel (CSWbemSecurity::GetDefaultImpersonationLevel ());
	}

    InterlockedIncrement(&g_cObj);
}

CSWbemLocator::CSWbemLocator(CSWbemLocator & csWbemLocator) :
		m_pUnsecuredApartment (NULL),
		m_pIServiceProvider (NULL),
		m_cRef (0)
{
	_RD(static char *me = "CSWbemLocator::CSWbemLocator()";)
	// This is a smart COM pointers so no explicit AddRef required
    m_pIWbemLocator = csWbemLocator.m_pIWbemLocator;
	
	m_Dispatch.SetObj((ISWbemLocator *)this,IID_ISWbemLocator,
						CLSID_SWbemLocator, L"SWbemLocator");
	m_SecurityInfo = new CWbemLocatorSecurity (csWbemLocator.m_SecurityInfo);

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemLocator::~CSWbemLocator
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CSWbemLocator::~CSWbemLocator(void)
{
    InterlockedDecrement(&g_cObj);

	RELEASEANDNULL(m_SecurityInfo)
	RELEASEANDNULL(m_pUnsecuredApartment)
}

//***************************************************************************
// HRESULT CSWbemLocator::QueryInterface
// long CSWbemLocator::AddRef
// long CSWbemLocator::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemLocator::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemLocator==riid)
		*ppv = (ISWbemLocator *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)((ISWbemLocator *)this);
	else if (IID_IObjectSafety==riid)
		*ppv = (IObjectSafety *)this;
	else if (IID_IDispatchEx==riid)
		*ppv = (IDispatchEx *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemLocator::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemLocator::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

// IDispatch methods should be inline

STDMETHODIMP		CSWbemLocator::GetTypeInfoCount(UINT* pctinfo)
	{
	_RD(static char *me = "CSWbemLocator::GetTypeInfoCount()";)
	_RPrint(me, "Called", 0, "");
	return  m_Dispatch.GetTypeInfoCount(pctinfo);}
STDMETHODIMP		CSWbemLocator::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
	_RD(static char *me = "CSWbemLocator::GetTypeInfo()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
STDMETHODIMP		CSWbemLocator::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,
						UINT cNames, LCID lcid, DISPID* rgdispid)
	{
	_RD(static char *me = "CSWbemLocator::GetIdsOfNames()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
					  lcid,
					  rgdispid);}
STDMETHODIMP		CSWbemLocator::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
						WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
								EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
	_RD(static char *me = "CSWbemLocator::Invoke()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
					pdispparams, pvarResult, pexcepinfo, puArgErr);}

// IDispatchEx methods should be inline
HRESULT STDMETHODCALLTYPE CSWbemLocator::GetDispID(
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemLocator::GetDispID()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetDispID(bstrName, grfdex, pid);
}

/* [local] */ HRESULT STDMETHODCALLTYPE CSWbemLocator::InvokeEx(
	/* [in] */ DISPID id,
	/* [in] */ LCID lcid,
	/* [in] */ WORD wFlags,
	/* [in] */ DISPPARAMS __RPC_FAR *pdp,
	/* [out] */ VARIANT __RPC_FAR *pvarRes,
	/* [out] */ EXCEPINFO __RPC_FAR *pei,
	/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	HRESULT hr;
	_RD(static char *me = "CSWbemLocator::InvokeEx()";)
	_RPrint(me, "Called", (long)id, "id");
	_RPrint(me, "Called", (long)wFlags, "wFlags");


	/*
	 * Store away the service provider so that it can be accessed
	 * by calls that remote to CIMOM
	 */
	m_pIServiceProvider = pspCaller;

	hr = m_Dispatch.InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);

	m_pIServiceProvider = NULL;

	return hr;
}

HRESULT STDMETHODCALLTYPE CSWbemLocator::DeleteMemberByName(
	/* [in] */ BSTR bstr,
	/* [in] */ DWORD grfdex)
{
	_RD(static char *me = "CSWbemLocator::DeleteMemberByName()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.DeleteMemberByName(bstr, grfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemLocator::DeleteMemberByDispID(
	/* [in] */ DISPID id)
{
	_RD(static char *me = "CSWbemLocator::DeletememberByDispId()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.DeleteMemberByDispID(id);
}

HRESULT STDMETHODCALLTYPE CSWbemLocator::GetMemberProperties(
	/* [in] */ DISPID id,
	/* [in] */ DWORD grfdexFetch,
	/* [out] */ DWORD __RPC_FAR *pgrfdex)
{
	_RD(static char *me = "CSWbemLocator::GetMemberProperties()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetMemberProperties(id, grfdexFetch, pgrfdex);
}

HRESULT STDMETHODCALLTYPE CSWbemLocator::GetMemberName(
	/* [in] */ DISPID id,
	/* [out] */ BSTR __RPC_FAR *pbstrName)
{
	_RD(static char *me = "CSWbemLocator::GetMemberName()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetMemberName(id, pbstrName);
}


/*
 * I don't think this needs implementing
 */
HRESULT STDMETHODCALLTYPE CSWbemLocator::GetNextDispID(
	/* [in] */ DWORD grfdex,
	/* [in] */ DISPID id,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	_RD(static char *me = "CSWbemLocator::GetNextDispID()";)
	HRESULT rc = S_FALSE;

	_RPrint(me, "Called", 0, "");
	if ((grfdex & fdexEnumAll) && pid) {
		if (DISPID_STARTENUM == id) {
			*pid = 1;
			rc = S_OK;
		} else if (1 == id) {
			*pid = 2;
		}
	}

	return rc;

}

HRESULT STDMETHODCALLTYPE CSWbemLocator::GetNameSpaceParent(
	/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
{
	_RD(static char *me = "CSWbemLocator::GetNamespaceParent()";)
	_RPrint(me, "Called", 0, "");
	return m_Dispatch.GetNameSpaceParent(ppunk);
}


//***************************************************************************
// HRESULT CSWbemLocator::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemLocator::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemLocator == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemLocator::ConnectServer
//
//  DESCRIPTION:
//
//  Initiate connection to namespace
//
//  PARAMETERS:
//
//	bsServer				The Server to which to connect
//	bsNamespace				The namespace to connect to (default is reg lookup)
//  bsUser					The user ("" implies default to logged-on user)
//  bsPassword				The password ("" implies default to logged-on user's
//							password if bsUser == "")
//	bsLocale				Requested locale
//	bsAuthority				Authority
//	lSecurityFlags			Currently 0 by default
//	pContext				If non-null, extra context info for the connection
//	ppNamespace				On successful return addresses the IWbemSServices
//								connection to the namespace.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CSWbemLocator::ConnectServer (
	BSTR bsServer,
    BSTR bsNamespace,
    BSTR bsUser,
	BSTR bsPassword,
	BSTR bsLocale,
    BSTR bsAuthority,
	long lSecurityFlags,
    /*ISWbemValueBag*/ IDispatch *pContext,
	ISWbemServices 	**ppNamespace
)
{
	_RD(static char *me = "CSWbemLocator::ConnectServer";)
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppNamespace)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemLocator && m_SecurityInfo)
	{
		bool useDefaultUser = (NULL == bsUser) || (0 == wcslen(bsUser));
		bool useDefaultAuthority = (NULL != bsAuthority) && (0 == wcslen (bsAuthority));

		// Build the namespace path
		BSTR bsNamespacePath = BuildPath (bsServer, bsNamespace);

		// Get the context
		IWbemContext	*pIContext = CSWbemNamedValueSet::GetIWbemContext (pContext, m_pIServiceProvider);

		// Connect to the requested namespace
		IWbemServices	*pIWbemService = NULL;

		bool needToResetSecurity = false;
		HANDLE hThreadToken = NULL;

		if (m_SecurityInfo->SetSecurity (bsUser, needToResetSecurity, hThreadToken))
			hr = m_pIWbemLocator->ConnectServer (
				bsNamespacePath,
				(useDefaultUser) ? NULL : bsUser,
				(useDefaultUser) ? NULL : bsPassword,
				((NULL != bsLocale) && (0 < wcslen (bsLocale))) ? bsLocale : NULL,
				lSecurityFlags,
				(useDefaultAuthority) ? NULL : bsAuthority,
				pIContext,
				&pIWbemService);

		if (needToResetSecurity)
			m_SecurityInfo->ResetSecurity (hThreadToken);

		if (WBEM_S_NO_ERROR == hr)
		{
			// Create a new CSWbemServices using the IWbemServices interface
			// just returned.  This will AddRef pIWbemService.

			CSWbemServices *pService =
					new CSWbemServices (
							pIWbemService,
							bsNamespacePath,
							((NULL != bsAuthority) && (0 < wcslen (bsAuthority))) ? bsAuthority : NULL,
							(useDefaultUser) ? NULL : bsUser,
							(useDefaultUser) ? NULL : bsPassword,
							m_SecurityInfo,
							((NULL != bsLocale) && (0 < wcslen (bsLocale))) ? bsLocale : NULL
						);

			if (!pService)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pService->QueryInterface (IID_ISWbemServices,
										(PPVOID) ppNamespace)))
				delete pService;

			pIWbemService->Release ();
		}

		if (NULL != pIContext)
			pIContext->Release ();

		SysFreeString (bsNamespacePath);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemLocator::BuildPath
//
//  DESCRIPTION:
//
//  Build a namespace path from a server and namespace
//
//  PARAMETERS:
//
//	bsServer				The Server to which to connect
//	bsNamespace				The namespace to connect to (default is reg lookup)
//
//  RETURN VALUES:
//
//	The fully-formed namespace path
//
//***************************************************************************

BSTR CSWbemLocator::BuildPath (BSTR bsServer, BSTR bsNamespace)
{
	BSTR namespacePath = NULL;
	bool ok = false;
	CComBSTR bsPath;

	if ((NULL == bsServer) || (0 == wcslen(bsServer)))
		bsServer = WBEMS_DEFAULT_SERVER;

	// Use the default namespace if none supplied
	if ((NULL == bsNamespace) || (0 == wcslen(bsNamespace)))
	{
		const wchar_t *defaultNamespace = GetDefaultNamespace ();

		if (defaultNamespace)
		{
			CWbemPathCracker pathCracker;
			pathCracker.SetServer (bsServer);
			pathCracker.SetNamespacePath (defaultNamespace);
			ok = pathCracker.GetPathText (bsPath, false, true);
		}
	}
	else
	{
		CWbemPathCracker pathCracker;
		pathCracker.SetServer (bsServer);
		pathCracker.SetNamespacePath (bsNamespace);
		ok = pathCracker.GetPathText (bsPath, false, true);
	}

	if (ok)
		namespacePath = bsPath.Detach ();

	return namespacePath;
}


//***************************************************************************
//
//  SCODE CSWbemLocator::GetDefaultNamespace
//
//  DESCRIPTION:
//
//		Get the default namespace path
//
//  PARAMETERS:
//
//		None
//
//  RETURN VALUES:
//
//		The default Namespace.
//
//***************************************************************************

const wchar_t *CSWbemLocator::GetDefaultNamespace ()
{
	if (!s_pDefaultNamespace)
	{
		// Get the value from the registry key
		HKEY hKey;

		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					WBEMS_RK_SCRIPTING, 0, KEY_QUERY_VALUE, &hKey))
		{
			DWORD dataLen = 0;

			// Find out how much space to allocate first
			if (ERROR_SUCCESS == RegQueryValueEx (hKey, WBEMS_RV_DEFNS,
						NULL, NULL, NULL,  &dataLen))
			{
				TCHAR *defNamespace = new TCHAR [dataLen];

				if (defNamespace)
				{
					if (ERROR_SUCCESS == RegQueryValueEx (hKey, WBEMS_RV_DEFNS,
							NULL, NULL, (LPBYTE) defNamespace,  &dataLen))
					{
#ifndef UNICODE
						// Convert the multibyte value to its wide character equivalent
						int wDataLen = MultiByteToWideChar(CP_ACP, 0, defNamespace, -1, NULL, 0);
						s_pDefaultNamespace = new wchar_t [wDataLen];

						if (s_pDefaultNamespace)
							MultiByteToWideChar(CP_ACP, 0, defNamespace, -1, s_pDefaultNamespace, wDataLen);
#else
						s_pDefaultNamespace = new wchar_t [wcslen (defNamespace) + 1];

						if (s_pDefaultNamespace)
							wcscpy (s_pDefaultNamespace, defNamespace);
#endif
					}

					delete [] defNamespace;
				}
			}

			RegCloseKey (hKey);
		}

		// If we failed to read the registry OK, just use the default
		if (!s_pDefaultNamespace)
		{
#ifndef UNICODE
			int wDataLen = MultiByteToWideChar(CP_ACP, 0, WBEMS_DEFNS, -1, NULL, 0);
			s_pDefaultNamespace = new wchar_t [wDataLen];

			if (s_pDefaultNamespace)
				MultiByteToWideChar(CP_ACP, 0, WBEMS_DEFNS, -1, s_pDefaultNamespace, wDataLen);
#else
			s_pDefaultNamespace = new wchar_t [wcslen (WBEMS_DEFNS) + 1];

			if (s_pDefaultNamespace)
				wcscpy (s_pDefaultNamespace, WBEMS_DEFNS);
#endif
		}
	}

	return s_pDefaultNamespace;
}

//***************************************************************************
//
//  SCODE CSWbemLocator::get_Security_
//
//  DESCRIPTION:
//
//  Return the security configurator
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemLocator::get_Security_	(
	ISWbemSecurity **ppSecurity
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppSecurity)
		hr = WBEM_E_INVALID_PARAMETER;
	else		// Bug ID 566345
	{
		*ppSecurity = NULL;

		if (m_SecurityInfo)
		{
			if (SUCCEEDED (m_SecurityInfo->QueryInterface (IID_ISWbemSecurity,
											(PPVOID) ppSecurity)))
				hr = WBEM_S_NO_ERROR;
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\locator.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  locator.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemLocator definition.
//
//***************************************************************************

#ifndef _LOCATOR_H_
#define _LOCATOR_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemLocator
//
//  DESCRIPTION:
//
//  Implements the IWbemSLocator interface.  This class is what the client gets
//  when it initially hooks up to the Wbemprox.dll.  The ConnectServer function
//  is what get the communication between client and server started.
//
//***************************************************************************


class CSWbemLocator : public ISWbemLocator,
					  public IDispatchEx,
					  public IObjectSafety,
					  public ISupportErrorInfo,
					  public IProvideClassInfo
{
private:

	CWbemLocatorSecurity	*m_SecurityInfo;
	CComPtr<IWbemLocator>	m_pIWbemLocator;
	CDispatchHelp			m_Dispatch;		
	IServiceProvider		*m_pIServiceProvider;
	IUnsecuredApartment		*m_pUnsecuredApartment;

	static wchar_t			*s_pDefaultNamespace;

	static BSTR				BuildPath (BSTR Server, BSTR Namespace);
	static const wchar_t	*GetDefaultNamespace ();
	
protected:

	long            m_cRef;         //Object reference count

public:
    
    CSWbemLocator(CSWbemPrivilegeSet *pPrivilegeSet = NULL);
	CSWbemLocator(CSWbemLocator &csWbemLocator);
    ~CSWbemLocator(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch methods should be inline

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid);
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr);

	// IDispatchEx methods should be inline
	HRESULT STDMETHODCALLTYPE GetDispID( 
		/* [in] */ BSTR bstrName,
		/* [in] */ DWORD grfdex,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	/* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
		/* [in] */ DISPID id,
		/* [in] */ LCID lcid,
		/* [in] */ WORD wFlags,
		/* [in] */ DISPPARAMS __RPC_FAR *pdp,
		/* [out] */ VARIANT __RPC_FAR *pvarRes,
		/* [out] */ EXCEPINFO __RPC_FAR *pei,
		/* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
		/* [in] */ BSTR bstr,
		/* [in] */ DWORD grfdex);
	
	HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
		/* [in] */ DISPID id);
	
	HRESULT STDMETHODCALLTYPE GetMemberProperties( 
		/* [in] */ DISPID id,
		/* [in] */ DWORD grfdexFetch,
		/* [out] */ DWORD __RPC_FAR *pgrfdex);
	
	HRESULT STDMETHODCALLTYPE GetMemberName( 
		/* [in] */ DISPID id,
		/* [out] */ BSTR __RPC_FAR *pbstrName);
	
	HRESULT STDMETHODCALLTYPE GetNextDispID( 
		/* [in] */ DWORD grfdex,
		/* [in] */ DISPID id,
		/* [out] */ DISPID __RPC_FAR *pid);
	
	HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
		/* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
    
	// ISWbemLocator methods

	HRESULT STDMETHODCALLTYPE  ConnectServer
	(
	    /*[in]*/	BSTR Server,           
        /*[in]*/   	BSTR Namespace,        
        /*[in]*/	BSTR User,
        /*[in]*/	BSTR Password,
		/*[in]*/   	BSTR Locale,
        /*[in]*/   	BSTR Authority,
		/*[in]*/	long lSecurityFlags,
        /*[in]*/ 	/*ISWbemNamedValueSet*/ IDispatch *pContext,
		/*[out]*/	ISWbemServices 	**ppNamespace
    );

	HRESULT STDMETHODCALLTYPE get_Security_
	(
		/* [in] */ ISWbemSecurity **ppSecurity
	);

	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	static void				Shutdown ()
	{
		if (s_pDefaultNamespace)
		{
			delete [] s_pDefaultNamespace;
			s_pDefaultNamespace = NULL;
		}
	}

	CWbemLocatorSecurity	*GetSecurityInfo ()
	{
		return m_SecurityInfo;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\method.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  method.h
//
//  alanbos  27-Mar-00   Created.
//
//  CSWbemMethod and CSWbemMethodSet definitions.
//
//***************************************************************************

#ifndef _METHOD_H_
#define _METHOD_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemMethod
//
//  DESCRIPTION:
//
//  Implements the ISWbemMethod interface.  
//
//***************************************************************************

class CSWbemMethod : public ISWbemMethod,
					 public ISupportErrorInfo,
					 public IProvideClassInfo
{
private:
	class CMethodDispatchHelp : public CDispatchHelp
	{
		public:
			bool HandleNulls (
						DISPID dispidMember,
						unsigned short wFlags)
			{
				return false;
			}
	};

	CSWbemServices		*m_pSWbemServices;
	IWbemClassObject	*m_pIWbemClassObject;
	CMethodDispatchHelp	m_Dispatch;
	BSTR				m_name;

protected:
	long				m_cRef;         //Object reference count

public:
    
    CSWbemMethod (CSWbemServices *pService, IWbemClassObject *pObject, 
					BSTR name);
    ~CSWbemMethod (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemProperty methods

	HRESULT STDMETHODCALLTYPE get_Name
	(
		/*[out]*/	BSTR *name
	);

	HRESULT STDMETHODCALLTYPE get_Origin
	(
		/*[out]*/	BSTR *pOrigin
	);

	HRESULT STDMETHODCALLTYPE get_InParameters
	(
		/*[out]*/	ISWbemObject **ppInParameters
	);
	
	HRESULT STDMETHODCALLTYPE get_OutParameters
	(
		/*[out]*/	ISWbemObject **ppOutParameters
	);
	
	HRESULT STDMETHODCALLTYPE get_Qualifiers_
	(
		/*[out]*/	ISWbemQualifierSet **ppQualSet
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemMethodSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemMethodSet interface.  
//
//***************************************************************************

class CSWbemMethodSet : public ISWbemMethodSet,
						public ISupportErrorInfo,
						public IProvideClassInfo
{
private:
	CSWbemServices		*m_pSWbemServices;
	IWbemClassObject	*m_pIWbemClassObject;
	CDispatchHelp		m_Dispatch;
	long				m_Count;

protected:
	long            m_cRef;         //Object reference count

public:
    
    CSWbemMethodSet (CSWbemServices *pService, IWbemClassObject *pObject);
    ~CSWbemMethodSet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR Name,
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemMethod **ppMethod
    );        

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[in]*/	long *plCount
	);

    // ISWbemMethodSet methods

	HRESULT STDMETHODCALLTYPE BeginEnumeration
	(
    );

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	long lFlags,
        /*[out]*/	ISWbemMethod **ppMethod
    );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\method.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  METHOD.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemMethod
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemMethod::CSWbemMethod
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemMethod::CSWbemMethod(
	CSWbemServices *pService, 
	IWbemClassObject *pIWbemClassObject,
	BSTR name
)
{
	m_Dispatch.SetObj (this, IID_ISWbemMethod, 
							CLSID_SWbemMethod, L"SWbemMethod");
    m_cRef=1;
	m_pIWbemClassObject = pIWbemClassObject;
	m_pIWbemClassObject->AddRef ();
	m_pSWbemServices = pService;

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

	m_name = SysAllocString (name);
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CSWbemMethod::~CSWbemMethod
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemMethod::~CSWbemMethod(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemClassObject)
		m_pIWbemClassObject->Release ();

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();

	SysFreeString (m_name);
}

//***************************************************************************
// HRESULT CSWbemMethod::QueryInterface
// long CSWbemMethod::AddRef
// long CSWbemMethod::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemMethod::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemMethod==riid)
		*ppv = (ISWbemMethod *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemMethod::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemMethod::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemMethod::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemMethod::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemMethod == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the method name
//
//  PARAMETERS:
//
//		pName		holds the name on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pName)
		hr = WBEM_E_INVALID_PARAMETER;
	else
		*pName = SysAllocString (m_name);

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_InParameters
//
//  DESCRIPTION:
//
//  Retrieve the method in parameters signature
//
//  PARAMETERS:
//
//		ppInSignature		addresses the in signature on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_InParameters (
	ISWbemObject **ppInSignature
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppInSignature)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppInSignature = NULL;

		if (m_pIWbemClassObject)
		{
			IWbemClassObject *pInSig = NULL;
			
			/*
			 * Note that if there are no in parameters, the following
			 * call will succeed but pInSig will be NULL.
			 */
			if ((WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetMethod 
							(m_name, 0, &pInSig, NULL))) && pInSig)
			{
				CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pInSig);

				if (!pObject)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject, 
										(PPVOID) ppInSignature)))
					delete pObject;

				pInSig->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_OutParameters
//
//  DESCRIPTION:
//
//  Retrieve the method out parameters signature
//
//  PARAMETERS:
//
//		ppOutSignature		addresses the out signature on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_OutParameters (
	ISWbemObject **ppOutSignature
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppOutSignature)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppOutSignature = NULL;

		if (m_pIWbemClassObject)
		{
			IWbemClassObject *pOutSig = NULL;
			
			/*
			 * Note that if there are no in parameters, the following
			 * call will succeed but pOutSig will be NULL.
			 */
			if ((WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetMethod 
							(m_name, 0, NULL, &pOutSig))) && pOutSig)
			{
				CSWbemObject *pObject = new CSWbemObject (m_pSWbemServices, pOutSig);

				if (!pObject)
					hr = WBEM_E_OUT_OF_MEMORY;
				else if (FAILED(hr = pObject->QueryInterface (IID_ISWbemObject, 
										(PPVOID) ppOutSignature)))
					delete pObject;

				pOutSig->Release ();
			}
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_Origin
//
//  DESCRIPTION:
//
//  Retrieve the method origin
//
//  PARAMETERS:
//
//		pOrigin		holds the origin class on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_Origin (
	BSTR *pOrigin
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	ResetLastErrors ();

	if (NULL == pOrigin)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		if (m_pIWbemClassObject)
			m_pIWbemClassObject->GetMethodOrigin (m_name, pOrigin);

		if (NULL == *pOrigin)
			*pOrigin = SysAllocString (OLESTR(""));
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethod::get_Qualifiers_
//
//  DESCRIPTION:
//
//  Retrieve the method qualifier set
//
//  PARAMETERS:
//
//		ppQualSet		addresses the qualifier set on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethod::get_Qualifiers_ (
	ISWbemQualifierSet **ppQualSet	
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppQualSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_pIWbemClassObject)
	{
		IWbemQualifierSet *pQualSet = NULL;

		if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetMethodQualifierSet 
									(m_name, &pQualSet)))
		{
			if (!(*ppQualSet = new CSWbemQualifierSet (pQualSet)))
				hr = WBEM_E_OUT_OF_MEMORY;

			pQualSet->Release ();
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\methset.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PROPSET.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemPropertySet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CSWbemMethodSet::CSWbemMethodSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemMethodSet::CSWbemMethodSet(CSWbemServices *pService, IWbemClassObject *pObject)
{
	m_Dispatch.SetObj (this, IID_ISWbemMethodSet, 
							CLSID_SWbemMethodSet, L"SWbemMethodSet");
	m_pIWbemClassObject = pObject;
	m_pIWbemClassObject->AddRef ();
	m_pSWbemServices = pService;

	if (m_pSWbemServices)
		m_pSWbemServices->AddRef ();

    m_cRef=1;
    InterlockedIncrement(&g_cObj);

	// Set up the Count.  We can do this because this is a read-only interface
	m_Count = 0;
	pObject->BeginMethodEnumeration (0);
	BSTR bstrName = NULL;

	while (WBEM_S_NO_ERROR == pObject->NextMethod (0, &bstrName, NULL, NULL))
	{
		SysFreeString (bstrName);
		m_Count++;
	}

	pObject->EndMethodEnumeration ();
}

//***************************************************************************
//
//  CSWbemMethodSet::~CSWbemMethodSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemMethodSet::~CSWbemMethodSet()
{
    InterlockedDecrement(&g_cObj);

	if (m_pIWbemClassObject)
	{
		m_pIWbemClassObject->EndMethodEnumeration ();
		m_pIWbemClassObject->Release ();
	}

	if (m_pSWbemServices)
		m_pSWbemServices->Release ();
}

//***************************************************************************
// HRESULT CSWbemMethodSet::QueryInterface
// long CSWbemMethodSet::AddRef
// long CSWbemMethodSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemMethodSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemMethodSet==riid)
		*ppv = (ISWbemMethodSet *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemMethodSet::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSWbemMethodSet::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemMethodSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemMethodSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemMethodSet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemMethodSet::Item
//
//  DESCRIPTION:
//
//  Get a method
//
//  PARAMETERS:
//
//		bsName			The name of the method
//		lFlags			Flags
//		ppProp			On successful return addresses the ISWbemMethod
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CSWbemMethodSet::Item (
	BSTR bsName,
	long lFlags,
    ISWbemMethod ** ppMethod
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppMethod)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppMethod = NULL;

		if (m_pIWbemClassObject)
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->GetMethod (bsName, lFlags, NULL, NULL)))
			{
				if (!(*ppMethod = 
						new CSWbemMethod (m_pSWbemServices, m_pIWbemClassObject, bsName)))
					hr = WBEM_E_OUT_OF_MEMORY;
			}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethodSet::BeginEnumeration
//
//  DESCRIPTION:
//
//  Begin an enumeration of the methods
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethodSet::BeginEnumeration (
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (m_pIWbemClassObject)
	{
		hr = m_pIWbemClassObject->EndEnumeration ();
		hr = m_pIWbemClassObject->BeginMethodEnumeration (0);
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethodSet::Next
//
//  DESCRIPTION:
//
//  Get next method in enumeration
//
//  PARAMETERS:
//
//		lFlags		Flags
//		ppMethod	Next method (or NULL if end of enumeration)
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemMethodSet::Next (
	long lFlags,
	ISWbemMethod ** ppMethod
)
{
	HRESULT hr = WBEM_E_FAILED;

	ResetLastErrors ();

	if (NULL == ppMethod)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppMethod = NULL;

		if (m_pIWbemClassObject)
		{
			BSTR bsName = NULL;
			
			if (WBEM_S_NO_ERROR == (hr = m_pIWbemClassObject->NextMethod (lFlags, &bsName, NULL, NULL)))
			{
				if (!(*ppMethod = new CSWbemMethod (m_pSWbemServices, m_pIWbemClassObject, bsName)))
					hr = WBEM_E_OUT_OF_MEMORY;

				SysFreeString (bsName);
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemMethodSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemMethodSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CMethodSetEnumVar *pEnum = new CMethodSetEnumVar (this);

		if (!pEnum)
			hr = WBEM_E_OUT_OF_MEMORY;
		else if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (PPVOID) ppUnk)))
			delete pEnum;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemMethodSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses value
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemMethodSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	ResetLastErrors ();

	if (NULL != plCount)
	{
		*plCount = m_Count;
		hr = S_OK;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\methvar.h ===
//***************************************************************************
//
//  methvar.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CMethodSetEnumVar object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _METHVAR_H_
#define _METHVAR_H_

// This class implements the IEnumVARIANT interface

class CMethodSetEnumVar : public IEnumVARIANT
{
private:
	long				m_cRef;
	CSWbemMethodSet		*m_pMethodSet;
	ULONG				m_pos;
		
	bool			SeekCurrentPosition ();

public:
	CMethodSetEnumVar (CSWbemMethodSet *pObject,
						ULONG initialPos = 0);
	~CMethodSetEnumVar (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\methvar.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  METHVAR.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines implementation of IEnumVARIANT for iterators of ISWbemMethodSet
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
//  CMethodSetEnumVar::CMethodSetEnumVar
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CMethodSetEnumVar::CMethodSetEnumVar(CSWbemMethodSet *pMethodSet,
									 ULONG initialPos)
{
	m_cRef = 0;
	m_pos = 0;
	m_pMethodSet = pMethodSet;
	m_pMethodSet->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CMethodSetEnumVar::~CMethodSetEnumVar
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CMethodSetEnumVar::~CMethodSetEnumVar(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pMethodSet)
		m_pMethodSet->Release ();
}

//***************************************************************************
// HRESULT CMethodSetEnumVar::QueryInterface
// long CMethodSetEnumVar::AddRef
// long CMethodSetEnumVar::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CMethodSetEnumVar::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CMethodSetEnumVar::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CMethodSetEnumVar::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 != cRef)
    {
        _ASSERT(cRef > 0);
        return cRef;
    }

    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CMethodSetEnumVar::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//
//***************************************************************************

HRESULT CMethodSetEnumVar::Reset ()
{
	m_pos = 0;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CMethodSetEnumVar::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//
//  RETURN VALUES:
//
//  S_OK				success (all requested elements returned)
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CMethodSetEnumVar::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if (NULL != pVar)
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		if (m_pMethodSet)
		{
			// Retrieve the next cElements elements.  
			if (SeekCurrentPosition ())
			{
				for (l2 = 0; l2 < cElements; l2++)
				{
					HRESULT hRes2;
					ISWbemMethod *pMethod = NULL;
					
					if (SUCCEEDED(hRes2 = m_pMethodSet->Next (0, &pMethod)))
					{
						if (NULL == pMethod)
						{
							break;
						}
						else
						{
							// Set the object into the variant array; note that pObject
							// has been addref'd as a result of the Next() call above
							pVar[l2].vt = VT_DISPATCH;
							pVar[l2].pdispVal = pMethod;
							m_pos++;
						}
					}
					else
						break;
				}
				if (NULL != pcElementFetched)
					*pcElementFetched = l2;
			}
		}
	}

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CMethodSetEnumVar::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_OUTOFMEMORY		insufficient memory to complete operation
//
//***************************************************************************

HRESULT CMethodSetEnumVar::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pMethodSet)
		{
			CMethodSetEnumVar *pEnum = new CMethodSetEnumVar (m_pMethodSet, m_pos);

			if (!pEnum)
				hr = WBEM_E_OUT_OF_MEMORY;
			else if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (PPVOID) ppEnum)))
				delete pEnum;;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CMethodSetEnumVar::Skip
//
//  DESCRIPTION:
//
//  Skips some elements in this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CMethodSetEnumVar::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;
	long count = 0;
	m_pMethodSet->get_Count (&count);

	if (((ULONG) count) >= cElements + m_pos)
	{
		hr = S_OK;
		m_pos += cElements;
	}
	else
		m_pos = count;

	return hr;
}
	
//***************************************************************************
//
//  SCODE CMethodSetEnumVar::SeekCurrentPosition
//
//  DESCRIPTION:
//
//  Iterate to current position.  Somewhat painful as there is no
//	underlying iterator so we have to reset and then step. Note that we
//	assume that the access to this iterator is apartment-threaded.
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

bool CMethodSetEnumVar::SeekCurrentPosition ()
{
	ISWbemMethod *pDummyObject = NULL;
	m_pMethodSet->BeginEnumeration ();

	// Traverse to the current position
	ULONG i = 0;

	for (; i < m_pos; i++)
	{
		if (WBEM_S_NO_ERROR != m_pMethodSet->Next (0, &pDummyObject))
			break;
		else
			pDummyObject->Release ();
	}

	return (i == m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\scripting\maindll.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  MAINDLL.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Contains DLL entry points.  
//
//***************************************************************************

#include "precomp.h"
#include "objsink.h"
#include "initguid.h"

// SWbemLocator registry strings
#define WBEMS_LOC_DESCRIPTION	_T("WBEM Scripting Locator")
#define WBEMS_LOC_PROGID		_T("WbemScripting.SWbemLocator")
#define WBEMS_LOC_PROGIDVER		_T("WbemScripting.SWbemLocator.1")
#define WBEMS_LOC_VERSION		_T("1.0")
#define WBEMS_LOC_VERDESC		_T("WBEM Scripting Locator 1.0")

// SWbemNamedValueSet registry strings
#define WBEMS_CON_DESCRIPTION	_T("WBEM Scripting Named Value Collection")
#define WBEMS_CON_PROGID		_T("WbemScripting.SWbemNamedValueSet")
#define WBEMS_CON_PROGIDVER		_T("WbemScripting.SWbemNamedValueSet.1")
#define WBEMS_CON_VERSION		_T("1.0")
#define WBEMS_CON_VERDESC		_T("WBEM Scripting Named Value Collection 1.0")

// SWbemObjectPath registry settings
#define WBEMS_OBP_DESCRIPTION	_T("WBEM Scripting Object Path")
#define WBEMS_OBP_PROGID		_T("WbemScripting.SWbemObjectPath")
#define WBEMS_OBP_PROGIDVER		_T("WbemScripting.SWbemObjectPath.1")
#define WBEMS_OBP_VERSION		_T("1.0")
#define WBEMS_OBP_VERDESC		_T("WBEM Scripting Object Path 1.0")

// SWbemParseDN registry settings
#define WBEMS_PDN_DESCRIPTION	_T("Wbem Scripting Object Path")
#define WBEMS_PDN_PROGID		_T("WINMGMTS")
#define WBEMS_PDN_PROGIDVER		_T("WINMGMTS.1")
#define WBEMS_PDN_VERSION		_T("1.0")
#define WBEMS_PDN_VERDESC		_T("Wbem Object Path 1.0")

// SWbemLastError registry settings
#define WBEMS_LER_DESCRIPTION	_T("Wbem Scripting Last Error")
#define WBEMS_LER_PROGID		_T("WbemScripting.SWbemLastError")
#define WBEMS_LER_PROGIDVER		_T("WbemScripting.SWbemLastError.1")
#define WBEMS_LER_VERSION		_T("1.0")
#define WBEMS_LER_VERDESC		_T("Wbem Last Error 1.0")

// SWbemSink registry strings
#define WBEMS_SINK_DESCRIPTION	_T("WBEM Scripting Sink")
#define WBEMS_SINK_PROGID		_T("WbemScripting.SWbemSink")
#define WBEMS_SINK_PROGIDVER	_T("WbemScripting.SWbemSink.1")
#define WBEMS_SINK_VERSION		_T("1.0")
#define WBEMS_SINK_VERDESC		_T("WBEM Scripting Sink 1.0")

// SWbemDateTime registry settings
#define WBEMS_DTIME_DESCRIPTION	_T("WBEM Scripting DateTime")
#define WBEMS_DTIME_PROGID		_T("WbemScripting.SWbemDateTime")
#define WBEMS_DTIME_PROGIDVER	_T("WbemScripting.SWbemDateTime.1")
#define WBEMS_DTIME_VERSION		_T("1.0")
#define WBEMS_DTIME_VERDESC		_T("WBEM Scripting DateTime 1.0")

// SWbemRefresher registry settings
#define WBEMS_REF_DESCRIPTION	_T("WBEM Scripting Refresher")
#define WBEMS_REF_PROGID		_T("WbemScripting.SWbemRefresher")
#define WBEMS_REF_PROGIDVER		_T("WbemScripting.SWbemRefresher.1")
#define WBEMS_REF_VERSION		_T("1.0")
#define WBEMS_REF_VERDESC		_T("WBEM Scripting Refresher 1.0")

// Standard registry key/value names
#define WBEMS_RK_SCC		_T("SOFTWARE\\CLASSES\\CLSID\\")
#define WBEMS_RK_SC			_T("SOFTWARE\\CLASSES\\")
#define WBEMS_RK_THRDMODEL	_T("ThreadingModel")
#define WBEMS_RV_APARTMENT	_T("Apartment")
#define WBEMS_RK_PROGID		_T("ProgID")
#define WBEMS_RK_VERPROGID	_T("VersionIndependentProgID")
#define WBEMS_RK_TYPELIB	_T("TypeLib")
#define WBEMS_RK_VERSION	_T("Version")
#define	WBEMS_RK_INPROC32	_T("InProcServer32")
#define WBEMS_RK_CLSID		_T("CLSID")
#define WBEMS_RK_CURVER		_T("CurVer")
#define WBEMS_RK_PROGRAMMABLE	_T("Programmable")

// Other values
#define WBEMS_RK_WBEM		_T("Software\\Microsoft\\Wbem")
#define WBEMS_SK_SCRIPTING	_T("Scripting")

#define GUIDSIZE	128

// Count number of objects and number of