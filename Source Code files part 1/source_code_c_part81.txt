*******
//
//  CNtSecurityDescriptor assignment operator
//
//***************************************************************************
// ok

CNtSecurityDescriptor & CNtSecurityDescriptor::operator=(
    CNtSecurityDescriptor &Src
    )
{
    if (m_pSD)
        delete m_pSD;

    m_dwStatus = Src.m_dwStatus;
    m_pSD = 0;

    if (Src.m_pSD == 0)
        return *this;

    //SIZE_T dwSize = 2*GetSecurityDescriptorLength(Src.m_pSD);
    SIZE_T dwSize = GetSecurityDescriptorLength(Src.m_pSD);
    m_pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSize];
    if(m_pSD == NULL)
    {
        m_dwStatus = Failed;
    }
    else
    {
        ZeroMemory(m_pSD, dwSize);
        CopyMemory(m_pSD, Src.m_pSD, dwSize);
    }

    return *this;
}


//***************************************************************************
//
//  CNtSecurityDescriptor destructor.
//
//***************************************************************************
// ok

CNtSecurityDescriptor::~CNtSecurityDescriptor()
{
    if (m_pSD)
        delete m_pSD;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::GetSacl
//
//  Returns the SACL of the security descriptor.
//
//  Return value:
//  A newly allocated CNtAcl which contains the SACL.   This object
//  is a copy of the SACL and modifications made to it do not affect
//  the security descriptor.  The caller must use operator delete
//  to deallocate the CNtAcl.
//
//  Returns NULL on error or if no SACL is available.
//
//***************************************************************************
// ok

CNtAcl *CNtSecurityDescriptor::GetSacl()
{
    BOOL bSaclPresent = FALSE;
    BOOL bDefaulted;

    PACL pSacl;
    BOOL bRes = GetSecurityDescriptorSacl(
        m_pSD,
        &bSaclPresent,
        &pSacl,
        &bDefaulted
        );

    if (!bRes)
    {
        return 0;
    }

    if (!bSaclPresent)  // No Sacl present
        return 0;

    CNtAcl *pNewSacl = new CNtAcl(pSacl);

    return pNewSacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetSacl
//
//  Sets the SACL of the Security descriptor.
//
//  Parameters:
//  <pSrc>      A read-only pointer to the new DACL to replace the current one.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetSacl(CNtAcl *pSrc)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;

    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorSacl(
        pTmp->m_pSD,
        TRUE,
        pSrc->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetGroup
//
//***************************************************************************
// ok

CNtSid *CNtSecurityDescriptor::GetGroup()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    PSID pSid = 0;
    BOOL bDefaulted;

    BOOL bRes = GetSecurityDescriptorGroup(m_pSD, &pSid, &bDefaulted);

    if ( NULL == pSid )
    {
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor has no group\n"));
        return 0;
    }

    if (!bRes || !IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);

}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetGroup
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetGroup(CNtSid *pSid)
{
    if (m_dwStatus != NoError || m_pSD == 0 || NULL == pSid)
        return FALSE;

    if ( pSid->GetPtr() == NULL )
    {
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor is trying to bland out the group!\n"));
        return FALSE;
    }

    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorGroup(
        pTmp->m_pSD,
        pSid->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::HasOwner
//
//  Determines if a security descriptor has an owner.
//
//  Return values:
//      SDNotOwned, SDOwned, Failed
//
//***************************************************************************
// ok

int CNtSecurityDescriptor::HasOwner()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return Failed;

    PSID pSid = 0;

    BOOL bDefaulted;
    BOOL bRes = GetSecurityDescriptorOwner(m_pSD, &pSid, &bDefaulted);

    if (!bRes || !IsValidSid(pSid))
        return Failed;

    if (pSid == 0)
        return SDNotOwned;

    return SDOwned;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetOwner
//
//  Returns the SID of the owner of the Security Descriptor or NULL
//  if an error occurred or there is no owner.  Use HasOwner() to
//  determine this.
//
//***************************************************************************
// ok

CNtSid *CNtSecurityDescriptor::GetOwner()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    PSID pSid = 0;
    BOOL bDefaulted;

    BOOL bRes = GetSecurityDescriptorOwner(m_pSD, &pSid, &bDefaulted);

    // bad for a SD not to have an Owner, but it can be that way
    if ( NULL == pSid) return 0;

    if (!bRes || !IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetOwner
//
//  Sets the owner of a security descriptor.
//
//  Parameters:
//  <pSid>  The SID of the new owner.
//
//  Return Value:
//  TRUE if owner was changed, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetOwner(CNtSid *pSid)
{
    if (m_pSD == 0 || m_dwStatus != NoError || NULL == pSid)
        return FALSE;

    if (!pSid->IsValid())
        return FALSE;

    // bad practice to remove owner, but this might be the usage
    //_DBG_ASSERT(NULL != pSid->GetPtr());
    
    // We must convert to absolute format to make the change.
    // =======================================================
    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = SetSecurityDescriptorOwner(pTmp->m_pSD, pSid->GetPtr(), FALSE);

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    // If here, we have managed the change, so we have to
    // convert *this back from the temporary absolute SD.
    // ===================================================

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return bRes;
}



//***************************************************************************
//
//  CNtSecurityDescriptor::CNtSecurityDescriptor
//
//***************************************************************************
// ok

CNtSecurityDescriptor::CNtSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD,
    BOOL bAcquire
    )
{
    m_pSD = 0;
    m_dwStatus = NullSD;

    // Ensure that SD is not NULL.
    // ===========================

    if (pSD == 0)
    {
        if (bAcquire)
            delete pSD;
        return;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        m_dwStatus = InvalidSD;
        if (bAcquire)
            delete pSD;
        return;
    }

    // Ensure that SD is self-relative
    // ===============================

    SECURITY_DESCRIPTOR_CONTROL ctrl;
    DWORD dwRev;

    BOOL bRes = GetSecurityDescriptorControl(
        pSD,
        &ctrl,
        &dwRev
        );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        if (bAcquire)
            delete pSD;
        return;
    }

    if ((ctrl & SE_SELF_RELATIVE) == 0)
    {
        // If here, we have to conver the SD to self-relative form.
        // ========================================================

        DWORD dwRequired = 0;

        bRes = MakeSelfRelativeSD(
            pSD,
            m_pSD,
            &dwRequired
            );

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                delete pSD;
            return;
        }

        m_pSD = new BYTE[dwRequired];
        if (!m_pSD)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                delete pSD;
            return;
        }

        ZeroMemory(m_pSD, dwRequired);

        bRes = MakeSelfRelativeSD(
            pSD,
            m_pSD,
            &dwRequired
            );

        if (!bRes)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                delete pSD;
            return;
        }

        m_dwStatus = NoError;
        return;
    }


    // If here, the SD was already self-relative.
    // ==========================================

    if (bAcquire)
        m_pSD = pSD;
    else
    {
        DWORD dwRes = GetSecurityDescriptorLength(pSD);
        m_pSD = new BYTE[dwRes];
        if (!m_pSD)
        {
            m_dwStatus = InvalidSD;
            return;
        }

        ZeroMemory(m_pSD, dwRes);
        memcpy(m_pSD, pSD, dwRes);
    }

    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtSecurity::IsUserInGroup
//
//  Determines if the use belongs to a particular NTLM group.
//
//  Parameters:
//  <hToken>            The user's access token.
//  <Sid>               Object containing the sid of the group being tested.
//
//  Return value:
//  TRUE if the user belongs to the group.
//
//***************************************************************************

BOOL CNtSecurity::IsUserInGroup(
        HANDLE hAccessToken,
        CNtSid & Sid)
{
    if(NULL == hAccessToken ) return FALSE;

    BOOL bRetMember;
    if (CheckTokenMembership(hAccessToken,Sid.GetPtr(),&bRetMember))
    {
        return bRetMember;
    }
    return FALSE;
}

C9XAce::C9XAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser
        )
{
    m_wszFullName = NULL;
    if(pUser)
        m_wszFullName = Macro_CloneLPWSTR(pUser);
    m_dwAccess = Mask;
    m_iFlags = dwAceFlags;
    m_iType = AceType;
}

C9XAce::~C9XAce()
{
    if(m_wszFullName)
        delete [] m_wszFullName;
}

HRESULT C9XAce::GetFullUserName2(WCHAR ** pBuff)
{
    if(wcslen(m_wszFullName) < 1)
        return WBEM_E_FAILED;

    int iLen = wcslen(m_wszFullName)+4;
    *pBuff = new WCHAR[iLen];
    if(*pBuff == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // there are two possible formats, the first is "UserName", and the 
    // second is "domain\username".  

    WCHAR * pSlash;
    for(pSlash = m_wszFullName; *pSlash && *pSlash != L'\\'; pSlash++); // intentional

    if(*pSlash && pSlash > m_wszFullName)
    {
        // got a domain\user, convert to domain|user
        
        StringCchCopyW(*pBuff, iLen, m_wszFullName);
        for(pSlash = *pBuff; *pSlash; pSlash++)
            if(*pSlash == L'\\')
            {
                *pSlash = L'|';
                break;
            }
    }
    else
    {
        // got a "user", convert to ".|user"
    
        StringCchCopyW(*pBuff, iLen, L".|");
        StringCchCatW(*pBuff, iLen, m_wszFullName);
    }
    return S_OK;
}

//***************************************************************************
//
//  C9XAce::GetSerializedSize
//
//  Returns the number of bytes needed to store this
//
//***************************************************************************

DWORD C9XAce::GetSerializedSize()
{
    if (m_wszFullName == 0 || wcslen(m_wszFullName) == 0)
        return 0;
    return 2 * (wcslen(m_wszFullName) + 1) + 12;
}

//***************************************************************************
//
//  C9XAce::Serialize
//
//  Serializes the ace.  The serialized version will consist of
//  <DOMAIN\USERNAME LPWSTR><FLAGS><TYPE><MASK>
//
//  Note that the fields are dwords except for the name.
//
//***************************************************************************

bool C9XAce::Serialize(BYTE * pData, size_t bufferSize)
{
    if (FAILED(StringCbCopyW((LPWSTR)pData, bufferSize, m_wszFullName)))      return false;
    
    pData += 2*(wcslen(m_wszFullName) + 1);
    DWORD * pdwData = (DWORD *)pData;
    *pdwData = m_iFlags;
    pdwData++;
    *pdwData = m_iType;
    pdwData++;
    *pdwData = m_dwAccess;
    pdwData++;
    return true;
}

//***************************************************************************
//
//  C9XAce::Deserialize
//
//  Deserializes the ace.  See the comments for Serialize for comments.
//
//***************************************************************************

bool C9XAce::Deserialize(BYTE * pData)
{
    size_t stringSize = wcslen((LPWSTR)pData) + 1;
    m_wszFullName = new WCHAR[stringSize];
    if (!m_wszFullName)
        return false;

    StringCchCopyW(m_wszFullName, stringSize, (LPWSTR)pData);
    pData += 2*(wcslen(m_wszFullName) + 1);

    DWORD * pdwData = (DWORD *)pData;

    m_iFlags = *pdwData;
    pdwData++;
    m_iType = *pdwData;
    pdwData++;
    m_dwAccess = *pdwData;
    pdwData++;
    return true;

}

//***************************************************************************
//
//  BOOL SetObjectAccess2
//
//  DESCRIPTION:
//
//  Adds read/open and set access for the everyone group to an object.
//
//  PARAMETERS:
//
//  hObj                Object to set access on.
//
//  RETURN VALUE:
//
//  Returns TRUE if OK.
//
//***************************************************************************

BOOL SetObjectAccess2(IN HANDLE hObj)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwLastErr = 0;
    BOOL bRet = FALSE;

    // no point if we arnt on nt

    if(!IsNT())
    {
        return TRUE;
    }

    // figure out how much space to allocate

    DWORD dwSizeNeeded;
    bRet = GetKernelObjectSecurity(
                    hObj,           // handle of object to query
                    DACL_SECURITY_INFORMATION, // requested information
                    pSD,  // address of security descriptor
                    0,           // size of buffer for security descriptor
                    &dwSizeNeeded);  // address of required size of buffer

    if(bRet == TRUE || (ERROR_INSUFFICIENT_BUFFER != GetLastError()))
        return FALSE;

    pSD = new BYTE[dwSizeNeeded];
    if(pSD == NULL)
        return FALSE;

    // Get the data

    bRet = GetKernelObjectSecurity(
                    hObj,           // handle of object to query
                    DACL_SECURITY_INFORMATION, // requested information
                    pSD,  // address of security descriptor
                    dwSizeNeeded,           // size of buffer for security descriptor
                    &dwSizeNeeded ); // address of required size of buffer
    if(bRet == FALSE)
    {
        delete pSD;
        return FALSE;
    }
    
    // move it into object for

    CNtSecurityDescriptor sd(pSD,TRUE);    // Acquires ownership of the memory
    if(sd.GetStatus() != 0)
        return FALSE;
    CNtAcl acl;
    if(!sd.GetDacl(acl))
        return FALSE;

    // Create an everyone ace

    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;;

    if(AllocateAndInitializeSid( &id2, 1,
        0,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        CNtAce * pace = new CNtAce(EVENT_MODIFY_STATE | SYNCHRONIZE, ACCESS_ALLOWED_ACE_TYPE, 0 
                                                , SidUsers);
        if(pace == NULL)
            return FALSE;
        if( pace->GetStatus() == 0)
            acl.AddAce(pace);
        delete pace;

    }

    if(acl.GetStatus() != 0)
        return FALSE;
    sd.SetDacl(&acl);
    bRet = SetKernelObjectSecurity(hObj, DACL_SECURITY_INFORMATION, sd.GetPtr());
    return bRet;
}


//***************************************************************************
//
//  IsAdmin
//
//  returns TRUE if we are a member of the admin group or running as 
//  NETWORK_SERVICE or running as LOCAL_SERVICE
//
//***************************************************************************

BOOL IsAdmin(HANDLE hAccess)
{
    BOOL bRet = FALSE;
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid Sid(pRawSid);
        FreeSid( pRawSid );
        if (CNtSid::NoError != Sid.GetStatus()) return FALSE;
            
        bRet = CNtSecurity::IsUserInGroup(hAccess, Sid);

      
    }
    return bRet;
}


//***************************************************************************
//
//  IsNetworkService
//
//  returns TRUE if we are running as NETWORK_SERVICE
//
//***************************************************************************

BOOL IsNetworkService ( HANDLE hAccess )
{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Construct the NETWORK_SERVICE SID
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    PSID pSidSystem;
    BOOL bRes = FALSE;
    
    if ( AllocateAndInitializeSid(&id, 1, SECURITY_NETWORK_SERVICE_RID, 0, 0,0,0,0,0,0,&pSidSystem) )
    {
        if ( !CheckTokenMembership ( hAccess, pSidSystem, &bRes ) )
        {
            bRes = FALSE;
        }
        FreeSid ( pSidSystem );
    }

    return bRes;
}



//***************************************************************************
//
//  IsLocalService
//
//  returns TRUE if we are running as LOCAL_SERVICE
//
//***************************************************************************

BOOL IsLocalService ( HANDLE hAccess )
{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Construct the NETWORK_SERVICE SID
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    PSID pSidSystem;
    BOOL bRes = FALSE;
    
    if ( AllocateAndInitializeSid(&id, 1, SECURITY_LOCAL_SERVICE_RID, 0, 0,0,0,0,0,0,&pSidSystem) )
    {
        if ( !CheckTokenMembership ( hAccess, pSidSystem, &bRes ) )
        {
            bRes = FALSE;
        }
        FreeSid ( pSidSystem );
    }

    return bRes;
}


//***************************************************************************
//
//  IsInAdminGroup
//
//  returns TRUE if we are a member of the admin group.
//
//***************************************************************************

BOOL IsInAdminGroup()
{
    HANDLE hAccessToken = INVALID_HANDLE_VALUE;
    if(S_OK != GetAccessToken(hAccessToken))
        return TRUE;       // Not having a token indicates an internal thread

    CCloseHandle cm(hAccessToken);

    DWORD dwMask = 0;

    if(IsAdmin(hAccessToken))
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  HRESULT GetAccessToken
//
//  Gets the access token and sets it the the reference argument.
//
//***************************************************************************

HRESULT GetAccessToken(HANDLE &hAccessToken)
{

    bool bIsImpersonating = WbemIsImpersonating();

    HRESULT hRes = S_OK;
    if(bIsImpersonating == false)
        hRes = WbemCoImpersonateClient();
    if(hRes == S_OK)
    {
        BOOL bOK = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hAccessToken);
        if(bOK == FALSE)
        {
            hRes = WBEM_E_INVALID_CONTEXT;
        }
        else
            hRes = S_OK;
    }

    if(bIsImpersonating == false)
        WbemCoRevertToSelf();

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wbemutil.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMUTIL.CPP

Abstract:

    General utility functions prototypes and macros.

History:

    a-raymcc    17-Apr-96      Created.

--*/

#ifndef _WBEMUTIL_H_
#define _WBEMUTIL_H_
#include "corepol.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#include <stdio.h>


void _inline DbgPrintfA(ULONG_PTR pBuff, const char * fmt,...)
{
    char pBuff_[128];
    va_list argptr;
    va_start(argptr, fmt);
    StringCchVPrintfA(pBuff_,128,fmt,argptr);
    OutputDebugStringA(pBuff_);
    va_end(argptr);
};

//
// must be used this way DBG_PRINTFA((pBuff,"FormatString %s %d",Param1,Param2,etc))
//

#ifdef DBG
#define DBG_PRINTFA( a ) { ULONG_PTR pBuff = 0; DbgPrintfA a ; }
#else
#define DBG_PRINTFA( a )
#endif


BOOL POLARITY WbemGetMachineShutdown();
BOOL POLARITY WbemSetMachineShutdown(BOOL bVal);


#ifndef VARIANT_TRUE
#define VARIANT_TRUE ((VARIANT_BOOL) 0xFFFF)
#define VARIANT_FALSE (0)
#endif


#define DUP_STRING_NEW(dest,src) \
	{ size_t tmpLenDoNotReuse = wcslen(src)+1; \
	  dest = new wchar_t[tmpLenDoNotReuse]; \
	  if (dest) StringCchCopyW(dest,tmpLenDoNotReuse , src); }


#ifdef __cplusplus
inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    wchar_t *dest = new wchar_t[wcslen(src) + 1];
    if (!dest)
        return 0;
    memcpy(dest, src, sizeof(wchar_t)*(wcslen(src) + 1));
    return dest;
}
#endif

#if (defined DBG || defined _DBG)
#if defined(__cplusplus)
void inline PrintAssert(const wchar_t * msg) { OutputDebugStringW(msg); }
void inline PrintAssert(const char * msg) { OutputDebugStringA(msg); }
#else
void _inline PrintAssert(const wchar_t * msg) { OutputDebugStringW(msg); }
#endif


#pragma message("_ASSERTs are being expanded.")
#define _ASSERT(exp, msg)    { if (!(exp)) { PrintAssert( msg ); DebugBreak(); }     }
#else
#define _ASSERT(exp, msg)
#endif

#ifdef DBG
#define _DBG_MSG_ASSERT(X, msg) { if (!(X)) { OutputDebugStringW( msg ); DebugBreak(); } }
#define _DBG_ASSERT(X) { if (!(X)) { DebugBreak(); } }
#else
#define _DBG_MSG_ASSERT(X, msg)
#define _DBG_ASSERT(X)
#endif


//LOGGING module.
//This is an index into an array in wbemutil.cpp which uses
//the filenames specified next
#define LOG_WBEMCORE    0
#define LOG_WINMGMT     1
#define LOG_ESS         2
#define LOG_WBEMPROX    3
#define LOG_WBEMSTUB    4
#define LOG_QUERY       5
#define LOG_MOFCOMP     6
#define LOG_EVENTLOG    7
#define LOG_WBEMDISP    8
#define LOG_STDPROV     9
#define LOG_WIMPROV     10
#define LOG_WMIOLEDB    11
#define LOG_WMIADAP     12
#define LOG_REPDRV		13
#define LOG_PROVSS		14
#define LOG_EVTPROV	15
#define LOG_VIEWPROV	16
#define LOG_DSPROV      17
#define LOG_SNMPPROV	18
#define LOG_PROVTHRD    19
#define LOG_MAX_PROV	20


//These are the log file names (possibly other things
//as well!) which is used in conjunction with the above
//ids.
#define FILENAME_PREFIX_CORE TEXT("wbemcore")
#define FILENAME_PREFIX_EXE TEXT("WinMgmt")
#define FILENAME_PREFIX_EXE_W L"WinMgmt"
#define FILENAME_PREFIX_CLI_MARSH TEXT("wbemprox")
#define FILENAME_PREFIX_SERV_MARSH TEXT("wbemstub")
#define FILENAME_PREFIX_ESS TEXT("wbemess")
#define FILENAME_PREFIX_QUERY TEXT("query")
#define FILENAME_PROFIX_MOFCOMP TEXT("mofcomp")
#define FILENAME_PROFIX_EVENTLOG TEXT("eventlog")
#define FILENAME_PROFIX_WBEMDISP TEXT("wbemdisp")
#define FILENAME_PROFIX_STDPROV TEXT("stdprov")
#define FILENAME_PROFIX_WMIPROV TEXT("wmiprov")
#define FILENAME_PROFIX_WMIOLEDB TEXT("wmioledb")
#define FILENAME_PREFIX_WMIADAP TEXT("wmiadap")
#define FILENAME_PREFIX_REPDRV TEXT("replog")
#define FILENAME_PREFIX_PROVSS TEXT("provss")
#define FILENAME_PREFIX_EVTPROV TEXT("ntevt")
#define FILENAME_PREFIX_VIEWPROV TEXT("viewprov")
#define FILENAME_PREFIX_DSPROV   TEXT("dsprovider")
#define FILENAME_PREFIX_SNMPPROV   TEXT("wbemsnmp")
#define FILENAME_PREFIX_PROVTHRD   TEXT("provthrd")

// True if unicode identifier, _, a-z, A-Z or 0x100-0xffef
BOOL POLARITY isunialpha(wchar_t c);
BOOL POLARITY isunialphanum(wchar_t c);
BOOL POLARITY IsValidElementName(LPCWSTR wszName, DWORD MaxAllow);
// Can't use overloading and/or default parameters because
// "C" files use these guys.  No, I'm not happy about
// this!
BOOL POLARITY IsValidElementName2(LPCWSTR wszName, DWORD MaxAllow, BOOL bAllowUnderscore);
BOOL POLARITY LoggingLevelEnabled(DWORD nLevel);
DWORD POLARITY GetLoggingLevelEnabled();

#define TRACE(x) DebugTrace x
#define ERRORTRACE(x) ErrorTrace x
#define DEBUGTRACE(x)   DebugTrace x

int POLARITY DebugTrace(char cCaller, const char *fmt, ...);
int POLARITY ErrorTrace(char cCaller, const char *fmt, ...);

int POLARITY CriticalFailADAPTrace(const char *string);

// BLOB manipulation.
// ==================

BLOB  POLARITY BlobCopy(const BLOB *pSrc);
void  POLARITY BlobClear(BLOB *pSrc);
void  POLARITY BlobAssign(BLOB *pSrc, LPVOID pBytes, DWORD dwCount, BOOL bAcquire);

#define BlobInit(p) \
    ((p)->cbSize = 0, (p)->pBlobData = 0)

#define BlobLength(p)  ((p)->cbSize)
#define BlobDataPtr(p) ((p)->pBlobData)

// Object ref count helpers.
// =========================
void ObjectCreated(DWORD,IUnknown * pThis);
void ObjectDestroyed(DWORD,IUnknown * pThis);

#define MAX_OBJECT_TYPES            16

#define OBJECT_TYPE_LOCATOR         0
#define OBJECT_TYPE_CLSOBJ          1
#define OBJECT_TYPE_PROVIDER        2
#define OBJECT_TYPE_QUALIFIER       3
#define OBJECT_TYPE_NOTIFY          4
#define OBJECT_TYPE_OBJENUM         5
#define OBJECT_TYPE_FACTORY         6
#define OBJECT_TYPE_WBEMLOGIN       7
#define OBJECT_TYPE_WBEMLOGINHELP   8
#define OBJECT_TYPE_CORE_BUSY       9
#define OBJECT_TYPE_STATUS         10
#define OBJECT_TYPE_BACKUP_RESTORE 11
#define OBJECT_TYPE_PATH_PARSER    12
#define OBJECT_TYPE_WMIARRAY	   13
#define OBJECT_TYPE_OBJ_FACTORY    14
#define OBJECT_TYPE_FREEFORM_OBJ   15

//Creates directories recursively
BOOL POLARITY WbemCreateDirectory(const TCHAR *szDirectory);

HRESULT POLARITY TestDirExistAndCreateWithSDIfNotThere(TCHAR * pDirectory, TCHAR * pSDDLString);

#define VT_EMBEDDED_OBJECT VT_UNKNOWN
#define V_EMBEDDED_OBJECT(VAR) V_UNKNOWN(VAR)
#define I_EMBEDDED_OBJECT IUnknown

#define IDISPATCH_METHODS_STUB \
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo) \
    {return E_NOTIMPL;}                         \
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)\
    {return E_NOTIMPL;}                                                 \
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,\
      LCID lcid, DISPID* rgdispid)                                          \
    {return E_NOTIMPL;}                                                      \
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,\
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,     \
      UINT* puArgErr)                                                          \
{return E_NOTIMPL;} \

// Quick WCHAR to MBS conversion helper
BOOL POLARITY AllocWCHARToMBS( WCHAR* pWstr, char** ppStr );

// Helpers needed in a couple of places.
LPTSTR POLARITY GetWMIADAPCmdLine( int nExtra );

BOOL POLARITY IsNtSetupRunning();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\winntsec.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINNTSEC.H

Abstract:

    Generic wrapper classes for NT security objects.

    Documention on class members is in WINNTSEC.CPP.  Inline members
    are commented in this file.

History:

    raymcc      08-Jul-97       Created.

--*/

#ifndef _WINNTSEC_H_
#define _WINNTSEC_H_

class POLARITY CNtSecurity;

// All ACE types are currently have the same binary layout. Rather
// than doing a lot of useless casts, we produce a general-purpose
// typedef to hold all ACEs.
// ================================================================

typedef ACCESS_ALLOWED_ACE GENERIC_ACE;
typedef GENERIC_ACE *PGENERIC_ACE;

#define FULL_CONTROL     \
        (DELETE |       \
         READ_CONTROL | \
        WRITE_DAC |         \
        WRITE_OWNER |   \
        SYNCHRONIZE | GENERIC_ALL)


//***************************************************************************
//
//  CNtSid
//
//  Models SIDs (users/groups).
//
//***************************************************************************

class POLARITY CNtSid
{
    PSID    m_pSid;
    LPWSTR  m_pMachine;
    DWORD   m_dwStatus;
    SID_NAME_USE m_snu;

public:
    enum { NoError, Failed, NullSid, InvalidSid, InternalError, AccessDenied = 0x5 };

    enum SidType {CURRENT_USER, CURRENT_THREAD};

    CNtSid(SidType st);
    CNtSid() { m_pSid = 0; m_pMachine = 0; m_dwStatus = NullSid; }
    bool IsUser(){return m_snu == SidTypeUser;};

    CNtSid(PSID pSrc);
        // Construct based on another SID.
    CNtSid(LPWSTR pUser, LPWSTR pMachine = 0);
        // Construct based on a user (machine name is optional).

   ~CNtSid();

    explicit CNtSid( const CNtSid &Src);
    CNtSid &operator =( const CNtSid &Src);

    int operator ==(CNtSid &Comparand);

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    PSID GetPtr() { return m_pSid; }
        // Returns the internal SID ptr to interface with NT APIs
    DWORD GetSize();

    BOOL CopyTo(PSID pDestination);

    BOOL IsValid() { return (m_pSid && IsValidSid(m_pSid)); }
        // Checks the validity of the internal SID.

    int GetInfo(
        LPWSTR *pRetAccount,        // Account, use operator delete
        LPWSTR *pRetDomain,         // Domain, use operator delete
        DWORD  *pdwUse              // See SID_NAME_USE for values
        );

    BOOL GetTextSid(LPTSTR pszSidText, LPDWORD dwBufferLen);

};

//***************************************************************************
//
//  CBaseAce
//
//  Base class for aces.
//
//***************************************************************************

class POLARITY CBaseAce
{

public:

    CBaseAce(){};
    virtual ~CBaseAce(){};

    virtual int GetType() = 0;
    virtual int GetFlags() = 0;         // inheritance etc.
    virtual ACCESS_MASK GetAccessMask() = 0;
    virtual HRESULT GetFullUserName2(WCHAR ** pBuff) = 0; // call must free
    virtual DWORD GetStatus() = 0;
    virtual void SetFlags(long lFlags) =0;
    virtual DWORD GetSerializedSize() = 0;
    virtual bool  Serialize(BYTE * pData, size_t buffersize)=0;
    virtual bool  Deserialize(BYTE * pData) = 0;
};


//***************************************************************************
//
//  CNtAce
//
//  Models NT ACEs.
//
//***************************************************************************

class POLARITY CNtAce : public CBaseAce
{
    PGENERIC_ACE    m_pAce;
    DWORD           m_dwStatus;

public:
    enum { NoError, InvalidAce, NullAce, InternalError };

    CNtAce() { m_pAce = 0; m_dwStatus = NullAce; }

    CNtAce(PGENERIC_ACE pAceSrc);
    CNtAce(const CNtAce &Src);
    CNtAce & operator =(const CNtAce &Src);

   ~CNtAce();

   CNtAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser,
        LPWSTR pMachine = 0         // Defaults to local machine
        );

    CNtAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        CNtSid & Sid
        );

    int GetType();
    int GetFlags();         // inheritance etc.
    void SetFlags(long lFlags){m_pAce->Header.AceFlags = (unsigned char)lFlags;};

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    int GetSubject(
        LPWSTR *pSubject
        );

    ACCESS_MASK GetAccessMask();

    CNtSid *GetSid();
    BOOL GetSid(CNtSid &Dest);

    PGENERIC_ACE GetPtr() { return m_pAce; }
    DWORD GetSize() { return m_pAce ? m_pAce->Header.AceSize : 0; }
    HRESULT GetFullUserName2(WCHAR ** pBuff); // call must free
    DWORD GetSerializedSize();
    bool Serialize(BYTE * pData, size_t bufferSize);
    bool Deserialize(BYTE * pData);

};


//***************************************************************************
//
//  C9XAce
//
//  Simulates NT ACEs for 9X boxs.
//
//***************************************************************************

class POLARITY C9XAce : public CBaseAce
{
    LPWSTR m_wszFullName;
    DWORD m_dwAccess;
    int m_iFlags;
    int m_iType;
public:

   C9XAce(){m_wszFullName = 0;};
   C9XAce(DWORD Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser);
   ~C9XAce();

    int GetType(){return m_iType;};
    int GetFlags(){return m_iFlags;};         // inheritance etc.

    ACCESS_MASK GetAccessMask(){return m_dwAccess;};
    HRESULT GetFullUserName2(WCHAR ** pBuff); // call must free
    DWORD GetStatus(){ return CNtAce::NoError; };
    void SetFlags(long lFlags){m_iFlags = (unsigned char)lFlags;};
    DWORD GetSerializedSize();
    bool Serialize(BYTE * pData, size_t buferSize);
    bool Deserialize(BYTE * pData);

};


//***************************************************************************
//
//  CNtAcl
//
//  Models an NT ACL.
//
//***************************************************************************

class POLARITY CNtAcl
{
    PACL    m_pAcl;
    DWORD   m_dwStatus;

public:
    enum { NoError, InternalError, NullAcl, InvalidAcl };
    enum { MinimumSize = 1 };

    CNtAcl(DWORD dwInitialSize = 128);

    CNtAcl(const CNtAcl &Src);
    CNtAcl & operator = (const CNtAcl &Src);

    CNtAcl(PACL pAcl);  // Makes a copy
   ~CNtAcl();

    int  GetNumAces();

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

	BOOL ContainsSid ( CNtSid& sid, BYTE& flags ) ;

    CNtAce *GetAce(int nIndex);
    BOOL GetAce(int nIndex, CNtAce &Dest);

    BOOL DeleteAce(int nIndex);
    BOOL AddAce(CNtAce *pAce);
	CNtAcl* OrderAces ( ) ;

    BOOL IsValid() { return(m_pAcl && IsValidAcl(m_pAcl)); }
        // Checks the validity of the embedded ACL.

    BOOL Resize(DWORD dwNewSize);
        // Or use CNtAcl::MinimumSize to trim the ACL to min size.
        // Fails if an illegal size is specified.

    DWORD GetSize();

    PACL GetPtr() { return m_pAcl; }
        // Returns the internal pointer for interface with NT APIs.

    BOOL GetAclSizeInfo(
        PDWORD pdwBytesInUse,
        PDWORD pdwBytesFree
        );

};

//***************************************************************************
//
//  SNtAbsoluteSD
//
//  Helper for converting between absolute and relative SDs.
//
//***************************************************************************

struct SNtAbsoluteSD
{
    PSECURITY_DESCRIPTOR m_pSD;

    PACL m_pDacl;
    PACL m_pSacl;
    PSID m_pOwner;
    PSID m_pPrimaryGroup;

    SNtAbsoluteSD();
   ~SNtAbsoluteSD();
};

//***************************************************************************
//
//  CNtSecurityDescriptor
//
//  Models an NT Security Descriptor.  Note that in order to use this for an
//  AccessCheck, the DACL, owner sid, and group sid must be set!
//
//***************************************************************************

class POLARITY CNtSecurityDescriptor
{
    PSECURITY_DESCRIPTOR m_pSD;
    int m_dwStatus;


public:
    enum { NoError, NullSD, Failed, InvalidSD, SDOwned, SDNotOwned };

    CNtSecurityDescriptor();

    CNtSecurityDescriptor(
        PSECURITY_DESCRIPTOR pSD,
        BOOL bAcquire = FALSE
        );

    CNtSecurityDescriptor(CNtSecurityDescriptor &Src);
    CNtSecurityDescriptor & operator=(CNtSecurityDescriptor &Src);

    ~CNtSecurityDescriptor();

    SNtAbsoluteSD* CNtSecurityDescriptor::GetAbsoluteCopy();
    BOOL SetFromAbsoluteCopy(SNtAbsoluteSD *pSrc);

    int HasOwner();

    BOOL IsValid() { return(m_pSD && IsValidSecurityDescriptor(m_pSD)); }
        // Checks the validity of the embedded security descriptor&

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    CNtAcl *GetDacl();
        // Deallocate with operator delete

    BOOL GetDacl(CNtAcl &DestAcl);
        // Retrieve into an existing object

    BOOL SetDacl(CNtAcl *pSrc);

    CNtAcl *GetSacl();
        // Deallocate with operator delete

    BOOL SetSacl(CNtAcl *pSrc);

    CNtSid *GetOwner();
    BOOL SetOwner(CNtSid *pSid);

    CNtSid *GetGroup();
    BOOL SetGroup(CNtSid *pSid);

    PSECURITY_DESCRIPTOR GetPtr() { return m_pSD; }
        // Returns the internal pointer for interface with NT APIs

    DWORD GetSize();

};

//***************************************************************************
//
//  CNtSecurity
//
//  General-purpose NT security helpers.
//
//***************************************************************************

class POLARITY CNtSecurity
{
public:
    enum { NoError, InternalFailure, NotFound, InvalidName, AccessDenied = 5, NoSecurity,
           Failed };

    static BOOL IsUserInGroup(
        HANDLE hClientToken,
        CNtSid & Sid
        );


};

BOOL FIsRunningAsService(VOID);
POLARITY BOOL SetObjectAccess2(HANDLE hObj);
POLARITY BOOL IsAdmin(HANDLE hAccess);
POLARITY BOOL IsNetworkService(HANDLE hAccess);
POLARITY BOOL IsLocalService(HANDLE hAccess);
POLARITY HRESULT GetAccessToken(HANDLE &hAccessToken);
POLARITY BOOL IsInAdminGroup();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wbemutil.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMUTIL.CPP

Abstract:

    General utility functions.

History:

    a-raymcc    17-Apr-96      Created.

--*/

#include "precomp.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>
#include <wbemutil.h>
#include <corex.h>
#include "reg.h"
#include "sync.h"
#include <statsync.h>
#include <ARRTEMPL.H>

static BOOL g_bMachineDown = FALSE;

BOOL WbemGetMachineShutdown()
{
    return g_bMachineDown;
};
BOOL WbemSetMachineShutdown(BOOL bVal)
{
    BOOL bTmp = g_bMachineDown;
    g_bMachineDown = bVal;
    return bTmp;
}


class AutoRevert
{
private:
    HANDLE oldToken_;
    BOOL SetThrTokResult_;
    bool self_;
public:
    AutoRevert();
    ~AutoRevert();
    void dismiss();
    bool self(){ return self_;}
};

AutoRevert::AutoRevert():oldToken_(NULL),self_(true),SetThrTokResult_(FALSE)
{
    if (OpenThreadToken(GetCurrentThread(),TOKEN_IMPERSONATE,TRUE,&oldToken_))
    {
        RevertToSelf();
    }
    else
    {
        if (GetLastError() != ERROR_NO_TOKEN)
            self_ = false;
    };
}

AutoRevert::~AutoRevert()
{
    dismiss();
}

void AutoRevert::dismiss()    
{
    if (oldToken_)
    {
        // if the handle has been opened with TOKEN_IMPERSONATE
        // and if nobody has touched the SD for the ETHREAD object, this will work
        SetThrTokResult_ = SetThreadToken(NULL,oldToken_);
        CloseHandle(oldToken_);
    }
}

//***************************************************************************
//
//  BOOL isunialpha(wchar_t c)
//
//  Used to test if a wide character is a unicode character or underscore.
//
//  Parameters:
//      c = The character being tested.
//  Return value:
//      TRUE if OK.
// 
//***************************************************************************

BOOL POLARITY isunialpha(wchar_t c)
{
    if(c == 0x5f || (0x41 <= c && c <= 0x5a) ||
       (0x61  <= c && c <= 0x7a) || (0x80  <= c && c <= 0xfffd))
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  BOOL isunialphanum(char_t c)
//
//  Used to test if a wide character is string suitable for identifiers.
//
//  Parameters:
//      pwc = The character being tested.
//  Return value:
//      TRUE if OK.
// 
//***************************************************************************

BOOL POLARITY isunialphanum(wchar_t c)
{
    if(isunialpha(c))
        return TRUE;
    else
        return wbem_iswdigit(c);
}

BOOL IsValidElementName( LPCWSTR wszName, DWORD MaxAllow )
{
    if(wszName[0] == 0)
        return FALSE;

    if(wszName[0] == '_')
        return FALSE;

    const WCHAR* pwc = wszName;

    LPCWSTR pTail = wszName+MaxAllow+1;

    // Check the first letter
    // ======================

    // this is for compatibility with IWbemPathParser
    if (iswspace(pwc[0])) 
        return FALSE;        

    if(!isunialpha(*pwc))
        return FALSE;
    pwc++;

    // Check the rest
    // ==============

    while(*pwc && (pwc < pTail))
    {
        if(!isunialphanum(*pwc))
            return FALSE;
        pwc++;
    }

    if ( pwc == pTail ) return FALSE;

    if (iswspace(*(pwc-1)))
        return FALSE;

    if(pwc[-1] == '_')
        return FALSE;

    return TRUE;
}

// Can't use overloading and/or default parameters because 
// "C" files use these guys.  No, I'm not happy about
// this!
BOOL IsValidElementName2( LPCWSTR wszName,DWORD MaxAllow, BOOL bAllowUnderscore )
{
    if(wszName[0] == 0)
        return FALSE;

    if(!bAllowUnderscore && wszName[0] == '_')
        return FALSE;

    const WCHAR* pwc = wszName;

    LPCWSTR pTail = wszName+MaxAllow+1;

    // Check the first letter
    // ======================

    // this is for compatibility with IWbemPathParser
    if (iswspace(pwc[0])) 
        return FALSE;    

    if(!isunialpha(*pwc))
        return FALSE;
    pwc++;

    // Check the rest
    // ==============

    while(*pwc && (pwc < pTail))
    {
        if(!isunialphanum(*pwc))
            return FALSE;
        pwc++;
    }

    if ( pwc == pTail ) return FALSE;    

    if (iswspace(*(pwc-1)))
        return FALSE;

    if(!bAllowUnderscore && pwc[-1] == '_')
        return FALSE;

    return TRUE;
}

BLOB POLARITY BlobCopy(const BLOB *pSrc)
{
    BLOB Blob;
    BYTE *p = new BYTE[pSrc->cbSize];

    // Check for allocation failure
    if ( NULL == p )
    {
        throw CX_MemoryException();
    }

    Blob.cbSize = pSrc->cbSize;
    Blob.pBlobData = p;
    memcpy(p, pSrc->pBlobData, Blob.cbSize);
    return Blob;
}

void POLARITY BlobAssign(BLOB *pBlob, LPVOID pBytes, DWORD dwCount, BOOL bAcquire)
{
    BYTE *pSrc = 0;
    if (bAcquire) 
        pSrc = (BYTE *) pBytes;
    else {
        pSrc = new BYTE[dwCount];

        // Check for allocation failure
        if ( NULL == pSrc )
        {
            throw CX_MemoryException();
        }

        memcpy(pSrc, pBytes, dwCount);
    }            
    pBlob->cbSize = dwCount;
    pBlob->pBlobData = pSrc;            
}

void POLARITY BlobClear(BLOB *pSrc)
{
    if (pSrc->pBlobData) 
        delete pSrc->pBlobData;

    pSrc->pBlobData = 0;
    pSrc->cbSize = 0;
}


class __Trace
{
    struct ARMutex
    {
    HANDLE h_;
    ARMutex(HANDLE h):h_(h){}
    ~ARMutex(){ ReleaseMutex(h_);}
    };

public:
    enum { REG_CHECK_INTERVAL =1000 * 60 };

    DWORD m_dwLogging;
    DWORD m_dwMaxLogSize;
    DWORD m_dwTimeLastRegCheck;
    wchar_t m_szLoggingDirectory[MAX_PATH+1];
    char m_szTraceBuffer[2048];
    char m_szTraceBuffer2[4096];
    wchar_t m_szBackupFileName[MAX_PATH+1];
    wchar_t m_szLogFileName[MAX_PATH+1];
    static const wchar_t *m_szLogFileNames[];

    BOOL LoggingLevelEnabled(DWORD dwLevel);
    DWORD GetLoggingLevel();
    int Trace(char caller, const char *fmt, va_list &argptr);
    __Trace();
    ~__Trace();
    HANDLE get_logfile(const wchar_t * name );
private:
    void ReadLogDirectory();
    void ReReadRegistry();
    HANDLE buffers_lock_;
};

const wchar_t * __Trace::m_szLogFileNames[] = 
                                { FILENAME_PREFIX_CORE       TEXT(".log"),
                                  FILENAME_PREFIX_EXE        TEXT(".log"),
                                  FILENAME_PREFIX_ESS        TEXT(".log"),
                                  FILENAME_PREFIX_CLI_MARSH  TEXT(".log"),
                                  FILENAME_PREFIX_SERV_MARSH TEXT(".log"),
                                  FILENAME_PREFIX_QUERY      TEXT(".log"),
                                  FILENAME_PROFIX_MOFCOMP    TEXT(".log"),
                                  FILENAME_PROFIX_EVENTLOG   TEXT(".log"),
                                  FILENAME_PROFIX_WBEMDISP   TEXT(".log"),
                                  FILENAME_PROFIX_STDPROV    TEXT(".log"),
                                  FILENAME_PROFIX_WMIPROV    TEXT(".log"),
                                  FILENAME_PROFIX_WMIOLEDB   TEXT(".log"),
                                  FILENAME_PREFIX_WMIADAP    TEXT(".log"),
                                  FILENAME_PREFIX_REPDRV     TEXT(".log"),
                                  FILENAME_PREFIX_PROVSS     TEXT(".log"),
                                  FILENAME_PREFIX_EVTPROV   TEXT(".log"),
                                  FILENAME_PREFIX_VIEWPROV   TEXT(".log"),
                                  FILENAME_PREFIX_DSPROV     TEXT(".log"),
				  FILENAME_PREFIX_SNMPPROV     TEXT(".log"),
                                  FILENAME_PREFIX_PROVTHRD   TEXT(".log")
                                  };

__Trace __g_traceInfo;

__Trace::__Trace()
    : m_dwLogging(1), 
      m_dwMaxLogSize(65536), 
      m_dwTimeLastRegCheck(GetTickCount())
{
    buffers_lock_ = CreateMutexA(0,0,0);
    if (NULL == buffers_lock_) 
    {
        CStaticCritSec::SetFailure();
        return;
    }
    ReadLogDirectory();
    ReReadRegistry();
}

__Trace::~__Trace()
{
    if (buffers_lock_) CloseHandle(buffers_lock_);
};

void __Trace::ReReadRegistry()
{
    Registry r(WBEM_REG_WINMGMT, KEY_READ);

    //Get the logging level
    if (r.GetDWORDStr(TEXT("Logging"), &m_dwLogging) != Registry::no_error)
    {
        m_dwLogging = 1;
        r.SetDWORDStr(TEXT("Logging"), m_dwLogging);
    }

    //Get the maximum log file size
    if (r.GetDWORDStr(TEXT("Log File Max Size"), &m_dwMaxLogSize) != Registry::no_error)
    {
        m_dwMaxLogSize = 65536;
        r.SetDWORDStr(TEXT("Log File Max Size"), m_dwMaxLogSize);
    }
}
void __Trace::ReadLogDirectory()
{
    Registry r(WBEM_REG_WINMGMT);

    //Retrieve the logging directory
    TCHAR *tmpStr = 0;
    
    if ((r.GetStr(TEXT("Logging Directory"), &tmpStr) == Registry::failed) ||
        (lstrlen(tmpStr) > (MAX_PATH)))
    {
        delete [] tmpStr;   //Just in case someone was trying for a buffer overrun with a long path in the registry...

        if (GetSystemDirectory(m_szLoggingDirectory, MAX_PATH+1) == 0)
        {
            StringCchCopy(m_szLoggingDirectory, MAX_PATH+1, TEXT("c:\\"));
        }
        else
        {
            StringCchCat(m_szLoggingDirectory,  MAX_PATH+1, TEXT("\\WBEM\\Logs\\"));
            r.SetStr(TEXT("Logging Directory"), m_szLoggingDirectory);
       }
    }
    else
    {
        StringCchCopy(m_szLoggingDirectory,  MAX_PATH+1, tmpStr);
        //make sure there is a '\' on the end of the path...
        if (m_szLoggingDirectory[lstrlen(m_szLoggingDirectory) - 1] != '\\')
        {
            StringCchCat(m_szLoggingDirectory,  MAX_PATH+1,TEXT("\\"));
            r.SetStr(TEXT("Logging Directory"), m_szLoggingDirectory);
        }
        delete [] tmpStr;
    }

    //Make sure directory exists
    WbemCreateDirectory(m_szLoggingDirectory);
}



HANDLE __Trace::get_logfile(const wchar_t * file_name )
{

    AutoRevert revert; 
    if (revert.self()==false)
        return INVALID_HANDLE_VALUE;

HANDLE hTraceFile = INVALID_HANDLE_VALUE;
bool bDoneWrite = false;

//Keep trying to open the file
while (!bDoneWrite)
{
    while (hTraceFile == INVALID_HANDLE_VALUE)
    {
        if (WaitForSingleObject(buffers_lock_,-1)==WAIT_FAILED)
            return INVALID_HANDLE_VALUE;

        StringCchCopy(m_szLogFileName, MAX_PATH+1, m_szLoggingDirectory);;
        StringCchCat(m_szLogFileName, MAX_PATH+1, file_name);

        hTraceFile = ::CreateFileW( m_szLogFileName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_DELETE,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
                                 NULL );
        if ( hTraceFile  == INVALID_HANDLE_VALUE ) 
        {
            ReleaseMutex(buffers_lock_);
            if (GetLastError() == ERROR_SHARING_VIOLATION)
            {
                Sleep(20);
            }
            else
            {
                return INVALID_HANDLE_VALUE;
            }

        }
    }

    ARMutex arm(buffers_lock_);
    //
    //  Now move the file pointer to the end of the file
    //
    LARGE_INTEGER liSize;
    liSize.QuadPart = 0;
    if ( !::SetFilePointerEx( hTraceFile,
                                  liSize,
                                  NULL,
                                  FILE_END ) ) 
    {
            CloseHandle( hTraceFile );
            return INVALID_HANDLE_VALUE;
    } 


    bDoneWrite = true;
    //Rename file if file length is exceeded
    LARGE_INTEGER liMaxSize;
    liMaxSize.QuadPart = m_dwMaxLogSize;
    if (GetFileSizeEx(hTraceFile, &liSize))
    {
        if (liSize.QuadPart > liMaxSize.QuadPart)
        {

            StringCchCopy(m_szBackupFileName, MAX_PATH+1, m_szLogFileName);
            StringCchCopy(m_szBackupFileName + lstrlen(m_szBackupFileName) - 3, MAX_PATH+1, TEXT("lo_"));
            DeleteFile(m_szBackupFileName);
            if (MoveFile(m_szLogFileName, m_szBackupFileName) == 0)
            {
                if ( liSize.QuadPart < liMaxSize.QuadPart*2)
                    return hTraceFile;
                else
                {
                    CloseHandle(hTraceFile);
                    return INVALID_HANDLE_VALUE;
                };
            }
                
            //Need to re-open the file!
            bDoneWrite = false;
            CloseHandle(hTraceFile);
            hTraceFile = INVALID_HANDLE_VALUE;
        }
    }
}
return hTraceFile;
};


int __Trace::Trace(char caller, const char *fmt, va_list &argptr)
{

    HANDLE hTraceFile = INVALID_HANDLE_VALUE;
    
    try
    {
        if (caller >= (sizeof(m_szLogFileNames) / sizeof(char)))
            caller = 0;

        hTraceFile  = get_logfile(m_szLogFileNames[caller]);
        if (hTraceFile == INVALID_HANDLE_VALUE)
          return 0;
        CCloseMe ch(hTraceFile);

        if (WaitForSingleObject(buffers_lock_,-1)==WAIT_FAILED)
            return 0;
        ARMutex arm(buffers_lock_);

        // Get time.
        // =========
        char timebuf[64];
        time_t now = time(0);
        struct tm *local = localtime(&now);
        if(local)
        {
            StringCchCopyA(timebuf, 64, asctime(local));
            timebuf[strlen(timebuf) - 1] = 0;   // O
        }
        else
        {
            StringCchCopyA(timebuf, 64, "??");
        }
        //Put time in start of log
        StringCchPrintfA(m_szTraceBuffer, 2048, "(%s.%d) : ", timebuf, GetTickCount());

        //Format the user string
        int nLen = strlen(m_szTraceBuffer);
        StringCchVPrintfA(m_szTraceBuffer + nLen, 2048 - nLen, fmt, argptr);

        //Unfortunately, lots of people only put \n in the string, so we need to convert the string...
        int nLen2 = 0;
        char *p = m_szTraceBuffer;
        char *p2 = m_szTraceBuffer2;
        for (; *p; p++,p2++,nLen2++)
        {
            if (*p == '\n')
            {
                *p2 = '\r';
                p2++;
                nLen2++;
                *p2 = '\n';
            }
            else
            {
                *p2 = *p;
            }
        }
        *p2 = '\0';

        //
        //  Write to file :
        //
        DWORD dwWritten;
        ::WriteFile( hTraceFile, m_szTraceBuffer2, nLen2, &dwWritten, NULL);

        return 1;
    }
    catch(...)
    { 
        return 0;
    }
}


BOOL __Trace::LoggingLevelEnabled(DWORD dwLevel)
{
    if (!WbemGetMachineShutdown()) // prevent touching registry during machine shutdown
    {
        DWORD dwCurTicks = GetTickCount();
        if (dwCurTicks - m_dwTimeLastRegCheck > REG_CHECK_INTERVAL)
        {
            ReReadRegistry();
            m_dwTimeLastRegCheck = dwCurTicks;
        }
    }
        
    if ((dwLevel > m_dwLogging))
        return FALSE;
    else
        return TRUE;
   
}

DWORD __Trace::GetLoggingLevel()
{
    if (!WbemGetMachineShutdown()) // prevent touching registry during machine shutdown
    {
        DWORD dwCurTicks = GetTickCount();
        if (dwCurTicks - m_dwTimeLastRegCheck > REG_CHECK_INTERVAL)
        {
            ReReadRegistry();
            m_dwTimeLastRegCheck = dwCurTicks;
        }
    }
        
    return m_dwLogging;
};

DWORD GetLoggingLevelEnabled()
{
    return __g_traceInfo.GetLoggingLevel();
}


BOOL LoggingLevelEnabled(DWORD dwLevel)
{
    return __g_traceInfo.LoggingLevelEnabled(dwLevel);
}
int ErrorTrace(char caller, const char *fmt, ...)
{
    if (__g_traceInfo.LoggingLevelEnabled(1))
    {
        va_list argptr;
        va_start(argptr, fmt);
        __g_traceInfo.Trace(caller, fmt, argptr);
        va_end(argptr);
        return 1;
    }
    else
        return 0;
}
int DebugTrace(char caller, const char *fmt, ...)
{
    if (__g_traceInfo.LoggingLevelEnabled(2))
    {
        va_list argptr;
        va_start(argptr, fmt);
        __g_traceInfo.Trace(caller, fmt, argptr);
        va_end(argptr);
        return 1;
    }
    else
        return 0;
}

int CriticalFailADAPTrace(const char *string)
// 
//  The intention of this trace function is to be used in situations where catastrophic events
//  may have occured where the state of the heap may be in question.  The function uses only 
//  stack variables.  Note that if a heap corruption has occured there is a small chance that 
//  the global object __g_traceInfo may have been damaged.
{

    return ErrorTrace(LOG_WMIADAP, "**CRITICAL FAILURE** %s", string);
}

// Helper for quick wchar to multibyte conversions.  Caller muts
// free the returned pointer
BOOL POLARITY AllocWCHARToMBS( WCHAR* pWstr, char** ppStr )
{
    if ( NULL == pWstr )
    {
        return FALSE;
    }

    // Get the length allocate space and copy the string
    long    lLen = wcstombs(NULL, pWstr, 0);
    *ppStr = new char[lLen + 1];
    if (*ppStr == 0)
        return FALSE;
    wcstombs( *ppStr, pWstr, lLen + 1 );

    return TRUE;
}

LPTSTR GetWbemWorkDir( void )
{
    LPTSTR    pWorkDir = NULL;

    Registry r1(WBEM_REG_WINMGMT);
    if (r1.GetStr(TEXT("Working Directory"), &pWorkDir))
    {
        size_t bufferLength = MAX_PATH + 1 + lstrlen(TEXT("\\WBEM"));
        wmilib::auto_buffer<TCHAR> p(new TCHAR[bufferLength]);
        if (NULL == p.get()) return NULL;
        
        DWORD dwRet = GetSystemDirectory(p.get(), MAX_PATH + 1);
        if (0 == dwRet) return NULL;
        
        if (dwRet > MAX_PATH) 
        {
            bufferLength = 4 + 1 + dwRet;            
            p.reset(new TCHAR[bufferLength]);
            if (NULL == p.get()) return NULL;
            
            if (0 == GetSystemDirectory(p.get(), dwRet + 1)) return NULL;

        }
        StringCchCat(p.get(), bufferLength, TEXT("\\WBEM"));

        pWorkDir = p.release();
    }

    return pWorkDir;
}

LPTSTR GetWMIADAPCmdLine( int nExtra )
{
    LPTSTR    pWorkDir = GetWbemWorkDir();
    CVectorDeleteMe<TCHAR>    vdm( pWorkDir );

    if ( NULL == pWorkDir )
    {
        return NULL;
    }

    // Buffer should be big enough for two quotes, WMIADAP.EXE and cmdline switches
    size_t bufferLength = lstrlen( pWorkDir ) + lstrlen(TEXT("\\\\?\\\\WMIADAP.EXE")) + nExtra + 1;
    LPTSTR    pCmdLine = new TCHAR[bufferLength];

    if ( NULL == pCmdLine )
    {
        return NULL;
    }

    StringCchPrintf( pCmdLine,bufferLength, TEXT("\\\\?\\%s\\WMIADAP.EXE"), pWorkDir );

    return pCmdLine;
}

BOOL IsNtSetupRunning()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,L"system\\Setup",0, KEY_READ, &hKey);

    if(ERROR_SUCCESS != lRes) return FALSE;

    DWORD dwSetupRunning;
    DWORD dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"SystemSetupInProgress", NULL, NULL,(LPBYTE)&dwSetupRunning, &dwLen);
    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS && (dwSetupRunning == 1))
    {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqllex.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLLEX.CPP

Abstract:

    WQL DFA Table

History:

    raymcc    14-Sep-97       Created.
    raymcc    06-Oct-97       Single quote support

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <wqllex.h>             

#define ST_STRING       26
#define ST_IDENT        31
#define ST_GE           37
#define ST_LE           39
#define ST_NE           42
#define ST_NUMERIC      44
#define ST_REAL         47
#define ST_STRING2      49
#define ST_STRING_ESC   54
#define ST_STRING2_ESC  55   
#define ST_SSTRING      56
#define ST_DOT          61

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl WQL_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          WQL_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  WQL_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  WQL_TOK_EQ,          GLEX_ACCEPT,
/* 9 */  L'[',   GLEX_EMPTY, 0,  WQL_TOK_OPEN_BRACKET,  GLEX_ACCEPT,
/* 10 */  L']',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_BRACKET, GLEX_ACCEPT,

/* 11 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 12 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 13 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 14 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 15 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 16 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 17 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 18 */ L'\'',  GLEX_EMPTY, ST_SSTRING, 0,               GLEX_CONSUME,

    // Whitespace, newlines, etc.
/* 19 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 20 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 21 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 22 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 23 */ 0,      GLEX_EMPTY, 0,  WQL_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 24 */ L',',   GLEX_EMPTY, 0,  WQL_TOK_COMMA, GLEX_ACCEPT,

    // Unknown characters

/* 25 */ GLEX_ANY, GLEX_EMPTY, 0,        WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 26 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 27 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 28 */   L'"',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 29 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 31 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 35 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 37 */  L'=',   GLEX_EMPTY,  0,  WQL_TOK_GE,  GLEX_ACCEPT,
/* 38 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 39 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_LE,  GLEX_ACCEPT,
/* 40 */  L'>',   GLEX_EMPTY,      0,  WQL_TOK_NE,  GLEX_ACCEPT,
/* 41 */  GLEX_ANY, GLEX_EMPTY,    0,  WQL_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 42 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_NE,     GLEX_ACCEPT,
/* 43 */  GLEX_ANY,  GLEX_EMPTY,   0,  WQL_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 44 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 45 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 46 */  GLEX_ANY, GLEX_EMPTY, 0,          WQL_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 47 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 48 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 49 */   L'\n',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 50 */   L'\r',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 51 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,   GLEX_CONSUME,
/* 52 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 53 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 55 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

// ST_SSTRING (Single quoted strings)
/* 56 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 57 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 58 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 59 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 60 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,

// ST_DOT
/* 61 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 62 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqllex.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLLEX.H

Abstract:

	WQL DFA Table & Tokenizer

History:

	raymcc    14-Sep-97       Created.

--*/

#ifndef _WQLLEX_H_

#include <genlex.h>
#define WQL_TOK_EOF           0
#define WQL_TOK_ERROR         1


#define WQL_TOK_SELECT                      256
#define WQL_TOK_ALL                         257
#define WQL_TOK_DISTINCT                    258
#define WQL_TOK_OPTIONS_DUMMY               259
#define WQL_TOK_ASTERISK                    260
#define WQL_TOK_COUNT                       261
#define WQL_TOK_COMMA                       262
#define WQL_TOK_OPEN_PAREN                  263
#define WQL_TOK_CLOSE_PAREN                 264
#define WQL_TOK_IDENT                       265
#define WQL_TOK_DOT                         266
#define WQL_TOK_FROM                        267
#define WQL_TOK_AS                          268
#define WQL_TOK_INNER                       269
#define WQL_TOK_FULL                        270
#define WQL_TOK_LEFT                        271
#define WQL_TOK_RIGHT                       272
#define WQL_TOK_OUTER                       273
#define WQL_TOK_JOIN                        274
#define WQL_TOK_ON                          275
#define WQL_TOK_WHERE                       276
#define WQL_TOK_GROUP                       277
#define WQL_TOK_BY                          278
#define WQL_TOK_HAVING                      279
#define WQL_TOK_ORDER                       280
#define WQL_TOK_OR                          281
#define WQL_TOK_AND                         282
#define WQL_TOK_NOT                         283
#define WQL_TOK_LE                          284
#define WQL_TOK_LT                          285
#define WQL_TOK_GE                          286
#define WQL_TOK_GT                          287
#define WQL_TOK_EQ                          288
#define WQL_TOK_NE                          289
#define WQL_TOK_LIKE                        290
#define WQL_TOK_IS                          291
#define WQL_TOK_BEFORE                      292
#define WQL_TOK_AFTER                       293
#define WQL_TOK_BETWEEN                     294
#define WQL_TOK_QSTRING                     295
#define WQL_TOK_INT                         296
#define WQL_TOK_REAL                        297
#define WQL_TOK_CHAR                        298
#define WQL_TOK_NULL                        299
#define WQL_TOK_OPEN_BRACKET                300
#define WQL_TOK_CLOSE_BRACKET               301
#define WQL_TOK_ISA                         302
#define WQL_TOK_A                           303
#define WQL_TOK_DAY                         304
#define WQL_TOK_MONTH                       305
#define WQL_TOK_YEAR                        306
#define WQL_TOK_HOUR                        307
#define WQL_TOK_MINUTE                      308
#define WQL_TOK_SECOND                      309
#define WQL_TOK_MILLISECOND                 310

#define WQL_TOK_UPPER                       311
#define WQL_TOK_LOWER                       312
#define WQL_TOK_DATEPART                    313
#define WQL_TOK_QUALIFIER                   314
#define WQL_TOK_ISNULL                      315
#define WQL_TOK_IN                          316

#define WQL_TOK_NOT_LIKE                    317
#define WQL_TOK_NOT_BEFORE                  318
#define WQL_TOK_NOT_AFTER                   319
#define WQL_TOK_NOT_BETWEEN                 320
#define WQL_TOK_NOT_NULL                    321
#define WQL_TOK_NOT_IN                      322
#define WQL_TOK_NOT_A                       323

#define WQL_TOK_TYPED_EXPR                  324


#define WQL_TOK_IN_SUBSELECT                325
#define WQL_TOK_NOT_IN_SUBSELECT            326
#define WQL_TOK_IN_CONST_LIST               327
#define WQL_TOK_NOT_IN_CONST_LIST           328

#define WQL_TOK_ASC                         329
#define WQL_TOK_DESC                        330
#define WQL_TOK_AGGREGATE                   331
#define WQL_TOK_FIRSTROW                    332

#define WQL_TOK_PROMPT                      333
#define WQL_TOK_UNION                       334
extern LexEl WQL_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqlscan.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLSCAN.CPP

Abstract:

    WQL Prefix Scanner

    This module implements a specially cased shift-reduce parser to
    parse out selected columns, JOINed tables and aliases, while ignoring
    the rest of the query.

History:

    raymcc    17-Oct-97       SMS extensions.

--*/


#include "precomp.h"
#include <stdio.h>

#include <flexarry.h>
#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>


inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    size_t length = wcslen(src) + 1;
    wchar_t *dest = new wchar_t[length];
    if (!dest)
        return 0;
    memcpy(dest, src, length * sizeof wchar_t);
    return dest;
}

#define trace(x) printf x


class CTokenArray : public CFlexArray
{
public:
    ~CTokenArray() { Empty(); }
    void Empty()
    {
        for (int i = 0; i < Size(); i++) delete PWSLexToken(GetAt(i));
        CFlexArray::Empty();
    }
};

//***************************************************************************
//
//  CWQLScanner::CWQLScanner
//
//  Constructor
//
//  Parameters:
//  <pSrc>          A source from which to lex from.
//
//***************************************************************************

CWQLScanner::CWQLScanner(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(WQL_LexTable, pSrc);
	if (m_pLexer == 0 || GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
	{
		delete m_pLexer;
		throw CX_MemoryException();
	}
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;
    m_bCount = FALSE;
}

//***************************************************************************
//
//  CWQLScanner::~CWQLScanner
//
//***************************************************************************


CWQLScanner::~CWQLScanner()
{
    delete m_pLexer;

    ClearTokens();
    ClearTableRefs();
    ClearPropRefs();
}

//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedAliases(CWStringArray &aAliases)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aAliases.Add(pTRef->m_pszAlias);
    }
    return TRUE;
}
//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedTables(CWStringArray &aClasses)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aClasses.Add(pTRef->m_pszTable);
    }
    return TRUE;
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearTokens()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
        delete (WSLexToken *) m_aTokens[i];
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearPropRefs()
{
    for (int i = 0; i < m_aPropRefs.Size(); i++)
        delete (SWQLColRef *) m_aPropRefs[i];
}

//***************************************************************************
//
//***************************************************************************

void CWQLScanner::ClearTableRefs()
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
        delete (WSTableRef *) m_aTableRefs[i];
    m_aTableRefs.Empty();
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

struct WqlKeyword
{
    LPWSTR m_pKeyword;
    int    m_nTokenCode;
};

static WqlKeyword KeyWords[] =      // Keep this alphabetized for binary search
{
    L"ALL",      WQL_TOK_ALL,
    L"AND",      WQL_TOK_AND,
    L"AS",       WQL_TOK_AS,
    L"BETWEEN",  WQL_TOK_BETWEEN,
    L"BY",       WQL_TOK_BY,
    L"COUNT",    WQL_TOK_COUNT,
    L"DATEPART", WQL_TOK_DATEPART,
    L"DISTINCT", WQL_TOK_DISTINCT,
    L"FIRSTROW", WQL_TOK_FIRSTROW,
    L"FROM",     WQL_TOK_FROM,
    L"FULL",     WQL_TOK_FULL,
    L"GROUP",    WQL_TOK_GROUP,
    L"HAVING",   WQL_TOK_HAVING,
    L"IN",       WQL_TOK_IN,
    L"INNER",    WQL_TOK_INNER,
    L"IS",       WQL_TOK_IS,
    L"ISA",      WQL_TOK_ISA,
    L"ISNULL",   WQL_TOK_ISNULL,
    L"JOIN",     WQL_TOK_JOIN,
    L"LEFT",     WQL_TOK_LEFT,
    L"LIKE",     WQL_TOK_LIKE,
    L"LOWER",    WQL_TOK_LOWER,
    L"NOT",      WQL_TOK_NOT,
    L"NULL",     WQL_TOK_NULL,
    L"ON",       WQL_TOK_ON,
    L"OR",       WQL_TOK_OR,
    L"ORDER",    WQL_TOK_ORDER,
    L"OUTER",    WQL_TOK_OUTER,
    L"QUALIFIER", WQL_TOK_QUALIFIER,
    L"RIGHT",    WQL_TOK_RIGHT,
    L"SELECT",   WQL_TOK_SELECT,
    L"UNION",    WQL_TOK_UNION,
    L"UPPER",    WQL_TOK_UPPER,
    L"WHERE",    WQL_TOK_WHERE

};

const int NumKeywords = sizeof(KeyWords)/sizeof(WqlKeyword);

BOOL CWQLScanner::Next()
{
    if (!m_pLexer)
        return FALSE;

    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == WQL_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == WQL_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check. Do a binary search
    // on the keyword table.
    // =================================

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        int l = 0, u = NumKeywords - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (wbem_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) < 0)
                u = m - 1;
            else if (wbem_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) > 0)
                l = m + 1;
            else        // Match
            {
                m_nCurrentToken = KeyWords[m].m_nTokenCode;
                break;
            }
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  CWQLScanner::ExtractNext
//
//***************************************************************************

PWSLexToken CWQLScanner::ExtractNext(BOOL bRemove)
{
    if (m_aTokens.Size() == 0)
        return NULL;

    PWSLexToken pTok = PWSLexToken(m_aTokens[0]);
    if (bRemove)
        m_aTokens.RemoveAt(0);
    return pTok;
}

//***************************************************************************
//
//  CWQLScanner::Pushback
//
//***************************************************************************

int CWQLScanner::Pushback(PWSLexToken pPushbackTok)
{
    return m_aTokens.InsertAt(0, pPushbackTok);
}

//***************************************************************************
//
//  Shift-reduce parser entry.
//
//***************************************************************************

int CWQLScanner::Parse()
{
    int nRes = SYNTAX_ERROR;
    if (m_pLexer == NULL)
        return FAILED;

    m_pLexer->Reset();

    if (!Next())
        return LEXICAL_ERROR;


    // Completely tokenize the entire query and build a parse-stack.
    // =============================================================

    if (m_nCurrentToken == WQL_TOK_SELECT)
    {
        while (1)
        {
            WSLexToken *pTok = new WSLexToken;
            if (!pTok)
                return FAILED;

            pTok->m_nToken = m_nCurrentToken;
            pTok->m_pszTokenText = Macro_CloneLPWSTR(m_pTokenText);
            if (!pTok->m_pszTokenText)
                return FAILED;

            if (m_aTokens.Add(pTok))
            {
                delete pTok;
                return FAILED;
            }

            if (m_nCurrentToken == WQL_TOK_EOF)
                break;

            if (!Next())
                return LEXICAL_ERROR;
        }
    }
    else
        return SYNTAX_ERROR;

    // Reduce by extracting the select type keywords if possible.
    // ==========================================================

    nRes = ExtractSelectType();
    if (nRes)
        return nRes;

    // Eliminate all tokens from WHERE onwards.
    // ========================================

    StripWhereClause();

    // Reduce by extracting the select list.
    // =====================================

    if (!m_bCount)
    {
        nRes = SelectList();
        if (nRes != 0)
            return nRes;
    }
    else
    {
        // Strip everything until the FROM keyword is encountered.
        // =======================================================

        WSLexToken *pTok = ExtractNext(FALSE);
        if (pTok->m_nToken != WQL_TOK_OPEN_PAREN)
        {
            nRes = SelectList();
            if (nRes )
                return nRes;
        }
        else
        {
            pTok = ExtractNext();
            while (pTok)
            {
                if (pTok->m_nToken == WQL_TOK_FROM)
                {
                    if (Pushback(pTok))
                    {
                        delete pTok;
                        return FAILED;
                    }
                    break;
                }
                // Bug #46728: the count(*) clause
                // can be the only element of the select clause.

                else if (!wcscmp(pTok->m_pszTokenText, L","))
                {
                    delete pTok;
                    return SYNTAX_ERROR;
                }

                delete pTok;
                pTok = ExtractNext();
            }
            if (pTok == 0)
                return SYNTAX_ERROR;
        }
    }

    // Extract tables/aliases from JOIN clauses.
    // =========================================

    if (ReduceSql89Joins() != TRUE)
    {
        ClearTableRefs();
        if (ReduceSql92Joins() != TRUE)
            return SYNTAX_ERROR;
    }


    // Post process select clause to determine if
    // columns are tables or aliases.
    // ==========================================
    for (int i = 0; i < m_aPropRefs.Size(); i++)
    {
        SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
        if (pCRef->m_pTableRef != 0)
        {
            LPWSTR pTbl = AliasToTable(pCRef->m_pTableRef);
            if (pTbl == 0)
                continue;

            if (wbem_wcsicmp(pTbl, pCRef->m_pTableRef) == 0)
                pCRef->m_dwFlags |= WQL_FLAG_TABLE;
            else
                pCRef->m_dwFlags |= WQL_FLAG_ALIAS;
        }
    }


    if (m_aTableRefs.Size() == 0)
        return SYNTAX_ERROR;


    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::StripWhereClause
//
//  If present, removes the WHERE or ORDER BY clause.  Because
//  of SQL Syntax, stripping the first of {ORDER BY, WHERE} will automatically
//  get rid of the other.
//
//***************************************************************************
BOOL CWQLScanner::StripWhereClause()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        WSLexToken *pCurrent = (WSLexToken *) m_aTokens[i];

        // If a WHERE token is found, we have something to strip.
        // ======================================================

        if (pCurrent->m_nToken == WQL_TOK_WHERE ||
            pCurrent->m_nToken == WQL_TOK_ORDER)
        {
            int nNumTokensToRemove = m_aTokens.Size() - i - 1;
            for (int i2 = 0; i2 < nNumTokensToRemove; i2++)
            {
                delete PWSLexToken(m_aTokens[i]);
                m_aTokens.RemoveAt(i);
            }
            return TRUE;
        }
    }

    return FALSE;
}


//***************************************************************************
//
//  CWQLScanner::ExtractSelectType
//
//  Examines the prefix to reduce the query by eliminating the SELECT
//  and select-type keywords, such as ALL, DISTINCT, FIRSTROW, COUNT
//
//  If COUNT is used, move past the open-close parentheses.
//
//***************************************************************************

int CWQLScanner::ExtractSelectType()
{
    // Verify that SELECT is the first token.
    // ======================================

    WSLexToken *pFront = ExtractNext();

    if (pFront == 0 || pFront->m_nToken == WQL_TOK_EOF)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    if (pFront->m_nToken != WQL_TOK_SELECT)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    delete pFront;

    // Check for possible select-type and extract it.
    // ==============================================

    pFront = ExtractNext();
    if (pFront == 0)
        return SYNTAX_ERROR;

    if (pFront->m_nToken == WQL_TOK_COUNT)
    {
        delete pFront;
        m_bCount = TRUE;
    }
    else if (pFront->m_nToken == WQL_TOK_ALL ||
        pFront->m_nToken == WQL_TOK_DISTINCT ||
        pFront->m_nToken == WQL_TOK_FIRSTROW
       )
        delete pFront;
    else
    {
        if (Pushback(pFront))
        {
            delete pFront;
            return FAILED;
        }
    }

    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::SelectList
//
//  Extracts all tokens up to the FROM keyword and builds a list
//  of selected properties/columns.  FROM is left on the parse-stack on exit.
//
//***************************************************************************

int CWQLScanner::SelectList()
{
    // If the first token is FROM, then we have a SELECT FROM <rest>
    // which is the same as SELECT * FROM <rest>.  We simply
    // alter the parse-stack and let the following loop handle it.
    // =============================================================

    WSLexToken *pTok = ExtractNext();

    if (!pTok)
        return SYNTAX_ERROR;

    if (pTok->m_nToken == WQL_TOK_FROM)
    {
        WSLexToken *pAsterisk = new WSLexToken;
        if (pAsterisk == NULL)
            return FAILED;

        pAsterisk->m_nToken = WQL_TOK_ASTERISK;
        pAsterisk->m_pszTokenText = Macro_CloneLPWSTR(L"*");
        if (!pAsterisk->m_pszTokenText)
            return FAILED;
        if (Pushback(pTok))
        {
            delete pTok;
            delete pAsterisk;
            return FAILED;
        }
        if (Pushback(pAsterisk))
        {
            delete pAsterisk;
            return FAILED;
        }
    }
    else
    {
        if (Pushback(pTok))
        {
            delete pTok;
            return FAILED;
        }
    }

    // Otherwise, some kind of column selection is present.
    // ====================================================

    BOOL bTerminate = FALSE;

    while (!bTerminate)
    {
        pTok = ExtractNext();
        if (pTok == 0)
            return SYNTAX_ERROR;

        // We must begin at a legal token.
        // ===============================

        if (pTok->m_nToken != WQL_TOK_EOF)
        {
            CTokenArray Tokens;
            if (Tokens.Add(pTok))
            {
                delete pTok;
                return FAILED;
            }

            while (1)
            {
                pTok = ExtractNext();
                if (pTok == 0 || pTok->m_nToken == WQL_TOK_EOF)
                {
                    delete pTok;
                    return SYNTAX_ERROR;
                }
                if (pTok->m_nToken == WQL_TOK_FROM)
                {
                    if (Pushback(pTok))
                    {
                        delete pTok;
                        return FAILED;
                    }

                    bTerminate = TRUE;
                    break;
                }
                else if (pTok->m_nToken == WQL_TOK_COMMA)
                {
                    delete pTok;
                    break;
                }
                else
                {
                    if (Tokens.Add(pTok))
                    {
                        delete pTok;
                        return FAILED;
                    }
                }
            }

            SWQLColRef *pColRef = new SWQLColRef;
            if (pColRef == 0)
                return FAILED;

            BOOL bRes = BuildSWQLColRef(Tokens, *pColRef);
            if (bRes)
            {
                if (m_aPropRefs.Add(pColRef))
                {
                    delete pColRef;
                    return FAILED;
                }
            }
            else
            {
                delete pColRef;
                return SYNTAX_ERROR;
            }
        }

        // Else an illegal token, such as WQL_TOK_EOF.
        // ===========================================
        else
        {
            delete pTok;
            return SYNTAX_ERROR;

        }
    }

    return SUCCESS;
}



//***************************************************************************
//
//  CWQLScanner::ReduceSql89Joins
//
//  Attempts to reduce the FROM clause, assuming it is based on SQL-89
//  join syntax or else a simple unary select.
//
//  The supported forms are:
//
//      FROM x
//      FROM x, y
//      FROM x as x1, y as y1
//      FROM x x1, y y1
//
//  If incompatible tokens are encountered, the entire function
//  returns FALSE and the results are ignored, and the parse-stack
//  is unaffected, in essence, allowing backtracking to try the SQL-92
//  syntax branch instead.
//
//***************************************************************************
BOOL CWQLScanner::ReduceSql89Joins()
{
    int i = 0;

    // Parse the FROM keyword.
    // =======================

    WSLexToken *pCurr = (WSLexToken *) m_aTokens[i++];
    if (pCurr->m_nToken != WQL_TOK_FROM)
        return FALSE;

    pCurr = (WSLexToken *) m_aTokens[i++];

    while (1)
    {
        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        // If here, we are looking at the beginnings of a table ref.
        // =========================================================

        WSTableRef *pTRef = new WSTableRef;
        if (pTRef == 0)
            return FAILED;

        pTRef->m_pszTable = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszTable)
            return FAILED;
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszAlias)
            return FAILED;
        if (m_aTableRefs.Add(pTRef))
        {
            delete pTRef;
            return FAILED;
        }

        // Attempt to recognize an alias.
        // ==============================

        pCurr = (WSLexToken *) m_aTokens[i++];
        if (pCurr == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken == WQL_TOK_AS)
            pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_COMMA)
        {
            pCurr = (WSLexToken *) m_aTokens[i++];
            continue;
        }

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        delete [] pTRef->m_pszAlias;
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszAlias)
            return FALSE;

        // We have completely parsed a table reference.
        // Now we move on to the next one.
        // ============================================

        pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_COMMA)
            return FALSE;

        pCurr = (WSLexToken *) m_aTokens[i++];
    }

    if (m_aTableRefs.Size())
        return TRUE;

    return FALSE;
}

//***************************************************************************
//
//  CWQLScanner::ReduceSql92Joins
//
//  This scans SQL-92 JOIN syntax looking for table aliases.   See the
//  algorithm at the end of this file.
//
//***************************************************************************

BOOL CWQLScanner::ReduceSql92Joins()
{
    WSLexToken *pCurrent = 0, *pRover = 0, *pRight = 0, *pLeft;
    int nNumTokens = m_aTokens.Size();
    DWORD dwNumJoins = 0;
    int iCurrBase = 0;

    for (int i = 0; i < nNumTokens; i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        // If a JOIN token is found, we have a candidate.
        // ==============================================

        if (pCurrent->m_nToken == WQL_TOK_JOIN)
        {
            dwNumJoins++;

            // Analyze right-context.
            // ======================

            if (i + 1 < nNumTokens)
                pRover = PWSLexToken(m_aTokens[i + 1]);
            else
                pRover = NULL;

            if (pRover && pRover->m_nToken == WQL_TOK_IDENT)
            {
                // Check for aliased table by checking for
                // AS or two juxtaposed idents.
                // =======================================

                if (i + 2 < nNumTokens)
                    pRight = PWSLexToken(m_aTokens[i + 2]);
                else
                    pRight = NULL;


                if (pRight && pRight->m_nToken == WQL_TOK_AS)
                {
                    if (i + 3 < nNumTokens)
                        pRight = PWSLexToken(m_aTokens[i + 3]);
                    else
                        pRight = NULL;
                }

                if (pRight && pRight->m_nToken == WQL_TOK_IDENT)
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FAILED;
                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRight->m_pszTokenText);
                    if (!pTRef->m_pszAlias)
                        return FAILED;
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszTable)
                        return FAILED;
                    if (m_aTableRefs.Add(pTRef))
                    {
                        delete pTRef;
                        return FAILED;
                    }
                }
                else    // An alias wasn't used, just a simple table ref.
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FAILED;

                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszAlias)
                        return FAILED;                        
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszTable)
                        return FAILED;
                    if (m_aTableRefs.Add(pTRef))
                    {
                        delete pTRef;
                        return FAILED;
                    }
                }
                // discontinue analysis of right-context.
            }


            // Analyze left-context.
            // =====================

            int nLeft = i - 1;

            if (nLeft >= 0)
                pRover = PWSLexToken(m_aTokens[nLeft--]);
            else
                continue;   // No point in continuing

            // Verify the ANSI join syntax.

            if (nLeft)
            {
                int iTemp = nLeft;
                WSLexToken *pTemp = pRover;
                bool bInner = false;
                bool bDir = false;
                bool bOuter = false;
                bool bFail = false;
                bool bIdent = false;
                while (iTemp >= iCurrBase)
                {
                    if (pTemp->m_nToken == WQL_TOK_INNER)
                    {
                        if (bOuter || bIdent || bInner)
                            bFail = TRUE;
                        bInner = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_OUTER)
                    {
                        if (bInner || bIdent || bOuter)
                            bFail = TRUE;
                        bOuter = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_FULL  ||
                        pTemp->m_nToken == WQL_TOK_LEFT  ||
                        pTemp->m_nToken == WQL_TOK_RIGHT
                        )
                    {
                        if (bDir || bIdent)
                            bFail = TRUE;
                        bDir = true;
                    }
                    else
                        bIdent = TRUE;

                    // We are trying to enforce correct ANSI-92 joins
                    // even though we don't support them ourselves:
                    // OK:  LEFT OUTER JOIN
                    //      OUTER LEFT JOIN
                    //      LEFT JOIN
                    //      INNER JOIN
                    // NOT: LEFT LEFT JOIN
                    //      LEFT INNER JOIN
                    //      LEFT RIGHT JOIN
                    //      OUTER INNER JOIN
                    //      OUTER LEFT OUTER JOIN
                    //      OUTER GARBAGE LEFT JOIN
                    //      (no right side)

                    if ((bDir && bInner) || bFail)
                        return FALSE;

                    pTemp = PWSLexToken(m_aTokens[iTemp--]);
                }

            }

            // Skip past potential JOIN modifiers : INNER, OUTER,
            // FULL, LEFT, RIGHT
            // ==================================================

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            // Now we look to see if the roving pointer is pointing
            // to an ident.
            // ====================================================

            if (pRover && pRover->m_nToken != WQL_TOK_IDENT)
            {
                // No chance that we are looking at an aliased
                // table in a JOIN clause.
                // ===========================================
                continue;
            }

            iCurrBase = i;

            // If here, we are now possibliy looking at the second half
            // of an alias, the 'alias' name proper.  We mark this
            // by leaving pRover alone and continue to move into the
            // left context with a different pointer.
            // ========================================================

            if (nLeft >= 0)
                pLeft = PWSLexToken(m_aTokens[nLeft--]);
            else
                pLeft = 0;

            if (pLeft && pLeft->m_nToken == WQL_TOK_AS)
            {
                if (nLeft >= 0)
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pLeft = 0;
            }

            // The critical test.  Are we at an ident?
            // =======================================

            if (pLeft && pLeft->m_nToken == WQL_TOK_IDENT)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FAILED;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszAlias)
                    return FAILED;
                pTRef->m_pszTable = Macro_CloneLPWSTR(pLeft->m_pszTokenText);
                if (!pTRef->m_pszTable)
                    return FAILED;
                if (m_aTableRefs.Add(pTRef))
                {
                    delete pTRef;
                    return FAILED;
                }
            }
            else if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FAILED;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszAlias)
                    return FAILED;
                pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszTable)
                    return FAILED;
                if (m_aTableRefs.Add(pTRef))
                {
                    delete pTRef;
                    return FAILED;
                }

                if (nLeft >= 0)
                {
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                    if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
                        return FALSE;
                }
            }
        }

        // Find next JOIN occurrence
    }

    // Make sure there are two sides to every join reference.

    if (dwNumJoins+1 != (DWORD)m_aTableRefs.Size())
        return FALSE;

    return TRUE;
}


//***************************************************************************
//
//***************************************************************************
void CWQLScanner::Dump()
{
    WSLexToken *pCurrent = 0;

    printf("---Token Stream----\n");

    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        printf("Token %d <%S>\n", pCurrent->m_nToken, pCurrent->m_pszTokenText);
    }

    printf("---Table Refs---\n");

    for (i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        printf("Table = %S  Alias = %S\n", pTRef->m_pszTable, pTRef->m_pszAlias);
    }


    if (!m_bCount)
    {
        printf("---Select List---\n");

        for (i = 0; i < m_aPropRefs.Size(); i++)
        {
            SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
            pCRef->DebugDump();
        }
    }
    else
        printf(" -> COUNT query\n");

    printf("\n\n---<end of dump>---\n\n");
}


/*---------------------------------------------------------------------------

   Algorithm for detecting aliased tables in SQL-92 join syntax.

   The JOIN keyword must appear.

   It may appear in several contexts which are not
   relevant to the aliasing problem, such as the following:

     select distinct t1a.name, t2a.id, t3.value from
       (t1 as t1a join t2 as t2a on t1a.name = t2a.name)
       join
       (t1 as t1b join t3 on t1b.id = t3.id and (t3.id = t1b.id or t1b.id = t3.id))
       on
       t1a.id = t3.id
     where a = b and c = d

   where the middle join is against anonymous result sets.

   When analyzing the JOIN, we can easily parse the right-context.  Either
   an identifier follows (possibly further followed by AS),and an optional
   identifier if the JOIN is aliased.  Otherwise, we hit ON immediately, or
   a parenthesis.

   The problem is the left-context of the JOIN token.

   For an alias to occur, an identifier must appear immediately to
   the left of the JOIN.

     id JOIN id2 as id3 ON ...
     ^

   If here, there is a chance we are looking at the left hand side of a
   SQL92 join, a table reference.  However, we might be looking at the end of
   an ON clause which ends in an identifier:

     idx = id JOIN id2 as id3 ON...
         ^
   To disambiguate, we have to do further analysis of left context.

   Consider the follow left-context possibilities:

        (1) t1 AS id JOIN id2 as id3 ON
               ^
        (2) t1 id JOIN id2 as id3 ON
            ^
        (3) <keyword (except AS)> id JOIN id2 as id3 ON
             ^
        (4) on x <rel op> id JOIN id2 as id3 ON
                  ^

   Once we have identified <id>, we have to consider the above cases.

   (1) Case 1 is easy.  An AS clearly tells us we have an alias
       and we know how to get at the table and alias names.

   (2) Case 2 is easy.  Two juxtaposed identifiers to the left always
       indicates an alias.

   In all other cases, like (3) and (4), etc., the table is not
   aliased anyway.  Therefore, we only have to determine whether we
   are looking at an unaliased table name or the trailing end of
   another construct like an ON clause.  This is easy.  Only the
   FROM keyword can precede <id> if <id> is a simple table name.

---------------------------------------------------------------------------
*/


//***************************************************************************
//
//  CWQLScanner::BuildSWQLColRef
//
//***************************************************************************

BOOL CWQLScanner::BuildSWQLColRef(
    IN  CFlexArray     &aTokens,
    IN OUT SWQLColRef  &ColRef      // Empty on entry
    )
{
    if (aTokens.Size() == 0)
        return FALSE;
    int nCurrent = 0;
    WSLexToken *pTok = PWSLexToken(aTokens[nCurrent++]);

    // Initial state: single asterisk or else prop name.
    // =================================================

    if (pTok->m_nToken == WQL_TOK_ASTERISK && aTokens.Size() == 1)
    {
        ColRef.m_pColName = Macro_CloneLPWSTR(L"*");
        if (!ColRef.m_pColName)
            return FALSE;
        ColRef.m_dwFlags = WQL_FLAG_ASTERISK;
        ColRef.m_pQName = new SWQLQualifiedName;
        if (ColRef.m_pQName == 0)
            return FALSE;
        SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
        if (pField == 0)
            return FALSE;

        pField->m_pName = Macro_CloneLPWSTR(L"*");
        if (!pField->m_pName)
            return FALSE;
        if (ColRef.m_pQName->Add(pField))
        {
            delete pField;
            return FALSE;
        }

        return TRUE;
    }

    // If not an identifier, we have an error.
    // =======================================

    else if (pTok->m_nToken == WQL_TOK_EOF)
        return FALSE;

    // If here, we have an identifier.
    // ===============================

    ColRef.m_pQName = new SWQLQualifiedName;
    if (ColRef.m_pQName == NULL)
        return FALSE;
    SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
    if (pField == 0)
        return FALSE;

    pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
    if (!pField->m_pName)
         return FALSE;
    if (ColRef.m_pQName->Add(pField))
    {
        delete pField;
        return FALSE;
    }

    // Subsequent states.
    // ==================

    while (1)
    {
        if (nCurrent == aTokens.Size())
            break;

        pTok = PWSLexToken(aTokens[nCurrent++]);

        if (pTok->m_nToken == WQL_TOK_DOT)
        {
            pField = new SWQLQualifiedNameField;
            if (pField == 0)
                return FALSE;

            if (ColRef.m_pQName->Add(pField))
            {
                delete pField;
                return FALSE;
            }

            if (nCurrent == aTokens.Size())
                return FALSE;
            pTok = PWSLexToken(aTokens[nCurrent++]);
            if (pTok->m_nToken != WQL_TOK_IDENT &&
                pTok->m_nToken != WQL_TOK_ASTERISK
                )
                return FALSE;

            pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
            if (!pField->m_pName)
                return FALSE;
        }
        else if (pTok->m_nToken == WQL_TOK_OPEN_BRACKET)
        {
            return FALSE; // Not supported at present!
        }
        else // illegal token
            return FALSE;
    }

    // Post-process.  If the name is not complex, then we
    // can fill out fields of ColRef.
    // ==================================================
    if (ColRef.m_pQName->GetNumNames() == 2)
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        if (!ColRef.m_pTableRef)
            return FALSE;
        ColRef.m_pColName  = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(1));
        if (!ColRef.m_pColName)
            return FALSE;
        if (wbem_wcsicmp(ColRef.m_pColName, L"NULL") == 0)
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else if (ColRef.m_pQName->GetNumNames() == 1)
    {
        LPWSTR pName = ColRef.m_pQName->GetName(0);
        ColRef.m_pColName  = Macro_CloneLPWSTR(pName);
        if (!ColRef.m_pColName)
            return FALSE;
        if (0 == wbem_wcsicmp(ColRef.m_pColName, L"NULL"))
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        if (!ColRef.m_pTableRef)
            return FALSE;
        
        ColRef.m_dwFlags = WQL_FLAG_COMPLEX_NAME;
    }

    return TRUE;
}




const LPWSTR CWQLScanner::AliasToTable(LPWSTR pszAlias)
{
    if (pszAlias == 0)
        return 0;

    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        if (wbem_wcsicmp(pszAlias, pTRef->m_pszAlias) == 0)
            return pTRef->m_pszTable;

        if (wbem_wcsicmp(pszAlias, pTRef->m_pszTable) == 0)
            return pTRef->m_pszTable;
    }

    return 0;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqlscan.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    WQLSCAN.H

Abstract:

    WQL Prefix Scanner

History:

	raymcc  26-Mar-98

--*/

#ifndef _WQLSCAN_H_
#define _WQLSCAN_H_


struct WSLexToken
{
    int      m_nToken;
    wchar_t *m_pszTokenText;

    WSLexToken() { m_pszTokenText = 0; }
    ~WSLexToken() { delete [] m_pszTokenText; }
};

typedef WSLexToken *PWSLexToken;

struct WSTableRef
{
    wchar_t *m_pszTable;    
    wchar_t *m_pszAlias;    // Can be NULL if no alias specified

    WSTableRef() { m_pszTable = m_pszAlias = 0; }
   ~WSTableRef() { delete [] m_pszTable; delete [] m_pszAlias; }
};

typedef WSTableRef * PWSTableRef;

class POLARITY CWQLScanner
{
    // Data.
    // =====

    CGenLexer    *m_pLexer;
    int           m_nLine;
    wchar_t      *m_pTokenText;
    int           m_nCurrentToken;
    BOOL          m_bCount;

    CFlexArray m_aTokens;       // Array of ptrs to WSLexToken structs.
    CFlexArray m_aPropRefs;     // Array of ptrs to SWQLColRef structs.
    CFlexArray m_aTableRefs;    // Ptrs to WSTableRef structs.
    
    // Local functions.
    // ==================

    BOOL Next();
    PWSLexToken ExtractNext(BOOL bRemoveToken = TRUE);
    int Pushback(PWSLexToken);

    BOOL StripWhereClause();
    BOOL SelectList();
    BOOL ReduceSql92Joins();
    BOOL ReduceSql89Joins();
    BOOL ExtractSelectType();

    void ClearTableRefs();
    void ClearPropRefs();
    void ClearTokens();

    BOOL BuildSWQLColRef(
        CFlexArray &aTokens,
        SWQLColRef  &ColRef      // Empty on entry
        );

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL,
        INVALID_PARAMETER,
        INTERNAL_ERROR
    };

    const LPWSTR AliasToTable(LPWSTR pszAlias);

    BOOL GetReferencedAliases(CWStringArray &aClasses);
    BOOL GetReferencedTables(CWStringArray &aClasses);
    BOOL CountQuery() {return m_bCount;}

    CWQLScanner(CGenLexSource *pSrc);
   ~CWQLScanner(); 
    int Parse();
    
    void Dump();

    const CFlexArray *GetSelectedColumns() { return &m_aPropRefs; }
        // Returns pointer to array of SWQLColRef*

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqltest.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLTEST.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>

#include <flexarry.h>

#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>




void xmain(int argc, char **argv)
{
    if (argc < 2)
    {
        printf("No SQL query specified\n");
        return;
    }

    char buf[8192];

    FILE *f = fopen(argv[1], "rt");
    int nCnt = fread(buf, 1, 8192, f);
    fclose(f);

    buf[nCnt] = 0;

    wchar_t buf2[8192];
    MultiByteToWideChar(CP_ACP, 0, buf, -1, buf2, 8192); 

    CTextLexSource src(buf2);

    CWQLScanner parser(&src);

    int nRes = parser.Parse();

    if (nRes)
    {
        printf("ERROR: %d\n", nRes);
    }
    else
    {
        printf("No errors.\n");
        parser.Dump();
    }
}

void main(int argc, char **argv)
{
    for (;;)
    {
        Sleep(500);
        xmain(argc, argv);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wstlallc.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    WSTLALLC.H

Abstract:

	WMI STL Allocator so we can throw exceptions

History:

    sanjes  16-Aug-99   Created

--*/

#ifndef __WSTLALLC_H__
#define __WSTLALLC_H__

#include <memory>
#include "corex.h"

template<class _Ty>
	class wbem_allocator {
public:
	typedef _SIZT size_type;
	typedef _PDFT difference_type;
	typedef _Ty _FARQ *pointer;
	typedef const _Ty _FARQ *const_pointer;
	typedef _Ty _FARQ& reference;
	typedef const _Ty _FARQ& const_reference;
	typedef _Ty value_type;
	pointer address(reference _X) const
		{return (&_X); }
	const_pointer address(const_reference _X) const
		{return (&_X); }
	pointer allocate(size_type _N, const void *)
		{
		_Ty _FARQ * pRet = ((_Ty _FARQ *)operator new(
		(_SIZT)_N * sizeof (_Ty)));

		if ( NULL == pRet )
		{
			throw CX_MemoryException();
		}

		return pRet; }
	char _FARQ *_Charalloc(size_type _N)
		{
		char _FARQ * pRet = ((char _FARQ *)operator new( (_SIZT)_N ));

		if ( NULL == pRet )
		{
			throw CX_MemoryException();
		}

		return pRet; }
	void deallocate(void _FARQ *_P, size_type)
		{operator delete(_P); }
	void construct(pointer _P, const _Ty& _V)
		{std::_Construct(_P, _V); }
	void destroy(pointer _P)
		{std::_Destroy(_P); }
	_SIZT max_size() const
		{_SIZT _N = (_SIZT)(-1) / sizeof (_Ty);
		return (0 < _N ? _N : 1); }
	friend bool operator==(const wbem_allocator<_Ty>&, const wbem_allocator<_Ty>&) { return true;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\bstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "bstring.h"

CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString)
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WSTRING.CPP

Abstract:

    Utility string class

History:

    a-raymcc    30-May-96       Created.
    a-dcrews    16-Mar-99       Added out-of-memory exception handling

--*/

#include "precomp.h"

#include <stdio.h>
#include <wstring.h>
#include <corex.h>

static wchar_t g_szNullString[1] = {0};

/*inline*/ void WString::DeleteString(wchar_t *pStr)
{
    if (pStr != g_szNullString)
        delete [] pStr;
}

WString::WString()
{ 
    m_pString = g_szNullString; 
}
WString::WString(wchar_t *pSrc, BOOL bAcquire)
{
    if (bAcquire) {
        m_pString = pSrc;
        if (m_pString == 0)
            m_pString = g_szNullString;
        return;            
    }

    if (pSrc == 0) {
        m_pString = g_szNullString;
        return;
    }

    size_t length  = wcslen(pSrc) + 1;
    m_pString = new wchar_t[length];


    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    memcpy(m_pString,  pSrc, sizeof wchar_t * length);
}

WString::WString(DWORD dwResourceID, HMODULE hMod)
{
    int iSize = 100;
    BOOL bNotDone = TRUE;
    TCHAR* pTemp = NULL;

    // load the string from the string table.  Since we dont know what size, try increasing the
    // buffer till it works, or until the clearly obsurd case is hit

    while (iSize < 10240)
    {
        pTemp = new TCHAR [iSize];

        // Watch for allocation failures
        if ( NULL == pTemp )
        {
            throw CX_MemoryException();
        }

        int iRead = LoadString(hMod, dwResourceID, pTemp, iSize);
        if(iRead == 0)
        {
            // Bad string

            m_pString = g_szNullString;
            delete [] pTemp;
            return;
        }
        if(iRead +1 < iSize)
            break;      // all is well;
        iSize += 100;    // Try again
        delete [] pTemp;
        pTemp = NULL;
    }

#ifdef UNICODE
//For unicode, this is the string we need!
    m_pString = pTemp;
#else
//Only have to convert if we are not using unicode, otherwise it is already in wide mode!
    if(pTemp)
    {   
        // got a narrow string, allocate a large string buffer and convert

        long len = mbstowcs(NULL, pTemp, lstrlen(pTemp)+1) + 1;
        m_pString = new wchar_t[len];

        // Watch for allocation failures
        if ( NULL == m_pString )
        {
            delete [] pTemp;
            throw CX_MemoryException();
        }

        mbstowcs(m_pString, pTemp, lstrlen(pTemp)+1);
        delete [] pTemp;
    }
    else
        m_pString = g_szNullString;
#endif

}


WString::WString(const wchar_t *pSrc)
{
    if (pSrc == 0) {
        m_pString = g_szNullString;
        return;
    }
    size_t tmpLength  = wcslen(pSrc) + 1;	
    m_pString = new wchar_t[tmpLength];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    memcpy(m_pString, pSrc, sizeof wchar_t * tmpLength);
}

WString::WString(const char *pSrc)
{
    m_pString = new wchar_t[strlen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    mbstowcs(m_pString, pSrc, strlen(pSrc) + 1);
}

LPSTR WString::GetLPSTR() const
{
    long len = 2*(wcslen(m_pString) + 1);
    char *pTmp = new char[len];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcstombs(pTmp, m_pString, len);
    return pTmp;
}

WString& WString::operator =(const WString &Src)
{
    DeleteString(m_pString);
    size_t stringSize = wcslen(Src.m_pString) + 1; 
    m_pString = new wchar_t[stringSize];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    StringCchCopyW(m_pString, stringSize, Src.m_pString);
    return *this;    
}

WString& WString::operator =(LPCWSTR pSrc)
{
    DeleteString(m_pString);
    size_t stringSize = wcslen(pSrc) + 1;
    m_pString = new wchar_t[stringSize];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    StringCchCopyW(m_pString, stringSize, pSrc);
    return *this;    
}

WString& WString::operator +=(const wchar_t *pOther)
{
    size_t tmpThisLength = wcslen(m_pString);
    size_t tmpOtherLength = wcslen(pOther)+1;
    size_t stringSize = tmpThisLength  + tmpOtherLength;

    wchar_t *pTmp = new wchar_t[stringSize];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    memcpy(pTmp, m_pString, (sizeof wchar_t) * tmpThisLength);
    memcpy(pTmp + tmpThisLength , pOther, (sizeof wchar_t) * tmpOtherLength);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}

WString& WString::operator +=(wchar_t NewChar)
{
    wchar_t Copy[2];
    Copy[0] = NewChar;
    Copy[1] = 0;
    return *this += Copy;
}


WString& WString::operator +=(const WString &Other)
{
    return *this += Other.m_pString;
}


wchar_t WString::operator[](int nIndex) const
{
    if (nIndex >= (int) wcslen(m_pString))
        return 0;
    return m_pString[nIndex];        
}


WString& WString::TruncAtRToken(wchar_t Token)
{
    for (int i = (int) wcslen(m_pString); i >= 0; i--) {
        wchar_t wc = m_pString[i];
        m_pString[i] = 0;
        if (wc == Token)
            break;
    }
    
    return *this;        
}


WString& WString::TruncAtLToken(wchar_t Token)
{
    int nStrlen = wcslen(m_pString);
    for (int i = 0; i < nStrlen ; i++) 
    {
        if (Token == m_pString[i])
        {
            m_pString[i] = 0;
            break;
        }        
    }
    
    return *this;        
}


WString& WString::StripToToken(wchar_t Token, BOOL bIncludeToken)
{
    int nStrlen = wcslen(m_pString);
    wchar_t *pTmp = new wchar_t[nStrlen + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    *pTmp = 0;

    BOOL bFound = FALSE;
        
    for (int i = 0; i < nStrlen; i++) {
        if (m_pString[i] == Token) {
            bFound = TRUE;
            break;    
        }            
    }    

    if (!bFound)
    {
        delete [] pTmp;
        return *this;
    }
        
    if (bIncludeToken) i++;
    StringCchCopyW(pTmp, nStrlen + 1, &m_pString[i]);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;
}

LPWSTR WString::UnbindPtr()
{
    if (m_pString == g_szNullString)
    {
        m_pString = new wchar_t[1];

        // Watch for allocation failures
        if ( NULL == m_pString )
        {
            throw CX_MemoryException();
        }

        *m_pString = 0;
    }
    wchar_t *pTmp = m_pString;
    m_pString = g_szNullString;
    return pTmp;
}

WString& WString::StripWs(int nType)
{
    if (nType & leading)
    {
    	size_t stringSize = wcslen(m_pString) + 1;
        wchar_t *pTmp = new wchar_t[stringSize];

        // Watch for allocation failures
        if ( NULL == pTmp )
        {
            throw CX_MemoryException();
        }

        int i = 0;
        while (iswspace(m_pString[i]) && m_pString[i]) i++;
        StringCchCopyW(pTmp, stringSize , &m_pString[i]);
        DeleteString(m_pString);
        m_pString = pTmp;
    }
               
    if (nType & trailing)
    {
        wchar_t *pCursor = m_pString + wcslen(m_pString) - 1;
        while (pCursor >= m_pString && iswspace(*pCursor)) 
            *pCursor-- = 0;
    }
    return *this;
}

wchar_t *WString::GetLToken(wchar_t Tok) const
{
    wchar_t *pCursor = m_pString;
    while (*pCursor && *pCursor != Tok) pCursor++;
    if (*pCursor == Tok)
        return pCursor;
    return 0;                
}

WString WString::operator()(int nLeft, int nRight) const
{
	size_t stringSize = wcslen(m_pString) + 1;
    wchar_t *pTmp = new wchar_t[stringSize];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wchar_t *pCursor = pTmp;
        
    for (int i = nLeft; i < (int) wcslen(m_pString) && i <= nRight; i++)
        *pCursor++ = m_pString[i];
    *pCursor = 0;

    return WString(pTmp, TRUE);        
}

BOOL WString::ExtractToken(const wchar_t * pDelimiters, WString &Extract)
{
    if(pDelimiters == NULL)
    {
        Extract.Empty();
        return FALSE;
    }

    // Find which character in the list works.  Use the first if none are
    // present

    int nLen = wcslen(m_pString);
    int nDimLen = wcslen(pDelimiters);

    for (int i = 0; i < nLen; i++)
        for(int j = 0; j < nDimLen; j++)
            if (m_pString[i] == pDelimiters[j])
                return ExtractToken(pDelimiters[j], Extract);

    // If none were found, just use the first.

    return ExtractToken(*pDelimiters, Extract);

}
 
BOOL WString::ExtractToken(wchar_t Delimiter, WString &Extract)
{
    int i, i2;
    BOOL bTokFound = FALSE;
    Extract.Empty();
    int nLen = wcslen(m_pString);
    wchar_t *pTmp = new wchar_t[nLen + 1];
    
    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    for (i = 0; i < nLen; i++)
        if (m_pString[i] == Delimiter) {
            bTokFound = TRUE;
            break;    
        }            
        else
            pTmp[i] = m_pString[i];            

    pTmp[i] = 0;
    Extract.BindPtr(pTmp);                      
                                              
    // Now make *this refer to any leftover stuff.
    // ===========================================
    pTmp = new wchar_t[nLen - wcslen(pTmp) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    *pTmp = 0;

    for (i2 = 0, i++; i <= nLen; i++)
        pTmp[i2++] = m_pString[i];

    DeleteString(m_pString);
    m_pString = pTmp;
    
    // Return TRUE if the token was encountered, FALSE if not.
    // =======================================================
    return bTokFound;
}

void WString::Empty()
{
    DeleteString(m_pString);
    m_pString = g_szNullString;
}

static int _WildcardAux(const wchar_t *pszWildstr, const wchar_t *pszTargetstr, 
    int iGreedy)
{
    enum { start, wild, strip } eState;
    wchar_t cInput, cInputw, cLaToken;
    
    if (!wcslen(pszTargetstr) || !wcslen(pszWildstr))
        return 0;
                
    for (eState = start;;)
        switch (eState)
        {
            case start:
                cInputw = *pszWildstr++;        // wildcard input 
                cInput = *pszTargetstr;         // target input 

                if (!cInputw)                   // at end of wildcard string? 
                    goto EndScan;

                // Check for wildcard chars first 
                   
                if (cInputw == L'?') {          // Simply strips both inputs 
                    if (!cInput)                // If end of input, error 
                        return 0;
                    pszTargetstr++;
                    continue;
                }
                if (cInputw == L'*')  {
                    eState = wild;                
                    break;
                }

                // If here, an exact match is required.                 

                if (cInput != cInputw)
                    return 0;
                    
                // Else remain in same state, since match succeeded 
                pszTargetstr++;
                break;

            case wild:
                cLaToken = *pszWildstr++;   // Establish the lookahead token 
                eState = strip;
                break;

            case strip:
                cInput = *pszTargetstr;

                if (cInput == cLaToken) {
                    if (!cInput)            // Match on a NULL 
                        goto EndScan;
                    ++pszTargetstr;  

                    // If there is another occurrence of the lookahead 
                    // token in the string, and we are in greedy mode,
                    // stay in this state 

                    if (!iGreedy)
                        eState = start;

                    if (!wcschr(pszTargetstr, cLaToken))
                        eState = start;

                    break;
                }
                    
                if (cLaToken && !cInput)    // End of input with a non-null la token 
                    return 0;

                ++pszTargetstr;             // Still stripping input 
                break;
        }


    //  Here if the wildcard input is exhausted.  If the
    //  target string is also empty, we have a match,
    //  otherwise not. 

EndScan:
    if (wcslen(pszTargetstr))
        return 0; 

    return 1;   
}

// Run the test both with greedy and non-greedy matching, allowing the
// greatest possible chance of a match. 

BOOL WString::WildcardTest(const wchar_t *pszWildstr) const
{
    return (_WildcardAux(pszWildstr, m_pString, 0) | 
            _WildcardAux(pszWildstr, m_pString, 1));
}


void WString::Unquote()
{
    if (!m_pString)
        return;
    int nLen = wcslen(m_pString);
    if (nLen == 0)
        return;

    // Remove trailing quote.
    // ======================
    
    if (m_pString[nLen - 1] == L'"')
        m_pString[nLen - 1] = 0;

    // Remove leading quote.
    // =====================
    
    if (m_pString[0] == L'"')
    {
        for (int i = 0; i < nLen; i++)
            m_pString[i] = m_pString[i + 1];
    }
}

WString WString::EscapeQuotes() const
{
    WString ws;

    int nLen = Length();
    for(int i = 0; i < nLen; i++)
    {
        if(m_pString[i] == '"' || m_pString[i] == '\\')
        {
            ws += L'\\';
        }

        ws += m_pString[i];
    }

    return ws;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wstring.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WSTRING.H

Abstract:

    Utility string class

History:

    a-raymcc    30-May-96       Created.
    a-dcrews    16-Mar-99       Added out-of-memory exception handling

--*/

#ifndef _WSTRING_H_
#define _WSTRING_H_

#include "corepol.h"
#include <strutils.h>

class POLARITY WString
{
private:
    wchar_t *m_pString;

    void DeleteString(wchar_t *pStr);

public:
    enum { leading = 0x1, trailing = 0x2 };

    WString(wchar_t *pSrc, BOOL bAcquire = FALSE);
    WString(DWORD dwResourceID, HMODULE hMod);      // creates from resource string
    WString(const wchar_t *pSrc);
    WString(const char *pSrc);
//    inline WString() { m_pString = g_szNullString; }
    WString();
    inline WString(const WString &Src) {  m_pString = 0; *this = Src; }
    WString& operator =(const WString &);
    WString& operator =(LPCWSTR);
   inline ~WString() { DeleteString(m_pString); }
    inline int Length() const { return wcslen(m_pString); }

    WString& operator +=(const WString &Other);
    WString& operator +=(const wchar_t *);
    WString& operator +=(wchar_t);
    
    inline operator const wchar_t *() const { return m_pString; } 
    inline operator wchar_t *() { return m_pString; } 
    wchar_t operator[](int nIndex) const;
    LPSTR GetLPSTR() const;

    inline BOOL Equal(const wchar_t *pTarget) const
        { return wcscmp(m_pString, pTarget) == 0; }
    inline BOOL EqualNoCase(const wchar_t *pTarget) const
        { return wbem_wcsicmp(m_pString, pTarget) == 0; }

    inline BOOL operator< (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) < 0; }
    inline BOOL operator> (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) > 0; }
    inline BOOL operator<= (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) <= 0; }
    inline BOOL operator>= (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) >= 0; }
        

    LPWSTR UnbindPtr();
    inline void BindPtr(LPWSTR ptr) { DeleteString(m_pString); m_pString = ptr; }
    void Empty();
    WString& StripWs(int nType);
        // Strip whitespace, use with a combination
        // of leading | trailing
        
    WString& TruncAtRToken(wchar_t Token);
        // Truncates the string at the token starting from the
        // right end. The token itself is also wiped out.

    WString& TruncAtLToken(wchar_t Token);
          
    WString& StripToToken(wchar_t Token, BOOL bIncludeToken);
        // Strips leading chars until the token is encountered.
        // If bIncludeTok==TRUE, strips the token too.

    wchar_t *GetLToken(wchar_t wcToken) const;
        // Gets the first occurrence of wcToken in the string or NULL
        
    WString operator()(int, int) const;
        // Returns a new WString based on the slice
        
    BOOL ExtractToken(const wchar_t * pDelimiters, WString &Extract);
        // Extracts the leading chars up to the token delimiter,
        // Removing the token from *this, and assigning the extracted
        // part to <Extract>.

    BOOL ExtractToken(wchar_t Delimiter, WString &Extract);
        // Extracts the leading chars up to the token delimiter,
        // Removing the token from *this, and assigning the extracted
        // part to <Extract>.
        
    BOOL WildcardTest(const wchar_t *pTestStr) const;
        // Tests *this against the wildcard string.  If a match,
        // returns TRUE, else FALSE.        
        
    void Unquote();        
        // Removes leading/trailing quotes, if any. 
        // Leaves escaped quotes intact.

    WString EscapeQuotes() const;
};

class WSiless
{
public:
    inline bool operator()(const WString& ws1, const WString& ws2) const
        {return wbem_wcsicmp(ws1, ws2) < 0;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\comndll\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAINDLL.CPP

Abstract:

    Contains DLL entry points.  Also has code that controls
    when the DLL can be unloaded by tracking the number of
    objects and locks.

--*/

#include "precomp.h"
#include <statsync.h>

HINSTANCE ghModule;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(  IN HINSTANCE hInstance,
                    IN ULONG ulReason,
                    LPVOID pvReserved)
{
    if(DLL_PROCESS_ATTACH == ulReason)
    {
        ghModule = hInstance;
		DisableThreadLibraryCalls ( hInstance ) ;
        if (CStaticCritSec::anyFailure())
            return FALSE;		
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\comnlib\tmpltest.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include "txttempl.h"
#include "comutl.h"

extern "C" int __cdecl wmain( int argc, wchar_t* argv[] )
{
    if ( argc < 3 )
    {
        printf("Usage:: tmpltest <objref> <tmplstr>\n");
        return 1;
    }
 
    LPWSTR wszPath = argv[1];
    LPWSTR wszTmpl = argv[2];

    HRESULT hr;
    CoInitialize( NULL );

    {

    CWbemPtr<IWbemLocator> pLocator;
    CWbemPtr<IWbemServices> pSvc;

    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_IWbemLocator, 
                           (void**)&pLocator );

    if ( FAILED(hr) )
    {
        printf("ERROR CoCIing WbemLocator : hr = 0x%x\n",hr);
        return 1;
    }

    hr = pLocator->ConnectServer( L"root", 
                                  NULL,
                                  NULL, 
                                  NULL,
                                  0, 
                                  NULL, 
                                  NULL, 
                                  &pSvc );
    
    if ( FAILED(hr) )
    {
        wprintf( L"ERROR Connecting to WMI : hr = 0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWbemClassObject> pObj;
    hr = pSvc->GetObject( wszPath, 0, NULL, &pObj, NULL );

    if ( FAILED(hr) )
    {
        printf("ERROR Fetching Obj : hr = 0x%x\n", hr );
        return 1;
    }

    CTextTemplate TextTmpl( wszTmpl );

    BSTR bstrNewQuery = TextTmpl.Apply( pObj );

    if ( bstrNewQuery == NULL )
    {
        printf("Failed getting applying template str to obj\n" );
        return 1;
    }

    wprintf( L"Template string is %s\n", bstrNewQuery );
    SysFreeString( bstrNewQuery );

    }



    CoUninitialize(); 
                   
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\localloc.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\bstring.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.H

Abstract:

History:

--*/

#ifndef _BSTRING_H_
#define _BSTRING_H_

class CBString
{
private:
    BSTR    m_pString;


public:
    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) {
            SysFreeString(m_pString);
        }
        m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#endif // _BSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\notsink.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    NOTSINK.H

Abstract:

History:

--*/

#include <wbemidl.h>
//#include <arena.h>
//#include <flexarry.h>
#include "wbemtest.h"

#pragma warning(disable:4355)

class CNotSink : public IWbemObjectSink
{
    long m_lRefCount;
    CQueryResultDlg* m_pViewer;
    CRITICAL_SECTION m_cs;
    
public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);

    // Private to implementation.
    // ==========================

    CNotSink(CQueryResultDlg* pViewer);
    ~CNotSink();
    void ResetViewer() { m_pViewer = NULL;}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\method.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    METHOD.H

Abstract:

History:

--*/

#ifndef __method__H_
#define __method__H_


#include <wbemdlg.h>
#include <wbemidl.h>
#include <resrc1.h>
#include "wbemqual.h"
#include "WT_WString.h"

class CMethodDlg : public CWbemDialog
{
    IWbemClassObject* m_pInParams;
    IWbemClassObject* m_pOutParams;

    BOOL m_bHasOutParam;
    IWbemClassObject * m_pClass;
    HWND m_hMethodList;
    BOOL m_bAtLeastOne;
    WString m_wsName;

    WCHAR m_Path[2048];
    WCHAR m_Class[2048];

    LONG  m_lGenFlags;  // generic WBEM_FLAG_ .. flags
    LONG  m_lSync;      // enum {sync = 0, async, semisync}
    LONG  m_lTimeout;   // used in semisync only

public:
    CMethodDlg(HWND hParent, LONG lGenFlags, LONG lSync, LONG lTimeout);
    ~CMethodDlg();
	void RunDetached(CRefCountable* pOwner);

protected:
    BOOL OnInitDialog();
    BOOL OnExecute();
    BOOL GetPath();
    BOOL OnCommand(WORD wNotifyCode, WORD nId);
    BOOL OnSelChange(int nID);
    void ResetButtons();
    BOOL UpdateObjs();
};

class CMethodEditor : public CWbemDialog
{
    CTestMethod *m_pTarget;
    BOOL m_bEditOnly;
    BOOL m_bInstance;

    // Control handles.
    // ================

    HWND m_hPropName;
    HWND m_hPropType;
    HWND m_hValue;
    HWND m_hQualifierList;


public:
    CMethodEditor(HWND hParent, CTestMethod *pMethod, BOOL bEditOnly,
                        BOOL bInstance);
    INT_PTR Edit();

    BOOL OnInitDialog();
    BOOL Verify();
    BOOL OnCommand(WORD wCode, WORD wID);
    BOOL OnDoubleClick(int nID);
    BOOL OnSelChange(int nID);

    void Refresh();
    void OnAddQualifier();
    void OnDelQualifier();
    void OnEditQualifier();
    void OnNotNull();
    void ViewEmbedding(BOOL bInput);
    int RemoveSysQuals();
    void SetSystemCheck(int nID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\method.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    METHOD.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
//#include <wbemutil.h>
//#include "wstring.h"
#include "method.h"
#include "wbemtest.h"
#include "bstring.h"
#include "wbemqual.h"
#include "textconv.h"
#include "genlex.h"
#include "objpath.h"
#include <cominit.h>            // for SetInterfaceSecurityEx()
#include <autoptr.h>

extern DWORD            gdwAuthLevel;
extern DWORD            gdwImpLevel;
extern BSTR             gpPrincipal;
extern COAUTHIDENTITY*  gpAuthIdentity;


INT_PTR GetObjectPath(HWND hDlg, LPWSTR pStr, int nMax);

#include "objedit.h"

CMethodDlg::CMethodDlg(HWND hParent, LONG lGenFlags, LONG lSync, LONG lTimeout)
    : CWbemDialog(IDD_METHOD, hParent), m_pOutParams(NULL), m_pInParams(NULL), 
            m_lGenFlags(lGenFlags), m_lSync(lSync), m_lTimeout(lTimeout)
{
    m_Path[0] = 0;
    m_Class[0] = 0;
    m_pClass = NULL;
    m_bAtLeastOne = FALSE;
    m_bHasOutParam = FALSE;
}

CMethodDlg::~CMethodDlg()
{
    if(m_pInParams) m_pInParams->Release();
    if(m_pClass)
        m_pClass->Release();
    if(m_pOutParams)
        m_pOutParams->Release();
}

BOOL CMethodDlg::OnInitDialog()
{
    m_hMethodList = GetDlgItem(IDC_METHLIST);
    BOOL bRet = GetPath();
    if(!bRet)
        EndDialog(IDCANCEL);
    ResetButtons();
    return bRet;
}


void CMethodDlg::RunDetached(CRefCountable* pOwner)
{
    SetOwner(pOwner);
    SetDeleteOnClose();
    Create(FALSE);
}

BOOL CMethodDlg::GetPath()
{
    WCHAR wTemp[2048];
    wcscpy(wTemp, m_Path);
    INT_PTR dwRet = GetObjectPath(m_hDlg, wTemp, 2048);
    if(dwRet == IDOK)
    {
        if(wcslen(wTemp) < 1)
        {
            MessageBox(m_hDlg, IDS_CANT_GET_CLASS, IDS_ERROR, MB_OK | MB_ICONSTOP);
            return FALSE;
        }
        wcscpy(m_Path, wTemp);
        CObjectPathParser par;
        ParsedObjectPath *pOutput;
        int nRes = par.Parse(m_Path, &pOutput);
        if(nRes || pOutput == NULL || pOutput->m_pClass == NULL)
        {
            MessageBox(IDS_CANT_GET_CLASS, IDS_WARNING, MB_OK | MB_ICONSTOP);
            return FALSE;
        }
        wcscpy(m_Class, pOutput->m_pClass);
        if(m_pClass)
        {
            m_pClass->Release();
            m_pClass = NULL;
        }
        CBString bsPath = m_Class;
        SCODE sc = g_pNamespace->GetObject(bsPath.GetString(), m_lGenFlags, g_Context, 
                                        &m_pClass, NULL);

        if(sc != S_OK)
        {
            FormatError(sc, m_hDlg, NULL);
            return FALSE;
        }
        // populate the combo box with methods.

        SendMessage(m_hMethodList, CB_RESETCONTENT, 0, 0);
        SendMessage(m_hMethodList, CB_SETCURSEL, -1, 0);

        m_bAtLeastOne = FALSE;
        if(sc == S_OK && m_pClass)
        {
            BSTR Name = NULL;
            m_pClass->BeginMethodEnumeration(0);
            while (m_pClass->NextMethod(0, &Name, NULL, NULL) == WBEM_S_NO_ERROR)
            {
                char buf[TEMP_BUF];
                wcstombs(buf, Name, TEMP_BUF);
                buf[TEMP_BUF-1] = '\0';
                SendMessage(m_hMethodList, CB_ADDSTRING, 0, LPARAM(buf));
                m_bAtLeastOne = TRUE;
            }
            if(m_bAtLeastOne)
            {
                SendMessage(m_hMethodList, CB_SETCURSEL, 0, 0);
                OnSelChange(0);
            }
            else
            {
                MessageBox(m_hDlg, IDS_CLASS_HAS_NO_METHODS, IDS_ERROR, MB_OK | MB_ICONSTOP);
                ResetButtons();
                return FALSE;
            }


            m_pClass->EndMethodEnumeration();
        }

        return TRUE;
    }
    else
        return FALSE;

}

BOOL CMethodDlg::OnCommand(WORD wNotifyCode, WORD nId)
{
    switch(nId)
    {
    case IDC_EDITPATH:
        GetPath();
        break;
    case IDC_CLEAR:
        UpdateObjs();
        break;

    case IDC_EXECUTE:
        OnExecute();
        break;

    case IDC_EDITOUT:
        if(m_pOutParams != NULL)
        {
            IWbemClassObject* pNew;
            m_pOutParams->Clone(&pNew);

            CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::readonly, m_lSync, 
                    pNew, m_lTimeout);
            ed.Run();
            pNew->Release();
        }
        break;

    case IDC_EDITIN:
        if(m_pInParams != NULL)
        {
            IWbemClassObject* pNew;
            m_pInParams->Clone(&pNew);

            CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::readwrite, m_lSync,
                    pNew, m_lTimeout);
            if(ed.Run() == IDOK)
            {
                m_pInParams->Release();
                m_pInParams = pNew;
            }
        }
        else
        {
            m_pInParams = _CreateInstance(m_hDlg, m_lGenFlags, m_lSync, m_lTimeout);
        }
        break;
    }
    ResetButtons();
    return TRUE;
}


void CMethodDlg::ResetButtons()
{
    EnableWindow(GetDlgItem(IDC_CLEAR), (m_pInParams != NULL));
    EnableWindow(GetDlgItem(IDC_EXECUTE), (wcslen(m_Path)));
    EnableWindow(GetDlgItem(IDC_EDITIN), (m_pInParams != NULL));
    EnableWindow(GetDlgItem(IDC_EDITOUT), (m_pOutParams != NULL));
    char cTemp[2048];
    wcstombs(cTemp, m_Path, 2048);
    SetWindowText(GetDlgItem(IDC_OBJPATH), cTemp);
}

BOOL CMethodDlg::OnExecute()
{
    // Get all the parameters
    // ======================

    if(wcslen(m_Path) == 0)
    {
        MessageBox(IDS_MUST_SPECIFY_PATH, IDS_ERROR, MB_OK | MB_ICONHAND);
        return FALSE;
    }
    if(wcslen(m_wsName) == 0)
    {
        MessageBox(IDS_MUST_SPECIFY_NAME, IDS_ERROR, MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Execute the method
    // ==================

    CBString bsPath(m_Path);
    CBString bsMethod(m_wsName);

    if(m_pOutParams)
        m_pOutParams->Release();
    m_pOutParams = NULL;

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->ExecMethodAsync(bsPath.GetString(), bsMethod.GetString(),
                                WBEM_FLAG_SEND_STATUS, 
                                g_Context, m_pInParams, CUnsecWrap(pNtfy));

        if(SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
            if(SUCCEEDED(res))
            {
                CFlexArray* pArray = pNtfy->GetObjectArray();

                if(m_bHasOutParam && pArray && pArray->Size() > 0)
                {
                    m_pOutParams = (IWbemClassObject*)pArray->GetAt(0);
                    if (m_pOutParams)
                        m_pOutParams->AddRef();
                }
            }
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->ExecMethod(bsPath.GetString(), bsMethod.GetString(),
                                WBEM_FLAG_RETURN_IMMEDIATELY, 
                                g_Context, m_pInParams, (m_bHasOutParam) ? &m_pOutParams : NULL, 
                                &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(m_lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::ExecMethod call
                if (m_bHasOutParam && res == WBEM_S_NO_ERROR)
                {
                    res = pCallRes->GetResultObject(0, &m_pOutParams);  // don't use timeout since object should be available
                }
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->ExecMethod(bsPath.GetString(), bsMethod.GetString(),
                                0, 
                                g_Context, m_pInParams, (m_bHasOutParam) ? &m_pOutParams : NULL, 
                                NULL);
    }

    if (FAILED(res))
        FormatError(res, m_hDlg, pErrorObj);
    else
        MessageBox(m_hDlg, IDS_STRING_METHOD_OK, IDS_WBEMTEST, MB_OK);

    return TRUE;
}

BOOL CMethodDlg::UpdateObjs()
{
    SCODE sc;
    if(m_pClass == NULL)
        return FALSE;

    if(m_pInParams)
    {
        m_pInParams->Release();
        m_pInParams = NULL;
    }
    if(m_pOutParams)
    {
        m_pOutParams->Release();
        m_pOutParams = NULL;
    }

    sc = m_pClass->GetMethod((LPWSTR)m_wsName, 0, &m_pInParams, &m_pOutParams); 

    m_bHasOutParam = (m_pOutParams != NULL);
    if(m_pOutParams)
    {
        m_pOutParams->Release();
        m_pOutParams = NULL;
    }

    return sc == S_OK;
}
BOOL CMethodDlg::OnSelChange(int nID)
{

    if(m_pClass == NULL)
        return FALSE;

    LRESULT nIndex = SendMessage(m_hMethodList, CB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return FALSE;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hMethodList, CB_GETLBTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return FALSE;

    m_wsName = buf;

    // Get the property value from the object
    // ======================================

    UpdateObjs();
    ResetButtons();
    return TRUE;
}
void CMethodEditor::OnAddQualifier()
{
    CTestQualifier att;

    att.m_lType =  
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

    CTestQualifierEditor ed(m_hDlg, &att, FALSE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;


    // If here, the Qualifier is being added.
    // ======================================

    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;

    VARIANT *p = att.m_pValue->GetNewVariant();

    HRESULT hres = pQualifierSet->Put(att.m_pName, p, att.m_lType);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
    }

    VariantClear(p);
    Refresh();
}

void CMethodEditor::SetSystemCheck(int nID)
{
    SetCheck(IDC_NOT_NULL, BST_UNCHECKED);
    SetCheck(IDC_NORMAL, BST_UNCHECKED);
    SetCheck(nID, BST_CHECKED);
}

int CMethodEditor::RemoveSysQuals()
{
    IWbemQualifierSet* pSet = m_pTarget->m_pQualifiers;
    HRESULT hres;

    hres = pSet->Delete(L"not_null");
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        SetSystemCheck(IDC_NOT_NULL);
        return IDC_NOT_NULL;
    }

    return 0;
}


void CMethodEditor::OnNotNull()
{
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;
    int nRes = RemoveSysQuals();
    if(nRes != 0)
    {
        MessageBox(IDS_CANNOT_CHANGE_SYSTEM_QUALS, IDS_ERROR, MB_OK);
        return;
    }
    VARIANT v;
    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    HRESULT hres = pQualifierSet->Put(L"not_null", 
                &v,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    if(FAILED(hres))
    {
        MessageBox(IDS_MAY_NOT_SPECIFY_NOT_NULL, IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        
        SetSystemCheck(IDC_NORMAL);
    }
}


void CMethodEditor::OnEditQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;


	int sizeRequired = SendMessage(m_hQualifierList, LB_GETTEXTLEN, nSel, 0);

    wmilib::auto_buffer<char> buf(new char[sizeRequired+1]); 
    if (buf.get() == 0)
        return;

	
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf.get()));
    if (*buf.get() == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf.get(), "%[^\t\0]", name) == EOF)
		return;
	if (*name == 0)
        return;

    WString WName = name;

    // Find the Qualifier in question.
    // ===============================

    VARIANT v;
    VariantInit(&v);
    LONG lType = 0;
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;

    CBString bsWName(WName);

    SCODE res = pQualifierSet->Get(bsWName.GetString(), 0, &v, &lType);
    if (res != 0)
    {
        MessageBox(IDS_QUALIFIER_NOT_FOUND, IDS_CRITICAL_ERROR, MB_OK);
        return;
    }

    // If here, convert temporarily to a CTestQualifier object for the duration of
    // the edit.
    // ====================================================================

    CVar *pNewVal = new CVar;
    pNewVal->SetVariant(&v);
    VariantClear(&v);

    CTestQualifier att;
    att.m_pValue = pNewVal;
    att.m_pName = new wchar_t[wcslen(WName) + 1];
    wcscpy(att.m_pName, WName);
    att.m_lType = lType;

    CTestQualifierEditor ed(m_hDlg, &att, TRUE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        return;
    }

    // If here, the Qualifier is being added.
    // ======================================

    VARIANT *p = att.m_pValue->GetNewVariant();

    CBString bsName(att.m_pName);

    res = pQualifierSet->Put(bsName.GetString(), p, att.m_lType);
    if(FAILED(res))
    {
        FormatError(res, m_hDlg);
    }
    VariantClear(p);
    Refresh();
}

//ok
void CMethodEditor::OnDelQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

	int sizeRequired = SendMessage(m_hQualifierList, LB_GETTEXTLEN, nSel, 0);

    wmilib::auto_buffer<char> buf(new char[sizeRequired+1]); 
    if (buf.get() == 0)
        return;


    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf.get()));
    if (*buf.get() == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf.get(), "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Remove the Qualifier.
    // =====================

    IWbemQualifierSet *pQualifierSet = m_pTarget->m_pQualifiers;

    CBString bsName(WName);

    HRESULT hres = pQualifierSet->Delete(bsName.GetString());
    if(FAILED(hres) || hres != 0)
    {
        FormatError(hres, m_hDlg);
    }
    Refresh();
}

void CMethodEditor::Refresh()
{
    // Zap the current contents.
    // =========================
    SendMessage(m_hQualifierList, LB_RESETCONTENT, 0, 0);
    SetCheck(IDC_NOT_NULL, BST_UNCHECKED);
    SetCheck(IDC_NORMAL, BST_CHECKED);

    EnableWindow(GetDlgItem(IDC_INPUT_ARGS), GetCheck(IDC_CHECKINPUT) == BST_CHECKED);
    EnableWindow(GetDlgItem(IDC_OUTPUT_ARGS), GetCheck(IDC_CHECKOUTPUT) == BST_CHECKED);

    // Fill in the Qualifier list.
    // ===========================

    IWbemQualifierSet *pQualifiers = m_pTarget->m_pQualifiers;

    if(pQualifiers == NULL)
    {
        EnableWindow(m_hQualifierList, FALSE);
        EnableWindow(GetDlgItem(IDC_NOT_NULL), FALSE);
        EnableWindow(GetDlgItem(IDC_NORMAL), FALSE);
        EnableWindow(GetDlgItem(IDC_ADD_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_EDIT_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_DELETE_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_STATIC_QUAL), FALSE);
    }

    if (pQualifiers)
    {
        pQualifiers->BeginEnumeration(0);

        BSTR strName = NULL;
        long lFlavor;
        VARIANT vVal;
        VariantInit(&vVal);

        while(pQualifiers->Next(0, &strName, &vVal, &lFlavor) == S_OK)
        {
            if(!wbem_wcsicmp(strName, L"not_null"))
            {
                if(GetCheck(IDC_KEY) == BST_UNCHECKED && 
                        GetCheck(IDC_INDEXED) == BST_UNCHECKED)
                {
                    SetSystemCheck(IDC_NOT_NULL);
                }
                SysFreeString(strName);
                strName = NULL;
                continue;
            }
                
            CTestQualifier A;
            A.m_pName = new wchar_t[wcslen(strName)+1];
            wcscpy(A.m_pName, strName);
            A.m_pValue = new CVar(&vVal);
            A.m_lType = lFlavor;

            // Build list box string.
            // ======================

            LPSTR stringValue = CTestQualifierToString(&A);
			SendMessage(m_hQualifierList, LB_ADDSTRING, 0,LPARAM(stringValue));
			delete[] stringValue;
            VariantClear(&vVal);
            SysFreeString(strName);
            strName = NULL;
        }

        pQualifiers->EndEnumeration();
        VariantClear(&vVal);
    }
}

BOOL CMethodEditor::OnDoubleClick(int nID)
{
    if(nID == IDC_ATTRIB_LIST)
    {
        OnEditQualifier();
        return TRUE;
    }
    return FALSE;
}

BOOL CMethodEditor::OnSelChange(int nID)
{
    if(nID == IDC_TYPE_LIST)
    {
        char* pszType = GetCBCurSelString(IDC_TYPE_LIST);
        BOOL bArray = (GetCheck(IDC_ARRAY) == BST_CHECKED);
        m_pTarget->m_lType = StringToType(pszType);
        if(bArray)
            m_pTarget->m_lType |= VT_ARRAY;

        if((m_pTarget->m_lType & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_SHOW);
        }
        else
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
        }
        delete [] pszType;
    }
    return TRUE;
}

BOOL CMethodEditor::OnCommand(WORD wCode, WORD wID)
{
    switch(wID)
    {
        case IDC_EDIT_ATTRIB: OnEditQualifier(); return TRUE;

        case IDC_ADD_ATTRIB: OnAddQualifier(); return TRUE;
        case IDC_DELETE_ATTRIB: OnDelQualifier(); return TRUE;
        case IDC_NOT_NULL:
            if(wCode == BN_CLICKED)
                OnNotNull();
            return TRUE;
        case IDC_NORMAL:
            if(wCode == BN_CLICKED)
                RemoveSysQuals();
            return TRUE;
        case IDC_INPUT_ARGS:
            ViewEmbedding(TRUE);
            return TRUE;
        case IDC_OUTPUT_ARGS:
            ViewEmbedding(FALSE);
            return TRUE;
        case IDC_CHECKINPUT:
            m_pTarget->m_bEnableInputArgs = (GetCheck(IDC_CHECKINPUT) == BST_CHECKED);
            Refresh();
            return TRUE;

        case IDC_CHECKOUTPUT:
            m_pTarget->m_bEnableOutputArgs = (GetCheck(IDC_CHECKOUTPUT) == BST_CHECKED);
            Refresh();
            return TRUE;

    }

    return TRUE;
}


BOOL CMethodEditor::OnInitDialog()
{
    ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
    CenterOnParent();

    m_hPropName = GetDlgItem(IDC_PROPNAME);
    m_hQualifierList = GetDlgItem(IDC_ATTRIB_LIST);

    SetCheck(IDC_CHECKINPUT, (m_pTarget->m_bEnableInputArgs) ? BST_CHECKED : BST_UNCHECKED);
    SetCheck(IDC_CHECKOUTPUT, (m_pTarget->m_bEnableOutputArgs) ? BST_CHECKED : BST_UNCHECKED);

    LONG Tabs[] = { 80, 120, 170 };
    int TabCount = 3;

    SendMessage(m_hQualifierList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);


    // Now initialize the controls with the contents of the
    // current object, if any.
    // ====================================================

    if (m_pTarget->m_pName)
    {
        SetWindowText(m_hPropName, LPWSTRToLPSTR(m_pTarget->m_pName));
    }

    if(m_pTarget->m_pClass)
    {
        SetDlgItemText(IDC_ORIGIN, LPWSTRToLPSTR(m_pTarget->m_pClass));
    }


    // Refresh the Qualifiers.
    // =======================

    Refresh();

    // If editing, don't allow type/name change.
    // =========================================

    if (m_bEditOnly)
    {
        EnableWindow(m_hPropName, FALSE);
    }

    if(m_bInstance)
    {
        EnableWindow(GetDlgItem(IDC_NOT_NULL), FALSE);
        EnableWindow(GetDlgItem(IDC_NORMAL), FALSE);
    }

    return TRUE;
}

void CMethodEditor::ViewEmbedding(BOOL bInput)
{

        IWbemClassObject* pCurrentEmbed;
        if(bInput)
            pCurrentEmbed = m_pTarget->m_pInArgs;
        else
            pCurrentEmbed = m_pTarget->m_pOutArgs;

        IWbemClassObject* pEmbed;
        pCurrentEmbed->Clone(&pEmbed);
//        pCurrentEmbed->Release();

        CObjectEditor ed(m_hDlg, 0, CObjectEditor::readwrite | CObjectEditor::nomethods,
                         SYNC, pEmbed);
        if(ed.Edit() == IDOK)
        {
            if(bInput)
                m_pTarget->m_pInArgs = pEmbed;
            else
                m_pTarget->m_pOutArgs = pEmbed;
        }
        else
            pEmbed->Release();
}
                

BOOL CMethodEditor::Verify()
{
    char buf[TEMP_BUF];

    // Verify that name is present.
    // ============================

    if (GetWindowText(m_hPropName, buf, TEMP_BUF) == 0)
    {
        MessageBox(IDS_NO_METHOD_NAME, IDS_ERROR, MB_OK);
        return FALSE;
    }
    StripTrailingWs(buf);

    WString Name = buf;

    if (m_pTarget->m_pName)
        delete m_pTarget->m_pName;

    m_pTarget->m_pName = new wchar_t[wcslen(Name) + 1];
    wcscpy(m_pTarget->m_pName, Name);

    return TRUE;
}

CMethodEditor::CMethodEditor(
    HWND hParent,
    CTestMethod *pMethod,
    BOOL bEditOnly,
    BOOL bInstance
    ) : CWbemDialog(IDD_METHOD_EDITOR, hParent)
{
    m_pTarget = pMethod;
    m_bEditOnly = bEditOnly;
    m_bInstance = bInstance;
}

INT_PTR CMethodEditor::Edit()
{
    return Run();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\notsink.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    NOTSINK.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "notsink.h"
#include <stdio.h>
#include "wbemntfy.h"

extern CStatusMonitor gStatus; 

// Notification Query Sink

SCODE CNotSink::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = this;
    }
    else if (riid == IID_IWbemObjectSink)
        *ppvObj = this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}


ULONG CNotSink::AddRef()
{
    InterlockedIncrement(&m_lRefCount);
    return (ULONG) m_lRefCount;
}

ULONG CNotSink::Release()
{
    InterlockedDecrement(&m_lRefCount);

    if (0 != m_lRefCount)
    {
        return 1;
    }

    delete this;
    return 0;
}


SCODE CNotSink::Indicate(
    long lObjectCount,
    IWbemClassObject ** pObjArray
    )
{
    if(lObjectCount == 0) return WBEM_NO_ERROR;
    if(m_pViewer == NULL) return WBEM_NO_ERROR;

    // Use critical section to prevent re-entrancy
    // from additional Indicate's into this code.
    EnterCriticalSection(&m_cs);
    for (int i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject *pObj = pObjArray[i];
        m_pViewer->PostObject(pObj);
    }
    m_pViewer->PostCount(lObjectCount);
    LeaveCriticalSection(&m_cs);

    return WBEM_NO_ERROR;
}

STDMETHODIMP CNotSink::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{ 
    if(lFlags & WBEM_STATUS_PROGRESS)
    {
        gStatus.Add(lFlags, lParam, strParam);
        return WBEM_NO_ERROR;
    }

    EnterCriticalSection(&m_cs);
    if(m_pViewer)
        m_pViewer->PostComplete(lParam, strParam, pObjParam);
    LeaveCriticalSection(&m_cs);
    return WBEM_S_NO_ERROR;
}

CNotSink::CNotSink(CQueryResultDlg* pViewer)
{
    m_lRefCount = 1;
    m_pViewer = pViewer;
    InitializeCriticalSection(&m_cs);
}

CNotSink::~CNotSink()
{
    DeleteCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#define STRSAFE_NO_DEPRECATE
#include <ole2.h>
#include <windows.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    RESOURCE.H

Abstract:

History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Wbemtest.x.rc
//
#define IDD_DIALOGBAR                   103
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\objedit.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OBJEDIT.CPP

Abstract:

    WBEMTEST object editor classes.

History:

    a-raymcc    12-Jun-96       Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "wbemqual.h"

#include "resource.h"
#include "resrc1.h"
#include "objedit.h"
#include "wbemtest.h"
//#include <wbemutil.h>
#include "textconv.h"
#include <cominit.h>
#include "bstring.h"
#include "WT_wstring.h"
#include "method.h"
#include <autoptr.h>
// following were changed due to very large SNMP properties

#define LARGE_BUF   2096

#define IDC_CLASS           IDC_SUPERCLASS
#define IDC_REFERENCES      IDC_DERIVED
#define IDC_ASSOCIATIONS    IDC_INSTANCES

extern DWORD            gdwAuthLevel;
extern DWORD            gdwImpLevel;
extern BSTR             gpPrincipal;
extern COAUTHIDENTITY*  gpAuthIdentity;

char *ValidQualifierTypes[] =
{
    "CIM_SINT32",
    "CIM_STRING",
    "CIM_BOOLEAN",
    "CIM_REAL64"
};

void CopyQualifierSet(IWbemQualifierSet* pDest, IWbemQualifierSet* pSrc, HWND hDlg)
{
    pSrc->BeginEnumeration(0);

    BSTR strName = NULL;
    VARIANT vVal;
    VariantInit(&vVal);
    long lFlavor;
    while(pSrc->Next(0, &strName, &vVal, &lFlavor) == S_OK)
    {
        if(!wbem_wcsicmp(strName, L"cimtype") && 
           !wbem_wcsicmp(V_BSTR(&vVal), L"sint32")) continue;
        SCODE hres = pDest->Put(strName, &vVal, lFlavor);
        if(FAILED(hres))
        {
            FormatError(hres, hDlg);
        }
    }
}

const int nNumValidQualifierTypes = sizeof(ValidQualifierTypes) / sizeof(char *);

LPSTR TypeToString(CVar *p)
{
    return TypeToString(p->GetOleType());
}

LPSTR LPWSTRToLPSTR(LPWSTR pWStr)
{
    static char buf[TEMP_BUF];
    wcstombs(buf, pWStr, TEMP_BUF);
    buf[TEMP_BUF-1] = '\0';
    return buf;
}


LPSTR CTestQualifierToString(CTestQualifier *pQualifier)
{
	int requiredLength = 0;
	char * typeString = 0;
	char * valueString = 0;
	char * returnString;
	int nameLength = 0;

	if (pQualifier->m_pName)
	{
		nameLength = wcslen(pQualifier->m_pName)+1;
        requiredLength += 2*nameLength;
    }
    if (pQualifier->m_pValue)
    {
		typeString = TypeToString(pQualifier->m_pValue);
		valueString = ValueToNewString(pQualifier->m_pValue);
		requiredLength += strlen(typeString)+strlen(valueString)+2;	//2 tabs
																	// null is nameLength
	}

	returnString = new char[requiredLength];

	if (returnString == 0)
		{
		delete[] valueString;
		return 0;
		}

	if (pQualifier->m_pName)
	{
        wcstombs(returnString, pQualifier->m_pName, nameLength*2);
	}
    
    if (pQualifier->m_pValue)
    {
        strcat(returnString, "\t");
        strcat(returnString, typeString);

        strcat(returnString, "\t");
        strcat(returnString, valueString);
		delete[] valueString;
    }

    return returnString;
}




BOOL CTestQualifierEditor::Verify()
{
    // Get the Qualifier name.
    // =======================
    char NameBuf[TEMP_BUF];
    char buf[TEMP_BUF];
    if (GetWindowText(m_hQualifierName, NameBuf, TEMP_BUF) == 0)
    {
        MessageBox(IDS_INVALID_QUALIFIER_NAME, IDS_ERROR, MB_OK);
        return FALSE;
    }
    StripTrailingWs(NameBuf);

    delete m_pTarget->m_pName;
    WString Tmp(NameBuf);
    m_pTarget->m_pName = new wchar_t[wcslen(Tmp) + 1];
    wcscpy(m_pTarget->m_pName, Tmp);

    // Get the Qualifier flavor.
    // =========================

    m_pTarget->m_lType = 0;

    if (SendMessage(m_hRadioPropClass, BM_GETCHECK, 0, 0) == BST_CHECKED)
        m_pTarget->m_lType |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
    if (SendMessage(m_hRadioPropInst, BM_GETCHECK, 0, 0) == BST_CHECKED)
        m_pTarget->m_lType |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
    if (SendMessage(m_hRadioOverride, BM_GETCHECK, 0, 0) == BST_UNCHECKED)
        m_pTarget->m_lType |= WBEM_FLAVOR_NOT_OVERRIDABLE;
    if (SendMessage(m_hRadioAmended, BM_GETCHECK, 0, 0) == BST_CHECKED)
        m_pTarget->m_lType |= WBEM_FLAVOR_AMENDED;

    // NOTE: do not retrieve origin!

    // Get the type string.
    // ====================

    LRESULT nIndex = SendMessage(m_hQualifierType, CB_GETCURSEL, 0, 0);

    if (SendMessage(m_hQualifierType, CB_GETLBTEXT, nIndex, LPARAM(buf)) == CB_ERR)
    {
        MessageBox(IDS_INVALID_QUALIFIER_TYPE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    // Convert type string to a type.
    // ==============================
    int nType = StringToType(buf);
    if (nType == 0)
    {
        MessageBox(IDS_INVALID_QUALIFIER_TYPE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    if(GetCheck(IDC_ARRAY) == BST_CHECKED)
        nType |= VT_ARRAY;

    // Get the value.
    // ==============
    if (m_pTarget->m_pValue)
    {
        m_pTarget->m_pValue->Empty();
        m_pTarget->m_pValue->SetAsNull();
    }

    CVar *pTemp = 0;

    if (GetWindowText(m_hQualifierVal, buf, TEMP_BUF))
    {
        StripTrailingWs(buf);
        pTemp = StringToValue(buf, nType);
    }
    else  // Value is NULL
    {
        pTemp = new CVar;
    }

    if (pTemp)
    {
        if (m_pTarget->m_pValue)
        {
            *m_pTarget->m_pValue = *pTemp;
            delete pTemp;
        }
        else
            m_pTarget->m_pValue = pTemp;
    }
    else
    {
        MessageBox(IDS_INVALID_VALUE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    return TRUE;
}

BOOL CTestQualifierEditor::OnInitDialog()
{
    CenterOnParent();

    m_hQualifierName = GetDlgItem(IDC_ATTRIB_NAME);
    m_hQualifierVal = GetDlgItem(IDC_ATTRIB_VALUE);
    m_hQualifierType = GetDlgItem(IDC_ATTRIB_TYPE);

    m_hRadioPropInst = GetDlgItem(IDC_PROP_INST);
    m_hRadioPropClass = GetDlgItem(IDC_PROP_CLASS);
    m_hRadioOverride = GetDlgItem(IDC_OVERRIDE);
    m_hRadioPropagated = GetDlgItem(IDC_PROPAGATED);
    m_hRadioAmended = GetDlgItem(IDC_AMENDED);

    SendMessage(m_hRadioPropInst, BM_SETCHECK, 
        (m_pTarget->m_lType & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE)?BST_CHECKED:BST_UNCHECKED,
        0);
    SendMessage(m_hRadioPropClass, BM_SETCHECK, 
        (m_pTarget->m_lType & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS)?BST_CHECKED:BST_UNCHECKED,
        0);
    SendMessage(m_hRadioOverride, BM_SETCHECK,
        (m_pTarget->m_lType & WBEM_FLAVOR_NOT_OVERRIDABLE)?BST_UNCHECKED:BST_CHECKED,
        0);
    SendMessage(m_hRadioPropagated, BM_SETCHECK, 
        (m_pTarget->m_lType & WBEM_FLAVOR_ORIGIN_PROPAGATED)?BST_CHECKED:BST_UNCHECKED,
        0);
    SendMessage(m_hRadioAmended, BM_SETCHECK, 
        (m_pTarget->m_lType & WBEM_FLAVOR_AMENDED)?BST_CHECKED:BST_UNCHECKED,
        0);

    EnableWindow(m_hRadioPropagated, FALSE);

    // Default property name.
    // ======================

    if (m_pTarget->m_pName)
        SetWindowText(m_hQualifierName, LPWSTRToLPSTR(m_pTarget->m_pName));

    // Populate the combo box with the valid Qualifier types
    // ======================================================

    for (int i = 0; i < nNumValidQualifierTypes; i++)
        SendMessage(m_hQualifierType, CB_ADDSTRING, 0, LPARAM(ValidQualifierTypes[i]));

    // If a type is assigned, select it.
    // =================================

    if (m_pTarget->m_pValue) 
    {
        long lType = m_pTarget->m_pValue->GetOleType();
        LPSTR pTypeStr = TypeToString(lType & ~VT_ARRAY);
        SendMessage(m_hQualifierType, CB_SELECTSTRING, WPARAM(-1), 
            LPARAM(pTypeStr));

        // Set the array bit
        // =================

        SetCheck(IDC_ARRAY, 
            ((lType & VT_ARRAY) ? BST_CHECKED : BST_UNCHECKED));
    }
    // Else select VT_BSTR by default.
    // ===============================
    else
    {
        SendMessage(m_hQualifierType, CB_SELECTSTRING, WPARAM(-1), LPARAM("CIM_STRING"));
    }

    // If a value is assigned, initialize it.
    // ======================================

    if (m_pTarget->m_pValue)
    {
        LPSTR pVal = ValueToNewString(m_pTarget->m_pValue);
        SetWindowText(m_hQualifierVal, pVal);
        delete[] pVal;
    }

    // If editing, don't allow the user to change
    // the Qualifier name or type.
    // ==========================================
    if (m_bEditing)
    {
        EnableWindow(m_hQualifierName, FALSE);
    }

    return TRUE;
}

CTestQualifierEditor::CTestQualifierEditor(
    HWND hParent,
    CTestQualifier *pTarget,
    BOOL bEditing
    ) : CWbemDialog(IDD_ATTRIB_EDITOR, hParent)
{
    m_pTarget = pTarget;
    m_bEditing = bEditing;
}

INT_PTR CTestQualifierEditor::Edit()
{
    return Run();
}



CEmbeddedObjectListEditor::CEmbeddedObjectListEditor(HWND hParent, LONG lGenFlags, LONG lQryFlags,
                                                     LPCWSTR wszPropName, CVarVector* pVarVector)
    : CQueryResultDlg(hParent, lGenFlags, lQryFlags), m_wsPropName((LPWSTR)wszPropName)
{
    m_pVarVector = pVarVector;
    for(int i = 0; i < pVarVector->Size(); i++)
    {
		CVar	vTemp;

		pVarVector->FillCVarAt( i, vTemp );

        IWbemClassObject* pObj = (IWbemClassObject*) vTemp.GetEmbeddedObject();
        m_InternalArray.Add(pObj);

        // Verify the object pointer

        if ( NULL != pObj )
        {
            pObj->Release();
        }
    }
}

CEmbeddedObjectListEditor::~CEmbeddedObjectListEditor()
{
    // Prevent object release --- we don't own them.
    // =============================================
}

BOOL CEmbeddedObjectListEditor::OnInitDialog()
{
    char szBuffer[1000];
    char szFormat[104];
    if(LoadString(GetModuleHandle(NULL), IDS_EMBEDDED_ARRAY, szFormat, 104))
    {
        sprintf(szBuffer, szFormat, (LPWSTR)m_wsPropName);
        SetTitle(szBuffer);
    }
    else
        SetTitle("Embedded array");

    BOOL bRet = CQueryResultDlg::OnInitDialog();
    SetComplete(WBEM_S_NO_ERROR, NULL, NULL);
    return bRet;
}

BOOL CEmbeddedObjectListEditor::Verify()
{
	// First AddRef all elements - this is so we don't release objects
	// out from underneath ourselves.
    for(int i = 0; i < m_InternalArray.Size(); i++)
    {
        IWbemClassObject* pObj = (IWbemClassObject*)m_InternalArray[i];

		if ( NULL != pObj )
		{
			pObj->AddRef();
		}
    }

	// Now axe the elements in the Vector
    while(m_pVarVector->Size()) m_pVarVector->RemoveAt(0);

	// First AddRef all elements - this is so we don't release objects
	// out from underneath ourselves.
    for(int i = 0; i < m_InternalArray.Size(); i++)
    {
        IWbemClassObject* pObj = (IWbemClassObject*)m_InternalArray[i];
        CVar v;
        v.SetEmbeddedObject((I_EMBEDDED_OBJECT*)pObj);
        m_pVarVector->Add( v );
    }


    return TRUE;
}

IWbemClassObject* CEmbeddedObjectListEditor::AddNewElement()
{
    return _CreateInstance(m_hDlg, m_lGenFlags, m_lSync, m_lTimeout);
}


BOOL CEmbeddedObjectListEditor::DeleteListElement(int nSel)
{
    return TRUE;
}



//***************************************************************************
//
//  class CTestPropertyEditor
//
//***************************************************************************

class CTestPropertyEditor : public CWbemDialog
{
    CTestProperty *m_pTarget;
    BOOL m_bEditOnly;
    BOOL m_bInstance;
    LONG m_lGenFlags;   // generic WBEM_FLAG_ .. flags
    LONG m_lSync;       // sync, async, semisync
    LONG m_lTimeout;    // used for semisync

    // Control handles.
    // ================

    HWND m_hPropName;
    HWND m_hPropType;
    HWND m_hValue;
    HWND m_hQualifierList;


public:
    CTestPropertyEditor(HWND hParent, LONG lGenFlags, BOOL bEditOnly, LONG lSync, 
                        CTestProperty *pProp, BOOL bInstance, LONG lTimeout);
    INT_PTR Edit();

    BOOL OnInitDialog();
    BOOL Verify();
    BOOL OnCommand(WORD wCode, WORD wID);
    BOOL OnDoubleClick(int nID);
    BOOL OnSelChange(int nID);

    void Refresh();
    void OnAddQualifier();
    void OnDelQualifier();
    void OnEditQualifier();
    void OnKey();
    void OnIndexed();
    void OnNotNull();
    void ViewEmbedding();
    void OnValueNull();
    void OnValueNotNull();
    void OnArray();

    int RemoveSysQuals();
    void SetSystemCheck(int nID);
};


void CTestPropertyEditor::OnAddQualifier()
{
    CTestQualifier att;

    att.m_lType =  
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

    CTestQualifierEditor ed(m_hDlg, &att, FALSE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;


    // If here, the Qualifier is being added.
    // ======================================

    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;

    VARIANT *p = att.m_pValue->GetNewVariant();

    HRESULT hres = pQualifierSet->Put(att.m_pName, p, att.m_lType);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
    }

    VariantClear(p);
    Refresh();
}

void CTestPropertyEditor::SetSystemCheck(int nID)
{
    SetCheck(IDC_KEY, BST_UNCHECKED);
    SetCheck(IDC_INDEXED, BST_UNCHECKED);
    SetCheck(IDC_NOT_NULL, BST_UNCHECKED);
    SetCheck(IDC_NORMAL, BST_UNCHECKED);
    SetCheck(nID, BST_CHECKED);
}

int CTestPropertyEditor::RemoveSysQuals()
{
    IWbemQualifierSet* pSet = m_pTarget->m_pQualifiers;
    HRESULT hres;
    hres = pSet->Delete(L"key");
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        SetSystemCheck(IDC_KEY);
        return IDC_KEY;
    }

    hres = pSet->Delete(L"indexed");
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        SetSystemCheck(IDC_INDEXED);
        return IDC_INDEXED;
    }

    hres = pSet->Delete(L"not_null");
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        SetSystemCheck(IDC_NOT_NULL);
        return IDC_NOT_NULL;
    }

    return 0;
}

void CTestPropertyEditor::OnIndexed()
{
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;
    int nRes = RemoveSysQuals();
    if(nRes != 0)
    {
        MessageBox(IDS_CANNOT_CHANGE_SYSTEM_QUALS, IDS_ERROR, MB_OK);
        return;
    }

    VARIANT v;
    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    HRESULT hres = pQualifierSet->Put(L"indexed", 
                &v,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    if(FAILED(hres))
    {
        MessageBox(IDS_MAY_NOT_SPECIFY_INDEXED, IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        
        SetSystemCheck(IDC_NORMAL);
    }
}

void CTestPropertyEditor::OnKey()
{
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;
    int nRes = RemoveSysQuals();
    if(nRes != 0)
    {
        MessageBox(IDS_CANNOT_CHANGE_SYSTEM_QUALS, IDS_ERROR, MB_OK);
        return;
    }

    VARIANT v;
    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    HRESULT hres = pQualifierSet->Put(L"key", 
                &v,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    if(FAILED(hres) && hres == WBEM_E_CANNOT_BE_KEY)
    {
        MessageBox(IDS_MAY_NOT_SPECIFY_KEY, IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        
        SetSystemCheck(IDC_NORMAL);
    }
}

void CTestPropertyEditor::OnNotNull()
{
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;
    int nRes = RemoveSysQuals();
    if(nRes != 0)
    {
        MessageBox(IDS_CANNOT_CHANGE_SYSTEM_QUALS, IDS_ERROR, MB_OK);
        return;
    }
    VARIANT v;
    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    HRESULT hres = pQualifierSet->Put(L"not_null", 
                &v,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    if(FAILED(hres))
    {
        MessageBox(IDS_MAY_NOT_SPECIFY_NOT_NULL, IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        
        SetSystemCheck(IDC_NORMAL);
    }
}


void CTestPropertyEditor::OnEditQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Find the Qualifier in question.
    // ===============================

    VARIANT v;
    VariantInit(&v);
    LONG lType = 0;
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;

    CBString bsWName(WName);

    SCODE res = pQualifierSet->Get(bsWName.GetString(), 0, &v, &lType);
    if (res != 0)
    {
        MessageBox(IDS_QUALIFIER_NOT_FOUND, IDS_CRITICAL_ERROR, MB_OK);
        return;
    }

    // If here, convert temporarily to a CTestQualifier object for the duration of
    // the edit.
    // ====================================================================

    CVar *pNewVal = new CVar;
    pNewVal->SetVariant(&v);
    VariantClear(&v);

    CTestQualifier att;
    att.m_pValue = pNewVal;
    att.m_pName = new wchar_t[wcslen(WName) + 1];
    wcscpy(att.m_pName, WName);
    att.m_lType = lType;

    CTestQualifierEditor ed(m_hDlg, &att, TRUE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        return;
    }

    // If here, the Qualifier is being added.
    // ======================================

    VARIANT *p = att.m_pValue->GetNewVariant();

    CBString bsName(att.m_pName);

    res = pQualifierSet->Put(bsName.GetString(), p, att.m_lType);
    if(FAILED(res))
    {
        FormatError(res, m_hDlg);
    }
    VariantClear(p);
    Refresh();
}

//ok
void CTestPropertyEditor::OnDelQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Remove the Qualifier.
    // =====================

    IWbemQualifierSet *pQualifierSet = m_pTarget->m_pQualifiers;

    CBString bsName(WName);

    HRESULT hres = pQualifierSet->Delete(bsName.GetString());
    if(FAILED(hres) || hres != 0)
    {
        FormatError(hres, m_hDlg);
    }
    Refresh();
}

void CTestPropertyEditor::Refresh()
{
    // Zap the current contents.
    // =========================
    SendMessage(m_hQualifierList, LB_RESETCONTENT, 0, 0);
    SetCheck(IDC_KEY, BST_UNCHECKED);
    SetCheck(IDC_INDEXED, BST_UNCHECKED);
    SetCheck(IDC_NOT_NULL, BST_UNCHECKED);
    SetCheck(IDC_NORMAL, BST_CHECKED);

    // Fill in the Qualifier list.
    // ===========================

    IWbemQualifierSet *pQualifiers = m_pTarget->m_pQualifiers;

    if(pQualifiers == NULL)
    {
        EnableWindow(m_hQualifierList, FALSE);
        EnableWindow(GetDlgItem(IDC_KEY), FALSE);
        EnableWindow(GetDlgItem(IDC_INDEXED), FALSE);
        EnableWindow(GetDlgItem(IDC_NOT_NULL), FALSE);
        EnableWindow(GetDlgItem(IDC_NORMAL), FALSE);
        EnableWindow(GetDlgItem(IDC_ADD_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_EDIT_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_DELETE_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_STATIC_QUAL), FALSE);
    }

    if (pQualifiers)
    {
        pQualifiers->BeginEnumeration(0);

        BSTR strName = NULL;
        long lFlavor;
        VARIANT vVal;
        VariantInit(&vVal);

        while(pQualifiers->Next(0, &strName, &vVal, &lFlavor) == S_OK)
        {
            if(!wbem_wcsicmp(strName, L"key"))
            {
                SetSystemCheck(IDC_KEY);
                SysFreeString(strName);
                strName = NULL;
                continue;
            }
            else if(!wbem_wcsicmp(strName, L"indexed"))
            {
                if(GetCheck(IDC_KEY) == BST_UNCHECKED)
                {
                    SetSystemCheck(IDC_INDEXED);
                }
                SysFreeString(strName);
                strName = NULL;
                continue;
            }
            else if(!wbem_wcsicmp(strName, L"not_null"))
            {
                if(GetCheck(IDC_KEY) == BST_UNCHECKED && 
                        GetCheck(IDC_INDEXED) == BST_UNCHECKED)
                {
                    SetSystemCheck(IDC_NOT_NULL);
                }
                SysFreeString(strName);
                strName = NULL;
                continue;
            }
                
            CTestQualifier A;
            A.m_pName = new wchar_t[wcslen(strName) + 1];
            wcscpy(A.m_pName, strName);
            A.m_pValue = new CVar(&vVal);
            A.m_lType = lFlavor;

            // Build list box string.
            // ======================
			const char * stringValue = CTestQualifierToString(&A);
            SendMessage(m_hQualifierList, LB_ADDSTRING, 0,LPARAM(stringValue));
			delete[] stringValue;
            VariantClear(&vVal);
            SysFreeString(strName);
            strName = NULL;
        }

        pQualifiers->EndEnumeration();
        VariantClear(&vVal);
    }
}

BOOL CTestPropertyEditor::OnDoubleClick(int nID)
{
    if(nID == IDC_ATTRIB_LIST)
    {
        OnEditQualifier();
        return TRUE;
    }
    return FALSE;
}

BOOL CTestPropertyEditor::OnSelChange(int nID)
{
    if(nID == IDC_TYPE_LIST)
    {
        char* pszType = GetCBCurSelString(IDC_TYPE_LIST);
        BOOL bArray = (GetCheck(IDC_ARRAY) == BST_CHECKED);
        m_pTarget->m_lType = StringToType(pszType);
        if(bArray)
            m_pTarget->m_lType |= VT_ARRAY;

        if((m_pTarget->m_lType & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_SHOW);
        }
        else
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
        }
        delete [] pszType;
    }
    return TRUE;
}

BOOL CTestPropertyEditor::OnCommand(WORD wCode, WORD wID)
{
    switch(wID)
    {
        case IDC_EDIT_ATTRIB: OnEditQualifier(); return TRUE;

        case IDC_ADD_ATTRIB: OnAddQualifier(); return TRUE;
        case IDC_DELETE_ATTRIB: OnDelQualifier(); return TRUE;
        case IDC_KEY:
            if(wCode == BN_CLICKED)
                OnKey();
            return TRUE;
        case IDC_INDEXED:
            if(wCode == BN_CLICKED)
                OnIndexed();
            return TRUE;
        case IDC_NOT_NULL:
            if(wCode == BN_CLICKED)
                OnNotNull();
            return TRUE;
        case IDC_NORMAL:
            if(wCode == BN_CLICKED)
                RemoveSysQuals();
            return TRUE;
        case IDC_VALUE_NULL:
            OnValueNull();
            return TRUE;
        case IDC_VALUE_NOT_NULL:
            OnValueNotNull();
            return TRUE;
        case IDC_EMBEDDING:
            ViewEmbedding();
            return TRUE;
        case IDC_ARRAY:
            OnArray();
            return TRUE;
    }

    return TRUE;
}

void CTestPropertyEditor::OnArray()
{
    if(GetCheck(IDC_ARRAY) == BST_CHECKED)
        m_pTarget->m_lType |= VT_ARRAY;
    else
        m_pTarget->m_lType &= ~VT_ARRAY;
}

void CTestPropertyEditor::OnValueNull()
{      
    if((m_pTarget->m_lType & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
    {
        if(MessageBox(IDS_SAVE_EMBEDDING, IDS_WARNING, 
            MB_ICONQUESTION | MB_YESNO) == IDYES)
        {
            SetCheck(IDC_VALUE_NULL, BST_UNCHECKED);
            SetCheck(IDC_VALUE_NOT_NULL, BST_CHECKED);
            return;
        }
        else
        {
            delete m_pTarget->m_pValue;
            m_pTarget->m_pValue = NULL;
            SetDlgItemText(IDC_VALUE, "");
        }
    }
        
    EnableWindow(m_hValue, FALSE);
    EnableWindow(GetDlgItem(IDC_EMBEDDING), FALSE);
}

void CTestPropertyEditor::OnValueNotNull()
{      
    if((m_pTarget->m_lType & ~VT_ARRAY) != VT_EMBEDDED_OBJECT)
    {
        EnableWindow(m_hValue, TRUE);
    }
    EnableWindow(GetDlgItem(IDC_EMBEDDING), TRUE);
}

BOOL CTestPropertyEditor::OnInitDialog()
{
    ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
    CenterOnParent();

    m_hPropName = GetDlgItem(IDC_PROPNAME);
    m_hPropType = GetDlgItem(IDC_TYPE_LIST);
    m_hValue = GetDlgItem(IDC_VALUE);
    m_hQualifierList = GetDlgItem(IDC_ATTRIB_LIST);

    LONG Tabs[] = { 80, 140, 170 };
    int TabCount = 3;

    SendMessage(m_hQualifierList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    // Populate the combo box with the valid prop types
    // ================================================

    for (int i = 0; i < g_nNumValidPropTypes; i++)
        SendMessage(m_hPropType, CB_ADDSTRING, 0, LPARAM(g_aValidPropTypes[i]));

    SendMessage(m_hPropType, CB_SELECTSTRING, WPARAM(-1), LPARAM("CIM_STRING"));

    // Now initialize the controls with the contents of the
    // current object, if any.
    // ====================================================

    if (m_pTarget->m_pName)
    {
        SetWindowText(m_hPropName, LPWSTRToLPSTR(m_pTarget->m_pName));
    }

    if(m_pTarget->m_pClass)
    {
        SetDlgItemText(IDC_ORIGIN, LPWSTRToLPSTR(m_pTarget->m_pClass));
    }

    // If the value is available, set the text and select.
    // ===================================================

    if (m_pTarget->m_pValue)
    {
        LPSTR pTypeStr = TypeToString(m_pTarget->m_lType & ~VT_ARRAY);
        SendMessage(m_hPropType, CB_SELECTSTRING, WPARAM(-1), LPARAM(pTypeStr));
        if(m_pTarget->m_lType & VT_ARRAY)
            SetCheck(IDC_ARRAY, BST_CHECKED);
        else
            SetCheck(IDC_ARRAY, BST_UNCHECKED);

        if((m_pTarget->m_lType & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_SHOW);
        }

        if(m_pTarget->m_pValue->IsNull())
        {
            SetCheck(IDC_VALUE_NULL, BST_CHECKED);
            EnableWindow(m_hValue, FALSE);
            EnableWindow(GetDlgItem(IDC_EMBEDDING), FALSE);
        }
        else
        {
            SetCheck(IDC_VALUE_NOT_NULL, BST_CHECKED);
            LPSTR pValStr = ValueToNewString(m_pTarget->m_pValue, 
                                            m_pTarget->m_lType);
            SetWindowText(m_hValue, pValStr);
            delete [] pValStr;
            EnableWindow(m_hValue, strstr(pTypeStr, "VT_EMBEDDED_OBJECT") 
                                    == NULL);
        }
    }
    else
    {
        SetCheck(IDC_VALUE_NULL, BST_CHECKED);
        SendMessage(m_hPropType, CB_SELECTSTRING, WPARAM(-1), LPARAM("VT_BSTR"));
        EnableWindow(m_hValue, FALSE);
        EnableWindow(GetDlgItem(IDC_EMBEDDING), FALSE);
    }

    // Refresh the Qualifiers.
    // =======================

    Refresh();

    // If editing, don't allow type/name change.
    // =========================================

    if (m_bEditOnly)
    {
        EnableWindow(m_hPropName, FALSE);
        EnableWindow(m_hPropType, FALSE);
    }

    if(m_bInstance)
    {
        EnableWindow(GetDlgItem(IDC_KEY), FALSE);
        EnableWindow(GetDlgItem(IDC_INDEXED), FALSE);
        EnableWindow(GetDlgItem(IDC_NOT_NULL), FALSE);
        EnableWindow(GetDlgItem(IDC_NORMAL), FALSE);
    }

    return TRUE;
}

void CTestPropertyEditor::ViewEmbedding()
{
    if(m_pTarget->m_lType == VT_EMBEDDED_OBJECT)
    {
        if(m_pTarget->m_pValue != NULL &&
            m_pTarget->m_pValue->GetType() != VT_EMBEDDED_OBJECT)
        {
            delete m_pTarget->m_pValue;
            m_pTarget->m_pValue = NULL;
        }

        if(m_pTarget->m_pValue == NULL)
        {
            m_pTarget->m_pValue = new CVar;
            m_pTarget->m_pValue->SetEmbeddedObject(NULL);
        }

        IWbemClassObject* pCurrentEmbed = 
            (IWbemClassObject*)m_pTarget->m_pValue->GetEmbeddedObject();

        IWbemClassObject* pEmbed;
        if(pCurrentEmbed == NULL)
        {
            pEmbed = PreCreateInstance(m_hDlg, m_lGenFlags, m_lSync, m_lTimeout);
            if(pEmbed == NULL) return;
        }
        else
        {
            pCurrentEmbed->Clone(&pEmbed);
            pCurrentEmbed->Release();
        }

        CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::readwrite, m_lSync, 
                         pEmbed, m_lTimeout);
        if(ed.Edit() == IDOK)
        {
            m_pTarget->m_pValue->SetEmbeddedObject(pEmbed);
            SetDlgItemText(IDC_VALUE, "<embedded object>");
        }

        pEmbed->Release();
    }
    else if(m_pTarget->m_lType == (VT_EMBEDDED_OBJECT | VT_ARRAY))
    {
        if(m_pTarget->m_pValue != NULL &&
            m_pTarget->m_pValue->GetType() != VT_EX_CVARVECTOR)
        {
            delete m_pTarget->m_pValue;
            m_pTarget->m_pValue = NULL;
        }

        if(m_pTarget->m_pValue == NULL)
        {
            m_pTarget->m_pValue = new CVar;
            CVarVector* pvv = new CVarVector(VT_EMBEDDED_OBJECT);
            m_pTarget->m_pValue->SetVarVector(pvv, TRUE);
        }

        CVarVector* pCurrentEmbed = m_pTarget->m_pValue->GetVarVector();
        
        CEmbeddedObjectListEditor ed(m_hDlg, m_lGenFlags, 0, m_pTarget->m_pName,
                                     pCurrentEmbed);
        // Pass on invocation method (sync, async..) related settings for use
        // by any further operations (editing/deleting/etc. of an instance).
        ed.SetCallMethod(m_lSync);
        ed.SetTimeout(m_lTimeout);

        ed.Run();
        SetDlgItemText(IDC_VALUE, "<array of embedded objects>");
    }
    else
    {
        ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
    }
}
                

BOOL CTestPropertyEditor::Verify()
{
    // Buffer is used for property name, value string (which can be long if an array), and type string).
    // Find the largest of the three for buffer length (TEMP_BUF size is used for type).
    int   buflen = max(max(GetWindowTextLength(m_hPropName), GetWindowTextLength(m_hValue)) + 1, TEMP_BUF);
    char* buf = new char[buflen];

    // Verify that name is present.
    // ============================

    if (GetWindowText(m_hPropName, buf, buflen) == 0)
    {
        MessageBox(IDS_NO_PROPERTY_NAME, IDS_ERROR, MB_OK);
        delete [] buf;
        return FALSE;
    }
    StripTrailingWs(buf);

    WString Name = buf;

    if (m_pTarget->m_pName)
        delete m_pTarget->m_pName;

    m_pTarget->m_pName = new wchar_t[wcslen(Name) + 1];
    wcscpy(m_pTarget->m_pName, Name);

    // Get the type.
    // =============

    LRESULT nIndex = SendMessage(m_hPropType, CB_GETCURSEL, 0, 0);

    if (SendMessage(m_hPropType, CB_GETLBTEXT, nIndex, LPARAM(buf)) == CB_ERR)
    {
        MessageBox(IDS_INVALID_PROPERTY_TYPE, IDS_ERROR, MB_OK);
        delete [] buf;
        return FALSE;
    }

    // Convert type string to a type.
    // ==============================

    int nType = StringToType(buf);
    if(GetCheck(IDC_ARRAY) == BST_CHECKED)
        nType |= VT_ARRAY;
    if (nType == 0)
    {
        MessageBox(IDS_INVALID_PROPERTY_TYPE, IDS_ERROR, MB_OK);
        delete [] buf;
        return FALSE;
    }

    m_pTarget->m_lType = nType;

    // Verify that Value is present.
    // =============================

    CVar *p;
    if(GetCheck(IDC_VALUE_NULL) == BST_CHECKED)
    {
        p = new CVar;
        p->SetAsNull();
    }
    else
    {
        *buf = 0;
        GetWindowText(m_hValue, buf, buflen);
        StripTrailingWs(buf);

        // Convert value string to the correct value.
        // ==========================================

        if((nType & ~VT_ARRAY) != VT_EMBEDDED_OBJECT)
        {
            p = StringToValue(buf, nType);
        }
        else
        {
            // otherwise already there
            p = m_pTarget->m_pValue;
        }
    }

    if (!p)
    {
        MessageBox(IDS_INVALID_PROPERTY_VALUE, IDS_ERROR, MB_OK);
        delete [] buf;
        return FALSE;
    }

    if(m_pTarget->m_pValue != p)
    {
        if (m_pTarget->m_pValue)
            delete m_pTarget->m_pValue;

        m_pTarget->m_pValue = p;
    }

    delete [] buf;
    return TRUE;
}

CTestPropertyEditor::CTestPropertyEditor(HWND hParent, LONG lGenFlags, BOOL bEditOnly, LONG lSync,
                                         CTestProperty* pProp, BOOL bInstance, LONG lTimeout) 
    : CWbemDialog(IDD_PROPERTY_EDITOR, hParent)
{
    m_pTarget = pProp;
    m_lGenFlags = lGenFlags;
    m_bEditOnly = bEditOnly;
    m_lSync = lSync;
    m_bInstance = bInstance;
    m_lTimeout = lTimeout;
}

INT_PTR CTestPropertyEditor::Edit()
{
    return Run();
}

void CObjectEditor::OnAddQualifier()
{
    CTestQualifier att;

    att.m_lType = WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

    CTestQualifierEditor ed(m_hDlg, &att, FALSE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    // If here, the Qualifier is being added.
    // ======================================

    IWbemQualifierSet* pQualifierSet = 0;
    m_pObj->GetQualifierSet(&pQualifierSet);

    VARIANT *p = att.m_pValue->GetNewVariant();

    CBString bsName(att.m_pName);

    /*
    DWORD dwFlavor = 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
    */

    HRESULT hres = pQualifierSet->Put(bsName.GetString(), p, att.m_lType);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
    }
    VariantClear(p);
    pQualifierSet->Release();
    Refresh();
}

void CObjectEditor::OnEditQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

	int sizeRequired = SendMessage(m_hQualifierList, LB_GETTEXTLEN, nSel, 0);

    wmilib::auto_buffer<char> buf(new char[sizeRequired+1]); 
    if (buf.get() == 0)
        return;

    *buf = 0;
    
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf.get()));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf.get(), "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Find the Qualifier in question.
    // ===============================

    IWbemQualifierSet* pQualifierSet = 0;
    VARIANT v;
    VariantInit(&v);
    LONG lType = 0;
    m_pObj->GetQualifierSet(&pQualifierSet);
    SCODE res = pQualifierSet->Get(WName, 0, &v, &lType);
    if (res != 0)
    {
        MessageBox(IDS_QUALIFIER_NOT_FOUND, IDS_CRITICAL_ERROR, MB_OK);
        pQualifierSet->Release();
        return;
    }

    // If here, convert temporarily to a CTestQualifier object for the duration of
    // the edit.
    // ====================================================================

    CVar *pNewVal = new CVar;
    pNewVal->SetVariant(&v);
    VariantClear(&v);

    CTestQualifier att;
    att.m_pValue = pNewVal;
    att.m_pName = new wchar_t[wcslen(WName) + 1];
    wcscpy(att.m_pName, WName);
    att.m_lType = lType;

    CTestQualifierEditor ed(m_hDlg, &att, TRUE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        pQualifierSet->Release();
        return;
    }

    // If here, the Qualifier is being added.
    // ======================================

    m_pObj->GetQualifierSet(&pQualifierSet);

    VARIANT *p = att.m_pValue->GetNewVariant();

    CBString bsName(att.m_pName);

    res = pQualifierSet->Put(bsName.GetString(), p, att.m_lType);
    if(FAILED(res))
    {
        FormatError(res, m_hDlg);
    }
    VariantClear(p);
    pQualifierSet->Release();
    Refresh();
}

//
//
// Called when deleting an Qualifier on the object itself.
//

void CObjectEditor::OnDelQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Remove the Qualifier.
    // =====================

    IWbemQualifierSet *pQualifierSet;
    m_pObj->GetQualifierSet(&pQualifierSet);
    HRESULT hres = pQualifierSet->Delete(WName);
    if(FAILED(hres) || hres != 0)
    {
        FormatError(hres, m_hDlg);
    }
    pQualifierSet->Release();
    Refresh();
}

void CObjectEditor::OnAddProp()
{
    HRESULT hres;

    // Add a dummy property for now
    // ============================

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_I4;
    V_I4(&v) = 1;

    CBString bsTemp(L"DUMMY_PROPERTY__D");

    if(FAILED(m_pObj->Put(bsTemp.GetString(), 0, &v, 0)))
    {
        MessageBox(NULL, IDS_CANNOT_ADD_PROPERTIES, IDS_ERROR, MB_OK|MB_ICONSTOP);
        return;
    }

    IWbemQualifierSet* pQualifierSet;
    m_pObj->GetPropertyQualifierSet(bsTemp.GetString(), &pQualifierSet);

    // Create CTestProperty with the dummy attr set for now
    // ================================================
    CTestProperty prop(pQualifierSet);

    VariantClear(&v);
    hres = m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
    
    if (hres != S_OK || V_VT(&v) != VT_BSTR )
    {
        prop.m_pClass = new wchar_t[wcslen(L"Unknown") + 1];
        wcscpy(prop.m_pClass, L"Unknown");
    }
    else
    {
        prop.m_pClass = new wchar_t[wcslen(V_BSTR(&v)) + 1];
        wcscpy(prop.m_pClass, V_BSTR(&v));
        VariantClear(&v);
    }

    CTestPropertyEditor ed(m_hDlg, m_lGenFlags, FALSE, m_lSync, &prop, FALSE, 
                           m_lTimeout);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        pQualifierSet->Release();
        m_pObj->Delete(bsTemp.GetString());
        return;
    }

    // Set the property
    // ================

    VARIANT* pVariant = prop.m_pValue->GetNewVariant();

    bsTemp = prop.m_pName;

    VARTYPE vtType;
    if(m_bClass)
    {
        vtType = (VARTYPE)prop.m_lType;
    }
    else 
    {
        vtType = 0;
    }

    hres = m_pObj->Put(bsTemp.GetString(), 0, pVariant, vtType);
    VariantClear(pVariant);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
        return;
    }

    // Copy the Qualifiers
    // ===================

    IWbemQualifierSet* pRealQualifierSet;

    bsTemp = prop.m_pName;
    m_pObj->GetPropertyQualifierSet(bsTemp.GetString(), &pRealQualifierSet);
    CopyQualifierSet(pRealQualifierSet, pQualifierSet, m_hDlg);

    pQualifierSet->EndEnumeration();
    pQualifierSet->Release();
    pRealQualifierSet->Release();

    bsTemp = L"DUMMY_PROPERTY__D";
    m_pObj->Delete(bsTemp.GetString());

    Refresh();
}

void CObjectEditor::OnEditProp()
{
    // Find out which property is selected.
    // ====================================

    LRESULT nIndex = SendMessage(m_hPropList, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hPropList, LB_GETTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return;

    // Scan out the property name.
    // ===========================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString wsName = name;

    // Get the property value from the object
    // ======================================

    VARIANT vVal;
    CIMTYPE ctType;
    m_pObj->Get((LPWSTR)wsName, 0, &vVal, &ctType, NULL);

    // Create a CTestProperty from it
    // ==========================

    IWbemQualifierSet* pQualifierSet = 0;
    SCODE sc = m_pObj->GetPropertyQualifierSet((LPWSTR)wsName, &pQualifierSet);

    CTestProperty Copy(pQualifierSet);
    if (pQualifierSet)
        pQualifierSet->Release();

    Copy.m_pName = new wchar_t[wcslen(wsName) + 1];
    wcscpy(Copy.m_pName, wsName);
    Copy.m_pValue = new CVar(&vVal);
    Copy.m_lType = ctType;

    // Note that GetPropertyOrigin can fail for objects returned by Projection
    // Queries, so we need to be careful with strClass.

    BSTR strClass = NULL;
    m_pObj->GetPropertyOrigin((LPWSTR)wsName, &strClass);

    if ( NULL != strClass )
    {
        Copy.m_pClass = new wchar_t[wcslen(strClass)+1];
        wcscpy(Copy.m_pClass, strClass);
        SysFreeString(strClass);
    }

    // Edit it.
    // =========
    CTestPropertyEditor ed(m_hDlg, m_lGenFlags, TRUE, m_lSync, &Copy, !m_bClass, 
                           m_lTimeout);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    // If here, we must replace the info for the property.
    // ===================================================

    VARIANT* pVariant = Copy.m_pValue->GetNewVariant();
    if(m_bClass && V_VT(pVariant) == VT_NULL)
        ctType = (VARTYPE)Copy.m_lType;
    else
        ctType = 0;

    sc = m_pObj->Put(Copy.m_pName, 0, pVariant, ctType);
    VariantClear(pVariant);
    if(FAILED(sc))
    {
        FormatError(sc, m_hDlg);
    }

    Refresh();
}

void CObjectEditor::OnDelProp()
{
    // Find out which property is selected.
    // ====================================

    LRESULT nIndex = SendMessage(m_hPropList, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hPropList, LB_GETTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return;

    // Scan out the property name.
    // ===========================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;
    if(FAILED(m_pObj->Delete(LPWSTR(WName))))
    {
        MessageBox(NULL, IDS_CANNOT_EDIT_PROPERTY, IDS_ERROR,
            MB_OK|MB_ICONSTOP);
        return;
    }

    Refresh();
}

class CMofViewer : public CWbemDialog
{
    BSTR m_strText;
public:
    CMofViewer(HWND hParent, BSTR strText) 
        : CWbemDialog(IDD_MOF, hParent), m_strText(strText)
    {}

    BOOL OnInitDialog();
};

BOOL CMofViewer::OnInitDialog()
{
    int iSize = wcslen(m_strText)*2+1;
    char* szText = new char[iSize];
    wcstombs(szText, m_strText, iSize);
    char* szText1 = new char[strlen(szText)*2+1];
    char* pc = szText;
    char* pc1 = szText1;
    while(*pc)
    {
        if(*pc == '\n')
        {
            *(pc1++) = '\r';
        }
        *(pc1++) = *(pc++);
    }
    *pc1 = 0;
    SetDlgItemText(IDC_MOF, szText1);
    delete [] szText;
    return TRUE;
}

void CObjectEditor::OnShowMof()
{
    BSTR strText;
    HRESULT hres = m_pObj->GetObjectText(0, &strText);
    if(FAILED(hres))
    {
        MessageBox(IDS_MOF_FAILED, IDS_ERROR, MB_OK);
    }
    else
    {
        CMofViewer mv(m_hDlg, strText);
        mv.Run();
    }
}


void CObjectEditor::OnRefreshObject()
{
#if 0
    BSTR strText;
	HRESULT res;
    // Asynchronous
    if (m_lSync & ASYNC)
    {
        MessageBox(IDS_ASYNC_NOT_SUPPORTED, IDS_ERROR, MB_OK);
        return;
    }
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResultEx* pCallRes = NULL;
        CHourGlass hg;
        res = g_pServicesEx->RefreshObject(&m_pObj,
                                m_lGenFlags  | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(m_lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::PutClass call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pServicesEx->RefreshObject(&m_pObj,
                                m_lGenFlags ,
                                g_Context, NULL);
    }




    HRESULT hres = g_pServicesEx->RefreshObject(&m_pObj, 0, NULL, NULL );
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg, NULL);
    }
	else
		Refresh();
#endif	

    HRESULT res;

    if (m_pObj)
    {
        VARIANT Var;
        VariantInit(&Var);
        
	    res = m_pObj->Get(L"__RELPATH",0,&Var,NULL,NULL);

	    if (SUCCEEDED(res))	    
	    {
	        if (VT_BSTR == V_VT(&Var))
	        {
	            IWbemClassObject * pObj = NULL;
			    res = g_pNamespace->GetObject(V_BSTR(&Var),
			                                  m_lGenFlags ,
			                                  g_Context,
			                                  &pObj,
			                                  NULL);
			    if (SUCCEEDED(res))
			    {
			        m_pObj->Release();
			        m_pObj = pObj;
			    }
			    else
			    {
			        FormatError(res, m_hDlg, NULL);
			    }
		    }
		    else
		    {
    		    FormatError(WBEM_E_INVALID_OBJECT, m_hDlg, NULL);
		    }
        }
        else
        {
            FormatError(res, m_hDlg, NULL);
        }
        
	    VariantClear(&Var);
	    
    }

}
BOOL CObjectEditor::OnInitDialog()
{
    CenterOnParent();

    m_hPropList = GetDlgItem(IDC_PROP_LIST);
    m_hQualifierList = GetDlgItem(IDC_ATTRIB_LIST);
    m_hMethodList = GetDlgItem(IDC_METHOD_LIST);

    // Set tabs in the property list box.
    // ==================================
    LONG Tabs[] = { 80, 140, 170 };
    int TabCount = 3;

    SendMessage(m_hPropList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    SendMessage(m_hPropList, LB_SETHORIZONTALEXTENT, 1000, 0);

    SendMessage(m_hQualifierList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    SendMessage(m_hQualifierList, LB_SETHORIZONTALEXTENT, 1000, 0);

    SendMessage(m_hMethodList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    SendMessage(m_hMethodList, LB_SETHORIZONTALEXTENT, 1000, 0);

    if (m_dwEditMode == readonly)
    {
        EnableWindow(GetDlgItem(IDOK), FALSE);
    }

    if (m_bClass)
    {
        SetCheck(IDC_UPDATE_NORMAL, TRUE);
        SetCheck(IDC_UPDATE_COMPATIBLE, TRUE);
    }
    else
    {
        SetCheck(IDC_UPDATE_NORMAL, TRUE);
        EnableWindow(GetDlgItem(IDC_UPDATE_COMPATIBLE), FALSE);
        EnableWindow(GetDlgItem(IDC_UPDATE_SAFE), FALSE);
        EnableWindow(GetDlgItem(IDC_UPDATE_FORCE), FALSE);
    }

    Refresh();
    return TRUE;
}

BOOL CObjectEditor::OnDoubleClick(int nID)
{
    if(nID == IDC_ATTRIB_LIST)
    {
        OnEditQualifier();
        return TRUE;
    }
    else if(nID == IDC_PROP_LIST)
    {
        OnEditProp();
        return TRUE;
    }
    else if(nID == IDC_METHOD_LIST)
    {
        OnEditMethod();
        return TRUE;
    }
    else return FALSE;
}

BOOL CObjectEditor::OnCommand(WORD wCode, WORD wID)
{
    switch(wID)
    {
        case IDC_EDIT_ATTRIB: OnEditQualifier(); return TRUE;

        case IDC_ADD_ATTRIB: OnAddQualifier(); return TRUE;

        case IDC_DELETE_ATTRIB: OnDelQualifier(); return TRUE;
        case IDC_SHOW_MOF: OnShowMof(); return TRUE;
		case IDC_ADD_PROP: OnAddProp(); return TRUE;
        case IDC_EDIT_PROP: OnEditProp(); return TRUE;
        case IDC_DELETE_PROP: OnDelProp(); return TRUE;
        case IDC_ADD_METHOD: OnAddMethod(); return TRUE;
        case IDC_EDIT_METHOD: OnEditMethod(); return TRUE;
        case IDC_DELETE_METHOD: OnDelMethod(); return TRUE;
        case IDC_REFRESH_OBJECT: OnRefreshObject(); return TRUE;

        case IDC_SUPERCLASS: 
            if(m_bClass) OnSuperclass(); 
            else OnClass();
            return TRUE;
        case IDC_DERIVED:
            if(m_bClass) OnDerived();
            else OnRefs();
            return TRUE;
        case IDC_INSTANCES:
            if(m_bClass) OnInstances();
            else OnAssocs();
            return TRUE;
        case IDC_HIDE_SYSTEM:
            OnHideSystem();
            return TRUE;
        case IDC_HIDE_DERIVED:
            OnHideDerived();
            return TRUE;
    }

    return FALSE;
}

void CObjectEditor::OnSuperclass()
{
    // Get the superclass
    // ==================

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__SUPERCLASS", 0, &v, NULL, NULL)) ||
        V_VT(&v) != VT_BSTR)
    {
        MessageBox(IDS_NO_SUPERCLASS, IDS_ERROR, MB_OK);
        return;
    }

    ShowClass(m_hDlg, m_lGenFlags, V_BSTR(&v), m_lSync, m_pOwner, m_lTimeout);
}

void CObjectEditor::OnClass()
{
    // Get the class
    // =============

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL)))
    {
        MessageBox(IDS_CRITICAL_ERROR, IDS_ERROR, MB_OK);
        return;
    }

    ShowClass(m_hDlg, m_lGenFlags, V_BSTR(&v), m_lSync, m_pOwner, m_lTimeout);
}

void CObjectEditor::OnDerived()
{
    // Get the children
    // ================

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL)) ||
        SysStringLen(V_BSTR(&v)) == 0)
    {
        MessageBox(IDS_INCOMPLETE_CLASS, IDS_ERROR, MB_OK);
        return;
    }

    ShowClasses(m_hDlg, m_lGenFlags, WBEM_FLAG_SHALLOW, V_BSTR(&v), m_lSync, m_pOwner,
                m_lTimeout, m_nBatch);
}

void CObjectEditor::OnInstances()
{
    // Get the instances
    // ================

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL)) ||
        SysStringLen(V_BSTR(&v)) == 0)
    {
        MessageBox(IDS_INCOMPLETE_CLASS, IDS_ERROR, MB_OK);
        return;
    }

    ShowInstances(m_hDlg, m_lGenFlags, WBEM_FLAG_SHALLOW, V_BSTR(&v), m_lSync, m_pOwner, 
                  m_lTimeout, m_nBatch);
}

void CObjectEditor::OnRefs()
{
    CQueryResultDlg* pResDlg = new CQueryResultDlg(m_hDlg, m_lGenFlags, WBEM_FLAG_DEEP);
    // Pass on invocation method (sync, async..) and related settings for this
    // query and by any further operations (editing/deleting/etc. of an instance).
    pResDlg->SetCallMethod(m_lSync);
    pResDlg->SetTimeout(m_lTimeout);
    pResDlg->SetBatchCount(m_nBatch);

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__RELPATH", 0, &v, NULL, NULL)) ||
        V_VT(&v) != VT_BSTR)
    {
        MessageBox(IDS_UNREFERENCABLE_OBJECT, IDS_ERROR, MB_OK);
        delete pResDlg;
        return;
    }

    WCHAR* wszQuery = new WCHAR[wcslen(V_BSTR(&v))+100];
    swprintf(wszQuery, L"references of {%s}", V_BSTR(&v));  // Actual query, dont internationalize
    char szTitle[1000];
    char szFormat[104];
    char* pTitle = NULL;
    if(LoadString(GetModuleHandle(NULL), IDS_REFERENCES_OF, szFormat, 104))
    {
        sprintf(szTitle, szFormat, V_BSTR(&v));
        pTitle = szTitle;
    }

    if(_ExecQuery(m_hDlg, m_lGenFlags, WBEM_FLAG_DEEP, wszQuery, L"WQL", m_lSync, 
                  pResDlg, pTitle, m_lTimeout, m_nBatch))
    {
        pResDlg->RunDetached(m_pOwner);
    }
    else
    {
        delete pResDlg;
    }
    delete [] wszQuery;
}

void CObjectEditor::OnAssocs()
{
    CQueryResultDlg* pResDlg = new CQueryResultDlg(m_hDlg, m_lGenFlags, WBEM_FLAG_DEEP);
    // Pass on invocation method (sync, async..) and related settings for this
    // query and by any further operations (editing/deleting/etc. of an instance).
    pResDlg->SetCallMethod(m_lSync);
    pResDlg->SetTimeout(m_lTimeout);
    pResDlg->SetBatchCount(m_nBatch);

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__RELPATH", 0, &v, NULL, NULL)) ||
        V_VT(&v) != VT_BSTR)
    {
        MessageBox(IDS_UNREFERENCABLE_OBJECT, IDS_ERROR, MB_OK);
        delete pResDlg;
        return;
    }

    WCHAR* wszQuery = new WCHAR[wcslen(V_BSTR(&v))+100];
    swprintf(wszQuery, L"associators of {%s}", V_BSTR(&v));  // Actual query, dont internationalize
    char szTitle[1000];
    char szFormat[104];
    char* pTitle = NULL;
    if(LoadString(GetModuleHandle(NULL), IDS_ASSOCIATORS_OF, szFormat, 104))
    {
        sprintf(szTitle, szFormat, V_BSTR(&v));
        pTitle = szTitle;
    }

    if(_ExecQuery(m_hDlg, m_lGenFlags, WBEM_FLAG_DEEP, wszQuery, L"WQL", m_lSync, 
                  pResDlg, pTitle, m_lTimeout, m_nBatch))
    {
        pResDlg->RunDetached(m_pOwner);
    }
    else
    {
        delete pResDlg;
    }
    delete [] wszQuery;
}
        

BOOL CObjectEditor::mstatic_bHideSystemDefault = FALSE;

void CObjectEditor::OnHideSystem()
{
    m_bHideSystem = (GetCheck(IDC_HIDE_SYSTEM) == BST_CHECKED);
    mstatic_bHideSystemDefault = m_bHideSystem;
    Refresh();
}

void CObjectEditor::OnHideDerived()
{
    m_bHideDerived = (GetCheck(IDC_HIDE_DERIVED) == BST_CHECKED);
    Refresh();
}

void CObjectEditor::Refresh()
{
    // Zap the current contents.
    // =========================
    SendMessage(m_hPropList, LB_RESETCONTENT, 0, 0);
    SendMessage(m_hQualifierList, LB_RESETCONTENT, 0, 0);
    SendMessage(m_hMethodList, LB_RESETCONTENT, 0, 0);

    // Set the title to relpath
    // ========================

    char buf[TEMP_BUF];
    char szFormat[1024];

    VARIANT v;
    VariantInit(&v);
    HRESULT hres = m_pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        hres = m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) == VT_NULL)
        {
            hres = m_pObj->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
            if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            {
                LoadString(GetModuleHandle(NULL), IDS_NEW_TOP_LEVEL_CLASS, buf, TEMP_BUF);
            }
            else
            {
                LoadString(GetModuleHandle(NULL), IDS_NEW_CHILD_OF, szFormat, 1024);
                _snprintf(buf, sizeof(buf)/sizeof(buf[0]), szFormat, V_BSTR(&v));
            }

        }
        else
        {
            LoadString(GetModuleHandle(NULL), IDS_INSTANCE_OF, szFormat, 1024);
            _snprintf(buf, sizeof(buf)/sizeof(buf[0]), szFormat, V_BSTR(&v));
        }
    }
    else
    {
        LoadString(GetModuleHandle(NULL), IDS_OBJECT_EDITOR_FOR, szFormat, 1024);
        _snprintf(buf, sizeof(buf)/sizeof(buf[0]), szFormat, V_BSTR(&v));
    }
		buf[sizeof(buf)-1] = '\0';

    VariantClear(&v);

    SetWindowText(m_hDlg, buf);    

    // Fill in the property list.
    // ==========================

    LONG lConFlags = 0;                 // condition flags (i.e., WBEM_CONDITION_FLAG_TYPE)
    if(m_bHideDerived)
        lConFlags = WBEM_FLAG_LOCAL_ONLY;
    else if(m_bHideSystem)
        lConFlags = WBEM_FLAG_NONSYSTEM_ONLY;

    m_pObj->BeginEnumeration(lConFlags);
    BSTR Name = NULL;

    CIMTYPE ctType;
    while (m_pObj->Next(0, &Name, &v, &ctType, NULL) == WBEM_S_NO_ERROR)
    {
        char buf2[TEMP_BUF];
        CVar value(&v);
        LPSTR TypeString = TypeToString(ctType);
        LPSTR ValueString = ValueToNewString(&value, ctType);
        if(strlen(ValueString) > 100)
        {
            ValueString[100] = 0;
        }
        sprintf(buf2, "%S\t%s\t%s", Name, TypeString, ValueString);
        delete [] ValueString;
        SendMessage(m_hPropList, LB_ADDSTRING, 0, LPARAM(buf2));
        VariantClear(&v);
    }
    m_pObj->EndEnumeration();

    // Fill in the Qualifier list.
    // ===========================

    IWbemQualifierSet *pQualifiers = NULL;
    hres = m_pObj->GetQualifierSet(&pQualifiers);
	if(SUCCEEDED(hres))
	{
		pQualifiers->BeginEnumeration(0);

		BSTR strName = NULL;
		VARIANT vVal;
		VariantInit(&vVal);

		long lFlavor;
		while(pQualifiers->Next(0, &strName, &vVal, &lFlavor) == S_OK)
		{
			CTestQualifier A;
			A.m_pName = new wchar_t[wcslen(strName)+1];
			wcscpy(A.m_pName, strName);
			A.m_pValue = new CVar(&vVal);
			A.m_lType = lFlavor;

			// Build list box string.
			// ======================
			const char * stringValue = CTestQualifierToString(&A);
			SendMessage(m_hQualifierList, LB_ADDSTRING, 0,
							LPARAM(stringValue));
			delete [] stringValue;
		}
		pQualifiers->EndEnumeration();
		pQualifiers->Release();
	}
	else
		EnableWindow(m_hQualifierList, FALSE);
    // Fill in the methods

    m_pObj->BeginMethodEnumeration(0);
    while (m_pObj->NextMethod(0, &Name, NULL, NULL) == WBEM_S_NO_ERROR)
    {
        char buf3[TEMP_BUF];
        wcstombs(buf3, Name, TEMP_BUF);
        buf3[TEMP_BUF-1] = '\0';
        SendMessage(m_hMethodList, LB_ADDSTRING, 0, LPARAM(buf3));
        VariantClear(&v);
    }
    m_pObj->EndMethodEnumeration();


    // Configure the buttons
    // =====================

    ConfigureButtons();
}

void CObjectEditor::ConfigureButtons()
{
    VARIANT v;
    VariantInit(&v);

    if(m_bClass)
    {
        // Configure for class
        // ===================

        if(FAILED(m_pObj->Get(L"__SUPERCLASS", 0, &v, NULL, NULL)) ||
            V_VT(&v) != VT_BSTR)
        {
            EnableWindow(GetDlgItem(IDC_SUPERCLASS), FALSE);
        }
        else
        {
            VariantClear(&v);
            EnableWindow(GetDlgItem(IDC_SUPERCLASS), TRUE);
        }
    }
    else
    {
        // Configure for instance
        // ======================

        SetDlgItemText(IDC_CLASS, IDS_CLASS);
        SetDlgItemText(IDC_REFERENCES, IDS_REFERENCES);
        SetDlgItemText(IDC_ASSOCIATIONS, IDS_ASSOCIATORS);

        EnableWindow(GetDlgItem(IDC_KEY), FALSE);
        EnableWindow(GetDlgItem(IDC_INDEXED), FALSE);
    }

    if(m_bNoMethods || !m_bClass)
    {
        EnableWindow(GetDlgItem(IDC_ADD_METHOD), FALSE);
        EnableWindow(GetDlgItem(IDC_EDIT_METHOD), FALSE);
        EnableWindow(GetDlgItem(IDC_DELETE_METHOD), FALSE);
    }

    SetCheck(IDC_HIDE_SYSTEM, m_bHideSystem?BST_CHECKED:BST_UNCHECKED);
    SetCheck(IDC_HIDE_DERIVED, m_bHideDerived?BST_CHECKED:BST_UNCHECKED);
    EnableWindow(GetDlgItem(IDC_HIDE_SYSTEM), !m_bHideDerived);

    if(m_dwEditMode == foreign)
    {
        EnableWindow(GetDlgItem(IDC_CLASS), FALSE);
        EnableWindow(GetDlgItem(IDC_REFERENCES), FALSE);
        EnableWindow(GetDlgItem(IDC_ASSOCIATIONS), FALSE);
        EnableWindow(GetDlgItem(IDOK), FALSE);
    }
}

CObjectEditor::CObjectEditor(HWND hParent, LONG lGenFlags, DWORD dwEditMode, LONG lSync,
                             IWbemClassObject *pObj, LONG lTimeout, ULONG nBatch)
 : CWbemDialog(IDD_OBJECT_EDITOR, hParent)
{
    m_pObj = pObj;
    pObj->AddRef();
    m_dwEditMode = dwEditMode;
    m_bHideSystem = mstatic_bHideSystemDefault;
    m_bHideDerived = FALSE;
    m_bNoMethods = dwEditMode & nomethods;

    m_lGenFlags = lGenFlags;    // generic flags (i.e., WBEM_GENERIC_FLAG_TYPE)
    m_lSync = lSync;            // sync, async, semisync
    m_lTimeout = lTimeout;      // used in semisync only
    m_nBatch = nBatch;          // used in semisync and sync enumerations

    VARIANT v;
    VariantInit(&v);
    m_pObj->Get(L"__GENUS", 0, &v, NULL, NULL);
    m_bClass = (V_I4(&v) == WBEM_GENUS_CLASS);

    m_bResultingObj = NULL;
}

CObjectEditor::~CObjectEditor()
{
    m_pObj->Release();
}

INT_PTR CObjectEditor::Edit()
{
   return Run();
}

BOOL CObjectEditor::OnOK()
{
    if(m_bResultingObj)
    {
        //We need to extract the flag values...
        LONG lChgFlags = 0;             // change flags  (i.e., WBEM_CHANGE_FLAG_TYPE)
        if (GetCheck(IDC_UPDATE_NORMAL))
            lChgFlags |= WBEM_FLAG_CREATE_OR_UPDATE;
        if (GetCheck(IDC_UPDATE_CREATE))
            lChgFlags |= WBEM_FLAG_CREATE_ONLY;
        if (GetCheck(IDC_UPDATE_UPDATE))
            lChgFlags |= WBEM_FLAG_UPDATE_ONLY;
        if (GetCheck(IDC_UPDATE_COMPATIBLE))
            lChgFlags |= WBEM_FLAG_UPDATE_COMPATIBLE;
        if (GetCheck(IDC_UPDATE_SAFE))
            lChgFlags |= WBEM_FLAG_UPDATE_SAFE_MODE;
        if (GetCheck(IDC_UPDATE_FORCE))
            lChgFlags |= WBEM_FLAG_UPDATE_FORCE_MODE;

        if (!ResultingObject(m_pObj, lChgFlags))
            return TRUE;
    }
    return CBasicWbemDialog::OnOK();
}

void CObjectEditor::RunDetached(CRefCountable* pOwner)
{
    m_bResultingObj = TRUE;
    SetOwner(pOwner);
    SetDeleteOnClose();
    Create(FALSE);
}

BOOL CObjectEditor::ResultingObject(IWbemClassObject* pObj, LONG lChgFlags)
{
    BOOL bRes;

    if(m_bClass)
        bRes = _PutClass(m_hDlg, m_lGenFlags, lChgFlags, m_lSync, pObj, m_lTimeout);
    else
        bRes = _PutInstance(m_hDlg, m_lGenFlags, lChgFlags, m_lSync, pObj, m_lTimeout);

    return bRes;
}

void CObjectEditor::OnAddMethod()
{

    // Add a dummy property for now
    // ============================

    SCODE hres;
    VARIANT v;
    v.vt = VT_BSTR;
    IWbemClassObject * pIn = NULL;
    IWbemClassObject * pOut = NULL;
    SCODE sc;
    CBString bsParm(L"__PARAMETERS");

    sc = g_pNamespace->GetObject(bsParm.GetString(), m_lGenFlags, g_Context, &pIn, NULL);
    sc = g_pNamespace->GetObject(bsParm.GetString(), m_lGenFlags, g_Context, &pOut, NULL);

    CBString bsTemp(L"__CLASS");

    v.bstrVal = SysAllocString(L"InArgs");
    sc = pIn->Put(bsTemp.GetString(), 0, &v, 0);
    SysFreeString(v.bstrVal);

    v.bstrVal = SysAllocString(L"OutArgs");
    sc = pOut->Put(bsTemp.GetString(), 0, &v, 0);
    SysFreeString(v.bstrVal);

    bsTemp = L"DUMMY_METHOD__D";

    if(FAILED(m_pObj->PutMethod(bsTemp.GetString(), 0, NULL, NULL)))
    {
        MessageBox(NULL, IDS_CANNOT_EDIT_METHOD, IDS_ERROR, MB_OK|MB_ICONSTOP);
        return;
    }

    IWbemQualifierSet* pQualifierSet;
    m_pObj->GetMethodQualifierSet(bsTemp.GetString(), &pQualifierSet);

    // Create CTestMethod with the dummy attr set for now
    // =================================================

    CTestMethod method(pQualifierSet, pIn, pOut, FALSE, FALSE);

    m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
    method.m_pClass = new wchar_t[wcslen(V_BSTR(&v)) + 1];
    wcscpy(method.m_pClass, V_BSTR(&v));
    VariantClear(&v);

    CMethodEditor ed(m_hDlg, &method, FALSE, FALSE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        pQualifierSet->Release();
        goto DeleteDummy;
    }

    // Set the method
    // ================

     

    bsTemp = method.m_pName;


    hres = m_pObj->PutMethod(bsTemp.GetString(), 0, 
        (method.m_bEnableInputArgs) ? method.m_pInArgs: NULL, 
        (method.m_bEnableOutputArgs) ? method.m_pOutArgs : NULL);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg, NULL);
        goto DeleteDummy;
    }
                
    // Copy the Qualifiers
    // ===================

    IWbemQualifierSet* pRealQualifierSet;

    m_pObj->GetMethodQualifierSet(bsTemp.GetString(), &pRealQualifierSet);

    CopyQualifierSet(pRealQualifierSet, pQualifierSet, m_hDlg);

    pQualifierSet->EndEnumeration();
    pQualifierSet->Release();
    pRealQualifierSet->Release();

    

DeleteDummy:
    bsTemp = L"DUMMY_METHOD__D";
    m_pObj->DeleteMethod(bsTemp.GetString());
    Refresh();
    return;

}

void CObjectEditor::OnEditMethod()
{

    SCODE sc;
    IWbemClassObject * pIn = NULL;
    IWbemClassObject * pOut = NULL;

    // Find out which property is selected.
    // ====================================

    LRESULT nIndex = SendMessage(m_hMethodList, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hMethodList, LB_GETTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return;

    WString wsName = buf;
    CBString bsTemp(L"__CLASS");

    // Get the property value from the object
    // ======================================

    m_pObj->GetMethod((LPWSTR)wsName, 0, &pIn, &pOut); 

    // Create a CTestMethod from it
    // ==========================

    IWbemQualifierSet* pQualifierSet = 0;
    sc = m_pObj->GetMethodQualifierSet((LPWSTR)wsName, &pQualifierSet); 

    IWbemClassObject * pTempIn = pIn;
    IWbemClassObject * pTempOut = pOut;
    VARIANT v;
    v.vt = VT_BSTR;

    // If the current methods lacks an input or output object, then just create a
    // temporary one in case the user decides to start using the input or output object.

    if(pTempIn == NULL)
    {
        CBString bsParm(L"__PARAMETERS");
        sc = g_pNamespace->GetObject(bsParm.GetString(), m_lGenFlags, g_Context, 
                                     &pTempIn, NULL);
        v.bstrVal = SysAllocString(L"InArgs");
        sc = pTempIn->Put(bsTemp.GetString(), 0, &v, 0);
        SysFreeString(v.bstrVal);
    }
    if(pTempOut == NULL)
    {
        CBString bsParm(L"__PARAMETERS");
        sc = g_pNamespace->GetObject(bsParm.GetString(), m_lGenFlags, g_Context, 
                                     &pTempOut, NULL);
        v.bstrVal = SysAllocString(L"OutArgs");
        sc = pTempOut->Put(bsTemp.GetString(), 0, &v, 0);
        SysFreeString(v.bstrVal);
    }

    CTestMethod Copy(pQualifierSet, pTempIn, pTempOut, pIn != NULL, pOut != NULL);
    if (pQualifierSet)
        pQualifierSet->Release();

    Copy.m_pName = new wchar_t[wcslen(wsName) + 1];
    wcscpy(Copy.m_pName, wsName);
    BSTR strClass;
    m_pObj->GetMethodOrigin((LPWSTR)wsName, &strClass); 
    Copy.m_pClass = new wchar_t[wcslen(strClass) + 1];
    wcscpy(Copy.m_pClass, strClass);
    SysFreeString(strClass);

    // Edit it.
    // =========
    CMethodEditor ed(m_hDlg, &Copy, TRUE, !m_bClass);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    // If here, we must replace the info for the property.
    // ===================================================

    sc = m_pObj->PutMethod(Copy.m_pName, 0, 
        (Copy.m_bEnableInputArgs) ? Copy.m_pInArgs : NULL, 
        (Copy.m_bEnableOutputArgs) ? Copy.m_pOutArgs : NULL); 
    if(FAILED(sc))
    {
        FormatError(sc, m_hDlg);
    }

    Refresh();
}

void CObjectEditor::OnDelMethod()
{
    // Find out which property is selected.
    // ====================================

    LRESULT nIndex = SendMessage(m_hMethodList, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hMethodList, LB_GETTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return;

    WString WName = buf;
    if(FAILED(m_pObj->DeleteMethod(LPWSTR(WName)))) 
    {
        MessageBox(NULL, IDS_CANNOT_EDIT_METHOD, IDS_ERROR,
            MB_OK|MB_ICONSTOP);
        return;
    }

    Refresh();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\objedit.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OBJEDIT.H

Abstract:

	WBEMTEST object editor classes.

History:

	a-raymcc    12-Jun-96       Created.

--*/

#ifndef _OBJEDIT_H_
#define _OBJEDIT_H_

#include "wbemqual.h"
#include "wbemdlg.h"
#include "resrc1.h"
#include "wbemtest.h"

#define TEMP_BUF    2096

class CObjectEditor : public CWbemDialog
{
    IWbemClassObject* m_pObj;

    DWORD m_dwEditMode;                     // readwrite, readonly, foreign, nomethods
    HWND  m_hPropList;
    HWND  m_hQualifierList;
    HWND  m_hMethodList;
    BOOL  m_bClass;

    BOOL  m_bHideSystem;
    BOOL  m_bHideDerived;
    BOOL  m_bNoMethods;
    BOOL  m_bResultingObj;

    LONG  m_lGenFlags;  // generic call flags (i.e., WBEM_FLAG_ .. used in IWbemServices methods)
    LONG  m_lSync;      // sync, async, semisync
    LONG  m_lTimeout;   // used in semisync only
    ULONG m_nBatch;     // used in semisync and sync enumerations

    static BOOL mstatic_bHideSystemDefault;

public:
    enum {readwrite = 0, readonly, foreign, nomethods};     // used for edit mode: controls commands (buttons) enabled

    CObjectEditor(HWND hParent, LONG lGenFlags, DWORD dwEditMode, LONG lSync, 
                  IWbemClassObject *pObj, LONG lTimeout = WBEM_INFINITE, 
                  ULONG nBatch = 1);
    ~CObjectEditor();
    INT_PTR  Edit();
    void RunDetached(CRefCountable* pOwner);

protected:
    BOOL OnInitDialog();
    BOOL OnCommand(WORD wCode, WORD wID);
    BOOL OnDoubleClick(int nID);
    BOOL OnOK();
    
    void ConfigureButtons();

    // Buttons
    void OnAddQualifier();
    void OnEditQualifier();
    void OnDelQualifier();

    void OnAddProp();
    void OnEditProp();
    void OnDelProp();

    void OnAddMethod();
    void OnEditMethod();
    void OnDelMethod();

    void OnSuperclass();
    void OnDerived();
    void OnInstances();

    void OnClass();
    void OnRefs();
    void OnAssocs();

    void OnShowMof();
	void OnHideSystem();
    void OnHideDerived();
    void Refresh();
	void OnRefreshObject();
    BOOL ResultingObject(IWbemClassObject* pObj, LONG lChgFlags);
};

//***************************************************************************
//
//  class CTestQualifierEditor
//
//***************************************************************************

class CTestQualifierEditor : public CWbemDialog
{
    HWND m_hQualifierName;
    HWND m_hQualifierVal;
    HWND m_hQualifierType;
    HWND m_hRadioPropInst;
    HWND m_hRadioPropClass;
    HWND m_hRadioOverride;
    HWND m_hRadioPropagated;
    HWND m_hRadioAmended;

    CTestQualifier *m_pTarget;
    BOOL m_bEditing;

public:
    CTestQualifierEditor(HWND hParent, CTestQualifier *pTarget,
                         BOOL bEditing = TRUE);
    INT_PTR Edit();
    BOOL OnInitDialog();
    BOOL Verify();
};
LPSTR CTestQualifierToString(CTestQualifier *pQualifier);
LPSTR LPWSTRToLPSTR(LPWSTR pWStr);

//***************************************************************************
//
//  class CEmbeddedObjectEditor
//
//***************************************************************************

class CEmbeddedObjectListEditor : public CQueryResultDlg
{
protected:
    CVarVector* m_pVarVector;
    WString m_wsPropName;
public:
    CEmbeddedObjectListEditor(HWND hParent, LONG lGenFlags, LONG lQryFlags,
                              LPCWSTR wszPropName, CVarVector* pVarVector);
    ~CEmbeddedObjectListEditor();

    BOOL CanAdd()		{ return TRUE;}
    IWbemClassObject* AddNewElement();
    BOOL DeleteListElement(int nSel);
    BOOL Verify();
    BOOL OnInitDialog();
};

extern char *ValidQualifierTypes[];

extern const int nNumValidQualifierTypes;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\textconv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TEXTCONV.H

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>
//#include <dbgalloc.h>
//#include <arena.h>
#include <var.h>
//#include <wbemutil.h>

#define TEMP_BUF    2096
#define LARGE_BUF   2096

LPWSTR CreateUnicode(LPSTR sz);
LPSTR TypeToString(int nType);
int StringToType(LPSTR pString);
CVar* StringToValue(LPSTR pString, int nValType);
LPSTR ValueToNewString(CVar *pValue, int nValType = 0);
void StripTrailingWs(LPSTR pVal);
void StripTrailingWs(LPWSTR pVal);

extern char *g_aValidPropTypes[];
extern const int g_nNumValidPropTypes;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\textconv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TEXTCONV.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <float.h>
#include <textconv.h>
#include <WT_wstring.h>
#include <bstring.h>
#include <wbemidl.h>

#include "WT_converter.h"

char *g_aValidPropTypes[] =
{
    "CIM_UINT8",
    "CIM_SINT8",
    "CIM_SINT16",
    "CIM_UINT16",
    "CIM_SINT32",
    "CIM_UINT32",
    "CIM_SINT64",
    "CIM_UINT64",
    "CIM_STRING",
    "CIM_BOOLEAN",
    "CIM_REAL32",
    "CIM_REAL64",
    "CIM_DATETIME",
    "CIM_REFERENCE",
    "CIM_OBJECT",
    "CIM_CHAR16",
    "CIM_EMPTY",
};

const int g_nNumValidPropTypes = sizeof(g_aValidPropTypes) / sizeof(char *);

LPWSTR CreateUnicode(LPSTR sz)
{
    int len = strlen(sz);
		WCHAR* wsz = new WCHAR[len+1];
		if (wsz == 0)
				return 0;

		mbstowcs(wsz, sz, len+1);
	  wsz[len] = L'\0';
    return wsz;
}

LPSTR TypeToString(int nType)
{
    static char *pCIM_EMPTY  = "CIM_EMPTY";
    static char *pCIM_UINT8  = "CIM_UINT8";
    static char *pCIM_SINT8  = "CIM_SINT8";
    static char *pCIM_SINT16   = "CIM_SINT16";
    static char *pCIM_UINT16   = "CIM_UINT16";
    static char *pCIM_SINT32   = "CIM_SINT32";
    static char *pCIM_UINT32   = "CIM_UINT32";
    static char *pCIM_SINT64   = "CIM_SINT64";
    static char *pCIM_UINT64   = "CIM_UINT64";
    static char *pCIM_REAL32   = "CIM_REAL32";
    static char *pCIM_REAL64   = "CIM_REAL64";
    static char *pCIM_BOOLEAN = "CIM_BOOLEAN";
    static char *pCIM_STRING = "CIM_STRING";
    static char *pCIM_DATETIME = "CIM_DATETIME";
    static char *pCIM_REFERENCE = "CIM_REFERENCE";
    static char *pCIM_OBJECT = "CIM_OBJECT";
    static char *pCIM_CHAR16 = "CIM_CHAR16";

    static char *pCIM_UINT8_ARRAY  = "CIM_UINT8 | CIM_FLAG_ARRAY";
    static char *pCIM_SINT8_ARRAY  = "CIM_SINT8 | CIM_FLAG_ARRAY";
    static char *pCIM_SINT16_ARRAY   = "CIM_SINT16 | CIM_FLAG_ARRAY";
    static char *pCIM_UINT16_ARRAY   = "CIM_UINT16 | CIM_FLAG_ARRAY";
    static char *pCIM_SINT32_ARRAY   = "CIM_SINT32 | CIM_FLAG_ARRAY";
    static char *pCIM_UINT32_ARRAY   = "CIM_UINT32 | CIM_FLAG_ARRAY";
    static char *pCIM_SINT64_ARRAY   = "CIM_SINT64 | CIM_FLAG_ARRAY";
    static char *pCIM_UINT64_ARRAY   = "CIM_UINT64 | CIM_FLAG_ARRAY";
    static char *pCIM_REAL32_ARRAY   = "CIM_REAL32 | CIM_FLAG_ARRAY";
    static char *pCIM_REAL64_ARRAY   = "CIM_REAL64 | CIM_FLAG_ARRAY";
    static char *pCIM_BOOLEAN_ARRAY = "CIM_BOOLEA | CIM_FLAG_ARRAY";
    static char *pCIM_STRING_ARRAY = "CIM_STRING | CIM_FLAG_ARRAY";
    static char *pCIM_DATETIME_ARRAY = "CIM_DATETIME | CIM_FLAG_ARRAY";
    static char *pCIM_REFERENCE_ARRAY = "CIM_REFERENCE | CIM_FLAG_ARRAY";
    static char *pCIM_OBJECT_ARRAY = "CIM_OBJECT | CIM_FLAG_ARRAY";
    static char *pCIM_CHAR16_ARRAY = "CIM_CHAR16 | CIM_FLAG_ARRAY";
    
    char *pRetVal = "<unknown>";

    switch (nType)
    {
        case CIM_UINT8: pRetVal = pCIM_UINT8; break;
        case CIM_SINT16: pRetVal = pCIM_SINT16; break;
        case CIM_SINT32: pRetVal = pCIM_SINT32; break;
        case CIM_SINT8: pRetVal = pCIM_SINT8; break;
        case CIM_UINT16: pRetVal = pCIM_UINT16; break;
        case CIM_UINT32: pRetVal = pCIM_UINT32; break;
        case CIM_UINT64: pRetVal = pCIM_UINT64; break;
        case CIM_SINT64: pRetVal = pCIM_SINT64; break;
        case CIM_REAL32: pRetVal = pCIM_REAL32; break;
        case CIM_REAL64: pRetVal = pCIM_REAL64; break;
        case CIM_BOOLEAN: pRetVal = pCIM_BOOLEAN; break;
        case CIM_STRING: pRetVal = pCIM_STRING; break;
        case CIM_DATETIME: pRetVal = pCIM_DATETIME; break;
        case CIM_REFERENCE: pRetVal = pCIM_REFERENCE; break;
        case CIM_OBJECT: pRetVal = pCIM_OBJECT; break;
        case CIM_CHAR16: pRetVal = pCIM_CHAR16; break;

        case CIM_UINT8|CIM_FLAG_ARRAY: pRetVal = pCIM_UINT8_ARRAY; break;
        case CIM_SINT16|CIM_FLAG_ARRAY: pRetVal = pCIM_SINT16_ARRAY; break;
        case CIM_SINT32|CIM_FLAG_ARRAY: pRetVal = pCIM_SINT32_ARRAY; break;
        case CIM_SINT8|CIM_FLAG_ARRAY: pRetVal = pCIM_SINT8_ARRAY; break;
        case CIM_UINT16|CIM_FLAG_ARRAY: pRetVal = pCIM_UINT16_ARRAY; break;
        case CIM_UINT32|CIM_FLAG_ARRAY: pRetVal = pCIM_UINT32_ARRAY; break;
        case CIM_UINT64|CIM_FLAG_ARRAY: pRetVal = pCIM_UINT64_ARRAY; break;
        case CIM_SINT64|CIM_FLAG_ARRAY: pRetVal = pCIM_SINT64_ARRAY; break;
        case CIM_REAL32|CIM_FLAG_ARRAY: pRetVal = pCIM_REAL32_ARRAY; break;
        case CIM_REAL64|CIM_FLAG_ARRAY: pRetVal = pCIM_REAL64_ARRAY; break;
        case CIM_BOOLEAN|CIM_FLAG_ARRAY: pRetVal = pCIM_BOOLEAN_ARRAY; break;
        case CIM_STRING|CIM_FLAG_ARRAY: pRetVal = pCIM_STRING_ARRAY; break;
        case CIM_DATETIME|CIM_FLAG_ARRAY: pRetVal = pCIM_DATETIME_ARRAY; break;
        case CIM_REFERENCE|CIM_FLAG_ARRAY: pRetVal = pCIM_REFERENCE_ARRAY;break;
        case CIM_OBJECT|CIM_FLAG_ARRAY: pRetVal = pCIM_OBJECT_ARRAY; break;
        case CIM_CHAR16|CIM_FLAG_ARRAY: pRetVal = pCIM_CHAR16_ARRAY; break;
    }

    return pRetVal;
}

// Returns 0 on error

int StringToType(LPSTR pString)
{
    if(pString == NULL)
        return 0;
    if (wbem_stricmp(pString, "CIM_STRING") == 0)
        return CIM_STRING;
    if (wbem_stricmp(pString, "CIM_UINT8") == 0)
        return CIM_UINT8;
    if (wbem_stricmp(pString, "CIM_SINT16") == 0)
        return CIM_SINT16;
    if (wbem_stricmp(pString, "CIM_SINT32") == 0)
        return CIM_SINT32;
    if (wbem_stricmp(pString, "CIM_SINT8") == 0)
        return CIM_SINT8;
    if (wbem_stricmp(pString, "CIM_UINT16") == 0)
        return CIM_UINT16;
    if (wbem_stricmp(pString, "CIM_UINT32") == 0)
        return CIM_UINT32;
    if (wbem_stricmp(pString, "CIM_UINT64") == 0)
        return CIM_UINT64;
    if (wbem_stricmp(pString, "CIM_SINT64") == 0)
        return CIM_SINT64;
    if (wbem_stricmp(pString, "CIM_BOOLEAN") == 0)
        return CIM_BOOLEAN;
    if (wbem_stricmp(pString, "CIM_DATETIME") == 0)
        return CIM_DATETIME;
    if (wbem_stricmp(pString, "CIM_REFERENCE") == 0)
        return CIM_REFERENCE;
    if (wbem_stricmp(pString, "CIM_REAL32") == 0)
        return CIM_REAL32;
    if (wbem_stricmp(pString, "CIM_REAL64") == 0)
        return CIM_REAL64;
    if (wbem_stricmp(pString, "CIM_EMPTY") == 0)
        return CIM_EMPTY;
    if (wbem_stricmp(pString, "CIM_OBJECT") == 0)
        return CIM_OBJECT;
    if (wbem_stricmp(pString, "CIM_CHAR16") == 0)
        return CIM_CHAR16;
    return 0;
}

// The functions does a preliminary check on arrays looking for leading commas, 
// multiple commas, and trailing commas

bool PrelimCheck(LPSTR pStr)
{
    int iNumCommaSinceLastNum = 3;
    for(; *pStr; pStr++)
    {
        // If not a space or comma, assume we are in a number
        
        if(!isspace(*pStr) && *pStr != ',')
            iNumCommaSinceLastNum = 0;
        if(*pStr == ',')
        {
            if(iNumCommaSinceLastNum > 0)
                return false;
            iNumCommaSinceLastNum++;
        }
    }
    if(iNumCommaSinceLastNum > 0)
        return false;
    else
        return true;
}

CVarVector* GetVT_I8Array(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_BSTR);

    char buf[TEMP_BUF];
    int n = 0;
    buf[0] = 0;

    char* pc = pStr;

    while(*pc)
    {
        if(*pc == ',')
        {
            buf[n] = 0;
            if(n == 0)
            {
                delete pVec;
                return NULL;
            }
            WString s = buf;
            pVec->Add(CVar(VT_BSTR, s));
            n = 0;
            buf[0] = 0;
        }
        else if(!isspace(*pc) && *pc != '"')
        {
            buf[n++] = *pc;
        }

        pc++;
    }

    if(n != 0)
    {
        buf[n] = 0;
        WString s = buf;
        pVec->Add(CVar(VT_BSTR, s));
        n = 0;
    }

    return pVec;
}



CVarVector* GetVT_BSTRArray(LPSTR pStr)
{
    CVarVector *pVec = new CVarVector(VT_BSTR);

    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInString = FALSE;
    while (*pStr)
    {
        if (*pStr == '\"')
        {
            if (bInString)
            {
                WString s = buf;
                pVec->Add(CVar(VT_BSTR, s));
                n = 0;
                bInString = FALSE;
                pStr++;
            }
            else {
                bInString = TRUE;
                pStr++;
                n=0;
                buf[0] = 0;
            }
            continue;
        }

        // Allow for \" escape sequence to include quotes in strings.
        // ==========================================================
        if (*pStr == '\\' && (*(pStr+1) == '\"' || (*(pStr+1) == '\\'))) {
            buf[n] = *(pStr+1);
            buf[++n] = 0;
            pStr += 2;
            continue;
        }

        if (!bInString)
        {
            if (isspace(*pStr) || *pStr == ',') {
                pStr++;
                continue;
            }
            // Error in array element separators
            delete pVec;
            return 0;
        }
        else
        {
            buf[n] = *pStr++;
            buf[++n] = 0;
        }
    }

	if(pVec->Size() < 1)
	{
		delete pVec;
		return 0;
	}
    return pVec;
}

CVarVector* GetVT_BOOLArray(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_BOOL);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bPending = FALSE;

    while (*pStr)
    {
        if (isspace(*pStr))
            pStr++;

        else if (*pStr == ',')
        {
            if (wbem_stricmp(buf, "TRUE") == 0 ||
                wbem_stricmp(buf, "1") == 0 ||
                wbem_stricmp(buf, "-1") == 0)
                pVec->Add(CVar((VARIANT_BOOL) -1, VT_BOOL));

            else if (wbem_stricmp(buf, "FALSE") == 0 || wbem_stricmp(buf, "0") == 0)
                pVec->Add(CVar((VARIANT_BOOL) 0, VT_BOOL));
            else
            {
                delete pVec;
                return NULL;
            }

            pStr++;
            bPending = FALSE;
            n = 0;
            buf[n] = 0;
        }
        else
        {
            buf[n] = *pStr++;
            buf[++n] = 0;
            bPending = TRUE;
        }
    }

    if (bPending)
    {
        if (wbem_stricmp(buf, "TRUE") == 0 ||
            wbem_stricmp(buf, "1") == 0 ||
            wbem_stricmp(buf, "-1") == 0)
            pVec->Add(CVar((VARIANT_BOOL) -1, VT_BOOL));

        else if (wbem_stricmp(buf, "FALSE") == 0 || wbem_stricmp(buf, "0") == 0)
            pVec->Add(CVar((VARIANT_BOOL) 0, VT_BOOL));
        else
        {
            delete pVec;
            return NULL;
        }
    }

    return pVec;
}

CVarVector* GetVT_I4Array(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_I4);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInNum = FALSE;

    while (*pStr)
    {
        if (wbem_isdigit(*pStr) || *pStr == '-')
        {
            bInNum = TRUE;
            buf[n] = *pStr++;
            buf[++n] = 0;
            continue;
        }
        else  // Non digit
        {
            if (bInNum)
            {
                pVec->Add(CVar((LONG) atol(buf)));
                n = 0;
                bInNum = FALSE;
                pStr++;
            }
            else // A separator or trash
            {
                if (*pStr == ',' || isspace(*pStr))
                    pStr++;
                else
                {
                    delete pVec;
                    return 0;
                }
            }
        }
    }

    if (bInNum)
        pVec->Add(CVar((LONG) atol(buf)));

    return pVec;
}

CVarVector* GetVT_I2Array(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_I2);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInNum = FALSE;

    while (*pStr)
    {
        if (wbem_isdigit(*pStr) || *pStr == '-')
        {
            bInNum = TRUE;
            buf[n] = *pStr++;
            buf[++n] = 0;
            continue;
        }
        else  // Non digit
        {
            if (bInNum)
            {
                pVec->Add(CVar((SHORT) atol(buf)));
                n = 0;
                bInNum = FALSE;
                pStr++;
            }
            else // A separator or trash
            {
                if (*pStr == ',' || isspace(*pStr))
                    pStr++;
                else
                {
                    delete pVec;
                    return 0;
                }
            }
        }
    }

    if (bInNum)
        pVec->Add(CVar((SHORT) atol(buf)));

    return pVec;
}



CVarVector* GetVT_UI1Array(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_UI1);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL	bPending = FALSE,
			fFailedConvert = FALSE;

    while ( !fFailedConvert && *pStr )
    {
        if (isspace(*pStr))
            pStr++;

        else if (*pStr == ',')
        {
            BYTE b = 0;
            int nRes = sscanf(buf, "'%c'", &b);
            if (nRes == 0)
            {
                int n2 = 0;
                nRes = sscanf(buf, "0x%X", &n2);
                if (nRes == 0)
                {
                    nRes = sscanf(buf, "%d", &n2);

					// check that n is in the byte range

					if ( n2 >= 0 && n2 <= 0xFF )
					{
						b = (BYTE)n2;
					}
					else
					{
						fFailedConvert = TRUE;
					}
                }
                else b = (BYTE)n2;
            }

			if ( !fFailedConvert )
			{
				pVec->Add(CVar(b));

				pStr++;
				bPending = FALSE;
				n = 0;
				buf[n] = 0;
			}
        }
        else
        {
            buf[n] = *pStr++;
            buf[++n] = 0;
            bPending = TRUE;
        }
    }

    if ( !fFailedConvert && bPending )
    {
        BYTE b = 0;
        int nRes = sscanf(buf, "'%c'", &b);
        if (nRes == 0)
        {
            int n2 = 0;
            nRes = sscanf(buf, "0x%X", &n2);
            if (nRes == 0)
            {
                nRes = sscanf(buf, "%d", &n2);

				// check that n is in the byte range

				if ( n2 >= 0 && n2 <= 0xFF )
				{
					b = (BYTE)n2;
				}
				else
				{
					fFailedConvert = TRUE;
				}
            }
            else b = (BYTE)n2;
        }

		// Don't set the value if the conversion failed
		if ( !fFailedConvert )
		{
			pVec->Add(CVar(b));
		}
    }

	// Check that we didn't fail conversion
	if ( fFailedConvert )
	{
		delete pVec;
		pVec = NULL;
	}

    return pVec;
}

CVarVector* GetVT_R4Array(LPSTR pStr)
{
    int iNumConv;
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_R4);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInNum = FALSE;

    while (*pStr)
    {
        if (*pStr != ',' && !isspace(*pStr))
        {
            bInNum = TRUE;
            buf[n] = *pStr++;
            buf[++n] = 0;
            continue;
        }
        else  // Non digit
        {
            if (bInNum)
            {
                double d = 0.0;
                iNumConv = sscanf(buf, "%lG", &d);
				if (!_finite(d) || iNumConv == 0)
				{
					delete pVec;
					return NULL;
				}
                pVec->Add(CVar((float) d));
                n = 0;
                bInNum = FALSE;
                pStr++;
            }
            else // A separator or trash
            {
                if (*pStr == ',' || isspace(*pStr))
                    pStr++;
                else
                {
                    delete pVec;
                    return 0;
                }
            }
        }
    }

    if (bInNum)
    {
        double d = 0.0;
        iNumConv = sscanf(buf, "%lG", &d);
		if (!_finite(d) || iNumConv == 0)
		{
			delete pVec;
			return NULL;
		}
        pVec->Add(CVar(float(d)));
    }

    return pVec;
}

CVarVector* GetVT_R8Array(LPSTR pStr)
{
    int iNumConv;
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_R8);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInNum = FALSE;

    while (*pStr)
    {
        if (*pStr != ',' && !isspace(*pStr))
        {
            bInNum = TRUE;
            buf[n] = *pStr++;
            buf[++n] = 0;
            continue;
        }
        else  // Non digit
        {
            if (bInNum)
            {
                double d = 0.0;
                iNumConv = sscanf(buf, "%lG", &d);
				if (!_finite(d) || iNumConv == 0)
				{
					delete pVec;
					return NULL;
				}

                pVec->Add(CVar(d));
                n = 0;
                bInNum = FALSE;
                pStr++;
            }
            else // A separator or trash
            {
                if (*pStr == ',' || isspace(*pStr))
                    pStr++;
                else
                {
                    delete pVec;
                    return 0;
                }
            }
        }
    }

    if (bInNum)
    {
        double d = 0.0;
        iNumConv = sscanf(buf, "%lG", &d);
 		if (!_finite(d) || iNumConv ==0)
		{
			delete pVec;
			return NULL;
		}
		pVec->Add(CVar(d));
    }

    return pVec;
}


// Allocates a new copy which must be deleted.

CVar* StringToValue(LPSTR pString, int nValType)
{
    char g;

    CVar *pRet = 0;
    if (pString == 0)
        return 0;

    switch (nValType)
    {
        case CIM_EMPTY:
            pRet = new CVar;
            pRet->SetAsNull();
            break;
        case CIM_CHAR16:
            {
                long l;
                if(sscanf(pString, "%d %c", &l, &g) != 1 && g != '(')
                    return NULL;

                pRet = new CVar;
                pRet->SetLong(l);
            }
            break;
        case CIM_UINT8:
        case CIM_SINT8:
        case CIM_SINT16:
        case CIM_UINT16:
        case CIM_SINT32:
        case CIM_UINT32:
			{
				pRet = new CVar;
				UINT uRetVal = CConverter::Convert(pString, nValType, pRet);
				if (ERR_NOERROR != uRetVal)
					return NULL;
			}
			break;
        case CIM_REAL32:
            {
                double d;
                if(sscanf(pString, "%lG %c", &d, &g) != 1)
                    return NULL;

				if (!_finite(d))
					return NULL;
				if ((d > 3.4E+38) || (d < 3.4E-38))
					return NULL;

                pRet = new CVar;
                pRet->SetFloat(float(d));
            }
            break;

        case CIM_REAL64:
            {
                double d;
                if(sscanf(pString, "%lG %c", &d, &g) != 1)
                    return NULL;
				if (!_finite(d))
					return NULL;
                pRet = new CVar;
                pRet->SetDouble(d);
            }
            break;

        case CIM_BOOLEAN:
            {
                pRet = new CVar;
                pRet->SetBool(0);   // False by default
                if (wbem_stricmp(pString, "TRUE") == 0)
                    pRet->SetBool(-1);
                else if (wbem_stricmp(pString, "FALSE") == 0)
                    pRet->SetBool(0);
                else if (atoi(pString) == 1)
                    pRet->SetBool(-1);
                else if (atoi(pString) == 0)
                    pRet->SetBool(0);
                else
                    return NULL;
            }
            break;

        case CIM_SINT64:
        case CIM_UINT64:
        case CIM_STRING:
        case CIM_DATETIME:
        case CIM_REFERENCE:
            {
                pRet = new CVar;
								wchar_t * wbuf = CreateUnicode(pString);
								if (wbuf != 0)
								{
									CBString bsTemp(wbuf);
									pRet->SetBSTR(bsTemp.GetString());
									delete wbuf;
								}
            }
            break;

        // Array types.
        // ============

        case CIM_SINT64|CIM_FLAG_ARRAY:
        case CIM_UINT64|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_I8Array(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_STRING|CIM_FLAG_ARRAY:
        case CIM_DATETIME|CIM_FLAG_ARRAY:
        case CIM_REFERENCE|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_BSTRArray(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_BOOLEAN|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_BOOLArray(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_UINT8|CIM_FLAG_ARRAY:
        case CIM_SINT8|CIM_FLAG_ARRAY:
        case CIM_UINT16|CIM_FLAG_ARRAY:
        case CIM_SINT16|CIM_FLAG_ARRAY:
        case CIM_UINT32|CIM_FLAG_ARRAY:
		case CIM_SINT32|CIM_FLAG_ARRAY:
			{
				CVarVector *pVec = new CVarVector;
				UINT uRes = CConverter::Convert(pString, (nValType & ~CIM_FLAG_ARRAY), pVec);
				if (ERR_NOERROR != uRes)
					return NULL;
				pRet = new CVar;
				pRet->SetVarVector(pVec, TRUE);
			}break;

        case CIM_CHAR16|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_I2Array(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_REAL32|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_R4Array(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_REAL64|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_R8Array(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;
    }

    return pRet;
}


LPSTR ValueToNewString(CVar *pValue, int vt)
{
    WString wsOut;
    char buf[LARGE_BUF];

    int nType = 0;

    if(pValue->GetType() == VT_NULL)
    {
        nType = CIM_EMPTY;
    }
    else if(vt != 0)
    {
        nType = vt;
    }
    else if (pValue->GetType() == VT_EX_CVARVECTOR)
    {
        nType = pValue->GetVarVector()->GetType();
        nType |= CIM_FLAG_ARRAY;
    }
    else
    {
        nType = pValue->GetType();
    }

    buf[0] = 0;
    switch (nType)
    {
        case CIM_EMPTY:
            sprintf(buf, "<null>");
            break;
        case CIM_OBJECT:
            if(pValue->GetEmbeddedObject() != NULL)
                sprintf(buf, "<embedded object>");
            else
                buf[0] = 0;
            break;
        case CIM_BOOLEAN:
            {
                VARIANT_BOOL b = pValue->GetBool();
                if (!b)
                    sprintf(buf, "FALSE");
                else
                    sprintf(buf, "TRUE");
            }
            break;

        case CIM_UINT8:
            {
                BYTE b = pValue->GetByte();
                sprintf(buf, "%d", (long)b);
            }
            break;

        case CIM_SINT8:
            {
                signed char b = (signed char)pValue->GetByte();
                sprintf(buf, "%d", (long)b);
            }
            break;

        case CIM_SINT16:
        case CIM_CHAR16:
            {
                SHORT i = pValue->GetShort();
                sprintf(buf, "%d (0x%04hx)", i, i);
            }
            break;

        case CIM_UINT16:
            {
                USHORT i = (USHORT)pValue->GetShort();
                sprintf(buf, "%d (0x%X)", (long)i, (long)i);
            }
            break;

        case CIM_SINT32:
            {
                LONG l = pValue->GetLong();
                sprintf(buf, "%d (0x%X)", l, l);
            }
            break;

        case CIM_UINT32:
            {
                ULONG l = (ULONG)pValue->GetLong();
                sprintf(buf, "%lu (0x%X)", l, l);
            }
            break;

        case CIM_REAL32:
            {
                float f = pValue->GetFloat();
                sprintf(buf, "%G", f);

            }
            break;

        case CIM_REAL64:
            {
                double d = pValue->GetDouble();
                sprintf(buf, "%G", d);
            }
            break;

        case CIM_SINT64:
        case CIM_UINT64:
        case CIM_STRING:
        case CIM_DATETIME:
        case CIM_REFERENCE:
            {
                LPWSTR pWStr = pValue->GetLPWSTR();
                wsOut += pWStr;
                *buf = 0;
            }
            break;

        case CIM_SINT64|CIM_FLAG_ARRAY:
        case CIM_UINT64|CIM_FLAG_ARRAY:
        case CIM_STRING|CIM_FLAG_ARRAY:
        case CIM_DATETIME|CIM_FLAG_ARRAY:
        case CIM_REFERENCE|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    LPWSTR pTmp = v.GetLPWSTR();
                    wsOut += L"\"";

                    LPWSTR pTmp2 = new WCHAR[ lstrlenW(pTmp)+1000 ];
                    int nIdx = 0;

                    // Add '\' before any "'s or '\'s
                    // ==============================
                    while(*pTmp) {
                        if(*pTmp == '\"' || *pTmp == '\\') {
                            pTmp2[nIdx++] = '\\';
                        }
                        pTmp2[nIdx++] = *pTmp++;
                    }
                    pTmp2[nIdx] = 0;

                    wsOut += pTmp2;
                    wsOut += L"\"";
                    bFirst = FALSE;
                    delete[] pTmp2;
                }

                *buf = 0;
            }
            break;

        case CIM_UINT8|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    BYTE b = v.GetByte();
                    wchar_t buf2[128];

                    swprintf(buf2, L"%d", (long)b);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_SINT8|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    signed char b = (signed char)v.GetByte();
                    wchar_t buf2[128];

                    swprintf(buf2, L"%d", (long)b);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_BOOLEAN|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    VARIANT_BOOL b = v.GetBool();
                    if (b)
                        wsOut += L"TRUE";
                    else
                        wsOut += L"FALSE";
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_SINT16|CIM_FLAG_ARRAY:
        case CIM_CHAR16|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    SHORT Tmp = v.GetShort();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%ld", (long)Tmp);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_UINT16|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    USHORT Tmp = (USHORT)v.GetShort();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%ld", (long)Tmp);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_SINT32|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    LONG Tmp = v.GetLong();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%d", Tmp);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_UINT32|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    ULONG Tmp = (ULONG)v.GetLong();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%lu", Tmp);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_REAL32|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    double d = v.GetFloat();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%G", d);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_REAL64|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    double d = v.GetDouble();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%G", d);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;
        case CIM_OBJECT|CIM_FLAG_ARRAY:
            if(pValue->GetVarVector() != NULL)
                sprintf(buf, "<array of embedded objects>");
            else
                buf[0] = 0;
            break;

        default:
            sprintf(buf, "<error>");
    }

    wsOut += WString(buf);
    return wsOut.GetLPSTR();
}


void StripTrailingWs(LPSTR pVal)
{
    if (!pVal || strlen(pVal) == 0)
        return;
    for (int i = strlen(pVal) - 1; i >= 0; i--)
        if (isspace(pVal[i])) pVal[i] = 0;
        else break;
}

void StripTrailingWs(LPWSTR pVal)
{
    if (!pVal || wcslen(pVal) == 0)
        return;
    for (int i = wcslen(pVal) - 1; i >= 0; i--)
        if (iswspace(pVal[i])) pVal[i] = 0;
        else break;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wbemtest.rc
//
#define IDS_NOT_REGISTERED              1
#define IDS_EMPTY                       2
#define IDS_ERROR                       3
#define IDC_ADDENUM                     3
#define IDS_MUST_SPECIFY_PATH           4
#define IDS_MUST_SPECIFY_NAME           5
#define IDS_STRANGE_RESULT_CODE         6
#define IDS_INVALID_QUALIFIER_NAME      7
#define IDS_INVALID_QUALIFIER_TYPE      8
#define IDS_INVALID_VALUE               9
#define IDS_CANNOT_CHANGE_SYSTEM_QUALS  10
#define IDS_MAY_NOT_SPECIFY_INDEXED     11
#define IDS_MAY_NOT_SPECIFY_KEY         12
#define IDS_MAY_NOT_SPECIFY_NOT_NULL    13
#define IDS_CRITICAL_ERROR              14
#define IDS_SAVE_EMBEDDING              15
#define IDS_WARNING                     16
#define IDS_NO_PROPERTY_NAME            17
#define IDS_INVALID_PROPERTY_TYPE       18
#define IDS_INVALID_PROPERTY_VALUE      19
#define IDS_QUALIFIER_NOT_FOUND         20
#define IDS_CANNOT_ADD_PROPERTIES       21
#define IDS_CANNOT_EDIT_PROPERTY        22
#define IDS_MOF_FAILED                  23
#define IDS_NO_SUPERCLASS               24
#define IDS_INCOMPLETE_CLASS            25
#define IDS_UNREFERENCABLE_OBJECT       26
#define IDS_WRONG_OBJECT                27
#define IDS_OLE_INIT_FAILED             28
#define IDS_FAILED_IWBEMLOCATOR         29
#define IDS_ABNORMAL_TERMINATION        30
#define IDS_INVALID_NAMESPACE           31
#define IDS_MUST_CLOSE_WINDOWS          32
#define IDS_NO_PATH                     33
#define IDS_NO_INITIAL_CONNECTION       34
#define IDS_MUST_SPECIFY_QUERY          35
#define IDS_MUST_SPECIFY_QUERY_LANGUAGE 36
#define IDS_DELETING_CLASS              37
#define IDS_CLASS                       38
#define IDS_REFERENCES                  39
#define IDS_ASSOCIATORS                 40
#define IDS_NEW_TOP_LEVEL_CLASS         41
#define IDS_NEW_CHILD_OF                42
#define IDS_NEW_INSTANCE_FOR            43
#define IDS_OBJECT_EDITOR_FOR           44
#define IDS_TOP_LEVEL_CLASSES           45
#define IDS_CHILD_CLASSES_OF            46
#define IDS_RECURSIVE_PARENS            47
#define IDS_CLASS_INFO                  48
#define IDS_INSTANCES_OF                49
#define IDS_INSTANCE_OF                 50
#define IDS_NO_CONNECTION               51
#define IDS_REFERENCES_OF               52
#define IDS_ASSOCIATORS_OF              53
#define IDS_ASSOC_COM_EVENT             54
#define IDS_EMBEDDED_ARRAY              55
#define IDD_CONNECT                     101
#define IDD_MAIN                        101
#define IDD_OBJECT_EDITOR               102
#define IDD_PROPERTY_EDITOR             103
#define IDD_ATTRIB_EDITOR               104
#define IDD_QUALIFIER_EDITOR            104
#define IDD_SUPERCLASS                  105
#define IDD_CLASS_NAME                  106
#define IDD_OBJECT_PATH                 107
#define IDM_MAIN_MENU                   109
#define IDD_QUERY_RESULT                110
#define IDD_QUERY                       111
#define IDD_PARENTCLASS                 112
#define IDD_PARENTINFO                  112
#define IDD_EVENT_REGISTRATION          113
#define IDD_EVENT_MONITOR               114
#define IDD_ERROR                       115
#define IDD_ACTUALCONNECT               116
#define IDD_WBEM_CONNECT                116
#define IDD_SECURITY_MAIN               117
#define IDD_USER_SECURITY               118
#define IDD_METHOD                      119
#define IDD_MOF                         120
#define IDD_CONTEXT_EDITOR              121
#define IDD_CONTEXT_PROPERTY            122
#define IDD_METHOD_EDITOR               123
#define IDS_NO_METHOD_NAME              124
#define IDD_STATUS_MONITOR              124
#define IDS_CANNOT_EDIT_METHOD          125
#define IDD_REFRESHER_OBJECT_PATH       125
#define IDS_CANT_GET_CLASS              126
#define IDD_QUERY_RESULT_SORTED         126
#define IDS_CLASS_HAS_NO_METHODS        127
#define IDD_RENAMEDIALOG                127
#define IDS_STRING_METHOD_OK            128
#define IDD_CREATEINSTANCE              128
#define IDS_WBEMTEST                    129
#define IDS_DONE                        130
#define IDS_IN_PROGRESS                 131
#define ERROR_FORMAT_EX                 132
#define ERROR_FORMAT_LONG               133
#define IDS_UNSECAPP_ERROR              134
#define IDS_FAIL_ENABLE_ALL_PRIV        135
#define IDS_NUM_OBJECTS_FORMAT          136
#define IDS_NUM_BATCH_FORMAT            137
#define IDS_ASYNC_NOT_SUPPORTED         138
#define IDD_WBEM_BIND                   139
#define IDS_FAILED_IWBEMBINDER          139
#define IDS_MULTIPLE_SEMISYNC_NOTIFICATION_QUERY_DLG_MSG 140
#define IDS_PARTIALRESULTS              141
#define IDS_NAMESPACE                   142
#define IDS_OBJECT_PATH                 143
#define IDS_NAMESPACE_SCOPE             144
#define IDC_NAMESPACE                   1001
#define IDC_CONNECT                     1002
#define IDC_CREATE_CLASS                1003
#define IDC_GET_CLASS                   1004
#define IDC_GET_CLASSES                 1005
#define IDC_EDIT_CLASS                  1006
#define IDC_DELETE_CLASS                1007
#define IDC_CREATE_INSTANCE             1008
#define IDC_GET_INSTANCE                1009
#define IDC_GET_INSTANCES               1010
#define IDC_EDIT_INSTANCE               1011
#define IDC_DELETE_INSTANCE             1012
#define IDC_QUERY                       1013
#define IDC_STATUS                      1014
#define IDC_ATTRIB_LIST                 1015
#define IDC_EVENTS                      1015
#define IDC_NUM_BATCH                   1015
#define IDC_ADD_ATTRIB                  1016
#define IDC_EDIT_ATTRIB                 1017
#define IDC_DELETE_ATTRIB               1018
#define IDC_PROP_LIST                   1019
#define IDC_ADD_PROP                    1020
#define IDC_EDIT_PROP                   1021
#define IDC_DELETE_PROP                 1022
#define IDC_SHOW_MOF                    1023
#define IDC_SHOW_XML                    1024
#define IDC_PROPNAME                    1025
#define IDC_TYPE_LIST                   1026
#define IDC_VALUE                       1027
#define IDC_ATTRIB_NAME                 1032
#define IDC_ATTRIB_TYPE                 1033
#define IDC_ATTRIB_VALUE                1034
#define IDC_SUPERCLASS                  1035
#define IDC_CLASS_NAME                  1036
#define IDC_DERIVED                     1036
#define IDC_OBJECT_PATH                 1037
#define IDR_CLASS_ATTRIB                1038
#define IDC_METHOD_NAME                 1038
#define IDR_TEMP_ATTRIB                 1039
#define IDR_NAMESPACE_ATTRIB            1040
#define IDR_PRIVATE_ATTRIB              1041
#define IDR_DYNAMIC_KEY                 1050
#define IDR_OBJECT_PATH                 1051
#define IDC_OBJECT_LIST                 1053
#define IDC_QUERY_STRING                1054
#define IDC_QUERY_TYPE                  1055
#define IDC_GET_CLASS_ASYNC             1056
#define IDC_GET_OBJECT_ASYNC            1057
#define IDC_GET_OBJECTS_ASYNC           1058
#define IDC_ASYNC_QUERY                 1059
#define IDC_REFRESH_INSTANCE            1060
#define IDC_REFRESH_INSTANCE_ASYNC      1061
#define IDC_GET_CLASSES_ASYNC           1062
#define IDC_IMMEDIATE_SUBCLASSES        1063
#define IDC_GET_INSTANCE_ASYNC          1063
#define IDC_RECURSIVE_SUBCLASSES        1064
#define IDC_GET_INSTANCES_ASYNC         1064
#define IDC_QUERY_ASYNC                 1065
#define IDC_OPEN_NS                     1067
#define IDC_NUM_OBJECTS                 1068
#define IDC_EXEC_METHOD                 1068
#define IDC_PROP_INST                   1069
#define IDC_PROP_CLASS                  1070
#define IDC_OVERRIDE                    1071
#define IDC_PROPAGATED                  1072
#define IDC_KEY                         1073
#define IDC_AMENDED                     1073
#define IDC_INDEXED                     1074
#define IDC_NOT_NULL                    1075
#define IDC_SPIN                        1078
#define IDC_USE_AMENDED                 1079
#define IDC_ASYNC                       1080
#define IDC_SYNC                        1081
#define IDC_SEMISYNC                    1082
#define IDC_DIRECT_READ                 1083
#define IDC_TYPE                        1084
#define IDC_CLEAR                       1086
#define IDC_DELETE                      1088
#define IDC_ADD                         1089
#define IDC_COPY_SEL                    1090
#define IDC_INSTANCES                   1091
#define IDC_HIDE_SYSTEM                 1092
#define IDC_HIDE_DERIVED                1093
#define IDC_HIDE_DERIVED2               1094
#define IDC_NORMAL                      1096
#define IDC_MESSAGE                     1097
#define IDC_SHOWOBJECT                  1098
#define IDC_ORIGIN                      1099
#define IDC_VALUE_NULL                  1100
#define IDC_VALUE_NOT_NULL              1101
#define IDC_EMBEDDING                   1102
#define IDC_USER                        1104
#define IDC_PASSWORD                    1105
#define IDC_TRANSPORT                   1106
#define IDC_LOCALE                      1107
#define IDC_SECURITY                    1108
#define IDC_AUTHORITY                   1108
#define IDC_ENABLE_NETWORK_ACCESS       1109
#define IDC_LIST1                       1113
#define IDC_METHOD_LIST                 1113
#define IDC_REPORTS                     1113
#define IDC_EDIT                        1116
#define IDC_EDITIN                      1116
#define IDC_EDITOUT                     1117
#define IDC_WBEM_SIGNATURES             1118
#define IDC_WBEM_ENCRYPTION             1119
#define IDC_WBEM_AUTHENTICATION         1121
#define IDC_NTLM_AUTHENTICATION         1122
#define IDC_ACCOUNT_ENABLED             1124
#define IDC_FULL_NAME                   1125
#define IDC_CONFIRM_PASSWORD            1127
#define IDC_READ_ONLY                   1128
#define IDC                             1129
#define IDC_NTLM_DOMAIN                 1130
#define IDC_ENABLE_ANONYMOUS_RW         1131
#define IDC_NULL                        1132
#define IDC_BLANK                       1133
#define IDC_LOCAL_ADMINS                1144
#define IDC_WBEM_USERS                  1145
#define IDC_WBEM_ADMINS                 1146
#define IDC_ADD_GROUP                   1148
#define IDC_ADD_USER                    1149
#define IDC_NTLM_DOMAIN_ADMINS          1150
#define IDC_MOF                         1158
#define IDC_EVT_COUNT                   1159
#define IDC_USE_CONTEXT                 1161
#define IDC_CONTEXT                     1162
#define IDC_VALUE_LIST                  1163
#define IDC_USE_NEXTASYNC               1163
#define IDC_REQUEST                     1165
#define IDC_ARRAY                       1166
#define IDC_REFRESH                     1167
#define IDC_PROTOTYPE                   1169
#define IDC_ADD_METHOD                  1170
#define IDC_EDIT_METHOD                 1171
#define IDC_INPUT_ARGS                  1171
#define IDC_DELETE_METHOD               1172
#define IDC_OUTPUT_ARGS                 1172
#define IDC_EXECUTE_METHOD              1173
#define IDC_CHECKINPUT                  1173
#define IDC_CHECKOUTPUT                 1174
#define IDC_EDITPATH                    1174
#define IDC_METHLIST                    1175
#define IDC_OBJPATH                     1176
#define IDC_OUTRES                      1177
#define IDC_EXECUTE                     1178
#define IDC_AS_EMPTY                    1180
#define IDC_IMP_IDENTIFY                1182
#define IDC_IMP_IMPERSONATE             1183
#define IDC_IMP_DELEGATE                1184
#define IDC_AUTH_NONE                   1185
#define IDC_AUTH_CONNECTION             1186
#define IDC_AUTH_CALL                   1187
#define IDC_AUTH_PACKET                 1188
#define IDC_AUTH_PACKET_INTEGRITY       1189
#define IDC_AUTH_PACKET_PRIVACY         1190
#define IDC_UPDATE_COMPATIBLE           1194
#define IDC_UPDATE_SAFE                 1195
#define IDC_UPDATE_FORCE                1196
#define IDC_UPDATE_CREATE               1199
#define IDC_UPDATE_UPDATE               1200
#define IDC_UPDATE_NORMAL               1202
#define IDC_ENABLE_PRIVILEGES           1204
#define IDC_REFR_OBJECT_PATH            1205
#define IDC_CALL_METHOD                 1209
#define IDC_TIMEOUT                     1211
#define IDC_STATIC_TIMEOUT              1213
#define IDC_STATIC_BATCH                1214
#define IDC_ENUM_OPTIONS                1215
#define IDC_BATCH                       1216
#define IDC_OPTIONS                     1217
#define IDC_OPEN                        1218
#define IDC_ADDOBJECT                   1219
#define IDC_DELETEOBJECT                1220
#define IDC_RENAMEOBJECT                1222
#define IDC_GETOBJECTSECURITY           1223
#define IDC_EDITOLD                     1224
#define IDC_SETOBJECTSECURITY           1224
#define IDC_EDITNEW                     1225
#define IDC_REFRESH_OBJECT              1226
#define IDC_BIND                        1227
#define IDC_USE_CLASSOBJ                1228
#define IDC_USE_SERVICES                1229
#define IDC_CONNECTUSING                1230
#define IDC_INTERFACERETURNED           1231
#define IDC_AUTHORITYLABEL              1232
#define IDC_PATHLABEL                   1233
#define IDC_COMPLETION                  1234
#define IDC_COMPLETIONLABEL             1235
#define IDC_QUERYTEST                   1236
#define IDC_QTAUTOTEST                  1237
#define IDC_QTMANUALTEST                1238
#define IDD_QUERYTEST                   1239
#define IDC_WBEMHELP                    1240
#define IDC_VIEW_REG                    2000
#define IDC_OPEN_VIEWER                 2000
#define IDC_REGISTER                    2001
#define IDC_NOTIFICATION_QUERY          2001
#define IDC_PROVIDE                     2003
#define IDC_STATIC                      -1
#define IDC_MENU_EXIT                   65535
#define IDC_STATIC_QUAL                 65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1237
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemdlg.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMDLG.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemdlg.h>
#include <stdio.h>
#include <wbemutil.h>

CBasicWbemDialog::CBasicWbemDialog(HWND hParent)
{
    m_lRefCount = 0;
    m_hParent = hParent;
    m_hDlg = NULL;
    m_bDeleteOnClose = FALSE;
    m_pOwner = NULL;
}


CBasicWbemDialog::~CBasicWbemDialog()
{
    if(m_pOwner)
        m_pOwner->Release();
}

INT_PTR CALLBACK CBasicWbemDialog::staticDlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        )
{
    CBasicWbemDialog* pThis;
    if(uMsg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pThis = (CBasicWbemDialog*)lParam;
        pThis->m_hDlg = hDlg;
        ShowWindow(hDlg, SW_HIDE);
	}
    else
    {
        pThis = (CBasicWbemDialog*)GetWindowLongPtr(hDlg, DWLP_USER);
    }

    if(pThis)
    {
        return pThis->DlgProc(hDlg, uMsg, wParam, lParam);
    }
    else return FALSE;
}


INT_PTR CALLBACK CBasicWbemDialog::DlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        )
{    
    switch(uMsg)
    {
    case WM_INITDIALOG:
	{
		CenterOnParent();
        return OnInitDialog();
	}
    case WM_COMMAND:
        if(LOWORD(wParam) == IDOK)
            return OnOK();
        else if(LOWORD(wParam) == IDCANCEL)
            return OnCancel();
        else if(HIWORD(wParam) == LBN_DBLCLK)
            return OnDoubleClick(LOWORD(wParam));
        else if(HIWORD(wParam) == LBN_SELCHANGE || HIWORD(wParam)==CBN_SELCHANGE)
            return OnSelChange(LOWORD(wParam));
        else
            return OnCommand(HIWORD(wParam), LOWORD(wParam));
    case WM_ACTIVATE:
        if(!m_bModal)
        {
            if(LOWORD(wParam) != WA_INACTIVE)
            {
                ms_hCurrentModeless = m_hDlg;
            }
            else
            {
                ms_hCurrentModeless = NULL;
            }
        }
        return TRUE;
    case WM_CLOSE:
        EndDialog(IDCANCEL);
        DestroyWindow(hDlg);
        return TRUE;
    case WM_NCDESTROY:
        if(m_bDeleteOnClose)
        {
            delete this;
        }
        return TRUE;
    case WM_VKEYTOITEM:
    	{
	    	WORD KeyCode = LOWORD(wParam);            
	    	if (VK_SPACE == KeyCode)
	    	{
	    	    int ListBoxId = GetDlgCtrlID((HWND)lParam);
	    	    OnDoubleClick(ListBoxId);
	    	}
    	}
    	return (BOOL)-1;
    case WM_APP:        // safe private message range (doesn't overlap with dialog controls)
        return OnUser(wParam, lParam);
    }
    return FALSE;
}


BOOL CBasicWbemDialog::OnOK()
{
    if(Verify())
    {
        EndDialog(IDOK);
        return TRUE;
    }
    else return FALSE;
}


BOOL CBasicWbemDialog::OnCancel()
{
    EndDialog(IDCANCEL);
    return TRUE;
}


BOOL CBasicWbemDialog::EndDialog(int nResult)
{
    if(m_bModal)
    {
//        PostMessage(m_hDlg, WM_DESTROY, 0, (LPARAM)nResult);
//        return TRUE;
        return ::EndDialog(m_hDlg, nResult);
    }
    else
    {
        DestroyWindow(m_hDlg);
        return TRUE;
    }
}


WORD CBasicWbemDialog::GetCheck(int nID)
{
    return (WORD)SendMessage(GetDlgItem(nID), BM_GETCHECK, 0, 0);
}


void CBasicWbemDialog::SetCheck(int nID, WORD wCheck)
{
    SendMessage(GetDlgItem(nID), BM_SETCHECK, wCheck, 0);
}

UINT CBasicWbemDialog::GetDlgItemTextX(
    int nDlgItem,
    LPWSTR pStr,
    int nMaxCount
    )
///////////////////////////////////////////////////////////////////
//
//	Starts a loop which creates a buffer of an initial conservative 
//	size and attempts to retrieve the dialog text using the buffer.  
//	If the buffer overflows, iterate the loop, deleting the current 
//	buffer, and recreating it incrementally larger.  Continue until
//	full text is retrieved.  If pStr is NULL, then the inner buffer
//	is not copied.
//
//	PARAMETERS: The dialog item ID, a buffer pointer to receive 
//				the string, the size of the buffer
//	
//	RETURNS:	The size of the total amount of text in the dialog
//				item, or 0 on failure/empty buffer.  It is up 
//				to the caller to compare the buffer size to the 
//				return value to determine of all text was recieved
//
///////////////////////////////////////////////////////////////////
{
	size_t	uLen = 0;		// Size of the internal buffer
	WCHAR	*pTmpStr = 0;	// The internal buffer
	UINT	uRes;			// The return value

	do {
		// Delete the previous buffer
		if (pTmpStr)
			delete [] pTmpStr;

		// Increase the size of the buffer
		uLen += 2048;

		pTmpStr = new WCHAR[ uLen+1 ];
		if (0 == pTmpStr)
			return 0;
		
		// Get the text
		uRes = GetDlgItemTextW(m_hDlg, nDlgItem, pTmpStr, uLen);

		// Verify the text
		if (uRes == 0 || wcslen(pTmpStr) == 0)
			return 0;

	// If the buffer is smaller than the text, 
	//	then continue to expand the buffer
	} while(uRes >= (uLen - 1));
        
	if (NULL != pStr)
            StringCchCopyW(pStr,nMaxCount,pTmpStr);

	delete [] pTmpStr;

	// Return the size of the text in the dlg box - regardless of 
	//	whether it was copied or not.
	return uRes;
}

BOOL CBasicWbemDialog::SetDlgItemTextX(int ID, WCHAR * pwc)
{
	int iLen = 2*(wcslen(pwc))+1;
	char * pTemp = new char[iLen];
	if(pTemp == NULL)
		return FALSE;
	wcstombs(pTemp, pwc, iLen);
	SetDlgItemText(ID, pTemp);
	delete [] pTemp;
    return TRUE;
}

void CBasicWbemDialog::AddStringToCombo(int nID, LPSTR szString, DWORD dwItemData)
{
	HWND hControl=GetDlgItem(nID);
	if (hControl!=NULL)
	{
		int pos=(int)SendMessage(GetDlgItem(nID), CB_ADDSTRING, 0, LPARAM(szString));
		if (dwItemData!=CB_ERR && pos!=CB_ERR)
		{
			SendMessage (hControl, CB_SETITEMDATA, pos, dwItemData);
		}
	}
}


void CBasicWbemDialog::SetComboSelection (int nID, DWORD dwItemData)
{
	HWND hControl=GetDlgItem(nID);
	int count=(int)SendMessage (hControl, CB_GETCOUNT, 0, 0L);
	for (int pos=0; pos<count; pos++)
	{
		DWORD dwTestData=(DWORD)SendMessage (hControl, CB_GETITEMDATA, pos, 0L);
		if (dwTestData==dwItemData)
		{
			SendMessage (hControl, CB_SETCURSEL, pos, 0L);
		}
	}
}


void CBasicWbemDialog::AddStringToList(int nID, LPSTR szString)
{
    SendMessage(GetDlgItem(nID), LB_ADDSTRING, 0, LPARAM(szString));
}


void CBasicWbemDialog::CenterOnParent()
{
    RECT rParent;

    if(m_hParent == NULL)
    {     
        GetWindowRect(GetDesktopWindow(), &rParent);
    }
    else
    {
        GetWindowRect(m_hParent, &rParent);
    }
        
    RECT rUs;
    GetWindowRect(m_hDlg, &rUs);

    int nHeight = rUs.bottom - rUs.top;
    int nWidth = rUs.right - rUs.left;
    int nX = ((rParent.right - rParent.left) - nWidth) / 2;
/// if(nX < 0) nX = 0;
    int nY = ((rParent.bottom - rParent.top) - nHeight) / 2;
/// if(nY < 0) nY = 0;

	if ( NULL != m_hParent )
	{
		RECT rDesktop;

		HWND hProgMan = FindWindowEx( NULL, NULL, "Progman", "Program Manager" );
		HWND hShell = FindWindowEx( hProgMan, NULL, "SHELLDLL_DefView", NULL );

		if ( ( NULL != hProgMan ) && ( NULL != hShell ) )
		{
			if ( GetClientRect( hShell, &rDesktop ) )
			{
				if ( ( nHeight < ( rDesktop.bottom ) ) && 
					 ( ( rParent.top + nY + nHeight ) > rDesktop.bottom ) )
				{
					nY = ( rDesktop.bottom - nHeight ) - rParent.top;
				}

				if ( ( nWidth < ( rDesktop.right ) ) && 
					 ( ( rParent.left + nX + nWidth ) > rDesktop.right ) )
				{
					nX = ( rDesktop.right - nWidth ) - rParent.left;
				}
			}
		}
	}

    MoveWindow(m_hDlg, rParent.left + nX, rParent.top + nY, 
        nWidth, nHeight, TRUE);
}

void CBasicWbemDialog::SetOwner(CRefCountable* pOwner)
{
    if(m_pOwner)
        m_pOwner->Release();
    m_pOwner = pOwner;
    if(m_pOwner)
        m_pOwner->AddRef();
}

LRESULT CBasicWbemDialog::GetLBCurSel(int nID)
{
    return SendMessage(GetDlgItem(nID), LB_GETCURSEL, 0, 0);
}

LPSTR CBasicWbemDialog::GetLBCurSelString(int nID)
{
    LRESULT nIndex = SendMessage(GetDlgItem(nID), LB_GETCURSEL, 0, 0);
    if(nIndex == LB_ERR)
        return NULL;
    LRESULT nLength = SendMessage(GetDlgItem(nID), LB_GETTEXTLEN, 
                                (WPARAM)nIndex, 0);
    char* sz = new char[nLength+3];
    SendMessage(GetDlgItem(nID), LB_GETTEXT, (WPARAM)nIndex, (LPARAM)sz);
    return sz;
}

LRESULT CBasicWbemDialog::GetCBCurSel(int nID)
{
    return SendMessage(GetDlgItem(nID), CB_GETCURSEL, 0, 0);
}

LPSTR CBasicWbemDialog::GetCBCurSelString(int nID)
{
    LRESULT nIndex = SendMessage(GetDlgItem(nID), CB_GETCURSEL, 0, 0);
    if(nIndex == CB_ERR)
        return NULL;
    LRESULT nLength = SendMessage(GetDlgItem(nID), CB_GETLBTEXTLEN, 
                                (WPARAM)nIndex, 0);
    char* sz = new char[nLength+3];
    SendMessage(GetDlgItem(nID), CB_GETLBTEXT, (WPARAM)nIndex, (LPARAM)sz);
    return sz;
}

HWND CBasicWbemDialog::ms_hCurrentModeless = NULL;

BOOL CBasicWbemDialog::IsDialogMessage(MSG* pMsg)
{
    if(ms_hCurrentModeless != NULL && IsWindow(ms_hCurrentModeless))
        return ::IsDialogMessage(ms_hCurrentModeless, pMsg);
    else
        return FALSE;
}

LRESULT CBasicWbemDialog::MessageLoop()
{
    MSG msg;
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) 
    { 
        if(msg.message == WM_DESTROY && msg.hwnd == m_hDlg)
        {
            DispatchMessage(&msg); 
            return msg.lParam;
        }
        if(CBasicWbemDialog::IsDialogMessage(&msg))
            continue;
        TranslateMessage(&msg); 
        DispatchMessage(&msg); 
    } 

    return FALSE;
}

BOOL CBasicWbemDialog::PostUserMessage(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    // Since user messages don't seem to be queued (even when
    // posted) mouse & keyboard input messages aren't getting
    // processed.  So we will process them here first.
    MSG msg;
    while (PeekMessage(&msg, (HWND)NULL, 0, 0, PM_REMOVE)) 
    { 
        if (CBasicWbemDialog::IsDialogMessage(&msg))
            continue;
        TranslateMessage(&msg); 
        DispatchMessage(&msg); 
    } 
    BOOL result;
    while (result = PostMessage(hWnd, WM_APP, wParam, lParam) == 0 && IsWindow(hWnd))
    { SwitchToThread();};
    return result;
}

int CBasicWbemDialog::MessageBox(UINT uTextId, UINT uCaptionId, UINT uType)
{
    return MessageBox(m_hDlg, uTextId, uCaptionId, uType);
}

int CBasicWbemDialog::MessageBox(HWND hDlg, UINT uTextId, UINT uCaptionId, UINT uType)
{
    char szText[2048];
    if(LoadString(GetModuleHandle(NULL), uTextId, szText, 2048) <= 0)
    {
        strcpy(szText, "Unable to load resource string");
    }

    char szCaption[2048];
    if(LoadString(GetModuleHandle(NULL), uCaptionId, szCaption, 2048) <= 0)
    {
        strcpy(szCaption, "Unable to load resource string");
    }

    return ::MessageBox(hDlg, szText, szCaption, uType);
}

BOOL CBasicWbemDialog::SetDlgItemText(int nID, UINT uTextId)
{
    char szText[2048];
    if(LoadString(GetModuleHandle(NULL), uTextId, szText, 2048) <= 0)
    {
        strcpy(szText, "Unable to load resource string");
    }

    return SetDlgItemText(nID, szText);
}

BOOL CALLBACK EnableWindowsProc(HWND hWnd, LPARAM lParam)
{
    DWORD dwPid;
    DWORD dwTid = GetWindowThreadProcessId(hWnd, &dwPid);
    if(dwPid == GetCurrentProcessId())
    {
        EnableWindow(hWnd, (BOOL)lParam);
    }
    return TRUE;
}
    
void CBasicWbemDialog::EnableAllWindows(BOOL bEnable)
{
    EnumWindows((WNDENUMPROC)EnableWindowsProc, (LPARAM)bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemdlg.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMDLG.H

Abstract:

History:

--*/

#ifndef __WBEMTEST_DIALOG__H_
#define __WBEMTEST_DIALOG__H_

#include <windows.h>

class CRefCountable
{
protected:
    long m_lRefCount;
public:
    virtual long AddRef() {return ++m_lRefCount;}
    virtual long Release() {return --m_lRefCount;}
};

class CBasicWbemDialog : public CRefCountable
{
protected:
    HWND m_hDlg;
    HWND m_hParent;
    BOOL m_bDeleteOnClose;
    BOOL m_bModal;

    CRefCountable* m_pOwner;

    static HWND ms_hCurrentModeless;
public:
    CBasicWbemDialog(HWND hParent = NULL);
    virtual ~CBasicWbemDialog();

    void SetDeleteOnClose() { m_bDeleteOnClose = TRUE;}
    void SetOwner(CRefCountable* pOwner);

public:
    HWND GetHWND() {return m_hDlg;}

    BOOL EndDialog(int nResult);
    HWND GetDlgItem(int nID) {return ::GetDlgItem(m_hDlg, nID);}

    WORD GetCheck(int nID);
    void SetCheck(int nID, WORD wCheck);

    UINT GetDlgItemTextX(int nDlgItem, LPWSTR pStr, int nMaxCount);
    BOOL SetDlgItemText(int nID, LPSTR szStr)
        {return ::SetDlgItemText(m_hDlg, nID, szStr);}
    BOOL SetDlgItemText(int nID, UINT uTextId);
    BOOL SetDlgItemTextX(int nDlgItem, LPWSTR pStr);

	void AddStringToCombo(int nID, LPSTR szString, DWORD dwItemData=CB_ERR);
	void SetComboSelection (int nID, DWORD dwItemData);
    void AddStringToList(int nID, LPSTR szString);

    LRESULT GetLBCurSel(int nID);
    LPSTR GetLBCurSelString(int nID);
    LRESULT GetCBCurSel(int nID);
    LPSTR GetCBCurSelString(int nID);
    
    void CenterOnParent();

    BOOL PostUserMessage(HWND hWnd, WPARAM wParam, LPARAM lParam);
    int MessageBox(UINT uTextId, UINT uCaptionId, UINT uType);
    static int MessageBox(HWND hDlg, UINT uTextId, UINT uCaptionId, UINT uType);

    static BOOL IsDialogMessage(MSG* pmsg);
    static void EnableAllWindows(BOOL bEnable);

protected:
    virtual INT_PTR CALLBACK DlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    virtual BOOL OnInitDialog() {return TRUE;}
    virtual BOOL OnCommand(WORD wNotifyCode, WORD wID) {return TRUE;}
    virtual BOOL OnUser(WPARAM wParam, LPARAM lParam) 
        {return TRUE;}
    virtual BOOL OnOK();
    virtual BOOL OnCancel();
    virtual BOOL OnDoubleClick(int nID) {return TRUE;}
    virtual BOOL OnSelChange(int nID) {return TRUE;}
    virtual BOOL Verify() {return TRUE;}

protected:
    static INT_PTR CALLBACK staticDlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    LRESULT MessageLoop();
};

class CWbemDialog : public CBasicWbemDialog
{
public:
	int m_ID;
    CWbemDialog(int tID, HWND hParent = NULL) : CBasicWbemDialog(hParent), m_ID(tID) {}
    virtual ~CWbemDialog(){}

    BOOL Create(BOOL bChild = TRUE);
    INT_PTR Run(HWND hParent = NULL, bool bPopup = false);
};

inline BOOL CWbemDialog::Create(BOOL bChild)
{
    m_bModal = FALSE;
    m_hDlg = CreateDialogParam(GetModuleHandle(NULL), 
        MAKEINTRESOURCE(m_ID), 
        (bChild?m_hParent:NULL), &staticDlgProc,
        (LPARAM)(CBasicWbemDialog*)this);

    ShowWindow(m_hDlg, SW_NORMAL);
    return (m_hDlg != NULL);
}

inline INT_PTR CWbemDialog::Run(HWND hParent, bool bPopup)
{
    if(hParent != NULL)
        m_hParent = hParent;

    //Create(TRUE);
    m_bModal = TRUE;
    HWND hCurrentFocus = GetFocus();

    if(!bPopup)
        EnableAllWindows(FALSE);

    INT_PTR ptr = DialogBoxParam(GetModuleHandle(NULL), 
        MAKEINTRESOURCE(m_ID), m_hParent, &staticDlgProc,
        (LPARAM)(CBasicWbemDialog*)this);

    if(!bPopup)
        EnableAllWindows(TRUE);
    SetFocus(hCurrentFocus);
    return ptr;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemntfy.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMNTFY.H

Abstract:

History:

--*/

#ifndef _WBEMNOTFY_H_
#define _WBEMNOTFY_H_

#include <wbemidl.h>
//#include <arena.h>
#include <WT_flexarry.h>

DWORD WINAPI WbemWaitForSingleObject(
    HANDLE hHandle, // handle of object to wait for
    DWORD dwMilliseconds    // time-out interval in milliseconds
   );

class CStatusMonitor
{
private:
    BOOL m_bOpen;
    HWND m_hDlg;
    HWND m_hList;
    BOOL m_bVisible;

public:
    CStatusMonitor();
    ~CStatusMonitor();
    void Hide();
    void Add(long lFlags, HRESULT hRes, BSTR bstr);
    static INT_PTR CALLBACK DlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );
};



class CTestNotify : public IWbemObjectSink
{
    CFlexArray m_aObjects;
    LONG m_lRefCount;
    CRITICAL_SECTION m_cs;
    HANDLE m_hEvent;
    HRESULT m_hres;
    IWbemClassObject* m_pErrorObj;
	IID m_pInterfaceID;
	IUnknown *m_pInterface;

public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, HRESULT hResult, BSTR strParam, 
                         IWbemClassObject* pObjPAram);

	//STDMETHOD(Set)(long lFlags, REFIID riid, void *pComObject);

    // Private to implementation.
    // ==========================

    CTestNotify(LONG lStartingRefCount = 1);
   ~CTestNotify();

    UINT WaitForSignal(DWORD dwMSec) { return ::WbemWaitForSingleObject(m_hEvent, dwMSec); }
    CFlexArray* GetObjectArray() { return &m_aObjects; }
	IUnknown *GetInterface() { return m_pInterface; }
    HRESULT GetStatusCode(IWbemClassObject** ppErrorObj = NULL)
    {
        if(ppErrorObj) 
        {
            *ppErrorObj = m_pErrorObj;
            if(m_pErrorObj) m_pErrorObj->AddRef();
        }
        return m_hres;
    }

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemntfy.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMNTFY.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemint.h>
#include <wbemdlg.h>
#include <resource.h>
#include <resrc1.h>
#include <wbemntfy.h>

CStatusMonitor gStatus; 

SCODE CTestNotify::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else if (riid == IID_IWbemObjectSink)
	{
        *ppvObj = (IWbemObjectSink *)this;
	}
    /*
    else if (riid == IID_IWbemObjectSinkEx)
	{
		*ppvObj = (IWbemObjectSinkEx *)this;
	}
	*/
	else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}


ULONG CTestNotify::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_lRefCount);
}

ULONG CTestNotify::Release()
{
    Lock();
    if(m_lRefCount <= 0) {
        char szDebug[1000];
        wsprintf(szDebug, "CTestNotify::Release(), ref count is %d", m_lRefCount);
        MessageBox(NULL, szDebug, "DEBUG", MB_OK);
        delete this;
        return 0;
    }

    if (InterlockedDecrement(&m_lRefCount))
    {
        Unlock();
        return 1;
    }

    Unlock();
    delete this;
    return 0;
}


SCODE CTestNotify::Indicate(
    long lObjectCount,
    IWbemClassObject ** pObjArray
    )
{
    if(lObjectCount == 0) return WBEM_NO_ERROR;

    Lock();

    for (int i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject *pObj = pObjArray[i];
        pObj->AddRef();
        m_aObjects.Add(pObj);
    }

    Unlock();
    return WBEM_NO_ERROR;
}


/*
HRESULT CTestNotify::Set(
    long lFlags,
    REFIID riid,
    void *pComObject)
{
	Lock();

	m_pInterfaceID=riid;
    if(pComObject)
    {
	    m_pInterface=(IUnknown *)pComObject;
        m_pInterface->AddRef();
    }
	Unlock();
	return WBEM_NO_ERROR;
}
*/


STDMETHODIMP CTestNotify::SetStatus(long lFlags, HRESULT hResult, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{
    m_hres = hResult;
    if(lFlags & WBEM_STATUS_PROGRESS)
    {
        gStatus.Add(lFlags, hResult, strParam);
        return WBEM_NO_ERROR;
    }
    m_pErrorObj = pObjParam;
    if(pObjParam)
        pObjParam->AddRef();

    SetEvent(m_hEvent);
    return WBEM_NO_ERROR;
}

CTestNotify::CTestNotify(LONG lStartingRefCount)
{
    InitializeCriticalSection(&m_cs);
    m_lRefCount = lStartingRefCount;
    m_hEvent = CreateEvent(0, FALSE, FALSE, 0);
    m_pErrorObj = NULL;
    m_pInterface = NULL;
}

CTestNotify::~CTestNotify()
{
    DeleteCriticalSection(&m_cs);
    CloseHandle(m_hEvent);

    for (int i = 0; i < m_aObjects.Size(); i++)
         ((IWbemClassObject *) m_aObjects[i])->Release();
    if(m_pErrorObj) m_pErrorObj->Release();
}

CStatusMonitor::CStatusMonitor()
{
    m_bVisible = FALSE;
        m_hDlg = CreateDialog(GetModuleHandle(NULL),
            MAKEINTRESOURCE(IDD_STATUS_MONITOR), NULL,
            CStatusMonitor::DlgProc);
        ShowWindow(m_hDlg, SW_HIDE);

        m_hList = GetDlgItem(m_hDlg, IDC_REPORTS);
}

CStatusMonitor::~CStatusMonitor()
{
    if(m_bOpen)
        EndDialog(m_hDlg, 0);
}

char buff[2048];

void CStatusMonitor::Add(long lFlags, HRESULT lParam, BSTR strParam)
{
    if(m_bVisible == FALSE)
    {
        ShowWindow(m_hDlg, SW_SHOW);
        SendMessage(m_hList, LB_RESETCONTENT, 0, 0);
    }

    m_bVisible = TRUE;
    if(strParam)
        wsprintf(buff,"Go progress, value is 0x%0x, and string is %S", lParam, strParam);
    else
        wsprintf(buff,"Go progress, value is 0x%0x, and no string", lParam);
 
    SendMessage(m_hList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)buff);
}
void CStatusMonitor::Hide()
{
    ShowWindow(m_hDlg, SW_HIDE);
    m_bVisible = FALSE;
}

INT_PTR CALLBACK CStatusMonitor::DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hList;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            hList = GetDlgItem(hDlg, IDC_REPORTS);
            SendMessage(hList, LB_RESETCONTENT, 0, 0);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case 2: // was IDANI_CLOSE:
                    gStatus.Hide();
                    return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemqual.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMQUAL.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
//#include <wbemutil.h>

#include "wbemqual.h"

//***************************************************************************
//
//  CTestQualifier::CTestQualifier
//
//  Constructor for CTestQualifier.
//
//***************************************************************************

CTestQualifier::CTestQualifier()
{
    m_pName = 0;
    m_pValue = 0;
    m_lType = 0;
}

//***************************************************************************
//
//  CTestQualifier::~CTestQualifier
//
//  Destructor for CTestQualifier.
//
//***************************************************************************

CTestQualifier::~CTestQualifier()
{
    delete m_pName;
    delete m_pValue;
}

//***************************************************************************
//
//  CTestQualifier::CTestQualifier
//
//  Copy constructor for CTestQualifier.
//
//***************************************************************************

CTestQualifier::CTestQualifier(CTestQualifier &Src)
{
    m_pName = 0;
    m_pValue = 0;
    m_lType = 0;
    *this = Src;
}

//***************************************************************************
//
//  CTestQualifier::operator =
//
//  Copy constructor for CTestQualifier.
//
//***************************************************************************

CTestQualifier& CTestQualifier::operator =(CTestQualifier &Src)
{
    delete m_pName;
    delete m_pValue;
    m_pName = new wchar_t[wcslen(Src.m_pName) + 1];
    wcscpy(m_pName, Src.m_pName);
    m_pValue = new CVar(*Src.m_pValue);
    m_lType = Src.m_lType;
    return *this;
}

//***************************************************************************
//
//  CTestProperty::CTestProperty
//
//  Constructor.
//
//***************************************************************************

CTestProperty::CTestProperty(IWbemQualifierSet* pQualifiers)
{
    m_pName = 0;
    m_pValue = 0;
    m_lType = 0;
    m_pClass = 0;

    m_pQualifiers = pQualifiers;
    if (m_pQualifiers)
        m_pQualifiers->AddRef();
}

//***************************************************************************
//
//  CTestProperty::~CTestProperty
//
//  Destructor.
//
//***************************************************************************

CTestProperty::~CTestProperty()
{
    delete m_pName;
    delete m_pValue;
    delete m_pClass;

    if (m_pQualifiers)
        m_pQualifiers->Release();
}

//***************************************************************************
//
//  CTestMethod::CTestMethod
//
//  Constructor.
//
//***************************************************************************

CTestMethod::CTestMethod(IWbemQualifierSet* pQualifiers, IWbemClassObject * pInArgs, 
                         IWbemClassObject * pOutArgs, BOOL bEnableInputArgs, BOOL bEnableOutputArgs)
                 :CTestProperty(pQualifiers)
{
    m_pInArgs = pInArgs;
    if (m_pInArgs)
        m_pInArgs->AddRef();
    m_pOutArgs = pOutArgs;
    if (m_pOutArgs)
        m_pOutArgs->AddRef();
    m_bEnableInputArgs = bEnableInputArgs;
    m_bEnableOutputArgs = bEnableOutputArgs;

}

//***************************************************************************
//
//  CTestMethod::~CTestMethod
//
//  Destructor.
//
//***************************************************************************

CTestMethod::~CTestMethod()
{
    if (m_pInArgs)
        m_pInArgs->Release();
    if (m_pOutArgs)
        m_pOutArgs->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemqual.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMQUAL.H

Abstract:

History:

--*/

#ifndef __WbemQualifier__H_
#define __WbemQualifier__H_

//#include <dbgalloc.h>
//#include <arena.h>
#include <var.h>
#include <wbemidl.h>

class CTestQualifier
{
public:
    wchar_t  *m_pName;
    LONG        m_lType;
    CVar        *m_pValue;

    CTestQualifier();
   ~CTestQualifier();
    CTestQualifier(CTestQualifier &Src);
    CTestQualifier& operator =(CTestQualifier &Src);
};

class CTestProperty
{
public:

    LPWSTR m_pName;

    CVar*  m_pValue;
    long m_lType;
    IWbemQualifierSet *m_pQualifiers;
    LPWSTR m_pClass;

    CTestProperty(IWbemQualifierSet* pQualifiers);
    ~CTestProperty();
};
typedef CTestProperty* PCTestProperty;

class CTestMethod : public CTestProperty
{
public:
    IWbemClassObject * m_pInArgs;
    IWbemClassObject * m_pOutArgs;
    BOOL m_bEnableInputArgs;
    BOOL m_bEnableOutputArgs;
    CTestMethod(IWbemQualifierSet* pQualifiers, IWbemClassObject * pInArgs, IWbemClassObject * pOutArgs
        , BOOL bEnableInputArgs, BOOL bEnableOuputArgs);
    ~CTestMethod();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemtest.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMTEST.H

Abstract:

History:

--*/

#ifndef __WBEMTEST__H_
#define __WBEMTEST__H_

#include <windows.h>
#include <wbemidl.h>
#include <wbemint.h>

//#include <dbgalloc.h>
//#include <arena.h>
#include <WT_wstring.h>

#include <wbemdlg.h>
#include <wbemntfy.h>
#include <resrc1.h>

#define I_EMBEDDED_OBJECT IUnknown
#define VT_EMBEDDED_OBJECT VT_UNKNOWN
#define TOKEN_THREAD	0
#define TOKEN_PROCESS	1
HRESULT EnableAllPrivileges(DWORD dwTokenType = TOKEN_THREAD);
int Trace(const char *fmt, ...);
extern IWbemLocator *g_pLocator;
extern IWbemServices *g_pNamespace;
//extern IWbemServicesEx *g_pServicesEx;
extern BSTR g_strNamespace;
extern BOOL gbSecured;

enum 
{ 
    SYNC            = 0,
    ASYNC           = 0x1, 
    SEMISYNC        = 0x2,
    USE_NEXTASYNC   = 0x1000        // applies to semisync enumeration only
};

void FormatError(SCODE res, HWND hParent, IWbemClassObject* pErrorObj = NULL);

class CQueryResultDlg;

void ShowClass(HWND hDlg, LONG lGenFlags, LPWSTR wszClass, 
               LONG lSync, CRefCountable* pOwner, LONG lTimeout);
void ShowClasses(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszParentClass, 
                 LONG lSync, CRefCountable* pOwner, LONG lTimeout, ULONG nBatch);
void ShowInstances(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszClass, 
                   LONG lSync, CRefCountable* pOwner, LONG lTimeout, ULONG nBatch);
BOOL _ExecQuery(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszQuery, LPWSTR wszLanguage, 
                LONG lSync, CQueryResultDlg* pRes, char* pWindowTitle, LONG lTimeout, ULONG nBatch);
BOOL _PutInstance(HWND hDlg, LONG lGenFlags, LONG lChgFlags, LONG lSync, 
                  IWbemClassObject* pInstance, LONG lTimeout);
BOOL _PutClass(HWND hDlg, LONG lGenFlags, LONG lChgFlags, LONG lSync, 
               IWbemClassObject* pClass, LONG lTimeout);

IWbemClassObject* _CreateInstance(HWND hDlg, LONG lGenFlags, LONG lSync, LONG lTimeout);
IWbemClassObject* PreCreateInstance(HWND hDlg, LONG lGenFlags, LONG lSync, LONG lTimeout);


class CNotSink;

//***************************************************************************

class CQueryResultDlg : public CWbemDialog
{
protected:
    CFlexArray m_InternalArray;
    CNotSink* m_pHandler;
    IWbemObjectSink* m_pWrapper;
    IEnumWbemClassObject* m_pEnum;          // for synchronous and semisynchronous enumeration

	bool m_partial_result;
    BOOL m_bRelease;
    BOOL m_bReadOnly;
	BOOL m_fDeletesAllowed;
    BOOL m_bComplete;
	BOOL m_bSort;

    LONG  m_lGenFlags;  // generic WBEM_FLAG_ .. flags
    LONG  m_lQryFlags;  // query WBEM_FLAG_ .. flags
    LONG  m_lSync;      // sync, async, semisync
    LONG  m_lTimeout;   // used in semisync only
    ULONG m_nBatch;     // used in semisync and sync enumerations
    ULONG m_nReturnedMax;   // maximum size of batch returned

    char *m_szTitle;

    struct CStatus
    {
        HRESULT m_hres;
        BSTR m_str;
        IWbemClassObject* m_pObj;
        
        CStatus(long l, BSTR str, IWbemClassObject* pObj)
            : m_hres(l), m_pObj(pObj)
        {
            m_str = (str ? SysAllocString(str) : NULL);
            if(m_pObj) m_pObj->AddRef();
        }
        ~CStatus()
        {
            SysFreeString(m_str);
            if(m_pObj) m_pObj->Release();
        }
    };
        
        
public:
								
    CQueryResultDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, BOOL fDeletesAllowed = TRUE, int tID = IDD_QUERY_RESULT);
    virtual ~CQueryResultDlg();

    void SetNotify(CNotSink* pNotify);
    void SetEnum(IEnumWbemClassObject* pEnum, HRESULT = 0);

    void SetReadOnly(BOOL bReadOnly = TRUE) { m_bReadOnly = bReadOnly; }
    void SetCallMethod(LONG lSync) { m_lSync = lSync; }
    void SetTimeout(LONG lTimeout) { m_lTimeout = lTimeout; }
    void SetBatchCount(ULONG nBatch) { m_nBatch = nBatch; }

    void SetTitle(char* szTitle);
    void SetComplete(HRESULT hres, BSTR strParam, IWbemClassObject* pErrorObj);
    void AddObject(IWbemClassObject* pObj);
    void RunDetached(CRefCountable* pOwner);
    void PostObject(IWbemClassObject* pObj);
    void PostCount(long nCount);
    void PostComplete(long lParam, BSTR strParam, IWbemClassObject* pObjParam);
    void set_partial(bool value){ if (m_partial_result==false) m_partial_result = value;}

    IWbemObjectSink* GetWrapper() {return m_pWrapper;}
protected:
    virtual BOOL OnInitDialog();
    virtual BOOL OnCommand(WORD wCode, WORD wID);
    virtual BOOL OnUser(WPARAM wParam, LPARAM lParam);
    virtual void OnDelete();
    virtual void OnAdd();
    virtual void OnCopy();
    virtual BOOL OnDoubleClick(int nID);

    virtual BOOL DeleteListElement(LRESULT nSel);
    virtual BOOL ViewListElement(LRESULT nSel);
    virtual IWbemClassObject* AddNewElement();
    virtual BOOL CanAdd()		{ return FALSE;}
    virtual BOOL CanDelete()	{ return m_fDeletesAllowed;}

    virtual BOOL Initialize() {return TRUE;}

    void MakeListEntry(IWbemClassObject* pObj, WString& ListEntry);
    void SetNumItems(LRESULT nNum);
    void SetNumBatchItems(ULONG nNum);
    void RefreshItem(int nItem);
    void ProcessEnum();
    void ProcessEnumSemisync();
    void SemisyncNextAsync();
};

//***************************************************************************

class CAppOwner : public CRefCountable
{
public:
    virtual long Release();
};

//***************************************************************************

class CQueryDlg : public CWbemDialog
{
protected:
    wchar_t **m_pwszQueryType;
    wchar_t **m_pwszQueryString;
    static char *m_szLastQueryType;
    static char *m_szLastQuery;
    LONG* m_plQryFlags;

public:
    CQueryDlg(HWND hParent, LONG* plQryFlags, LPWSTR *pwszQueryString, LPWSTR *pwszQueryType)
        :  CWbemDialog(IDD_QUERY, hParent), m_plQryFlags(plQryFlags), 
            m_pwszQueryType(pwszQueryType), m_pwszQueryString(pwszQueryString)
    {}

protected:
    BOOL OnInitDialog();
    BOOL Verify();
};

class CContext
{
protected:
    BOOL m_bNull;
    IWbemContext* m_pContext;

public:
    CContext();
    ~CContext();

    BOOL IsNull() {return m_bNull;}
    IWbemContext* GetStoredContext() {return m_pContext;}

    INT_PTR Edit(HWND hParent);
    operator IWbemContext*();
    IWbemContext* operator->() {return (IWbemContext*)*this;}
    void operator=(const CContext& Other);

    BOOL SetNullness(BOOL bNull);
    void Clear();
};

extern CContext g_Context;

//***************************************************************************

class CRefresherDlg : public CQueryResultDlg
{
protected:
    IWbemRefresher* m_pRefresher;
    IWbemConfigureRefresher* m_pCreator;
    CFlexArray m_aIds;
	CFlexArray m_apEnums;

public:
    CRefresherDlg(HWND hParent, LONG lGenFlags);
    ~CRefresherDlg();

    virtual BOOL OnInitDialog();
    virtual BOOL OnCommand(WORD wCode, WORD wID);
    virtual void OnRefresh();
    virtual IWbemClassObject* AddNewElement();
    virtual BOOL DeleteListElement(LRESULT nSel);

	virtual BOOL OnDoubleClick( int nID );
    virtual BOOL CanAdd()    { return TRUE;}
};

//***************************************************************************

class CRefresherEnumDlg : public CQueryResultDlg
{
protected:
    IWbemHiPerfEnum*		m_pEnum;
	char*					m_pszName;

public:
    CRefresherEnumDlg(HWND hParent, LONG lGenFlags, IWbemHiPerfEnum* pEnum, char* pszName);
    ~CRefresherEnumDlg();

    virtual BOOL OnInitDialog();
    virtual BOOL CanAdd()		{ return FALSE;}
};

//***************************************************************************

class CHourGlass
{
protected:
    HCURSOR m_hCursor;
public:
    CHourGlass();
    ~CHourGlass();
};

//***************************************************************************

void Fatal(UINT uMsg);

class CUnsecWrap
{
protected:
    IWbemObjectSink* m_pSink;
    IWbemObjectSink* m_pWrapper;
    
    static IUnsecuredApartment* mstatic_pApartment;

protected:
    static void Init()
    {
        if(mstatic_pApartment == NULL && gbSecured)
        {
            HRESULT hres = CoCreateInstance(CLSID_UnsecuredApartment, NULL, 
                            CLSCTX_ALL,
                            IID_IUnsecuredApartment, 
                            (void**)&mstatic_pApartment);
            if(FAILED(hres))
            {
                Fatal(IDS_OLE_INIT_FAILED);
            }
        }
    }
public:
    CUnsecWrap(IWbemObjectSink* pSink) : m_pSink(pSink), m_pWrapper(NULL)
    {
        m_pSink->AddRef();
        Init();
    }
    ~CUnsecWrap()
    {
        m_pSink->Release();
        if(m_pWrapper)
            m_pWrapper->Release();
    }

    operator IWbemObjectSink*()
    {
        if(!gbSecured)
            return m_pSink;
        if(m_pWrapper)
            return m_pWrapper;
        
        IUnknown* pUnk = NULL;
        SCODE sc = mstatic_pApartment->CreateObjectStub(m_pSink, &pUnk);
        if(sc != S_OK || pUnk == NULL)
        {

            Fatal(IDS_UNSECAPP_ERROR);
            FormatError(sc, NULL);
            return NULL;
        }
        pUnk->QueryInterface(IID_IWbemObjectSink, (void**)&m_pWrapper);
        pUnk->Release();
        return m_pWrapper;
    }
};


class CUnsecWrapEx
{
protected:
    IWbemObjectSink* m_pSink;
    IWbemObjectSink* m_pWrapper;
    
    static IUnsecuredApartment* mstatic_pApartment;

protected:
    static void Init()
    {
        if(mstatic_pApartment == NULL && gbSecured)
        {
            HRESULT hres = CoCreateInstance(CLSID_UnsecuredApartment, NULL, 
                            CLSCTX_ALL,
                            IID_IUnsecuredApartment, 
                            (void**)&mstatic_pApartment);
            if(FAILED(hres))
            {
                Fatal(IDS_OLE_INIT_FAILED);
            }
        }
    }
public:
    CUnsecWrapEx(IWbemObjectSink* pSink) : m_pSink(pSink), m_pWrapper(NULL)
    {
        m_pSink->AddRef();
        Init();
    }
    ~CUnsecWrapEx()
    {
        m_pSink->Release();
        if(m_pWrapper)
            m_pWrapper->Release();
    }

    operator IWbemObjectSink*()
    {
        if(!gbSecured)
            return m_pSink;
        if(m_pWrapper)
            return m_pWrapper;
        
        IUnknown* pUnk = NULL;
        SCODE sc = mstatic_pApartment->CreateObjectStub(m_pSink, &pUnk);
        if(sc != S_OK || pUnk == NULL)
        {

            Fatal(IDS_UNSECAPP_ERROR);
            FormatError(sc, NULL);
            return NULL;
        }
        pUnk->QueryInterface(IID_IWbemObjectSink, (void**)&m_pWrapper);
        pUnk->Release();
        return m_pWrapper;
    }
};
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_arrtempl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ARRTEMPL.H

Abstract:

    This file defines a simple template for an array of arbitrary pointers.
    Actual growing array functionality is provided by CFlexArray.

    Classes defined:

        template CPointerArray

History:

    11/27/96    a-levn      Compiles.

--*/

#ifndef __ARRAY_TEMPLATE__H_
#define __ARRAY_TEMPLATE__H_

#pragma warning(disable:4786)

#include <map>
#include <WT_strutils.h>


using namespace std;
class wcsless : public binary_function<LPWSTR, LPWSTR, bool>
{
public:
    bool operator()(const LPWSTR& wcs1, const LPWSTR& wcs2) const
        {return wcscmp(wcs1, wcs2) < 0;}
};

class wcsiless : public binary_function<LPWSTR, LPWSTR, bool>
{
public:
    bool operator()(const LPWSTR& wcs1, const LPWSTR& wcs2) const
        {return wbem_wcsicmp(wcs1, wcs2) < 0;}
};

class CReleaseMe
{
protected:
    IUnknown* m_pUnk;

public:
    CReleaseMe(IUnknown* pUnk) : m_pUnk(pUnk){}
    ~CReleaseMe() {if(m_pUnk) m_pUnk->Release();}
};

template<class T>
class CTemplateReleaseMe
{
protected:
    T* m_p;

public:
    CTemplateReleaseMe(T* p) : m_p(p){}
    ~CTemplateReleaseMe() {if(m_p) m_p->Release();}
};

template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p) : m_p(p){}
    ~CDeleteMe() {delete m_p;}
};

class CCloseMe
{
protected:
    HANDLE m_h;
public:
    CCloseMe(HANDLE hToClose){m_h = hToClose;};
    ~CCloseMe(){if(m_h && m_h != INVALID_HANDLE_VALUE)CloseHandle(m_h);};
};

class CfcloseMe
{
protected:
    FILE * m_h;
public:
    CfcloseMe(FILE * ToClose){m_h = ToClose;};
    ~CfcloseMe(){if(m_h != NULL)fclose(m_h);};
};

typedef CCloseMe CCloseHandle;

class CRegCloseMe
{
protected:
    HKEY m_h;
public:
    CRegCloseMe(HKEY hToClose){m_h = hToClose;};
    ~CRegCloseMe(){if(m_h)RegCloseKey(m_h);};
};

template<class T>
class CVectorDeleteMe
{
protected:
    T* m_p;
    T** m_pp;

public:
    CVectorDeleteMe(T* p) : m_p(p), m_pp(NULL){}
    CVectorDeleteMe(T** pp) : m_p(NULL), m_pp(pp){}
    ~CVectorDeleteMe() {if(m_p) delete [] m_p; else if(m_pp) delete [] *m_pp;}
};

class CClearMe
{
protected:
    VARIANT* m_pv;

public:
    CClearMe(VARIANT* pv) : m_pv(pv){}
    ~CClearMe() {VariantClear(m_pv);}
};

class CSysFreeMe
{
protected:
    BSTR m_str;

public:
    CSysFreeMe(BSTR str) : m_str(str){}
    ~CSysFreeMe() {SysFreeString(m_str);}
};

class CUnaccessMe
{
protected:
    SAFEARRAY* m_psa;
public:
    CUnaccessMe(SAFEARRAY* psa) : m_psa(psa){}
    ~CUnaccessMe() {SafeArrayUnaccessData(m_psa);}
};

class CMemFreeMe
{
protected:
    void*	m_pMem;
public:
    CMemFreeMe( void* pMem ) : m_pMem(pMem){}
    ~CMemFreeMe() { if ( NULL != m_pMem ) CoTaskMemFree(m_pMem);}
};

#include <WT_flexarry.h>
//#include <flexq.h>
//#include <smallarr.h>

//*****************************************************************************
//
//  class CPointerArray
//
//  Array of pointers to TMember, where TMember is any class. See CFlexArray
//  in coredll\flexarry.h/cpp for documentation.
//
//*****************************************************************************

template <class TMember>
class CNullManager
{
public:
    void AddRefElement(TMember*){}
    void ReleaseElement(TMember*){}
};

template <class TMember, class TManager = CNullManager<TMember>,
                class TArray = CFlexArray>
class CPointerArray
{
protected:
    TArray m_Array;
    TManager m_Manager;
public:
    CPointerArray(const TManager& Manager = TManager())
        : m_Manager(Manager){}
    ~CPointerArray();

     int GetSize() const
        {return m_Array.Size();}
     void SetSize(int nNewSize)
        {m_Array.SetSize(nNewSize);}
     const TMember* GetAt(int nIndex) const
        {return (TMember*)m_Array.GetAt(nIndex);}
     TMember* GetAt(int nIndex)
        {return (TMember*)m_Array.GetAt(nIndex);}
     const TMember* operator[](int nIndex) const
        {return (TMember*)m_Array.GetAt(nIndex);}
     TMember* operator[](int nIndex)
        {return (TMember*)m_Array.GetAt(nIndex);}
     void SetAt(int nIndex, TMember* pElement, TMember** ppOld = NULL);
     bool RemoveAt(int nIndex, TMember** ppOld = NULL);
     bool InsertAt(int nIndex, TMember* pElement);
     int Add(TMember* pElement);
     TMember** GetArrayPtr();
     TMember** UnbindPtr();
     void RemoveAll();
     void Swap(int nIndex1, int nIndex2);
     void Trim() {m_Array.Trim();}

protected:
     void AddRefElement(TMember* p){m_Manager.AddRefElement(p);}
     void ReleaseElement(TMember* p){m_Manager.ReleaseElement(p);}
};
/*
template<class TMember>
class CPointerSmallArray :
        public CPointerArray<TMember, CNullManager<TMember>, CSmallArray>
{
};
*/
//*****************************************************************************
//
//  class CPointerQueue
//
//  Queue of pointers to TMember, where TMember is any class. See CFlexQueue
//  in coredll\flexq.h/cpp for documentation.
//
//*****************************************************************************
/*
template <class TMember, class TManager = CNullManager<TMember> >
class CPointerQueue
{
protected:
    CFlexQueue m_Queue;
    TManager m_Manager;
public:
    CPointerQueue(int nInitialSize = 1, const TManager& Manager = TManager())
        : m_Manager(Manager), m_Queue(nInitialSize){}
    Clear();
    ~CPointerQueue()
        {Clear();}

    inline int GetQueueSize() const
        {return m_Queue.GetQueueSize();}

    bool Enqueue(TMember* pNew)
    {
        AddRefElement(pNew);
        return m_Queue.Enqueue(pNew);
    }
    TMember* Dequeue()
    {
        TMember* p = (TMember*)m_Queue.Dequeue();
        return p;
    }
    bool Requeue(TMember* pNew)
    {
        AddRefElement(pNew);
        return m_Queue.Requeue(pNew);
    }
    TMember* Unqueue()
    {
        TMember* p = (TMember*)m_Queue.Unqueue();
        AddRefElement(p);
        return p;
    }
protected:
     void AddRefElement(TMember* p){m_Manager.AddRefElement(p);}
     void ReleaseElement(TMember* p){m_Manager.ReleaseElement(p);}
};
*/

//*****************************************************************************
//
//  UNIQUE POINTER ARRAY
//
//*****************************************************************************

template <class TMember>
class CUniqueManager
{
public:
    void AddRefElement(TMember*){}
    void ReleaseElement(TMember* pMember) {delete pMember;}
};

template<class TMember>
class CUniquePointerArray :
        public CPointerArray<TMember, CUniqueManager<TMember> >
{
};
/*
template<class TMember>
class CUniquePointerSmallArray :
        public CPointerArray<TMember, CUniqueManager<TMember>, CSmallArray>
{
};
*/
/*
template<class TMember>
class CUniquePointerQueue :
        public CPointerQueue<TMember, CUniqueManager<TMember> >
{
public:
    CUniquePointerQueue<TMember>(int nInitialSize = 1)
        : CPointerQueue<TMember, CUniqueManager<TMember> >(nInitialSize)
    {}
};
*/

//*****************************************************************************
//
//  REFED POINTER ARRAY
//
//*****************************************************************************
template <class TMember>
class CReferenceManager
{
public:
    void AddRefElement(TMember* pMember) {if(pMember)pMember->AddRef();}
    void ReleaseElement(TMember* pMember) {if(pMember)pMember->Release();}
};

template<class TMember>
class CRefedPointerArray :
        public CPointerArray<TMember, CReferenceManager<TMember> >
{
};

		/*
template<class TMember>
class CRefedPointerSmallArray :
        public CPointerArray<TMember, CReferenceManager<TMember>, CSmallArray>
{
};
*/
/*
template<class TMember>
class CRefedPointerQueue :
        public CPointerQueue<TMember, CReferenceManager<TMember> >
{
    CRefedPointerQueue(int nInitialSize = 1)
        : CPointerQueue<TMember, CReferenceManager<TMember> >(nInitialSize)
    {}
};
*/
//*****************************************************************************
//
//  ARRAY OF UNIQUE ARRAYS
//
//*****************************************************************************

template <class TMember>
class CUniqueArrayManager
{
    void AddRefElement(TMember**){}
    void ReleaseElement(TMember** pMember) {delete [] pMember;}
};
template<class TMember>
class CUniqueArrayArray : public CPointerArray<TMember*,
                                               CUniqueArrayManager<TMember> >
{
};

//*****************************************************************************
//
//  IMPLEMENTATION
//
//*****************************************************************************

template <class TMember, class TManager, class TArray>
CPointerArray<TMember, TManager, TArray>::~CPointerArray()
{
    RemoveAll();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::RemoveAll()
{
    for(int i = 0; i < m_Array.Size(); i++)
    {
        ReleaseElement(GetAt(i));
    }
    m_Array.Empty();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::SetAt(int nIndex,
                                            TMember* pElement, TMember** ppOld)
{
    if(ppOld == NULL)
        ReleaseElement(GetAt(nIndex));
    else
        *ppOld = GetAt(nIndex);

    AddRefElement(pElement);

    m_Array.SetAt(nIndex, (void*)pElement);
}

template <class TMember, class TManager, class TArray>
bool CPointerArray<TMember, TManager, TArray>::RemoveAt(int nIndex,
                                                        TMember** ppOld)
{
    if(ppOld == NULL)
        ReleaseElement(GetAt(nIndex));
    else
        *ppOld = GetAt(nIndex);

    if(m_Array.RemoveAt(nIndex) != CFlexArray::no_error)
        return false;
    return true;
}

template <class TMember, class TManager, class TArray>
bool CPointerArray<TMember, TManager, TArray>::InsertAt(int nIndex,
                                                        TMember* pElement)
{
    AddRefElement(pElement);
    if(m_Array.InsertAt(nIndex, (void*)pElement) != CFlexArray::no_error)
    {
        ReleaseElement(pElement);
        return false;
    }
    return true;
}

template <class TMember, class TManager, class TArray>
int CPointerArray<TMember, TManager, TArray>::Add(TMember* pElement)
{
    AddRefElement(pElement);
    if(m_Array.Add((void*)pElement) != CFlexArray::no_error)
    {
        ReleaseElement(pElement);
        return -1;
    }
    return m_Array.Size()-1;
}

template <class TMember, class TManager, class TArray>
TMember** CPointerArray<TMember, TManager, TArray>::GetArrayPtr()
{
    return (TMember**)m_Array.GetArrayPtr();
}

template <class TMember, class TManager, class TArray>
TMember** CPointerArray<TMember, TManager, TArray>::UnbindPtr()
{
    return (TMember**)m_Array.UnbindPtr();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager>::Swap(int nIndex1, int nIndex2)
{
    void* pTemp = m_Array[nIndex1];
    m_Array.SetAt(nIndex1, m_Array[nIndex2]);
    m_Array.SetAt(nIndex2, pTemp);
}
/*
template <class TMember, class TManager>
CPointerQueue<TMember, TManager>::Clear()
{
    TMember* p;
    while(p = (TMember*)m_Queue.Dequeue())
    {
        ReleaseElement(p);
    }
}
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemtest.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMTEST.CPP

Abstract:

    Test for WBEM

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <mbstring.h>
#include <wbemidl.h>

#include <cominit.h>

#include "objedit.h"
#include "wbemntfy.h"
#include "resource.h"
#include "resrc1.h"

#include "bstring.h"

#include "wbemtest.h"

#include "initguid.h"
//#include <wbemcomn.h>
#include "notsink.h"
#include "method.h"
#include "textconv.h"
#include <string.h>
#include <tchar.h>
#include <Htmlhelp.h>
//#include <wbemerror.h>
//#include <genutils.h>

DWORD gdwAuthLevel = RPC_C_AUTHN_LEVEL_PKT;
DWORD gdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;

WCHAR gNameSpace[2048] = L"";
WCHAR gPassword[1024];
WCHAR * gpPassword = NULL;
WCHAR gUser[1024] = L"";
WCHAR * gpUser = NULL;
WCHAR gAuthority[1024] = L"";
WCHAR * gpAuthority = NULL;

// These will be established at ConnectServer time and should remain valid for
// the life of the namespace and all its proxies, refreshers, etc.
BSTR            gpPrincipal = NULL;
COAUTHIDENTITY* gpAuthIdentity = NULL;

WCHAR gTransport[1024] = L"";
WCHAR gLocale[1024] = L"";
long gLoginType = 0;
BOOL gbSecured = FALSE;
//BOOL gbAdvanced = FALSE;

class CCreateInstanceDlg : public CWbemDialog
{
protected:
    LPWSTR m_wszClass;
    long m_lMaxLen;
    LONG* m_plQryFlags;
public:
    CCreateInstanceDlg(HWND hParent, LPWSTR wszClass, long lMaxLen, LONG* plQryFlags)
        : m_wszClass(wszClass), m_lMaxLen(lMaxLen), m_plQryFlags(plQryFlags),
            CWbemDialog(IDD_CREATEINSTANCE, hParent)
    {}

protected:
    BOOL OnInitDialog();
    BOOL Verify();
};

//#pragma warning(4270:disable)

int __cdecl CmpFunc( const void *arg1, const void *arg2 )
{
    if ((arg1 == NULL) || (*(int*)arg1 == 0))
    {
        return 1;
    }

    if ((arg2 == NULL) || (*(int*)arg2 == 0))
    {
        return -1;
    }

    VARIANT t_v1;
    VariantInit(&t_v1);
    VARIANT t_v2;
    VariantInit(&t_v2);
    int retVal = 0;

    if (SUCCEEDED( (*(IWbemClassObject **)arg1)->Get(L"__RELPATH", 0, &t_v1, NULL, NULL) ))
    {
        if (SUCCEEDED( (*(IWbemClassObject **)arg2)->Get(L"__RELPATH", 0, &t_v2, NULL, NULL) ))
        {
            if ( (VT_BSTR == t_v1.vt) && (VT_BSTR == t_v2.vt) )
            {
                char buffA[5120];
                char buffB[5120];
                wcstombs( buffA, t_v1.bstrVal, 5120 );
                wcstombs( buffB, t_v2.bstrVal, 5120 );
                int t_i = CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, buffA, -1, buffB, -1 );

                switch (t_i)
                {
                    case CSTR_LESS_THAN:
                    {
                        retVal = -1;
                        break;
                    }
                    case CSTR_EQUAL:
                    {
                        retVal = 0;
                        break;
                    }
                    case CSTR_GREATER_THAN:
                    default:
                    {
                        retVal = 1;
                        break;
                    }
                }
            }

            VariantClear(&t_v2);
        }

        VariantClear(&t_v1);
    }

    return retVal;
}

UINT WINAPI GetDlgItemTextX(
    HWND hDlg,
    int nDlgItem,
    LPWSTR pStr,
    int nMaxCount
    )
{
    char Tmp[5120];
    *Tmp = 0;
    *pStr = 0;
    UINT uRes = GetDlgItemTextA(hDlg, nDlgItem, Tmp, 5120);
    if (uRes == 0 || strlen(Tmp) == 0)
        return uRes;
    if (mbstowcs(pStr, Tmp, nMaxCount) == (unsigned) nMaxCount)
        *(pStr + nMaxCount - 1) = 0;
    return uRes;
}

BOOL GetServerNamespace(IWbemClassObject *pObj, WCHAR *szResult, int nMaxSize);
INT_PTR GetSuperclassInfo(HWND hDlg, LPWSTR pClass, LONG lMaxBuf, LONG *plQryFlags);
INT_PTR GetClassInfo(HWND hDlg, LPWSTR pClass, LONG lMaxBuf, LONG *plQryFlags);


/////////////////////////////////////////////////////////////////////////////


IWbemLocator *g_pLocator = 0;
//IWbemConnection *g_pConnection = 0;
IWbemServices *g_pNamespace = 0;
//IWbemServicesEx *g_pServicesEx=NULL;
BSTR g_strNamespace = NULL;
CAppOwner g_Owner;
CContext g_Context;

void Fatal(UINT uMsg)
{
    CBasicWbemDialog::MessageBox(0, uMsg, IDS_CRITICAL_ERROR, MB_OK | MB_SYSTEMMODAL);
}

/////////////////////////////////////////////////////////////////////////////


BOOL RegisterEventSink();
BOOL UnregisterEventSink();

/////////////////////////////////////////////////////////////////////////////


IUnsecuredApartment* CUnsecWrap::mstatic_pApartment = NULL;
IUnsecuredApartment* CUnsecWrapEx::mstatic_pApartment = NULL;


class CMainDlg : public CWbemDialog
{
protected:
    void Connect(BOOL bBind);
    void ConnectButtons(BOOL b);
    void OpenHelp(void);
    void GetClasses();
    void EditClass();
    void CreateClass();
    void DeleteClass();

    void GetInstances();
    void EditInstance();
    void CreateInstance();
    void DeleteInstance();

    void ExecQuery();

    void ExecNotificationQuery();

    void ExecMethod();
    void OpenNs();
    void CreateRefresher();
    void EditContext();

    /*
    void Open();
    void AddObject();
    void DeleteObject();
    void RenameObject();
    void GetObjectSecurity();
    void SetObjectSecurity();
	void DoServicesExGenObject(int iOpt);
	*/

    LONG  Timeout();
    ULONG BatchCount();

    LONG  m_lGenFlags;      // generic flags (i.e., WBEM_FLAG_ .. used in IWbemServices methods)
    LONG  m_lSync;          // sync, async, semisync

public:
    BOOL  m_fNotificationQueryResultDlg;

    CMainDlg() : CWbemDialog(IDD_MAIN, (HWND)NULL)
    {
        m_lGenFlags = 0;
        m_lSync = SEMISYNC;
        m_fNotificationQueryResultDlg = FALSE;
    }
    ~CMainDlg();

    BOOL OnInitDialog();
    BOOL OnCommand(WORD wNotifyCode, WORD wID);
    BOOL OnOK();
};

BOOL CMainDlg::OnOK()
{
    if(m_lRefCount > 0)
    {
        MessageBox(IDS_MUST_CLOSE_WINDOWS, IDS_ERROR, MB_OK | MB_ICONSTOP);
        return FALSE;
    }

    return CBasicWbemDialog::OnOK();
}

long CAppOwner::Release()
{
    if(CRefCountable::Release() == 0)
    {
        //CoUninitialize();
    }
    return m_lRefCount;
}


int WINAPI WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    PSTR szCmdLine,
    int iCmdShow
    )
{

    setlocale(LC_ALL, "");

    mbstowcs(gNameSpace, "", 1000);
    g_strNamespace = SysAllocString(gNameSpace);

    // OLE initialization.
    // ===================

    HRESULT hr = CoInitializeEx(NULL,COINIT_MULTITHREADED );

    if (RPC_E_CHANGED_MODE == hr) // somebody beat us
    {
        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    }

    if (hr != S_OK)
    {
        Fatal(IDS_OLE_INIT_FAILED);
        return -1;
    }

    gbSecured = (strstr(szCmdLine, "/sec") != NULL);

    if (strstr(szCmdLine, "/setp") != NULL)
    {
        if (FAILED(EnableAllPrivileges(TOKEN_PROCESS)))
        {
            Fatal(IDS_FAIL_ENABLE_ALL_PRIV);
            return -1;
        }
    }



    hr = InitializeSecurity(NULL, -1, NULL, NULL,
                                RPC_C_AUTHN_LEVEL_NONE,
                                RPC_C_IMP_LEVEL_IMPERSONATE,
                                NULL, EOAC_NONE, 0);

///	// Get a session object.
///	// =======================
///
///	dwRes = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
///			IID_IWbemLocator, (LPVOID *) &g_pLocator);
///
///
///	if (dwRes != S_OK)
///	{
///		Fatal(IDS_FAILED_IWBEMLOCATOR);
///		OleUninitialize();
///		Fatal(IDS_ABNORMAL_TERMINATION);
///		return -1;
///	}
///
///	dwRes = CoCreateInstance(CLSID_WbemConnection, 0, CLSCTX_INPROC_SERVER,
///			IID_IWbemConnection, (LPVOID *) &g_pConnection);
///
///
///	if (dwRes != S_OK)
///	{
///		Fatal(IDS_FAILED_IWBEMBINDER);
///		OleUninitialize();
///		Fatal(IDS_ABNORMAL_TERMINATION);
///		return -1;
///	}



    CMainDlg* pDlg = new CMainDlg;
    pDlg->SetDeleteOnClose();
    pDlg->SetOwner(&g_Owner);
    pDlg->Create();

    MSG msg;
    while (GetMessage(&msg, (HWND) NULL, 0, 0))
    {
        if(CBasicWbemDialog::IsDialogMessage(&msg))
            continue;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    if (g_pNamespace) g_pNamespace->Release();
    //if (g_pServicesEx) g_pServicesEx->Release();
    if (g_pLocator) g_pLocator->Release();
    //if (g_pConnection) g_pConnection->Release();

    g_Context.Clear();
    CoUninitialize();

    // Terminating normally.
    // =====================

    return 0;
}

//***************************************************************************
//
//***************************************************************************

class CErrorDlg : public CWbemDialog
{
protected:
    HRESULT m_hres;
    IWbemClassObject* m_pErrorObj;

public:
    CErrorDlg(HWND hParent, HRESULT hres, IWbemClassObject* pErrorObj = NULL)
        : CWbemDialog(IDD_ERROR,hParent), m_hres(hres), m_pErrorObj(pErrorObj)
    {
        if(pErrorObj) pErrorObj->AddRef();
    }
    ~CErrorDlg()
    {
        if(m_pErrorObj) m_pErrorObj->Release();
    }

    BOOL OnInitDialog();
    BOOL OnCommand(WORD wNotifyCode, WORD wID);
};

BOOL CErrorDlg::OnInitDialog()
{
    CenterOnParent();

    WCHAR szError[TEMP_BUF];
    szError[0] = 0;
    WCHAR szFacility[TEMP_BUF];
    szFacility[0] = 0;
    char szMsg[TEMP_BUF];
    char szFormat[100];
    IWbemStatusCodeText * pStatus = NULL;

    SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
                                        IID_IWbemStatusCodeText, (LPVOID *) &pStatus);

    if(sc == S_OK)
    {
        BSTR bstr = 0;
        sc = pStatus->GetErrorCodeText(m_hres, 0, 0, &bstr);
        if(sc == S_OK)
        {
            wcsncpy(szError, bstr, TEMP_BUF-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        sc = pStatus->GetFacilityCodeText(m_hres, 0, 0, &bstr);
        if(sc == S_OK)
        {
            wcsncpy(szFacility, bstr, TEMP_BUF-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        pStatus->Release();
    }
    if(wcslen(szFacility) == 0 || wcslen(szError) == 0)
    {
        LoadString(GetModuleHandle(NULL), ERROR_FORMAT_EX, szFormat, 99);
        sprintf(szMsg, szFormat, m_hres);
    }
    else
    {
        LoadString(GetModuleHandle(NULL), ERROR_FORMAT_LONG, szFormat, 99);
        sprintf(szMsg, szFormat, m_hres, szFacility, szError);
    }
    SetDlgItemText(IDC_MESSAGE, szMsg);


    EnableWindow(GetDlgItem(IDC_SHOWOBJECT), (m_pErrorObj != NULL));
    return TRUE;
}

BOOL CErrorDlg::OnCommand(WORD wNotifyCode, WORD wID)
{
    // Show object is the only command out there

    if(wID == IDC_SHOWOBJECT)
    {
        CObjectEditor Ed(m_hDlg, 0, CObjectEditor::readonly, SYNC, m_pErrorObj);
        Ed.Edit();
    }
    return TRUE;
}

void FormatError(HRESULT res, HWND hParent, IWbemClassObject* pErrorObj)
{
    BOOL bOwn = FALSE;
    if(pErrorObj == NULL)
    {
        IErrorInfo* pEI;
        if(GetErrorInfo(0, &pEI) == S_OK)
        {
            pEI->QueryInterface(IID_IWbemClassObject, (void**)&pErrorObj);
            pEI->Release();
            if(pErrorObj)
                bOwn = TRUE;
        }
    }

    CErrorDlg Dlg(hParent, res, pErrorObj);
    Dlg.Run(NULL, true); // no disablement
    if(bOwn)
        pErrorObj->Release();
}


static wchar_t *g_pTargetClassBuf;
static int g_nMaxTargetClassBuf;

void SetDlgItemTextWC(HWND hDlg, int ID, WCHAR * pwc)
{
    int iLen = 2*(wcslen(pwc))+1;
    char * pTemp = new char[iLen];
    if(pTemp == NULL)
        return;
    wcstombs(pTemp, pwc, iLen);
    SetDlgItemText(hDlg, ID, pTemp);
    delete pTemp;
}

void GetDlgItemTextWC(HWND hDlg, int ID, WCHAR * pwc,int iwcSize)
{
    char * pTemp = new char[iwcSize * 2];
    if(pTemp == NULL)
        return;
    if(GetDlgItemText(hDlg, ID, pTemp, iwcSize *2))
    {
        mbstowcs(pwc, pTemp, iwcSize);
    }
    else *pwc = 0;

    delete pTemp;
}


class CConnectDlg : public CWbemDialog
{
protected:
	BOOL m_bBind;
    LONG  m_lGenFlags;  // generic WBEM_FLAG_ .. flags
    LONG  m_lTimeout;   // used in semisync only

public:
    CConnectDlg(HWND hParent, BOOL bBind, LONG lGenFlags, LONG lTimeout) : CWbemDialog((bBind) ? IDD_WBEM_BIND : IDD_WBEM_CONNECT, hParent),
		 m_lGenFlags(lGenFlags), m_lTimeout(lTimeout)
    { m_bBind = bBind;}

protected:
	enum {CONNECT_IWBEMLOCATOR, CONNECT_IWBEMCONNECTION};
	enum {INTERFACE_IWBEMSERVICES, INTERFACE_IWBEMSERVICESEX, INTERFACE_IWBEMCLASSOBJECT};

    BOOL OnInitDialog();
    BOOL Verify();
    virtual BOOL OnSelChange(int nID);
};

BOOL CConnectDlg::OnInitDialog()
{
	if (gNameSpace[0]==L'\0')
		SetDlgItemTextX(IDC_NAMESPACE, L"root\\default");
	else
		SetDlgItemTextX(IDC_NAMESPACE, gNameSpace);
    SetDlgItemTextX(IDC_USER, gUser);
    SetDlgItemTextX(IDC_PASSWORD, gPassword);
    SetDlgItemTextX(IDC_LOCALE, gLocale);
    SetDlgItemTextX(IDC_AUTHORITY, gAuthority);
    BOOL bRet = CheckRadioButton(m_hDlg, IDC_NULL, IDC_BLANK, IDC_NULL);

    if (gdwImpLevel == RPC_C_IMP_LEVEL_IDENTIFY)
    {
        CheckRadioButton(m_hDlg, IDC_IMP_IDENTIFY, IDC_IMP_DELEGATE, IDC_IMP_IDENTIFY);
    }
    else if (gdwImpLevel == RPC_C_IMP_LEVEL_IMPERSONATE)
    {
        CheckRadioButton(m_hDlg, IDC_IMP_IDENTIFY, IDC_IMP_DELEGATE, IDC_IMP_IMPERSONATE);
    }
    else if (gdwImpLevel == RPC_C_IMP_LEVEL_DELEGATE)
    {
        CheckRadioButton(m_hDlg, IDC_IMP_IDENTIFY, IDC_IMP_DELEGATE, IDC_IMP_DELEGATE);
    }
    if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_NONE)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_NONE);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_CONNECT)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_CONNECTION);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_CALL)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_CALL);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_PKT)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_PACKET);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_PACKET_INTEGRITY);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_PACKET_PRIVACY);
    }

   	AddStringToCombo (IDC_CONNECTUSING, "IWbemLocator (Namespaces)", CONNECT_IWBEMLOCATOR);

#if 0
	RAID 167868 
	Support for EX temporary removed, default IWbemLocator
	AddStringToCombo (IDC_CONNECTUSING, "IWbemConnection (Namespaces, Scopes, Objects)", CONNECT_IWBEMCONNECTION);
#endif
	SetComboSelection (IDC_CONNECTUSING, CONNECT_IWBEMLOCATOR );
	SendMessage (m_hDlg, WM_COMMAND, MAKEWPARAM(IDC_CONNECTUSING, CBN_SELCHANGE), (LPARAM)GetDlgItem (IDC_CONNECTUSING));

	AddStringToCombo (IDC_COMPLETION, "Synchronous", SYNC);
	AddStringToCombo (IDC_COMPLETION, "Semisynchronous", SEMISYNC);
	AddStringToCombo (IDC_COMPLETION, "Asynchronous", ASYNC);
	SetComboSelection (IDC_COMPLETION, SYNC);

	return TRUE;
}


BOOL CConnectDlg::OnSelChange(int nID)
{
	int sel=(int)SendDlgItemMessage (m_hDlg, IDC_CONNECTUSING, CB_GETCURSEL, 0, 0L);
	int connectusing=(int)SendDlgItemMessage (m_hDlg, IDC_CONNECTUSING, CB_GETITEMDATA, sel, 0L);
	sel=(int)SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_GETCURSEL, 0, 0L);
	int interfacereturned=(int)SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_GETITEMDATA, sel, 0L);

	switch (nID)
	{
		case IDC_CONNECTUSING:
		{
			bool authority=(connectusing==CONNECT_IWBEMLOCATOR);
			EnableWindow (GetDlgItem (IDC_AUTHORITY), authority);
			EnableWindow (GetDlgItem (IDC_AUTHORITYLABEL), authority);

			bool asynchronous=(connectusing==CONNECT_IWBEMCONNECTION);
			EnableWindow (GetDlgItem (IDC_COMPLETION), asynchronous);
			EnableWindow (GetDlgItem (IDC_COMPLETIONLABEL), asynchronous);
			if (!asynchronous)
				SetComboSelection (IDC_COMPLETION, SYNC);

			SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_RESETCONTENT, 0, 0L);
			AddStringToCombo (IDC_INTERFACERETURNED, "IWbemServices", INTERFACE_IWBEMSERVICES);
			
/*		
			RAID 167868 
			Support for EX temporary removed 
			AddStringToCombo (IDC_INTERFACERETURNED, "IWbemServicesEx", INTERFACE_IWBEMSERVICESEX);
*/
			if (connectusing==CONNECT_IWBEMCONNECTION)
				AddStringToCombo (IDC_INTERFACERETURNED, "IWbemClassObject", INTERFACE_IWBEMCLASSOBJECT);
			
			SetComboSelection (IDC_INTERFACERETURNED, ( INTERFACE_IWBEMSERVICES ));

			SendMessage (m_hDlg, WM_COMMAND, MAKEWPARAM(IDC_INTERFACERETURNED, CBN_SELCHANGE), (LPARAM)GetDlgItem (IDC_INTERFACERETURNED));

			break;
		}

		case IDC_INTERFACERETURNED:
		{
			char szBuffer[1024];

			if (connectusing==CONNECT_IWBEMLOCATOR)
				LoadString(GetModuleHandle(NULL), IDS_NAMESPACE, szBuffer, 1024);
			else
			{
				if (interfacereturned==INTERFACE_IWBEMCLASSOBJECT)
					LoadString(GetModuleHandle(NULL), IDS_OBJECT_PATH, szBuffer, 1024);
				else
					LoadString(GetModuleHandle(NULL), IDS_NAMESPACE_SCOPE, szBuffer, 1024);
			}

			SetDlgItemText(IDC_PATHLABEL, szBuffer);

			break;
		}
	}

    return TRUE;
}

BOOL CConnectDlg::Verify()
{
    WCHAR NameSpace[512], User[64], Password[64], Locale[128];
    WCHAR Authority[64];
    User[0] = Password[0] = Locale[0] = Authority[0] = NameSpace[0] = 0;
	bool bBoundToObject = false;

    GetDlgItemTextX(IDC_NAMESPACE, NameSpace, 512);
    GetDlgItemTextX(IDC_USER, User, 64);
    GetDlgItemTextX(IDC_PASSWORD, Password, 64);
    GetDlgItemTextX(IDC_AUTHORITY, Authority, 64);
    GetDlgItemTextX(IDC_LOCALE, Locale, 128);

    bool bTreatEmptyAsBlank = (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_BLANK));

    gdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
    gdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_IMP_IDENTIFY))
    {
        gdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_IMP_IMPERSONATE))
    {
        gdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_IMP_DELEGATE))
    {
        gdwImpLevel = RPC_C_IMP_LEVEL_DELEGATE ;
    }
    if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_NONE))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_CONNECTION))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_CALL))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_CALL ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_PACKET))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_PKT ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_PACKET_INTEGRITY))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_PACKET_PRIVACY))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY ;
    }

    if(wcslen(NameSpace) < 1)
    {
        MessageBox(m_hDlg, IDS_INVALID_NAMESPACE, IDS_ERROR, MB_OK | MB_ICONSTOP);
        return FALSE;
    }
    CBString bsNamespace(NameSpace);
    CBString bsLocale(Locale);

    HCURSOR hWait, hSave = NULL;

    CBString bsUser;
    CBString bsAuthority;
    CBString bsPassword;

    if(wcslen(User) > 0)
        bsUser = User;

    if(wcslen(Password) > 0)
        bsPassword = Password;
    else if (bTreatEmptyAsBlank)
        bsPassword = L"";

    if(wcslen(Authority) > 0)
        bsAuthority = Authority;

    // Cleanup a preexisting principal and AuthIdentity as necessary
    if ( NULL != gpPrincipal )
    {
        SysFreeString( gpPrincipal );
        gpPrincipal = NULL;
    }

    if ( NULL != gpAuthIdentity )
    {
        WbemFreeAuthIdentity( gpAuthIdentity );
        gpAuthIdentity = NULL;
    }

    hWait = LoadCursor(NULL, IDC_WAIT);
    SCODE sRes=S_OK;
    if(hWait)
        hSave = SetCursor(hWait);


	// Determine which connection method and interface is requested.
	int cursel=(int)SendDlgItemMessage (m_hDlg, IDC_CONNECTUSING, CB_GETCURSEL, 0, 0);
	int ConnectUsing=(int)SendDlgItemMessage (m_hDlg, IDC_CONNECTUSING, CB_GETITEMDATA, cursel, 0);
	cursel=(int)SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_GETCURSEL, 0, 0);
	int InterfaceReturned=(int)SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_GETITEMDATA, cursel, 0);
	int sel=(int)SendDlgItemMessage (m_hDlg, IDC_COMPLETION, CB_GETCURSEL, 0, 0);
	LONG lSync=(LONG)SendDlgItemMessage (m_hDlg, IDC_COMPLETION, CB_GETITEMDATA, sel, 0);
    IID riid;
	switch (InterfaceReturned)
	{
		case INTERFACE_IWBEMSERVICES:
            riid = IID_IWbemServices;
			break;
//		case INTERFACE_IWBEMSERVICESEX:
//            riid = IID_IWbemServicesEx;
			break;
		case INTERFACE_IWBEMCLASSOBJECT:
            riid = IID_IWbemClassObject;
    }

	// Obtain a connection object of the requested type.
	if (g_pLocator) g_pLocator->Release();
	//if (g_pConnection) g_pConnection->Release();
	g_pLocator=NULL;
	//g_pConnection=NULL;
	switch (ConnectUsing)
	{
		case CONNECT_IWBEMLOCATOR:
		{
			sRes=CoCreateInstance (CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void **)&g_pLocator);
			break;
		}
/*
		case CONNECT_IWBEMCONNECTION:
		{
			sRes=CoCreateInstance (CLSID_WbemConnection, 0, CLSCTX_INPROC_SERVER, IID_IWbemConnection, (void **)&g_pConnection);
			break;
		}
*/		
    }


	// Connect and obtain requested interfaces.
	if (g_pNamespace) g_pNamespace->Release();
	//if (g_pServicesEx) g_pServicesEx->Release();
	g_pNamespace=NULL;
	//g_pServicesEx=NULL;
	IWbemClassObject *pObject=NULL;
	if (g_pLocator)
	{
		sRes=g_pLocator->ConnectServer (bsNamespace.GetString(), 
			bsUser.GetString(), bsPassword.GetString(),
			bsLocale.GetString(), 0, bsAuthority.GetString(), g_Context, &g_pNamespace);

		if (SUCCEEDED(sRes))
		{
			switch (InterfaceReturned)
			{
			    /*
				case INTERFACE_IWBEMSERVICESEX:
				{
					sRes=g_pNamespace->QueryInterface (IID_IWbemServicesEx, (void **)&g_pServicesEx);
					break;
				}
				*/

				case INTERFACE_IWBEMCLASSOBJECT:
				{
					// This should always fail.  It's here so that wbemtest can display the actual
					// return code as generated by QI in such a case.
					sRes=g_pNamespace->QueryInterface (IID_IWbemClassObject, (void **)&pObject);
					break;
				}
			}
		}
	}
/*	
	else if (g_pConnection)
	{
		IUnknown *pUnknown=NULL;

		if (lSync & ASYNC)
		{
			CTestNotify* pSink=new CTestNotify();

			sRes=g_pConnection->OpenAsync(bsNamespace.GetString(),
				bsUser.GetString(), bsPassword.GetString(),
				bsLocale.GetString(), 0, g_Context, 
				riid, pSink);

			if (SUCCEEDED(sRes))
			{
				pSink->WaitForSignal(INFINITE);
				sRes = pSink->GetStatusCode();
				if(SUCCEEDED(sRes))
				{
					pUnknown=pSink->GetInterface();
					pSink->Release();
				}
			}
		}
		else if (lSync & SEMISYNC)
		{
	        IWbemCallResultEx *pResult=NULL;

			sRes=g_pConnection->Open (bsNamespace.GetString(),
				bsUser.GetString(), bsPassword.GetString(),
				bsLocale.GetString(), 0, g_Context, 
				riid, NULL, &pResult);

			if (SUCCEEDED(sRes))
			{
				SetInterfaceSecurityEx (pResult, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);

				LONG lStatus;
				while ((sRes=pResult->GetCallStatus (WBEM_INFINITE, &lStatus))==WBEM_S_TIMEDOUT)
				{
                    Sleep(200);         // give the other threads a chance
				}

				if (SUCCEEDED(sRes))
				{
					sRes=(HRESULT)lStatus;
					if (sRes==WBEM_S_NO_ERROR)
					{
						sRes=pResult->GetResult (0, 0, IID_IWbemServices, (void**)&pUnknown);
					}
				}

				pResult->Release();
			}
		}
		else
		{
			sRes=g_pConnection->Open (bsNamespace.GetString(),
				bsUser.GetString(), bsPassword.GetString(),
				bsLocale.GetString(), 0, g_Context, 
				riid, (void **)&pUnknown, NULL);
		}

		if (SUCCEEDED(sRes))
		{
			switch (InterfaceReturned)
			{
				case INTERFACE_IWBEMSERVICES:
				{
					sRes=pUnknown->QueryInterface (IID_IWbemServices, (void **)&g_pNamespace);
					break;
				}

				case INTERFACE_IWBEMSERVICESEX:
				{
					// A-DAVCOO: We temporarily need both interfaces when an IWbemServicesEx is requested.
					sRes=pUnknown->QueryInterface (IID_IWbemServices, (void **)&g_pNamespace);
					if (SUCCEEDED(sRes))
						sRes=pUnknown->QueryInterface (IID_IWbemServicesEx, (void **)&g_pServicesEx);

					break;
				}
				

				case INTERFACE_IWBEMCLASSOBJECT:
				{
					sRes=pUnknown->QueryInterface (IID_IWbemClassObject, (void **)&pObject);
					break;
				}
			}

			pUnknown->Release();
			pUnknown=NULL;
		}
	}
*/

	// If an IWbemClassObject was obtained, display the object editor.
	if (pObject)
	{
		bBoundToObject=true;
		CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::foreign, lSync, pObject, m_lTimeout);
		ed.Edit();

		pObject->Release();
		pObject=NULL;
	}


    if(hSave)
        SetCursor(hSave);
    if(SUCCEEDED(sRes))
    {
        if(!bBoundToObject)
			wcscpy(gNameSpace, NameSpace);
        wcscpy(gLocale, Locale);
        wcscpy(gAuthority, Authority);
        wcscpy(gUser, User);
        if(wcslen(gUser) > 0)
            gpUser = gUser;
        else
            gpUser = NULL;
        wcscpy(gPassword, Password);
        if(wcslen(gPassword) > 0)
            gpPassword = gPassword;
        else if (bTreatEmptyAsBlank)
            gpPassword = L"";
        else
            gpPassword = NULL;

        if(wcslen(gAuthority) > 0)
            gpAuthority = gAuthority;
        else
            gpAuthority = NULL;

		if (g_pNamespace)
		{
			SetInterfaceSecurityEx(g_pNamespace, gpAuthority, gpUser, gpPassword,
				gdwAuthLevel, gdwImpLevel, EOAC_NONE, &gpAuthIdentity, &gpPrincipal );
		}

/*
		if (g_pServicesEx)
		{
			SetInterfaceSecurityEx(g_pNamespace, gpAuthority, gpUser, gpPassword,
				gdwAuthLevel, gdwImpLevel, EOAC_NONE, &gpAuthIdentity, &gpPrincipal );
		}
*/		
    }

	if (FAILED(sRes))
	{
        FormatError(sRes, m_hDlg);
        SetDlgItemText(IDC_PASSWORD, "");
        return FALSE;
    }

	if(bBoundToObject)
		return FALSE;
	else
	{
		SysFreeString(g_strNamespace);
		g_strNamespace = SysAllocString(bsNamespace.GetString());
	    return TRUE;
	}
}

//***************************************************************************
//
//***************************************************************************
void CMainDlg::Connect(BOOL bBind)
{
    if(m_lRefCount > 0)
    {
        MessageBox(IDS_MUST_CLOSE_WINDOWS, IDS_ERROR, MB_OK | MB_ICONSTOP);
        return;
    }

    CConnectDlg ConnectDlg(m_hDlg, bBind, m_lGenFlags, Timeout());
    INT_PTR nRes = ConnectDlg.Run();
    ConnectButtons(g_pNamespace!=NULL);

    if(nRes != IDOK)
    {
        if(g_pNamespace == NULL)
            SetDlgItemText(IDC_NAMESPACE, "");
        return;
    }
    // If here, we succeeded.
    // ======================
    SetDlgItemTextWC(m_hDlg, IDC_NAMESPACE, gNameSpace);
    ConnectButtons(TRUE);
}


//***************************************************************************
//
//***************************************************************************
void CMainDlg::OpenHelp(void)
{

  TCHAR helpFile[]=TEXT("\\HELP\\WBEMTEST.CHM");
  const int maxPath = MAX_PATH+sizeof(helpFile)/sizeof(TCHAR);

  TCHAR sysLoc[maxPath];  
  const int pathLen = GetWindowsDirectory (sysLoc,MAX_PATH);

  if (pathLen == 0 || pathLen >=MAX_PATH)
      return;
  _tcscat(sysLoc,helpFile);

 HtmlHelp(m_hDlg,sysLoc,HH_DISPLAY_TOPIC,0);
}


//***************************************************************************
//
//***************************************************************************



INT_PTR CALLBACK GetClassNameDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    *g_pTargetClassBuf = 0;
                    GetDlgItemTextX(hDlg, IDC_CLASS_NAME, g_pTargetClassBuf,
                        g_nMaxTargetClassBuf);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
    }
    return FALSE;
}

//***************************************************************************
//
//***************************************************************************

INT_PTR GetClassName(HWND hDlg, wchar_t *pszClassName, int nLimit)
{
    g_pTargetClassBuf = pszClassName;
    g_nMaxTargetClassBuf = nLimit;

    INT_PTR nRes = DialogBox(GetModuleHandle(0),
        MAKEINTRESOURCE(IDD_CLASS_NAME), hDlg,
            GetClassNameDlgProc
            );

    return nRes;
}

BOOL _GetObject(HWND hDlg, LONG lGenFlags, wchar_t *pszPath, LONG lSync, IWbemClassObject*& pClass,
                LONG lTimeout, bool bSuppressErrors = false)
{
    CBString bsPath(pszPath);
    pClass = NULL;

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->GetObjectAsync(bsPath.GetString(),
                                lGenFlags | WBEM_FLAG_SEND_STATUS,
                                g_Context, CUnsecWrap(pNtfy));

        if(SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
            if(SUCCEEDED(res))
            {
                CFlexArray* pArray = pNtfy->GetObjectArray();

                if(pArray && pArray->Size() > 0)
                {
                    pClass = (IWbemClassObject*)pArray->GetAt(0);
                    if (pClass)
                        pClass->AddRef();
                }
            }
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->GetObject(bsPath.GetString(),
                                lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, &pClass, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::GetObject call
				if ( SUCCEEDED (res) )
                {
                    res = pCallRes->GetResultObject(0, &pClass); // don't use timeout since object should be available
                }
				else
				{
			        if(!bSuppressErrors)
						FormatError(res, hDlg, pErrorObj);
					return FALSE;
				}
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->GetObject(bsPath.GetString(),
                                lGenFlags,
                                g_Context, &pClass, NULL);
    }

    if (FAILED(res))
    {
        if(!bSuppressErrors)
			FormatError(res, hDlg, pErrorObj);
        return FALSE;
    }

    return TRUE;
}

BOOL _PutClass(HWND hDlg, LONG lGenFlags, LONG lChgFlags, LONG lSync,
               IWbemClassObject* pClass, LONG lTimeout)
{
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if(lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->PutClassAsync(pClass,
                                lGenFlags | lChgFlags | WBEM_FLAG_SEND_STATUS,
                                g_Context, CUnsecWrap(pNtfy));

        if(SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->PutClass(pClass,
                                lGenFlags | lChgFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::PutClass call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->PutClass(pClass,
                                lGenFlags | lChgFlags,
                                g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, hDlg, pErrorObj);
        return FALSE;
    }

    return TRUE;
}

void ShowClass(HWND hDlg, LONG lGenFlags, LPWSTR wszClass, LONG lSync,
               CRefCountable* pOwner, LONG lTimeout)
{
    IWbemClassObject* pClass;
    if(!_GetObject(hDlg, lGenFlags, wszClass, lSync, pClass, lTimeout))
        return;

    DWORD dwEditMode;
    if(wcschr(wszClass, L'\\') || wcschr(wszClass, L':'))
        dwEditMode = CObjectEditor::foreign;
    else
        dwEditMode = CObjectEditor::readwrite;

    CObjectEditor* ped = new CObjectEditor(hDlg, lGenFlags, dwEditMode, lSync, pClass,
                                           lTimeout);
    ped->RunDetached(pOwner);
    pClass->Release();
}

void CMainDlg::EditClass()
{
    wchar_t Class[2048];
    *Class = 0;

    INT_PTR nRes = GetClassName(m_hDlg, Class, 2048);
    if (nRes == IDCANCEL || wcslen(Class) == 0)
        return;

    // Create the requested class; the timeout is only used if semisync
    IWbemClassObject* pClass;
    if (!_GetObject(m_hDlg, m_lGenFlags, Class, m_lSync, pClass, Timeout()))
        return;

    DWORD dwEditMode = CObjectEditor::readwrite;

    // Create an object that is guarenteed to be in the local server\namespace
    IWbemClassObject *pLocalObj = 0;

    if (_GetObject(m_hDlg, m_lGenFlags, L"__SystemClass", m_lSync, pLocalObj, Timeout(), true))
	{

		// Extract the server\namespace path for the objects
		WCHAR szSNS1[2048], szSNS2[2048];
		GetServerNamespace(pClass, szSNS1, 2048);
		GetServerNamespace(pLocalObj, szSNS2, 2048);

		// Set the edit permissions based on whether the requested
		//  object is in the same namespace
		if (wbem_wcsicmp(szSNS1, szSNS2))
			dwEditMode = CObjectEditor::foreign;
	}

    if (pLocalObj)
        pLocalObj->Release();

    CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags, dwEditMode, m_lSync,
                                           pClass, Timeout(), BatchCount());
    ped->RunDetached(this);
    pClass->Release();
}

//***************************************************************************
//
//***************************************************************************

static wchar_t *g_pSupClassBuf = 0;
static int g_nMaxSupClassBuf = 0;

INT_PTR CALLBACK SuperclassDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    *g_pSupClassBuf = 0;
                    GetDlgItemTextX(hDlg, IDC_SUPERCLASS, g_pSupClassBuf,
                        g_nMaxSupClassBuf);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
    }
    return FALSE;
}

//***************************************************************************
//
//***************************************************************************

INT_PTR GetSuperclass(HWND hDlg, wchar_t *pszClassName, int nLimit)
{
    g_pSupClassBuf = pszClassName;
    g_nMaxSupClassBuf = nLimit;

    INT_PTR nRes = DialogBox(GetModuleHandle(0),
        MAKEINTRESOURCE(IDD_SUPERCLASS), hDlg,
            SuperclassDlgProc
            );

    return nRes;
}

//***************************************************************************
//
//***************************************************************************
BOOL PreCreateClass(HWND hDlg, LONG lGenFlags, WCHAR* Superclass, LONG lSync,
                    IWbemClassObject*& pNewClass, LONG lTimeout)
{
    // Get the parent class, if any
    // ============================

    IWbemClassObject* pParentClass = 0;
    if (!_GetObject(hDlg, lGenFlags, Superclass, lSync, pParentClass, lTimeout))
    {
        return FALSE;
    }

    // Create an empty child class
    // ===========================

    HRESULT hres = WBEM_S_NO_ERROR;
    if (wcslen(Superclass) > 0)
    {
        hres = pParentClass->SpawnDerivedClass(0, &pNewClass);
        if (hres != WBEM_S_NO_ERROR)
        {
            FormatError(hres, hDlg);
            pParentClass->Release();
            return FALSE;
        }
    }
    else
    {
        pNewClass = pParentClass;
        pNewClass->AddRef();
    }

    pParentClass->Release();
    if (FAILED(hres))
    {
        FormatError(hres, hDlg);
        return FALSE;
    }

    VARIANT v;
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(L"");
    pNewClass->Put(L"__CLASS", 0, &v, 0);
    VariantClear(&v);

    return TRUE;
}

BOOL _CreateClass(HWND hDlg, LONG lGenFlags, WCHAR* Superclass, LONG lSync,
                    IWbemClassObject** ppClass, LONG lTimeout)
{
    IWbemClassObject* pNewClass;

    if (!PreCreateClass(hDlg, lGenFlags, Superclass, lSync, pNewClass, lTimeout))
        return FALSE;

    // Start editing
    // =============

    CObjectEditor ed(hDlg, lGenFlags, CObjectEditor::readwrite, lSync, pNewClass,
                     lTimeout);
    if (ed.Edit() == IDCANCEL)
    {
        pNewClass->Release();
        return FALSE;
    }

    // Finally, commit the class definition if the user
    // did not hit 'cancel'.
    // =================================================

    BOOL bRes = _PutClass(hDlg, lGenFlags, WBEM_FLAG_CREATE_ONLY, lSync, pNewClass, lTimeout);

    if (bRes && ppClass)
        *ppClass = pNewClass;
    else
        pNewClass->Release();

    return bRes;
}

void CMainDlg::CreateClass()
{
    wchar_t Superclass[2048];
    *Superclass = 0;

    // Allow user to specify a superclass.
    // ====================================

    INT_PTR nRes = GetSuperclass(m_hDlg, Superclass, 2048);
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    IWbemClassObject* pClass = NULL;
    PreCreateClass(m_hDlg, m_lGenFlags, Superclass, m_lSync, pClass, Timeout());

    if(pClass == NULL)
        return;

    CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags, CObjectEditor::readwrite,
                                           m_lSync, pClass, Timeout(), BatchCount());
    ped->RunDetached(this);
    pClass->Release();
}

void CMainDlg::DeleteClass()
{
    wchar_t ClassName[2048];
    *ClassName = 0;

    INT_PTR nRes = GetClassName(m_hDlg, ClassName, 2048);

    if (nRes == IDCANCEL || wcslen(ClassName) == 0)
        return;

    nRes = MessageBox(IDS_DELETING_CLASS, IDS_WARNING, MB_YESNO | MB_ICONWARNING);
    if(nRes != IDYES)
        return;

    CBString bsClassName(ClassName);

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if(m_lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->DeleteClassAsync(bsClassName.GetString(),
                                             m_lGenFlags | WBEM_FLAG_SEND_STATUS,
                                             g_Context, CUnsecWrap(pNtfy));

        if (SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->DeleteClass(bsClassName.GetString(),
                                        m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                        g_Context, &pCallRes);
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteClass call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->DeleteClass(bsClassName.GetString(),
                                        m_lGenFlags,
                                        g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
        return;
    }
}

BOOL _PutInstance(HWND hDlg, LONG lGenFlags, LONG lChgFlags, LONG lSync,
                  IWbemClassObject* pInstance, LONG lTimeout)
{
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if(lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->PutInstanceAsync(pInstance,
                                lGenFlags | lChgFlags | WBEM_FLAG_SEND_STATUS,
                                g_Context, CUnsecWrap(pNtfy));

        if (SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->PutInstance(pInstance,
                                lGenFlags | lChgFlags |  WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::PutInstance call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->PutInstance(pInstance,
                                lGenFlags | lChgFlags,
                                g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, hDlg, pErrorObj);
        return FALSE;
    }

    return TRUE;
}


IWbemClassObject* PreCreateInstance(HWND hDlg, LONG lGenFlags, LONG lSync, LONG lTimeout)
{
    // Get the class.
    // ==============
    wchar_t ClassName[2048];
    *ClassName = 0;

	long lFlags = 0;
    CCreateInstanceDlg InfoDlg(hDlg, ClassName, 2048, &lFlags);
    INT_PTR nRes = InfoDlg.Run();

    if (nRes == IDCANCEL || wcslen(ClassName) == 0)
        return NULL;

	IWbemClassObject* pInst = 0;
	if(lFlags == 1)
	{
		IWbemClassObject* pClass = 0;
		if (!_GetObject(hDlg, lGenFlags, ClassName, lSync, pClass, lTimeout))
			return NULL;

		// Get a clean instance of the class.
		// ==================================

		HRESULT hres = pClass->SpawnInstance(0, &pInst);
		if (FAILED(hres))
		{
			FormatError(hres, hDlg);
			return NULL;
		}
	}
	else
	{
		if (!_GetObject(hDlg, WBEM_FLAG_SPAWN_INSTANCE, ClassName, lSync, pInst, lTimeout))
			return NULL;
	}

    return pInst;
}

IWbemClassObject* _CreateInstance(HWND hDlg, LONG lGenFlags, LONG lSync, LONG lTimeout)
{
    IWbemClassObject* pInst = PreCreateInstance(hDlg, lGenFlags, lSync, lTimeout);
    if(pInst == NULL)
        return NULL;

    // If here, we have an instance we can edit.
    // =========================================

    CObjectEditor ed(hDlg, lGenFlags, CObjectEditor::readwrite, lSync, pInst, lTimeout);
    if (ed.Edit() == IDCANCEL)
    {
        pInst->Release();
        return NULL;
    }

    return pInst;
}


void CMainDlg::CreateInstance()
{
    IWbemClassObject* pInst = PreCreateInstance(m_hDlg, m_lGenFlags, m_lSync, Timeout());
    if(pInst == NULL)
        return;

    CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags, CObjectEditor::readwrite,
                                           m_lSync, pInst, Timeout(), BatchCount());
    ped->RunDetached(this);
    pInst->Release();
}

/////////////////////////////////////////////////////////////////////////////
//
//  Refresher Object Path Dialog
//
/////////////////////////////////////////////////////////////////////////////
static wchar_t *g_pszRefrObjectPath = 0;
static int g_nMaxRefrObjectPath = 0;

INT_PTR CALLBACK RefrObjectPathDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    *g_pszRefrObjectPath = 0;
                    GetDlgItemTextX(hDlg, IDC_REFR_OBJECT_PATH, g_pszRefrObjectPath,
                        g_nMaxRefrObjectPath);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDC_ADDENUM:
                    *g_pszRefrObjectPath = 0;
                    GetDlgItemTextX(hDlg, IDC_REFR_OBJECT_PATH, g_pszRefrObjectPath,
                        g_nMaxRefrObjectPath);
                    EndDialog(hDlg, IDC_ADDENUM);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
    }
    return FALSE;
}

INT_PTR GetRefrObjectPath(HWND hDlg, LPWSTR pStr, int nMax)
{
    g_pszRefrObjectPath = pStr;
    g_nMaxRefrObjectPath = nMax;

    INT_PTR nRes = DialogBox(GetModuleHandle(0),
        MAKEINTRESOURCE(IDD_REFRESHER_OBJECT_PATH), hDlg,
            RefrObjectPathDlgProc
            );
    return nRes;
}

/////////////////////////////////////////////////////////////////////////////
//
//  Object Path Dialog
//
/////////////////////////////////////////////////////////////////////////////
static wchar_t *g_pszObjectPath = 0;
static int g_nMaxObjectPath = 0;

INT_PTR CALLBACK ObjectPathDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    *g_pszObjectPath = 0;
                    GetDlgItemTextX(hDlg, IDC_OBJECT_PATH, g_pszObjectPath,
                        g_nMaxObjectPath);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
    }
    return FALSE;
}

INT_PTR GetObjectPath(HWND hDlg, LPWSTR pStr, int nMax)
{
    g_pszObjectPath = pStr;
    g_nMaxObjectPath = nMax;

    INT_PTR nRes = DialogBox(GetModuleHandle(0),
        MAKEINTRESOURCE(IDD_OBJECT_PATH), hDlg,
            ObjectPathDlgProc
            );
    return nRes;
}

BOOL GetServerNamespace(IWbemClassObject *pObj, WCHAR *szResult, int nMaxSize)
///////////////////////////////////////////////////////////////////
//
//  Calls Get on the object's path property, removes the colon
//  and object name which results in a string representing the
//  server\namespace.
//
//  Parameters: a pointer to a Class Object, a pointer to the output
//              string, and the maximum size of the output string
//
//  Returns :   True if success.
//
///////////////////////////////////////////////////////////////////
{
    VARIANT vObjNS;
    VariantInit(&vObjNS);

    // Get the full object path
    HRESULT hRes = pObj->Get(L"__PATH", 0, &vObjNS, NULL, NULL);
    if (FAILED(hRes))
        return FALSE;

    // Identify the colon location
    int len = wcscspn(V_BSTR(&vObjNS), L":");

    // Check boundary of the result string
    if (len + 1 > nMaxSize)
        return FALSE;

    // Copy the server\namespace
    wcsncpy(szResult, V_BSTR(&vObjNS), len);
    szResult[len] = L'\0';

    VariantClear(&vObjNS);

    return TRUE;
}

void CMainDlg::EditInstance()
{
    wchar_t ObjPath[2560];

    // Get the path for the object to be created
    INT_PTR iRet = GetObjectPath(m_hDlg, ObjPath, 2560);
    if(iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
    {
        MessageBox(IDS_NO_PATH, IDS_ERROR, MB_OK);
        return;
    }

    // Create the requested object; the timeout is only used if semisync
    IWbemClassObject *pInst = 0;
    if (!_GetObject(m_hDlg, m_lGenFlags, ObjPath, m_lSync, pInst, Timeout()))
        return;

    DWORD dwEditMode = CObjectEditor::readwrite;

    // Create an object that is guarenteed to be in the server\namespace
	// This is used so that we can gray out the "save" buttons in the case
	// where an a GetObject is passed another namespace and we dont have the
	// IWbemServices pointer to it.

    IWbemClassObject *pLocalObj = 0;
    if (_GetObject(m_hDlg, m_lGenFlags, L"__SystemClass", m_lSync, pLocalObj,
                    Timeout(), true))
	{
		// Extract the server\namespace path for the objects
		WCHAR szSNS1[2048], szSNS2[2048];
		GetServerNamespace(pInst, szSNS1, 2048);
		GetServerNamespace(pLocalObj, szSNS2, 2048);

		// Set the edit permissions based on whether the requested
		//  object is in the same namespace
		if(wbem_wcsicmp(szSNS1, szSNS2))
			dwEditMode = CObjectEditor::foreign;

		if (pLocalObj)
			pLocalObj->Release();
	}

    CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags, dwEditMode, m_lSync,
                                           pInst, Timeout(), BatchCount());
    ped->RunDetached(this);
    pInst->Release();
}


void CMainDlg::DeleteInstance()
{
    wchar_t ObjPath[2560];
    *ObjPath = 0;

    INT_PTR iRet = GetObjectPath(m_hDlg, ObjPath, 2560);
    if (iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
        return;

    CBString bsObjPath(ObjPath);
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->DeleteInstanceAsync(bsObjPath.GetString(),
                                                m_lGenFlags | WBEM_FLAG_SEND_STATUS,
                                                g_Context, CUnsecWrap(pNtfy));

        if (SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->DeleteInstance(bsObjPath.GetString(),
                                           m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           g_Context, &pCallRes);
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteIntance call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->DeleteInstance(bsObjPath.GetString(), m_lGenFlags,
                                           g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
    }
}



//***************************************************************************
//
//***************************************************************************
class CNotificationQueryResultDlg : public CQueryResultDlg
{
public:
    CNotificationQueryResultDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, LONG lSync )
	    : CQueryResultDlg(hParent, lGenFlags, lQryFlags, FALSE)
	{
        if ( SEMISYNC == lSync )
        {
		    CMainDlg * pMainDlg = (CMainDlg*)GetWindowLongPtr(hParent, DWLP_USER);
		    pMainDlg->m_fNotificationQueryResultDlg = TRUE;
        }
	};

	~CNotificationQueryResultDlg( )
	{
        if ( SEMISYNC == m_lSync )
        {
		    CMainDlg * pMainDlg = (CMainDlg*)GetWindowLongPtr(m_hParent, DWLP_USER);
			if ( NULL != pMainDlg )
			{
			    pMainDlg->m_fNotificationQueryResultDlg = FALSE;
			}
			else
			{
				// this means that the main dlg has been yanked away, so reset owner, because owner is GONE
				m_pOwner = NULL;
			}
        }
	}
};



//***************************************************************************
//
//***************************************************************************
class CInstanceListDlg : public CQueryResultDlg
{
protected:
    BSTR m_strClass;

    BOOL CanAdd()		{ return !m_bReadOnly && m_lQryFlags & WBEM_FLAG_SHALLOW; }
    IWbemClassObject* AddNewElement();

public:
    CInstanceListDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, LPWSTR wszClass,
                     LONG lSync, BOOL bReadOnly, LONG lTimeout, ULONG nBatch)
        : CQueryResultDlg(hParent, lGenFlags, lQryFlags), m_strClass(SysAllocString(wszClass))
    {
        SetReadOnly(bReadOnly);
        // Pass on invocation method (sync, async..) related settings for use in this
        // enumeration and by any further operations (editing/deleting/etc. of an instance).
        SetCallMethod(lSync);
        SetTimeout(lTimeout);
        SetBatchCount(nBatch);
    }
    ~CInstanceListDlg()
    {
        SysFreeString(m_strClass);
    }
    BOOL Initialize();
};

BOOL CInstanceListDlg::Initialize()
{
    char szTitle[1024];
    char szFormat[1024];
    LoadString(GetModuleHandle(NULL), IDS_INSTANCES_OF, szFormat, 1024);
    sprintf(szTitle, szFormat, m_strClass);

    if(m_lQryFlags & WBEM_FLAG_DEEP)
    {
        LoadString(GetModuleHandle(NULL), IDS_RECURSIVE_PARENS, szFormat, 1024);
        strcat(szTitle, szFormat);
    }

    SetTitle(szTitle);

    // Asynchronous
    if(m_lSync & ASYNC)
    {
        CNotSink* pHandler = new CNotSink(this);        // contructor starts ref count at 1
        SetNotify(pHandler);

        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateInstanceEnumAsync(m_strClass,
                         m_lGenFlags | m_lQryFlags | WBEM_FLAG_SEND_STATUS,
                         g_Context, GetWrapper());
        }
        pHandler->Release();

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateInstanceEnum(m_strClass,
                        m_lGenFlags | m_lQryFlags | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                        g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }

        // Create sink for use in NextAsync calls.
        if (m_lSync & USE_NEXTASYNC)
        {
            CNotSink* pHandler = new CNotSink(this);        // contructor starts ref count at 1
            SetNotify(pHandler);
            pHandler->Release();
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        SetEnum(pEnum);
        pEnum->Release();
    }

    // Synchronous
    else
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateInstanceEnum(m_strClass,
                        m_lGenFlags | m_lQryFlags | WBEM_FLAG_FORWARD_ONLY,
                        g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        SetEnum(pEnum,hres);
        pEnum->Release();
    }

    return TRUE;
}

IWbemClassObject* CInstanceListDlg::AddNewElement()
{
    IWbemClassObject* pClass = 0;
    if(!_GetObject(m_hDlg, m_lGenFlags, m_strClass, m_lSync, pClass, m_lTimeout))
        return NULL;

    // Get a clean instance of the class.
    // ==================================

    IWbemClassObject* pInst = 0;
    HRESULT hres = pClass->SpawnInstance(0, &pInst);
    pClass->Release();
    if (FAILED(hres))
    {
        FormatError(hres, m_hDlg);
        return NULL;
    }

    CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::readwrite, m_lSync, pInst,
                     m_lTimeout, m_nBatch);
    if (ed.Edit() == IDCANCEL)
    {
        pInst->Release();
        return NULL;
    }

    if(_PutInstance(m_hDlg, m_lGenFlags, WBEM_FLAG_CREATE_ONLY, m_lSync, pInst, m_lTimeout))
        return pInst;
    else
    {
        pInst->Release();
        return NULL;
    }
}


void ShowInstances(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszClass, LONG lSync,
                   CRefCountable* pOwner, LONG lTimeout, ULONG nBatch)
{
    CInstanceListDlg* pDlg = new CInstanceListDlg(hDlg, lGenFlags, lQryFlags, wszClass, lSync,
                                                  FALSE, lTimeout, nBatch);
    pDlg->RunDetached(pOwner);
}

void CMainDlg::GetInstances()
{
    wchar_t ClassName[2560];
    *ClassName = 0;
    LONG lQryFlags = 0;
    INT_PTR nRes = GetClassInfo(m_hDlg, ClassName, 2560, &lQryFlags);
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    CInstanceListDlg* pDlg = new CInstanceListDlg(m_hDlg, m_lGenFlags, lQryFlags, ClassName, m_lSync,
                                                  FALSE, Timeout(), BatchCount());
    pDlg->RunDetached(this);
}

//********************************************************************
class CClassListDlg : public CQueryResultDlg
{
protected:
    BSTR m_strParentClass;

    BOOL CanAdd()		{ return !m_bReadOnly; /* && m_lQryFlags & WBEM_FLAG_SHALLOW; */ }
    IWbemClassObject* AddNewElement();

public:
    CClassListDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, LPWSTR wszParentClass, LONG lSync,
                  BOOL bReadOnly, LONG lTimeout, ULONG nBatch)
        : CQueryResultDlg(hParent, lGenFlags, lQryFlags, TRUE, IDD_QUERY_RESULT_SORTED),
                m_strParentClass(SysAllocString(wszParentClass))
    {
        SetReadOnly(bReadOnly);
        // Pass on invocation method (sync, async..) related settings for use in this
        // enumeration and by any further operations (editing/deleting/etc. of an instance).
        SetCallMethod(lSync);
        SetTimeout(lTimeout);
        SetBatchCount(nBatch);
    }
    ~CClassListDlg()
    {
        SysFreeString(m_strParentClass);
    }
    BOOL Initialize();
};

BOOL CClassListDlg::Initialize()
{
    const TitleSize = 1000;
    char szTitle[TitleSize];
    char szFormat[1024];
    if (m_strParentClass == NULL || wcslen(m_strParentClass) == 0)
    {
        LoadString(GetModuleHandle(NULL), IDS_TOP_LEVEL_CLASSES, szTitle, TitleSize);
    }
    else
    {
        LoadString(GetModuleHandle(NULL), IDS_CHILD_CLASSES_OF, szFormat, 1024);
        sprintf(szTitle, szFormat, m_strParentClass);
    }
    szTitle[TitleSize-1] = '\0';

    if (m_lQryFlags & WBEM_FLAG_DEEP)
    {
        LoadString(GetModuleHandle(NULL), IDS_RECURSIVE_PARENS, szFormat, 1024);
        strncat(szTitle, szFormat, sizeof(szTitle) - strlen(szTitle) - 1);
    }

    SetTitle(szTitle);

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        CHourGlass hg;
        CNotSink* pHandler = new CNotSink(this);
        SetNotify(pHandler);

        HRESULT hres = g_pNamespace->CreateClassEnumAsync(m_strParentClass,
                              m_lGenFlags | m_lQryFlags | WBEM_FLAG_SEND_STATUS,
                              g_Context, GetWrapper());

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }
        pHandler->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateClassEnum(m_strParentClass,
                         m_lGenFlags | m_lQryFlags  | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                         g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }

        // Create sink for use in NextAsync calls.
        if (m_lSync & USE_NEXTASYNC)
        {
            CNotSink* pHandler = new CNotSink(this);        // contructor starts ref count at 1
            SetNotify(pHandler);
            pHandler->Release();
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        SetEnum(pEnum);
        pEnum->Release();
    }

    // Synchronous
    else
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateClassEnum(m_strParentClass,
                         m_lGenFlags | m_lQryFlags  | WBEM_FLAG_FORWARD_ONLY,
                         g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        SetEnum(pEnum,hres);
        pEnum->Release();
    }

    return TRUE;
}

IWbemClassObject* CClassListDlg::AddNewElement()
{
    IWbemClassObject* pClass;
    if(_CreateClass(m_hDlg, m_lGenFlags, m_strParentClass, m_lSync, &pClass, m_lTimeout))
        return pClass;
    else
        return NULL;
}


void ShowClasses(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszParentClass, LONG lSync,
                 CRefCountable* pOwner, LONG lTimeout, ULONG nBatch)
{
    CClassListDlg* pDlg = new CClassListDlg(hDlg, lGenFlags, lQryFlags, wszParentClass,
                                            lSync, FALSE, lTimeout, nBatch);
    pDlg->RunDetached(pOwner);
}


void CMainDlg::GetClasses()
{
    wchar_t Superclass[2048];
    *Superclass = 0;
    LONG lQryFlags = 0;
    INT_PTR nRes = GetSuperclassInfo(m_hDlg, Superclass, 2048, &lQryFlags);
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    CClassListDlg* pDlg = new CClassListDlg(m_hDlg, m_lGenFlags, lQryFlags, Superclass, m_lSync,
                                            FALSE, Timeout(), BatchCount());
    pDlg->RunDetached(this);
}

//***************************************************************************
//
//***************************************************************************
void CMainDlg::OpenNs()
{
    wchar_t ObjPath[2560];
    INT_PTR iRet = GetObjectPath(m_hDlg, ObjPath, 2560);
    if(iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
    {
        MessageBox(IDS_NO_PATH, IDS_ERROR, MB_OK);
        return;
    }

    if (g_pNamespace == 0)
    {
        MessageBox(IDS_NO_INITIAL_CONNECTION, IDS_ERROR, MB_OK);
        return;
    }

    IWbemServices* pNewNs = NULL;
    CBString bsObjPath(ObjPath);

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        MessageBox(IDS_ASYNC_NOT_SUPPORTED, IDS_ERROR, MB_OK);
        return;
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->OpenNamespace(bsObjPath.GetString(),
                                m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, NULL, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(Timeout(), &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::OpenNamespace call
                if (res == WBEM_S_NO_ERROR)
                {
                    res = pCallRes->GetResultServices(0, &pNewNs);    // don't use timeout since object should be available
                }
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->OpenNamespace(bsObjPath.GetString(),
                                m_lGenFlags,
                                g_Context, &pNewNs, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
        return;
    }

    g_pNamespace->Release();
    pNewNs->QueryInterface(IID_IWbemServices, (void **)&g_pNamespace);
    pNewNs->Release();
    SetInterfaceSecurityEx(g_pNamespace, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);

    wcscat(gNameSpace, L"\\");
    wcscat(gNameSpace, bsObjPath.GetString());
    SetDlgItemTextWC(m_hDlg, IDC_NAMESPACE, gNameSpace);

    SysFreeString(g_strNamespace);
    g_strNamespace = SysAllocString(gNameSpace);
}

void CMainDlg::CreateRefresher()
{
    CRefresherDlg* pDlg = new CRefresherDlg(m_hDlg, m_lGenFlags);
    pDlg->RunDetached(NULL);
}

void CMainDlg::EditContext()
{
    g_Context.Edit(m_hDlg);
}

//***************************************************************************
//
//***************************************************************************

void CenterOnScreen(HWND hDlg)
{
    HWND hScreen = GetDesktopWindow();

    RECT rScreen;
    GetClientRect(hScreen, &rScreen);

    RECT rDlg;
    GetWindowRect(hDlg, &rDlg);

    int nX = (rScreen.right - (rDlg.right - rDlg.left))/2;
    int nY = (rScreen.bottom - (rDlg.bottom - rDlg.top))/2;

    MoveWindow(hDlg, nX, nY, rDlg.right - rDlg.left,
        rDlg.bottom - rDlg.top, TRUE);
}


void CMainDlg::ConnectButtons(BOOL b)
{
    EnableWindow(GetDlgItem(IDC_CREATE_CLASS), b);
    EnableWindow(GetDlgItem(IDC_GET_CLASS), b);
    EnableWindow(GetDlgItem(IDC_GET_CLASSES), b);
    EnableWindow(GetDlgItem(IDC_EDIT_CLASS), b);
    EnableWindow(GetDlgItem(IDC_DELETE_CLASS), b);

    EnableWindow(GetDlgItem(IDC_CREATE_INSTANCE), b);
    EnableWindow(GetDlgItem(IDC_GET_INSTANCE), b);
    EnableWindow(GetDlgItem(IDC_GET_INSTANCES), b);
    EnableWindow(GetDlgItem(IDC_EDIT_INSTANCE), b);
    EnableWindow(GetDlgItem(IDC_DELETE_INSTANCE), b);

    EnableWindow(GetDlgItem(IDC_QUERY), b);

///	EnableWindow(GetDlgItem(IDC_ASYNC), TRUE);
///	EnableWindow(GetDlgItem(IDC_SYNC), TRUE);
///	EnableWindow(GetDlgItem(IDC_SEMISYNC), TRUE);
	EnableWindow(GetDlgItem(IDC_ASYNC), b);
	EnableWindow(GetDlgItem(IDC_SYNC), b);
	EnableWindow(GetDlgItem(IDC_SEMISYNC), b);
	EnableWindow(GetDlgItem(IDC_BATCH), b);
	EnableWindow(GetDlgItem(IDC_TIMEOUT), b);
	EnableWindow(GetDlgItem(IDC_BATCH), b && !(m_lSync & ASYNC));
	EnableWindow(GetDlgItem(IDC_TIMEOUT), b && m_lSync & SEMISYNC && !(m_lSync & USE_NEXTASYNC));
	EnableWindow(GetDlgItem(IDC_USE_NEXTASYNC), b && m_lSync & SEMISYNC);

    EnableWindow(GetDlgItem(IDC_USE_AMENDED), b);
    EnableWindow(GetDlgItem(IDC_DIRECT_READ), b);

    EnableWindow(GetDlgItem(IDC_REGISTER), b);
    EnableWindow(GetDlgItem(IDC_VIEW_REG), b);
    EnableWindow(GetDlgItem(IDC_EVENTS), b);
    EnableWindow(GetDlgItem(IDC_EXEC_METHOD), b);
    EnableWindow(GetDlgItem(IDC_OPEN_NS), b);

    EnableWindow(GetDlgItem(IDC_REFRESH), b);
    
	// IWbemServicesEx
/*
	RAID 167868
	bool ex=(b && g_pServicesEx!=NULL);
	EnableWindow(GetDlgItem(IDC_OPEN), ex);
	EnableWindow(GetDlgItem(IDC_ADDOBJECT), ex);
	EnableWindow(GetDlgItem(IDC_DELETEOBJECT), ex);
	EnableWindow(GetDlgItem(IDC_RENAMEOBJECT), ex);
	EnableWindow(GetDlgItem(IDC_GETOBJECTSECURITY), ex);
	EnableWindow(GetDlgItem(IDC_SETOBJECTSECURITY), ex);
*/
}

//////////////////


//////////////////
CQueryResultDlg::CQueryResultDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, BOOL fCanDelete, int tID)
    : CWbemDialog(tID, hParent), m_pHandler(NULL), m_bReadOnly(FALSE), m_fDeletesAllowed(fCanDelete),
            m_pEnum(NULL), m_pWrapper(NULL), m_bComplete(FALSE),
            m_lGenFlags(lGenFlags), m_lQryFlags(lQryFlags),
            m_lTimeout(0), m_nBatch(1),
            m_partial_result(false)
{
    m_szTitle = 0;
    m_nReturnedMax = 0;

    if (tID == IDD_QUERY_RESULT_SORTED)
    {
        m_bSort = TRUE;
    }
    else
    {
        m_bSort = FALSE;
    }
}

void CQueryResultDlg::SetEnum(IEnumWbemClassObject* pEnum, HRESULT hres)
{
    set_partial (hres==WBEM_S_PARTIAL_RESULTS);
    m_pEnum = pEnum;
    if(m_pEnum)
        m_pEnum->AddRef();
    if(m_hDlg)
    {
        PostUserMessage(m_hDlg, 0, 0);      // starts processing of enumeration
    }
}

// This function is called once (via PostMessage) and will loop until the
// synchronous enumeration is complete.  It repeatedly requests batches of
// objects (without a timeout) and adds them to the list.
void CQueryResultDlg::ProcessEnum()
{
    ULONG uIdx;
    IWbemClassObject** aObjects = new IWbemClassObject*[m_nBatch];

    for (uIdx = 0; uIdx < m_nBatch; uIdx++)
    {
        aObjects[uIdx] = NULL;
    }

    ULONG uRet = 0;
    HRESULT hres;

    // Do not use the timeout since the synchronous enumeration was
    // started without WBEM_FLAG_RETURN_IMMEDIATELY.
    while (SUCCEEDED(hres = m_pEnum->Next(WBEM_NO_WAIT, m_nBatch, aObjects, &uRet)))
    {
        for (uIdx = 0; uIdx < uRet; uIdx++)
        {
            if (aObjects[uIdx])
            {
                IWbemClassObject* pObj = aObjects[uIdx];
                AddObject(pObj);
                pObj->Release();
                aObjects[uIdx] = NULL;
            }
        }
        if (uRet)
            SetNumBatchItems(uRet);

        if (hres == WBEM_S_FALSE)
        {
            InvalidateRect(GetDlgItem(IDC_OBJECT_LIST), NULL, FALSE);
            UpdateWindow(GetDlgItem(IDC_OBJECT_LIST));
            break;
        }
    }

    SetComplete(hres, NULL, NULL);
    m_pEnum->Release();
    m_pEnum = NULL;

    delete [] aObjects;
}

// This function is called repeatedly (via PostMessage) until the
// semisync enumeration is complete.  This function adds the objects
// to the list and requests another batch of objects with a timeout.
void CQueryResultDlg::ProcessEnumSemisync()
{
    ULONG uIdx;
    IWbemClassObject** aObjects = new IWbemClassObject*[m_nBatch];

    for (uIdx = 0; uIdx < m_nBatch; uIdx++)
    {
        aObjects[uIdx] = NULL;
    }

    ULONG uRet = 0;
    HRESULT hres = m_pEnum->Next(m_lTimeout, m_nBatch, aObjects, &uRet);
    if (SUCCEEDED(hres))
    {
        for (uIdx = 0; uIdx < uRet; uIdx++)
        {
            if (aObjects[uIdx])
            {
                IWbemClassObject* pObj = aObjects[uIdx];
                AddObject(pObj);
                pObj->Release();
                aObjects[uIdx] = NULL;
            }
        }

        if (uRet)
        {
            SetNumBatchItems(uRet);
            InvalidateRect(GetDlgItem(IDC_OBJECT_LIST), NULL, FALSE);
            UpdateWindow(GetDlgItem(IDC_OBJECT_LIST));
        }
    }

    if (hres == WBEM_S_NO_ERROR || hres == WBEM_S_TIMEDOUT)
    {
        PostUserMessage(m_hDlg, 0, 0);      // continues processing of enumeration
    }
    else
    {
        // Stop if an error or if WBEM_S_FALSE is returned.
        // WBEM_S_FALSE indicates that the enumeration is complete.
        SetComplete(hres, NULL, NULL);
        m_pEnum->Release();
        m_pEnum = NULL;
    }

    delete [] aObjects;
}

// This function is called repeatedly (via PostMessage) until the semisync
// enumeration using NextAsync is complete.  This function simply requests
// another (or the first) batch of objects using the same sink.
void CQueryResultDlg::SemisyncNextAsync()
{
    if (m_pEnum)
    {
        HRESULT hres = m_pEnum->NextAsync(m_nBatch, m_pHandler);

        // If WBEM_S_FALSE or error then we are done with the enumerator.
        // For NextAsync, SetStatus is called after every Indicate so that
        // we must call SetComplete here.
        if (hres != WBEM_S_NO_ERROR)
        {
            SetComplete(hres, NULL, NULL);
            m_pEnum->Release();
            m_pEnum = NULL;
        }
    }
}

void CQueryResultDlg::SetNotify(CNotSink* pNotify)
{
    m_pHandler = pNotify;
    if (m_pHandler)
        m_pHandler->AddRef();

    CUnsecWrap Wrap(m_pHandler);
    m_pWrapper = (IWbemObjectSink*)Wrap;
    if(m_pWrapper)
        m_pWrapper->AddRef();
}

CQueryResultDlg::~CQueryResultDlg()
{
    if (m_szTitle)
        delete [] m_szTitle;

    if(m_pHandler)
    {
        m_pHandler->ResetViewer();

        if(!m_bComplete)
        {
            CHourGlass hg;
            g_pNamespace->CancelAsyncCall(m_pWrapper);
        }
        m_pHandler->Release();
    }

    if(m_pWrapper)
        m_pWrapper->Release();
    if(m_pEnum)
        m_pEnum->Release();

    for(int i = 0; i < m_InternalArray.Size(); i++)
    {
        // Check the pointer
        if ( NULL != m_InternalArray[i] )
        {
            ((IWbemClassObject*)m_InternalArray[i])->Release();
        }
    }
}

void CQueryResultDlg::SetTitle(char* szTitle)
{
    m_szTitle = new char[strlen(szTitle)+2];
    strcpy(m_szTitle, szTitle);
    unsigned char* pc = (unsigned char*)m_szTitle;
    while(*pc)
    {
        if(*pc < 32) *pc = 32;
        pc = _mbsinc(pc);
    }

    if(m_hDlg)
    {
        SetDlgItemText(IDC_REQUEST, m_szTitle);
    }
}

void CQueryResultDlg::PostObject(IWbemClassObject* pObject)
{
    if(m_hDlg)
    {
        pObject->AddRef();
        PostUserMessage(m_hDlg, 1, LPARAM(pObject));
    }
    else
    {
        AddObject(pObject);
    }
}

void CQueryResultDlg::AddObject(IWbemClassObject* pObject)
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    if(pObject == NULL)
        return;
    pObject->AddRef();
    m_InternalArray.Add(pObject);

    WString wsText;
    MakeListEntry(pObject, wsText);
    long len = wsText.Length()*2+20;
    char* szTemp = new char[len];
    wcstombs(szTemp, LPWSTR(wsText), len);
    SendMessage(hList, LB_ADDSTRING, 0, LPARAM(szTemp));
    delete [] szTemp;
    SetNumItems(SendMessage(hList, LB_GETCOUNT, 0, 0));
}

void CQueryResultDlg::MakeListEntry(IWbemClassObject* pObj, WString& ListEntry)
{
    ListEntry = L"";
	HRESULT hres;
    if ( NULL != pObj )
    {
        VARIANT v;
        VariantInit(&v);
        pObj->Get(L"__GENUS", 0, &v, NULL, NULL);

        if (V_I4(&v) == 1)
        {
            // Class def.
            VariantClear(&v);

            hres = pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
			if(SUCCEEDED(hres))
				ListEntry += V_BSTR(&v);
			else
				ListEntry += L"Unknown class";
            VariantClear(&v);

            ListEntry += L"\t(";

            hres = pObj->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
            if (SUCCEEDED(hres) && V_VT(&v) == VT_BSTR)
                ListEntry += V_BSTR(&v);
            VariantClear(&v);

            ListEntry += L')';
        }
        else
        {
            // Instance
            VariantClear(&v);

            hres = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
            if(FAILED(hres) || V_VT(&v) == VT_NULL)
            {
                hres = pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
                if(SUCCEEDED(hres))
					ListEntry += V_BSTR(&v);
                ListEntry += L"=<no key>";
            }
            else
            {
                ListEntry += V_BSTR(&v);
            }
            VariantClear(&v);
        }

    }   // IF NULL != pObj
    else
    {
        ListEntry = L"NULL Object";
    }

}

void CQueryResultDlg::PostCount(long nCount)
{
    if(m_hDlg)
    {
        PostUserMessage(m_hDlg, 3, LPARAM(nCount));
    }
}

void CQueryResultDlg::RefreshItem(int nItem)
{
    IWbemClassObject* pObj = (IWbemClassObject*)m_InternalArray.GetAt(nItem);
    WString wsListEntry;
    MakeListEntry(pObj, wsListEntry);

    // Convert to ANSI (Win95 requires this)
    char* szTemp = new char[wsListEntry.Length()*2+10];
    wcstombs(szTemp, LPWSTR(wsListEntry), wsListEntry.Length()+1);
    szTemp[wsListEntry.Length()] = '\0';
    SendMessage(GetDlgItem(IDC_OBJECT_LIST), LB_DELETESTRING, nItem, 0);
    SendMessage(GetDlgItem(IDC_OBJECT_LIST), LB_INSERTSTRING, nItem,
        LPARAM(szTemp));
    delete [] szTemp;
}

void CQueryResultDlg::RunDetached(CRefCountable* pOwner)
{
    SetDeleteOnClose();
    SetOwner(pOwner);
    Create(FALSE);
    if(!Initialize())
    {
        PostMessage(m_hDlg, WM_CLOSE, 0, 0);
    }
}

void CQueryResultDlg::PostComplete(long lParam, BSTR strParam,
                                    IWbemClassObject* pObjParam)
{
    if(m_hDlg)
    {
        if (m_lSync & SEMISYNC)
        {
            // For semisync using NextAsync, SetStatus indicates the batch is
            // complete so we continue with the sink and another NextAsync call.
            PostUserMessage(m_hDlg, 0, 0);
        }
        else
        {
            // For async, the final SetStatus has been called so we are done
            // with the sink.
            CStatus* pStatus = new CStatus(lParam, strParam, pObjParam);
            PostUserMessage(m_hDlg, 2, (LPARAM)pStatus);
        }
    }
    else
    {
        SetComplete(lParam, strParam, pObjParam);
    }
}

void CQueryResultDlg::SetComplete(HRESULT hres, BSTR strParam,
                                  IWbemClassObject* pErrorObj)
{
    if(m_bComplete)
        return;
    set_partial(hres==WBEM_S_PARTIAL_RESULTS);
    m_bComplete = TRUE;

    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg, pErrorObj);
        PostMessage(m_hDlg, WM_CLOSE, 0, 0);
        return;
    }

    if(m_pHandler)
    {
        m_pHandler->Release();
        m_pHandler = NULL;
    }
    if(m_hDlg)
    {
        char szBuffer[1024]="";
        LoadString(GetModuleHandle(NULL), m_partial_result==true?IDS_PARTIALRESULTS:IDS_DONE, szBuffer, 1024);
        SetDlgItemText(IDC_STATUS, szBuffer);
        EnableWindow(GetDlgItem(IDC_DELETE), CanDelete());
        EnableWindow(GetDlgItem(IDC_ADD), CanAdd());
        if (m_bSort)
        {
            qsort((void*)m_InternalArray.GetArrayPtr(), m_InternalArray.Size(), sizeof(void*), CmpFunc);
        }
    }
}

BOOL CQueryResultDlg::OnInitDialog()
{
    CenterOnParent();
    static LONG Tabs[] = { 80, 120, 170 };
    int TabCount = 3;

    SendMessage(GetDlgItem(IDC_OBJECT_LIST), LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);
    SendMessage(GetDlgItem(IDC_OBJECT_LIST), LB_SETHORIZONTALEXTENT,
        10000, 0);

    IWbemClassObject *pObj;
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);
    WString wsListEntry;

    SetDlgItemText(IDC_REQUEST, m_szTitle);
    if(m_bComplete)
    {
        char szBuffer[1024];
        LoadString(GetModuleHandle(NULL), IDS_DONE, szBuffer, 1024);
        SetDlgItemText(IDC_STATUS, szBuffer);
    }
    else
    {
        char szBuffer[1024];
        LoadString(GetModuleHandle(NULL), IDS_IN_PROGRESS, szBuffer, 1024);
        SetDlgItemText(IDC_STATUS, szBuffer);
    }

    EnableWindow(GetDlgItem(IDC_ADD), CanAdd());
    EnableWindow(GetDlgItem(IDC_DELETE), CanDelete());
    for(int i = 0; i < m_InternalArray.Size(); i++)
    {
        pObj = (IWbemClassObject*)m_InternalArray.GetAt(i);
        MakeListEntry(pObj, wsListEntry);

        // Convert to ANSI (Win95 requires this)
        char* szTemp = new char[wsListEntry.Length()*2+10];
        wcstombs(szTemp, LPWSTR(wsListEntry), wsListEntry.Length()+1);
        SendMessage(hList, LB_ADDSTRING, 0, LPARAM(szTemp));
        delete [] szTemp;
    }

    if(m_pEnum)
    {
        PostUserMessage(m_hDlg, 0, 0);
    }

    SetNumItems(m_InternalArray.Size());

    if(m_bReadOnly)
    {
        EnableWindow(GetDlgItem(IDC_DELETE), FALSE);
        EnableWindow(GetDlgItem(IDC_ADD), FALSE);
    }

    return TRUE;
}

// Total number of items
void CQueryResultDlg::SetNumItems(LRESULT nNum)
{
    char szBuffer[512];
    char szFormat[500];
    LoadString(GetModuleHandle(NULL), IDS_NUM_OBJECTS_FORMAT, szFormat, 500);
    sprintf(szBuffer, szFormat, nNum);
    SetWindowText(GetDlgItem(IDC_NUM_OBJECTS), szBuffer);
}

// Number returned in most recent sink Indicate or enum Next.
void CQueryResultDlg::SetNumBatchItems(ULONG nNum)
{
    // Show only maximum returned batch size.
    if (nNum > m_nReturnedMax)
    {
        char szBuffer[512];
        char szFormat[500];
        LoadString(GetModuleHandle(NULL), IDS_NUM_BATCH_FORMAT, szFormat, 500);
        sprintf(szBuffer, szFormat, nNum);
        SetWindowText(GetDlgItem(IDC_NUM_BATCH), szBuffer);
        m_nReturnedMax = nNum;
    }
}

BOOL CQueryResultDlg::ViewListElement(LRESULT nSel)
{
    IWbemClassObject *pObj = 0;

    pObj = (IWbemClassObject*)m_InternalArray.GetAt((DWORD)nSel);

    if ( NULL != pObj )
    {
        CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags,
                m_bReadOnly ? CObjectEditor::readonly : CObjectEditor::readwrite,
                m_lSync, pObj, m_lTimeout, m_nBatch);
        ped->RunDetached(m_pOwner);
    }

    return TRUE;
}

BOOL CQueryResultDlg::OnDoubleClick(int nID)
{
    if(nID != IDC_OBJECT_LIST) return FALSE;
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    LRESULT nSel = SendMessage(hList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return TRUE;

    ViewListElement(nSel);
    SendMessage(hList, LB_SETCURSEL, nSel, 0);
    return TRUE;
}

BOOL CQueryResultDlg::OnUser(WPARAM wParam, LPARAM lParam)
{
    if(wParam == 0)
    {
        if (m_lSync & SEMISYNC)
        {
            if (m_lSync & USE_NEXTASYNC)
                SemisyncNextAsync();
            else
                ProcessEnumSemisync();
        }
        else    // synchronous
        {
            ProcessEnum();
        }
        return TRUE;
    }
    else if(wParam == 1)
    {
        IWbemClassObject* pObj = (IWbemClassObject*)lParam;
        AddObject(pObj);
        pObj->Release();
        return TRUE;
    }
    else if(wParam == 2)
    {
        CStatus* pStatus = (CStatus*)lParam;
        SetComplete(pStatus->m_hres, pStatus->m_str, pStatus->m_pObj);
        delete pStatus;
        return TRUE;
    }
    else if(wParam == 3)
    {
        SetNumBatchItems(ULONG(lParam));
        return TRUE;
    }
    else return FALSE;
}

BOOL CQueryResultDlg::OnCommand(WORD wCode, WORD nID)
{
    if(wCode == 0xFFFF && nID == 0xFFFF)
    {
        if (m_lSync & SEMISYNC)
        {
            if (m_lSync & USE_NEXTASYNC)
                SemisyncNextAsync();
            else
                ProcessEnumSemisync();
        }
        else    // synchronous
        {
            ProcessEnum();
        }
        return TRUE;
    }
    else if(nID == IDC_DELETE)
    {
        OnDelete();
        return TRUE;
    }
    else if(nID == IDC_ADD)
    {
        OnAdd();
        return TRUE;
    }
    else if(nID == IDC_COPY_SEL)
    {
        OnCopy();
        return TRUE;
    }

    return FALSE;
}

void CQueryResultDlg::OnDelete()
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);
    LRESULT nSel = SendMessage(hList, LB_GETCURSEL, 0, 0);
    if (nSel == LB_ERR)
        return;

    if(DeleteListElement(nSel))
    {
        SendMessage(hList, LB_DELETESTRING, nSel, 0);

        SetNumItems(SendMessage(hList, LB_GETCOUNT, 0, 0));

        IWbemClassObject* pObj = (IWbemClassObject*)m_InternalArray.GetAt((DWORD)nSel);
        m_InternalArray.RemoveAt((DWORD)nSel);

        // Verify the pointer
        if ( NULL != pObj )
        {
            pObj->Release();
        }
    }
}


BOOL CQueryResultDlg::DeleteListElement(LRESULT nSel)
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    IWbemClassObject *pObj = 0;

    pObj = (IWbemClassObject*)m_InternalArray.GetAt((DWORD)nSel);

    VARIANT vPath;
    VariantInit(&vPath);
    pObj->Get(L"__RELPATH", 0, &vPath, NULL, NULL);

    VARIANT vGenus;
    VariantInit(&vGenus);
    pObj->Get(L"__GENUS", 0, &vGenus, NULL, NULL);

    HRESULT hres;
    if(V_I4(&vGenus) == WBEM_GENUS_CLASS)
    {
        CHourGlass hg;
        hres = g_pNamespace->DeleteClass(V_BSTR(&vPath), m_lGenFlags, g_Context, NULL);
    }
    else
    {
        CHourGlass hg;
        hres = g_pNamespace->DeleteInstance(V_BSTR(&vPath), m_lGenFlags, g_Context, NULL);
    }

    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
        return FALSE;
    }

    return TRUE;
}

void CQueryResultDlg::OnAdd()
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);
    IWbemClassObject* pNewObj;

    pNewObj = AddNewElement();
    if(pNewObj)
    {
        // Search for the object with the same PATH
        // ========================================

        VARIANT vNewPath;
        HRESULT hres = pNewObj->Get(L"__RELPATH", 0, &vNewPath, NULL, NULL);
        if(SUCCEEDED(hres) && V_VT(&vNewPath) == VT_BSTR)
        {
            for(int i = 0; i < m_InternalArray.Size(); i++)
            {
                IWbemClassObject* pThis = (IWbemClassObject*)m_InternalArray[i];

                // Check for a NULL pointer
                if ( NULL != pThis )
                {
                    VARIANT vThisPath;
                    hres = pThis->Get(L"__RELPATH", 0, &vThisPath, NULL, NULL);
                    if(SUCCEEDED(hres) && V_VT(&vThisPath) == VT_BSTR &&
                        !wbem_wcsicmp(V_BSTR(&vThisPath), V_BSTR(&vNewPath)))
                    {
                        // Found a duplicate
                        // =================

                        pThis->Release();
                        m_InternalArray.SetAt(i, pNewObj);
                        RefreshItem(i);
                        return;
                    }

                }
            }
        }

        AddObject(pNewObj);
        pNewObj->Release();

        if (m_bSort)
        {
            qsort((void*)m_InternalArray.GetArrayPtr(), m_InternalArray.Size(), sizeof(void*), CmpFunc);
        }
    }
}

// TODO: WM_COPY doesn't work for listbox so we need to code
// OpenClipboard & SetClipboardData.  Also need way to copy all
// items to clipboard.  Buttons changed to invisible for now.
void CQueryResultDlg::OnCopy()
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);
    SendMessage(hList, WM_COPY, 0, 0);
}

IWbemClassObject* CQueryResultDlg::AddNewElement()
{
    return NULL;
}


////////////////////////////

char *CQueryDlg::m_szLastQueryType = NULL;
char *CQueryDlg::m_szLastQuery = NULL;

BOOL CQueryDlg::OnInitDialog()
{
    AddStringToCombo(IDC_QUERY_TYPE, "WQL");

    // Initialize Query Type

    if(NULL == m_szLastQueryType)
    {
        m_szLastQueryType = new char[8];
        strcpy(m_szLastQueryType, "WQL");
    }

    // Initialize Query String

    if (NULL == m_szLastQuery)
    {
        m_szLastQuery = new char[1];
        *m_szLastQuery = 0;
    }

    LRESULT uRes = SendMessage(GetDlgItem(IDC_QUERY_TYPE), CB_SELECTSTRING,
                    WPARAM(-1), LPARAM(m_szLastQueryType));

    SetDlgItemText(IDC_QUERY_STRING, m_szLastQuery);
    SendMessage(GetDlgItem(IDC_QUERY_STRING), EM_SETSEL, 0, -1);
    EnableWindow(GetDlgItem(IDC_PROTOTYPE), NULL != m_plQryFlags);

    return TRUE;
}

BOOL CQueryDlg::Verify()
{
    UINT uRes = 0;
    UINT uStringSize = 0;

    // Query String Processing

    if (*m_pwszQueryString)
        delete [] *m_pwszQueryString;

    // Determine the required size of the buffer
    uRes = GetDlgItemTextX(IDC_QUERY_STRING, *m_pwszQueryString, uStringSize);
    if(0 == uRes)
    {
        MessageBox(IDS_MUST_SPECIFY_QUERY, IDS_ERROR,
            MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Create the buffer
    uStringSize = uRes + 10;
    *m_pwszQueryString = new wchar_t[uStringSize];

    // Fetch the text
    uRes = GetDlgItemTextX(IDC_QUERY_STRING, *m_pwszQueryString, uStringSize);
    if(wcslen(*m_pwszQueryString) == 0)
    {
        MessageBox(IDS_MUST_SPECIFY_QUERY, IDS_ERROR,
            MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Set up last query member
    if (m_szLastQuery)
        delete [] m_szLastQuery;
    m_szLastQuery = new char[uStringSize];
    wcstombs(m_szLastQuery, *m_pwszQueryString, uStringSize);
    m_szLastQuery[uStringSize - 1] = '\0';

    // Query Type Processing

    if (*m_pwszQueryType)
        delete [] *m_pwszQueryType;
    uStringSize = 0;

    // Determine the required size of the buffer
    uRes = GetDlgItemTextX(IDC_QUERY_TYPE, *m_pwszQueryType, uStringSize);
    if(0 == uRes)
    {
        MessageBox(IDS_MUST_SPECIFY_QUERY_LANGUAGE, IDS_ERROR,
            MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Create the buffer
    uStringSize = uRes + 10;
    *m_pwszQueryType = new wchar_t[uStringSize];

    // Fetch the text
    uRes = GetDlgItemTextX(IDC_QUERY_TYPE, *m_pwszQueryType, uStringSize);
    if(wcslen(*m_pwszQueryType) == 0)
    {
        MessageBox(IDS_MUST_SPECIFY_QUERY_LANGUAGE, IDS_ERROR,
            MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Set up last query type
    if (m_szLastQueryType)
        delete [] m_szLastQueryType;
    m_szLastQueryType = new char[uStringSize];
    wcstombs(m_szLastQueryType, *m_pwszQueryType, uStringSize);
    m_szLastQueryType[uStringSize - 1] = '\0';

    if(m_plQryFlags)
    {
        if(GetCheck(IDC_PROTOTYPE) == BST_CHECKED)
            *m_plQryFlags |= WBEM_FLAG_PROTOTYPE;
        else
            *m_plQryFlags &= ~WBEM_FLAG_PROTOTYPE;
    }

    return TRUE;
}

// ****************************************************************************

BOOL _ExecQuery(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszQuery, LPWSTR wszLanguage,
                LONG lSync, CQueryResultDlg* pRes, char* pWindowTitle, LONG lTimeout, ULONG nBatch)
{
    CBString bsQueryType(wszLanguage);
    CBString bsQueryStr(wszQuery);

    if(pWindowTitle)
        pRes->SetTitle(pWindowTitle);

    HRESULT hres;

    // Asynchronous
    if(lSync & ASYNC)
    {
        CNotSink* pHandler = new CNotSink(pRes);        // constructor starts ref count at 1
        pRes->SetNotify(pHandler);

        {
            CHourGlass hg;
            hres = g_pNamespace->ExecQueryAsync(bsQueryType.GetString(), bsQueryStr.GetString(),
                        lGenFlags | lQryFlags | WBEM_FLAG_SEND_STATUS,
                        g_Context, pRes->GetWrapper());
        }
        pHandler->Release();

        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IEnumWbemClassObject* pEnum = NULL;

        {
            CHourGlass hg;
            hres = g_pNamespace->ExecQuery(bsQueryType.GetString(), bsQueryStr.GetString(),
                       lGenFlags | lQryFlags | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                       g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }

        // Create sink for use in NextAsync calls.
        if (lSync & USE_NEXTASYNC)
        {
            CNotSink* pHandler = new CNotSink(pRes);        // contructor starts ref count at 1
            pRes->SetNotify(pHandler);
            pHandler->Release();
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        pRes->SetEnum(pEnum);
        pEnum->Release();
    }

    // Synchronous
    else
    {
        IEnumWbemClassObject* pEnum = NULL;
        {
            CHourGlass hg;
            hres = g_pNamespace->ExecQuery(bsQueryType.GetString(), bsQueryStr.GetString(),
                       lGenFlags | lQryFlags  | WBEM_FLAG_FORWARD_ONLY,
                       g_Context, &pEnum);
        }
        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        pRes->SetEnum(pEnum,hres);
        pEnum->Release();
    }

    return TRUE;
}

void CMainDlg::ExecQuery()
{
    wchar_t *pQueryStr = 0;
    wchar_t *pQueryType = 0;
    LONG lQryFlags = 0;

    CQueryDlg QD(m_hDlg, &lQryFlags, &pQueryStr, &pQueryType);
    INT_PTR nRes = QD.Run();

    if ((nRes == IDCANCEL) || (nRes == 0) || (!pQueryStr) || (!pQueryType))
        return;

    // If here, we are ready to execute the query.
    // ===========================================

    CQueryResultDlg* pResDlg = new CQueryResultDlg(m_hDlg, m_lGenFlags, lQryFlags);
    // Pass on invocation method (sync, async..) and related settings for this
    // query and by any further operations (editing/deleting/etc. of an instance).
    pResDlg->SetCallMethod(m_lSync);
    pResDlg->SetTimeout(Timeout());
    pResDlg->SetBatchCount(BatchCount());

    wchar_t szDest[512];
	szDest[511] = L'\0';
    char szTitle[1000];
    sprintf(szTitle, "%S: %S", pQueryType, wcsncpy(szDest, pQueryStr, 511));

    if (_ExecQuery(m_hDlg, m_lGenFlags, lQryFlags, pQueryStr, pQueryType, m_lSync,
                  pResDlg, szTitle, Timeout(), BatchCount()))
    {
        pResDlg->RunDetached(this);
    }
    else
    {
        delete pResDlg;
    }

    delete [] pQueryStr;
    delete [] pQueryType;
}

// ****************************************************************************

BOOL _ExecNotificationQuery(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszQuery,
                            LPWSTR wszLanguage, LONG lSync, CQueryResultDlg* pRes,
                            char* pWindowTitle, LONG lTimeout, ULONG nBatch)
{
    CBString bsQueryType(wszLanguage);
    CBString bsQueryStr(wszQuery);

    if(pWindowTitle)
        pRes->SetTitle(pWindowTitle);

    HRESULT hres;

    // Asynchronous
    if(lSync & ASYNC)
    {
        CNotSink* pHandler = new CNotSink(pRes);        // constructor starts ref count at 1
        pRes->SetNotify(pHandler);

        {
            CHourGlass hg;
            hres = g_pNamespace->ExecNotificationQueryAsync(bsQueryType.GetString(),
                        bsQueryStr.GetString(),
                        lGenFlags | lQryFlags,
                        g_Context, pRes->GetWrapper());
        }
        pHandler->Release();

        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IEnumWbemClassObject* pEnum = NULL;

		{
            CHourGlass hg;
            hres = g_pNamespace->ExecNotificationQuery(bsQueryType.GetString(), bsQueryStr.GetString(),
                       lGenFlags | lQryFlags | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                       g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }

        // Create sink for use in NextAsync calls.
        if (lSync & USE_NEXTASYNC)
        {
            CNotSink* pHandler = new CNotSink(pRes);        // contructor starts ref count at 1
            pRes->SetNotify(pHandler);
            pHandler->Release();
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        pRes->SetEnum(pEnum);
        pEnum->Release();
    }

    // Synchronous
    else
    {
        // Note, this call should fail with WBEM_E_INVALID_PARAMETER because synchronous invocation
        // isn't supported for ExecNotificationQuery due to the continuous nature of events.
        IEnumWbemClassObject* pEnum = NULL;
        {
            CHourGlass hg;
            hres = g_pNamespace->ExecNotificationQuery(bsQueryType.GetString(), bsQueryStr.GetString(),
                       lGenFlags | lQryFlags  | WBEM_FLAG_FORWARD_ONLY,
                       g_Context, &pEnum);
        }
        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        pRes->SetEnum(pEnum,hres);
        pEnum->Release();
    }

    return TRUE;
}

void CMainDlg::ExecNotificationQuery()
{
    // Does not allow multiple semisync notification query dlg
    // ========================================================

	if ( m_fNotificationQueryResultDlg && SEMISYNC == m_lSync )
    {
        MessageBox(IDS_MULTIPLE_SEMISYNC_NOTIFICATION_QUERY_DLG_MSG, IDS_ERROR, MB_OK | MB_ICONHAND);
        return;
    }
    
    wchar_t *pQueryStr = 0;
    wchar_t *pQueryType = 0;
    LONG lQryFlags = 0;

    CQueryDlg QD(m_hDlg, &lQryFlags, &pQueryStr, &pQueryType);
    INT_PTR nRes = QD.Run();

    if ((nRes == IDCANCEL) || (nRes == 0) || (!pQueryStr) || (!pQueryType))
        return;

    // If here, we are ready to execute the query.
    // ===========================================

    CNotificationQueryResultDlg* pResDlg = new CNotificationQueryResultDlg(m_hDlg, m_lGenFlags, lQryFlags, m_lSync );
    // Pass on invocation method (sync, async..) and related settings for this
    // query and by any further operations (editing/deleting/etc. of an instance).

    pResDlg->SetCallMethod(m_lSync);
    pResDlg->SetTimeout(Timeout());
    pResDlg->SetBatchCount(BatchCount());

    wchar_t szDest[512];
	szDest[511] = L'\0';
    char szTitle[1000];
    sprintf(szTitle, "%S: %S", pQueryType, wcsncpy(szDest, pQueryStr, 511));

    if(lQryFlags & WBEM_FLAG_PROTOTYPE)
        lQryFlags = (lQryFlags & ~WBEM_FLAG_PROTOTYPE) | WBEM_FLAG_MONITOR;

    if (_ExecNotificationQuery(m_hDlg, m_lGenFlags, lQryFlags, pQueryStr, pQueryType,
                               m_lSync, pResDlg, szTitle, Timeout(), BatchCount()))
    {
        pResDlg->RunDetached(this);
    }
    else
    {
        delete pResDlg;
    }

    delete [] pQueryStr;
    delete [] pQueryType;
}

// ****************************************************************************

void CMainDlg::ExecMethod()
{
    CMethodDlg * pDlg = new CMethodDlg(m_hDlg, m_lGenFlags, m_lSync, Timeout());
    pDlg->RunDetached(this);
}



////////////////////////////////////////////////////////////////////////
//

class CSuperclassInfoDlg : public CWbemDialog
{
protected:
    LPWSTR m_wszSuperclass;
    long m_lMaxLen;
    LONG* m_plQryFlags;
    BOOL m_bIsInstance;
public:
    CSuperclassInfoDlg(HWND hParent, LPWSTR wszClass, long lMaxLen, LONG* plQryFlags)
        : m_wszSuperclass(wszClass), m_lMaxLen(lMaxLen), m_plQryFlags(plQryFlags),
            m_bIsInstance(FALSE), CWbemDialog(IDD_PARENTINFO, hParent)
    {}
    void SetIsInstance() {m_bIsInstance = TRUE;}

protected:
    BOOL OnInitDialog();
    BOOL Verify();
};

class CRenameDlg : public CWbemDialog
{
protected:
    LPWSTR m_wszOld;
    long m_lMaxOldLen;
    LPWSTR m_wszNew;
    long m_lMaxNewLen;
public:
    CRenameDlg(HWND hParent, LPWSTR wszOld, long lMaxOldLen, LPWSTR wszNew, long lMaxNewLen)
        : m_wszOld(wszOld), m_lMaxOldLen(lMaxOldLen), m_wszNew(wszNew), m_lMaxNewLen(lMaxNewLen),
            CWbemDialog(IDD_RENAMEDIALOG, hParent)
    {}

protected:
    BOOL OnInitDialog(){return TRUE;};
    BOOL Verify();
};
BOOL CRenameDlg::Verify()
{
    *m_wszOld = 0;
    GetDlgItemTextX(IDC_EDITOLD, m_wszOld, m_lMaxOldLen);
    *m_wszNew = 0;
    GetDlgItemTextX(IDC_EDITNEW, m_wszNew, m_lMaxNewLen);
    return TRUE;
}

BOOL CSuperclassInfoDlg::OnInitDialog()
{
    char szFormat[1024];
    SetCheck(IDC_IMMEDIATE_SUBCLASSES, BST_CHECKED);
    if(m_bIsInstance)
    {
        LoadString(GetModuleHandle(NULL), IDS_CLASS_INFO, szFormat, 1024);
        SetWindowText(m_hDlg, szFormat);
    }

    return TRUE;
}

BOOL CSuperclassInfoDlg::Verify()
{
    if (GetCheck(IDC_IMMEDIATE_SUBCLASSES) == BST_CHECKED)
        *m_plQryFlags = WBEM_FLAG_SHALLOW;
    else
        *m_plQryFlags = WBEM_FLAG_DEEP;

    *m_wszSuperclass = 0;
    GetDlgItemTextX(IDC_SUPERCLASS, m_wszSuperclass, m_lMaxLen);
    return TRUE;
}

BOOL CCreateInstanceDlg::OnInitDialog()
{
    char szFormat[1024];
    SetCheck(IDC_USE_CLASSOBJ, BST_CHECKED);
    return TRUE;
}

BOOL CCreateInstanceDlg::Verify()
{
    if (GetCheck(IDC_USE_CLASSOBJ) == BST_CHECKED)
        *m_plQryFlags = 1;
    else
        *m_plQryFlags = 0;

    *m_wszClass = 0;
    GetDlgItemTextX(IDC_SUPERCLASS, m_wszClass, m_lMaxLen);
    return TRUE;
}

INT_PTR GetSuperclassInfo(HWND hDlg, LPWSTR pClass, LONG lMaxBuf, LONG* plQryFlags)
{
    CSuperclassInfoDlg InfoDlg(hDlg, pClass, lMaxBuf, plQryFlags);
    return InfoDlg.Run();
}

INT_PTR GetClassInfo(HWND hDlg, LPWSTR pClass, LONG lMaxBuf, LONG* plQryFlags)
{
    CSuperclassInfoDlg InfoDlg(hDlg, pClass, lMaxBuf, plQryFlags);
    InfoDlg.SetIsInstance();
    return InfoDlg.Run();
}

class CContextValueDlg : public CWbemDialog
{
protected:
    BSTR* m_pstrName;
    VARIANT* m_pvValue;
    BOOL m_bNew;

public:
    CContextValueDlg(HWND hParent, BSTR* pstrName, VARIANT* pvValue, BOOL bNew)
        : CWbemDialog(IDD_CONTEXT_PROPERTY, hParent), m_pstrName(pstrName),
        m_pvValue(pvValue), m_bNew(bNew)
    {}

    BOOL OnInitDialog();
    BOOL Verify();

    void Refresh();
};

BOOL CContextValueDlg::OnInitDialog()
{
    // Populate the combo box with the valid prop types
    // ================================================

    AddStringToCombo(IDC_TYPE_LIST, "CIM_STRING");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_UINT8");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_SINT16");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_SINT32");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_REAL32");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_REAL64");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_BOOLEAN");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_OBJECT");

    if(!m_bNew)
        EnableWindow(GetDlgItem(IDC_PROPNAME), FALSE);

    if(*m_pstrName)
    {
        SetDlgItemTextX(IDC_PROPNAME, *m_pstrName);
    }

    if(V_VT(m_pvValue) != VT_EMPTY)
    {
        LPSTR pTypeStr = TypeToString(V_VT(m_pvValue) & ~VT_ARRAY);
        SendMessage(GetDlgItem(IDC_TYPE_LIST), CB_SELECTSTRING, WPARAM(-1),
            LPARAM(pTypeStr));
        if(V_VT(m_pvValue) & VT_ARRAY)
            SetCheck(IDC_ARRAY, BST_CHECKED);

        CVar v;
        v.SetVariant(m_pvValue);
        LPSTR szValue = ValueToNewString(&v);
        SetDlgItemText(IDC_VALUE, szValue);
		delete [] szValue;
    }
    else
    {
        SendMessage(GetDlgItem(IDC_TYPE_LIST), CB_SELECTSTRING, WPARAM(-1),
            LPARAM("VT_NULL"));
    }

    return TRUE;
}

BOOL CContextValueDlg::Verify()
{
    WCHAR wszName[1024];
    GetDlgItemTextX(IDC_PROPNAME, wszName, 1024);
    if(*wszName == 0)
    {
        MessageBox(IDS_NO_PROPERTY_NAME, IDS_ERROR, MB_OK);
        return FALSE;
    }

    StripTrailingWs(wszName);

    LPSTR szType = GetCBCurSelString(IDC_TYPE_LIST);
    int nType = StringToType(szType);
    if(nType == VT_NULL)
    {
        MessageBox(IDS_INVALID_PROPERTY_TYPE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    if(GetCheck(IDC_ARRAY) == BST_CHECKED)
    {
        nType |= VT_ARRAY;
    }

    CHAR szValue[1024];
    UINT uRes = GetDlgItemTextA(m_hDlg, IDC_VALUE, szValue, 1024);
    CVar* pVal = StringToValue(szValue, nType);
    if(pVal == NULL)
    {
        MessageBox(IDS_INVALID_PROPERTY_VALUE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    // All checked out. Store and succeed
    // ==================================

    SysFreeString(*m_pstrName);
    *m_pstrName = SysAllocString(wszName);
    VariantClear(m_pvValue);
    pVal->FillVariant(m_pvValue);

    return TRUE;
}

class CContextDlg : public CWbemDialog
{
    CContext* m_pContext;
    CContext m_Context;
public:
    CContextDlg(HWND hParent, CContext* pContext)
        : CWbemDialog(IDD_CONTEXT_EDITOR, hParent), m_pContext(pContext)
    {}
protected:
    BOOL OnInitDialog();
    BOOL Verify();
    BOOL OnCommand(WORD wCode, WORD wID);
    BOOL OnDoubleClick(int nId);

    void EnableControls(BOOL bEnable);
    void Refresh();
    void OnUse();
    void OnAdd();
    void OnDelete();
    void OnEdit();

    BSTR GetCurSelEntryName();
    LPSTR MakeListEntry(LPCWSTR wszName, VARIANT& vValue);
};

CContext::CContext() : m_bNull(TRUE), m_pContext(NULL)
{
}

BOOL CContext::SetNullness(BOOL bNull)
{
    m_bNull = bNull;
    if(!m_bNull && m_pContext == NULL)
    {
        HRESULT hres = CoCreateInstance(CLSID_WbemContext, NULL,
            CLSCTX_INPROC_SERVER, IID_IWbemContext, (void**)&m_pContext);
        return SUCCEEDED(hres);
    }
    else return TRUE;
}

CContext::~CContext()
{
    if(m_pContext)
        m_pContext->Release();
}

void CContext::Clear()
{
    if(m_pContext)
        m_pContext->Release();
    m_pContext = NULL;
    m_bNull = TRUE;
}


INT_PTR CContext::Edit(HWND hParent)
{
    CContextDlg Dlg(hParent, this);
    return Dlg.Run();
}

CContext::operator IWbemContext*()
{
    if(m_bNull)
        return NULL;
    else
        return m_pContext;
}

void CContext::operator=(const CContext& Other)
{
    m_bNull = Other.m_bNull;
    if(m_pContext)
        m_pContext->Release();
    if(Other.m_pContext)
        Other.m_pContext->Clone(&m_pContext);
    else
        m_pContext = NULL;
}

void CContextDlg::OnUse()
{
    BOOL bEnable = (GetCheck(IDC_USE_CONTEXT) == BST_CHECKED);
    EnableControls(bEnable);
    m_Context.SetNullness(!bEnable);
}

BOOL CContextDlg::OnCommand(WORD wCode, WORD wID)
{
    if(wID == IDC_USE_CONTEXT)
        OnUse();
    else if(wID == IDC_ADD_PROP)
        OnAdd();
    else if(wID == IDC_EDIT_PROP)
        OnEdit();
    else if(wID == IDC_DELETE_PROP)
        OnDelete();
    return TRUE;
}

BOOL CContextDlg::OnDoubleClick(int nID)
{
    if(nID == IDC_VALUE_LIST)
        OnEdit();
    return TRUE;
}

void CContextDlg::OnAdd()
{
    BSTR strName = NULL;
    VARIANT vValue;
    VariantInit(&vValue);

    CContextValueDlg Dlg(m_hDlg, &strName, &vValue, TRUE);
    INT_PTR nRes = Dlg.Run();
    if(nRes == IDOK)
    {
        m_Context.SetNullness(FALSE);
        m_Context->SetValue(strName, 0, &vValue);
        Refresh();
    }
    SysFreeString(strName);
    VariantClear(&vValue);
}

void CContextDlg::OnEdit()
{
    BSTR strName = GetCurSelEntryName();
    if(strName == NULL)
        return;
    VARIANT vValue;
    VariantInit(&vValue);

    m_Context->GetValue(strName, 0, &vValue);

    CContextValueDlg Dlg(m_hDlg, &strName, &vValue, FALSE);
    INT_PTR nRes = Dlg.Run();
    if(nRes == IDOK)
    {
        m_Context->SetValue(strName, 0, &vValue);
        Refresh();
    }
    SysFreeString(strName);
    VariantClear(&vValue);
}

void CContextDlg::OnDelete()
{
    BSTR strName = GetCurSelEntryName();
    if(strName == NULL)
        return;
    m_Context->DeleteValue(strName, 0);
    SysAllocString(strName);
    Refresh();
}

LPSTR CContextDlg::MakeListEntry(LPCWSTR wszName, VARIANT& vValue)
{
    CVar value(&vValue);
    LPSTR TypeString = TypeToString(V_VT(&vValue));
    LPSTR ValueString = ValueToNewString(&value);

    char* sz = new char[strlen(TypeString) + strlen(ValueString) +
        wcslen(wszName)*4 + 100];

    sprintf(sz, "%S\t%s\t%s", wszName, TypeString, ValueString);
	delete [] ValueString;
    return sz;
}

BSTR CContextDlg::GetCurSelEntryName()
{
    LPSTR szEntry = GetLBCurSelString(IDC_VALUE_LIST);
    if(szEntry == NULL)
        return NULL;
    char* pc = strchr(szEntry, '\t');
    if(pc) *pc = 0;
    LPWSTR wszName = CreateUnicode(szEntry);
    delete [] szEntry;
    BSTR strName = SysAllocString(wszName);
    delete [] wszName;
    return strName;
}

void CContextDlg::Refresh()
{
    SendMessage(GetDlgItem(IDC_VALUE_LIST), LB_RESETCONTENT, 0, 0);

    IWbemContext* pContext = m_Context.GetStoredContext();
    if(pContext)
    {
        pContext->BeginEnumeration(0);
        BSTR strName;
        VARIANT vValue;
        VariantInit(&vValue);
        while(pContext->Next(0, &strName, &vValue) == S_OK)
        {
            char* szEntry = MakeListEntry(strName, vValue);
            AddStringToList(IDC_VALUE_LIST, szEntry);
            delete [] szEntry;
            VariantClear(&vValue);
        }
        pContext->EndEnumeration();
    }

    if(m_Context.IsNull())
    {
        SetCheck(IDC_USE_CONTEXT, BST_UNCHECKED);
        EnableControls(FALSE);
    }
    else
    {
        SetCheck(IDC_USE_CONTEXT, BST_CHECKED);
    }
}

BOOL CContextDlg::OnInitDialog()
{
    m_Context = *m_pContext;

    // Set tabs in the list box
    // ========================
    LONG Tabs[] = { 80, 120, 170 };
    int TabCount = 3;

    SendMessage(GetDlgItem(IDC_VALUE_LIST), LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    SendMessage(GetDlgItem(IDC_VALUE_LIST), LB_SETHORIZONTALEXTENT, 1000, 0);

    Refresh();

    return TRUE;
}

void CContextDlg::EnableControls(BOOL bEnable)
{
    EnableWindow(GetDlgItem(IDC_VALUE_LIST), bEnable);
    EnableWindow(GetDlgItem(IDC_ADD_PROP), bEnable);
    EnableWindow(GetDlgItem(IDC_EDIT_PROP), bEnable);
    EnableWindow(GetDlgItem(IDC_DELETE_PROP), bEnable);
}

CContextDlg::Verify()
{
    *m_pContext = m_Context;
    return TRUE;
}



CMainDlg::~CMainDlg()
{
    PostQuitMessage(0);
}

BOOL CMainDlg::OnInitDialog()
{
    CenterOnScreen(m_hDlg);
//    if(!gbAdvanced)
//  {
//      ShowWindow(GetDlgItem(IDC_ENABLE_PRIVILEGES), SW_HIDE);
//  }

    ConnectButtons(FALSE);
    SetDlgItemTextWC(m_hDlg, IDC_NAMESPACE, gNameSpace);

    CheckRadioButton(m_hDlg, IDC_ASYNC, IDC_SEMISYNC,
            (m_lSync & ASYNC) ? IDC_ASYNC : ((m_lSync & SEMISYNC) ? IDC_SEMISYNC : IDC_SYNC));
    SetDlgItemText(IDC_TIMEOUT, "5000");
    SetDlgItemText(IDC_BATCH, "10");

    SetFocus(GetDlgItem(IDC_CONNECT));
    return FALSE;
}

BOOL CMainDlg::OnCommand(WORD wNotifyCode, WORD wID)
{

    switch (wID)
    {
        case IDC_MENU_EXIT:
        case IDC_CONNECT:
            Connect(FALSE);
            return TRUE;
	case IDC_WBEMHELP:
  	  OpenHelp();
	  return TRUE;

        case IDC_BIND:
            Connect(TRUE);
            return TRUE;

        case IDC_CREATE_CLASS:
            CreateClass();
            return TRUE;
        case IDC_GET_CLASSES:
            GetClasses();
            return TRUE;

        case IDC_EDIT_CLASS:
            EditClass();
            return TRUE;

        case IDC_DELETE_CLASS:
            DeleteClass();
            return TRUE;

        case IDC_CREATE_INSTANCE:
            CreateInstance();
            return TRUE;
        case IDC_GET_INSTANCES:
            GetInstances();
            return TRUE;

        case IDC_EDIT_INSTANCE:
            EditInstance();
            return TRUE;

        case IDC_EXEC_METHOD:
            ExecMethod();
            return TRUE;

        case IDC_DELETE_INSTANCE:
            DeleteInstance();
            return TRUE;

        case IDC_QUERY:
            ExecQuery();
            return TRUE;

        case IDC_NOTIFICATION_QUERY:
            ExecNotificationQuery();
            return TRUE;

        case IDC_OPEN_NS:
            OpenNs();
            return TRUE;

        case IDC_REFRESH:
            CreateRefresher();
            return TRUE;
        case IDC_CONTEXT:
            EditContext();
            return TRUE;
        case IDC_ENABLE_PRIVILEGES:
            {
                // From common\genutils.cpp
                HRESULT hRes = EnableAllPrivileges(TOKEN_PROCESS);
                BOOL bRes = SUCCEEDED(hRes);
                if (bRes)
                    EnableWindow(GetDlgItem(IDC_ENABLE_PRIVILEGES), FALSE);
                return bRes;
            }
        case IDC_USE_AMENDED:
            if (GetCheck(IDC_USE_AMENDED) == BST_CHECKED)
                m_lGenFlags |= WBEM_FLAG_USE_AMENDED_QUALIFIERS;
            else
                m_lGenFlags &= ~WBEM_FLAG_USE_AMENDED_QUALIFIERS;
            return TRUE;
        case IDC_DIRECT_READ:
            if (GetCheck(IDC_DIRECT_READ) == BST_CHECKED)
                m_lGenFlags |= WBEM_FLAG_DIRECT_READ;
            else
                m_lGenFlags &= ~WBEM_FLAG_DIRECT_READ;
            return TRUE;
        case IDC_USE_NEXTASYNC:
            if (GetCheck(IDC_USE_NEXTASYNC) == BST_CHECKED)
                m_lSync |= USE_NEXTASYNC;
            else
                m_lSync &= ~USE_NEXTASYNC;
            EnableWindow(GetDlgItem(IDC_TIMEOUT), !(m_lSync & USE_NEXTASYNC));
            return TRUE;

        case IDC_ASYNC:
        case IDC_SYNC:
        case IDC_SEMISYNC:
            // Can ignore USE_NEXTASYNC checkbox because we are changing to or from
            // semisync which means this checkbox either was clear or is now cleared.
            if (GetCheck(IDC_ASYNC) == BST_CHECKED)
            {
                m_lSync = ASYNC;
                SetCheck(IDC_USE_NEXTASYNC, BST_UNCHECKED);
            }
            else if (GetCheck(IDC_SYNC) == BST_CHECKED)
            {
                m_lSync = SYNC;
                SetCheck(IDC_USE_NEXTASYNC, BST_UNCHECKED);
            }
            else if (GetCheck(IDC_SEMISYNC) == BST_CHECKED)
            {
                m_lSync = SEMISYNC;
            }
            EnableWindow(GetDlgItem(IDC_BATCH), !(m_lSync & ASYNC));
            EnableWindow(GetDlgItem(IDC_TIMEOUT), (m_lSync & SEMISYNC));
            EnableWindow(GetDlgItem(IDC_USE_NEXTASYNC), (m_lSync & SEMISYNC));
            return TRUE;
/*            
		case IDC_OPEN:
            Open();
            return TRUE;

		case IDC_ADDOBJECT:
            AddObject();
            return TRUE;

		case IDC_DELETEOBJECT:
            DeleteObject();
            return TRUE;

		case IDC_RENAMEOBJECT:
            RenameObject();
            return TRUE;

		case IDC_GETOBJECTSECURITY:
            GetObjectSecurity();
            return TRUE;

		case IDC_SETOBJECTSECURITY:
            SetObjectSecurity();
            return TRUE;
*/            
    }
    return TRUE;
}

LONG CMainDlg::Timeout()
{
    wchar_t wszTimeout[32];
    *wszTimeout = 0;
    LONG lTimeout = 0;

    ::GetDlgItemTextX(m_hDlg, IDC_TIMEOUT, wszTimeout, 32);
    if (*wszTimeout != 0)
        lTimeout = _wtol(wszTimeout);
    if (lTimeout < 0)
        lTimeout = WBEM_INFINITE;

    return lTimeout;
}

ULONG CMainDlg::BatchCount()
{
    wchar_t wszBatch[32];
    *wszBatch = 0;
    ULONG nBatch = 1;

    ::GetDlgItemTextX(m_hDlg, IDC_BATCH, wszBatch, 32);
    if (*wszBatch != 0)
        nBatch = _wtol(wszBatch);
    if (nBatch == 0)
        nBatch = 1;

    return nBatch;
}

CRefresherDlg::CRefresherDlg(HWND hParent, LONG lGenFlags)
    : CQueryResultDlg(hParent, lGenFlags, WBEM_FLAG_DEEP)
{
    CoCreateInstance(CLSID_WbemRefresher, NULL,
        CLSCTX_INPROC_SERVER, IID_IWbemRefresher, (void**)&m_pRefresher);
    m_pRefresher->QueryInterface(IID_IWbemConfigureRefresher,
        (void**)&m_pCreator);
}

CRefresherDlg::~CRefresherDlg()
{
    // Release all allocated enumerators
    while ( m_apEnums.Size() != 0 )
    {
        IEnumWbemClassObject*   pEnum = (IEnumWbemClassObject*) m_apEnums.GetAt( 0 );
        if ( NULL != pEnum )
        {
            pEnum->Release();
        }
        m_apEnums.RemoveAt( 0 );
    }

    m_pRefresher->Release();
    m_pCreator->Release();
}

BOOL CRefresherDlg::OnInitDialog()
{
    SetTitle("REFRESHER");
    ShowWindow(GetDlgItem(IDC_STATUS), SW_HIDE);
    ShowWindow(GetDlgItem(IDC_NUM_BATCH), SW_HIDE);
    if(!CQueryResultDlg::OnInitDialog())
        return FALSE;
    ShowWindow(GetDlgItem(IDC_REFRESH), SW_SHOWNORMAL);
    return TRUE;
}

BOOL CRefresherDlg::OnCommand(WORD wCode, WORD wID)
{
    if(wID == IDC_REFRESH)
    {
        OnRefresh();
        return TRUE;
    }
    else return CQueryResultDlg::OnCommand(wCode, wID);
}

void CRefresherDlg::OnRefresh()
{
    HRESULT hres = m_pRefresher->Refresh(0);
    if(FAILED(hres))
    {
        FormatError(hres, NULL);
    }
}

BOOL CRefresherDlg::DeleteListElement(LRESULT nSel)
{
    HRESULT hres = m_pCreator->Remove(PtrToLong(m_aIds[(DWORD)nSel]), 0);
    if(FAILED(hres))
    {
        FormatError(hres, NULL);
        return FALSE;
    }

    m_aIds.RemoveAt((DWORD)nSel);

    // If this is an enumerator, we should release it before we remove it
    IEnumWbemClassObject*   pEnum = (IEnumWbemClassObject*) m_apEnums.GetAt( (DWORD)nSel );

    if ( NULL != pEnum )
    {
        pEnum->Release();
    }
    m_apEnums.RemoveAt((DWORD)nSel);

    return TRUE;
}


IWbemClassObject* CRefresherDlg::AddNewElement()
{
    if(g_pNamespace == NULL)
    {
        MessageBox(IDS_NO_CONNECTION, IDS_ERROR, MB_OK);
        return NULL;
    }
    wchar_t ObjPath[2560];

    INT_PTR iRet = GetRefrObjectPath(m_hDlg, ObjPath, 2560);
    if(iRet == IDCANCEL)
        return NULL;

    if (wcslen(ObjPath) == 0)
    {
        MessageBox(IDS_NO_PATH, IDS_ERROR, MB_OK);
        return NULL;
    }

    IWbemClassObject* pObj = NULL;
    IWbemHiPerfEnum*    pEnum = NULL;
    long lId;
    HRESULT hres = WBEM_S_NO_ERROR;



    // iRet for whether we want to add an object or an enum

    if ( IDOK == iRet )
    {
        hres = m_pCreator->AddObjectByPath(g_pNamespace, ObjPath,
            m_lGenFlags, g_Context, &pObj, &lId);
        if(FAILED(hres))
        {
            FormatError(hres, NULL);
            return NULL;
        }
#ifdef _WIN64
        m_aIds.Add(IntToPtr(lId));   // ok since we are really using safearray for dword 
#else
        m_aIds.Add((void*)lId);
#endif
        // Fakes out the Enumerator List
        m_apEnums.Add( NULL );
        return pObj;
    }

    // Add an enumerator to the dialog
    hres = m_pCreator->AddEnum(g_pNamespace, ObjPath,
        m_lGenFlags, g_Context, &pEnum, &lId);
    if(FAILED(hres))
    {
        FormatError(hres, NULL);
        return NULL;
    }

#ifdef _WIN64
        m_aIds.Add(IntToPtr(lId));      // ok since we are really using safearray for dword 
#else
        m_aIds.Add((void*)lId);
#endif
    m_apEnums.Add( (void*) pEnum );

    // Fakes out the object list
    m_InternalArray.Add( NULL );

    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    // Allocate a large enough buffer
    char*   szTemp = new char[(wcslen( ObjPath ) * 2) + 64];
    sprintf( szTemp, "%S Enumerator, Id: %d", ObjPath, lId );
    SendMessage(hList, LB_ADDSTRING, 0, LPARAM(szTemp));
    delete [] szTemp;

    SetNumItems(SendMessage(hList, LB_GETCOUNT, 0, 0));

    return NULL;

}

BOOL CRefresherDlg::OnDoubleClick(int nID)
{
    if(nID != IDC_OBJECT_LIST) return FALSE;
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    LRESULT nSel = SendMessage(hList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return TRUE;

    IWbemHiPerfEnum*    pEnum = (IWbemHiPerfEnum*) m_apEnums.GetAt( (DWORD)nSel );

    if ( NULL != pEnum )
    {
        char*   szTemp = new char[SendMessage( hList, LB_GETTEXTLEN, nSel, 0 )+10];
        SendMessage( hList, LB_GETTEXT, nSel, (LPARAM) szTemp );

        // Run the dialog modal
        CRefresherEnumDlg* pDlg = new CRefresherEnumDlg(m_hDlg, m_lGenFlags, pEnum, szTemp);
        pDlg->Run( NULL );

		delete pDlg;
        delete [] szTemp;
        SendMessage(hList, LB_SETCURSEL, nSel, 0);
        return TRUE;
    }
    else
    {
        return CQueryResultDlg::OnDoubleClick( nID );
    }
    return TRUE;
}

CRefresherEnumDlg::CRefresherEnumDlg(HWND hParent, LONG lGenFlags, IWbemHiPerfEnum* pEnum,
                                     char* pszName)
    : CQueryResultDlg(hParent, lGenFlags, WBEM_FLAG_DEEP), m_pEnum(pEnum), m_pszName(pszName)
{

    if ( NULL != m_pEnum )
    {
        m_pEnum->AddRef();
    }
}

CRefresherEnumDlg::~CRefresherEnumDlg()
{
    if ( NULL != m_pEnum )
    {
        m_pEnum->Release();
    }
}

BOOL CRefresherEnumDlg::OnInitDialog()
{
    // Set the dialog title
    char*   szTemp = new char[strlen(m_pszName)+64];
    sprintf( szTemp, "REFRESHER: %s", m_pszName );
    SetTitle(szTemp);
    delete [] szTemp;

    ShowWindow(GetDlgItem(IDC_STATUS), SW_HIDE);
    ShowWindow(GetDlgItem(IDC_NUM_BATCH), SW_HIDE);
    if(!CQueryResultDlg::OnInitDialog())
        return FALSE;

    // Iterate the enumerator and add all its objects into the list
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject*   pObj = NULL;
    ULONG               nNumObjects = 0,
                        nNumReturned = 0;

    // Find out how many objects to retrieve then get them
    // and stick them in the dialog

    // Don't pass flags on  this call
    m_pEnum->GetObjects( 0L, 0, NULL, &nNumObjects );

    if ( nNumObjects > 0 )
    {
        IWbemObjectAccess** apObjAccess = new IWbemObjectAccess*[nNumObjects];

        if ( NULL != apObjAccess )
        {
            // Don't pass flags on  this call
            hr = m_pEnum->GetObjects( 0L, nNumObjects, apObjAccess, &nNumReturned );

            if ( SUCCEEDED( hr ) )
            {
                IWbemClassObject*   pClassObj = NULL;

                for ( ULONG n = 0; SUCCEEDED( hr ) && n < nNumReturned; n++ )
                {
                    hr = apObjAccess[n]->QueryInterface( IID_IWbemClassObject, (void**) &pClassObj );

                    if ( SUCCEEDED( hr ) )
                    {
                        AddObject( pClassObj );
                        apObjAccess[n]->Release();
                        pClassObj->Release();
                    }
                }
            }
            delete [] apObjAccess;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    if ( FAILED( hr ) )
    {
        FormatError(hr, NULL);
    }

    return TRUE;
}

CHourGlass::CHourGlass()
{
    m_hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
}

CHourGlass::~CHourGlass()
{
    SetCursor(m_hCursor);
}

HRESULT EnableAllPrivileges(DWORD dwTokenType)
{
    // Open thread token
    // =================

    HANDLE hToken = NULL;
    BOOL bRes;

    switch (dwTokenType)
    {
    case TOKEN_THREAD:
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken);
        break;
    case TOKEN_PROCESS:
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken);
        break;
    }
    if(!bRes)
        return WBEM_E_ACCESS_DENIED;

    // Get the privileges
    // ==================

    DWORD dwLen;
    TOKEN_USER tu;
    memset(&tu,0,sizeof(TOKEN_USER));
    bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);

    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
    {
        CloseHandle(hToken);
        return WBEM_E_OUT_OF_MEMORY;
    }

    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen,
                                &dwLen);
    if(!bRes)
    {
        CloseHandle(hToken);
        delete [] pBuffer;
        return WBEM_E_ACCESS_DENIED;
    }

    // Iterate through all the privileges and enable them all
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
    }

    // Store the information back into the token
    // =========================================

    bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
    delete [] pBuffer;
    CloseHandle(hToken);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;
    else
        return WBEM_S_NO_ERROR;
}

/*
void CMainDlg::Open()
{

    wchar_t ObjPath[2560];
    int iRet = (int) GetObjectPath(m_hDlg, ObjPath, 2560);
    if(iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
    {
        MessageBox(IDS_NO_PATH, IDS_ERROR, MB_OK);
        return;
    }

    if (g_pNamespace == 0)
    {
        MessageBox(IDS_NO_INITIAL_CONNECTION, IDS_ERROR, MB_OK);
        return;
    }

    IWbemServicesEx* pNewNs = NULL;
    CBString bsObjPath(ObjPath);

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {

		IUnknown *pUnknown=NULL;

		CTestNotify* pSink=new CTestNotify(1);

		res=g_pServicesEx->OpenAsync(bsObjPath.GetString(), 0,
                                m_lGenFlags,
                                g_Context, CUnsecWrapEx(pSink));

		if (SUCCEEDED(res))
		{
			pSink->WaitForSignal(INFINITE);
			res = pSink->GetStatusCode();
			if(SUCCEEDED(res))
			{
				pUnknown=pSink->GetInterface();
                if(pUnknown)
                {
                    res = pUnknown->QueryInterface(IID_IWbemServicesEx, (void**)&pNewNs);
                    pUnknown->Release();
                }
                else
                    res = WBEM_E_FAILED;
			}
		}
		pSink->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResultEx* pCallRes = NULL;
        CHourGlass hg;
        res = g_pServicesEx->Open(bsObjPath.GetString(), 0,
                                m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, NULL, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(Timeout(), &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::OpenNamespace call
                if (res == WBEM_S_NO_ERROR)
                {
                    res = pCallRes->GetResult(0, 0, IID_IWbemServicesEx, (LPVOID *) &pNewNs);    // don't use timeout since object should be available
                }
            }

            pCallRes->Release();
        }
		
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pServicesEx->Open(bsObjPath.GetString(), 0,
                                m_lGenFlags,
                                g_Context, &pNewNs, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
        return;
    }

    g_pNamespace->Release();
	g_pNamespace = pNewNs;
    SetInterfaceSecurityEx(g_pNamespace, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);

    wcscat(gNameSpace, L":");
    wcscat(gNameSpace, bsObjPath.GetString());
    SetDlgItemTextWC(m_hDlg, IDC_NAMESPACE, gNameSpace);

    SysFreeString(g_strNamespace);
    g_strNamespace = SysAllocString(gNameSpace);
}

void CMainDlg::DoServicesExGenObject(int iOpt)
{
    wchar_t ObjPath[2560];
    *ObjPath = 0;

    int iRet = (int) GetObjectPath(m_hDlg, ObjPath, 2560);
    if (iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
        return;

    CBString bsObjPath(ObjPath);
    HRESULT res = 0;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        MessageBox(IDS_ASYNC_NOT_SUPPORTED, IDS_ERROR, MB_OK);
        return;
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResultEx* pCallRes = NULL;
        CHourGlass hg;
		switch (iOpt)
		{
			case IDC_ADDOBJECT:
				// Link
                res = E_NOTIMPL;
				break;

			case IDC_DELETEOBJECT:
				// Unlink
                res = E_NOTIMPL;
				break;


		}
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteIntance call
            }
            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;

		switch (iOpt)
		{
			case IDC_ADDOBJECT:
                // Link
                res = E_NOTIMPL;
                break;

			case IDC_DELETEOBJECT:
                // Unlink
                res = E_NOTIMPL;
                break;


		}
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
    }
}

void CMainDlg::AddObject()
{
	DoServicesExGenObject(IDC_ADDOBJECT);
}

void CMainDlg::DeleteObject()
{
    wchar_t ObjPath[2560];
    *ObjPath = 0;

    INT_PTR iRet = GetObjectPath(m_hDlg, ObjPath, 2560);
    if (iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
        return;

    CBString bsObjPath(ObjPath);
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pServicesEx->DeleteObjectAsync(bsObjPath.GetString(),
                                                m_lGenFlags | WBEM_FLAG_SEND_STATUS,
                                                g_Context, CUnsecWrap(pNtfy));

        if (SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pServicesEx->DeleteObject(bsObjPath.GetString(),
                                           m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           g_Context, &pCallRes);
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteIntance call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pServicesEx->DeleteObject(bsObjPath.GetString(), m_lGenFlags,
                                           g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
    }
}


void CMainDlg::GetObjectSecurity()
{
	::MessageBox(NULL, "Show me the code", "help!", MB_OK);
}

void CMainDlg::SetObjectSecurity()
{
	::MessageBox(NULL, "Show me the code", "help!", MB_OK);
}

void CMainDlg::RenameObject()
{
	WCHAR wsOld[512], wsNew[512];
    CRenameDlg InfoDlg(m_hDlg, wsOld, 512, wsNew, 512);
    if(IDOK != InfoDlg.Run())
		return;

    CBString bsOld(wsOld);
    CBString bsNew(wsNew);
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        MessageBox(IDS_ASYNC_NOT_SUPPORTED, IDS_ERROR, MB_OK);
        return;
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResultEx* pCallRes = NULL;
        CHourGlass hg;
		res = g_pServicesEx->RenameObject(bsOld.GetString(), bsNew.GetString(),
                                           m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           g_Context, &pCallRes);
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteIntance call
            }
            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;

    	res = g_pServicesEx->RenameObject(bsOld.GetString(), bsNew.GetString(),
                                           m_lGenFlags,
                                           g_Context, NULL);
 }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
    }


}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_converter.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    Converter.h

Abstract:

    interface for the CConverter class.

History:

	9/15/98 Created 
	9/22/98	Removed Convert(ULONG); Added Convert(CVar) & Convert(CVarVector)

--*/
#ifndef __CONVERTER_H
#define __CONVERTER_H

#define ERR_NOERROR					0x00000000
#define ERR_UNKNOWN					0x00000001
#define ERR_INVALID_SIGNED_VALUE	0x00000002
#define ERR_INVALID_TOKEN			0x00000003
#define ERR_OUT_OF_RANGE			0x00000004
#define ERR_NULL_CIMTYPE			0x00000005
#define ERR_INVALID_INPUT_STRING	0x00000006
#define ERR_NULL_TOKEN				0x00000007
#define ERR_UNKNOWN_BASE			0x00000008
#define ERR_UNMATCHED_BRACE			0x00000009

#define BASE_DEC	10
#define BASE_HEX	16

typedef long CIMType;

class CConverter  
{
	CIMType	m_ct;			// CIM type
	char*	m_szString;		// Input string
//	char*	m_szCurrent;	// Current token pointer

	CConverter(const char* szString, CIMType ct);
	virtual ~CConverter();

	UINT SetBoundary(BOOL bNeg, ULONG *uMaxSize);
	BOOL Done(char *ch);
	BOOL Separator();
	BOOL IsValidDec(char ch);
	BOOL IsValidHex(char ch);

	char PeekToken(char *ch);
	BOOL GetToken(char **ch);
	void ReplaceToken(char **ch);

	UINT Token_Sequence(CVarVector *pVarVec);
	UINT Token_Sequence(CVar *pVar);
	UINT Token_Number(char **ch, CVar *pVar);
	UINT Token_Digit(char **ch, ULONG *ulRes);
	UINT Token_Separator(char **ch);
	UINT Token_DecField(char **ch, BOOL bNeg, ULONG *pVal);
	UINT Token_HexField(char **ch, BOOL bNeg, ULONG *pVal);
	UINT Token_DecDigit(char **ch, ULONG *pVal);
	UINT Token_HexDigit(char **ch, ULONG *pVal);
	UINT Token_Comment(char **ch);
	UINT Token_WhiteSpace(char **ch);
public:
	static UINT Convert(const char* szString, CIMType ct, ULONG *ulRes);
	static UINT Convert(const char* szString, CIMType ct, CVar *pVar);
	static UINT Convert(const char* szString, CIMType ct, CVarVector *pVarVec);
};

#endif //__CONVERTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_converter.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CONVERTER.CPP

Abstract:

    <sequence>   ::= <number> | <number><separator><sequence>
    <separator>  ::= [<whitespace>],[<whitespace>] | <whitespace>
    <number>     ::= <whitespace>[-]0x<hexfield>[<comment>] | <whitespace>[-]<digitfield>[<comment>]
    <decfield>   ::= <decdigit> | <decdigit><decfield>
    <decdigit>   ::= 0..9
    <hexfield>   ::= <hexdigit> | <hexdigit><hexfield>
    <hexdigit>   ::= 1..9 | A | B | C | D | E | F
    <comment>    ::= [<whitespace>](<string>)[<whitespace>]
    <whitespace> ::= SP | TAB | CR | LF

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>

#include "wbemcli.h"
#include "var.h"
#include "WT_Converter.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CConverter::CConverter(const char* szString, CIMType ct)
{
    int nSize = strlen(szString);
    m_szString = new char[nSize + 1];   // Made to fit

    strcpy(m_szString, szString);
    m_ct = ct;                          // CIM_TYPE
}

CConverter::~CConverter()
{
    delete m_szString;
}

/******************************************************************
//
//      Helper Functions
//
*******************************************************************/

UINT CConverter::SetBoundary(BOOL bNeg, ULONG *uMaxSize)
//////////////////////////////////////////////////////////////////////
//
//  Establishs the outer boundary of a give CIM type.  Returns the 
//  maximum absolute value, including an offset if the value is 
//  negative. (Compensating for the additional size of 2's complement 
//  negative values)
//
//////////////////////////////////////////////////////////////////////
{
    *uMaxSize = 0;

    switch (m_ct)   
    {
    case CIM_UINT8:
        *uMaxSize = 0x000000FF; break;
    case CIM_SINT8:
        *uMaxSize = (bNeg ? 0x00000080 : 0x0000007F); break;
    case CIM_UINT16:
        *uMaxSize = 0x0000FFFF; break;
    case CIM_SINT16:
        *uMaxSize = (bNeg ? 0x00008000 : 0x00007FFF); break;
    case CIM_UINT32:
        *uMaxSize = 0xFFFFFFFF; break;
    case CIM_SINT32:
        *uMaxSize = (bNeg ? 0x80000000 : 0x7FFFFFFF); break;
    case NULL:
        return ERR_NULL_CIMTYPE;
    default:
        return ERR_UNKNOWN;
    }

    return ERR_NOERROR;
}

BOOL CConverter::IsValidDec(char ch)
//////////////////////////////////////////////////////////////////////
//
//  PARAMETERS : a character to be validated as decimal
//  RETURNS: TRUE only if the character is a valid decimal character
//
//////////////////////////////////////////////////////////////////////
{
    return (('0' <= ch) && ('9' >= ch));
}

BOOL CConverter::IsValidHex(char ch)
//////////////////////////////////////////////////////////////////////
//
//  PARAMETERS : a character to be validated as hexadecimal
//  RETURNS: TRUE only if the character is a valid hexadecimal character
//
//////////////////////////////////////////////////////////////////////
{
    return ((('0' <= ch) && ('9' >= ch)) || (('a' <= ch) && ('f' <= ch)));
}

/******************************************************************
//
//      Parser Functions
//
*******************************************************************/

char CConverter::PeekToken(char *ch)
//////////////////////////////////////////////////////////////////////
//
//  PARAMETERS: the token pointer (by val)
//  RETURNS: the character following the current token pointer.  Does
//  not increment the token pointer.
//
//////////////////////////////////////////////////////////////////////
{
    // ch is passed by value; change is local to method
    ch++;

    // Ensure lower case
    if (('A' <= *ch) && ('Z' >= *ch))
        *ch += ('a' - 'A');
    
    return *ch;
}

BOOL CConverter::GetToken(char **ch)
//////////////////////////////////////////////////////////////////////
//
//  If the token pointer is not at the end of the string, it will be
//  incremented and the current token will be converted into lower 
//  case and passed back.  If the pointer is at the end of the string, 
//  NULL will be passed and the pointer unaffected.  
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: TRUE if the token pointer is mid-string, and FALSE if it 
//  is at the end of the string.
//
//////////////////////////////////////////////////////////////////////
{
    // Increment pointer by 1 byte
    if ('\0' != **ch)
        *ch += 1;

    // Ensure lower case
    if (('A' <= **ch) && ('Z' >= **ch))
        **ch += ('a' - 'A');

    // End of the line?
    return ('\0' != **ch);
}

void CConverter::ReplaceToken(char **ch)
//////////////////////////////////////////////////////////////////////
//
//  If not at the front of the string, the token pointer will be 
//  decremented one place towards the head of the string.
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: void
//
//////////////////////////////////////////////////////////////////////
{
    if (*ch != m_szString)
        *ch -= 1;
    return;
}

BOOL CConverter::Done(char *ch)
//////////////////////////////////////////////////////////////////////
//
//  Checks for additional non-whitespace tokens following current 
//  token.  Does not validate token.
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: TRUE if no further non-whitespace tokens follow the 
//  current token pointer
//
//////////////////////////////////////////////////////////////////////
{
    if ('\0' == *ch)
        return TRUE;

    while (isspace(*ch))
        ch++;

    return ('\0' == *ch);
}

/******************************************************************
//
//      Token Functions
//
*******************************************************************/

UINT CConverter::Token_Sequence(CVar *pVar)
//////////////////////////////////////////////////////////////////////
//
//  Root of parsing for single (non-array) values.  Sets up token
//  pointer (ch), and parses one number.  If tokens remain in the 
//  input string following the parsing of the first number, then
//  the input string is invalid.  
//
//  If the parsing fails, the value of pVar is not changed
//
//  PARAMETERS: a variant for the result (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    CVar aVar;              // A temporary result variant
    char *ch = m_szString;  // The token pointer
    UINT uRes;              // A generic result sink

    // Parse out the number
    uRes = Token_Number(&ch, &aVar);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Check for remaining tokens
    if (!Done(ch))
        return ERR_INVALID_INPUT_STRING;

    // Parsing ok, copy temp variant into final destiation
    *pVar = aVar;

    return ERR_NOERROR;
}

UINT CConverter::Token_Sequence(CVarVector *pVarVec)
//////////////////////////////////////////////////////////////////////
//
//  Root of parsing for multiple (array) values.  Sets up token
//  pointer (ch), and parses the input string.  It starts with a 
//  single number, and then enters the loop, verifying a seperator
//  between each subsequent number.  Each number is added to the 
//  variant array as it is parsed.
//
//  If the parsing fails, the value if pVarVec is not changed
//
//  PARAMETERS: a variant vector for the result (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    CVar aVar;                  // A temporary result variant
    char *ch = m_szString;      // The token pointer
    UINT uRes;                  // A generic result sink
    UINT uVTType;

    switch (m_ct)
    {
    case CIM_UINT8:
        uVTType = VT_UI1;break;
    case CIM_SINT8:
    case CIM_SINT16:
        uVTType = VT_I2;break;
    case CIM_UINT16:
    case CIM_UINT32:
    case CIM_SINT32:
        uVTType = VT_I4;break;
    }

    CVarVector aVarVec(uVTType);// A temporary result variant vector

    // Parse out the first number
    uRes = Token_Number(&ch, &aVar);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Add to array, and clear temporary variant
    aVarVec.Add(aVar);

    // If more tokens exist, continue
    while (!Done(ch))
    {
        // Verify separator
        uRes = Token_Separator(&ch);
        if (ERR_NOERROR != uRes)
            return uRes;

        // Parse out next number
        uRes = Token_Number(&ch, &aVar);
        if (ERR_NOERROR != uRes)
            return uRes;

        // Add to array, and clear temporary variant
        aVarVec.Add(aVar);
    }

    // Parsing ok, copy temp variant vector into final destiation
    *pVarVec = aVarVec;

    return ERR_NOERROR;
}

UINT CConverter::Token_WhiteSpace(char **ch)
//////////////////////////////////////////////////////////////////////
//
//  Move token pointer to the next non-white space token
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    while (isspace(**ch))
        GetToken(ch);

    return ERR_NOERROR;
}

UINT CConverter::Token_Separator(char **ch)
//////////////////////////////////////////////////////////////////////
//
//  A valid separator is either white space or a comma optionally 
//  preceeded by white space.  Parese out white space.  Stop when
//  a non-whitespace character is encountered.  If a comma, then 
//  there must be a following non-whitespace token.
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    BOOL bComma = FALSE;
    
    while ((isspace(**ch) || (',' == **ch)) && !bComma)
    {
        if (',' == **ch)
            bComma = TRUE;

        // If a comma exists, the string must not be done
        if (!GetToken(ch) && bComma)
            return ERR_INVALID_TOKEN;
    }

    return ERR_NOERROR;
}

UINT CConverter::Token_Number(char **ch, CVar *pVar)
//////////////////////////////////////////////////////////////////////
//
//  Determines the sign and base values of the number, and then 
//  calls either Token_HexField or Token_DecField to continue
//  parsing the digit fields.  The numerical value returned from
//  the parsing is unsigned.  If the value is signed and negative
//  the value is negated.  Comments are then parsed out.
//
//  If the parsing fails, the value of pVar does not change
//
//  PARAMETERS: the token pointer (by ref) and a Variant representing 
//  the number (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    ULONG   aVal;               // Temp value returned from Token_XXXField
    USHORT  uBase = BASE_DEC;   // Base of number
    BOOL    bNegative = FALSE;  // Sign of number
    UINT    uRes;               // Generic result sink

    // Parse out white space
    uRes = Token_WhiteSpace(ch);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Determines the sign (assumed positive) and validates against type
    if (**ch == '-')
    {
        if ((CIM_UINT8 == m_ct) || (CIM_UINT16 == m_ct) || (CIM_UINT32 == m_ct))
            return ERR_INVALID_SIGNED_VALUE;
        //else
        bNegative = TRUE;
        GetToken(ch);   // Get the next token to handle
    }

    // Determine Base (we have initialized as decimal)
    if (**ch == '0')
    {
        if (PeekToken(*ch) == 'x')      // Hexadecimal!
        {                       
            uBase = BASE_HEX;   // Modify base 
            GetToken(ch);       // Get Rid of the 'x' token
            GetToken(ch);       // Get the next token to handle
        }
    }

    // Parse digit field and put result in aVal
    if (BASE_HEX == uBase)
        uRes = Token_HexField(ch, bNegative, &aVal);
    else if (BASE_DEC == uBase)
        uRes = Token_DecField(ch, bNegative, &aVal);
    else
        return ERR_UNKNOWN_BASE;

    if (ERR_NOERROR != uRes)
        return uRes;

    // NOTE: signed operation on unsigned value 
    //      -this may cause a problem on some platforms
    if (bNegative)
        aVal *= (-1);

    // Set variant
    pVar->SetLong(aVal);

    // Parse out comments
    uRes = Token_Comment(ch);
    if (ERR_NOERROR != uRes)
        return uRes;
    
    return ERR_NOERROR;
}

UINT CConverter::Token_DecField(char **ch, BOOL bNeg, ULONG *pVal)
//////////////////////////////////////////////////////////////////////
//
//  Token_DecField first determines the maximum possible value of 
//  the number based on the CIM type for the purpose of bonuds checking.
//  The digit field is parsed, withe each token being added to the 
//  previous tally value after it has increased in magnitude.
//
//  Prior to the tally increasing, the proposed tally is validated 
//  using an algorithm that assumes that the current value is in 
//  range, and verifies that the proposed value will be in range 
//  by working back from the maximum value.  This algorithm works,
//  given that the initial value is 0, which is guarenteed to be
//  within range.  The difference between the current tally, and the
//  proposed tally is subtracted from the maximum value, and if the 
//  result is larger than the current tally, then the propsed value
//  is valid.
//
//  This algorithm assumes that we are using unsigend values.  Signed 
//  negative values are constructed as positive values, and then
//  converted.  In this case, the maximum value is one larger than the 
//  positive maximum value, according to the rules of 2's complement.
//
//  If the parsing fails, the value of pVal does not change
//
//  PARAMETERS: the token pointer (by ref), the sign flag (by val) 
//  and a the unsigned value of the number (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    ULONG uMaxSize;     // Boundary value
    ULONG aVal = 0;     // Tally value
    ULONG uDigitVal;    // Return digit from Token_DecDigit
    UINT uRes;          // Generic result sink

    // Sets the maximum value of the tally
    uRes = SetBoundary(bNeg, &uMaxSize);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Pareses the first digit
    uRes = Token_DecDigit(ch, &uDigitVal);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Adds to tally
    aVal = uDigitVal;

    // If more decimal tokens...
    while (IsValidDec(**ch))
    {
        // Parse the token
        uRes = Token_DecDigit(ch, &uDigitVal);
        if (ERR_NOERROR != uRes)
            return uRes;

        // Test the bounds of the proposed tally
        if (((uMaxSize - uDigitVal) / BASE_DEC ) < aVal) 
            return ERR_OUT_OF_RANGE;

        // Increase the magnitude and add the token digit value
        aVal = (aVal * BASE_DEC) + uDigitVal;
    }

    // Parsing ok, copy the temp to the destination
    *pVal = aVal;

    return ERR_NOERROR;
}

UINT CConverter::Token_HexField(char **ch, BOOL bNeg, ULONG *pVal)
//////////////////////////////////////////////////////////////////////
//
//  See Token_DecField
//
//////////////////////////////////////////////////////////////////////
{
    ULONG uMaxSize;     // Boundary value
    ULONG aVal = 0;     // Tally value
    ULONG uDigitVal;    // Return digit from Token_DecDigit
    UINT uRes;          // Generic result

    // Sets the maximum value of the tally
    uRes = SetBoundary(bNeg, &uMaxSize);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Pareses the first digit
    uRes = Token_HexDigit(ch, &uDigitVal);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Adds to tally
    aVal = uDigitVal;

    // If more decimal tokens...
    while (IsValidHex(**ch))
    {
        // Parse the token
        uRes = Token_HexDigit(ch, &uDigitVal);
        if (ERR_NOERROR != uRes)
            return uRes;

        // Test the bounds of next tally
        if (((uMaxSize - uDigitVal) / BASE_HEX ) < aVal) 
            return ERR_OUT_OF_RANGE;

        // Increase the magnitude and add the token digit value
        aVal = (aVal * BASE_HEX) + uDigitVal;
    }

    // Parsing ok, copy the temp to the destination
    *pVal = aVal;
    return ERR_NOERROR;
}

UINT CConverter::Token_DecDigit(char **ch, ULONG *pVal)
//////////////////////////////////////////////////////////////////////
//
//  Validates the token, and converts to numerical equivalent
//
//  If the parsing fails, the value of pVal does not change
//
//  PARAMETERS: the token pointer (by ref) and a the value 
//  of the digit (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    ULONG uVal = 0;     // Temp value

    // Validate digit & convert
    if (('0' <= **ch) && ('9' >= **ch)) 
        uVal = **ch - '0';
    else if ('\0' == **ch)
        return ERR_NULL_TOKEN;
    else
        return ERR_INVALID_TOKEN;

    // Parsing ok, copy value to destination
    *pVal = uVal;

    // Move token pointer
    GetToken(ch);

    return ERR_NOERROR;
}

UINT CConverter::Token_HexDigit(char **ch, ULONG *pVal)
//////////////////////////////////////////////////////////////////////
//
//  Validates the token, and converts to numerical equivalent
//
//  If the parsing fails, the value of pVal does not change
//
//  PARAMETERS: the token pointer (by ref) and a the value 
//  of the digit (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    ULONG uVal = 0;     // Temp value

    // Validate digit & convert
    if (('a' <= **ch) && ('f' >= **ch))
        uVal = 0xA + (**ch - 'a');
    else if (('0' <= **ch) && ('9' >= **ch)) 
        uVal = **ch - '0';
    else if ('\0' == **ch)
        return ERR_NULL_TOKEN;
    else
        return ERR_INVALID_TOKEN;

    // Parsing ok, copy value to destination
    *pVal = uVal;

    // Move token pointer
    GetToken(ch);

    return ERR_NOERROR;
}

UINT CConverter::Token_Comment(char** ch)
//////////////////////////////////////////////////////////////////////
//
//  Parses out white space and contents between braces, if they exist.
//  If an opening brace is encountered, all of the contents, including 
//  the braces, are ignored.  If an opening brace is encountered, a 
//  closing brace must follow.
//
//  NOTE: Nested comments are not allowed
//
//  PARAMETERS: the token pointer (by ref) 
//  
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    // Parse out white space
    UINT uRes = Token_WhiteSpace(ch);
    if (ERR_NOERROR != uRes)
        return uRes;

    // If the token following the white space is an opening brace,
    // parse out the contents, and verify the existance of the 
    // closing brace
    if ('(' == **ch)
    {
        while ((')' != **ch)) 
        {
            if (!GetToken(ch))
                return ERR_UNMATCHED_BRACE;
        }
        GetToken(ch);   // Purge closing brace
    }

    return ERR_NOERROR;
}

/******************************************************************
//
//      Static Functions
//
*******************************************************************/

UINT CConverter::Convert(const char* szString, CIMType ct, CVar *pVar)
/////////////////////////////////////////////////////////////////////
//
//  Convert is a static method that creates an instance of the 
//  Converter object and converts the string to a variant.  If an
//  error occurs, the value of pVar is not affected.
//
//  PARAMETERS: the input string (by val), the CIM type (by val) and
//  the outout variant (by ref)
//
//  RETURNS: the result state of the parsing
//
/////////////////////////////////////////////////////////////////////
{
    // Checks the CIM type is initialized
    if (NULL == ct)
        return ERR_NULL_CIMTYPE;

    CConverter converter(szString, ct); // The converter object
    CVar aVar;                          // Temp variant

    // Parse out the first number
    UINT uRes = converter.Token_Sequence(&aVar);
    // Check return code
    if (ERR_NOERROR != uRes)
        return uRes;

    // Parsing ok, copy temp to destination
    *pVar = aVar;
    
    return ERR_NOERROR;
}

UINT CConverter::Convert(const char* szString, CIMType ct, CVarVector *pVarVec)
/////////////////////////////////////////////////////////////////////
//
//  Convert is a static method that creates an instance of the 
//  Converter object and converts the string to an array of values.
//  If an error occurs, the value of pVarVec is not affected.
//
//  PARAMETERS: the input string (by val), the CIM type (by val) and
//  the outout variant vecter (by ref)
//
//  Returns the result state of the parsing
//
/////////////////////////////////////////////////////////////////////
{
    // Checks the CIM type is initialized
    if (NULL == ct)
        return ERR_NULL_CIMTYPE;

    CConverter converter(szString, ct); // The converter object
    CVarVector aVarVec;                 // Temp variant vector

    // Parse out the first number
    UINT uRes = converter.Token_Sequence(&aVarVec);
    // Check return code
    if (ERR_NOERROR != uRes)
        return uRes;

    // Parsing ok, copy temp to destination
    *pVarVec = aVarVec;
    
    return ERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_flexarry.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXARRAY.CPP

Abstract:

  CFlexArray and CWStringArray implementation.

  These objects can operate from any allocator, and be constructed
  on arbitrary memory blocks.

History:

  11-Apr-96   a-raymcc    Created.
  24-Apr-96   a-raymcc    Updated for CArena support.

--*/

#include "precomp.h"
#include <stdio.h>
#include <WT_flexarry.h>
#include "WT_strutils.h"
class CX_MemoryException
{
};

//***************************************************************************
//
//  CFlexArray::CFlexArray
//
//  Constructs the array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(
    int nSize, 
    int nGrowByPercent
    )
{
    m_nExtent = nSize;
    m_nSize = 0;
    m_nGrowByPercent = nGrowByPercent;
    if(nSize > 0)
    {
        m_pArray = 
            (void**)HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * nSize);

        // Check for allocation failures
        if ( NULL == m_pArray )
        {
            throw CX_MemoryException();
        }
    }
    else
        m_pArray = NULL;
}
    
//***************************************************************************
//
//  CFlexArray::~CFlexArray
//
//***************************************************************************
// ok
CFlexArray::~CFlexArray()
{
    HeapFree(GetProcessHeap(), 0, m_pArray);
}


//***************************************************************************
//
//  Copy constructor.
//  
//  Copies the pointers, not their contents.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(CFlexArray &Src)
{
    m_pArray = 0;
    m_nSize = 0;
    m_nExtent = 0;
    m_nGrowByPercent = 0;

    *this = Src;
}

//***************************************************************************
//
//  operator =
//
//  Assignment operator.
//
//  Arenas are not copied.  This allows transfer of arrays between arenas.
//  Arrays are copied by pointer only.
//
//***************************************************************************
// ok

CFlexArray& CFlexArray::operator=(CFlexArray &Src)
{
    m_nSize   = Src.m_nSize;
    m_nExtent = Src.m_nExtent;
    m_nGrowByPercent = Src.m_nGrowByPercent;

    HeapFree(GetProcessHeap(), 0, m_pArray);
    if(m_nExtent > 0)
    {
        m_pArray = 
           (void**)HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * m_nExtent);

        // Check for allocation failures
        if ( NULL == m_pArray )
        {
            throw CX_MemoryException();
        }

    }
    else
        m_pArray = NULL;
    memcpy(m_pArray, Src.m_pArray, sizeof(void *) * m_nSize);
        
    return *this;    
}

//***************************************************************************
//
//  CFlexArray::RemoveAt
//
//  Removes the element at the specified location.  Does not
//  actually delete the pointer. Shrinks the array over the top of
//  the 'doomed' element.
//
//  Parameters:
//  <nIndex>    The location of the element.
//    
//  Return value:
//  range_error     The index is not legal.
//  no_error        Success.
//  
//***************************************************************************
// ok

int CFlexArray::RemoveAt(int nIndex)
{
    if (nIndex >= m_nSize)
        return range_error;

    // Account for the index being 0 based and size being 1 based
    MoveMemory( &m_pArray[nIndex], &m_pArray[nIndex+1], ( ( m_nSize - nIndex ) - 1 ) * sizeof(void *) );
    
    m_nSize--;
    m_pArray[m_nSize] = 0;

    return no_error;
}

int CFlexArray::EnsureExtent(int nExtent)
{
    if(m_nExtent < nExtent)
    {
        m_nExtent = nExtent;
        if(m_pArray)
        {
            register void** pTmp = (void **) HeapReAlloc(GetProcessHeap(), 0, m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
                return out_of_memory;
            m_pArray =  pTmp;
        }
        else
            m_pArray = (void **) HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * m_nExtent);    
        if (!m_pArray)
            return out_of_memory;                
    }

    return no_error;
}
        
    
//***************************************************************************
//
//  CFlexArray::InsertAt
//
//  Inserts a new element at the specified location.  The pointer is copied.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to insert the new element.
//  <pSrc>          The pointer to copy. (contents are not copied).
//
//  Return value:
//  array_full
//  out_of_memory
//  no_error
//
//***************************************************************************
// ok

int CFlexArray::InsertAt(int nIndex, void *pSrc)
{
    // TEMP: fix for sparse functionality in stdprov
    // =============================================

    while(nIndex > m_nSize)
        Add(NULL);

    // If the array is full, we need to expand it.
    // ===========================================
    
    if (m_nSize == m_nExtent) {
        if (m_nGrowByPercent == 0)
            return array_full;
        register nTmpExtent = m_nExtent;
        m_nExtent += 1;
        m_nExtent *= (100 + m_nGrowByPercent);
        m_nExtent /= 100;

        if(m_pArray)
        {
            register void** pTmp = (void **) HeapReAlloc(GetProcessHeap(), 0, m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
            {
                m_nExtent = nTmpExtent; //Change it back, otherwise the extent could constantly grow even though  it keeps failing...
                return out_of_memory;
            }
            m_pArray =  pTmp;
        }
        else
            m_pArray = (void **) HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * m_nExtent);    
        if (!m_pArray)
            return out_of_memory;                
    }

    // Special case of appending.  This is so frequent
    // compared to true insertion that we want to optimize.
    // ====================================================
    
    if (nIndex == m_nSize) {
        m_pArray[m_nSize++] = pSrc;
        return no_error;
    }
    
    // If here, we are inserting at some random location.
    // We start at the end of the array and copy all the elements 
    // one position farther to the end to make a 'hole' for
    // the new element.
    // ==========================================================

    // Account for nIndex being 0 based and m_nSize being 1 based
    MoveMemory( &m_pArray[nIndex+1], &m_pArray[nIndex], ( m_nSize - nIndex ) * sizeof(void *) );

    m_pArray[nIndex] = pSrc;
    m_nSize++;
            
    return no_error;    
}

void CFlexArray::Sort()
{
    if(m_pArray)
        qsort((void*)m_pArray, m_nSize, sizeof(void*), CFlexArray::CompareEls);
}

int __cdecl CFlexArray::CompareEls(const void* pelem1, const void* pelem2)
{
    return *(int*)pelem1 - *(int*)pelem2;
}
//***************************************************************************
//
//  CFlexArray::DebugDump
//
//***************************************************************************
void CFlexArray::DebugDump()
{
    printf("----CFlexArray Debug Dump----\n");
    printf("m_pArray = 0x%P\n", m_pArray);
    printf("m_nSize = %d\n", m_nSize);
    printf("m_nExtent = %d\n", m_nExtent);
    printf("m_nGrowByPercent = %d\n", m_nGrowByPercent);

    for (int i = 0; i < m_nExtent; i++)
    {
        if (i < m_nSize)
            printf("![%P] = %X\n", i, m_pArray[i]);
        else
            printf("?[%P] = %X\n", i, m_pArray[i]);                    
    }        
}

//***************************************************************************
//
//  CFlexArray::Compress
//
//  Removes NULL elements by moving all non-NULL pointers to the beginning
//  of the array.  The array "Size" changes, but the extent is untouched.
//
//***************************************************************************
// ok

void CFlexArray::Compress()
{
    int nLeftCursor = 0, nRightCursor = 0;
    
    while (nLeftCursor < m_nSize - 1) {
        if (m_pArray[nLeftCursor]) {
            nLeftCursor++;
            continue;
        }
        else {
            nRightCursor = nLeftCursor + 1;
            while (m_pArray[nRightCursor] == 0 && nRightCursor < m_nSize)
                nRightCursor++;
            if (nRightCursor == m_nSize)
                break;  // Short circuit, no more nonzero elements.
            m_pArray[nLeftCursor] = m_pArray[nRightCursor];
            m_pArray[nRightCursor] = 0;                                            
        }                    
    }
    
    Trim();
}    

void CFlexArray::Trim()
{
    while (m_nSize >  0 && m_pArray[m_nSize - 1] == NULL) m_nSize--;
}

//***************************************************************************
//
//  CFlexArray::Empty
//
//  Clears the array of all pointers (does not deallocate them) and sets
//  its apparent size to zero.
//
//***************************************************************************
// ok
void CFlexArray::Empty()
{
    HeapFree(GetProcessHeap(), 0, m_pArray);
    m_pArray = NULL;
    m_nSize = 0;
    m_nExtent = 0;
}

//***************************************************************************
//
//  CFlexArray::UnbindPtr
//
//  Empties the array and returns the pointer to the data it contained
//
//***************************************************************************

void** CFlexArray::UnbindPtr()
{
    void** pp = m_pArray;
    m_pArray = NULL;
    Empty();
    return pp;
}

//***************************************************************************
//
//  CFlexArray::CopyData
//
//  Copies the data but not the settings of another flexarray
//
//***************************************************************************

int CFlexArray::CopyDataFrom(const CFlexArray& aOther)
{
    // Check if there is enough room
    // =============================

    if(aOther.m_nSize > m_nExtent)
    {
        // Extend the array to the requisite size
        // ======================================

        m_nExtent = aOther.m_nSize;
        if(m_pArray)
        {
            register void** pTmp = (void **) HeapReAlloc(GetProcessHeap(), 0, m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
                return out_of_memory;
            m_pArray =  pTmp;
        }
        else
            m_pArray = (void **) HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * m_nExtent);    
        if (!m_pArray)
            return out_of_memory;                
    }

    // Copy the data
    // =============

    m_nSize = aOther.m_nSize;
    memcpy(m_pArray, aOther.m_pArray, sizeof(void*) * m_nSize);
    return no_error;
}

//***************************************************************************
//
//  CWStringArray::CWStringArray
//
//  Constructs a wide-string array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************

CWStringArray::CWStringArray(
        int nSize, 
        int nGrowBy
        )
        : 
        m_Array(nSize, nGrowBy)
{
}        

//***************************************************************************
//
//  Copy constructor.
//
//***************************************************************************

CWStringArray::CWStringArray(CWStringArray &Src)
{
    
    *this = Src;    
}

//***************************************************************************
//
//  Destructor.  Cleans up all the strings.
//
//***************************************************************************

CWStringArray::~CWStringArray()
{
    Empty();
}

//***************************************************************************
//
//  CWStringArray::DeleteStr
//
//  Frees the string at the specified index and sets the element to NULL.  
//  Does not compress array.
// 
//  Does not currently do a range check.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the string to remove.
//
//  Return values:
//  no_error
//  
//***************************************************************************

int CWStringArray::DeleteStr(int nIndex)
{
    HeapFree(GetProcessHeap(), 0, m_Array[nIndex]);
    m_Array[nIndex] = 0;
    return no_error;
}   

//***************************************************************************
//
//  CWStringArray::FindStr
//
//  Finds the specified string and returns its location.
//
//  Parameters:
//  <pTarget>       The string to find.
//  <nFlags>        <no_case> or <with_case>
//  
//  Return value:
//  The 0-origin location of the string, or -1 if not found.
//
//***************************************************************************

int CWStringArray::FindStr(const wchar_t *pTarget, int nFlags)
{
    if (nFlags == no_case) {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wbem_wcsicmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    else {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wcscmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    return not_found;
}

//***************************************************************************
//
//  operator =
//  
//***************************************************************************

//  Heap handle & allocation functions are not copied. This allows
//  transfer of arrays between heaps.
         
CWStringArray& CWStringArray::operator =(CWStringArray &Src)
{
    Empty();
    
    for (int i = 0; i < Src.Size(); i++) 
    {
        wchar_t *pSrc = (wchar_t *) Src.m_Array[i];
        wchar_t *pCopy = (wchar_t *) HeapAlloc(GetProcessHeap, 0, (wcslen(pSrc) + 1) * 2);

        // Check for allocation failures
        if ( NULL == pCopy )
        {
            throw CX_MemoryException();
        }

        wcscpy(pCopy, pSrc);

        if ( m_Array.Add(pCopy) != CFlexArray::no_error )
        {
            throw CX_MemoryException();
        }
    }

    return *this;
}

//***************************************************************************
//
//  CWStringArray::Add
//
//  Appends a new string to the end of the array.
//
//  Parameters:
//  <pSrc>      The string to copy.
//
//  Return value:
//  The return values of CFlexArray::Add.
//  
//***************************************************************************
    
int CWStringArray::Add(const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) HeapAlloc(GetProcessHeap(), 0, (wcslen(pSrc) + 1) * 2);

    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wcscpy(pNewStr, pSrc);
    return m_Array.Add(pNewStr);
}
//***************************************************************************
//
//  CWStringArray::InsertAt
//
//  Inserts a copy of a string in the array.
//
//  Parameters:
//  <nIndex>    The 0-origin location at which to insert the string.
//  <pSrc>      The string to copy.
//
//  Return values:
//  The return values of CFlexArray::InsertAt
//
//***************************************************************************

int CWStringArray::InsertAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) HeapAlloc(GetProcessHeap(), 0, (wcslen(pSrc) + 1) * 2);

    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wcscpy(pNewStr, pSrc);
    return m_Array.InsertAt(nIndex, pNewStr);
}


//***************************************************************************
//
//  CWStringArray::RemoveAt
//
//  Removes and deallocates the string at the specified location.
//  Shrinks the array.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the 'doomed' string.
//  
//  Return value:
//  Same as CFlexArray::RemoveAt.
//
//***************************************************************************

int CWStringArray::RemoveAt(int nIndex)
{
    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    HeapFree(GetProcessHeap, 0, pDoomedString);
    return m_Array.RemoveAt(nIndex);
}

//***************************************************************************
//
//  CWStringArray::SetAt
//
//  Replaces the string at the targeted location with the new one.
//  The old string at the location is cleaned up.
//
//  No range checking or out-of-memory checks at present.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to replace the string.
//  <pSrc>          The string to copy.  
//
//  Return value:
//  no_error
//   
//***************************************************************************

int CWStringArray::SetAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) HeapAlloc(GetProcessHeap(), 0, (wcslen(pSrc) + 1) * 2);
    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    if (pDoomedString)
        delete [] pDoomedString;

    wcscpy(pNewStr, pSrc);
    m_Array[nIndex] = pNewStr;

    return no_error;
}

//***************************************************************************
//
//  CWStringArray::ReplaceAt
//
//  Directly replaces the pointer at the specified location with the
//  one in the parameter.   No copy or cleanup.
//
//  Parameters:
//  <nIndex>     The 0-origin location at which to replace.
//  <pSrc>       The new pointer to copy over the old one.
//
//  Return value:
//  no_error        (No checking done at present).
//  
//***************************************************************************

int CWStringArray::ReplaceAt(int nIndex, wchar_t *pSrc)
{
    m_Array[nIndex] = pSrc;
    return no_error;
}



//***************************************************************************
//
//  CWStringArray::Empty
//
//  Empties the array, deallocates all strings, and sets the apparent
//  array size to zero.
//
//***************************************************************************

void CWStringArray::Empty()
{
    for (int i = 0; i < m_Array.Size(); i++)
        HeapFree(GetProcessHeap(), 0, m_Array[i]);
    m_Array.Empty();        
}

//***************************************************************************
//
//  CWStringArray::Sort
//
//  Sorts the array according to UNICODE order.  
//  (Shell sort).
//
//***************************************************************************
void CWStringArray::Sort()
{
    for (int nInterval = 1; nInterval < m_Array.Size() / 9; nInterval = nInterval * 3 + 1);    

    while (nInterval) 
    {
        for (int iCursor = nInterval; iCursor < m_Array.Size(); iCursor++) 
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 &&
               wbem_wcsicmp((const wchar_t *) m_Array[iBackscan],
                    (const wchar_t *) m_Array[iBackscan-nInterval]) < 0) 
            {
                wchar_t *pTemp = (wchar_t *) m_Array[iBackscan - nInterval];
                m_Array[iBackscan - nInterval] = m_Array[iBackscan];
                m_Array[iBackscan] = pTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


//***************************************************************************
//
//  CWStringArray::Difference
//
//  Set-theoretic difference operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array which is 'subtracted' from first (not modified).    
//  <Diff>      Receives the difference.  Should be an empty array on entry.
//
//***************************************************************************
void CWStringArray::Difference(
    CWStringArray &Src1, 
    CWStringArray &Src2,
    CWStringArray &Diff
    )
{
    for (int i = 0; i < Src1.Size(); i++)
    {
        if (Src2.FindStr(Src1[i], no_case) == -1)
        {
            if ( Diff.Add(Src1[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
}

//***************************************************************************
//
//  CWStringArray::Intersection
//
//  Set-theoretic intersection operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the intersection.  Should be an empty array on entry.

//***************************************************************************

void CWStringArray::Intersection(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    for (int i = 0; i < Src1.Size(); i++)
    {
        if (Src2.FindStr(Src1[i], no_case) != -1)
        {
            if ( Output.Add(Src1[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }

    }
}    

//***************************************************************************
//
//  CWStringArray::Union
//
//  Set-theoretic union operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the union.  Should be an empty array on entry.
//
//***************************************************************************

void CWStringArray::Union(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    Output = Src1;
    for (int i = 0; i < Src2.Size(); i++)
    {
        if (Output.FindStr(Src2[i], no_case) == not_found)
        {
            if ( Output.Add(Src2[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_flexarry.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXARRAY.H

Abstract:

  CFlexArray and CWStringArray implementation.

  These objects can operate from any allocator, and be constructed
  on arbitrary memory blocks.

History:

  11-Apr-96   a-raymcc    Created.

--*/

#ifndef _FLEXARRY_H_
#define _FLEXARRY_H_

//***************************************************************************
//
//  class CFlexArray
//
//  This class is a generic pointer array.
//
//***************************************************************************

class CFlexArray
{
protected:
    int m_nSize;            // apparent size
    int m_nExtent;          // de facto size
    int m_nGrowByPercent;          
    void** m_pArray;
            
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };

    // Constructs a flex array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CFlexArray(
        IN int nInitialSize = 0, 
        IN int nGrowByPercent = 100
        );

   ~CFlexArray(); 
    CFlexArray(CFlexArray &);
    CFlexArray& operator=(CFlexArray &);

    int CopyDataFrom(const CFlexArray& aOther);
    int EnsureExtent(int nExtent);

    // Gets an element at a particular location.
    // =========================================
    inline void *  GetAt(int nIndex) const { return m_pArray[nIndex]; }

    // Returns a ptr in the array; allows use on left-hand side of assignment.
    // =======================================================================
    inline void * operator[](int nIndex) const { return m_pArray[nIndex]; }
    inline void *& operator[](int nIndex) { return m_pArray[nIndex]; }

    // Sets the element at the requested location.
    // ===========================================
    void inline SetAt(int nIndex, void *p) { m_pArray[nIndex] = p; }

    // Removes an element.
    // ====================
    int   RemoveAt(int nIndex);

    // Inserts an element.
    // ===================
    int   InsertAt(int nIndex, void *);

    // Removes all zero entries (null ptrs) and shrinks the array size.
    // ================================================================
    void  Compress();    

    // Removes all zero entries from the end of the array and shrinks it
    // =================================================================

    void Trim();

    // Adds a new element to the end of the array.
    // ===========================================
    int inline Add(void *pSrc) { return InsertAt(m_nSize, pSrc); }    

    // Gets the apparent size of the array (number of used elements)
    // =============================================================
    int inline Size() const { return m_nSize; }

    // Sets the apparent size of the array
    // ===================================
    void inline SetSize(int nNewSize) { m_nSize = nNewSize;}

    // Removes all entries and reduces array size to zero. The elements
    // are simply removed; not deallocated (this class doesn't know what
    // they are).
    // =================================================================
    void  Empty();

    // Gets a pointer to the internal array.
    // =====================================
    inline void**  GetArrayPtr() { return m_pArray; }
    inline void* const*  GetArrayPtr() const { return m_pArray; }
    
    // Gets a pointer to the internal array and Resets the contents to none
    // ====================================================================

    void** UnbindPtr();

    // For debugging.
    // ==============
    void  DebugDump();

    void Sort();

protected:
    static int __cdecl CompareEls(const void* pelem1, const void* pelem2);
};

//***************************************************************************
//
//  class CWStringArray
//
//  This class is a generic wide-string array.
//
//***************************************************************************


class CWStringArray
{
    CFlexArray m_Array;
    
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };
    enum { not_found = -1, no_case, with_case };
        
    CWStringArray(
        int nSize = 0, 
        int nGrowBy = 100
        );

    CWStringArray(CWStringArray &Src);
   ~CWStringArray();
            
    CWStringArray& operator =(CWStringArray &Src);

    // Gets the read-only ptr to the string at the requested index.
    // =============================================================    
    inline wchar_t *GetAt(int nIndex) const { return (wchar_t *) m_Array[nIndex]; }

    // Same as GetAt().
    // ================
    inline wchar_t *operator[](int nIndex) const{ return (wchar_t *) m_Array[nIndex]; }

    // Appends a new element to the end of the array. Copies the param.
    // ================================================================
    int  Add(const wchar_t *pStr);

    // Inserts a new element within the array.
    // =======================================
    int  InsertAt(int nIndex, const wchar_t *pStr);

    // Removes an element at the specified index.  Takes care of
    // cleanup.
    // =========================================================
    int  RemoveAt(int nIndex);

    // Inserts a copy of <pStr> at that location after removing
    // the prior string and deallocating it.
    // ========================================================
    int  SetAt(int nIndex, const wchar_t *pStr);

    // Directly replaces the pointer at the specified location
    // with the ptr value in <pStr>. No allocs or deallocs are done.
    // =============================================================
    int  ReplaceAt(int nIndex, wchar_t *pStr);
        // Unchecked replacement

    // Deletes the string at the location and sets the entry to zero
    // without compressing the array.
    // =============================================================
    int  DeleteStr(int nIndex);  

    // Returns the 'apparent' size of the array.
    // =========================================
    inline int  Size() const { return m_Array.Size(); }

    // Empties the array by cleaning up after all strings and
    // setting the size to zero.
    // ======================================================
    void Empty();

    // Locates a string or returns -1 if not found.
    // ============================================
    int  FindStr(const wchar_t *pTarget, int nFlags);  

    // Compresses the array by removing all zero elements.
    // ===================================================
    inline void Compress() { m_Array.Compress(); }

    // Sorts the array according to UNICODE order.
    // ===========================================
    void Sort();

    inline LPCWSTR*  GetArrayPtr() { return (LPCWSTR*) m_Array.GetArrayPtr(); }

    // Standard set-theoretic operations.
    // ==================================
    static void Difference(
        CWStringArray &Src1, 
        CWStringArray &Src2,
        CWStringArray &Diff
        );

    static void Intersection(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );

    static void Union(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_safearry.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SAFEARRY.CPP

Abstract:

  CSafeArray implementation.

  Notes:
  (1) Support only for arrays with origin at 0 or 1.
      Can VB deal with a SAFEARRAY of origin zero?

  (2) Support only for the following OA types:
        VT_BSTR, VT_VARIANT,
        VT_UI1, VT_I2, VT_I4, VT_R8

History:

    08-Apr-96   a-raymcc    Created.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#include "precomp.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <WT_safearry.h>
#include <WT_arrtempl.h>

typedef struct 
{
    DWORD m_nMaxElementUsed;
    DWORD m_nFlags;
    DWORD m_nGrowBy;
    DWORD m_nStatus;
    DWORD m_nVarType;
    SAFEARRAYBOUND m_bound;    
}   PersistHeaderBlock;


//***************************************************************************
//  
//  CSafeArray::CheckType
//
//  Verifies that the constructor is being invoked with a supported type.
//
//  PARAMETERS:
//  nTest
//      One of the supported OLE VT_ constants.
//
//***************************************************************************
void CSafeArray::CheckType(int nTest)
{
    if (nTest != VT_BSTR &&
        nTest != VT_VARIANT &&
        nTest != VT_UI1 &&
        nTest != VT_I2 &&
        nTest != VT_I4 &&
        nTest != VT_R4 &&
        nTest != VT_R8 &&
        nTest != VT_BOOL &&
        nTest != VT_DISPATCH &&
        nTest != VT_UNKNOWN        
        )
        Fatal("Caller attempted to use unsupported OLE Automation Type (VT_*)");
}

//***************************************************************************
//
//  CSafeArray::CSafeArray
//
//  Constructor which creates a new SAFEARRAY.
//
//  PARAMETERS:
//  vt
//      An OLE VT_ type indicator, indicating the element type.
//  nFlags
//      The destruct policy, either <no_delete> or <auto_delete>.  With
//      <no_delete>, the underlying SAFEARRAY is not deallocated, whereas
//      with <auto_delete> the destructor destroys the SAFEARRAY.
//  nSize
//      The initial size of the SAFEARRAY.
//  nGrowBy
//      The amount the SAFEARRAY should grow by when the user attempts to
//      add elements to a full array.
//
//***************************************************************************

CSafeArray::CSafeArray(
    IN int vt,
    IN int nFlags,
    IN int nSize,
    IN int nGrowBy
    )
{
    CheckType(vt);

    m_nMaxElementUsed = -1;
    m_nFlags = nFlags;
    m_nGrowBy = nGrowBy;
    m_nVarType = vt;

    // Allocate the array.
    // ===================

    m_bound.cElements = nSize;
    m_bound.lLbound = 0;

    m_pArray = SafeArrayCreate(vt, 1, &m_bound);

    if (m_pArray == 0)
        m_nStatus = failed;
    else
        m_nStatus = no_error;
}

//***************************************************************************
//
//  CSafeArray::CSafeArray
//
//  Constructor based on an existing SAFEARRAY.
//
//  PARAMETERS:
//  pSrc
//      A pointer to an existing SAFEARRAY which is used as a source
//      during object construction.
//  nType
//      One of the OLE VT_ type indicators.
//  nFlags
//      OR'ed Bit flags indicating the bind vs. copy, and the 
//      object destruct policy.
//
//      The destruct policy is either <no_delete> or <auto_delete>.  With
//      <no_delete>, the underlying SAFEARRAY is not deallocated, whereas
//      with <auto_delete> the destructor destroys the SAFEARRAY.
//
//      Binding is indicated by <bind>, in which case the SAFEARRAY
//      pointed to by <pSrc> becomes the internal SAFEARRAY of the
//      object.  Otherwise, this constructor makes a new copy of the
//      SAFEARRAY for internal use.
//  nGrowBy
//      How much to grow the array by when it fills and the user attempts
//      to add more elements.  This allows the array to grow in chunks
//      so that continuous Add() operations do not operate slowly on
//      large arrays.
//
//***************************************************************************

CSafeArray::CSafeArray(
    IN SAFEARRAY *pSrcCopy,
    IN int nType,
    IN int nFlags,
    IN int nGrowBy
    )
{
    m_nStatus = no_error;

    CheckType(nType);

    // Verify that this is only a 1-dimensional array.
    // ===============================================

    if (1 != SafeArrayGetDim(pSrcCopy))
        m_nStatus = failed;

    // Now copy the source or 'bind' the incoming array.
    // ====================================================

    if (nFlags & bind)
        m_pArray = pSrcCopy;
    else if (SafeArrayCopy(pSrcCopy, &m_pArray) != S_OK)
        m_nStatus = failed;

    // Get bound information.
    // ======================

    LONG uBound = 0;
    if (S_OK != SafeArrayGetUBound(m_pArray, 1, &uBound))
        m_nStatus = failed;

    // Correct the Upper Bound into a size.
    // ====================================

    m_bound.cElements = uBound + 1;
    m_bound.lLbound = 0;
    m_nMaxElementUsed = uBound;
    m_nVarType = nType;
    m_nGrowBy = nGrowBy;
    m_nFlags = nFlags & 3;  // Mask out the acquire & copy bits.
}


//***************************************************************************
//
//  CSafeArray::GetScalarAt
//
//  For class internal use.  This function returns the element at
//  the specified index.
//  
//  PARAMETERS:
//  nIndex
//      The index at which to retrieve the scalar.
//
//  RETURN VALUE:
//  The scalar at the specified the location.
//
//***************************************************************************
SA_ArrayScalar CSafeArray::GetScalarAt(IN int nIndex)
{
    SA_ArrayScalar retval = {0};

    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return retval;

    SafeArrayGetElement(m_pArray, (long *) &nIndex, &retval);
    return retval;
}


//***************************************************************************
//
//  CSafeArray assignment operator.
//
//***************************************************************************

CSafeArray& CSafeArray::operator =(IN CSafeArray &Src)
{
    Empty();

    m_nMaxElementUsed = Src.m_nMaxElementUsed;
    m_nFlags = Src.m_nFlags;
    m_nGrowBy = Src.m_nGrowBy;
    m_nStatus = Src.m_nStatus;
    m_nVarType = Src.m_nVarType;
    m_bound = Src.m_bound;

    if (SafeArrayCopy(Src.m_pArray, &m_pArray) != S_OK)
        m_nStatus = failed;

    return *this;
}

//***************************************************************************
//
//  Copy constructor.
//
//  This is implemented primarily via the assignment operator.
//
//***************************************************************************

CSafeArray::CSafeArray(CSafeArray &Src)
{
    m_nMaxElementUsed = 0;
    m_nFlags = 0;
    m_nGrowBy = 0;
    m_nStatus = no_error;
    m_nVarType = VT_NULL;
    m_pArray = 0;
    m_bound.cElements = 0;
    m_bound.lLbound = 0;

    *this = Src;
}


//***************************************************************************
//
//  CSafeArray::Add
//
//  Adds the BSTR to the array, growing the array if required.
//
//  PARAMETERS:
//  Src
//      The source BSTR to add to the array.  If NULL, then a
//      blank string is added by the underlying SAFEARRAY implementation.
//      (there is no way to prevent this).  This can point to 
//      an LPWSTR as well.
//
//  RETURN VALUE:
//  <no_error> or <failed>.
//
//***************************************************************************

int CSafeArray::AddBSTR(IN BSTR Src)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;

        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    BSTR Copy = SysAllocString(Src);
    CSysFreeMe auto1(Copy);

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, Copy) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddVariant
//
//  Adds the specified VARIANT to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source VARIANT, which is copied.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddVariant(IN VARIANT *pSrc)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pSrc) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddDispatch
//
//  Adds the specified IDispatch* to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source IDispatch*, which is AddRefed.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddDispatch(IN IDispatch *pDisp)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pDisp) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddUnknown
//
//  Adds the specified IUnknown* to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source IUnknown*, which is AddRefed.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddUnknown(IN IUnknown *pUnk)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pUnk) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}



//***************************************************************************
//
//  CSafeArray::GetBSTRAt
//
//  If the array type is VT_BSTR, this returns the string at the specified
//  index.
//
//  PARAMETERS:
//  nIndex
//      The array index for which the string is requried.
//
//  RETURN VALUE:
//  A dynamically allocated BSTR which must be freed with SysFreeString.
//  NULL is returned on error. If NULL was originally added at this
//  location, a string with zero length will be returned, which still
//  must be freed with SysFreeString.
//
//***************************************************************************

BSTR CSafeArray::GetBSTRAt(int nIndex)
{
    BSTR StrPtr = 0;

    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != SafeArrayGetElement(m_pArray, (long *) &nIndex, &StrPtr))
        return NULL;

    return StrPtr;
}


//***************************************************************************
//
//  CSafeArray::GetVariantAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the VARIANT.
//  
//  RETURN VALUE:
//  Returns a new VARIANT at the specified location.  The receiver must
//  call VariantClear() on this VARIANT when it is no longer used.
//
//***************************************************************************

VARIANT CSafeArray::GetVariantAt(int nIndex)
{
    VARIANT Var;
    VariantInit(&Var);

    if (nIndex >= (int) m_bound.cElements)
        return Var;

    if (S_OK != SafeArrayGetElement(m_pArray, (long *) &nIndex, &Var))
        return Var;

    return Var;
}

//***************************************************************************
//
//  CSafeArray::GetDispatchAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the IDispatch*.
//  
//  RETURN VALUE:
//  Returns the IDispatch* at the specified location.  The receiver must
//  call Release on this pointer (if not NULL) when it is no longer used.
//
//***************************************************************************

IDispatch* CSafeArray::GetDispatchAt(int nIndex)
{
    IDispatch* pDisp;
    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != SafeArrayGetElement(m_pArray, (long *) &nIndex, &pDisp))
        return NULL;

    return pDisp;
}

//***************************************************************************
//
//  CSafeArray::GetUnknownAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the IUnknown*.
//  
//  RETURN VALUE:
//  Returns the IUnknown* at the specified location.  The receiver must
//  call Release on this pointer (if not NULL) when it is no longer used.
//
//***************************************************************************

IUnknown* CSafeArray::GetUnknownAt(int nIndex)
{
    IUnknown* pUnk;
    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != SafeArrayGetElement(m_pArray, (long *) &nIndex, &pUnk))
        return NULL;

    return pUnk;
}

//***************************************************************************
//
//  CSafeArray::SetAt
//
//  Replaces the BSTR value at the specified array index.   The original
//  BSTR value is automatically deallocated and replaced by the new value.
//  You can only call this to replace an existing element or to add a
//  new element to the end (one position past the last element).  If the
//  array size is 10, you can call this with 0..10, but not 11 or higher.
//
//  PARAMETERS:
//  nIndex
//      The position at which to replace the element.
//  Str
//      The new string.
//  nFlags
//      If <acquire> this function acquires ownership of the string and
//      can delete it.  Otherwise, the caller retains ownership of the
//      string.
//
//  RETURN VALUE:
//  no_error
//  range_error
//  failed
//
//***************************************************************************
int CSafeArray::SetBSTRAt(
    IN int nIndex,
    IN BSTR Str
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddBSTR(Str);

    BSTR Copy = SysAllocString(Str);
    CSysFreeMe auto1(Copy);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, Copy) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetVariantAt
//
//  Sets the VARIANT at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the VARIANT.  The original contents
//      at this location are automatically deallocated and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetVariantAt(
    IN int nIndex,
    IN VARIANT *pVal
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddVariant(pVal);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, pVal) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetDispatchAt
//
//  Sets the IDispatch* at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the IDispatch*.  The original contents
//      at this location are automatically Released and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetDispatchAt(
    IN int nIndex,
    IN IDispatch *pDisp
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddDispatch(pDisp);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, pDisp) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetUnknownAt
//
//  Sets the IUnknown* at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the IUnknown*.  The original contents
//      at this location are automatically Released and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetUnknownAt(
    IN int nIndex,
    IN IUnknown *pUnk
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddUnknown(pUnk);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, pUnk) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::RemoveAt
//
//  Removes the element at the specified index.  After a series of these
//  operations, the caller should call the Trim() function.
//
//  PARAMETERS:
//  nIndex
//      The target index for element removal.
//
//  RETURN VALUE:
//      no_error, range_error
//
//***************************************************************************
int CSafeArray::RemoveAt(IN int nIndex)
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Copy element n+1 into n.
    // ========================

    BSTR strVal;
    VARIANT v;
    SA_ArrayScalar scalar;
    IDispatch* pDisp;
    IUnknown* pUnk;

    for (long i = nIndex; i < m_nMaxElementUsed; i++) {
        long nNext = i + 1;

        if (m_nVarType == VT_BSTR) {
            SafeArrayGetElement(m_pArray, &nNext, &strVal);
            SafeArrayPutElement(m_pArray, &i, strVal);
            SysFreeString(strVal);
        }
        else if (m_nVarType == VT_VARIANT) {
            SafeArrayGetElement(m_pArray, &nNext, &v);
            SafeArrayPutElement(m_pArray, &i, &v);
            VariantClear(&v);
        }
        else if (m_nVarType == VT_DISPATCH) {
            SafeArrayGetElement(m_pArray, &nNext, &pDisp);
            SafeArrayPutElement(m_pArray, &i, pDisp);
            if(pDisp) pDisp->Release();
        }            
        else if (m_nVarType == VT_UNKNOWN) {
            SafeArrayGetElement(m_pArray, &nNext, &pUnk);
            SafeArrayPutElement(m_pArray, &i, pUnk);
            if(pUnk) pUnk->Release();
        }            
        else {
            SafeArrayGetElement(m_pArray, &nNext, &scalar);
            SafeArrayPutElement(m_pArray, &i, &scalar);
        }
    }

    m_nMaxElementUsed--;
    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetScalarAt
//
//  For class internal use.  Sets the scalar type at the specified index.
//  
//  PARAMETERS:
//  nIndex
//      The target index.
//  val
//      The new value.
//
//  RETURN VALUES:
//  range_error, failed, no_error    
//
//***************************************************************************
int CSafeArray::SetScalarAt(IN int nIndex, IN SA_ArrayScalar val)
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddScalar(val);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, &val) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddScalar
//
//  For class internal use only.
//
//  Adds a new scalar to the 'end' of the array, growing it if required
//  and if possible.
//
//  PARAMETERS:
//  val
//      The new value.
//
//  RETURN VALUE:
//  no_error, range_error, failed
//
//***************************************************************************
int CSafeArray::AddScalar(IN SA_ArrayScalar val)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;

        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, &val) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}



//***************************************************************************
//
//  CSafeArray::Empty
//
//  Empties the SAFEARRAY.
//
//***************************************************************************
void CSafeArray::Empty()
{
    m_nMaxElementUsed = 0;
    m_nFlags = 0;
    m_nGrowBy = 0;
    m_nStatus = no_error;
    m_nVarType = VT_NULL;
    if (m_pArray)
        SafeArrayDestroy(m_pArray);
    m_pArray = 0;
    m_bound.cElements = 0;
    m_bound.lLbound = 0;
}

//***************************************************************************
//
//  CSafeArray::GetArrayCopy
//
//  RETURN VALUE:
//  A copy of the internal SAFEARRAY or NULL on error.
//
//***************************************************************************
SAFEARRAY *CSafeArray::GetArrayCopy()
{
    SAFEARRAY *pCopy = 0;
    if (SafeArrayCopy(m_pArray, &pCopy) != S_OK)
        return 0;
    return pCopy;
}

//***************************************************************************
//
//  CSafeArray destructor.
//
//  If the internal flags are set to auto_delete, then the internal
//  SAFEARRAY is destroyed during destruction.
//
//***************************************************************************
CSafeArray::~CSafeArray()
{
    if (m_nFlags == auto_delete)
        SafeArrayDestroy(m_pArray);
}


//***************************************************************************
//
//  CSafeArray::Trim
//
//***************************************************************************
int CSafeArray::Trim()
{                                           
    m_bound.cElements = m_nMaxElementUsed + 1;

    // HACK for NT 3.51: may not redimention to size 0
    // ===============================================

    if(m_bound.cElements == 0)
    {
        SafeArrayDestroy(m_pArray);
        m_pArray = SafeArrayCreate(m_nVarType, 1, &m_bound);
    }
    else
    {
        SafeArrayRedim(m_pArray, &m_bound);
    }

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
void CSafeArray::Fatal(const char *pszMsg)
{
//    MessageBox(0, pszMsg, "CSafeArray FATAL Error",
//        MB_OK | MB_SYSTEMMODAL | MB_ICONEXCLAMATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_safearry.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SAFEARRY.H

Abstract:

  CSafeArray implementation.

History:

	08-Apr-96   a-raymcc    Created.
	18-Mar-99	a-dcrews	Added out-of-memory exception handling

--*/

#ifndef _SAFEARRY_H_
#define _SAFEARRY_H_


typedef union 
{ 
    double dblVal; 
    float fltVal; 
    short iVal; 
    long lVal; 
    BYTE bVal; 
    VARIANT_BOOL boolVal;
}   SA_ArrayScalar;            

// Conversion functions due to VC 5.0 Optimizer Problems
inline SA_ArrayScalar ToSA_ArrayScalar( double dblVal )
{	SA_ArrayScalar sa;	sa.dblVal = dblVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalar( float fltVal )
{	SA_ArrayScalar sa;	sa.fltVal = fltVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalar( short iVal )
{	SA_ArrayScalar sa;	sa.iVal = iVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalar( long lVal )
{	SA_ArrayScalar sa;	sa.lVal = lVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalar( BYTE bVal )
{	SA_ArrayScalar sa;	sa.bVal = bVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalarBool( VARIANT_BOOL boolVal )
{	SA_ArrayScalar sa;	sa.boolVal = boolVal;	return sa;	}


class  CSafeArray
{
    int m_nMaxElementUsed;
    int m_nFlags;
    int m_nGrowBy;
    int m_nStatus;
    int m_nVarType;
    SAFEARRAYBOUND m_bound;    
    SAFEARRAY *m_pArray;
    
    void Empty();                    // Empty array
    void Fatal(const char *);
    void CheckType(int n);
    int  AddScalar(IN SA_ArrayScalar val);
    int  SetScalarAt(IN int nIndex, IN SA_ArrayScalar val);
    SA_ArrayScalar GetScalarAt(IN int nIndex);
        
public:
    enum { no_error, failed, range_error };
    enum { no_delete = 0x1, auto_delete = 0x2, bind = 0x4 };

    
    // Construction, destruction, and assignment.
    // ==========================================
        
    CSafeArray(
        IN int vt, 
        IN int nFlags,          // no_delete|auto_delete
        IN int nSize = 32, 
        IN int nGrowBy = 32
        );

    CSafeArray(
        IN SAFEARRAY *pSrc, 
        IN int nType,           // VT_ type of SAFEARRAY.
        IN int nFlags,          // no_delete|auto_delete [|bind]
        IN int nGrowBy = 32
        );

    CSafeArray &operator =(IN CSafeArray &Src);
    CSafeArray(IN CSafeArray &Src);
   ~CSafeArray();
    
    // Get functions.
    // ==============    

    BYTE    GetByteAt(IN int nIndex)
        { return GetScalarAt(nIndex).bVal; }
    LONG    GetLongAt(IN int nIndex)
        { return GetScalarAt(nIndex).lVal; }
    SHORT   GetShortAt(IN int nIndex)
        { return GetScalarAt(nIndex).iVal; }
    double  GetDoubleAt(IN int nIndex)
        { return GetScalarAt(nIndex).dblVal; }
    float   GetFloatAt(IN int nIndex)
        { return GetScalarAt(nIndex).fltVal; }
    VARIANT_BOOL GetBoolAt(IN int nIndex)
        { return GetScalarAt(nIndex).boolVal; }        

    BSTR    GetBSTRAt(IN int nIndex);          // Caller must use SysFreeString
    VARIANT GetVariantAt(IN int nIndex);      // 
    IDispatch* GetDispatchAt(IN int nIndex);
    IUnknown* GetUnknownAt(IN int nIndex);

    // Set functions.
    // ==============
        
    int SetByteAt(IN int nIndex, IN BYTE byVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(byVal)); }
    int SetLongAt(IN int nIndex, IN LONG lVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(lVal)); }
    int SetFloatAt(IN int nIndex, IN float fltVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(fltVal)); }
    int SetDoubleAt(IN int nIndex, IN double dVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(dVal)); }    
    int SetShortAt(IN int nIndex, IN SHORT iVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(iVal)); }        
    int SetBoolAt(IN int nIndex, IN VARIANT_BOOL boolVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalarBool(boolVal)); }        

    int SetBSTRAt(IN int nIndex, IN BSTR Str);     // A copy of the BSTR is made
    int SetVariantAt(IN int nIndex, IN VARIANT *pSrc);
    int SetDispatchAt(IN int nIndex, IN IDispatch* pDisp);
    int SetUnknownAt(IN int nIndex, IN IUnknown* pUnk);
    
    // Add (append) functions.
    // =======================
    
    int AddByte(IN BYTE byVal)  { return AddScalar(ToSA_ArrayScalar(byVal)); }
    int AddLong(IN LONG lVal)   { return AddScalar(ToSA_ArrayScalar(lVal)); }
    int AddFloat(IN float fltVal) { return AddScalar(ToSA_ArrayScalar(fltVal)); }
    int AddDouble(IN double dVal) { return AddScalar(ToSA_ArrayScalar(dVal)); }
    int AddShort(IN SHORT iVal)  { return AddScalar(ToSA_ArrayScalar(iVal)); }
    int AddBool(IN VARIANT_BOOL boolVal) { return AddScalar(ToSA_ArrayScalarBool(boolVal)); }
    int AddBSTR(IN BSTR Str);
    int AddVariant(IN VARIANT *pData);
    int AddDispatch(IN IDispatch* pDisp);
    int AddUnknown(IN IUnknown* pUnk);
    
    // Operations the array as a whole. 
    // ================================

    int RemoveAt(IN int nIndex);                    
    int Size()    { return m_nMaxElementUsed + 1; }
    int GetType() { return m_nVarType; }
    int Status()  { return m_nStatus; }
    int Trim();                    
    void SetGrowGranularity(IN int n)  { m_nGrowBy = n; }
    void SetDestructorPolicy(IN int n) { m_nFlags = n; }   // auto_delete|no_delete
            
    SAFEARRAY *GetArrayCopy();                 // Returns a copy of the array
    SAFEARRAY *GetArray() { return m_pArray; }

    int TextDump(IN FILE *fStream);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_strutils.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    STRUTILS.H

Abstract:

	String utilities

History:

--*/

#ifndef __WBEM_STRING_UTILS__H_
#define __WBEM_STRING_UTILS__H_

#pragma optimize("gt", on)

/*
inline int wbem_towlower(wint_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return towlower(c);
}
*/

#define wbem_towlower(C) \
    (((C) >= 0 && (C) <= 127)?          \
        (((C) >= 'A' && (C) <= 'Z')?          \
            ((C) + ('a' - 'A')):          \
            (C)          \
        ):          \
        towlower(C)          \
    )          

inline int wbem_towupper(wint_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return towupper(c);
}

inline int wbem_tolower(int c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return tolower(c);
}

inline int wbem_toupper(int c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return toupper(c);
}

inline int wbem_wcsicmp(const wchar_t* wsz1, const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

// just like wcsicmp, but first 0 of unicode chracters have been omitted
inline int wbem_ncsicmp(const char* wsz1, const char* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower((unsigned char)*wsz1) - 
                    wbem_towlower((unsigned char)*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_wcsnicmp(const wchar_t* wsz1, const wchar_t* wsz2, size_t n)
{
    while(n-- && (*wsz1 || *wsz2))
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_stricmp(const char* sz1, const char* sz2)
{
    while(*sz1 || *sz2)
    {
        int diff = wbem_tolower(*sz1) - wbem_tolower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

inline int wbem_strnicmp(const char* sz1, const char* sz2, size_t n)
{
    while(n-- && (*sz1 || *sz2))
    {
        int diff = wbem_tolower(*sz1) - wbem_tolower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

#pragma optimize("", off)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_var.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    VAR.H

Abstract:

  CVar & CVarVector.


  These are thread-safe translators for VARIANT and SAFEARRAY
  and represent all types support by WBEM.

  These are mutually nestable to any level.  A CVarVector can contain 
  an array of CVar, and a CVar can contain a CVarVector.    One CVar
  can therefore contain a whole tree of CVar objects, themselves
  containing homogeneous or heterogeneous arrays of CVar objects.

  Note: CVar should not be bound to one type and then immediately
  coerced to a new type.  This object is designed for speed, not safety,
  so there is no checking to see if this has been done.  A memory leak
  is likely to occur.

  The assignment operator and copy constructors are the only method
  of changing the type on a CVar.  Do NOT construct the object as
  a BSTR, for example, and then call SetDWORD.

History:

	16-Apr-96   a-raymcc    Created.
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.
	18-Mar-99	a-dcrews	Added out-of-memory exception handling

--*/

#ifndef _VAR_H_
#define _VAR_H_

#include <WT_flexarry.h>
//#include <safearry.h>


#define VT_EX_CVAR           (VT_USERDEFINED | 0x80010000)
#define VT_EX_CVARVECTOR     (VT_USERDEFINED | 0x80010002)


class CVarVector;

typedef union
{
    char     cVal;          // VT_I1
    BYTE     bVal;          // VT_UI1
    SHORT    iVal;          // VT_I2
    WORD     wVal;          // VT_UI2
    LONG     lVal;          // VT_I4
    DWORD    dwVal;         // VT_UI4
    VARIANT_BOOL boolVal;   // VT_BOOL    

    float    fltVal;        // VT_R4
    double   dblVal;        // VT_R8

    LPSTR    pStr;          // VT_LPSTR
    LPWSTR   pWStr;         // VT_LPWSTR
    BSTR     Str;           // VT_BSTR      (stored as VT_LPWSTR)
    
    FILETIME Time;          // VT_FILETIME
    BLOB   Blob;            // VT_BLOB        
    LPCLSID  pClsId;        // VT_CLSID
    IUnknown* pUnk;         // VT_UNKNOWN
    IDispatch* pDisp;       // VT_DISPATCH
    CVarVector *pVarVector; // VT_EX_CVARVECTOR
        
}   METAVALUE;


class CVar  
{
    int m_vt;
    METAVALUE m_value;
    int m_nStatus;    
    BOOL m_bCanDelete;
    
    void Init();
public:
    enum { no_error, unsupported, failed };
    
    CVar() { Init(); } 
   ~CVar();
    CVar(CVar &);
    CVar& operator =(CVar &);

    CVar(char c)            { Init(); SetChar(c); }
    CVar(BYTE b)            { Init(); SetByte(b); }
    CVar(SHORT s)           { Init(); SetShort(s); }
    CVar(WORD w)            { Init(); SetWord(w); }
    CVar(LONG l)            { Init(); SetLong(l); }
    CVar(DWORD dw)          { Init(); SetDWORD(dw); }     
    CVar(float f)           { Init(); SetFloat(f); }
    CVar(double d)          { Init(); SetDouble(d); }
    CVar(VARIANT_BOOL b,int){ Init(); SetBool(b); }

    CVar(LPSTR p, BOOL bAcquire = FALSE)  
        { Init(); SetLPSTR(p, bAcquire); }

    CVar(LPWSTR p, BOOL bAcquire = FALSE)          
        { Init(); SetLPWSTR(p, bAcquire); }
        
    CVar(int, BSTR b, BOOL bAcquire = FALSE)       
        { Init(); SetBSTR(b, bAcquire); }      
        // Dummy int required for context, since BSTR is also LPWSTR
        // from Win32 point of view, although the VT_ indicators differ.
        
    CVar(CLSID *p, BOOL bAcquire = FALSE)  
        { Init(); SetClsId(p, bAcquire); }

    CVar(BLOB *p, BOOL bAcquire = FALSE)           
        { Init(); SetBlob(p, bAcquire); }
        
    CVar(FILETIME *p)       { Init(); SetFileTime(p); }

    CVar(CVarVector *p, BOOL bAcquire = FALSE) { Init(); SetVarVector(p, bAcquire); }
    CVar(VARIANT *p)        { Init(); SetVariant(p); }    
    CVar(int nType, SAFEARRAY *p) { Init(); SetSafeArray(nType, p); }
    int Status() { return m_nStatus; }

    int  DumpText(FILE *fStream);
    int  GetType() { return m_vt; }
    int  GetOleType();
    void Empty();

    int operator ==(CVar &Other);
    BOOL CompareTo(CVar& Other, BOOL bIgnoreCase);


    void SetRaw(int vt, void* pvData, int nDataLen);
    void* GetRawData() {return (void*)&m_value;}
    BOOL CanDelete() {return m_bCanDelete;}
    void SetCanDelete(BOOL bCanDelete) {m_bCanDelete = bCanDelete;}

    // Numeric types.
    // ==============
    
    void SetAsNull() { m_vt = VT_NULL; m_value.lVal = 0; }
    BOOL IsNull() {return m_vt == VT_NULL;}
    BOOL IsDataNull();
    
    void SetChar(char c) { m_vt = VT_I1; m_value.cVal = c; }
    char GetChar() { return m_value.cVal; }
    operator char() { return m_value.cVal; }
    
    void SetByte(BYTE b) { m_vt = VT_UI1; m_value.bVal = b; }
    BYTE GetByte() { return m_value.bVal; }
    operator BYTE() { return m_value.bVal; }
    
    void  SetShort(SHORT iVal) { m_vt = VT_I2; m_value.iVal = iVal; }
    SHORT GetShort() { return m_value.iVal; }
    operator SHORT() { return m_value.iVal; }
    
    void SetWord(WORD wVal) { m_vt = VT_UI2; m_value.wVal = wVal; }
    WORD GetWord() { return m_value.wVal; }
    operator WORD() { return m_value.wVal; }
    
    void SetLong(LONG lVal) { m_value.lVal = lVal; m_vt = VT_I4; }
    LONG GetLong() { return m_value.lVal; }
    operator LONG() { return m_value.lVal; }
    
    void SetDWORD(DWORD dwVal) { m_value.dwVal = dwVal; m_vt = VT_UI4; }
    DWORD GetDWORD() { return m_value.dwVal; }
    operator DWORD() { return m_value.dwVal; }
    
    void SetBool(VARIANT_BOOL b) { m_value.boolVal = b; m_vt = VT_BOOL; }
    VARIANT_BOOL GetBool() { return m_value.boolVal; }

    void SetFloat(float f) { m_value.fltVal = f; m_vt = VT_R4; }
    float GetFloat() { return m_value.fltVal; }
    operator float() { return m_value.fltVal; }
    
    void   SetDouble(double dblVal) { m_value.dblVal = dblVal; m_vt = VT_R8; }
    double GetDouble() { return m_value.dblVal; }
    operator double() { return m_value.dblVal; }

    void SetDispatch(IDispatch* pDisp);
    IDispatch* GetDispatch() 
    {if(m_value.pDisp) m_value.pDisp->AddRef(); return m_value.pDisp;}
    
    void SetUnknown(IUnknown* pUnk);
    IUnknown* GetUnknown() 
    {if(m_value.pUnk) m_value.pUnk->AddRef(); return m_value.pUnk;}

    void SetEmbeddedObject(IUnknown* pUnk) {SetUnknown(pUnk);}
    IUnknown* GetEmbeddedObject() {return GetUnknown();}

    int SetVariant(VARIANT *pSrc);

    void FillVariant(VARIANT* pDest);
    VARIANT *GetNewVariant();    
    
    // String types.
    // =============
    
    BOOL  SetLPWSTR(LPWSTR pVal, BOOL bAcquire = FALSE);
    wchar_t *GetLPWSTR() { return m_value.pWStr; }
    operator LPWSTR() { return m_value.pWStr; }    
    
    BOOL  SetLPSTR(LPSTR pStr, BOOL bAcquire = FALSE);
    LPSTR GetLPSTR() { return m_value.pStr; }
    operator LPSTR() { return m_value.pStr; }
    
    BOOL SetBSTR(BSTR str, BOOL bAcquire = FALSE);
    BSTR GetBSTR();     // Makes a dynamic copy which must be freed.
    
    // Misc. types.
    // ============
    
    void SetFileTime(FILETIME *pft) { m_value.Time = *pft; m_vt = VT_FILETIME; }
    FILETIME GetFileTime() { return m_value.Time; }
    operator FILETIME() { return m_value.Time; }    
    
    void SetBlob(BLOB *pBlob, BOOL bAcquire = FALSE);
    BLOB *GetBlob() { return &m_value.Blob; }
    operator BLOB *() { return &m_value.Blob; }        
    
    void SetClsId(CLSID *pClsId, BOOL bAcquire);
    CLSID* GetClsId() { return m_value.pClsId; }    // Return value is read-only
    operator CLSID*() { return m_value.pClsId; }    // Return value is read-only    
    
    void SetVarVector(CVarVector *pVec, BOOL bAcquire);
    CVarVector *GetVarVector()  { return m_value.pVarVector; }  
    operator CVarVector *()  { return m_value.pVarVector; }  
    
    void SetSafeArray(int nType, SAFEARRAY *pArray); // Copies the source
    SAFEARRAY *GetNewSafeArray();   // New SAFEARRAY which must be released

    static BSTR TypeToText(int nType);
    BSTR GetTypeText();
    BSTR GetText(long lFlags, long lType = 0);

    BOOL ChangeTypeTo(VARTYPE vtNew);
    BOOL ChangeTypeToEx(VARTYPE vtNew, LCID lcid = 0x409 );
    BOOL ToSingleChar();
    BOOL ToUI4();
};


class  CVarVector
{
    int         m_nType;
    CFlexArray  m_Array;
    int         m_nStatus;
public:
    enum { no_error, failed, unsupported };

    CVarVector();    
    CVarVector(int nVarType, int nInitSize = 32, int nGrowBy = 32);

    // These two only support limited SAFEARRAY types.
    // ===============================================

    CVarVector(int nVarType, SAFEARRAY *pSrc);
    SAFEARRAY *GetNewSafeArray();

    int  GetType() { return m_nType; }        
    int  Status() { return m_nStatus; }
    void Empty();
                    
   ~CVarVector();
    CVarVector(CVarVector &Src);
    CVarVector& operator =(CVarVector &Src);
    int operator ==(CVarVector &Src);     
    BOOL CompareTo(CVarVector& Other, BOOL bIgnoreCase);
    int Size() { return m_Array.Size(); }

    int    Add(CVar &Value);  
    int    Add(CVar *pAcquiredPtr);
    CVar&  GetAt(int nIndex) { return *(CVar *) m_Array[nIndex]; }
    CVar&  operator [](int nIndex)  { return *(CVar *) m_Array[nIndex]; }
    int    RemoveAt(int nIndex);
    int    InsertAt(int nIndex, CVar &Value);

    BSTR GetText(long lFlags, long lType = 0);
    BOOL ToSingleChar();
    BOOL ToUI4();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_wstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WSTRING.CPP

Abstract:

    Utility string class

History:

    a-raymcc    30-May-96       Created.
    a-dcrews    16-Mar-99       Added out-of-memory exception handling

--*/

#include "precomp.h"
#include <stdio.h>
#include <WT_wstring.h>

class CX_MemoryException
{
};

static wchar_t g_szNullString[1] = {0};

inline void WString::DeleteString(wchar_t *pStr)
{
    if (pStr != g_szNullString)
        delete [] pStr;
}

WString::WString()
{ 
    m_pString = g_szNullString; 
}
WString::WString(wchar_t *pSrc, BOOL bAcquire)
{
    if (bAcquire) {
        m_pString = pSrc;
        if (m_pString == 0)
            m_pString = g_szNullString;
        return;            
    }

    if (pSrc == 0) {
        m_pString = g_szNullString;
        return;
    }

    m_pString = new wchar_t[wcslen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, pSrc);
}

WString::WString(DWORD dwResourceID, HMODULE hMod)
{
    int iSize = 100;
    BOOL bNotDone = TRUE;
    TCHAR* pTemp = NULL;

    // load the string from the string table.  Since we dont know what size, try increasing the
    // buffer till it works, or until the clearly obsurd case is hit

    while (iSize < 10240)
    {
        pTemp = new TCHAR [iSize];

        // Watch for allocation failures
        if ( NULL == pTemp )
        {
            throw CX_MemoryException();
        }

        int iRead = LoadString(hMod, dwResourceID, pTemp, iSize);
        if(iRead == 0)
        {
            // Bad string

            m_pString = g_szNullString;
            delete [] pTemp;
            return;
        }
        if(iRead +1 < iSize)
            break;      // all is well;
        iSize += 100;    // Try again
        delete [] pTemp;
        pTemp = NULL;
    }

#ifdef UNICODE
//For unicode, this is the string we need!
    m_pString = pTemp;
#else
//Only have to convert if we are not using unicode, otherwise it is already in wide mode!
    if(pTemp)
    {   
        // got a narrow string, allocate a large string buffer and convert

        long len = mbstowcs(NULL, pTemp, lstrlen(pTemp)+1) + 1;
        m_pString = new wchar_t[len];

        // Watch for allocation failures
        if ( NULL == m_pString )
        {
            delete [] pTemp;
            throw CX_MemoryException();
        }

        mbstowcs(m_pString, pTemp, lstrlen(pTemp)+1);
        delete [] pTemp;
    }
    else
        m_pString = g_szNullString;
#endif

}


WString::WString(const wchar_t *pSrc)
{
    if (pSrc == 0) {
        m_pString = g_szNullString;
        return;
    }

    m_pString = new wchar_t[wcslen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, pSrc);
}

WString::WString(const char *pSrc)
{
    m_pString = new wchar_t[strlen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    mbstowcs(m_pString, pSrc, strlen(pSrc) + 1);
//    swprintf(m_pString, L"%S", pSrc);
}

LPSTR WString::GetLPSTR() const
{
    long len = 2*(wcslen(m_pString) + 1);
    char *pTmp = new char[len];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcstombs(pTmp, m_pString, len);
//    sprintf(pTmp, "%S", m_pString);
    return pTmp;
}

WString& WString::operator =(const WString &Src)
{
    DeleteString(m_pString);
    m_pString = new wchar_t[wcslen(Src.m_pString) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, Src.m_pString);
    return *this;    
}

WString& WString::operator =(LPCWSTR pSrc)
{
    DeleteString(m_pString);
    m_pString = new wchar_t[wcslen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, pSrc);
    return *this;    
}

WString& WString::operator +=(const wchar_t *pOther)
{
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 
            wcslen(pOther) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcscpy(pTmp, m_pString);
    wcscat(pTmp, pOther);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}

WString& WString::operator +=(wchar_t NewChar)
{
    wchar_t Copy[2];
    Copy[0] = NewChar;
    Copy[1] = 0;
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 2];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcscpy(pTmp, m_pString);
    wcscat(pTmp, Copy);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}


WString& WString::operator +=(const WString &Other)
{
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 
            wcslen(Other.m_pString) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcscpy(pTmp, m_pString);
    wcscat(pTmp, Other.m_pString);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}


wchar_t WString::operator[](int nIndex) const
{
    if (nIndex >= (int) wcslen(m_pString))
        return 0;
    return m_pString[nIndex];        
}


WString& WString::TruncAtRToken(wchar_t Token)
{
    for (int i = (int) wcslen(m_pString); i >= 0; i--) {
        wchar_t wc = m_pString[i];
        m_pString[i] = 0;
        if (wc == Token)
            break;
    }
    
    return *this;        
}


WString& WString::TruncAtLToken(wchar_t Token)
{
    int nStrlen = wcslen(m_pString);
    for (int i = 0; i < nStrlen ; i++) 
    {
        if (Token == m_pString[i])
        {
            m_pString[i] = 0;
            break;
        }        
    }
    
    return *this;        
}


WString& WString::StripToToken(wchar_t Token, BOOL bIncludeToken)
{
    int nStrlen = wcslen(m_pString);
    wchar_t *pTmp = new wchar_t[nStrlen + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    *pTmp = 0;

    BOOL bFound = FALSE;
        
    for (int i = 0; i < nStrlen; i++) {
        if (m_pString[i] == Token) {
            bFound = TRUE;
            break;    
        }            
    }    

    if (!bFound)
        return *this;
        
    if (bIncludeToken) i++;
    wcscpy(pTmp, &m_pString[i]);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;
}

LPWSTR WString::UnbindPtr()
{
    if (m_pString == g_szNullString)
    {
        m_pString = new wchar_t[1];

        // Watch for allocation failures
        if ( NULL == m_pString )
        {
            throw CX_MemoryException();
        }

        *m_pString = 0;
    }
    wchar_t *pTmp = m_pString;
    m_pString = g_szNullString;
    return pTmp;
}

WString& WString::StripWs(int nType)
{
    if (nType & leading)
    {
        wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 1];

        // Watch for allocation failures
        if ( NULL == pTmp )
        {
            throw CX_MemoryException();
        }

        int i = 0;
        while (iswspace(m_pString[i]) && m_pString[i]) i++;
        wcscpy(pTmp, &m_pString[i]);
        DeleteString(m_pString);
        m_pString = pTmp;
    }
               
    if (nType & trailing)
    {
        wchar_t *pCursor = m_pString + wcslen(m_pString) - 1;
        while (pCursor >= m_pString && iswspace(*pCursor)) 
            *pCursor-- = 0;
    }
    return *this;
}

wchar_t *WString::GetLToken(wchar_t Tok) const
{
    wchar_t *pCursor = m_pString;
    while (*pCursor && *pCursor != Tok) pCursor++;
    if (*pCursor == Tok)
        return pCursor;
    return 0;                
}

WString WString::operator()(int nLeft, int nRight) const
{
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wchar_t *pCursor = pTmp;
        
    for (int i = nLeft; i < (int) wcslen(m_pString) && i <= nRight; i++)
        *pCursor++ = m_pString[i];
    *pCursor = 0;

    return WString(pTmp, TRUE);        
}

BOOL WString::ExtractToken(const wchar_t * pDelimiters, WString &Extract)
{
    if(pDelimiters == NULL)
    {
        Extract.Empty();
        return FALSE;
    }

    // Find which character in the list works.  Use the first if none are
    // present

    int nLen = wcslen(m_pString);
    int nDimLen = wcslen(pDelimiters);

    for (int i = 0; i < nLen; i++)
        for(int j = 0; j < nDimLen; j++)
            if (m_pString[i] == pDelimiters[j])
                return ExtractToken(pDelimiters[j], Extract);

    // If none were found, just use the first.

    return ExtractToken(*pDelimiters, Extract);

}
 
BOOL WString::ExtractToken(wchar_t Delimiter, WString &Extract)
{
    int i, i2;
    BOOL bTokFound = FALSE;
    Extract.Empty();
    int nLen = wcslen(m_pString);
    wchar_t *pTmp = new wchar_t[nLen + 1];
    
    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    for (i = 0; i < nLen; i++)
        if (m_pString[i] == Delimiter) {
            bTokFound = TRUE;
            break;    
        }            
        else
            pTmp[i] = m_pString[i];            

    pTmp[i] = 0;
    Extract.BindPtr(pTmp);                      
                                              
    // Now make *this refer to any leftover stuff.
    // ===========================================
    pTmp = new wchar_t[nLen - wcslen(pTmp) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    *pTmp = 0;

    for (i2 = 0, i++; i <= nLen; i++)
        pTmp[i2++] = m_pString[i];

    DeleteString(m_pString);
    m_pString = pTmp;
    
    // Return TRUE if the token was encountered, FALSE if not.
    // =======================================================
    return bTokFound;
}

void WString::Empty()
{
    DeleteString(m_pString);
    m_pString = g_szNullString;
}

static int _WildcardAux(const wchar_t *pszWildstr, const wchar_t *pszTargetstr, 
    int iGreedy)
{
    enum { start, wild, strip } eState;
    wchar_t cInput, cInputw, cLaToken;
    
    if (!wcslen(pszTargetstr) || !wcslen(pszWildstr))
        return 0;
                
    for (eState = start;;)
        switch (eState)
        {
            case start:
                cInputw = *pszWildstr++;        // wildcard input 
                cInput = *pszTargetstr;         // target input 

                if (!cInputw)                   // at end of wildcard string? 
                    goto EndScan;

                // Check for wildcard chars first 
                   
                if (cInputw == L'?') {          // Simply strips both inputs 
                    if (!cInput)                // If end of input, error 
                        return 0;
                    pszTargetstr++;
                    continue;
                }
                if (cInputw == L'*')  {
                    eState = wild;                
                    break;
                }

                // If here, an exact match is required.                 

                if (cInput != cInputw)
                    return 0;
                    
                // Else remain in same state, since match succeeded 
                pszTargetstr++;
                break;

            case wild:
                cLaToken = *pszWildstr++;   // Establish the lookahead token 
                eState = strip;
                break;

            case strip:
                cInput = *pszTargetstr;

                if (cInput == cLaToken) {
                    if (!cInput)            // Match on a NULL 
                        goto EndScan;
                    ++pszTargetstr;  

                    // If there is another occurrence of the lookahead 
                    // token in the string, and we are in greedy mode,
                    // stay in this state 

                    if (!iGreedy)
                        eState = start;

                    if (!wcschr(pszTargetstr, cLaToken))
                        eState = start;

                    break;
                }
                    
                if (cLaToken && !cInput)    // End of input with a non-null la token 
                    return 0;

                ++pszTargetstr;             // Still stripping input 
                break;
        }


    //  Here if the wildcard input is exhausted.  If the
    //  target string is also empty, we have a match,
    //  otherwise not. 

EndScan:
    if (wcslen(pszTargetstr))
        return 0; 

    return 1;   
}

// Run the test both with greedy and non-greedy matching, allowing the
// greatest possible chance of a match. 

BOOL WString::WildcardTest(const wchar_t *pszWildstr) const
{
    return (_WildcardAux(pszWildstr, m_pString, 0) | 
            _WildcardAux(pszWildstr, m_pString, 1));
}


void WString::Unquote()
{
    if (!m_pString)
        return;
    int nLen = wcslen(m_pString);
    if (nLen == 0)
        return;

    // Remove trailing quote.
    // ======================
    
    if (m_pString[nLen - 1] == L'"')
        m_pString[nLen - 1] = 0;

    // Remove leading quote.
    // =====================
    
    if (m_pString[0] == L'"')
    {
        for (int i = 0; i < nLen; i++)
            m_pString[i] = m_pString[i + 1];
    }
}

WString WString::EscapeQuotes() const
{
    WString ws;

    int nLen = Length();
    for(int i = 0; i < nLen; i++)
    {
        if(m_pString[i] == '"' || m_pString[i] == '\\')
        {
            ws += L'\\';
        }

        ws += m_pString[i];
    }

    return ws;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_var.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    VAR.H

Abstract:

  CVar & CVarVector implemntation

History:

    16-Apr-96   a-raymcc    Created.
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>

#include <WT_var.h>
#include <wbemidl.h>
#include <WT_arrtempl.h>
//#include <olewrap.h>
#include "WT_SafeArry.h"
class CX_MemoryException
{
};
class CX_Exception
{
};
typedef BYTE* LPMEMORY;
BLOB BlobCopy(BLOB *pSrc)
{
    BLOB Blob;
    BYTE *p = new BYTE[pSrc->cbSize];

    // Check for allocation failure
    if ( NULL == p )
    {
        throw CX_MemoryException();
    }

    Blob.cbSize = pSrc->cbSize;
    Blob.pBlobData = p;
    memcpy(p, pSrc->pBlobData, Blob.cbSize);
    return Blob;
}
#define BlobLength(p)  ((p)->cbSize)
#define BlobDataPtr(p) ((p)->pBlobData)
void  BlobClear(BLOB *pSrc)
{
    if (pSrc->pBlobData) 
        delete pSrc->pBlobData;

    pSrc->pBlobData = 0;
    pSrc->cbSize = 0;
}
HRESULT WbemVariantChangeType(VARIANT* pvDest, VARIANT* pvSrc, 
                                        VARTYPE vtNew)
{
    HRESULT hres;

    if(V_VT(pvSrc) == VT_NULL)
    {
        return VariantCopy(pvDest, pvSrc);
    }

    if(vtNew & VT_ARRAY)
    {
        // It's an array, we have to do our own conversion
        // ===============================================

        if((V_VT(pvSrc) & VT_ARRAY) == 0)
            return DISP_E_TYPEMISMATCH;

        SAFEARRAY* psaSrc = V_ARRAY(pvSrc);

        SAFEARRAYBOUND aBounds[1];

        long lLBound;
        SafeArrayGetLBound(psaSrc, 1, &lLBound);

        long lUBound;
        SafeArrayGetUBound(psaSrc, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        SAFEARRAY* psaDest = SafeArrayCreate(vtNew & ~VT_ARRAY, 1, aBounds);

        // Stuff the individual data pieces
        // ================================

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================

            VARIANT vSrcEl;
            V_VT(&vSrcEl) = V_VT(pvSrc) & ~VT_ARRAY;
            SafeArrayGetElement(psaSrc, &lIndex, &V_UI1(&vSrcEl));

            // Cast it to the new type
            // =======================

            hres = VariantChangeType(&vSrcEl, &vSrcEl, 0, vtNew & ~VT_ARRAY);
            if(FAILED(hres)) 
            {
                SafeArrayDestroy(psaDest);
                return hres;
            }

            // Put it into the new array
            // =========================

            if(V_VT(&vSrcEl) == VT_BSTR)
            {
                hres = SafeArrayPutElement(psaDest, &lIndex, V_BSTR(&vSrcEl));
            }
            else
            {
                hres = SafeArrayPutElement(psaDest, &lIndex, &V_UI1(&vSrcEl));
            }
            if(FAILED(hres)) 
            {
                SafeArrayDestroy(psaDest);
                return hres;
            }
        }

        if(pvDest == pvSrc)
        {
            VariantClear(pvSrc);
        }

        V_VT(pvDest) = vtNew;
        V_ARRAY(pvDest) = psaDest;

        return TRUE;
    }
    else
    {
        // Not an array. Can use OLE functions
        // ===================================

        return VariantChangeType(pvDest, pvSrc, VARIANT_NOVALUEPROP, vtNew);
    }
}


//***************************************************************************
//
//  CVar::Empty
//
//  Constructor helper.
//
//  This merely clears everything.  VT_EMPTY is the default.
//
//***************************************************************************

void CVar::Init()
{
    m_nStatus = no_error; 
    m_vt = VT_EMPTY;
    m_bCanDelete = TRUE;
    memset(&m_value, 0, sizeof(METAVALUE));
}


//***************************************************************************
//
//  CVar::~CVar
//
//  Destructor.
//
//***************************************************************************

CVar::~CVar()
{
    Empty();
}



//***************************************************************************
//
//  CVar::CVar
//
//  Copy constructor.  This is implemented via the assignment operator.
//  
//***************************************************************************

CVar::CVar(CVar &Src)
{
    m_vt = VT_EMPTY;
    m_nStatus = no_error; 
    memset(&m_value, 0, sizeof(METAVALUE));
    *this = Src;
}

//***************************************************************************
//
//  CVar::operator =
//
//  NOTES:
//  Observe that VT_EX_CVARVECTOR is dedicated to embedded CVarVector objects.
//  Also, only pointer types require a new allocation + copy, whereas
//  most of the simple types are directly assignable, in the <default>
//  label of the switch statement.
//
//***************************************************************************

CVar& CVar::operator =(CVar &Src)
{
    Empty();

    m_vt = Src.m_vt;
    m_nStatus = m_nStatus;
    m_bCanDelete = TRUE;

    switch (m_vt) {
        case VT_LPSTR:

            // Check for an allocation failure
            if ( NULL != Src.m_value.pStr )
            {
                m_value.pStr = new char[strlen(Src.m_value.pStr) + 1];

                if ( NULL == m_value.pStr )
                {
                    throw CX_MemoryException();
                }
                strcpy( m_value.pStr, Src.m_value.pStr );
            }
            else
            {
                m_value.pStr = NULL;
            }

            break;

        case VT_LPWSTR:
        case VT_BSTR:
            // Check for an allocation failure
            if ( NULL != Src.m_value.pWStr )
            {
                m_value.pWStr = new wchar_t[wcslen(Src.m_value.pWStr) + 1];

                if ( NULL == m_value.pWStr )
                {
                    throw CX_MemoryException();
                }
                wcscpy( m_value.pWStr, Src.m_value.pWStr );
            }
            else
            {
                m_value.pWStr = NULL;
            }

            break;

        case VT_BLOB:
            // This will natively throw an exception, but make sure the
            // original value is cleared in case an exception is thrown
            // so we don't AV destructing this object
            ZeroMemory( &m_value.Blob, sizeof( m_value.Blob ) );
            m_value.Blob = BlobCopy(&Src.m_value.Blob);
            break;

        case VT_CLSID:
            m_value.pClsId = new CLSID(*Src.m_value.pClsId);

            // Check for a failed allocation
            if ( NULL == m_value.pClsId )
            {
                throw CX_MemoryException();
            }

            break;

        case VT_DISPATCH:
            m_value.pDisp = Src.m_value.pDisp;
            if(m_value.pDisp) m_value.pDisp->AddRef();
            break;

        case VT_UNKNOWN:
            m_value.pUnk = Src.m_value.pUnk;
            if(m_value.pUnk) m_value.pUnk->AddRef();
            break;

        // CVarVector
        // ==========

        case VT_EX_CVARVECTOR:
            m_value.pVarVector = new CVarVector(*Src.m_value.pVarVector);

            // Check for a failed allocation
            if ( NULL == m_value.pVarVector )
            {
                throw CX_MemoryException();
            }

            break;

        // All remaining simple types. 
        // ===========================
        default:        
            m_value = Src.m_value;
    }

    return *this;
}

//***************************************************************************
//
//  CVar::operator ==
//
//  Equality test operator.
//
//***************************************************************************

int CVar::operator ==(CVar &Src)
{
    return CompareTo(Src, TRUE);
}

BOOL CVar::CompareTo(CVar& Src, BOOL bIgnoreCase)
{
    // If types are not the same, forget the test.
    // ===========================================

    if (m_vt != Src.m_vt)
        return 0;

    // If here, the types are the same, so test
    // the fields.
    // ========================================

    switch (m_vt) {
        case VT_LPSTR:
            if(bIgnoreCase)
            {
                if (wbem_stricmp(m_value.pStr, Src.m_value.pStr) == 0)
                    return 1;
            }
            else
            {
                if (strcmp(m_value.pStr, Src.m_value.pStr) == 0)
                    return 1;
            }

            break;

        case VT_LPWSTR:
        case VT_BSTR:
            if(bIgnoreCase)
            {
                if (wbem_wcsicmp(m_value.pWStr, Src.m_value.pWStr) == 0)
                    return 1;
            }
            else
            {
                if (wcscmp( m_value.pWStr, Src.m_value.pWStr) == 0)
                    return 1;
            }
            break;

        case VT_BLOB:
            if (BlobLength(&m_value.Blob) != BlobLength(&Src.m_value.Blob))
                return 0;
            if (memcmp(BlobDataPtr(&m_value.Blob), BlobDataPtr(&Src.m_value.Blob),
                BlobLength(&m_value.Blob)) == 0)
                return 1;                            
            break;

        case VT_CLSID:
            if (memcmp(m_value.pClsId, Src.m_value.pClsId, sizeof(CLSID)) == 0)
                return 1;
            break;
    
        // CVarVector
        // ==========

        case VT_EX_CVARVECTOR:
            if (m_value.pVarVector == Src.m_value.pVarVector)
                return 1;
            if (m_value.pVarVector == 0 || Src.m_value.pVarVector == 0)
                return 0;
            return *m_value.pVarVector == *Src.m_value.pVarVector;

        // All remaining simple types. 
        // ===========================

        case VT_I1: 
            return m_value.cVal == Src.m_value.cVal;
        case VT_UI1:
            return m_value.bVal == Src.m_value.bVal;
        case VT_I2:
            return m_value.iVal == Src.m_value.iVal;
        case VT_UI2:
            return m_value.wVal == Src.m_value.wVal;
        case VT_I4:
            return m_value.lVal == Src.m_value.lVal;
        case VT_UI4:
            return m_value.dwVal == Src.m_value.dwVal;
        case VT_BOOL:
            return m_value.boolVal == Src.m_value.boolVal;
        case VT_R8:
            return m_value.dblVal == Src.m_value.dblVal;
        case VT_R4:
            return m_value.fltVal == Src.m_value.fltVal;
        case VT_DISPATCH:
            // Note: no proper comparison of embedded objects.
            return m_value.pDisp == Src.m_value.pDisp;
        case VT_UNKNOWN:
            // Note: no proper comparison of embedded objects.
            return m_value.pUnk == Src.m_value.pUnk;
        case VT_FILETIME:
            if (memcmp(&m_value.Time, &Src.m_value.Time, sizeof(FILETIME)) == 0)
                return 1;
        case VT_NULL:
            return 1;
    }

    return 0;    
}


//***************************************************************************
//
//  CVar::Empty
//
//  Clears the CVar to 'empty', deallocates any objects based on pointers, 
//  unless bCanDelete is set to FALSE, indicating that the stored pointer
//  is owned by somebody else.
//
//***************************************************************************

void CVar::Empty()
{
    if(m_bCanDelete)
    {
        // Only pointer types require a deallocation phase.
        // =================================================

        switch (m_vt) {
            case VT_LPSTR:       delete m_value.pStr; break;
            case VT_LPWSTR:      delete m_value.pWStr; break;
            case VT_BSTR:        delete m_value.Str; break;
            case VT_BLOB:        BlobClear(&m_value.Blob); break;
            case VT_CLSID:       delete m_value.pClsId; break;
            case VT_EX_CVARVECTOR: delete m_value.pVarVector; break;
            case VT_DISPATCH:    if(m_value.pDisp) m_value.pDisp->Release(); break;
            case VT_UNKNOWN:    if(m_value.pUnk) m_value.pUnk->Release(); break;
        }
    }

    memset(&m_value, 0, sizeof(METAVALUE)); 
    m_vt = VT_EMPTY;
    m_nStatus = no_error;
    m_bCanDelete = TRUE;
}

//***************************************************************************
//
//  CVar::IsDataNull
//
//  Determines if this CVar contains a NULL pointer.
//
//***************************************************************************
BOOL CVar::IsDataNull()
{
    if(m_vt == VT_LPWSTR && m_value.pWStr == NULL)
        return TRUE;
    if(m_vt == VT_LPSTR && m_value.pStr == NULL)
        return TRUE;
    if(m_vt == VT_BSTR && m_value.Str == NULL)
        return TRUE;
    if(m_vt == VT_DISPATCH && m_value.pDisp == NULL)
        return TRUE;
    if(m_vt == VT_UNKNOWN && m_value.pUnk == NULL)
        return TRUE;

    return FALSE;
}
//***************************************************************************
//
//  CVar::SetRaw
//
//  Creates a CVar from raw data. Sets the type and copies the right
//  number of bytes from the source to METAVALUE.
//
//***************************************************************************

void CVar::SetRaw(int vt, void* pvData, int nDataLen)
{
    m_vt = vt;
    memcpy(&m_value, pvData, nDataLen);
    m_nStatus = no_error;
    m_bCanDelete = TRUE;
}

//***************************************************************************
//
//  CVar::SetSafeArray
//
//  PARAMETERS:
//  nType  
//      This is the VT_ type indicator of the SAFEARRAY.    
//  pArray 
//      This is the pointer to the SAFEARRAY which will be used as
//      a source.  The SAFEARRAY is not acquired; it is copied.
//
//***************************************************************************

void CVar::SetSafeArray(int nType, SAFEARRAY *pArray)
{
    CVarVector *pVec = NULL;
    m_nStatus = no_error;

    try
    {
        pVec = new CVarVector(nType, pArray);

        // Check for a failed allocation
        if ( NULL == pVec )
        {
            throw CX_MemoryException();
        }

        SetVarVector(pVec, TRUE);
    }
    catch (CX_MemoryException)
    {
        // SetVarVector can throw an exception
        // m_value aquires the pVec pointer, so auto delete will not work

        if (NULL != pVec)
        {
            delete pVec;
            pVec = NULL;
        }

        throw;
    }
}


//***************************************************************************
//
//  CVar::GetNewSafeArray
//
//  RETURN VALUE:
//  A pointer to newly allocated SAFEARRAY which must be released by
//  SafeArrayDestroy.
//
//***************************************************************************

SAFEARRAY *CVar::GetNewSafeArray()
{
    CVarVector *p = (CVarVector *) GetVarVector();
    return p->GetNewSafeArray();
}


//***************************************************************************
//
//  CVar::SetValue
//  
//  Sets the value based on an incoming VARIANT.  A VARIANT containing
//  a SAFEARRAY is supported as long as it is not an array of VARIANTs.
//  Some of the other VARIANT types, such as IUnknown, Currency, etc.,
//  are not supported.  The complete list is:
//      VT_UI1, VT_I2, VT_I4, VT_BSTR, VT_BOOL
//      VT_R4, VT_R8, or SAFEARRAY of any of these.
//
//  PARAMETERS:
//  pSrc 
//      A pointer to the source VARIANT.  This is treated as read-only.
//
//  RETURN VALUES:
//  no_error
//      Returned on succcess.
//  unsupported
//      Returned if the VARIANT contains unsupported types.
//
//***************************************************************************

int CVar::SetVariant(VARIANT *pSrc)
{
    if(pSrc == NULL)
    {
        SetAsNull();
        return no_error;
    }

    // If a SAFEARRAY, check it.
    // =========================

    if (pSrc->vt & VT_ARRAY) 
    {
        CVarVector *pVec = NULL;

        try
        {
            int nType = pSrc->vt & 0xFF;    // Find the type of the array

            // BEGIN MODIFIED by a-levn

            // First, check if the incoming SAFEARRAY is NULL
            // ==============================================

            SAFEARRAY *pSafeArr;
    /*
            if(pSrc->parray == NULL)
            {
                pSafeArr = NULL;
            }
            else
            {
                // Make a copy of the SAFEARRAY using CSafeArray which will NOT 
                // autodestruct
                // ============================================================

                CSafeArray array(pSrc->parray, nType, CSafeArray::no_delete, 0);
                pSafeArr = array.GetArray();
            }

    */
            pSafeArr = pSrc->parray;

            // Goal: Convert the SAFEARRAY to a CVarVector.
            // Use CVarVector itself to do the conversion.
            // ===========================================

            pVec = new CVarVector(nType, pSafeArr);

            // Check for an allocation failure.
            if ( NULL == pVec )
            {
                throw CX_MemoryException();
            }

            // END MODIFIED

            if (pVec->Status() != no_error) 
            {

                // If here, the SAFEARRAY was not compatible.
                // ==========================================
  
                delete pVec;
                pVec = NULL;
                m_nStatus = unsupported;
                m_vt = VT_EMPTY;
                return unsupported;
            }

            SetVarVector(pVec, TRUE);
            return no_error;
        }
        catch(CX_MemoryException)
        {
            // new and SetVarVector can throw exceptions
            // m_value aquires the pVec pointer, so an auto delete will not work

            if (NULL != pVec)
            {
                delete pVec;
                pVec = NULL;
            }

            throw;
        }
    }

    // Simple copies.
    // ==============

    switch (pSrc->vt) {
        case VT_NULL:
            SetAsNull();
            return no_error;

        case VT_UI1:
            SetByte(pSrc->bVal);
            return no_error;

        case VT_I2:
            SetShort(pSrc->iVal);
            return no_error;
        
        case VT_I4:
            SetLong(pSrc->lVal);
            return no_error;

        case VT_R4:
            SetFloat(pSrc->fltVal);
            return no_error;

        case VT_R8:        
            SetDouble(pSrc->dblVal);
            return no_error;

        case VT_BSTR:
            SetBSTR(pSrc->bstrVal);
            return no_error;

        case VT_BOOL:
            SetBool(pSrc->boolVal);
            return no_error;

        case VT_DISPATCH:
            SetDispatch(V_DISPATCH(pSrc));
            return no_error;

        case VT_UNKNOWN:
            SetUnknown(V_UNKNOWN(pSrc));
            return no_error;
    }

    m_nStatus = unsupported;
    return unsupported;
}

//***************************************************************************
//
//  CVar::GetNewVariant
//  
//  RETURN VALUE:
//  A pointer to a new VARIANT which contains the value of object.
//  If the original value was a SAFEARRAY, then the VARIANT will contain
//  the embedded SAFEARRAY.
//      
//***************************************************************************

void CVar::FillVariant(VARIANT* pNew)
{
    switch (m_vt) {
        case VT_NULL:
            V_VT(pNew) = VT_NULL;
            break;

        case VT_BOOL:
            V_VT(pNew) = VT_BOOL;
            V_BOOL(pNew) = (m_value.boolVal ? VARIANT_TRUE : VARIANT_FALSE);
            break;
            
        case VT_BSTR:

            // Set type afterwards here so if the SysAlloc throws an exception, the
            // type will not have been reset to a VT_BSTR which could cause a subtle
            // memory corruption (or worse) if VariantClear is called - SJS

            V_BSTR(pNew) = SysAllocString(m_value.Str);
            V_VT(pNew) = VT_BSTR;
            break;

        case VT_DISPATCH:
            V_VT(pNew) = VT_DISPATCH;
            V_DISPATCH(pNew) = m_value.pDisp;
            if(m_value.pDisp) m_value.pDisp->AddRef();
            break;

        case VT_UNKNOWN:
            V_VT(pNew) = VT_UNKNOWN;
            V_UNKNOWN(pNew) = m_value.pUnk;
            if(m_value.pUnk) m_value.pUnk->AddRef();
            break;

        case VT_UI1:
            V_VT(pNew) = VT_UI1;
            V_UI1(pNew) = m_value.bVal;
            break;

        case VT_I4:
            V_VT(pNew) = VT_I4;
            V_I4(pNew) = m_value.lVal;
            break;

        case VT_I2:
            V_VT(pNew) = VT_I2;
            V_I2(pNew) = m_value.iVal;
            break;

        case VT_R4:
            V_VT(pNew) = VT_R4;
            V_R4(pNew) = m_value.fltVal;
            break;

        case VT_R8:        
            V_VT(pNew) = VT_R8;
            V_R8(pNew) = m_value.dblVal;
            break;

        // An embedded CVarVector which must be converted
        // to a SAFEARRAY.
        // ==============================================

        case VT_EX_CVARVECTOR:
            {
                // Set type afterwards here so if GetNewSafeArray throws an exception, the
                // type will not have been reset to an Array which could cause a subtle
                // memory corruption (or worse) if VariantClear is called - SJS

                V_ARRAY(pNew) = m_value.pVarVector->GetNewSafeArray();
                V_VT(pNew) = m_value.pVarVector->GetType() | VT_ARRAY;
            }
            break;
                                   
        default:
            VariantClear(pNew);        
    }
}

VARIANT *CVar::GetNewVariant()
{
    VARIANT *pNew = new VARIANT;

    // Check for an allocation failure.
    if ( NULL == pNew )
    {
        throw CX_MemoryException();
    }

    VariantInit(pNew);
    
    FillVariant(pNew);       
    return pNew;    
}
    
//***************************************************************************
//
//***************************************************************************

int CVar::DumpText(FILE *fStream)
{
    return unsupported;
}

//***************************************************************************
//
//  CVar::SetLPWSTR
//
//  Sets the value of the CVar to the indicated LPWSTR.
//
//  PARAMETERS:
//  pStr
//      A pointer to the source string.
//  bAcquire
//      If TRUE, then the ownership of pStr is trasferred and becomes
//      the internal pointer to the string. If FALSE, then the string
//      is copied.
//      
//***************************************************************************

BOOL CVar::SetLPWSTR(LPWSTR pStr, BOOL bAcquire)
{
    m_vt = VT_LPWSTR;
    if (bAcquire)
    {
        m_value.pWStr = pStr;
        return TRUE;
    }
    else            
    {
        // Check for an allocation failure
        if ( NULL != pStr )
        {
            m_value.pWStr = new wchar_t[wcslen(pStr) + 1];

            if ( NULL == m_value.pWStr )
            {
                throw CX_MemoryException();
            }
            wcscpy( m_value.pWStr, pStr );
        }
        else
        {
            m_value.pWStr = NULL;
        }

        return TRUE;
    }
}

//***************************************************************************
//
//  CVar::SetLPSTR
//
//  Sets the value of the CVar to the indicated LPSTR.
//
//  PARAMETERS:
//  pStr
//      A pointer to the source string.
//  bAcquire
//      If TRUE, then the ownership of pStr is trasferred and becomes
//      the internal pointer to the string. If FALSE, then the string
//      is copied (it must have been allocated with operator new).
//    
//***************************************************************************
    
BOOL CVar::SetLPSTR(LPSTR pStr, BOOL bAcquire)
{
    m_vt = VT_LPSTR;
    if (bAcquire)
    {
        m_value.pStr = pStr;
        return TRUE;
    }
    else        
    {
        if ( NULL != pStr)
        {
            m_value.pStr = new char[strlen(pStr) + 1];

            // On failure, throw an exception
            if ( NULL == m_value.pStr )
            {
                throw CX_MemoryException();
            }

            strcpy( m_value.pStr, pStr );
        }
        else
        {
            m_value.pStr = NULL;
        }
        
        return TRUE;

    }
}

//***************************************************************************
//
//  CVar::SetBSTR
//
//  Sets the value of the CVar to the indicated BSTR.
//
//  NOTE: This BSTR value is actually stored as an LPWSTR to avoid 
//  apartment-threading restrictions on real BSTR objects allocated 
//  with SysAllocString.
//
//  PARAMETERS:
//  str
//      A pointer to the string, which is copied into an internal LPWSTR.
//  bAcquire
//      If FALSE, then the BSTR is treated as read-only and copied.
//      If TRUE, then this function becomes owner of the BSTR and
//      frees it after the copy is made.
//
//***************************************************************************

BOOL CVar::SetBSTR(BSTR str, BOOL bAcquire)
{
    m_vt = VT_BSTR;

    if (str == 0) {
        m_value.pWStr = 0;
        return TRUE;
    }
        
    // Check for an allocation failure
    if ( NULL != str )
    {
        m_value.pWStr = new wchar_t[wcslen(str) + 1];

        // If allocation fails, throw an exception
        if ( NULL == m_value.pWStr )
        {
            throw CX_MemoryException();
        }
        wcscpy( m_value.pWStr, str );
    }
    else
    {
        m_value.pWStr = NULL;
    }


    // Check that this succeeded before we free
    // the string passed into us
    if ( NULL != m_value.pWStr )
    {
        if (bAcquire)
            SysFreeString(str);
    }

    // return whether or not we obtained a value
    return ( NULL != m_value.pWStr );
}

//***************************************************************************
//
//  CVar::GetBSTR
//
//  Returns the BSTR value of the current object.  
//
//  RETURN VALUE:
//  A newly allocated BSTR which must be freed with SysFreeString().
//
//***************************************************************************

BSTR CVar::GetBSTR()
{
    if (m_vt != VT_BSTR)
        return NULL;
    return SysAllocString(m_value.pWStr);
}
    
void CVar::SetDispatch(IDispatch* pDisp) 
{
    m_vt = VT_DISPATCH; 
    m_value.pDisp = pDisp; 

    if(pDisp) 
    {
        pDisp->AddRef();
    }
}

void CVar::SetUnknown(IUnknown* pUnk) 
{
    m_vt = VT_UNKNOWN; 
    m_value.pUnk = pUnk; 

    if(pUnk) 
    {
        pUnk->AddRef();
    }
}

//***************************************************************************
//
//  CVar::SetBlob
//
//  Sets the object to the value of the BLOB object.
//
//  PARAMETERS:
//  pBlob
//      A pointer to a valid VT_BLOB object.
//  bAcquire
//      If TRUE, then the pointer to the data will be acquired. It must
//      have been allocated with operator new in the current process, 
//      since operator delete will be used to free it.
//      
//***************************************************************************
    
void CVar::SetBlob(BLOB *pBlob, BOOL bAcquire)
{
    m_vt = VT_BLOB;
    if (pBlob == 0) 
        BlobClear(&m_value.Blob);
    else if (!bAcquire)
        m_value.Blob = BlobCopy(pBlob);        
    else
        m_value.Blob = *pBlob;        
}

//***************************************************************************
//
//  CVar::SetClsId
//
//  Sets the value of the object to a CLSID.
//  
//  PARAMETERS:
//  pClsId
//      Points the source CLSID.
//  bAcquire
//      If TRUE, the ownership of the pointer is transferred to the
//      object.  The CLSID must have been allocated with operator new.
//      If FALSE, the caller retains ownership and a copy is made.
//
//***************************************************************************
        
void CVar::SetClsId(CLSID *pClsId, BOOL bAcquire)
{
    m_vt = VT_CLSID;
    if (pClsId == 0)
        m_value.pClsId = 0;
    else
    {
        m_value.pClsId = new CLSID(*pClsId);

        // Check for an allocation failure.
        if ( NULL == m_value.pClsId )
        {
            throw CX_MemoryException();
        }

    }
}

//***************************************************************************
//
//  CVar::SetVarVector
//
//  Sets the value of the object to the specified CVarVector.  This
//  allows the CVar to contain a complete array.
//  
//  PARAMETERS:
//  pVec
//      A pointer to the CVarVector object which is the source.
//  bAcquire
//      If TRUE, then ownership of the CVarVector is transferred to
//      the object.  If FALSE, a new copy of the CVarVector is made and
//      the caller retains ownership.
//
//***************************************************************************
    
void CVar::SetVarVector(CVarVector *pVec, BOOL bAcquire)
{
    m_vt = VT_EX_CVARVECTOR;

    if (bAcquire) {
        // If here, we acquire the caller's pointer.
        // =========================================
        m_value.pVarVector = pVec;
        return;
    }

    // If here, make a copy.
    // =====================

    m_value.pVarVector = new CVarVector(*pVec);

    // Check for an allocation failure.
    if ( NULL == m_value.pVarVector )
    {
        throw CX_MemoryException();
    }


}

int CVar::GetOleType() 
{ 
    if(m_vt == VT_EX_CVARVECTOR)
    {
        if(m_value.pVarVector == NULL) return VT_ARRAY;
        else return VT_ARRAY | m_value.pVarVector->GetType();
    }
    else
    {
        return m_vt;
    }
}        


//***************************************************************************
//
//  CVar::GetText
//
//  Produces textual representation of the Var's type and data
//
//  PARAMETERS:
//  long lFlags     reseved, must be 0
//  BSTR* pstrType  destination for the type representation
//  BSTR* pstrValue destination for the value representation.
//
//***************************************************************************

BSTR CVar::GetText(long lFlags, long lType)
{
    if(m_vt == VT_EX_CVARVECTOR)
    {
        // When we get the text for the array, make sure the CIM_FLAG_ARRAY is masked out
        BSTR strTemp = GetVarVector()->GetText(lFlags, lType & ~CIM_FLAG_ARRAY);
        CSysFreeMe auto1(strTemp);

        WCHAR* wszValue = new WCHAR[SysStringLen(strTemp) + 3];

        // Check for allocation failures
        if ( NULL == wszValue )
        {
            throw CX_MemoryException();
        }

        CVectorDeleteMe<WCHAR> auto2(wszValue);

        wcscpy(wszValue, L"{");
        wcscat(wszValue, strTemp);
        wcscat(wszValue, L"}");

        BSTR strRet = SysAllocString(wszValue);

        return strRet;
    }
        
    WCHAR* wszValue = new WCHAR[100];

    // Check for allocation failures
    if ( NULL == wszValue )
    {
        throw CX_MemoryException();
    }


    WCHAR* pwc;
    int i;

    if(m_vt == VT_NULL)
        return NULL;

    if(lType == 0)
        lType = m_vt;

    try
    {
        switch(lType)
        {
        case CIM_SINT8:
            swprintf(wszValue, L"%d", (long)(signed char)GetByte());
            break;

        case CIM_UINT8:
            swprintf(wszValue, L"%d", GetByte());
            break;

        case CIM_SINT16:
            swprintf(wszValue, L"%d", (long)GetShort());
            break;

        case CIM_UINT16:
            swprintf(wszValue, L"%d", (long)(USHORT)GetShort());
            break;

        case CIM_SINT32:
            swprintf(wszValue, L"%d", GetLong());
            break;

        case CIM_UINT32:
            swprintf(wszValue, L"%lu", (ULONG)GetLong());
            break;

        case CIM_BOOLEAN:
            swprintf(wszValue, L"%s", (GetBool()?L"TRUE":L"FALSE"));
            break;

        case CIM_REAL32:
            {
                // Since the decimal point can be localized, and MOF text should
                // always be english, we will return values localized to 0x409,

                CVar    var( GetFloat() );

                // If this fails, we can't guarantee a good value,
                // so throw an exception.

                if ( !var.ChangeTypeToEx( VT_BSTR ) )
                {
                    throw CX_Exception();
                }

                wcscpy( wszValue, var.GetLPWSTR() );
            }
            break;

        case CIM_REAL64:
            {
                // Since the decimal point can be localized, and MOF text should
                // always be english, we will return values localized to 0x409,

                CVar    var( GetDouble() );

                // If this fails, we can't guarantee a good value,
                // so throw an exception.

                if ( !var.ChangeTypeToEx( VT_BSTR ) )
                {
                    throw CX_Exception();
                }

                wcscpy( wszValue, var.GetLPWSTR() );
            }
            break;

        case CIM_CHAR16:
            if(GetShort() == 0)
                wcscpy(wszValue, L"0x0");
            else
                swprintf(wszValue, L"'\\x%X'", (WCHAR)GetShort());
            break;

        case CIM_OBJECT:
            swprintf(wszValue, L"\"not supported\"");
            break;

        case CIM_REFERENCE:
        case CIM_DATETIME:
        case CIM_STRING:
        case CIM_SINT64:
        case CIM_UINT64:
        {
            // Escape all the quotes
            // =====================

            int nStrLen = wcslen(GetLPWSTR());
            delete [] wszValue;
            wszValue = NULL;

            wszValue = new WCHAR[nStrLen*2+10];

            // Check for allocation failures
            if ( NULL == wszValue )
            {
                throw CX_MemoryException();
            }

            wszValue[0] = L'"';
            pwc = wszValue+1;
            for(i = 0; i < (int)nStrLen; i++)
            {    
                WCHAR wch = GetLPWSTR()[i];
                if(wch == L'\n')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = L'n';
                }
                else if(wch == L'\t')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = L't';
                }
                else if(wch == L'"' || wch == L'\\')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = wch;
                }
                else
                {
                    *(pwc++) = wch;
                }
            }
            *(pwc++) = L'"';
            *pwc = 0;
        }
            break;
        default:
            swprintf(wszValue, L"\"not supported\"");
            break;
        }
        
        BSTR strRes = SysAllocString(wszValue);

        // Still need to clean up this value
        delete [] wszValue;

        return strRes;
    }
    catch (...)
    {
        // Cleanup always if this has a value
        if ( NULL != wszValue )
        {
            delete [] wszValue;
        }

        // Rethrow the exception
        throw;
    }

}


BSTR CVar::TypeToText(int nType)
{
    const WCHAR* pwcType;

    switch(nType)
    {
    case VT_I1:
        pwcType = L"sint8";
        break;

    case VT_UI1:
        pwcType = L"uint8";
        break;

    case VT_I2:
        pwcType = L"sint16";
        break;

    case VT_UI2:
        pwcType = L"uint16";
        break;

    case VT_I4:
        pwcType = L"sint32";
        break;

    case VT_UI4:
        pwcType = L"uint32";
        break;

    case VT_I8:
        pwcType = L"sint64";
        break;

    case VT_UI8:
        pwcType = L"uint64";
        break;

    case VT_BOOL:
        pwcType = L"boolean";
        break;

    case VT_R4:
        pwcType = L"real32";
        break;

    case VT_R8:
        pwcType = L"real64";
        break;    

    case VT_BSTR:
        pwcType = L"string";
        break;

    case VT_DISPATCH:
        pwcType = L"object";
        break;

    case VT_UNKNOWN:
        pwcType = L"object";
        break;

    default:
        return NULL;
    }

    return SysAllocString(pwcType);
}

BSTR CVar::GetTypeText() 
{
    if(m_vt != VT_EX_CVARVECTOR)
    {
        return TypeToText(m_vt);
    }
    else
    {
        return TypeToText(GetVarVector()->GetType());
    }
}

BOOL CVar::ChangeTypeTo(VARTYPE vtNew)
{
    // TBD: there are more efficient ways!
    // ===================================

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    HRESULT hres = WbemVariantChangeType(&v, &v, vtNew);
    if(FAILED(hres))
        return FALSE;

    // Load it back in
    // ===============

    Empty();
    SetVariant(&v);
    return TRUE;
}

// Performs localized changes (defaults to 0x409 for this)
BOOL CVar::ChangeTypeToEx(VARTYPE vtNew, LCID lcid /*=0x409*/)
{
    // TBD: there are more efficient ways!
    // ===================================

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    try
    {
        HRESULT hres = VariantChangeTypeEx(&v, &v, lcid, 0L, vtNew);
        if(FAILED(hres))
            return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }

    // Load it back in
    // ===============

    Empty();
    SetVariant(&v);
    return TRUE;
}

BOOL CVar::ToSingleChar()
{
    // Defer to CVarVector for arrays
    // ==============================

    if(m_vt == VT_EX_CVARVECTOR)
    {
        return GetVarVector()->ToSingleChar();
    }

    // Anything that's not a string follows normal OLE rules
    // =====================================================

    if(m_vt != VT_BSTR)
    {
        return ChangeTypeTo(VT_I2);
    }
    
    // It's a string. Make sure the length is 1
    // ========================================

    LPCWSTR wsz = GetLPWSTR();
    if(wcslen(wsz) != 1)
        return FALSE;

    // Take the first character
    // ========================
    
    WCHAR wc = wsz[0];
    Empty();

    SetShort(wc);
    return TRUE;
}

BOOL CVar::ToUI4()
{
    // Defer to CVarVector for arrays
    // ==============================

    if(m_vt == VT_EX_CVARVECTOR)
    {
        return GetVarVector()->ToSingleChar();
    }

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    HRESULT hres = WbemVariantChangeType(&v, &v, VT_UI4);
    if(FAILED(hres))
        return FALSE;

    // Load it back in
    // ===============

    Empty();

    // Here we cheat and reset to VT_I4 so we can natively reset
    V_VT(&v) = VT_I4;
    SetVariant(&v);
    return TRUE;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  Default constructor.  The caller should not attempt to add any
//  elements when the internal type is VT_EMPTY.  Objects constructed
//  with this constructor should only be used as l-values in an 
//  assignment of CVarVector objects.
//
//***************************************************************************

CVarVector::CVarVector()
{
    m_Array.Empty();
    m_nType = VT_EMPTY;
    m_nStatus = no_error;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  This is the standard constructor.
//
//  PARAMETERS:
//  nVarType
//      An OLE VT_ type indicator.  Heterogeneous arrays are possible
//      if the type VT_EX_CVAR is used.  Embedded CVarVectors can
//      occur, since a CVar can in turn hold a CVarVector.
//  
//  nInitSize
//      The starting size of the internal CFlexArray. See FLEXARRY.CPP.
//  nGrowBy
//      The "grow by" factor of the internal CFlexArray. See FLEXARRAY.CPP.
//          
//***************************************************************************

CVarVector::CVarVector(
    int nVarType, 
    int nInitSize, 
    int nGrowBy
    ) :
    m_Array(nInitSize, nGrowBy)
{
    m_nType = nVarType;
    m_nStatus = no_error;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  Alternate constructor to build a new CVarVector based on a 
//  SAFEARRAY object.  The only supported types for the SAFEARRAY
//  are VT_BSTR, VT_UI1, VT_I2, VT_I4, VT_R4, and VT_R8.
//
//  PARAMETERS:
//  nVarType
//      The VT_ type indicator of the incoming SAFEARRAY.
//  pSrc
//      A pointer to a SAFEARRAY, which is treated as read-only.
//
//  NOTES:
//  This will set the internal m_nStatus variable to <unsupported> if
//  an unsupported VT_ type is in the SAFEARRAY.  The caller can immediately
//  call CVarVector::Status() after construction to see if the operation
//  was successful.
//
//***************************************************************************

CVarVector::CVarVector(int nVarType, SAFEARRAY *pSrc)
{
    SAFEARRAY* pNew = NULL;

    try
    {
        m_nType = nVarType;
        if(pSrc == NULL)
        {
            // NULL safearray --- empty
            // ========================

            m_nStatus = no_error;
            return;
        }

        // Bind to the incoming SAFEARRAY, but don't delete it during destruct.
        // ====================================================================
    
        if(SafeArrayGetDim(pSrc) != 1)
        {
            m_nStatus = unsupported;
            return;
        }

        long lLBound, lUBound;
        SafeArrayGetLBound(pSrc, 1, &lLBound);
        SafeArrayGetUBound(pSrc, 1, &lUBound);

        if(lLBound != 0)
        {
            // Non-0-based safearray --- since CSafeArray doesn't support that, and
            // we can't change pSrc, create a copy
            // ====================================================================
    
            if(FAILED(SafeArrayCopy(pSrc, &pNew)))
            {
                m_nStatus = failed;
                return;
            }
        
            SAFEARRAYBOUND sfb;
            sfb.cElements = (lUBound - lLBound) + 1;
            sfb.lLbound = 0;
            SafeArrayRedim(pNew, &sfb);
        }
        else
        {
            pNew = pSrc;
        }
        
        CSafeArray sa(pNew, nVarType, CSafeArray::no_delete | CSafeArray::bind);
    
        for (int i = 0; i < sa.Size(); i++) {

            CVar*   pVar = NULL;
        
            switch (m_nType) {
                case VT_BOOL:
                    {
                        VARIANT_BOOL boolVal = sa.GetBoolAt(i);

                        pVar = new CVar(boolVal, VT_BOOL);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }

                        break;
                    }

                case VT_UI1: 
                    {
                        BYTE b = sa.GetByteAt(i);

                        pVar = new CVar(b);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_I2:  
                    {
                        SHORT s = sa.GetShortAt(i);

                        pVar = new CVar(s);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_I4:
                    {
                        LONG l = sa.GetLongAt(i);

                        pVar = new CVar(l);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_R4:
                    {
                        float f = sa.GetFloatAt(i);

                        pVar = new CVar(f);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_R8:
                    {
                        double d = sa.GetDoubleAt(i);

                        pVar = new CVar(d);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_BSTR:
                    {
                        BSTR bstr = sa.GetBSTRAt(i);
                        CSysFreeMe auto1(bstr);

                        pVar = new CVar(VT_BSTR, bstr, FALSE);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }

                        break;
                    }
                case VT_DISPATCH:
                    {
                        IDispatch* pDisp = sa.GetDispatchAt(i);
                        CReleaseMe auto2(pDisp);

                        pVar = new CVar;

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        pVar->SetDispatch(pDisp);
                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }
                case VT_UNKNOWN:
                    {
                        IUnknown* pUnk = sa.GetUnknownAt(i);
                        CReleaseMe auto3(pUnk);
                        pVar = new CVar;

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        pVar->SetUnknown(pUnk);
                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                default:
                    m_nStatus = unsupported;
                    if(pNew != pSrc)
                        SafeArrayDestroy(pNew);
                    return;
            }
        }

        if(pNew != pSrc)
            SafeArrayDestroy(pNew);

        m_nStatus = no_error;
    }
    catch (CX_MemoryException)
    {
        // SafeArrayCopy, GetBSTRAt, new can all throw exceptions

        m_nStatus = failed;

        if(pNew != pSrc)
            SafeArrayDestroy(pNew);

        throw;
    }
}

//***************************************************************************
//
//  CVarVector::GetNewSafeArray
//
//  Allocates a new SAFEARRAY equivalent to the current CVarVector.
//  
//  RETURN VALUE:
//  A new SAFEARRAY pointer which must be deallocated with 
//  SafeArrayDestroy().  Returns NULL on error or unsupported types.
//
//***************************************************************************

SAFEARRAY *CVarVector::GetNewSafeArray()
{
    CSafeArray *pArray = new CSafeArray(m_nType, CSafeArray::no_delete);

    // Check for an allocation failure
    if ( NULL == pArray )
    {
        throw CX_MemoryException();
    }

    CDeleteMe<CSafeArray> auto1(pArray);

    for (int i = 0; i < m_Array.Size(); i++) {
        CVar &v = *(CVar *) m_Array[i];
        switch (m_nType) {
            case VT_UI1:
                pArray->AddByte(v.GetByte());
                break;

            case VT_I2:
                pArray->AddShort(v.GetShort());
                break;

            case VT_I4:
                pArray->AddLong(v.GetLong());
                break;

            case VT_R4:
                pArray->AddFloat(v.GetFloat());
                break;

            case VT_R8:
                pArray->AddDouble(v.GetDouble());
                break;

            case VT_BOOL:
                pArray->AddBool(v.GetBool());
                break;
                
            case VT_BSTR:
                {
                    BSTR s = v.GetBSTR();
                    CSysFreeMe auto2(s);
                    pArray->AddBSTR(s);
                    break;
                }
            case VT_DISPATCH:
                {
                    IDispatch* pDisp = v.GetDispatch();
                    CReleaseMe auto3(pDisp);
                    pArray->AddDispatch(pDisp);
                    break;
                }
            case VT_UNKNOWN:
                {
                    IUnknown* pUnk = v.GetUnknown();
                    CReleaseMe auto4(pUnk);
                    pArray->AddUnknown(pUnk);
                    break;
                }
            default:
                // For unsupported types, return a NULL.
                // Since we constructed the SAFEARRAY object to
                // not delete the SAFEARRAY and we have encountered
                // a condition where the internal SAFEARRAY of
                // CSafeArray should not be returned, we have
                // to switch our destruct policy.
                // ================================================
                pArray->SetDestructorPolicy(CSafeArray::auto_delete);
                return 0;
        }
    }

    // Final cleanup.  Get the SAFEARRAY pointer, and delete
    // the wrapper.
    // =====================================================
    
    pArray->Trim();
    
    SAFEARRAY *pRetValue = pArray->GetArray();
    return pRetValue;
}

//***************************************************************************
//
//  CVarVector::~CVarVector
//
//  Destructor.
//
//***************************************************************************

CVarVector::~CVarVector()
{
    Empty();
}

//***************************************************************************
//
//  CVarVector::Empty
//
//***************************************************************************

void CVarVector::Empty()
{
    for (int i = 0; i < m_Array.Size(); i++)  {
        delete (CVar *) m_Array[i];
    }
    m_Array.Empty();
    m_nType = VT_EMPTY;
    m_nStatus = no_error;
}


//***************************************************************************
//
//  CVarVector::CVarVector
//   
//  Copy constructor.  This is implemented via the assignment operator.
// 
//***************************************************************************

CVarVector::CVarVector(CVarVector &Src)
{
    m_nType = 0;
    m_nStatus = no_error;    
    *this = Src;
}

//***************************************************************************
//
//  CVarVector::operator =
//
//  Assignment operator.
//
//***************************************************************************

CVarVector& CVarVector::operator =(CVarVector &Src)
{
    Empty();

    for (int i = 0; i < Src.m_Array.Size(); i++) 
    {
        CVar* pVar = new CVar(*(CVar *) Src.m_Array[i]);

        // Check for an allocation failure
        if ( NULL == pVar )
        {
            throw CX_MemoryException();
        }

        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
        {
            delete pVar;
            throw CX_MemoryException();
        }
    }

    m_nStatus = Src.m_nStatus;
    m_nType = Src.m_nType;

    return *this;
}

//***************************************************************************
//
//  CVarVector::operator ==
//
//  Equality test operator.
//
//***************************************************************************

int CVarVector::operator ==(CVarVector &Src)
{
    return CompareTo(Src, TRUE);
}

BOOL CVarVector::CompareTo(CVarVector& Src, BOOL bIgnoreCase)
{
    if (m_nType != Src.m_nType)
        return 0;

    if (m_Array.Size() != Src.m_Array.Size())
        return 0;

    for (int i = 0; i < Src.m_Array.Size(); i++)  {
        CVar *pThisVar = (CVar *) m_Array[i];
        CVar *pThatVar = (CVar *) Src.m_Array[i];

        if (!pThisVar->CompareTo(*pThatVar, bIgnoreCase))
            return 0;
    }

    return 1;
}

//***************************************************************************
//
//  CVarVector::Add
//
//  Adds a new CVar to the array.  A reference is used so that anonymous
//  objects can be constructed in the Add() call:
//
//      pVec->Add(CVar(33));
//
//  PARAMETERS:
//  Value
//      A reference to a CVar object of the correct type for the array.
//      No type checking is done. 
//
//  RETURN VALUE:
//  no_error
//  failed
//
//***************************************************************************

int CVarVector::Add(CVar &Value)
{
    CVar *p = new CVar(Value);

    // Check for allocation failures
    if ( NULL == p )
    {
        return failed;
    }

    if (m_Array.Add(p) != CFlexArray::no_error)
    {
        delete p;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CVarVector::Add
//
//  Adds a new CVar to the array.  This overload simply takes ownership
//  of the incoming pointer and adds it directly.
//
//  PARAMETERS:
//  pAcquiredPtr
//      A pointer to a CVar object which is acquired by the vector.
//
//  RETURN VALUE:
//  no_error
//  failed
//
//***************************************************************************

int CVarVector::Add(CVar *pAcquiredPtr)
{
    if (m_Array.Add(pAcquiredPtr) != CFlexArray::no_error)
    {
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CVarVector::RemoveAt
//
//  Removes the array element at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The location at which to remove the element.
//
//  RETURN VALUE:
//  no_error
//      On success.
//  failed
//      On range errors, etc.
//
//***************************************************************************

int CVarVector::RemoveAt(int nIndex)
{
    CVar *p = (CVar *) m_Array[nIndex];
    delete p;
    if (m_Array.RemoveAt(nIndex) != CFlexArray::no_error)
        return failed;

    return no_error;
}

//***************************************************************************
//
//  CVarVector::InsertAt
//
//  Inserts the new element at the specified location.
//  
//  PARAMETERS:
//  nIndex
//      The location at which to add the new element.
//  Value
//      A reference to the new value.
//
//  RETURN VALUE:
//  no_error
//      On success.
//  failed
//      An invalid nIndex value was specified.      
//
//***************************************************************************

int CVarVector::InsertAt(int nIndex, CVar &Value)
{
    CVar *pNew = new CVar(Value);

    // Check for allocation failures
    if ( NULL == pNew )
    {
        return failed;
    }

    if (m_Array.InsertAt(nIndex, pNew) != CFlexArray::no_error)
    {
        delete pNew;
        return failed;
    }
    return no_error;
}


BSTR CVarVector::GetText(long lFlags, long lType/* = 0 */)
{
    // Construct an array of values
    // ============================

    BSTR* aTexts = NULL;
    int i;

    try
    {
        aTexts = new BSTR[Size()];

        // Check for allocation failures
        if ( NULL == aTexts )
        {
            throw CX_MemoryException();
        }

        memset(aTexts, 0, Size() * sizeof(BSTR));

        int nTotal = 0;
        for(i = 0; i < Size(); i++)
        {
            aTexts[i] = GetAt(i).GetText(lFlags, lType);
            nTotal += SysStringLen(aTexts[i]) + 2; // 2: for ", "
        }

        // Allocate a BSTR to contain them all
        // ===================================

        BSTR strRes = SysAllocStringLen(NULL, nTotal);
        CSysFreeMe auto2(strRes);
        *strRes = 0;

        for(i = 0; i < Size(); i++)
        {
            if(i != 0)
            {
                wcscat(strRes, L", ");
            }

            wcscat(strRes, aTexts[i]);
            SysFreeString(aTexts[i]);
        }

        delete [] aTexts;
        aTexts = NULL;
        BSTR strPerfectRes = SysAllocString(strRes);
        return strPerfectRes;
    }
    catch(CX_MemoryException)
    {
        // new, GetText, SysAllocStringLen and SysAllocString can all throw exceptions
        if (NULL != aTexts)
        {
            for(int x = 0; x < Size(); x++)
            {
                if (NULL != aTexts[x])
                    SysFreeString(aTexts[x]);
            }
            delete [] aTexts;
            aTexts = NULL;
        }

        throw;
    }
}

BOOL CVarVector::ToSingleChar()
{
    for(int i = 0; i < Size(); i++)
    {
        if(!GetAt(i).ToSingleChar())
            return FALSE;
    }

    // Since all of the conversions succeeded, we will
    // assume the vector type is now VT_I2.

    m_nType = VT_I2;
    return TRUE;
}

BOOL CVarVector::ToUI4()
{
    for(int i = 0; i < Size(); i++)
    {
        if(!GetAt(i).ToUI4())
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\backuprestore.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    BackupRestore.CPP

Abstract:

    Backup Restore Interface.

History:

  paulall       08-Feb-99   Implemented the call-outs to do the backup
                            and recovery.  Stole lots of code from the core
                            to get this working!

--*/

#include "precomp.h"
#include <wbemint.h>
#include <reg.h>
#include <cominit.h>  // for WbemCoImpersonate
#include <genutils.h> // for IsPrivilegePresent
#include <arrtempl.h> // for CReleaseMe
#include <CoreX.h>    // for CX_MemoryException
#include <reposit.h>

#include "BackupRestore.h"
#include "winmgmt.h"

#include <malloc.h>
#include <helper.h>
#include <aclapi.h>

#define RESTORE_FILE L"repdrvfs.rec"
#define DEFAULT_TIMEOUT_BACKUP   (15*60*1000)

HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);

HRESULT DeleteRepository();
HRESULT DeleteSavedRepository(const wchar_t *wszBackupDirectory);

HRESULT DoDeleteContentsOfDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszRepositoryDirectory);
HRESULT DoDeleteDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);

HRESULT GetRepPath(wchar_t wcsPath[MAX_PATH+1], wchar_t * wcsName);

HRESULT WbemPauseService();
HRESULT WbemContinueService();

HRESULT SaveRepository(wchar_t *wszBackupDirectory);
HRESULT RestoreSavedRepository(const wchar_t *wszBackupDirectory);

HRESULT MoveRepositoryFiles(const wchar_t *wszSourceDirectory, const wchar_t *wszDestinationDirectory, bool bMoveForwards);


BOOL CheckSecurity(LPCTSTR pPriv,HANDLE * phToken = NULL)
{
    HRESULT hres = WbemCoImpersonateClient();
    if (FAILED(hres))
        return FALSE;

    HANDLE hToken;
    BOOL bRet = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
    WbemCoRevertToSelf();
    if(!bRet)
        return FALSE;
    bRet = IsPrivilegePresent(hToken, pPriv);
    if (phToken)
        *phToken = hToken;
    else
        CloseHandle(hToken);
    return bRet;
}

//
//
//  Static Initialization
//
//////////////////////////////////////////////////////////////////////

LIST_ENTRY CWbemBackupRestore::s_ListHead = { &CWbemBackupRestore::s_ListHead, &CWbemBackupRestore::s_ListHead };
CStaticCritSec CWbemBackupRestore::s_CritSec;

CWbemBackupRestore::CWbemBackupRestore(HINSTANCE hInstance): 
    m_cRef(0),
    m_pDbDir(0), 
    m_pWorkDir(0),
    m_hInstance(hInstance), 
    m_pController(0),
    m_PauseCalled(0),
    m_lResumeCalled(0),
    m_Method(0),
    m_hTimer(NULL),
    m_dwDueTime(DEFAULT_TIMEOUT_BACKUP)
{
    
    DWORD dwTemp;
    if (ERROR_SUCCESS == RegGetDWORD(HKEY_LOCAL_MACHINE,
                                      HOME_REG_PATH,
                                      TEXT("PauseResumeTimeOut"),
                                      &dwTemp))
    {
        m_dwDueTime = dwTemp;
    }    

    CInCritSec ics(&s_CritSec);
    InsertTailList(&s_ListHead,&m_ListEntry);

    //DBG_PRINTFA((pBuff,"+  (%p)\n",this));    
};

CWbemBackupRestore::~CWbemBackupRestore(void)
{
    if (m_PauseCalled)
    {
        Resume();    // Resume will release the IDbController
    }

    delete [] m_pDbDir;
    delete [] m_pWorkDir;

    CInCritSec ics(&s_CritSec);
    RemoveEntryList(&m_ListEntry);
    
    //DBG_PRINTFA((pBuff,"-  (%p)\n",this));
}

TCHAR *CWbemBackupRestore::GetDbDir()
{
    if (m_pDbDir == NULL)
    {
        Registry r(WBEM_REG_WINMGMT);
        if (m_pWorkDir == NULL)
        {
            if (r.GetStr(__TEXT("Working Directory"), &m_pWorkDir))
            {
                ERRORTRACE((LOG_WINMGMT,"Unable to read 'Installation Directory' from registry\n"));
                return NULL;
            }
        }
        if (r.GetStr(__TEXT("Repository Directory"), &m_pDbDir))
        {
            size_t cchSizeTmp = lstrlen(m_pWorkDir) + lstrlen(__TEXT("\\Repository")) +1;
            m_pDbDir = new TCHAR [cchSizeTmp];
            if (m_pDbDir)
            {
                StringCchPrintf(m_pDbDir,cchSizeTmp, __TEXT("%s\\REPOSITORY"), m_pWorkDir); 
                r.SetStr(__TEXT("Repository Directory"), m_pDbDir);
            }
        }        
    }
    return m_pDbDir;
}

TCHAR *CWbemBackupRestore::GetFullFilename(const TCHAR *pszFilename)
{
    const TCHAR *pszDirectory = GetDbDir();
    if (NULL == pszDirectory) return 0;
    size_t cchSizeTmp = lstrlen(pszDirectory) + lstrlen(pszFilename) + 2;
    TCHAR *pszPathFilename = new TCHAR[cchSizeTmp];
    if (pszPathFilename == 0)
        return 0;
    StringCchCopy(pszPathFilename,cchSizeTmp, pszDirectory);
    if ((lstrlen(pszPathFilename)) && (pszPathFilename[lstrlen(pszPathFilename)-1] != '\\'))
    {
        StringCchCat(pszPathFilename,cchSizeTmp, __TEXT("\\"));
    }
    StringCchCat(pszPathFilename,cchSizeTmp, pszFilename);

    return pszPathFilename;
}
TCHAR *CWbemBackupRestore::GetExePath(const TCHAR *pszFilename)
{
    size_t cchSizeTmp = lstrlen(m_pWorkDir) + lstrlen(pszFilename) + 2;
    TCHAR *pszPathFilename = new TCHAR[cchSizeTmp];
    if (pszPathFilename == 0)
        return 0;
    StringCchCopy(pszPathFilename,cchSizeTmp, m_pWorkDir);
    StringCchCat(pszPathFilename,cchSizeTmp, __TEXT("\\"));
    StringCchCat(pszPathFilename,cchSizeTmp, pszFilename);

    return pszPathFilename;
}

HRESULT CWbemBackupRestore::GetDefaultRepDriverClsId(CLSID &clsid)
{
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pClsIdStr = 0;
    TCHAR *pFSClsId = __TEXT("{7998dc37-d3fe-487c-a60a-7701fcc70cc6}");
    HRESULT hRes;
    TCHAR Buf[128];

    if (r.GetStr(__TEXT("Default Repository Driver"), &pClsIdStr))
    {
        // If here, default to FS for now.
        // =====================================
        r.SetStr(__TEXT("Default Repository Driver"), pFSClsId);
        StringCchPrintf(Buf,128, __TEXT("%s"), pFSClsId);
        hRes = CLSIDFromString(Buf, &clsid);
        return hRes;
    }

    // If here, we actually retrieved one.
    // ===================================
    StringCchPrintf(Buf,128, __TEXT("%s"), pClsIdStr);
    hRes = CLSIDFromString(Buf, &clsid);
    delete [] pClsIdStr;
    return hRes;
}

//
//
//
/////////////////////////////////////////////////////

DWORD CheckTokenForFileAccess(HANDLE hToken,
                             LPCWSTR pBackupFile)
{
    DWORD dwRes;
    SECURITY_INFORMATION SecInfo = DACL_SECURITY_INFORMATION |
                                   SACL_SECURITY_INFORMATION |
                                   OWNER_SECURITY_INFORMATION |
                                   GROUP_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR pSecDes = NULL;
    if (ERROR_SUCCESS != (dwRes = GetNamedSecurityInfo((LPWSTR)pBackupFile,
                                                    SE_FILE_OBJECT,
                                                    SecInfo,
                                                    NULL,NULL,NULL,NULL,
                                                    &pSecDes))) return dwRes;
    OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> fm(pSecDes);

    BOOL bCheckRes = FALSE;
    DWORD DesiredMask = FILE_GENERIC_WRITE;
    DWORD ReturnedMask = 0;
    GENERIC_MAPPING Mapping= {0,0,0,0};
    struct tagPrivSet : PRIVILEGE_SET  {
        LUID_AND_ATTRIBUTES  m_[SE_MAX_WELL_KNOWN_PRIVILEGE];
    } PrivSec;
    DWORD dwPrivSecLen = sizeof(PrivSec);
    
    if (FALSE == AccessCheck(pSecDes,
                          hToken,
                          DesiredMask,
                          &Mapping,
                          &PrivSec,
                          &dwPrivSecLen,
                          &ReturnedMask,
                          &bCheckRes)) return GetLastError();
    
    if (FALSE == bCheckRes)
        return ERROR_ACCESS_DENIED;
    
    return ERROR_SUCCESS;        
}

//
// to debug Volume Snapshot failure in IOStress we introduced 
// some self instrumentation that did relay on RtlCaptureStackBacktrace
// that function works only if there is a proper stack frame
// the general trick to force stack frames on i386 is the usage of _alloca
//
//#ifdef _X86_
//    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
//#endif

// enable generation of stack frames here
#pragma optimize( "y", off )

//***************************************************************************
//
//  CWbemBackupRestore::Backup()
//
//  Do the backup.
//
//***************************************************************************
HRESULT CWbemBackupRestore::Backup(LPCWSTR strBackupToFile, long lFlags)
{
    //DBG_PRINTFA((pBuff,"(%p)->Backup\n",this));

    m_Method |= mBackup;
    m_CallerId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSize,m_Trace,&Hash);

    
    if (m_PauseCalled)
    {
        // invalid state machine
        return WBEM_E_INVALID_OPERATION;    
    }
    else
    {   
        try
        {
            // Check security
            EnableAllPrivileges(TOKEN_PROCESS);
            HANDLE hToken = NULL;
            BOOL bCheck = CheckSecurity(SE_BACKUP_NAME,&hToken);
            if(!bCheck)
            {
                if (hToken) CloseHandle(hToken);
                return WBEM_E_ACCESS_DENIED;
            }
            OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> cm(hToken);

            // Check the params
            if (NULL == strBackupToFile || (lFlags != 0))
                return WBEM_E_INVALID_PARAMETER;

            // Use GetFileAttributes to validate the path.
            DWORD dwAttributes = GetFileAttributesW(strBackupToFile);
            if (dwAttributes == 0xFFFFFFFF)
            {
                // It failed -- check for a no such file error (in which case, we're ok).
                if ((ERROR_FILE_NOT_FOUND != GetLastError()) && (ERROR_PATH_NOT_FOUND != GetLastError()))
                {
                    return WBEM_E_INVALID_PARAMETER;
                }
            }
            else
            {
                // The file already exists -- create mask of the attributes that would make an existing file invalid for use
                DWORD dwMask =    FILE_ATTRIBUTE_DEVICE |
                                FILE_ATTRIBUTE_DIRECTORY |
                                FILE_ATTRIBUTE_OFFLINE |
                                FILE_ATTRIBUTE_READONLY |
                                FILE_ATTRIBUTE_REPARSE_POINT |
                                FILE_ATTRIBUTE_SPARSE_FILE |
                                FILE_ATTRIBUTE_SYSTEM |
                                FILE_ATTRIBUTE_TEMPORARY;

                if (dwAttributes & dwMask)
                    return WBEM_E_INVALID_PARAMETER;

                //
                // we are doing backup on behaf of clients
                // from localsystem, so attempt to do accesscheck here
                // if the file already exists
                //
                if (ERROR_SUCCESS != CheckTokenForFileAccess(hToken,strBackupToFile))
                    return WBEM_E_ACCESS_DENIED;
            }

            //Now we need to determine if we are a disk file or not
            {
                HANDLE hFile = CreateFileW(strBackupToFile, 0, FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL , NULL);
                if (hFile != INVALID_HANDLE_VALUE)
                {
                    DWORD dwType = GetFileType(hFile);
                    
                    CloseHandle(hFile);
                    
                    if (dwType != FILE_TYPE_DISK)
                        return WBEM_E_INVALID_PARAMETER;
                        
                }
            }


            // Retrieve the CLSID of the default repository driver
            CLSID clsid;
            HRESULT hRes = GetDefaultRepDriverClsId(clsid);
            if (FAILED(hRes))
                return hRes;

            // Call IWmiDbController to do backup
            IWmiDbController* pController = NULL;
            _IWmiCoreServices *pCoreServices = NULL;
            IWbemServices *pServices = NULL;

            //Make sure the core is initialized...
            hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL,
                        CLSCTX_INPROC_SERVER, IID__IWmiCoreServices,
                        (void**)&pCoreServices);
            CReleaseMe rm1(pCoreServices);

            if (SUCCEEDED(hRes))
            {
                hRes = pCoreServices->GetServices(L"root", NULL,NULL,0, IID_IWbemServices, (LPVOID*)&pServices);
            }
            CReleaseMe rm2(pServices);

            if (SUCCEEDED(hRes))
            {
                hRes = CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER, IID_IWmiDbController, (LPVOID *) &pController);
            }
            CReleaseMe rm3(pController);

            if (SUCCEEDED(hRes))
            {
                //DBG_PRINTFA((pBuff,"(%p)->RealBackup\n",this));
                hRes = pController->Backup(strBackupToFile, lFlags);
            }
            return hRes;
        }
        catch (CX_MemoryException)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        catch (...)
        {
            return WBEM_E_CRITICAL_ERROR;
        }
    }
}

//***************************************************************************
//
//  CWbemBackupRestore::Restore()
//
//  Do the restore.
//
//***************************************************************************
HRESULT CWbemBackupRestore::Restore(LPCWSTR strRestoreFromFile, long lFlags)
{
    //DBG_PRINTFA((pBuff,"(%p)->Restore\n",this));

    m_Method |= mRestore;
    m_CallerId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSize,m_Trace,&Hash);
    
    if (m_PauseCalled)
    {
        // invalid state machine
        return WBEM_E_INVALID_OPERATION;    
    }
    else
    {  
        try
        {
            HRESULT hr = WBEM_S_NO_ERROR;

            // Check security
            EnableAllPrivileges(TOKEN_PROCESS);
            if(!CheckSecurity(SE_RESTORE_NAME))
                hr = WBEM_E_ACCESS_DENIED;

            // Check the params
            if (SUCCEEDED(hr) && ((NULL == strRestoreFromFile) || (lFlags & ~WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN)))
                hr = WBEM_E_INVALID_PARAMETER;

            // Use GetFileAttributes to validate the path.
            if (SUCCEEDED(hr))
            {
                DWORD dwAttributes = GetFileAttributesW(strRestoreFromFile);
                if (dwAttributes == 0xFFFFFFFF)
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }
                else
                {
                    // The file exists -- create mask of the attributes that would make an existing file invalid for use
                    DWORD dwMask =    FILE_ATTRIBUTE_DEVICE |
                                    FILE_ATTRIBUTE_DIRECTORY |
                                    FILE_ATTRIBUTE_OFFLINE |
                                    FILE_ATTRIBUTE_REPARSE_POINT |
                                    FILE_ATTRIBUTE_SPARSE_FILE;

                    if (dwAttributes & dwMask)
                        hr = WBEM_E_INVALID_PARAMETER;
                }
            }
            //Now we need to determine if we are a disk file or not
            if (SUCCEEDED(hr))
            {
                HANDLE hFile = CreateFileW(strRestoreFromFile, 0, FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL , NULL);
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    return WBEM_E_INVALID_PARAMETER;
                }
                else
                {
                    DWORD dwType = GetFileType(hFile);
                    
                    CloseHandle(hFile);
                    
                    if (dwType != FILE_TYPE_DISK)
                        return WBEM_E_INVALID_PARAMETER;
                        
                }
            }
            //**************************************************
            // Shutdown the core if it is running
            // and make sure it does not start up while we are
            // preparing to restore...
            //**************************************************
            bool bPaused = false;
            if (SUCCEEDED(hr))
            {
                hr = WbemPauseService();
                if (SUCCEEDED(hr))
                    bPaused=true;
            }

            //**************************************************
            // Now we need to copy over the <restore file> into
            // the repository directory
            // This must be done before the repository rename
            // because we don't know if the rename will affect
            // the location of the file, thus making
            // strRestoreFromFile invalid.
            //**************************************************

            wchar_t szRecoveryActual[MAX_PATH+1] = { 0 };
        
            if (SUCCEEDED(hr))
                hr = GetRepPath(szRecoveryActual, RESTORE_FILE);

            bool bRestoreFileCopied = false;
            if (SUCCEEDED(hr))
            {
                if(wbem_wcsicmp(szRecoveryActual, strRestoreFromFile))
                {
                    DeleteFileW(szRecoveryActual);
                    if (!CopyFileW(strRestoreFromFile, szRecoveryActual, FALSE))
                        hr = WBEM_E_FAILED;
                    else
                        bRestoreFileCopied = true;
                }
            }

            //**************************************************
            // Now we need to rename the existing repository so
            // that we can restore it in the event of a failure.
            // We also need to create a new empty repository 
            // directory and recopy the <restore file> into it
            // from the now renamed original repository directory.
            //**************************************************

            wchar_t wszRepositoryOrg[MAX_PATH+1] = { 0 };
            wchar_t wszRepositoryBackup[MAX_PATH+1] = { 0 };

            if (SUCCEEDED(hr))
            {
                hr = SaveRepository(wszRepositoryBackup);    //Moves the files into the backup directory!
            }

            //******************************************************************
            // Regardless of whether we succeeded or failed the calls above,
            // we need to restart the core or we leave WMI in an unusable state.
            // However, we don't want to lose knowledge of any prior failure,
            // so we use a different HRESULT variable
            //******************************************************************
            HRESULT hrContinue = 0;
            if (bPaused)
                hrContinue = WbemContinueService();

            if (SUCCEEDED(hr) && SUCCEEDED(hrContinue))
            {
                //**************************************************
                //Connecting to winmgmt will now result in this 
                //backup file getting loaded
                //**************************************************
                {   //Scoping for destruction of COM objects before CoUninitialize!
                    IWbemLocator *pLocator = NULL;
                    hr = CoCreateInstance(CLSID_WbemLocator,NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator,(void**)&pLocator);
                    CReleaseMe relMe(pLocator);

                    if (SUCCEEDED(hr))
                    {
                        IWbemServices *pNamespace = NULL;
                        BSTR tmpStr = SysAllocString(L"root");
                        CSysFreeMe sysFreeMe(tmpStr);

                        if (tmpStr == NULL)
                            hr = WBEM_E_OUT_OF_MEMORY;

                        if (SUCCEEDED(hr))
                        {

                            HKEY hKeyLoc;
                            LONG lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,WBEM_REG_WINMGMT,0,KEY_SET_VALUE,&hKeyLoc);
                            if (ERROR_SUCCESS != lRes) hr = HRESULT_FROM_WIN32(lRes);

                            if (SUCCEEDED(hr))
                            {  
                                RegDeleteValue(hKeyLoc,L"LocaleUpgrade");
                                RegCloseKey(hKeyLoc);
                                
                                hr = pLocator->ConnectServer(tmpStr, NULL, NULL, NULL, NULL, NULL, NULL, &pNamespace);
                                CReleaseMe relMe4(pNamespace);

                                //If connect server failed, then we want a generic failure error code!
                                if (hr == WBEM_E_INITIALIZATION_FAILURE)
                                    hr = WBEM_E_FAILED;
                            }
                        }
                    }
                }

                if (FAILED(hr))
                {
                    // something failed, so we need to put back the original repository
                    // - pause service
                    // - delete failed repository
                    // - rename the backed up repository
                    // - restart the service

                    HRESULT hres = WbemPauseService();

                    if (SUCCEEDED(hres))
                        hres = DeleteRepository();

                    if (SUCCEEDED(hres))
                    {
                        hres = RestoreSavedRepository(wszRepositoryBackup);
                    }

                    if (SUCCEEDED(hres))
                        hres = WbemContinueService();
                }
                else
                {
                    // restore succeeded, so delete the saved original repository
                    DeleteSavedRepository(wszRepositoryBackup);
                }
            }

            //Delete our copy of the restore file if we made one
            if (bRestoreFileCopied)
            {
                if (*szRecoveryActual)
                    DeleteFileW(szRecoveryActual);
            }

            //**************************************************
            // All done!
            // Return the more interesting of the two HRESULTs
            //**************************************************
            if (SUCCEEDED(hr))
                return hrContinue;
            else
                return hr;
        }
        catch (CX_MemoryException)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        catch (...)
        {
            return WBEM_E_CRITICAL_ERROR;
        }
    }
}

//***************************************************************************
//    
//    EXTENDED Interface
//
//***************************************************************************

HRESULT CWbemBackupRestore::Pause()
{
    //DBG_PRINTFA((pBuff,"(%p)->Pause\n",this));

    m_Method |= mPause;
    m_CallerId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSize,m_Trace,&Hash);

    if (InterlockedCompareExchange(&m_PauseCalled,1,0))
        return WBEM_E_INVALID_OPERATION;

    try
    {    
        HRESULT hRes = WBEM_NO_ERROR;

        // determine if we are already paused

        // Check security
        if (SUCCEEDED(hRes))
        {
            EnableAllPrivileges(TOKEN_PROCESS);
            if(!CheckSecurity(SE_BACKUP_NAME))
                hRes = WBEM_E_ACCESS_DENIED;
        }

        // Retrieve the CLSID of the default repository driver
        CLSID clsid;
        if (SUCCEEDED(hRes))
        {
            hRes = GetDefaultRepDriverClsId(clsid);
        }

        //Make sure the core is initialized...
        _IWmiCoreServices *pCoreServices = NULL;
        if (SUCCEEDED(hRes))
        {
            hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL, CLSCTX_INPROC_SERVER, IID__IWmiCoreServices, (void**)&pCoreServices);
        }
        CReleaseMe rm1(pCoreServices);

        IWbemServices *pServices = NULL;
        if (SUCCEEDED(hRes))
        {
            hRes = pCoreServices->GetServices(L"root", NULL,NULL,0, IID_IWbemServices, (LPVOID*)&pServices);
        }
        CReleaseMe rm2(pServices);

        // Call IWmiDbController to do UnlockRepository
        if (SUCCEEDED(hRes))
        {
            hRes = CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER, IID_IWmiDbController, (LPVOID *) &m_pController);
        }

        if (SUCCEEDED(hRes))
        {
            hRes = m_pController->LockRepository();
            //DBG_PRINTFA((pBuff,"(%p)->Pause : LockRepository %08x\n",this,hRes));
            if (FAILED(hRes))
            {
                m_pController->Release();
                m_pController = reinterpret_cast<IWmiDbController*>(-1);    // For debug
            }
            else
            {
                this->AddRef();
                if (CreateTimerQueueTimer(&m_hTimer,NULL,
                    CWbemBackupRestore::TimeOutCallback,
                    this,
                    m_dwDueTime,
                    0,
                    WT_EXECUTEINTIMERTHREAD|WT_EXECUTEONLYONCE))
                {
                    // we are OK here, we have a timer that will save the repository lock
                    //DBG_PRINTFA((pBuff,"+ (%p)->m_hTimer = %p\n",this,m_hTimer));
                }
                else
                {
                    this->Release();
                    // we are going to be left locked in case a bad client exists
                }            
            }
        }

        if (FAILED(hRes))
        {
            InterlockedDecrement(&m_PauseCalled);
        }

        return hRes;
    }
    catch (CX_MemoryException)
    {
        InterlockedDecrement(&m_PauseCalled);
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        InterlockedDecrement(&m_PauseCalled);
        return WBEM_E_CRITICAL_ERROR;
    }
}

HRESULT CWbemBackupRestore::pResume()
{
    //DBG_PRINTFA((pBuff,"(%p)->pResume\n",this));
    if (0 == m_pController ||
      -1 == (LONG_PTR)m_pController )
        return WBEM_E_INVALID_OPERATION;
    HRESULT hRes = m_pController->UnlockRepository();
    m_pController->Release();
    m_pController = 0;
    // clean the state machine
    InterlockedDecrement(&m_PauseCalled);
    m_lResumeCalled = 0; // Resume is completed here
    return hRes;
}

HRESULT CWbemBackupRestore::Resume()
{
    //DBG_PRINTFA((pBuff,"(%p)->Resume\n",this));

    m_Method |= mResume;
    m_CallerId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSize,m_Trace,&Hash);

    if (!m_PauseCalled)
    {
        // invalid state machine pause without resume
        return WBEM_E_INVALID_OPERATION;    
    }

    if (InterlockedCompareExchange(&m_lResumeCalled,1,0))
    {
        // the time-out-thread beat us
        return WBEM_E_TIMED_OUT;    
    }
    else
    {
        HANDLE hTimer = m_hTimer;
        m_hTimer = NULL;
        //DBG_PRINTFA((pBuff,"- (%p)->m_hTimer = %p\n",this,hTimer));
        DeleteTimerQueueTimer(NULL,hTimer,INVALID_HANDLE_VALUE);

        this->Release(); //compensate the Addref in the Pause 
        return pResume();
    }
}

VOID CALLBACK 
CWbemBackupRestore::TimeOutCallback(PVOID lpParameter, 
                                   BOOLEAN TimerOrWaitFired)
{
    //DBG_PRINTFA((pBuff,"(%p)->TimeOutCallback\n",lpParameter));
    CWbemBackupRestore * pBackupRes= (CWbemBackupRestore *)lpParameter;
    if (InterlockedCompareExchange(&pBackupRes->m_lResumeCalled,1,0))
    {
        // the Resume call beat us
        // the Resume will DelteTimer and Release us
        return; 
    }
    else
    {
        HANDLE hTimer = pBackupRes->m_hTimer;
        pBackupRes->m_hTimer = NULL;        
        DeleteTimerQueueTimer(NULL,hTimer,NULL);

        HRESULT hrLog = pBackupRes->pResume();
        
        ERRORTRACE((LOG_WINMGMT,"Forcing a IWbemBackupRestoreEx::Resume after %x ms hr = %08x\n",pBackupRes->m_dwDueTime,hrLog));
        
        pBackupRes->Release(); //compensate the Addref in the Pause 

        //DBG_PRINTFA((pBuff,"- (%p)->m_hTimer = %p\n",lpParameter,hTimer));        
    }    
}

#pragma optimize( "", on )

/******************************************************************************
 *
 *    GetRepositoryDirectory
 *
 *    Description:
 *        Retrieves the location of the repository directory from the registry.
 *
 *    Parameters:
 *        wszRepositoryDirectory:    Array to store location in.
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                                               L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                                               0, 
                                               KEY_READ,
                                               &hKey);
    if (ERROR_SUCCESS != lRes) return WBEM_E_FAILED;        
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm(hKey);    

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwType;
    DWORD dwLen = sizeof(wchar_t) * (MAX_PATH + 1);
    lRes = RegQueryValueExW(hKey,
                                           L"Repository Directory", 
                                           NULL, 
                                           &dwType, 
                                          (LPBYTE)wszTmp, 
                                          &dwLen);
    if (ERROR_SUCCESS != lRes) return WBEM_E_FAILED;    
    if (REG_EXPAND_SZ != dwType) return WBEM_E_FAILED;

    if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
        return WBEM_E_FAILED;

    DWORD dwOutLen = wcslen(wszRepositoryDirectory);
    if (dwOutLen < 2) return WBEM_E_FAILED; // at least 'c:'
    if (wszRepositoryDirectory[dwOutLen-1] == L'\\')
        wszRepositoryDirectory[dwOutLen-1] = L'\0';
        
    return WBEM_S_NO_ERROR;
}

/******************************************************************************
 *
 *    CRepositoryPackager::DeleteRepository
 *
 *    Description:
 *        Delete all the files associated with the repository
 *
 *    Parameters:
 *        <none>
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT DeleteRepository()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    wchar_t *wszRepositoryOrg = new wchar_t[MAX_PATH+1];
    CVectorDeleteMe<wchar_t> vdm1(wszRepositoryOrg);

    if (!wszRepositoryOrg)
        hr = WBEM_E_OUT_OF_MEMORY;
    
    if (SUCCEEDED(hr))
        hr = GetRepositoryDirectory(wszRepositoryOrg);

    //MOVE EACH OF THE FILES, ONE BY ONE
    for (int i = 0; SUCCEEDED(hr) && (i != 6); i++)
    {
        static wchar_t *filename[] = { L"\\$winmgmt.cfg", L"\\index.btr", L"\\objects.data", L"\\Mapping1.map", L"\\Mapping2.map", L"Mapping.Ver"};
        wchar_t *wszDestinationFile = new wchar_t[MAX_PATH+1];
        CVectorDeleteMe<wchar_t> vdm2(wszDestinationFile);
        if (!wszDestinationFile)
            hr = WBEM_E_OUT_OF_MEMORY;
        else
        {
            StringCchCopy(wszDestinationFile,MAX_PATH+1, wszRepositoryOrg);

            if (i != 0)
            {
                StringCchCat(wszDestinationFile,MAX_PATH+1, L"\\fs");
            }
            StringCchCat(wszDestinationFile,MAX_PATH+1, filename[i]);

            if (!DeleteFileW(wszDestinationFile))
            {
                if ((GetLastError() != ERROR_FILE_NOT_FOUND) && (GetLastError() != ERROR_PATH_NOT_FOUND))
                {
                    hr = WBEM_E_FAILED;

                    break;
                }
            }
        }
    }

    return hr;
}


/******************************************************************************
 *
 *    DoDeleteContentsOfDirectory
 *
 *    Description:
 *        Given a directory, iterates through all files and directories and
 *        calls into the function to delete it.
 *
 *    Parameters:
 *        wszRepositoryDirectory:    Directory to process
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT DoDeleteContentsOfDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszRepositoryDirectory)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];    
    if (wszFullFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> dm_(wszFullFileName);

    //create file search pattern...
    wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
    if (wszSearchPattern == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> dm1_(wszSearchPattern);
    
    StringCchCopy(wszSearchPattern,MAX_PATH+1, wszRepositoryDirectory);
    StringCchCat(wszSearchPattern,MAX_PATH+1, L"\\*");

    WIN32_FIND_DATAW findFileData;
    HANDLE hff = INVALID_HANDLE_VALUE;

    //Start the file iteration in this directory...    
    hff = FindFirstFileW(wszSearchPattern, &findFileData);
    if (hff == INVALID_HANDLE_VALUE)
    {
        hres = WBEM_E_FAILED;
    }

    
    if (SUCCEEDED(hres))
    {
        do
        {
            //If we have a filename of '.' or '..' we ignore it...
            if ((wcscmp(findFileData.cFileName, L".") == 0) ||
                (wcscmp(findFileData.cFileName, L"..") == 0))
            {
                //Do nothing with these...
            }
            else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                //This is a directory, so we need to deal with that...
                hres = DoDeleteDirectory(wszExcludeFile, wszRepositoryDirectory, findFileData.cFileName);
                if (FAILED(hres))
                    break;
            }
            else
            {
                //This is a file, so we need to deal with that...
                StringCchCopy(wszFullFileName,MAX_PATH+1, wszRepositoryDirectory);
                StringCchCat(wszFullFileName,MAX_PATH+1, L"\\");
                StringCchCat(wszFullFileName,MAX_PATH+1, findFileData.cFileName);

                //Make sure this is not the excluded filename...
                if (wbem_wcsicmp(wszFullFileName, wszExcludeFile) != 0)
                {
                    if (!DeleteFileW(wszFullFileName))
                    {
                        hres = WBEM_E_FAILED;
                        break;
                    }
                }
            }
            
        } while (FindNextFileW(hff, &findFileData));
    }

    DWORD dwLastErrBeforeFindClose = GetLastError();
    
    if (hff != INVALID_HANDLE_VALUE)
        FindClose(hff);

    if (ERROR_SUCCESS != dwLastErrBeforeFindClose &&
        ERROR_NO_MORE_FILES != dwLastErrBeforeFindClose)
    {
        hres = WBEM_E_FAILED;
    }

    return hres;
}

/******************************************************************************
 *
 *    DoDeleteDirectory
 *
 *    Description:
 *        This is the code which processes a directory.  It iterates through
 *        all files and directories in that directory.
 *
 *    Parameters:
 *        wszParentDirectory:    Full path of parent directory
 *        eszSubDirectory:    Name of sub-directory to process
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT DoDeleteDirectory(const wchar_t *wszExcludeFile, 
                        const wchar_t *wszParentDirectory, 
                        wchar_t *wszSubDirectory)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    //Get full path of new directory...
    wchar_t *wszFullDirectoryName = new wchar_t[MAX_PATH+1];
    if (wszFullDirectoryName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> dm_(wszFullDirectoryName);

    StringCchCopy(wszFullDirectoryName,MAX_PATH+1, wszParentDirectory);
    StringCchCat(wszFullDirectoryName,MAX_PATH+1, L"\\");
    StringCchCat(wszFullDirectoryName,MAX_PATH+1, wszSubDirectory);

    //delete the contents of that directory...
    hres = DoDeleteContentsOfDirectory(wszExcludeFile, wszFullDirectoryName);

    // now that the directory is empty, remove it
    if (!RemoveDirectoryW(wszFullDirectoryName))
    {   //If a remove directory fails, it may be because our excluded file is in it!
    }

    return hres;
}

/******************************************************************************
 *
 *    GetRepPath
 *
 *    Description:
 *        Gets the repository path and appends the filename to the end
 *
 *    Parameters:
 *        wcsPath: repository path with filename appended
 *        wcsName: name of file to append
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_FAILED            If anything failed
 *
 ******************************************************************************
 */

HRESULT GetRepPath(wchar_t wcsPath[MAX_PATH+1], wchar_t * wcsName)
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if (ERROR_SUCCESS != lRes) return WBEM_E_FAILED;        
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm(hKey);    
    

    wchar_t wszTmp[MAX_PATH+1];
    DWORD dwLen = sizeof(wchar_t) * (MAX_PATH+1);
    DWORD dwType;
    lRes = RegQueryValueExW(hKey, 
                           L"Repository Directory", 
                           NULL,&dwType, 
                           (LPBYTE)(wchar_t*)wszTmp, 
                           &dwLen);
    if (ERROR_SUCCESS != lRes) return WBEM_E_FAILED;        
    if(REG_EXPAND_SZ != dwType) return WBEM_E_FAILED;

    if (ExpandEnvironmentStringsW(wszTmp, wcsPath, MAX_PATH+1) == 0)
        return WBEM_E_FAILED;

    DWORD dwOutLen = wcslen(wcsPath);
    if (dwOutLen < 2 )  return WBEM_E_FAILED; // at least 'c:'
    if (wcsPath[dwOutLen-1] != L'\\')
        StringCchCat(wcsPath,MAX_PATH+1, L"\\");

    StringCchCat(wcsPath,MAX_PATH+1, wcsName);

    return WBEM_S_NO_ERROR;

}


DWORD g_DirSD[] = {
0x90040001, 0x00000000, 0x00000000, 0x00000000,
0x00000014,
0x004c0002, 0x00000003, 0x00180300, 0x001f01ff,
0x00000201, 0x05000000, 0x00000020, 0x00000220,
0x00180300, 0x001f01ff, 0x00000201, 0x05000000, 
0x00000020, 0x00000227, 0x00140300, 0x001f01ff,
0x00000101, 0x05000000, 0x00000012
};

/******************************************************************************
 *
 *    SaveRepository
 *
 *    Description:
 *        Moves the existing repository to a safe location so that it may be
 *        put back in the event of restore failure.  A new empty repository
 *        directory is then created, and our copy of the restore file is then
 *        recopied into it.
 *
 *    Parameters:
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */

HRESULT SaveRepository(wchar_t* wszRepositoryBackup)
{
    wchar_t* wszRepositoryOrg = new wchar_t[MAX_PATH+1];
    if (NULL == wszRepositoryOrg) return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> vdm1(wszRepositoryOrg);
    
    HRESULT hr = GetRepositoryDirectory(wszRepositoryOrg);

    if (SUCCEEDED(hr))
    {
    	unsigned long i = 0;
    	DWORD dwAttributes = INVALID_FILE_ATTRIBUTES;
		do
    	{
    		StringCchPrintfW(wszRepositoryBackup, MAX_PATH+1, L"%sTempBackup.%lu", wszRepositoryOrg, i++);

	        dwAttributes = GetFileAttributesW(wszRepositoryBackup);

    	} while (dwAttributes != INVALID_FILE_ATTRIBUTES) ;

		DWORD dwLastError = GetLastError();
		if (dwLastError != ERROR_FILE_NOT_FOUND)
			hr = WBEM_E_FAILED;

        //Create the backup directory where we copy the current repository files to
        SECURITY_ATTRIBUTES sa = { sizeof(sa),g_DirSD,FALSE};
        if (SUCCEEDED(hr) && !CreateDirectoryW(wszRepositoryBackup, &sa))
            hr = WBEM_E_FAILED;
    }

    if (SUCCEEDED(hr))
        hr = MoveRepositoryFiles(wszRepositoryOrg, wszRepositoryBackup, true);

    return hr;
}


HRESULT RestoreSavedRepository(const wchar_t* wszRepositoryBackup)
{
    wchar_t* wszRepositoryOrg = new wchar_t[MAX_PATH+1];
    if (NULL == wszRepositoryOrg) return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> vdm1(wszRepositoryOrg);
    
    HRESULT hr = GetRepositoryDirectory(wszRepositoryOrg);

    if (SUCCEEDED(hr))
        hr = MoveRepositoryFiles(wszRepositoryOrg, wszRepositoryBackup, false);

    if (SUCCEEDED(hr))
        RemoveDirectoryW(wszRepositoryBackup);

    return hr;
}

HRESULT MoveRepositoryFiles(const wchar_t *wszSourceDirectory, const wchar_t *wszDestinationDirectory, bool bMoveForwards)
{
    static wchar_t *filename[] = 
    { 
        L"\\$winmgmt.cfg", 
        L"\\index.btr", 
        L"\\objects.data", 
        L"\\Mapping1.map" ,
        L"\\Mapping2.map", 
        L"\\Mapping.ver"
    };

    wchar_t *wszSourceFile = new wchar_t[MAX_PATH+1];
    if (NULL == wszSourceFile) return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> vdm2(wszSourceFile);
    
    wchar_t *wszDestinationFile = new wchar_t[MAX_PATH+1];
    if (NULL == wszDestinationFile) return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> vdm3(wszDestinationFile);

    HRESULT hr = WBEM_S_NO_ERROR;

    //MOVE EACH OF THE FILES, ONE BY ONE
    for (int i = 0; SUCCEEDED(hr) && (i != 6); i++)
    {
        StringCchCopy(wszSourceFile,MAX_PATH+1, wszSourceDirectory);
        StringCchCopy(wszDestinationFile,MAX_PATH+1, wszDestinationDirectory);

        if (i != 0)
        {
            StringCchCat(wszSourceFile,MAX_PATH+1, L"\\fs");
        }
        StringCchCat(wszSourceFile,MAX_PATH+1, filename[i]);
        StringCchCat(wszDestinationFile,MAX_PATH+1, filename[i]);

        if (bMoveForwards)
        {
            if (!MoveFileW(wszSourceFile, wszDestinationFile))
            {
                if ((GetLastError() != ERROR_FILE_NOT_FOUND) && (GetLastError() != ERROR_PATH_NOT_FOUND))
                {
                    hr = WBEM_E_FAILED;

                    break;
                }
            }
        }
        else
        {
            if (!MoveFileW(wszDestinationFile, wszSourceFile))
            {
                if ((GetLastError() != ERROR_FILE_NOT_FOUND) && (GetLastError() != ERROR_PATH_NOT_FOUND))
                {
                    hr = WBEM_E_FAILED;

                    break;
                }
            }
        }
    }

    return hr;
}



HRESULT DeleteSavedRepository(const wchar_t *wszRepositoryBackup)
{
    wchar_t *wszDestinationFile = new wchar_t[MAX_PATH+1];
    if (NULL == wszDestinationFile) return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> vdm3(wszDestinationFile);
    HRESULT hr = WBEM_S_NO_ERROR;
    
    //MOVE EACH OF THE FILES, ONE BY ONE
    for (int i = 0; SUCCEEDED(hr) && (i != 6); i++)
    {
        static wchar_t *filename[] = { L"\\$winmgmt.cfg", L"\\index.btr", L"\\objects.data", L"\\mapping1.map", L"\\mapping2.map" , L"\\mapping.ver" };
        
        StringCchCopy(wszDestinationFile,MAX_PATH+1, wszRepositoryBackup);
        StringCchCat(wszDestinationFile,MAX_PATH+1, filename[i]);

        if (!DeleteFileW(wszDestinationFile))
        {
            if ((GetLastError() != ERROR_FILE_NOT_FOUND) && (GetLastError() != ERROR_PATH_NOT_FOUND))
                hr = WBEM_E_FAILED;
        }
    }

    if (SUCCEEDED(hr))
        RemoveDirectoryW(wszRepositoryBackup);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_wstring.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WSTRING.H

Abstract:

    Utility string class

History:

	a-raymcc    30-May-96       Created.
	a-dcrews	16-Mar-99		Added out-of-memory exception handling

--*/

#ifndef _WSTRING_H_
#define _WSTRING_H_

#include <strutils.h>

class WString
{
    wchar_t *m_pString;

    void DeleteString(wchar_t *pStr);

public:
    enum { leading = 0x1, trailing = 0x2 };

    WString(wchar_t *pSrc, BOOL bAcquire = FALSE);
    WString(DWORD dwResourceID, HMODULE hMod);      // creates from resource string
    WString(const wchar_t *pSrc);
    WString(const char *pSrc);
//    inline WString() { m_pString = g_szNullString; }
	WString();
    inline WString(const WString &Src) {  m_pString = 0; *this = Src; }
    WString& operator =(const WString &);
    WString& operator =(LPCWSTR);
   inline ~WString() { DeleteString(m_pString); }
    inline int Length() const { return wcslen(m_pString); }

    WString& operator +=(const WString &Other);
    WString& operator +=(const wchar_t *);
    WString& operator +=(wchar_t);
    
    inline operator const wchar_t *() const { return m_pString; } 
    inline operator wchar_t *() { return m_pString; } 
    wchar_t operator[](int nIndex) const;
    LPSTR GetLPSTR() const;

    inline BOOL Equal(const wchar_t *pTarget) const
        { return wcscmp(m_pString, pTarget) == 0; }
    inline BOOL EqualNoCase(const wchar_t *pTarget) const
        { return wbem_wcsicmp(m_pString, pTarget) == 0; }

    inline BOOL operator< (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) < 0; }
    inline BOOL operator> (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) > 0; }
    inline BOOL operator<= (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) <= 0; }
    inline BOOL operator>= (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) >= 0; }
        

    LPWSTR UnbindPtr();
    inline void BindPtr(LPWSTR ptr) { DeleteString(m_pString); m_pString = ptr; }
    void Empty();
    WString& StripWs(int nType);
        // Strip whitespace, use with a combination
        // of leading | trailing
        
    WString& TruncAtRToken(wchar_t Token);
        // Truncates the string at the token starting from the
        // right end. The token itself is also wiped out.

    WString& TruncAtLToken(wchar_t Token);
          
    WString& StripToToken(wchar_t Token, BOOL bIncludeToken);
        // Strips leading chars until the token is encountered.
        // If bIncludeTok==TRUE, strips the token too.

    wchar_t *GetLToken(wchar_t wcToken) const;
        // Gets the first occurrence of wcToken in the string or NULL
        
    WString operator()(int, int) const;
        // Returns a new WString based on the slice
        
    BOOL ExtractToken(const wchar_t * pDelimiters, WString &Extract);
        // Extracts the leading chars up to the token delimiter,
        // Removing the token from *this, and assigning the extracted
        // part to <Extract>.

    BOOL ExtractToken(wchar_t Delimiter, WString &Extract);
        // Extracts the leading chars up to the token delimiter,
        // Removing the token from *this, and assigning the extracted
        // part to <Extract>.
        
    BOOL WildcardTest(const wchar_t *pTestStr) const;
        // Tests *this against the wildcard string.  If a match,
        // returns TRUE, else FALSE.        
        
    void Unquote();        
        // Removes leading/trailing quotes, if any. 
        // Leaves escaped quotes intact.

    WString EscapeQuotes() const;
};

class WSiless
{
public:
    inline bool operator()(const WString& ws1, const WString& ws2) const
        {return wbem_wcsicmp(ws1, ws2) < 0;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\backuprestore.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    BackupRestore.H

Abstract:

    Backup Restore Interface.

History:

--*/

#ifndef __BACKUPRESTORE_H__
#define __BACKUPRESTORE_H__ 

#include "precomp.h"

#include <statsync.h>

interface IWmiDbController;
class CWbemBackupRestore : IWbemBackupRestoreEx
{
public:
    enum CallerType
    {
        VssWriter = 'wssV',
        NtBackup = 'kcaB'
    };
    enum Traces 
    {
        MaxTraceSize = 8
    };
    enum MethodTypes 
    {
        mBackup = 1,
        mRestore = 2,
        mPause = 4,
        mResume = 8
    };
protected:
    long   m_cRef;        
    TCHAR *m_pDbDir;
    TCHAR *m_pWorkDir;
    HINSTANCE m_hInstance;
    HANDLE m_hTimer;
    DWORD m_dwDueTime;
    // used by extended interface
    IWmiDbController* m_pController;
    LONG m_PauseCalled;
    LONG m_lResumeCalled;
    //instrumentation;
    LIST_ENTRY m_ListEntry;
    int m_Method;
    DWORD    m_CallerId;
    PVOID    m_Trace[MaxTraceSize];
    // statics for instrumentation
    static LIST_ENTRY s_ListHead;
    static CStaticCritSec s_CritSec;
    

public:
        CWbemBackupRestore(HINSTANCE hInstance);

        virtual ~CWbemBackupRestore(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, LPVOID *ppv)
        {
    
            if (IID_IUnknown==riid || 
              IID_IWbemBackupRestore==riid || 
              IID_IWbemBackupRestoreEx==riid)
            {
                *ppv=this;
            }
            else
            {
                 *ppv=NULL;            
                return E_NOINTERFACE;
            }

            ((IUnknown*)(*ppv))->AddRef();
            return NOERROR;
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return InterlockedIncrement(&m_cRef);
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRef = InterlockedDecrement(&m_cRef);
            if (0L == lRef)
                delete this;
            return lRef;
        };

        HRESULT STDMETHODCALLTYPE Backup(
            LPCWSTR   strBackupToFile,
            long   lFlags);
        
        HRESULT STDMETHODCALLTYPE Restore(
            LPCWSTR   strRestoreFromFile,
            long   lFlags);


        void InitEmpty(){};
        TCHAR *GetDbDir();
        TCHAR *GetFullFilename(const TCHAR *pszFilename);
        TCHAR *GetExePath(const TCHAR *pszFilename);
        HRESULT GetDefaultRepDriverClsId(CLSID &clsid);

        // EXTENDED interface
        HRESULT STDMETHODCALLTYPE Pause();
        HRESULT STDMETHODCALLTYPE Resume();

        HRESULT pResume();
        static VOID CALLBACK TimeOutCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired);
        
};

#endif /*__BACKUPRESTORE_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\cntserv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CNTSERV.H

Abstract:


History:

  a-davj      20-June-96  Created.
  ivanbrug    30-Aug-2000 modified for SvcHost

--*/

#ifndef _CNTSERV_H_
#define _CNTSERV_H_

#define DEFAULT_WAIT_HINT 30000


class CNtService {
public: 

    CNtService(DWORD ControlAccepted);
    ~CNtService();

    // Starts up the service.  This must be called to start the service.
    //==================================================================

    virtual DWORD Run(LPWSTR pszServiceName,
              DWORD dwNumServicesArgs,
              LPWSTR *lpServiceArgVectors,
              PVOID lpData);

    // This MUST be overridden since this is where the actual work is done
    //====================================================================

    virtual DWORD WorkerThread() = 0;

    // This MUST be overridden to signal the worker thread to exit its routine
    //=========================================================================

    virtual void Stop(BOOL bSystemShutDownCalled) = 0;

    // If there is some lengthy initialization, it should be done by 
    // overriding this routine.
    //===============================================================

    virtual BOOL Initialize(DWORD dwNumServicesArgs,
                            LPWSTR *lpServiceArgVectors){return TRUE;};
    virtual void FinalCleanup(){};

    // These routines are optional and should be overridden if the features
    // are desired.  Note that supporting Pause and Continue also require a
    // call to SetPauseContinue()
    //=====================================================================

    virtual void Pause(){return;};
    virtual void Continue(){return;};

    // dumps messages to the event log.  Can be overriden if there is 
    // another diagnostic in place.
    //===============================================================

    virtual VOID Log(LPCTSTR lpszMsg);

private:

    static DWORD WINAPI _HandlerEx(DWORD dwControl,
                                  DWORD dwEventType, 
                                  LPVOID lpEventData,
                                  LPVOID lpContext);

    BOOL m_bStarted;
    TCHAR * m_pszServiceName;
    DWORD m_dwCtrlAccepted;
    SERVICE_STATUS          ssStatus;       // current status of the service
    SERVICE_STATUS_HANDLE   sshStatusHandle;
                                                                                         
    virtual DWORD WINAPI HandlerEx(DWORD dwControlCode,
                         DWORD dwEventType, 
                         LPVOID lpEventData,
                         LPVOID lpContext);
    
protected:

    // this might come in handy if the derived class needs to communicate
    // with the SCM.
    //===================================================================

    BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
         DWORD dwWin32ExitCode, DWORD dwCheckPoint, DWORD dwWaitHint);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\cntserv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CNTSERV.CPP

Abstract:

    A class which allows easy creation of Win32 Services.   This class
    only allows one service per .EXE file.  The process can be run as a
    service or a regular non-service EXE, a runtime option.

    This class is largly based on the SMS CService class which was created by
    a-raymcc.  This differs in that it is simplified in two ways; First, it 
    does not keep track of the worker threads since that is the responsibility
    of the derived code, and second, it doesnt use some SMS specific diagnostics

    NOTE: See the file SERVICE.TXT for details on how to use this class.
    There are a number of issues which cannot be conveyed by simply studying
    the class declaration.

History:

  a-davj      20-June-96  Created.

--*/

#include "precomp.h"
#include <wtypes.h>
#include <stdio.h>
#include "cntserv.h"

//****************************************************************************
//
//  CNtService::CNtService
//  CNtService::~CNtService
//
//  Constructor and destructor.
//
//****************************************************************************

CNtService::CNtService(DWORD ControlAccepted)
{
    m_dwCtrlAccepted = ControlAccepted;
    m_bStarted = FALSE;
    m_pszServiceName = NULL;
}

CNtService::~CNtService()
{
    if(m_pszServiceName)
        delete m_pszServiceName;
}

//
//
//  CNtService::Run
//
//
//////////////////////////////////////////////////////////////////

DWORD CNtService::Run(LPWSTR pszServiceName,
                      DWORD dwNumServicesArgs,
                      LPWSTR *lpServiceArgVectors,
                      PVOID lpData)
{

    size_t cchSizeTmp = lstrlen(pszServiceName)+1;
    m_pszServiceName = new TCHAR[cchSizeTmp];
    if(m_pszServiceName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    StringCchCopyW(m_pszServiceName,cchSizeTmp,pszServiceName);
    
    // Register our service control handler.
    // =====================================

    sshStatusHandle = RegisterServiceCtrlHandlerEx(m_pszServiceName, 
                                                   (LPHANDLER_FUNCTION_EX)CNtService::_HandlerEx,
                                                   lpData);

    if (!sshStatusHandle)
    {
        Log(TEXT("Initial call to RegisterServiceCtrlHandler failed"));
        goto cleanup;
    }

    ssStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;

    // Report the status to the service control manager.
    // =================================================

    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING,                // service state
        NO_ERROR,                             // exit code
        1,                                    // checkpoint
        DEFAULT_WAIT_HINT))                   // wait hint
        goto cleanup;


    if (!Initialize(dwNumServicesArgs, lpServiceArgVectors))
    {
        Log(TEXT("Initialize call failed, bailing out"));
        goto cleanup;
    }


    // Report the status to the service control manager.
    // =================================================

    if (!ReportStatusToSCMgr(
        SERVICE_RUNNING,       // service state
        NO_ERROR,              // exit code
        0,                     // checkpoint
        0))                    // wait hint
            goto cleanup;

    m_bStarted = TRUE;

    // The next routine is always over ridden and is 
    // where the acutal work of the service is done.
    // =============================================

    WorkerThread();     

    // Service is done, send last report to SCM.
    // =========================================

cleanup:
    m_bStarted = FALSE;

    //
    //
    //  we cannot rely on the distructor to be called after
    //  the SetServiceStatus(STOPPED) to perform operations
    //
    /////////////////////////////////////////////////////////

    FinalCleanup();

    ReportStatusToSCMgr(
        SERVICE_STOPPED,                 // service state
        NO_ERROR,                        // exit code
        0,                               // checkpoint
        0);                              // wait hint

    return 0;

}


//
//
//  CNtService::Log
//
//
//////////////////////////////////////////////////////////////////

VOID CNtService::Log(LPCTSTR lpszMsg)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPCTSTR  lpszStrings[2];


    DWORD dwErr = GetLastError();
    StringCchPrintf(szMsg,256, TEXT("%s error: %d"), m_pszServiceName, dwErr);

    // Dump the error code and text message out to the event log

    hEventSource = RegisterEventSource(NULL, m_pszServiceName);

    lpszStrings[0] = szMsg;
    lpszStrings[1] = lpszMsg;

    if (hEventSource != NULL) 
    {
         ReportEvent(hEventSource, // handle of event source
                     EVENTLOG_ERROR_TYPE,  // event type
                     0,                    // event category
                     0,                    // event ID
                     NULL,                 // current user's SID
                     2,                    // strings in lpszStrings
                     0,                    // no bytes of raw data
                     lpszStrings,          // array of error strings
                     NULL);                // no raw data

         DeregisterEventSource(hEventSource);
    }
    
}

//****************************************************************************
//
//  CNtService::_Handler
//
//  Entry points for calls from the NT service control manager.  These entry
//  points just call the actual functions using the default object.
//
//****************************************************************************


DWORD WINAPI CNtService::_HandlerEx(
  DWORD dwControl,     // requested control code
  DWORD dwEventType,   // event type
  LPVOID lpEventData,  // event data
  LPVOID lpContext     // user-defined context data
)
{
    _DBG_ASSERT(lpContext);

    return ((CNtService *)lpContext)->HandlerEx(dwControl,dwEventType,lpEventData,lpContext);
}


//****************************************************************************
//
//  CNtService::ReportStatusToSCMgr
//
//  Used by other member functions to report their status to the
//  service control manager.
//
//  Parameters:
//      DWORD dwCurrentState            One of the SERVICE_ codes.
//      DWORD dwWin32ExitCode           A Win32 Error code; usually 0.
//      DWORD dwCheckPoint              Checkpoint value (not used).
//      DWORD dwWaitHint                Milliseconds before Service Control
//                                      Manager gets worried.
//  Returns:
//
//      BOOL fResult                    Whatever code was returned
//                                      by SetServiceStatus().
//
//****************************************************************************

BOOL CNtService::ReportStatusToSCMgr(DWORD dwCurrentState,
    DWORD dwWin32ExitCode, DWORD dwCheckPoint, DWORD dwWaitHint)
{
    BOOL fResult;

    // Disable control requests until the service is started.
    // ======================================================

    if (dwCurrentState == SERVICE_START_PENDING)
    {
        ssStatus.dwControlsAccepted = 0;
    }
    else if (dwCurrentState == SERVICE_STOPPED)
    {
        ssStatus.dwControlsAccepted = 0;    
    }
    else
    {
        ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN |
            m_dwCtrlAccepted;
    }

    // These SERVICE_STATUS members are set from parameters.
    // =====================================================

    ssStatus.dwCurrentState  = dwCurrentState;
    ssStatus.dwWin32ExitCode = dwWin32ExitCode;
    ssStatus.dwCheckPoint    = dwCheckPoint;
    ssStatus.dwWaitHint      = dwWaitHint;

    // Report the status of the service to the service control manager.
    // ================================================================

    if (!(fResult = SetServiceStatus(
        sshStatusHandle,    // service reference handle
        &ssStatus)))
    {

        // If an error occurs, log it.
        // =====================================
        
        Log(TEXT("Could not SetServiceStatus"));

    }
    return fResult;
}

//*****************************************************************************
//
//  CNtService::Handler
//
//  This handles incoming messages from the Service Controller.
//
//  Parameters:
//
//      DWORD dwControlCode             One of the SERVICE_CONTROL_
//                                      codes or a user defined code 125..255.
//
//*****************************************************************************

DWORD WINAPI 
CNtService::HandlerEx(  DWORD dwControl,     // requested control code
                             DWORD dwEventType,   // event type
                             LPVOID lpEventData,  // event data
                             LPVOID lpContext     // user-defined context data
)
{
    switch(dwControl) {

        // Pause, set initial status, call overriden function and set final status
        //========================================================================

        case SERVICE_CONTROL_PAUSE:

            ReportStatusToSCMgr(
                    SERVICE_PAUSE_PENDING,     // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint
            Pause();
            ReportStatusToSCMgr(
                    SERVICE_PAUSED,            // current state
                    NO_ERROR,                  // exit code
                    0,                         // checkpoint
                    0);                        // wait hint    
            break;


        // Continue, set initial status, call overriden function and set final status
        //===========================================================================

        case SERVICE_CONTROL_CONTINUE:

            ReportStatusToSCMgr(
                    SERVICE_CONTINUE_PENDING,  // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);      // wait hint

            Continue(); 

            ReportStatusToSCMgr(
                    SERVICE_RUNNING,           // current state
                    NO_ERROR,                  // exit code
                    0,                         // checkpoint
                    0);                        // wait hint

            break;

        // Stop the service.  Note that the Stop function is supposed
        // to signal the worker thread which should return which then
        // causes the StartMain() function to end which sends the
        // final status!  
        //==========================================================

        case SERVICE_CONTROL_SHUTDOWN:
        case SERVICE_CONTROL_STOP:

            ReportStatusToSCMgr(
                    SERVICE_STOP_PENDING,      // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint

            Stop((dwControl == SERVICE_CONTROL_SHUTDOWN)?TRUE:FALSE);
            
            break;

        // Could get an interrogate at any time, just report the current status.
        //======================================================================

        case SERVICE_CONTROL_INTERROGATE:
            ReportStatusToSCMgr(
                    ssStatus.dwCurrentState,   // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint
            break;

        // Some user defined code.  Call the overriden function and report status.
        //========================================================================

        default:
            ReportStatusToSCMgr(
                    ssStatus.dwCurrentState,   // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint
            return ERROR_CALL_NOT_IMPLEMENTED;
    }

    return NO_ERROR;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\factory.cpp ===
#include "precomp.h"

#include "winmgmt.h"
#include "backuprestore.h"

//***************************************************************************
//
//  CForwardFactory::AddRef()
//  CForwardFactory::Release()
//  CForwardFactory::QueryInterface()
//  CForwardFactory::CreateInstance()
//
//  DESCRIPTION:
//
//  Class factory for the exported WbemNTLMLogin interface.  Note that this
//  just serves as a wrapper to the factory inside the core.  The reason for
//  having a wrapper is that the core may not always be loaded.
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CForwardFactory::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CForwardFactory::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CForwardFactory::QueryInterface(REFIID riid,
                                                            void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

#ifdef  INSTRUMENTED_BUILD
#ifdef  _X86_
extern BOOL g_FaultHeapEnabled;
extern BOOL g_FaultFileEnabled;
extern LONG g_nSuccConn;
#endif
#endif


HRESULT STDMETHODCALLTYPE CForwardFactory::CreateInstance(IUnknown* pUnkOuter,
                            REFIID riid, void** ppv)
{
    DEBUGTRACE((LOG_WINMGMT, "CForwardFactory::CreateInstance\n"));
    SCODE sc = S_OK;
    CInMutex im(g_ProgRes.hMainMutex);

    try 
    {
    
        if(g_ProgRes.bShuttingDownWinMgmt)
        {
            DEBUGTRACE((LOG_WINMGMT, "CreateInstance returned CO_E_SERVER_STOPPING\n"));
            return CO_E_SERVER_STOPPING;
        }

        if(m_ForwardClsid == CLSID_WbemBackupRestore)
        {
            CWbemBackupRestore * pObj = new CWbemBackupRestore(g_hInstance);
            if (!pObj)
                return WBEM_E_OUT_OF_MEMORY;

            sc = pObj->QueryInterface(riid, ppv);
            if(FAILED(sc))
                delete pObj;
        }
        else // tertium non datur
        {
            HMODULE hCoreModule = LoadLibraryEx(__TEXT("wbemcore.dll"),NULL,0);
            if(hCoreModule)
            {
                HRESULT (STDAPICALLTYPE *pfn)(DWORD);
                pfn = (long (__stdcall *)(DWORD))GetProcAddress(hCoreModule, "Reinitialize");
                if(pfn == NULL)
                     sc = WBEM_E_CRITICAL_ERROR;
                else
                {
                    pfn(0);
                    sc = CoCreateInstance(CLSID_InProcWbemLevel1Login, NULL,
                            CLSCTX_INPROC_SERVER , IID_IUnknown,
                            (void**)ppv);
                    if (FAILED(sc))
                        DEBUGTRACE((LOG_WINMGMT, "CoCreateInstance(CLSID_InProcWbemLevel1Login) returned\n: 0x%X\n", sc));
                }
                FreeLibrary(hCoreModule);
             }
             else
                 sc = WBEM_E_CRITICAL_ERROR;

#ifdef  INSTRUMENTED_BUILD
#ifdef  _X86_
/*
             if (++g_nSuccConn > 500)
             {
                 g_FaultHeapEnabled = TRUE;
                 g_FaultFileEnabled = TRUE;
             };
*/             
#endif
#endif             
        }
    } 
    catch (...) 
    {
        ERRORTRACE((LOG_WINMGMT,"--------------- CForwardFactory::Exception thrown from CreateInstance -------------\n"));
        sc = E_NOINTERFACE;
    }
    
    return sc;
}

HRESULT STDMETHODCALLTYPE CForwardFactory::LockServer(BOOL fLock)
{
    return S_OK;
}

CForwardFactory::~CForwardFactory()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS
#pragma warning (disable : 4786)

#include <ole2.h>
#include <windows.h>

#include "corepol.h"


#include <comdef.h>
#include <helper.h>

#include <strsafe.h>

#include <wbemidl.h>
#include <comdef.h>

#include <strsafe.h>
#include <wbemutil.h>
#include <wbemint.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\mofdutil.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

	winmgmt.cpp

Abstract:

	HotMof directory functions

--*/



#include "precomp.h"
#include <malloc.h>

#include <mofcomp.h> // for AUTORECOVERY_REQUIRED

#include "winmgmt.h"   // this project
#include "arrtempl.h" // for CDeleteMe

//
//
//  CheckNoResyncSwitch
//
//////////////////////////////////////////////////////////////////

BOOL CheckNoResyncSwitch( void )
{
    BOOL bRetVal = TRUE;
    DWORD dwVal = 0;
    Registry rCIMOM(WBEM_REG_WINMGMT);
    if (rCIMOM.GetDWORDStr( WBEM_NORESYNCPERF, &dwVal ) == Registry::no_error)
    {
        bRetVal = !dwVal;

        if ( bRetVal )
        {
            DEBUGTRACE((LOG_WINMGMT, "NoResyncPerf in CIMOM is set to TRUE - ADAP will not be shelled\n"));
        }
    }

    // If we didn't get anything there, we should try the volatile key
    if ( bRetVal )
    {
        Registry rAdap( HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_ADAP);

        if ( rAdap.GetDWORD( WBEM_NOSHELL, &dwVal ) == Registry::no_error )
        {
            bRetVal = !dwVal;

            if ( bRetVal )
            {
                DEBUGTRACE((LOG_WINMGMT, 
                    "NoShell in ADAP is set to TRUE - ADAP will not be shelled\n"));
            }

        }
    }

    return bRetVal;
}

//
//
//  CheckNoResyncSwitch
//
//////////////////////////////////////////////////////////////////

BOOL 
CheckSetupSwitch( void )
{
    BOOL bRetVal = FALSE;
    DWORD dwVal = 0;
    Registry r(WBEM_REG_WINMGMT);
    if (r.GetDWORDStr( WBEM_WMISETUP, &dwVal ) == Registry::no_error)
    {
        bRetVal = dwVal;
        DEBUGTRACE((LOG_WINMGMT, "Registry entry is indicating a setup is %d\n",bRetVal));
    }
    return bRetVal;
}

//
//
//  CheckGlobalSetupSwitch
//
//////////////////////////////////////////////////////////////////

BOOL 
CheckGlobalSetupSwitch( void )
{
    BOOL bRetVal = FALSE;
    DWORD dwVal = 0;
    Registry r(TEXT("system\\Setup"));
    if (r.GetDWORD(TEXT("SystemSetupInProgress"), &dwVal ) == Registry::no_error)
    {
        if(dwVal == 1)
            bRetVal = TRUE;
    }
    return bRetVal;
}

//
//
//
// This function will place a volatile registry key under the 
// CIMOM key in which we will write a value indicating 
// we should not shell ADAP.  This way, after a setup runs, WINMGMT
// will NOT automatically shell ADAP dredges of the registry, 
// until the system is rebooted and the volatile registry key is removed.
//
//
///////////////////////////////////////////////////////////////////////////

void SetNoShellADAPSwitch( void )
{
    DWORD   dwDisposition = 0;

    Registry  r( HKEY_LOCAL_MACHINE, 
                 REG_OPTION_VOLATILE, KEY_READ | KEY_WRITE, WBEM_REG_ADAP );

    if ( ERROR_SUCCESS == r.GetLastError() )
    {

        if ( r.SetDWORD( WBEM_NOSHELL, 1 ) != Registry::no_error )
        {
            DEBUGTRACE( ( LOG_WINMGMT, "Failed to create NoShell value in volatile reg key: %d\n",
                        r.GetLastError() ) );
        }
    }
    else
    {
        DEBUGTRACE( ( LOG_WINMGMT, "Failed to create volatile ADAP reg key: %d\n", r.GetLastError() ) );
    }

}

//
//
//  bool IsValidMulti
//
//
//  Does a sanity check on a multstring.
//
//////////////////////////////////////////////////////////////////////


BOOL IsValidMulti(TCHAR * pMultStr, DWORD dwSize)
{
    // Divide the size by the size of a tchar, in case these
    // are WCHAR strings
    dwSize /= sizeof(TCHAR);

    if(pMultStr && dwSize >= 2 && pMultStr[dwSize-2]==0 && pMultStr[dwSize-1]==0)
        return TRUE;
    return FALSE;
}

//
//
//  BOOL IsStringPresetn
//
//
//  Searches a multstring for the presense of a string.
//
//
////////////////////////////////////////////////////////////////////

BOOL IsStringPresent(TCHAR * pTest, TCHAR * pMultStr)
{
    TCHAR * pTemp;
    for(pTemp = pMultStr; *pTemp; pTemp += lstrlen(pTemp) + 1)
        if(!lstrcmpi(pTest, pTemp))
            return TRUE;
    return FALSE;
}



//
//
//  AddToAutoRecoverList
//
//
////////////////////////////////////////////////////////////////////

void AddToAutoRecoverList(TCHAR * pFileName)
{
    TCHAR cFullFileName[MAX_PATH+1];
    TCHAR * lpFile;
    DWORD dwSize;
    TCHAR * pNew = NULL;
    TCHAR * pTest;
    DWORD dwNewSize = 0;

    // Get the full file name

    long lRet = GetFullPathName(pFileName, MAX_PATH, cFullFileName, &lpFile);
    if(lRet == 0)
        return;

    BOOL bFound = FALSE;
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pMulti = r.GetMultiStr(__TEXT("Autorecover MOFs"), dwSize);
    CVectorDeleteMe<TCHAR> dm_(pMulti);

    // Ignore the empty string case

    if(dwSize == 1)
    {
        pMulti = NULL;
    }
    if(pMulti)
    {
        if(!IsValidMulti(pMulti, dwSize))
        {
            return;             // bail out, messed up multistring
        }
        bFound = IsStringPresent(cFullFileName, pMulti);
        if(!bFound)
        {

            // The registry entry does exist, but doesnt have this name
            // Make a new multistring with the file name at the end

            dwNewSize = dwSize + ((lstrlen(cFullFileName) + 1) * sizeof(TCHAR));
            size_t cchSizeOld = dwSize / sizeof(TCHAR);
            size_t cchSizeNew = dwNewSize / sizeof(TCHAR);
            pNew = new TCHAR[cchSizeNew];
            if(!pNew) return;
            
            memcpy(pNew, pMulti, dwSize);

            // Find the double null

            for(pTest = pNew; pTest[0] || pTest[1]; pTest++);     // intentional semi

            // Tack on the path and ensure a double null;

            pTest++;
            size_t cchSizeTmp = cchSizeNew - cchSizeOld;
            StringCchCopy(pTest,cchSizeTmp,cFullFileName);
            pTest+= lstrlen(cFullFileName)+1;
            *pTest = 0;         // add second numm
        }
    }
    else
    {
        // The registry entry just doesnt exist.  
        // Create it with a value equal to our name

        dwNewSize = ((lstrlen(cFullFileName) + 2) * sizeof(TCHAR));
        pNew = new TCHAR[dwNewSize / sizeof(TCHAR)];
        if(!pNew)
            return;
        size_t cchSizeTmp = dwNewSize / sizeof(TCHAR);
        StringCchCopy(pNew,cchSizeTmp, cFullFileName);
        pTest = pNew + lstrlen(pNew) + 1;
        *pTest = 0;         // add second null
    }

    if(pNew)
    {
        // We will cast pNew, since the underlying function will have to cast to
        // LPBYTE and we will be WCHAR if UNICODE is defined
        r.SetMultiStr(__TEXT("Autorecover MOFs"), pNew, dwNewSize);
        delete [] pNew;
    }

    FILETIME ftCurTime;
    LARGE_INTEGER liCurTime;
    TCHAR szBuff[50];
    GetSystemTimeAsFileTime(&ftCurTime);
    liCurTime.LowPart = ftCurTime.dwLowDateTime;
    liCurTime.HighPart = ftCurTime.dwHighDateTime;
    _ui64tow(liCurTime.QuadPart, szBuff, 10);
    r.SetStr(__TEXT("Autorecover MOFs timestamp"), szBuff);

}


//
//  LoadMofsInDirectory
//
//
////////////////////////////////////////////////////////////////////////////////////////

void LoadMofsInDirectory(const TCHAR *szDirectory)
{
    if (NULL == szDirectory)
        return;
    
    if(CheckGlobalSetupSwitch())
        return;                     // not hot compiling during setup!

    size_t cchHotMof = lstrlen(szDirectory) + lstrlen(__TEXT("\\*")) + 1;
    TCHAR *szHotMofDirFF = new TCHAR[cchHotMof];
    if(!szHotMofDirFF)return;
    CDeleteMe<TCHAR> delMe1(szHotMofDirFF);

    size_t cchHotMofBad = lstrlen(szDirectory) + lstrlen(__TEXT("\\bad\\")) + 1;
    TCHAR *szHotMofDirBAD = new TCHAR[cchHotMofBad];
    if(!szHotMofDirBAD)return;
    CDeleteMe<TCHAR> delMe2(szHotMofDirBAD);

    size_t cchHotMofGood = lstrlen(szDirectory) + lstrlen(__TEXT("\\good\\")) + 1;
    TCHAR *szHotMofDirGOOD = new TCHAR[cchHotMofGood];
    if(!szHotMofDirGOOD)return;
    CDeleteMe<TCHAR> delMe3(szHotMofDirGOOD);

    IWinmgmtMofCompiler * pCompiler = NULL;

    //Find search parameter
    StringCchCopy(szHotMofDirFF,cchHotMof, szDirectory);
    StringCchCat(szHotMofDirFF,cchHotMof, __TEXT("\\*"));

    //Where bad mofs go
    StringCchCopy(szHotMofDirBAD,cchHotMofBad, szDirectory);
    StringCchCat(szHotMofDirBAD,cchHotMofBad, __TEXT("\\bad\\"));

    //Where good mofs go
    StringCchCopy(szHotMofDirGOOD,cchHotMofGood, szDirectory);
    StringCchCat(szHotMofDirGOOD,cchHotMofGood, __TEXT("\\good\\"));

    //Make sure directories exist
    WCHAR * pSDDL = TEXT("D:P(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)");   
    if (FAILED(TestDirExistAndCreateWithSDIfNotThere((TCHAR *)szDirectory,pSDDL))) { return; };
    if (FAILED(TestDirExistAndCreateWithSDIfNotThere(szHotMofDirBAD,pSDDL))) { return; };
    if (FAILED(TestDirExistAndCreateWithSDIfNotThere(szHotMofDirGOOD,pSDDL))) { return; };

    //Find file...
    WIN32_FIND_DATA ffd;
    HANDLE hFF = FindFirstFile(szHotMofDirFF, &ffd);

    if (hFF != INVALID_HANDLE_VALUE)
    {
        OnDelete<HANDLE,BOOL(*)(HANDLE),FindClose> cm(hFF);
        do
        {
            //We only process if this is a file
            if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                //Create a full filename with path
                size_t cchSizeTmp = lstrlen(szDirectory) + lstrlen(__TEXT("\\")) + lstrlen(ffd.cFileName) + 1;
                TCHAR *szFullFilename = new TCHAR[cchSizeTmp];
                if(!szFullFilename) return;
                CDeleteMe<TCHAR> delMe4(szFullFilename);
                StringCchCopy(szFullFilename,cchSizeTmp, szDirectory);
                StringCchCat(szFullFilename,cchSizeTmp, __TEXT("\\"));
                StringCchCat(szFullFilename,cchSizeTmp, ffd.cFileName);


                TRACE((LOG_WINMGMT,"Auto-loading MOF %s\n", szFullFilename));

                //We need to hold off on this file until it has been finished writing
                //otherwise the CompileFile will not be able to read the file!
                HANDLE hMof = INVALID_HANDLE_VALUE;
                DWORD dwRetry = 10;
                while (hMof == INVALID_HANDLE_VALUE)
                {
                    hMof = CreateFile(szFullFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

                    //If cannot open yet sleep for a while
                    if (hMof == INVALID_HANDLE_VALUE)
                    {
                        if (--dwRetry == 0)
                            break;
                        Sleep(1000);
                    }
                }

                DWORD dwRetCode;
                WBEM_COMPILE_STATUS_INFO Info;
                DWORD dwAutoRecoverRequired = 0;
                if (hMof == INVALID_HANDLE_VALUE)
                {
                    TRACE((LOG_WINMGMT,"Auto-loading MOF %s failed because we could not open it for exclusive access\n", szFullFilename));
                    dwRetCode = 1;
                }
                else
                {
                    CloseHandle(hMof);

                    if (pCompiler == 0)
                    {

                       SCODE sc = CoCreateInstance(CLSID_MofCompilerOOP, 0,  
                       	                                         CLSCTX_LOCAL_SERVER| CLSCTX_ENABLE_AAA, 
                                                                     IID_IWinmgmtMofCompilerOOP, 
                                                                     (LPVOID *) &pCompiler);                    
                       /*
                        SCODE sc = CoCreateInstance(CLSID_WinmgmtMofCompiler, 
                                                    0, 
                                                    CLSCTX_INPROC_SERVER,
                                                    IID_IWinmgmtMofCompiler, 
                                                    (LPVOID *) &pCompiler);
                       */                                                    
                        if(sc != S_OK)
                            return;
                    }
                    dwRetCode = pCompiler->WinmgmtCompileFile(szFullFilename,
                                                             NULL,
                                                             WBEM_FLAG_DONT_ADD_TO_LIST,             // autocomp, check, etc
                                                             0,
                                                             0,
                                                             NULL, 
                                                             NULL, 
                                                             &Info);

                }
                
                TCHAR *szNewDir = (dwRetCode?szHotMofDirBAD:szHotMofDirGOOD);
                cchSizeTmp = lstrlen(szNewDir)  + lstrlen(ffd.cFileName) + 1;
                TCHAR *szNewFilename = new TCHAR[cchSizeTmp];
                if(!szNewFilename) return;
                CDeleteMe<TCHAR> delMe5(szNewFilename);

                StringCchCopy(szNewFilename,cchSizeTmp, szNewDir);
                StringCchCat(szNewFilename,cchSizeTmp, ffd.cFileName);

                //Make sure we have access to delete the old file...
                DWORD dwOldAttribs = GetFileAttributes(szNewFilename);

                if (dwOldAttribs != -1)
                {
                    dwOldAttribs &= ~FILE_ATTRIBUTE_READONLY;
                    SetFileAttributes(szNewFilename, dwOldAttribs);

                    if (DeleteFile(szNewFilename))
                    {
                        TRACE((LOG_WINMGMT, "Removing old MOF %s\n", szNewFilename));
                    }
                }
                
                TRACE((LOG_WINMGMT, "Loading of MOF %s was %s.  Moving to %s\n", szFullFilename, dwRetCode?"unsuccessful":"successful", szNewFilename));
                MoveFile(szFullFilename, szNewFilename);

                //Now mark the file as read only so no one deletes it!!!
                //Like that stops anyone deleting files :-)
                dwOldAttribs = GetFileAttributes(szNewFilename);

                if (dwOldAttribs != -1)
                {
                    dwOldAttribs |= FILE_ATTRIBUTE_READONLY;
                    SetFileAttributes(szNewFilename, dwOldAttribs);
                }

                if ((dwRetCode == 0) && (Info.dwOutFlags & AUTORECOVERY_REQUIRED))
                {
                    //We need to add this item into the registry for auto-recovery purposes
                    TRACE((LOG_WINMGMT, "MOF %s had an auto-recover pragrma.  Updating registry.\n", szNewFilename));
                    AddToAutoRecoverList(szNewFilename);
                }
            }
        } while (FindNextFile(hFF, &ffd));
    }
    if (pCompiler)
        pCompiler->Release();
}


//
//
//  bool InitHotMofStuff
//
//
//////////////////////////////////////////////////////////////////

BOOL InitHotMofStuff( IN OUT struct _PROG_RESOURCES * pProgRes)
{

    // Get the installation directory

    if (pProgRes->szHotMofDirectory)
    {
        delete [] pProgRes->szHotMofDirectory;
        pProgRes->szHotMofDirectory = NULL;
    }

    Registry r1(WBEM_REG_WINMGMT);

    // The HotMof same permission as the autorecover
    TCHAR * pMofDir = NULL;    
    if (r1.GetStr(__TEXT("MOF Self-Install Directory"), &pMofDir))
    {
        size_t cchSizeTmp = MAX_PATH + 1 + lstrlen(__TEXT("\\wbem\\mof"));
        pMofDir = new TCHAR[cchSizeTmp];
        if (NULL == pMofDir) return false;
        
        DWORD dwRet = GetSystemDirectory(pMofDir, MAX_PATH + 1);
        if (0 == dwRet || dwRet > (MAX_PATH)) { delete [] pMofDir; return false; }
        
        StringCchCat(pMofDir,cchSizeTmp, __TEXT("\\wbem\\mof"));
        
        if(r1.SetStr(__TEXT("MOF Self-Install Directory"),pMofDir) == Registry::failed)
        {
            ERRORTRACE((LOG_WINMGMT,"Unable to set 'Hot MOF Directory' in the registry\n"));
            delete [] pMofDir;
            return false;
        }        
    }
    pProgRes->szHotMofDirectory = pMofDir;

    // Ensure the directory is there and secure it if not there
    // ===================================
    TCHAR * pString =TEXT("D:P(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)"); 
    HRESULT hRes;
    if (FAILED(hRes = TestDirExistAndCreateWithSDIfNotThere(pProgRes->szHotMofDirectory,pString)))
    {
        ERRORTRACE((LOG_WINMGMT,"TestDirExistAndCreateWithSDIfNotThere %S hr %08x\n",pMofDir,hRes));        
    	return false;
    }

    //Create an event on change notification for the MOF directory
    pProgRes->ghMofDirChange = FindFirstChangeNotification(pProgRes->szHotMofDirectory, 
                                                 FALSE, 
                                                 FILE_NOTIFY_CHANGE_FILE_NAME);
                                                 
    if (pProgRes->ghMofDirChange == INVALID_HANDLE_VALUE)
    {
        pProgRes->ghMofDirChange = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pProgRes->ghMofDirChange == NULL)
            return false;
    }
    
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\regcode.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2001 Microsoft Corporation, All rights reserved
//
//  Module: regcode.cpp
//  
//  Implements the Service registration routines
//
//  History:
//
//    ivanbrug      17-09-2000        CreateF
//
//
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <winmgmt.h>
#include <strings.h> // for LoadString
#include <malloc.h>
#include <winntsec.h>
#include <autoptr.h>
#include <strutils.h>

#define SVCHOST_HOME  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost") 
#define SERVICE_PATH  TEXT("System\\CurrentControlSet\\Services\\")
#define DLL_PATH      TEXT("%SystemRoot%\\system32\\wbem\\WMIsvc.dll")
#define ENTRY_POINT   TEXT("ServiceMain")

#define COM_APPID TEXT("Software\\classes\\AppID\\{8BC3F05E-D86B-11D0-A075-00C04FB68820}")
    //= Windows Management Instrumentation
    //LocalService = WinMgmt

#define COM_APPID_NAME TEXT("Software\\classes\\AppID\\winmgmt")
    //AppID = {8BC3F05E-D86B-11D0-A075-00C04FB68820}
    
#define SERVICE_CLSID TEXT("{8BC3F05E-D86B-11D0-A075-00C04FB68820}")


#define SERVICE_NAME_GROUP_ALONE TEXT("winmgmt")
#define SERVICE_NAME_GROUP TEXT("netsvcs")
#define SERVICE_NAME_GROUP_TOGETHER TEXT("netsvcs")


// see winmgmt.h
//#define SERVICE_NAME       TEXT("winmgmt")

#define VALUE_AUTH   TEXT("AuthenticationCapabilities")
#define VALUE_COINIT TEXT("CoInitializeSecurityParam")
#define VALUE_AUTZN  TEXT("AuthenticationLevel")
#define VALUE_IMPER  TEXT("ImpersonationLevel") 

#define ACCOUNT_NAME   TEXT("LocalService") // unused, for now
#define DISPLAY_CLSID        TEXT("Windows Management and Instrumentation")
#define DISPLAY_BACKUP_CLSID TEXT("Windows Management Instrumentation Backup and Recovery")

//
// for the Description string
//
#define MAX_BUFF 2048

//
// this is the rundll32 interface
// usage is 
// C:\>rundll32 %windir%\system32\wbem\wmisvc.dll,MoveToAlone X
// where X is the AuthenticationLevel
//
//////////////////////////////////////////////////////////////////

void CALLBACK 
MoveToAlone(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow) //RPC_C_AUTHN_LEVEL_CONNECT
{
    BOOL bRet = TRUE;
    LONG lRet;
    

    DWORD dwLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    if (lpszCmdLine)
    {
        dwLevel = atoi(lpszCmdLine);
        if (0 == dwLevel)  // in case of error
        {
            dwLevel = RPC_C_AUTHN_LEVEL_CONNECT;
        }
    }

    
    if (bRet)
    {
        // create the new group key under svchost        
        HKEY hKey;
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            SVCHOST_HOME,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);
        if (ERROR_SUCCESS == lRet)
        {
            OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm(hKey);
            // add the group

            LONG lRet2;
            DWORD dwCurrSize = 0;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[(dwCurrSize+sizeof(SERVICE_NAME)+4)];
                wmilib::auto_buffer<BYTE> rm_(pMulti);
                if (pMulti)
                {
                    lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,&dwType,pMulti,&dwCurrSize);                
                    if (ERROR_SUCCESS == lRet2 && REG_MULTI_SZ == dwType)
                    {
                        TCHAR * pInsertPoint = (TCHAR *)(pMulti+dwCurrSize-sizeof(TCHAR));
                        // verify the multisz  
                        TCHAR *pEnd = (TCHAR *)pMulti;
                        BOOL bIsThere = FALSE;

                        while (*pEnd) 
                        {
                            if (0 == wbem_wcsicmp(pEnd,SERVICE_NAME))
                            {
                                bIsThere = TRUE;  
                            }
                            while (*pEnd){
                                pEnd++;
                            }
                            pEnd++; // past the zero who terminates the string
                        }
                        if (!bIsThere)
                        {
                            if ((ULONG_PTR)pEnd == (ULONG_PTR)pInsertPoint)
                            {
                                wcsncpy(pEnd,SERVICE_NAME TEXT("\0"),sizeof(SERVICE_NAME)/sizeof(TCHAR)+1);
                                DWORD dwNowSize = dwCurrSize+sizeof(SERVICE_NAME);
                                if (ERROR_SUCCESS == RegSetValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,REG_MULTI_SZ,pMulti,dwNowSize))
                                    bRet = TRUE;
                                else
                                    bRet = FALSE;
                            }
                            else
                            {
                                bRet = FALSE;
                            }
                        }
                    }
                }
            }
            else if (ERROR_FILE_NOT_FOUND == lRet2) 
            {
                BYTE * pMulti = (BYTE *)SERVICE_NAME_GROUP_ALONE TEXT("\0");                
                LONG lResInner = RegSetValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,REG_MULTI_SZ,pMulti,sizeof(SERVICE_NAME_GROUP)+sizeof(TEXT("")));
                bRet = (ERROR_SUCCESS == lResInner)?TRUE:FALSE;
            }
            else
            {
                bRet = FALSE;
            }

            // create the key with the COM init Param
            if (bRet)
            {
                HKEY hKey2;
                DWORD dwDisposistion;
                lRet = RegCreateKeyEx(hKey,
                                      SERVICE_NAME_GROUP_ALONE,
                                      0,NULL,
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_ALL_ACCESS,
                                      NULL,
                                      &hKey2,
                                      &dwDisposistion);
                if (ERROR_SUCCESS == lRet)
                {
                    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm2(hKey2);
                    
                    // any value non NULL will work
                    DWORD dwVal = 1;
                    RegSetValueEx(hKey2,VALUE_COINIT,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));
                    // from packet to connect
                    dwVal = dwLevel; //RPC_C_AUTHN_LEVEL_CONNECT;
                    RegSetValueEx(hKey2,VALUE_AUTZN,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

                    dwVal = RPC_C_IMP_LEVEL_IDENTIFY;
                    RegSetValueEx(hKey2,VALUE_IMPER,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

                    dwVal = EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL | EOAC_STATIC_CLOAKING ;
                    RegSetValueEx(hKey2,VALUE_AUTH,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

                    bRet = TRUE;
                }
                else
                {
                    bRet = FALSE;
                }
            }
        }
        else
        {
            // no svchost key
            bRet = FALSE;
        }
    }

    if (bRet)
    {
        SC_HANDLE scHandle = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
        if (scHandle)
        {
            OnDelete<SC_HANDLE,BOOL(*)(SC_HANDLE),CloseServiceHandle> cm1(scHandle);
            
            SC_HANDLE scService = OpenService(scHandle,SERVICE_NAME,SERVICE_ALL_ACCESS);            
            if (scService)
            {
                OnDelete<SC_HANDLE,BOOL(*)(SC_HANDLE),CloseServiceHandle> cm2(scService);
                
                DWORD dwNeeded = 0;
                bRet = QueryServiceConfig(scService,NULL,0,&dwNeeded);
                
                if (!bRet && (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
                {
                    BYTE * pByte = new BYTE[dwNeeded];
                    wmilib::auto_buffer<BYTE> rm_(pByte);
                    QUERY_SERVICE_CONFIG* pConfig = (QUERY_SERVICE_CONFIG *)pByte;
                    if (pConfig)
                    {
                        bRet = QueryServiceConfig(scService,pConfig,dwNeeded,&dwNeeded);
                        if (bRet)
                        {
                              TCHAR BinPath[MAX_PATH];
                              StringCchPrintf(BinPath,MAX_PATH,TEXT("%%systemroot%%\\system32\\svchost.exe -k %s"),SERVICE_NAME_GROUP_ALONE);

                              bRet = ChangeServiceConfig(scService,
                                                         pConfig->dwServiceType,
                                                         pConfig->dwStartType,
                                                         pConfig->dwErrorControl,
                                                         BinPath,
                                                         pConfig->lpLoadOrderGroup,
                                                         NULL, //&pConfig->dwTagId,
                                                         pConfig->lpDependencies,
                                                         pConfig->lpServiceStartName,
                                                         NULL,
                                                         pConfig->lpDisplayName);
                              if (!bRet)
                              {
                                  DBG_PRINTFA((pBuff,"ChangeServiceConfig %d\n",GetLastError()));
                              }
                        }
                    }
                    else
                    {
                        bRet = FALSE;
                    }
                }                
                else
                {
                    bRet = FALSE;
                }
            }
            else
            {
                // the service was not there or other error
                DBG_PRINTFA((pBuff,"MoveToStandalone OpenService %d\n",GetLastError()));                
                bRet = FALSE;
            }            
        }
        else
        {
            DBG_PRINTFA((pBuff,"MoveToStandalone OpenSCManager %d\n",GetLastError()));
            bRet = FALSE;
        }
    }

    if (bRet)
    {
    //
    //  remove the winmgmt string from the multi-sz of netsvcs
    //    
        HKEY hKey;
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            SVCHOST_HOME,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);
        if (ERROR_SUCCESS == lRet)
        {
            OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm3(hKey);  
            // add the group

            LONG lRet2;
            DWORD dwCurrSize = 0;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[dwCurrSize+4];
                wmilib::auto_buffer<BYTE> rm1_(pMulti);
                BYTE * pMultiNew = new BYTE[dwCurrSize+4];
                wmilib::auto_buffer<BYTE> rm2_(pMultiNew);
                TCHAR * pMultiNewCopy = (TCHAR *)pMultiNew;

                if (pMulti && pMultiNew)
                {
                    lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,&dwType,pMulti,&dwCurrSize);
                    
                    if (ERROR_SUCCESS == lRet2 && REG_MULTI_SZ == dwType) 
                    {
                        
                        // verify the multisz  
                        TCHAR *pEnd = (TCHAR *)pMulti;
                        BOOL bIsThere = FALSE;

                        while (*pEnd) 
                        {
                            if (0 == wbem_wcsicmp(pEnd,SERVICE_NAME))
                            {
                                bIsThere = TRUE; 
                                while (*pEnd){
                                    pEnd++;
                                }
                                pEnd++; // past the zero who terminates the string                            
                            }
                            else // copy
                            {
                                while (*pEnd){
                                    *pMultiNewCopy++ = *pEnd++;
                                }
                                pEnd++; // past the zero who terminates the string
                                *pMultiNewCopy++ = 0;
                            }
                        }
                        *pMultiNewCopy++ = 0;  // put the double terminator
                        
                        if (bIsThere)
                        {
                            DWORD dwNowSize = dwCurrSize-sizeof(SERVICE_NAME);
                            RegSetValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,REG_MULTI_SZ,pMultiNew,dwNowSize);
                        }
                    }
                    else
                    {
                        bRet = FALSE;
                    }
                }
                else
                {
                    bRet = FALSE;
                }
            }
            else
            {
                //
                //  the netsvcs multi sz MUST be there !!!!
                //
                bRet = TRUE;
            }

        }
        else
        {
             bRet = FALSE;
        }
    }

    return;
}

//
//
// this is the rundll32 interface
//
//
//////////////////////////////////////////////////////////////////

void CALLBACK 
MoveToShared(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow) //RPC_C_AUTHN_LEVEL_CONNECT
{
    //
    BOOL bRet = TRUE;
    LONG lRet;
    

    DWORD dwLevel = RPC_C_PROTECT_LEVEL_PKT;
    if (lpszCmdLine)
    {
        dwLevel = atoi(lpszCmdLine);
        if (0 == dwLevel)  // in case of error
        {
            dwLevel = RPC_C_PROTECT_LEVEL_PKT;
        }
    }

    // create the new group key under svchost
    if (bRet)
    {
        HKEY hKey;
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            SVCHOST_HOME,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);
        if (ERROR_SUCCESS == lRet)
        {
            OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm(hKey);  
            // add the group

            LONG lRet2;
            DWORD dwCurrSize = 0;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[(dwCurrSize+sizeof(SERVICE_NAME)+4)];
                wmilib::auto_buffer<BYTE> rm_(pMulti);
                if (pMulti)
                {
                    lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,&dwType,pMulti,&dwCurrSize);
                    
                    if (ERROR_SUCCESS == lRet2 && REG_MULTI_SZ == dwType)
                    {
                        TCHAR * pInsertPoint = (TCHAR *)(pMulti+dwCurrSize-sizeof(TCHAR));
                        // verify the multisz  
                        TCHAR *pEnd = (TCHAR *)pMulti;
                        BOOL bIsThere = FALSE;

                        while (*pEnd) 
                        {
                            if (0 == wbem_wcsicmp(pEnd,SERVICE_NAME))
                            {
                                bIsThere = TRUE;  
                            }
                            while (*pEnd){
                                pEnd++;
                            }
                            pEnd++; // past the zero who terminates the string
                        }
                        if (!bIsThere)
                        {
                            if ((ULONG_PTR)pEnd == (ULONG_PTR)pInsertPoint)
                            {
                                wcsncpy(pEnd,SERVICE_NAME TEXT("\0"),sizeof(SERVICE_NAME)/sizeof(TCHAR)+1);
                                DWORD dwNowSize = dwCurrSize+sizeof(SERVICE_NAME);
                                RegSetValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,REG_MULTI_SZ,pMulti,dwNowSize);
                            }
                            else
                            {
                                bRet = FALSE;
                                DBG_PRINTFA((pBuff,"Malformed REG_MULTI_SZ under %S\n",SERVICE_NAME_GROUP_TOGETHER));
                            }
                        }
                    }
                    else
                    {
                        // invalid type in reg_multi_sz
                        bRet = FALSE;
                    }
                }
                else
                {
                    bRet = FALSE;
                }
            }
            else if (ERROR_FILE_NOT_FOUND == lRet2) 
            {
                BYTE * pMulti = (BYTE *)SERVICE_NAME_GROUP_TOGETHER TEXT("\0");                
                RegSetValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,REG_MULTI_SZ,pMulti,sizeof(SERVICE_NAME_GROUP)+sizeof(TEXT("")));            
            }
            else
            {
                bRet = FALSE;
            }

            HKEY hKey2;
            DWORD dwDisposistion;
            lRet = RegCreateKeyEx(hKey,
                                  SERVICE_NAME_GROUP_TOGETHER,
                                  0,NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKey2,
                                  &dwDisposistion);
            if (ERROR_SUCCESS == lRet)
            {
                OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm2(hKey2);  
                
                // any value non NULL will work
                DWORD dwVal = 1;
                RegSetValueEx(hKey2,VALUE_COINIT,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));
                // from packet to connect
                dwVal = dwLevel; //RPC_C_AUTHN_LEVEL_CONNECT;
                RegSetValueEx(hKey2,VALUE_AUTZN,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

                dwVal = RPC_C_IMP_LEVEL_IDENTIFY;
                RegSetValueEx(hKey2,VALUE_IMPER,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

                dwVal = EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL | EOAC_STATIC_CLOAKING ;
                RegSetValueEx(hKey2,VALUE_AUTH,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));
                
                bRet = TRUE;
            }
            else
            {
                DBG_PRINTFA((pBuff,"Could not create %S\n",SERVICE_NAME_GROUP_TOGETHER));
                bRet = FALSE;
            }
        }
        else
        {
            bRet = FALSE;
        }
    }

    //
    //  changes the SCM database
    //
    if (bRet)
    {
        SC_HANDLE scHandle = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);

        if (scHandle)
        {
            OnDelete<SC_HANDLE,BOOL(*)(SC_HANDLE),CloseServiceHandle> cm1(scHandle);

            SC_HANDLE  scService = OpenService(scHandle,SERVICE_NAME,SERVICE_ALL_ACCESS);
            
            if (scService)
            {
                OnDelete<SC_HANDLE,BOOL(*)(SC_HANDLE),CloseServiceHandle> cm2(scService);

                DWORD dwNeeded = 0;
                bRet = QueryServiceConfig(scService,NULL,0,&dwNeeded);
                
                if (!bRet && (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
                {
                    BYTE * pByte = new BYTE[dwNeeded];
                    wmilib::auto_buffer<BYTE> rm1_(pByte);
                    QUERY_SERVICE_CONFIG* pConfig = (QUERY_SERVICE_CONFIG *)pByte;
                    if (pConfig)
                    {
                        bRet = QueryServiceConfig(scService,pConfig,dwNeeded,&dwNeeded);
                        if (bRet)
                        {
                              TCHAR BinPath[MAX_PATH];
                              StringCchPrintf(BinPath,MAX_PATH,TEXT("%%systemroot%%\\system32\\svchost.exe -k %s"),SERVICE_NAME_GROUP_TOGETHER);

                              bRet = ChangeServiceConfig(scService,
                                                         pConfig->dwServiceType,
                                                         pConfig->dwStartType,
                                                         pConfig->dwErrorControl,
                                                         BinPath,
                                                         pConfig->lpLoadOrderGroup,
                                                         NULL, //&pConfig->dwTagId,
                                                         pConfig->lpDependencies,
                                                         pConfig->lpServiceStartName,
                                                         NULL,
                                                         pConfig->lpDisplayName);
                              if (!bRet)
                              {
                                  DBG_PRINTFA((pBuff,"ChangeServiceConfig %d\n",GetLastError()));
                              }
                        }
                    }
                    else
                    {
                        bRet = FALSE;
                    }
                }
                else
                {
                    bRet = FALSE;
                }
            }
            else
            {
                // the service was not there or other error
                DBG_PRINTFA((pBuff,"MoveToShared OpenService %d\n",GetLastError()));                
                bRet = FALSE;
            }
        }
        else
        {
            DBG_PRINTFA((pBuff,"MoveToShared OpenSCManager %d\n",GetLastError()));
            bRet = FALSE;
        }
    }


    if (bRet)
    {
    //
    //  remove the winmgmt string from the multi-sz of winmgmt
    //    
        HKEY hKey;
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            SVCHOST_HOME,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);
        if (ERROR_SUCCESS == lRet)
        {
            OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm3(hKey);
            // add the group

            LONG lRet2;
            DWORD dwCurrSize;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[dwCurrSize+4];
                wmilib::auto_buffer<BYTE> rm2_(pMulti);                
                BYTE * pMultiNew = new BYTE[dwCurrSize+4];
                wmilib::auto_buffer<BYTE> rm3_(pMultiNew);
                TCHAR * pMultiNewCopy = (TCHAR *)pMultiNew;

                if (pMulti && pMultiNew)
                {
                    lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,&dwType,pMulti,&dwCurrSize);
                    
                    if (ERROR_SUCCESS == lRet2 && REG_MULTI_SZ == dwType)
                    {
                        
                        // verify the multisz  
                        TCHAR *pEnd = (TCHAR *)pMulti;
                        BOOL bIsThere = FALSE;

                        while (*pEnd) 
                        {
                            if (0 == wbem_wcsicmp(pEnd,SERVICE_NAME))
                            {
                                bIsThere = TRUE; 
                                while (*pEnd){
                                    pEnd++;
                                }
                                pEnd++; // past the zero who terminates the string                            
                            }
                            else // copy
                            {
                                while (*pEnd){
                                    *pMultiNewCopy++ = *pEnd++;
                                }
                                pEnd++; // past the zero who terminates the string
                                *pMultiNewCopy++ = 0;
                            }
                        }
                        *pMultiNewCopy++ = 0;  // put the double terminator
                        
                        if (bIsThere)
                        {
                            DWORD dwNowSize = dwCurrSize-sizeof(SERVICE_NAME);
                            RegSetValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,REG_MULTI_SZ,pMultiNew,dwNowSize);
                        }
                    }
                    else
                    {
                        bRet = FALSE;
                    }
                }
                else
                {
                    bRet = FALSE;
                }
            }
            else
            {
                //
                //  the winmgmt multi sz MUST can be NOT there
                //
                bRet = TRUE;
            }
        }
        else
        {
             bRet = FALSE;
        }
    }

    
}

//***************************************************************************
//
//  void InitializeLaunchPermissions()
//
//  DESCRIPTION:
//
//  Sets the DCOM Launch permissions.
//
//***************************************************************************

void InitializeLaunchPermissions()
{

    Registry reg(__TEXT("SOFTWARE\\CLASSES\\APPID\\{8bc3f05e-d86b-11d0-a075-00c04fb68820}"));
    if(reg.GetLastError() != 0)
        return;

    // If there already is a SD, then dont overwrite

    BYTE * pData = NULL;
    DWORD dwDataSize = 0;

    int iRet = reg.GetBinary(__TEXT("LaunchPermission"), &pData, &dwDataSize);
    if(iRet == 0)
    {
        delete [] pData;       
        return; // it's already there
    }
    
    PSID pEveryoneSid;
    SID_IDENTIFIER_AUTHORITY id_World = SECURITY_WORLD_SID_AUTHORITY;

    if(!AllocateAndInitializeSid( &id_World, 1,
                                            SECURITY_WORLD_RID,
                                            0,0,0,0,0,0,0,
                                            &pEveryoneSid)) return;
    OnDelete<PSID,PVOID(*)(PSID),FreeSid> freeSid1(pEveryoneSid);

    SID_IDENTIFIER_AUTHORITY  id_NT = SECURITY_NT_AUTHORITY;
    PSID pAdministratorsSid = NULL;
    
    if (!AllocateAndInitializeSid(&id_NT,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0, 0, 0, 0, 0, 0,
                            &pAdministratorsSid)) return; 
    OnDelete<PSID,PVOID(*)(PSID),FreeSid> freeSid2(pAdministratorsSid);
    
    // Create the class sids for everyone and administrators
    CNtSid SidEveryone(pEveryoneSid);
    CNtSid SidAdmins(pAdministratorsSid);
    
    if(SidEveryone.GetStatus() != 0 || SidAdmins.GetStatus() != 0)
        return;

    // Create a single ACE, and add it to the ACL

    CNtAcl DestAcl;
    CNtAce Users(1, ACCESS_ALLOWED_ACE_TYPE, 0, SidEveryone);
    if(Users.GetStatus() != 0)
        return;
    DestAcl.AddAce(&Users);
    if(DestAcl.GetStatus() != 0)
        return;

    // Set the descresionary acl, and the owner and group sids
    //  Create a sd with a single entry for launch permissions.
    CNtSecurityDescriptor LaunchPermSD;
    LaunchPermSD.SetDacl(&DestAcl);
    LaunchPermSD.SetOwner(&SidAdmins);
    LaunchPermSD.SetGroup(&SidAdmins);
    if(LaunchPermSD.GetStatus() != 0) return;

    // Write it out
    reg.SetBinary(__TEXT("LaunchPermission"), (BYTE *)LaunchPermSD.GetPtr(), LaunchPermSD.GetSize());
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the COM server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************
//
// Phase 1 : Create the MULTI_SZ under the svchost key (AKA, create a group of services)
//               If the key is there, check if the WinMgmt service is already there, otherwise add it
// Phase 2 : Use the SCM Api in order to create the service if not there
//               otherwise change the service configuration to some known value
// Phase 3 : Creates specific keys under the Services\WinMgmt key.
//                cannot be done before, if the service is not already there
// Phase 4 : Expose this service as a COM server, creates CLSID, APPID and misc keys
//
STDAPI DllRegisterServer(void)
{
    LONG lRet;
    BOOL bRet = TRUE;

    // 
    // Phase 1
    //
    if (bRet)
    {
        HKEY hKey;
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            SVCHOST_HOME,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);
        if (ERROR_SUCCESS == lRet)
        {
           OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm(hKey);            
            // add the group

            LONG lRet2;
            DWORD dwCurrSize = 0;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[(dwCurrSize+sizeof(SERVICE_NAME)+4)];
                wmilib::auto_buffer<BYTE> rm4_(pMulti);
                if (pMulti)
                {
                    lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP,0,&dwType,pMulti,&dwCurrSize);
                    
                    if (ERROR_SUCCESS == lRet2 && REG_MULTI_SZ == dwType )
                    {
                        TCHAR * pInsertPoint = (TCHAR *)(pMulti+dwCurrSize-sizeof(TCHAR));
                        // verify the multisz  
                        TCHAR *pEnd = (TCHAR *)pMulti;
                        BOOL bIsThere = FALSE;

                        while (*pEnd) 
                        {
                            if (0 == wbem_wcsicmp(pEnd,SERVICE_NAME))
                            {
                                bIsThere = TRUE;  
                            }
                            while (*pEnd){
                                pEnd++;
                            }
                            pEnd++; // past the zero who terminates the string
                        }
                        if (!bIsThere)
                        {
                            if ((ULONG_PTR)pEnd == (ULONG_PTR)pInsertPoint)
                            {
                                wcsncpy(pEnd,SERVICE_NAME TEXT("\0"),sizeof(SERVICE_NAME)/sizeof(TCHAR)+1);
                                DWORD dwNowSize = dwCurrSize+sizeof(SERVICE_NAME);
                                RegSetValueEx(hKey,SERVICE_NAME_GROUP,0,REG_MULTI_SZ,pMulti,dwNowSize);
                            }
                            else
                            {
                                bRet = FALSE;
                            }
                        }
                    }
                    else
                    {
                        bRet = FALSE;
                    }
                }
                else
                {
                    bRet = FALSE;
                }
            }
            else if (ERROR_FILE_NOT_FOUND == lRet2) 
            {
                BYTE * pMulti = (BYTE *)SERVICE_NAME_GROUP TEXT("\0");                
                lRet = RegSetValueEx(hKey,SERVICE_NAME_GROUP,0,REG_MULTI_SZ,pMulti,sizeof(SERVICE_NAME_GROUP)+sizeof(TEXT("")));
                bRet = (ERROR_SUCCESS == lRet)?TRUE:FALSE;
            }
            else
            {                
                bRet = FALSE;
            }

            HKEY hKey2;
            DWORD dwDisposistion;
            lRet = RegCreateKeyEx(hKey,
                                  SERVICE_NAME_GROUP,
                                  0,NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKey2,
                                  &dwDisposistion);
            if (ERROR_SUCCESS == lRet)
            {
                OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm2(hKey2); 
                
                // any value non NULL will work
                DWORD dwVal = 1;
                RegSetValueEx(hKey2,VALUE_COINIT,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

                // servicehost default + static cloaking
                dwVal = EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL | EOAC_STATIC_CLOAKING ;
                RegSetValueEx(hKey2,VALUE_AUTH,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));
                
                bRet = TRUE;
            }
            else
            {
                bRet = FALSE;
            }
        }
        else
        {
            bRet = FALSE;
        }
    }

    // 
    // Phase 2
    //
    if (bRet)
    {
        SC_HANDLE hSCM = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
        if (hSCM)
        {
            OnDelete<SC_HANDLE,BOOL(*)(SC_HANDLE),CloseServiceHandle> cm1(hSCM);

            DWORD dwTag;
            TCHAR BinPath[MAX_PATH];
            
            StringCchPrintf(BinPath,MAX_PATH,TEXT("%%systemroot%%\\system32\\svchost.exe -k %s"),SERVICE_NAME_GROUP);

            TCHAR * pServiceDisplay = new TCHAR[MAX_BUFF];
            wmilib::auto_buffer<TCHAR> rm(pServiceDisplay);
            if (pServiceDisplay)
            {
                int nRet = LoadString(g_hInstance,ID_WINMGMT_SERVICE,pServiceDisplay,MAX_BUFF);
            }
            else
            {
                bRet = FALSE;
            }

            SC_HANDLE hService = NULL;
            if (bRet)
            {
                hService = OpenService(hSCM,SERVICE_NAME,SERVICE_ALL_ACCESS );
            }
            
            SC_ACTION ac[2];
            ac[0].Type = SC_ACTION_RESTART;
            ac[0].Delay = 60000;
            ac[1].Type = SC_ACTION_RESTART;
            ac[1].Delay = 60000;
                    
            SERVICE_FAILURE_ACTIONS sf;
            sf.dwResetPeriod = 86400;
            sf.lpRebootMsg = NULL;
            sf.lpCommand = NULL;
            sf.cActions = 2;
            sf.lpsaActions = ac;            
                        
            if (hService)
            {
                OnDelete<SC_HANDLE,BOOL(*)(SC_HANDLE),CloseServiceHandle> cm2(hService);
                
                bRet = ChangeServiceConfig(hService,                                         
                                         SERVICE_WIN32_SHARE_PROCESS,
                                         SERVICE_AUTO_START, //SERVICE_DEMAND_START,
                                         SERVICE_ERROR_IGNORE,
                                         BinPath,
                                         NULL,
                                         NULL,
                                         TEXT("RPCSS\0Eventlog\0\0\0"),
                                         NULL, //ACCOUNT_NAME,
                                         NULL,
                                         pServiceDisplay);
                if (bRet)
                {
                    ChangeServiceConfig2(hService, SERVICE_CONFIG_FAILURE_ACTIONS, &sf);                                         
                    //
                    //  insert code for description here
                    TCHAR * pBuff = new TCHAR[MAX_BUFF];
                    if (pBuff)
                    {
                        int nRet = LoadString(g_hInstance,ID_WINMGMT_DESCRIPTION,pBuff,MAX_BUFF);
                        if (nRet)
                        {
                            SERVICE_DESCRIPTION sd;
                            sd.lpDescription = pBuff;
                               ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION,&sd);
                        }
                        delete [] pBuff;
                    }
                    //
                    //
                    
                }
                else
                {
                    DBG_PRINTFA((pBuff,"ChangeServiceConfig %d\n",GetLastError()));
                }
            }
            else
            {
                // Create it
                hService = CreateService(hSCM,
                                         SERVICE_NAME,
                                         pServiceDisplay,
                                         SERVICE_ALL_ACCESS,
                                         SERVICE_WIN32_SHARE_PROCESS,
                                         SERVICE_AUTO_START, //SERVICE_DEMAND_START,
                                         SERVICE_ERROR_IGNORE,
                                         BinPath,
                                         NULL,
                                         NULL,
                                         TEXT("RPCSS\0Eventlog\0\0\0"),
                                         NULL, //ACCOUNT_NAME,
                                         NULL);
                if (hService)
                {
                    OnDelete<SC_HANDLE,BOOL(*)(SC_HANDLE),CloseServiceHandle> cm3(hService);
                                    
                    ChangeServiceConfig2(hService, SERVICE_CONFIG_FAILURE_ACTIONS, &sf);

                    //
                    //  insert code for description here
                    TCHAR * pBuff = new TCHAR[MAX_BUFF];
                    if (pBuff)
                    {
                        int nRet = LoadString(g_hInstance,ID_WINMGMT_DESCRIPTION,pBuff,MAX_BUFF);
                        if (nRet)
                        {
                            SERVICE_DESCRIPTION sd;
                            sd.lpDescription = pBuff;
                               ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION,&sd);
                        }
                        delete [] pBuff;
                    }
                    bRet = TRUE;
                }
                else
                {
                    bRet = FALSE;
                }
            }
        }
        else
        {
            bRet = FALSE;
        }        
    }

    //
    // Phase 3
    //
    if (bRet)
    {
        HKEY hKey;
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            SERVICE_PATH SERVICE_NAME,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);
        if (ERROR_SUCCESS == lRet)
        {
           OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm3(hKey);             
           
            HKEY hKey3;
            DWORD dwDisposistion;
            lRet = RegCreateKeyEx(hKey,
                                  TEXT("Parameters"),
                                  0,NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKey3,
                                  &dwDisposistion);
            if (ERROR_SUCCESS == lRet)
            {
                
                
                RegSetValueEx(hKey3,TEXT("ServiceDll"),0,REG_EXPAND_SZ,(BYTE *)DLL_PATH,sizeof(DLL_PATH)-sizeof(TCHAR));
                
                RegSetValueEx(hKey3,TEXT("ServiceMain"),0,REG_SZ,(BYTE *)ENTRY_POINT,sizeof(ENTRY_POINT)-sizeof(TCHAR));

                RegCloseKey(hKey3);

                bRet = TRUE;
            }
            else
            {
                bRet = FALSE;
            }
        }
        else
        {
            bRet = FALSE;
        }
    }

    //
    // Phase 4
    //

    if (bRet)
    {
        HKEY hKey4;
        DWORD dwDisposistion;
        lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              COM_APPID,
                              0,NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey4,
                              &dwDisposistion);
        if (ERROR_SUCCESS == lRet)
        {
            RegSetValueEx(hKey4,NULL,0,REG_SZ,(BYTE *)DISPLAY_CLSID,sizeof(DISPLAY_CLSID)-sizeof(TCHAR));
            RegSetValueEx(hKey4,TEXT("LocalService"),0,REG_SZ,(BYTE *)SERVICE_NAME,sizeof(SERVICE_NAME)-sizeof(TCHAR));
            RegCloseKey(hKey4);
        }

        lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              COM_APPID_NAME,
                              0,NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey4,
                              &dwDisposistion);
        if (ERROR_SUCCESS == lRet)
        {
            
            RegSetValueEx(hKey4,TEXT("AppID"),0,REG_SZ,(BYTE *)SERVICE_CLSID,sizeof(SERVICE_CLSID)-sizeof(TCHAR));
            RegCloseKey(hKey4);
        }

        InitializeLaunchPermissions();

        OLECHAR ClsidBuff[40];
        TCHAR * ClsidBuff2;
        TCHAR ClsidPath[MAX_PATH];
                
        StringFromGUID2(CLSID_WbemLevel1Login,ClsidBuff,40);        
#ifdef UNICODE
        ClsidBuff2 = ClsidBuff;
#else
        TCHAR pTmp_[40];
        ClsidBuff2 = pTmp_;
        WideCharToMultiByte(CP_ACP,0,ClsidBuff,-1,ClsidBuff2,40,NULL,NULL);
#endif
        
        StringCchPrintf(ClsidPath,MAX_PATH,TEXT("software\\classes\\CLSID\\%s"),ClsidBuff2);       
        
        lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              ClsidPath,
                              0,NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey4,
                              &dwDisposistion);
        if (ERROR_SUCCESS == lRet)
        {
            RegSetValueEx(hKey4,NULL,0,REG_SZ,(BYTE *)DISPLAY_CLSID,sizeof(DISPLAY_CLSID)-sizeof(TCHAR));
            RegSetValueEx(hKey4,TEXT("AppId"),0,REG_SZ,(BYTE *)SERVICE_CLSID,sizeof(SERVICE_CLSID)-sizeof(TCHAR));
            RegSetValueEx(hKey4,TEXT("LocalService"),0,REG_SZ,(BYTE *)SERVICE_NAME,sizeof(SERVICE_NAME)-sizeof(TCHAR));
            RegCloseKey(hKey4);
        }

        StringFromGUID2(CLSID_WbemBackupRestore,ClsidBuff,40);
#ifdef UNICODE
        ClsidBuff2 = ClsidBuff;
#else
        WideCharToMultiByte(CP_ACP,0,ClsidBuff,-1,ClsidBuff2,40,NULL,NULL);
#endif

        StringCchPrintf(ClsidPath,MAX_PATH,TEXT("software\\classes\\CLSID\\%s"),ClsidBuff);
        
        lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              ClsidPath,
                              0,NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey4,
                              &dwDisposistion);
        if (ERROR_SUCCESS == lRet)
        {
            RegSetValueEx(hKey4,NULL,0,REG_SZ,(BYTE *)DISPLAY_BACKUP_CLSID,sizeof(DISPLAY_BACKUP_CLSID)-sizeof(TCHAR));
            RegSetValueEx(hKey4,TEXT("AppId"),0,REG_SZ,(BYTE *)SERVICE_CLSID,sizeof(SERVICE_CLSID)-sizeof(TCHAR));
            RegSetValueEx(hKey4,TEXT("LocalService"),0,REG_SZ,(BYTE *)SERVICE_NAME,sizeof(SERVICE_NAME)-sizeof(TCHAR));
            RegCloseKey(hKey4);
        }        

    }

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the COM server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    LONG lRet;
    
    TCHAR ClsidBuff[40];
    TCHAR ClsidPath[MAX_PATH];

#ifdef UNICODE                
    StringFromCLSID(CLSID_WbemLevel1Login,(LPOLESTR *)ClsidBuff);
#else
    WCHAR ClsidPath2[40];
    StringFromCLSID(CLSID_WbemLevel1Login,(LPOLESTR *)ClsidBuff2);
    MultiByteToWideChar(CP_ACP,0,ClsidBuff2,-1,ClsidBuff,40);
#endif

    StringCchPrintf(ClsidPath,MAX_PATH,TEXT("software\\classes\\CLSID\\%s"),ClsidBuff);
    
    lRet = RegDeleteKey(HKEY_LOCAL_MACHINE,ClsidPath);
    if (ERROR_SUCCESS != lRet) return E_FAIL;

#ifdef UNICODE
    StringFromCLSID(CLSID_WbemBackupRestore,(LPOLESTR *)ClsidBuff);
#else
    WCHAR ClsidPath2[40];
    StringFromCLSID(CLSID_WbemBackupRestore,(LPOLESTR *)ClsidBuff2);
    MultiByteToWideChar(CP_ACP,0,ClsidBuff2,-1,ClsidBuff,40);
#endif

    StringCchPrintf(ClsidPath,MAX_PATH,TEXT("software\\classes\\CLSID\\%s"),ClsidBuff);
    
    lRet = RegDeleteKey(HKEY_LOCAL_MACHINE,ClsidPath);
    if (ERROR_SUCCESS != lRet) return E_FAIL;    

    lRet = RegDeleteKey(HKEY_LOCAL_MACHINE,COM_APPID);
    if (ERROR_SUCCESS != lRet) return E_FAIL;    
    
    lRet = RegDeleteKey(HKEY_LOCAL_MACHINE,COM_APPID_NAME);
    if (ERROR_SUCCESS != lRet) return E_FAIL;    
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\resync2.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC2.CPP

Abstract:

    implements the listener for WDM events and events for sync-up with IdleTask

History:

    ivanbrug 01-Oct-2000  changed for svchost migration

--*/

#include "precomp.h"
#include <winntsec.h>
#include <malloc.h>
#include <initguid.h>
#include "WinMgmt.h"
#include <Wmistr.h>

#include <wmium.h>
#include <wmicom.h>
#include <wmimof.h>

#include "resync2.h"
#include "wbemdelta.h" // for DeltaDredge
#include "arrtempl.h"

//
//
//   this is because WDMLib is __BADLY__ DESIGNED
//
/////////////////////////////////////////////////////////////

void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
    return;
}

//
//
//  This class listens on WDM events
//
/////////////////////////////////////////////////////////////

CWDMListener::CWDMListener():
                  m_dwSignature(SIG_WDMEVENTS_FREE),
                  m_hEventAdd(NULL),
                  m_hEventRem(NULL),
                  m_hWaitAdd(NULL),
                  m_hWaitRem(NULL),
                  m_UnInited(TRUE),
                  m_GuidAdd(GUID_MOF_RESOURCE_ADDED_NOTIFICATION),
                  m_GuidRem(GUID_MOF_RESOURCE_REMOVED_NOTIFICATION)
                  
{
 
}

DWORD 
CWDMListener::OpenAdd()
{
    DWORD dwErr;
    dwErr = WmiOpenBlock(&m_GuidAdd,
                         WMIGUID_NOTIFICATION | SYNCHRONIZE,
                         &m_hEventAdd);
    if (ERROR_SUCCESS == dwErr)
    {

        if (RegisterWaitForSingleObject(&m_hWaitAdd,
                                        m_hEventAdd,
                                        CWDMListener::EvtCallBackAdd,
                                        this,
                                        INFINITE,
                                        WT_EXECUTEONLYONCE))
        {
            return ERROR_SUCCESS;
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else
    {
        dwErr = GetLastError();
    }

    // if here, some errors
    CloseAdd();
    return dwErr;
}

DWORD 
CWDMListener::OpenRemove()
{
    DWORD dwRet;

    dwRet = WmiOpenBlock(&m_GuidRem,
                         WMIGUID_NOTIFICATION | SYNCHRONIZE,
                         &m_hEventRem);
    if (ERROR_SUCCESS == dwRet)
    {
        if (RegisterWaitForSingleObject(&m_hWaitRem,
                                        m_hEventRem,
                                        CWDMListener::EvtCallBackRem,
                                        this,
                                        INFINITE,
                                        WT_EXECUTEONLYONCE))
        {
            return ERROR_SUCCESS;                    
        }
        else
        {
            dwRet = GetLastError();
        }        
    }
    else
    {
        dwRet = GetLastError();
    }

    CloseRemove();
    return dwRet;

}

DWORD
CWDMListener::CloseAdd()
{
    if (m_hWaitAdd)
    {
        UnregisterWaitEx(m_hWaitAdd,NULL);
        m_hWaitAdd = NULL;
    }
    if (m_hEventAdd)
    {
        WmiCloseBlock(m_hEventAdd);
        m_hEventAdd = NULL;
    }
    return 0;
}

DWORD
CWDMListener::CloseRemove()
{
    if (m_hWaitRem)
    {
        UnregisterWaitEx(m_hWaitRem,NULL);
        m_hWaitRem = NULL;
    }
    if (m_hEventRem)
    {
        WmiCloseBlock(m_hEventRem);
        m_hEventRem = NULL;
    }
    return 0;    
}


VOID
CWDMListener::Unregister()
{
    CInCritSec ics(&m_cs);
    if (m_UnInited) return;

    CloseAdd();
    CloseRemove();    
    
    m_dwSignature = SIG_WDMEVENTS_FREE;    
    m_UnInited = TRUE;    
}

CWDMListener::~CWDMListener()
{
    Unregister(); 
}

DWORD 
CWDMListener::Register()
{
    CInCritSec ics(&m_cs);

    if (!m_UnInited) // prevent multiple calls
        return 0;
    
    if (ERROR_SUCCESS == OpenAdd() && ERROR_SUCCESS == OpenRemove())
    {
        m_dwSignature = SIG_WDMEVENTS_BUSY;        
        m_UnInited = FALSE;
    }

    return GetLastError();
}

VOID NTAPI 
CWDMListener::EvtCallBackAdd(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred()) return;  
    CWDMListener * pThis = (CWDMListener *)pContext;
    if (NULL == pThis) return;
    if (SIG_WDMEVENTS_BUSY != pThis->m_dwSignature) return;

    pThis->EvtCallThis(bTimerFired,Type_Added);

    //
    // we have process the WDM event
    // since we are in the RtlpWorkerThread and 
    // we are registred with WT_EXECUTEONLYONCE
    // REDO FROM START
    //
    {
        CInCritSec ics(&pThis->m_cs);
        if (ERROR_SUCCESS == pThis->CloseAdd())
        {
            pThis->OpenAdd();
        }        
    }
}

VOID NTAPI 
CWDMListener::EvtCallBackRem(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred()) return;
    CWDMListener * pThis = (CWDMListener *)pContext;
    if (NULL == pThis) return;
    if (SIG_WDMEVENTS_BUSY != pThis->m_dwSignature) return;
    
    pThis->EvtCallThis(bTimerFired,Type_Removed);
        
    //
    // we have process the WDM event
    // since we are in the RtlpWorkerThread and 
    // we are registred with WT_EXECUTEONLYONCE
    // REDO FROM START
    //        
    {
        CInCritSec ics(&pThis->m_cs);
        if (ERROR_SUCCESS == pThis->CloseRemove())
        {
            pThis->OpenRemove();
        }        
    }        
}


VOID
CWDMListener::EvtCallThis(BOOLEAN bTimerFired, int Type)
{
    if (bTimerFired)
    {
        _DBG_ASSERT(FALSE);
    }
    else
    {
        if (m_UnInited)
            return;
        
        DWORD dwRet;
        if (Type_Added == Type)
        {
            dwRet = WmiReceiveNotifications(1,&m_hEventAdd,CWDMListener::WmiCallBack,(ULONG_PTR)this);
        }
        else if (Type_Removed == Type)
        {
            dwRet = WmiReceiveNotifications(1,&m_hEventRem,CWDMListener::WmiCallBack,(ULONG_PTR)this);
        }
    }
}

VOID WINAPI 
CWDMListener::WmiCallBack(PWNODE_HEADER Wnode, 
                          UINT_PTR NotificationContext)
{
    // pThis is checked in the EventCallBack 
    CWDMListener * pThis = (CWDMListener *)NotificationContext;
    
#ifdef DEBUG_ADAP

    WCHAR pszClsID[40];
    StringFromGUID2(Wnode->Guid,pszClsID,40);
    DBG_PRINTFA((pBuff,"Flag %08x ProvId %08x %p GUID %S\n",
    Wnode->Flags,Wnode->ProviderId,(ULONG_PTR)Wnode->ClientContext,pszClsID));
    if (WNODE_FLAG_ALL_DATA & Wnode->Flags)
    {
        WNODE_ALL_DATA * pAllData = (WNODE_ALL_DATA *)Wnode;
        DWORD i;
        for (i=0;i<pAllData->InstanceCount;i++)
        {
            WCHAR pTmpBuff[MAX_PATH+1];
            pTmpBuff[MAX_PATH] = 0;
            DWORD dwSize = (pAllData->OffsetInstanceDataAndLength[i].LengthInstanceData>MAX_PATH)?MAX_PATH:pAllData->OffsetInstanceDataAndLength[i].LengthInstanceData;
            memcpy(pTmpBuff,(BYTE*)pAllData+pAllData->OffsetInstanceDataAndLength[i].OffsetInstanceData,dwSize);
            DBG_PRINTFA((pBuff,"%d - %S\n",i,pTmpBuff));
        }
    };

#endif

#ifdef DBG
    if (!HeapValidate(GetProcessHeap(),0,NULL))
    {
        DebugBreak();
    }
    if (!HeapValidate(CWin32DefaultArena::GetArenaHeap(),0,NULL))
    {
        DebugBreak();
    }    
#endif
    
    CWMIBinMof  WMIBinMof;
    //=============================================================================
    // Note: this combo will always succeed, as all the initialize is doing is 
    // setting a flag to FALSE and returning S_OK
    //=============================================================================
    if( SUCCEEDED( WMIBinMof.Initialize(NULL,FALSE)) )
    {
           if (WMIBinMof.BinaryMofEventChanged(Wnode))
        {     
#ifdef DEBUG_ADAP        
            DBG_PRINTFA((pBuff,"---- WMIBinMof.BinaryMofEventChanged == CHANGED ----\n"));
#endif
            DEBUGTRACE((LOG_WINMGMT,"WDM event && WMIBinMof.BinaryMofEventChanged == TRUE\n"));

            ResyncPerf(RESYNC_TYPE_WDMEVENT);
#ifdef DBG
            if (!HeapValidate(GetProcessHeap(),0,NULL))
            {
                DebugBreak();
            }
            if (!HeapValidate(CWin32DefaultArena::GetArenaHeap(),0,NULL))
            {
                DebugBreak();
            }            
#endif
        }
        else
        {
#ifdef DEBUG_ADAP        
             DBG_PRINTFA((pBuff,"---- WMIBinMof.BinaryMofEventChanged == NOT CHANGED ----\n"));
#endif
        }
    }
    return;
}



CCounterEvts::CCounterEvts():
                 m_dwSignature(SIG_COUNTEEVENTS_BUSY),
                 m_LoadCtrEvent(NULL),
                 m_UnloadCtrEvent(NULL),
                 m_Uninited(TRUE),
                 m_WaitLoadCtr(NULL),
                 m_WaitUnloadCtr(NULL),
                 m_hWmiReverseAdapSetLodCtr(NULL),
                 m_hWmiReverseAdapLodCtrDone(NULL),
                 m_hPendingTasksStart(NULL),
                 m_hPendingTasksComplete(NULL)
{    
}

//
// allows localsystem to use the event
//
//
// SDDL: L"O:SYG:SYD:(A;;0x1f0003;;;SY)"
//
DWORD g_LocalSystemSD[] = {
0x80040001, 0x00000014, 0x00000020, 0x00000000,
0x0000002c, 0x00000101, 0x05000000, 0x00000012,
0x00000101, 0x05000000, 0x00000012, 0x00300002, 
0x00000001, 0x00140000, 0x001f0003, 0x00000101, 
0x05000000, 0x00000012, 0x00000000, 0x00000000
};

//
// allow administrators and localsystem to use the event
//
//
// SDDL: L"O:SYG:SYD:(A;;0x1f0003;;;SY)(A;;0x1f0003;;;BA)"
//
DWORD g_LocalSystemAdminsSD[] = {
0x80040001, 0x00000014, 0x00000020, 0x00000000,
0x0000002c, 0x00000101, 0x05000000, 0x00000012,
0x00000101, 0x05000000, 0x00000012, 0x00340002, 
0x00000002, 0x00140000, 0x001f0003, 0x00000101, 
0x05000000, 0x00000012, 0x00180000, 0x001f0003, 
0x00000201, 0x05000000, 0x00000020, 0x00000220 
};

DWORD
CCounterEvts::Init()
{
    if (!m_Uninited)
       return 0;

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);    
    sa.lpSecurityDescriptor = (LPVOID)g_LocalSystemAdminsSD;
    sa.bInheritHandle = FALSE;
    
    m_LoadCtrEvent = CreateEvent(&sa, FALSE, FALSE,LOAD_CTR_EVENT_NAME);
    if (NULL == m_LoadCtrEvent)
        goto end_fail;

    m_UnloadCtrEvent = CreateEvent(&sa, FALSE, FALSE, UNLOAD_CTR_EVENT_NAME);    
    if (NULL == m_UnloadCtrEvent)
        goto end_fail;    

    m_hWmiReverseAdapSetLodCtr = CreateEvent(&sa,FALSE,FALSE,REVERSE_DREDGE_EVENT_NAME_SET);    
    if (NULL == m_hWmiReverseAdapSetLodCtr)
        goto end_fail;    

    m_hWmiReverseAdapLodCtrDone = CreateEvent(&sa,FALSE,FALSE,REVERSE_DREDGE_EVENT_NAME_ACK);
    if (NULL == m_hWmiReverseAdapLodCtrDone)
        goto end_fail;    

    sa.lpSecurityDescriptor = (LPVOID)g_LocalSystemSD;

    m_hPendingTasksStart = CreateEvent(&sa,FALSE,FALSE,PENDING_TASK_START);
    if (!m_hPendingTasksStart)
           goto end_fail;

    m_hPendingTasksComplete = CreateEvent(&sa,TRUE,TRUE,PENDING_TASK_COMPLETE);
    if (!m_hPendingTasksComplete)
        goto end_fail;

    m_Uninited = FALSE;
    return NO_ERROR;    
    
end_fail:
    return GetLastError();        
}

VOID NTAPI 
CCounterEvts::EvtCallBackLoad(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred()) return;
    CCounterEvts * pCounter = (CCounterEvts *)pContext;
    if (NULL == pCounter) return;
    if (SIG_COUNTEEVENTS_BUSY != pCounter->m_dwSignature) return;
    
    pCounter->CallBack(bTimerFired,Type_Load);
}

VOID NTAPI 
CCounterEvts::EvtCallBackUnload(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred()) return;
    CCounterEvts * pCounter = (CCounterEvts *)pContext;
    if (NULL == pCounter) return;
    if (SIG_COUNTEEVENTS_BUSY != pCounter->m_dwSignature) return;
            
    pCounter->CallBack(bTimerFired,Type_Unload);
}

VOID NTAPI 
CCounterEvts::EvtCallBackPendingTask(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred()) return;
    CCounterEvts * pCounter = (CCounterEvts *)pContext;
    if (NULL == pCounter) return;
    if (SIG_COUNTEEVENTS_BUSY != pCounter->m_dwSignature) return;
            
    pCounter->CallBackPending(bTimerFired);
}

VOID 
CCounterEvts::CallBack(BOOLEAN bTimerFired,int Type)
{
#ifdef DEBUG_ADAP
    DBG_PRINTFA((pBuff,"CallBack with type %d called\n",Type));
#endif    
    
    if (GLOB_IsResyncAllowed())
    {
        DWORD dwRet = WaitForSingleObject(m_hWmiReverseAdapSetLodCtr,0);
        if (WAIT_OBJECT_0 == dwRet)
        {
            // this is the hack not to spawn a Delta Dredge when there is before a Reverese Dredge
#ifdef DEBUG_ADAP            
            DBG_PRINTFA((pBuff," - SetEvent(m_hWmiReverseAdapLodCtrDone);\n"));
#endif
            SetEvent(m_hWmiReverseAdapLodCtrDone);
        }
        else
        {
#ifdef DEBUG_ADAP        
            DBG_PRINTFA((pBuff," - ResyncPerf(RESYNC_TYPE_LODCTR);\n"));
#endif
            ResyncPerf(RESYNC_TYPE_LODCTR);
        }
    }
}

VOID 
CCounterEvts::CallBackPending(BOOLEAN bTimerFired)
{
    if (GLOB_IsResyncAllowed())
    {
#ifdef DEBUG_ADAP    
        DBG_PRINTFA((pBuff," - PendingTask Start set\n"));
#endif
        ResyncPerf(RESYNC_TYPE_PENDING_TASKS);
    }
}

VOID RevertRegister_(HANDLE & hWaitHandle)
{
    UnregisterWaitEx(hWaitHandle,NULL);
    hWaitHandle = NULL;
}

DWORD 
CCounterEvts::Register()
{


    // automatic reset    
    if (!RegisterWaitForSingleObject(&m_WaitLoadCtr,
                                    m_LoadCtrEvent,
                                    CCounterEvts::EvtCallBackLoad,
                                    this,
                                    INFINITE,
                                    WT_EXECUTEDEFAULT)) return GetLastError();
    OnDeleteIf<HANDLE &,VOID(*)(HANDLE &),RevertRegister_> UnReg1(m_WaitLoadCtr);
    
    // automatic reset
    if(!RegisterWaitForSingleObject(&m_WaitUnloadCtr,
                                       m_UnloadCtrEvent,
                                       CCounterEvts::EvtCallBackUnload,
                                       this,
                                       INFINITE,
                                       WT_EXECUTEDEFAULT)) return GetLastError();
    OnDeleteIf<HANDLE &,VOID(*)(HANDLE &),RevertRegister_> UnReg2(m_WaitUnloadCtr);

    if (!RegisterWaitForSingleObject(&m_hWaitPendingTasksStart,
                              m_hPendingTasksStart,
                              CCounterEvts::EvtCallBackPendingTask,
                              this,
                              INFINITE,
                              WT_EXECUTEDEFAULT)) return GetLastError();
    OnDeleteIf<HANDLE &,VOID(*)(HANDLE &),RevertRegister_> UnReg3(m_hWaitPendingTasksStart);

    // here everything is OK
    UnReg1.dismiss();
    UnReg2.dismiss();
    UnReg3.dismiss();    
    
    m_dwSignature = SIG_COUNTEEVENTS_BUSY;    
    return ERROR_SUCCESS;    
}

DWORD 
CCounterEvts::Unregister()
{
    if (m_WaitLoadCtr)
    {
        UnregisterWaitEx(m_WaitLoadCtr,NULL);
        m_WaitLoadCtr = NULL;
    }
    if (m_WaitUnloadCtr)
    {
        UnregisterWaitEx(m_WaitUnloadCtr,NULL);
        m_WaitUnloadCtr = NULL;
    }
    if (m_hWaitPendingTasksStart)
    {
        UnregisterWaitEx(m_hWaitPendingTasksStart,NULL);
        m_hWaitPendingTasksStart = NULL;
    }
    m_dwSignature = SIG_COUNTEEVENTS_FREE;    
    return 0;
}

VOID
CCounterEvts::UnInit()
{
    if (!m_Uninited)
        return;
        
    if(m_LoadCtrEvent) {
        CloseHandle(m_LoadCtrEvent);
        m_LoadCtrEvent = NULL;
    }
    if(m_UnloadCtrEvent)
    {
        CloseHandle(m_UnloadCtrEvent);
        m_UnloadCtrEvent = NULL;
    }
    if (m_hWmiReverseAdapSetLodCtr)
    {
        CloseHandle(m_hWmiReverseAdapSetLodCtr);
        m_hWmiReverseAdapSetLodCtr = NULL;
    }
    if (m_hWmiReverseAdapLodCtrDone)
    {
        CloseHandle(m_hWmiReverseAdapLodCtrDone);
        m_hWmiReverseAdapLodCtrDone = NULL;
    }
    if (m_hPendingTasksStart)
    {
        CloseHandle(m_hPendingTasksStart);
        m_hPendingTasksStart = NULL;
    }
    if (m_hPendingTasksComplete)
    {
        CloseHandle(m_hPendingTasksComplete);
        m_hPendingTasksComplete = NULL;
    }                                   
    m_Uninited = TRUE;
}

CCounterEvts::~CCounterEvts()
{
    if (!m_Uninited)
        UnInit();
        
    m_dwSignature = SIG_COUNTEEVENTS_FREE;        
}

//
//  this is the main abstraction
//  the child classes will call the ResyncPerf function,
//  as long as the CWbemServices write hook.
//  The ResyncPerf function will grab the global monitor
//  and register a Timer Callback
//  the gate will be implemented in the GetAvailable function
//
//
/////////////////////////////////////////////////////////////////////

CMonitorEvents::CMonitorEvents():
    m_bInit(FALSE),
    m_bRegistred(FALSE)
{  
};

CMonitorEvents::~CMonitorEvents()
{    
}

//
// We install a console control handler because we want to unregister
// the WDM event monitor before the GIUD_REMOVE events gets in
// the console applications get notified of shutdown before services and drivers
//
////////////////////////////////////////////////////////
BOOL WINAPI
CMonitorEvents::MonitorCtrlHandler( DWORD dwCtrlType )
{
    BOOL bRet = FALSE;
    switch(dwCtrlType)
    {
    case CTRL_SHUTDOWN_EVENT:        
    
        GLOB_GetMonitor()->m_WDMListener.Unregister();
#ifdef DEBUG_ADAP        
        DBG_PRINTFA((pBuff,"WDM Handles closed\n"));
#endif
        bRet = TRUE;
        break;
    default:
        bRet = FALSE;
    };
    return bRet;    
};


BOOL 
CMonitorEvents::Init()
{
    if (m_bInit) return TRUE;

    CInCritSec ics(&m_cs);
    if (m_bInit) return TRUE;

    m_dwSig =  'VEOM';
    m_CntsEvts.Init();
    m_dwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
    m_dwLodCtrDelaySec = WMIADAP_DEFAULT_DELAY_LODCTR;
    m_dwTimeToFull = WMIADAP_DEFAULT_TIMETOFULL;
    m_dwTimeToKillAdap = MAX_PROCESS_WAIT;

    memset(&m_FileTime,0,sizeof(m_FileTime));
    
    RegRead();
    
    for (DWORD i=0;i<RESYNC_TYPE_MAX;i++)
    {
        m_ResyncTasks[i].dwSig       = SIG_RESYNC_PERF;
        m_ResyncTasks[i].bFree       = TRUE;
        m_ResyncTasks[i].pMonitor    = this;
        m_ResyncTasks[i].hTimer      = NULL;
        m_ResyncTasks[i].hWaitHandle = NULL;
        m_ResyncTasks[i].hProcess    = NULL;
        m_ResyncTasks[i].Enabled = TRUE;
    }

    //m_ResyncTasks[RESYNC_TYPE_LODCTR].CmdType // to be decided by DeltaDredge
    m_ResyncTasks[RESYNC_TYPE_INITIAL].dwTimeDue = (m_dwADAPDelaySec)*1000;
    
    m_ResyncTasks[RESYNC_TYPE_LODCTR].CmdType = RESYNC_DELTA_THROTTLE;
    m_ResyncTasks[RESYNC_TYPE_LODCTR].dwTimeDue = (m_dwLodCtrDelaySec)*1000;

    // //RESYNC_TYPE_CLASSCREATION is the same
    m_ResyncTasks[RESYNC_TYPE_WDMEVENT].CmdType = RESYNC_RADAPD_THROTTLE;
    m_ResyncTasks[RESYNC_TYPE_WDMEVENT].dwTimeDue = (m_dwLodCtrDelaySec)*1000;

    m_ResyncTasks[RESYNC_TYPE_PENDING_TASKS].CmdType =   RESYNC_FULL_RADAPD_NOTHROTTLE;
    m_ResyncTasks[RESYNC_TYPE_PENDING_TASKS].dwTimeDue = 500; // hard coded

    //
    // set up the console handler
    //
    SetConsoleCtrlHandler( MonitorCtrlHandler, TRUE );

    //
    // let's asses some initial state for the IdleTask business
    //
    m_OutStandingProcesses = 0;
    m_bFullReverseNeeded = FALSE;

    m_bInit = TRUE;

    return TRUE;
};


BOOL 
CMonitorEvents::Uninit()
{
    if (!m_bInit) return TRUE;
    CInCritSec ics(&m_cs);
    if (!m_bInit) return TRUE;

    for (DWORD i=0;i<RESYNC_TYPE_MAX;i++)
    {
        if (m_ResyncTasks[i].hTimer)
        {
            DeleteTimerQueueTimer(NULL,m_ResyncTasks[i].hTimer,NULL);
            m_ResyncTasks[i].hTimer = NULL;
        }
        if (m_ResyncTasks[i].hWaitHandle)
        {
            UnregisterWaitEx(m_ResyncTasks[i].hWaitHandle,NULL);
            m_ResyncTasks[i].hWaitHandle = NULL;        
        }
        if (m_ResyncTasks[i].hProcess)
        {
            CloseHandle(m_ResyncTasks[i].hProcess);
            m_ResyncTasks[i].hProcess = NULL;
        }
        m_ResyncTasks[i].dwSig = (DWORD)'eerf';
    }

    m_CntsEvts.UnInit();

    //
    // tear-down the console handler
    //
    SetConsoleCtrlHandler( MonitorCtrlHandler, FALSE );

    m_bInit = FALSE;
    m_dwSig = 'veom';

    return TRUE;
};


//
//
// called in the running/continue
//
/////////////

DWORD 
CMonitorEvents::Register()
{
    m_CntsEvts.Register();
    m_WDMListener.Register();    

    m_bRegistred = TRUE;
    
    return 0;
};   

//
//
// called in the pause/stop
//
//////////////////////////////////////////////////////////

DWORD 
CMonitorEvents::Unregister(BOOL bIsSystemShutDown)
{

    m_bRegistred = FALSE;

    if (!bIsSystemShutDown)
    {
        m_CntsEvts.Unregister();
        m_WDMListener.Unregister();
    }
    return 0;
};

//
//
//
/////////////////////////////////////////////////////////

VOID
CMonitorEvents::RegRead()
{
    // Read the initialization information

    LONG lRet;
    HKEY hKey;
    DWORD dwTemp;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("Software\\Microsoft\\WBEM\\CIMOM"),
                        NULL,
                        KEY_READ|KEY_WRITE,
                        &hKey);
    
    
    if (ERROR_SUCCESS == lRet)
    {
        OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm(hKey);           
                
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        lRet = RegQueryValueEx(hKey,
                               TEXT("ADAPDelay"),
                               NULL,
                               &dwType,
                               (BYTE *)&m_dwADAPDelaySec,
                               &dwSize);

        if (ERROR_SUCCESS == lRet && REG_DWORD == dwType)
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == lRet )
        {
            dwTemp = WMIADAP_DEFAULT_DELAY;
            RegSetValueEx(hKey,
                          TEXT("ADAPDelay"),
                          NULL,
                          REG_DWORD,
                          (BYTE *)&dwTemp,
                          sizeof(DWORD));
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
        }

        dwSize = sizeof(DWORD);
        lRet = RegQueryValueEx(hKey,
                               TEXT("LodCtrDelay"),
                               NULL,
                               &dwType,
                               (BYTE *)&m_dwLodCtrDelaySec,
                               &dwSize);

        if (ERROR_SUCCESS == lRet && REG_DWORD == dwType)
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == lRet )
        {
            dwTemp = WMIADAP_DEFAULT_DELAY_LODCTR;
            RegSetValueEx(hKey,
                          TEXT("LodCtrDelay"),
                          NULL,
                          REG_DWORD,
                          (BYTE *)&dwTemp,
                          sizeof(DWORD));
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
        }         

        dwSize = sizeof(DWORD);
        lRet = RegQueryValueEx(hKey,
                               ADAP_TIME_TO_FULL,
                               NULL,
                               &dwType,
                               (BYTE *)&m_dwTimeToFull,
                               &dwSize);

        if (ERROR_SUCCESS == lRet && REG_DWORD == dwType)
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == lRet )
        {
            dwTemp = WMIADAP_DEFAULT_TIMETOFULL;
            RegSetValueEx(hKey,
                          ADAP_TIME_TO_FULL,
                          NULL,
                          REG_DWORD,
                          (BYTE *)&dwTemp,
                          sizeof(DWORD));
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
        }

        dwSize = sizeof(DWORD);
        lRet = RegQueryValueEx(hKey,
                               ADAP_TIME_TO_KILL_ADAP,
                               NULL,
                               &dwType,
                               (BYTE *)&m_dwTimeToKillAdap,
                               &dwSize);

        if (ERROR_SUCCESS == lRet && REG_DWORD == dwType)
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == lRet )
        {
            dwTemp = MAX_PROCESS_WAIT;
            RegSetValueEx(hKey,
                          ADAP_TIME_TO_KILL_ADAP,
                          NULL,
                          REG_DWORD,
                          (BYTE *)&dwTemp,
                          sizeof(DWORD));
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the %S value in the CIMOM subkey.  Continuing using a default value.\n",ADAP_TIME_TO_KILL_ADAP));
        }

        //ADAP_TIMESTAMP_FULL
        dwSize = sizeof(FILETIME);
        lRet = RegQueryValueEx(hKey,
                               ADAP_TIMESTAMP_FULL,
                               NULL,
                               &dwType,
                               (BYTE *)&m_FileTime,
                               &dwSize);

    }
    else
    {
        // Error
        ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf could not open the CIMOM subkey to read initialization data. Continuing using a default value.\n" ) );

    }

}

//
//
//
////////////////////////////////////////////////////////

ResyncPerfTask *
CMonitorEvents::GetAvailable(DWORD dwReason)
{
    ResyncPerfTask * pPerf = NULL;
    
    CInCritSec ics(&m_cs);

    if (m_ResyncTasks[dwReason].bFree)
    {
        m_ResyncTasks[dwReason].bFree = FALSE;
        m_ResyncTasks[dwReason].Type = dwReason;
        pPerf = &m_ResyncTasks[dwReason];
    }
    
    return pPerf;
}

TCHAR * g_Strings[] = {
    TEXT("/F /T"),     // FULL            Throttle
    TEXT("/D /T"),     // DELTA           Throttle    
    TEXT("/R /T"),     // REVERSE_ADAPTER Throttle        
    TEXT("/F /R /T"),  // FULL REVERSE_ADAPTER Throttle
    TEXT("/D /R /T"),  // DELTA REVERSE_ADAPTER Throttle
    TEXT("/F /R")      // FULL REVERSE no Throttle
};

void inline DoUnThrottleDredges()
{
#ifdef DEBUG_ADAP
    DBG_PRINTFA((pBuff,"DoUnThrottleDredges\n"));
#endif
    RegSetDWORD(HKEY_LOCAL_MACHINE,HOME_REG_PATH,DO_THROTTLE,0);
    return;
}

void inline DoThrottleDredges()
{
#ifdef DEBUG_ADAP
    DBG_PRINTFA((pBuff,"DoThrottleDredges\n"));
#endif
    RegSetDWORD(HKEY_LOCAL_MACHINE,HOME_REG_PATH,DO_THROTTLE,1);    
    return;
}

BOOL 
CMonitorEvents::CreateProcess_(TCHAR * pCmdLine,
                            CMonitorEvents * pMonitor,
                            ResyncPerfTask * pPerf)
{
            BOOL bRes = FALSE;
            STARTUPINFO si;
            PROCESS_INFORMATION ProcInfo;
            memset(&si,0,sizeof(STARTUPINFO));
            si.cb = sizeof(STARTUPINFO);
            si.dwFlags = STARTF_FORCEOFFFEEDBACK;

            // Get the appropriate cmdline and attach the proper command line switches
            LPTSTR    pWriteableBuff = GetWMIADAPCmdLine( 64 );
            CVectorDeleteMe<TCHAR>    vdm( pWriteableBuff );

            if ( NULL == pWriteableBuff )
            {
                ERRORTRACE((LOG_WINMGMT,"Memory Allocation error spawning dredger!\n"));
                pMonitor->Lock();
                pPerf->bFree = TRUE;
                pMonitor->Unlock();                
                return bRes;
            }


#ifdef DEBUG_ADAP
                  DBG_PRINTFA((pBuff,"Creating process: %S\n",pCmdLine));
#endif 
                  DEBUGTRACE((LOG_WINMGMT,"Creating process: %S\n",pCmdLine));

            bRes = CreateProcess(pWriteableBuff,
                                 pCmdLine,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 CREATE_NO_WINDOW,
                                 NULL,
                                 NULL,
                                 &si,
                                 &ProcInfo);
            if (bRes)
            {
                CloseHandle(ProcInfo.hThread);

                pPerf->hProcess = ProcInfo.hProcess;

                if (RegisterWaitForSingleObject(&pPerf->hWaitHandle,
                                                pPerf->hProcess,
                                                CMonitorEvents::EventCallBack,
                                                pPerf,
                                                pMonitor->m_dwTimeToKillAdap,
                                                WT_EXECUTEONLYONCE|WT_EXECUTEINWAITTHREAD))
                {
                    //
                    // we don't need to free the slot, 
                    // because the event callback will do that
                    //
                } 
                else
                {
                    DEBUGTRACE((LOG_WINMGMT,"Unable to schedule WmiADAP process termination handler: err %d\n",GetLastError()));
                    CloseHandle(pPerf->hProcess);
                    pPerf->hProcess = NULL;
                    pMonitor->Lock();
                    pPerf->bFree = TRUE;
                    pMonitor->Unlock();                    
                }
            }
            else
            {
                ERRORTRACE((LOG_WINMGMT,"CreatProcess %S err: %d\n",pWriteableBuff,GetLastError()));
                pMonitor->Lock();
                pPerf->bFree = TRUE;
                pMonitor->Unlock();                
            }
    return bRes;            
}

VOID NTAPI 
CMonitorEvents::EventCallBack(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred()) return;
    ResyncPerfTask * pPerf = (ResyncPerfTask *)pContext;

    if (!pPerf || (SIG_RESYNC_PERF  != pPerf->dwSig)) return;
 
    
    CMonitorEvents * pMonitor = pPerf->pMonitor;
    HANDLE hProcess = pPerf->hProcess;
    
    if(bTimerFired)
    {
        //
        //    The LONG time-out for our process has expired
        //    Kill The Process
        //
        TerminateProcess(pPerf->hProcess,0);
#ifdef DEBUG_ADAP        
        DBG_PRINTFA((pBuff,"WmiADAP did not finish within %d msec\n",pMonitor->m_dwTimeToKillAdap));
#endif
        ERRORTRACE((LOG_WINMGMT,"the ResyncTask of type %d timed-out and has been killed\n",pPerf->Type));
    }
    else
    {
        //
        // the handle has been signaled, meaning that
        // the process exited normally
        // 
#ifdef DEBUG_ADAP        
        DBG_PRINTFA((pBuff,"ResyncPerf for task %d completed\n",pPerf->Type));
#endif
    }

    CloseHandle(pPerf->hProcess);
    //
    // if there was a call to ProcessIdleTasks
    // if we were forced to unthrottle the running tasks
    // revert back
    //
    if (RESYNC_TYPE_PENDING_TASKS == pPerf->Type)
    {
        pMonitor->m_bFullReverseNeeded = FALSE;
        DoThrottleDredges();
#ifdef DEBUG_ADAP        
        DBG_PRINTFA((pBuff,"Setting the WMI_ProcessIdleTasksComplete\n"));        
#endif
        if (GLOB_GetMonitor()->IsRegistred())        
            SetEvent(GLOB_GetMonitor()->GetTaskCompleteEvent());
    } 
    else // a process has exited or it has been terminated
    {
        LONG nProc = InterlockedDecrement(&pMonitor->m_OutStandingProcesses);
#ifdef DEBUG_ADAP        
        DBG_PRINTFA((pBuff,"(-) Outstanding Tasks %d\n",pMonitor->m_OutStandingProcesses));
#endif
        if (0 == nProc &&
          pMonitor->m_bFullReverseNeeded)
        {
            // Create Here the process
            CMonitorEvents * pMonitor = GLOB_GetMonitor();
            ResyncPerfTask * pPerfTask = pMonitor->GetAvailable(RESYNC_TYPE_PENDING_TASKS);
            if (pPerfTask)
            {
                TCHAR pCmdLine[64];
                StringCchCopy(pCmdLine,64,TEXT("wmiadap.exe "));
                StringCchCat(pCmdLine,64,g_Strings[pPerfTask->CmdType]);
                CMonitorEvents::CreateProcess_(pCmdLine,pMonitor,pPerfTask);
            }
            else
            {
#ifdef DEBUG_ADAP            
                DBG_PRINTFA((pBuff,"GetAvailable(RESYNC_TYPE_PENDING_TASKS) returned NULL\n"));
#endif
            }
        }
    }
    
    pPerf->hProcess = NULL;
    pMonitor->Lock();
    pPerf->bFree = TRUE;
    pMonitor->Unlock();

    UnregisterWaitEx(pPerf->hWaitHandle,NULL);
    pPerf->hWaitHandle = NULL;

}

//
//  This is the main function executed when
//  -1- the LoadCtr/UnlaodCtr events are set
//  -2- the Unthrottle events is set by Schedule via the API exposed in Advapi32
//  -3- it runs the 4-minutes-after-boot dredge
//  This function also take care of Reverse-Adapter dredges, if needed
//
////////////////////////////////////////////////////////////////
VOID NTAPI
CMonitorEvents::TimerCallBack(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred())
    {
        return;
    }

    if(bTimerFired)
    {
        ResyncPerfTask * pPerf = (ResyncPerfTask *)pContext;
        CMonitorEvents * pMonitor = pPerf->pMonitor;        
        BOOL bFreeSlot = FALSE;        

#ifdef DEBUG_ADAP
        DBG_PRINTFA((pBuff,"TIMER: Command Type %x\n",pPerf->Type));
#endif

        // check if the Delta Task was disabled on the Fly
        if (!pPerf->Enabled)
        {
#ifdef DEBUG_ADAP        
            DBG_PRINTFA((pBuff,"Task %d was disabled on the fly\n",pPerf->Type));
#endif
               bFreeSlot = TRUE;            
            goto unregister_timer;
        }

        BOOL bDoSomething = TRUE;
        BOOL RunDeltaLogic = TRUE;
        BOOL AddReverseAdapter = FALSE;
        BOOL WDMTriggeredReverseAdapter = FALSE;
        BOOL bDoFullSystemReverseHere = FALSE;

        if (RESYNC_TYPE_PENDING_TASKS == pPerf->Type)
        {
            pMonitor->Lock();
            // here disable tasks that are on the wait list
            for (DWORD i=0;i<RESYNC_TYPE_MAX;i++)
            {
                if (RESYNC_TYPE_PENDING_TASKS != i)
                {
                    if (pMonitor->m_ResyncTasks[i].hTimer)
                    {
#ifdef DEBUG_ADAP                    
                        DBG_PRINTFA((pBuff,"Disabling the pending task %d\n",i));
#endif
                        pMonitor->m_ResyncTasks[i].Enabled = FALSE;
                    }
                }
            }        
            pMonitor->Unlock();
            // now check if the are processes running
               DoUnThrottleDredges();            
            if (pMonitor->m_OutStandingProcesses)
            {
                pMonitor->m_bFullReverseNeeded = TRUE;
                // no need to CreateProcess, the last outstanding process will do that
#ifdef DEBUG_ADAP                
                DBG_PRINTFA((pBuff,"OutStandingProcess, no CreateProcessHere\n"));
#endif
                bFreeSlot = TRUE;
                goto unregister_timer;            
            }
            else // no processes outstanding, create the process now
            {
                bDoFullSystemReverseHere = TRUE;
#ifdef DEBUG_ADAP                
                DBG_PRINTFA((pBuff,"GOTO CreateProcess\n"));
#endif
                 goto createprocess_label;
            }
        }

        if (RESYNC_TYPE_INITIAL == pPerf->Type )
        {
            // check if the Reverse Adapters need a Delta

            LONG lRet;
            HKEY hKey;
            DWORD dwTemp;

            lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                WBEM_REG_REVERSE_KEY,
                                NULL,
                                KEY_READ,
                                &hKey);
    
    
            if (ERROR_SUCCESS == lRet)
            {
                DWORD dwType;
                DWORD dwSize = sizeof(DWORD);
                DWORD dwVal;
                lRet = RegQueryValueEx(hKey,
                                       WBEM_REG_REVERSE_VALUE,
                                       NULL,
                                       &dwType,
                                          (BYTE *)&dwVal,
                                       &dwSize);
                                       
                //    if the key is there, is NULL and it is of the right type
                // OR if the key is not there
                if( ERROR_SUCCESS == lRet &&
                    REG_DWORD == dwType &&
                    dwVal )
                {
                    AddReverseAdapter = TRUE;
#ifdef DEBUG_ADAP                    
                    DBG_PRINTFA((pBuff,"\"Performance Refresh\" key set to %d\n",dwVal));
#endif                    
                    DEBUGTRACE((LOG_WINMGMT,"\"Performance Refresh\" key set to %d\n",dwVal));
                }
                                       
                RegCloseKey(hKey);
            }

            // check the WDM stuff
            if (!AddReverseAdapter)
            {
#ifdef DBG
                if (!HeapValidate(GetProcessHeap(),0,NULL))
                {
                    DebugBreak();
                }
                if (!HeapValidate(CWin32DefaultArena::GetArenaHeap(),0,NULL))
                {
                    DebugBreak();
                }
#endif
            
                            CWMIBinMof BinMof;
                //=============================================================================
                // Note: this combo will always succeed, as all the initialize is doing is 
                // setting a flag to FALSE and returning S_OK
                //=============================================================================
                if( SUCCEEDED( BinMof.Initialize(NULL,FALSE) ) )
                {
                    WDMTriggeredReverseAdapter = BinMof.BinaryMofsHaveChanged();
                    if (WDMTriggeredReverseAdapter)
                    {
                        // override the previous decition
                        AddReverseAdapter = TRUE; 
#ifdef DEBUG_ADAP                        
                        DBG_PRINTFA((pBuff,"BinaryMofs DO HAVE changed\n"));
#endif                        
                        DEBUGTRACE((LOG_WINMGMT,"CWMIBinMof.BinaryMofsHaveChanged == TRUE\n"));
                    }

#ifdef DBG
                    if (!HeapValidate(GetProcessHeap(),0,NULL))
                    {
                        DebugBreak();
                    }
                    if (!HeapValidate(CWin32DefaultArena::GetArenaHeap(),0,NULL))
                    {
                        DebugBreak();
                    }                
#endif                    
                }
            }
            
            // overrides delta with full, if the case
            if (WMIADAP_DEFAULT_TIMETOFULL == pMonitor->GetFullTime())
            {
                // no override
            }
            else  // read timestamp and decide
            {
                ULARGE_INTEGER li;
                li.LowPart = pMonitor->GetTimeStamp().dwLowDateTime;
                li.HighPart = pMonitor->GetTimeStamp().dwHighDateTime;
                __int64 Seconds = pMonitor->GetFullTime();
                Seconds *= 10000000; // number of 100ns units in 1 second

                ULARGE_INTEGER liNow;
                GetSystemTimeAsFileTime((FILETIME *)&liNow);
                
                if ((li.QuadPart + Seconds) < liNow.QuadPart)
                {
                    pPerf->CmdType = RESYNC_FULL_THROTTLE;
                    RunDeltaLogic = FALSE;
                }
            }
        } // end if command type initial

        if ((RESYNC_TYPE_INITIAL == pPerf->Type) && RunDeltaLogic)
        {
             DWORD ret = DeltaDredge2(0,NULL);
#ifdef DEBUG_ADAP             
             DBG_PRINTFA((pBuff,"DeltaDredge2 ret %d\n",ret));
#endif             
             switch(ret)
             {
             case FULL_DREDGE:
                 pPerf->CmdType = RESYNC_FULL_THROTTLE;
                 break;
             case PARTIAL_DREDGE:
                 pPerf->CmdType = RESYNC_DELTA_THROTTLE;
                 break;
             case NO_DREDGE:
                 //
                 // this is the case where we do nothing
                 DEBUGTRACE((LOG_WINMGMT,"No Dredge to run\n"));
                 //
                 bDoSomething = FALSE;
                 break;
             default:
                 //
                 // never here
                 //
                 break;
             }

#ifdef DEBUG_ADAP
             DBG_PRINTFA((pBuff,"DeltaDredge2() ret = %d, bDoSomething = %d \n",ret,bDoSomething));
#endif             
             DEBUGTRACE((LOG_WINMGMT,"DeltaDredge2() ret = %d, bDoSomething = %d \n",ret,bDoSomething));
        }

        if (bDoSomething || AddReverseAdapter)
        {       
createprocess_label:        
            TCHAR pCmdLine[64];
            StringCchCopy(pCmdLine,64,TEXT("wmiadap.exe "));
                   
            if (bDoFullSystemReverseHere)
            {
                StringCchCat(pCmdLine,64,g_Strings[pPerf->CmdType]);            
            }
            else
            {
                if (bDoSomething && AddReverseAdapter)
                {
                    StringCchCat(pCmdLine,64,g_Strings[pPerf->CmdType]);
                    StringCchCat(pCmdLine,64,TEXT(" /R"));                
                }
                if (bDoSomething && !AddReverseAdapter)
                {
                    StringCchCat(pCmdLine,64,g_Strings[pPerf->CmdType]);
                }
                if (!bDoSomething && AddReverseAdapter)
                {
                    StringCchCat(pCmdLine,64,g_Strings[RESYNC_RADAPD_THROTTLE]);
                }            
            }
            CMonitorEvents::CreateProcess_(pCmdLine,pMonitor,pPerf);

            if (GLOB_GetMonitor()->IsRegistred())
            {
                if (!bDoFullSystemReverseHere)
                {
                    InterlockedIncrement(&(GLOB_GetMonitor()->m_OutStandingProcesses));
#ifdef DEBUG_ADAP                    
                    DBG_PRINTFA((pBuff,"(+) Outstanding Tasks %d\n",GLOB_GetMonitor()->m_OutStandingProcesses));                
#endif
                }
            }
        }
        else
        {
            pMonitor->Lock();
            pPerf->bFree = TRUE;
            pMonitor->Unlock();
        }

unregister_timer:
        if (bFreeSlot)
        {
            pMonitor->Lock();
            pPerf->bFree = TRUE;
            pMonitor->Unlock();        
        }
        DeleteTimerQueueTimer(NULL,pPerf->hTimer,NULL);
        pPerf->hTimer = NULL;
        pPerf->Enabled = TRUE;
        
    }
    else
    {
        // never here
        _DBG_ASSERT(FALSE);
    }
}

//
//
//
///////////////////////////////////////////////

DWORD ResyncPerf(DWORD dwReason)
{

    if(!GLOB_IsResyncAllowed())
    {
        ERRORTRACE((LOG_WINMGMT,"ResyncPerf disable g_fSetup or g_fDoResync\n"));
        return 0;
    }
    
    ResyncPerfTask * pPerfTask = GLOB_GetMonitor()->GetAvailable(dwReason);

    if (pPerfTask)
    {   
        // here you have the slot for execution
        // tell Reverse_Adapter that it's scheduled
        if (RESYNC_TYPE_WDMEVENT == dwReason ||  
            RESYNC_TYPE_CLASSCREATION == dwReason)
        {

            LONG lRet;
            HKEY hKey;
            DWORD dwTemp;

            lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                WBEM_REG_REVERSE_KEY,
                                NULL,
                                KEY_READ|KEY_WRITE,
                                &hKey);
    
    
            if (ERROR_SUCCESS == lRet)
            {
                DWORD dwType;
                DWORD dwSize = sizeof(DWORD);
                DWORD dwVal;
                lRet = RegQueryValueEx(hKey,
                                       WBEM_REG_REVERSE_VALUE,
                                       NULL,
                                       &dwType,
                                          (BYTE *)&dwVal,
                                       &dwSize);
                                       
                //    if the key is there, is NULL and it is of the right type
                // OR if the key is not there
                if((ERROR_SUCCESS == lRet &&
                    REG_DWORD == dwType &&
                    0 == dwVal) ||
                    (ERROR_FILE_NOT_FOUND == lRet))
                {
                    dwVal = 1;
                    RegSetValueEx(hKey,
                                  WBEM_REG_REVERSE_VALUE,
                                  0,
                                  REG_DWORD,
                                  (BYTE *)&dwVal,
                                  sizeof(DWORD));
                }
                                       
                RegCloseKey(hKey);
            }
        
        };
        
        if (CreateTimerQueueTimer(&pPerfTask->hTimer,
                                  NULL,
                                  CMonitorEvents::TimerCallBack,
                                  pPerfTask,
                                  pPerfTask->dwTimeDue,
                                  0,
                                  WT_EXECUTEONLYONCE|WT_EXECUTELONGFUNCTION))
        {            
            return 0;
        }
        else
        {
            // ERRORTRACE
            return GetLastError();
        }
    }
    else
    {
        // no slot availables
        return ERROR_BUSY;
    }
}

//
//  
//  This function is called by the Hook installed in wbemcore
//  that monitors class creation
//
///////////////////////////////////////////

DWORD __stdcall
DredgeRA(VOID * pReserved)
{
    //DBG_PRINTFA((pBuff,"Classes\n"));
    return ResyncPerf(RESYNC_TYPE_CLASSCREATION);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\sched.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SCHED.CPP

Abstract:

    Implements the CSched class which is a crude schedualer.

History:

--*/

#include "precomp.h"

#include <persistcfg.h>

#include "sched.h"
#include <stdio.H>
#include <helper.h>

CSched::CSched()
{
    for(DWORD dwCnt = 0; dwCnt < EOL; dwCnt++)
        m_dwDue[dwCnt] = 0xffffffff;
}

void CSched::SetWorkItem(JobType jt, DWORD dwMsFromNow)
{
    m_dwDue[jt] = GetTickCount() + dwMsFromNow;
}

DWORD CSched::GetWaitPeriod()
{
    DWORD dwCurr = GetTickCount();
    DWORD dwRet = INFINITE;
    for(DWORD dwCnt = 0; dwCnt < EOL; dwCnt++)
    {
        if(m_dwDue[dwCnt] == 0xffffffff)
            continue;
        if(m_dwDue[dwCnt] < dwCurr)
            dwRet = 10;
        else
        {
            DWORD dwGap = m_dwDue[dwCnt] - dwCurr;
            if(dwGap < dwRet)
                dwRet = dwGap;
        }
    }
    return dwRet;
}

bool CSched::IsWorkItemDue(JobType jt)
{
    if(m_dwDue[jt] == 0xffffffff)
        return FALSE;
    
    DWORD dwCurr = GetTickCount();    
    return (m_dwDue[jt] <= dwCurr);
}

void CSched::ClearWorkItem(JobType jt)
{
    m_dwDue[jt] = INFINITE;
}

void CSched::StartCoreIfEssNeeded()
{
    DEBUGTRACE((LOG_WINMGMT,"+ CSched::StartCoreIfEssNeeded\n"));

    DWORD dwEssNeedsLoading = 0;
    // Get the values from the configuration time

    CPersistentConfig per;
    per.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING, dwEssNeedsLoading);

    if(dwEssNeedsLoading)
    {
        //
        // we might have the case of a 'net stop' but wbemcore might still be up
        // if it is stillloaded, we have to re-initilaize it
        // if it was unloaded, this is the first time load and globals are OK
        //
        HMODULE hCoreModule = NULL;                
        if (GetModuleHandleEx(0,__TEXT("wbemcore.dll"),&hCoreModule))
        {  
            OnDelete<HMODULE,BOOL(*)(HMODULE),FreeLibrary> flm(hCoreModule);
            
            HRESULT (STDAPICALLTYPE * pfnReinit)(DWORD) ;
            pfnReinit = (HRESULT (STDAPICALLTYPE *)(DWORD))GetProcAddress(hCoreModule, "Reinitialize");
            
            if (NULL == pfnReinit) return;
            pfnReinit(0);
        }
    
        IWbemLevel1Login * pCore = NULL;        
        SCODE sc = CoCreateInstance(CLSID_InProcWbemLevel1Login, 
                                    NULL, 
                                    CLSCTX_INPROC_SERVER ,
                                    IID_IUnknown, 
                                    (void**)&pCore);

        if(sc == S_OK)
        {
            IWbemServices * pServ = NULL;
            sc = pCore->NTLMLogin(L"Root", NULL, 0, NULL, &pServ);
            if(SUCCEEDED(sc))
                pServ->Release();

            pCore->Release();
        }
            
    }

    DEBUGTRACE((LOG_WINMGMT,"- CSched::StartCoreIfEssNeeded\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\resync2.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC2.H

Abstract:

	Declares the various idle task

History:

--*/

#ifndef _RESYNC2_H_
#define _RESYNC2_H_

#include <wmistr.h>
#include <wmium.h>

#include <statsync.h>

#define MAX_LOOP 0x100000


#define LOAD_CTR_EVENT_NAME TEXT("WMI_SysEvent_LodCtr")
#define UNLOAD_CTR_EVENT_NAME TEXT("WMI_SysEvent_UnLodCtr")

#define REVERSE_DREDGE_EVENT_NAME_SET TEXT("WMI_RevAdap_Set")
#define REVERSE_DREDGE_EVENT_NAME_ACK TEXT("WMI_RevAdap_ACK")

//
// these names containd the Idle word just because of a misunderstanding, 
// but we don't have idle task, just pending task at most
//
#define PENDING_TASK_START       TEXT("WMI_ProcessIdleTasksStart")
#define PENDING_TASK_COMPLETE    TEXT("WMI_ProcessIdleTasksComplete")

#define SIG_WDMEVENTS_BUSY       ((DWORD)'EMDW')
#define SIG_WDMEVENTS_FREE       ((DWORD)'emdw')

class CWDMListener
{
    enum {
        Type_Added,
        Type_Removed
    };

public:
    CWDMListener();
    ~CWDMListener();

    DWORD OpenAdd();
    DWORD CloseAdd();
    DWORD OpenRemove();
    DWORD CloseRemove();
    
    
    DWORD Register();
    VOID  Unregister();
    
    static VOID NTAPI  EvtCallBackAdd(VOID * pContext,BOOLEAN bTimerFired);
    static VOID NTAPI  EvtCallBackRem(VOID * pContext,BOOLEAN bTimerFired);
    static VOID WINAPI WmiCallBack(PWNODE_HEADER Wnode, UINT_PTR NotificationContext);

    VOID EvtCallThis(BOOLEAN bTimerFired,int Type);
    
private:
    DWORD     m_dwSignature;
    WMIHANDLE m_hEventAdd;
    WMIHANDLE m_hEventRem;
    HANDLE    m_hWaitAdd;
    HANDLE    m_hWaitRem;
    BOOL      m_UnInited;
    CStaticCritSec  m_cs;
    GUID	  m_GuidAdd;// = GUID_MOF_RESOURCE_ADDED_NOTIFICATION ;
	GUID	  m_GuidRem;// = GUID_MOF_RESOURCE_REMOVED_NOTIFICATION ;
    
};

#define SIG_COUNTEEVENTS_BUSY       ((DWORD)'ETNC')
#define SIG_COUNTEEVENTS_FREE       ((DWORD)'etnc')

class CCounterEvts
{
    enum {
       Type_Load,
       Type_Unload
    };
public:
    CCounterEvts();
    ~CCounterEvts();
    DWORD Init();
    VOID UnInit();

    DWORD Register();
    DWORD Unregister();

    static VOID NTAPI EvtCallBackLoad(VOID * pContext,BOOLEAN bTimerFired);
    static VOID NTAPI EvtCallBackUnload(VOID * pContext,BOOLEAN bTimerFired);
    static VOID NTAPI EvtCallBackPendingTask(VOID * pContext,BOOLEAN bTimerFired);

    VOID CallBack(BOOLEAN bTimerFired,int Type);
    VOID CallBackPending(BOOLEAN bTimerFired);    
    BOOL IsInited(){return !m_Uninited; };
    HANDLE GetTaskCompleteEvent(){ return m_hPendingTasksComplete; };
    
private:
    DWORD  m_dwSignature;
    HANDLE m_hTerminateEvt;
    HANDLE m_LoadCtrEvent;
    HANDLE m_UnloadCtrEvent;

    HANDLE m_WaitLoadCtr;
    HANDLE m_WaitUnloadCtr;
    BOOL   m_Uninited;
    HANDLE m_hWmiReverseAdapSetLodCtr;
    HANDLE m_hWmiReverseAdapLodCtrDone;
    HANDLE m_hWaitPendingTasksStart;
    HANDLE m_hPendingTasksStart;
    HANDLE m_hPendingTasksComplete;    
};

DWORD ResyncPerf(DWORD dwReason);

#define MAX_PROCESS_WAIT (10*60*1000)
#define MAX_PROCESS_NUM  (2)

#define RESYNC_FULL_THROTTLE         0
#define RESYNC_DELTA_THROTTLE        1
#define RESYNC_RADAPD_THROTTLE       2
#define RESYNC_FULL_RADAPD_THROTTLE  3
#define RESYNC_DELTA_RADAPD_THROTTLE 4
#define RESYNC_FULL_RADAPD_NOTHROTTLE 5

#define RESYNC_TYPE_INITIAL          0
#define RESYNC_TYPE_LODCTR           1
#define RESYNC_TYPE_WDMEVENT         2
#define RESYNC_TYPE_CLASSCREATION    2  // intentionally duplicated
#define RESYNC_TYPE_PENDING_TASKS    3
#define RESYNC_TYPE_MAX              4

#define SIG_RESYNC_PERF              ((DWORD)'YSER')

class CMonitorEvents;

//
// the gate-ing is implemented with the  ResyncPerfTask::bFree
// The GetAvailable() will set the bFree to FALSE, 
// and any task completion will set that to TRUE.
// A task can be completed:
// immediatly in the Timer-Phase
//  this happens if the task has been disabled by ProcessIdleTasks
//  this happens if the ProcessIdleTasks command 
//      will be re-processed when OutStandingProcess == 0
// A task can be completed in the Event-Call back phase
//  when a process naturally exits or terminate process is invoked.
//  when there is an error in the machinery that creates the process
//
//

class ResyncPerfTask{
public:
    DWORD  dwSig;
    BOOL   bFree;               // set under CritSec
    DWORD  Type;                // set by GetAvailable
    DWORD  CmdType;             // set by GetAvailable or the TimerCallback
    HANDLE hTimer;              // set by the 
    DWORD  dwTimeDue;           // set by GetAvailable
    CMonitorEvents * pMonitor;  // set by the constructor
    HANDLE  hProcess;           // set by the DeltaDredge2
    HANDLE  hWaitHandle;        //   
    BOOL    Enabled;            // this is to disable an already scheduled stask
};

//
//
//  MonitorEvents
//  This class monitors the Load-Unlodctr events
//  schedules the ResyncPerf
//  and monitors for WDM events in a Service-friendly way
//
///////////////////////////////////////////////////////////////

class CMonitorEvents
{
public:
    CMonitorEvents();
    ~CMonitorEvents();
    BOOL Init();
    BOOL Uninit();
    DWORD Register();   // called in the running/continue
    DWORD Unregister(BOOL bIsSystemShutDown); // called in the pause/stop
    
    VOID Lock(){ m_cs.Enter(); };
    VOID Unlock(){ m_cs.Leave(); };

    VOID RegRead();
    ResyncPerfTask * GetAvailable(DWORD dwReason);
    DWORD GetFullTime(){ return m_dwTimeToFull; };
    FILETIME & GetTimeStamp(){ return m_FileTime; };
    static VOID NTAPI TimerCallBack(VOID * pContext,BOOLEAN bTimerFired);
    static VOID NTAPI EventCallBack(VOID * pContext,BOOLEAN bTimerFired);
    BOOL IsRegistred(){ return m_bRegistred; };
    HANDLE GetTaskCompleteEvent(){ return m_CntsEvts.GetTaskCompleteEvent(); };

    static BOOL WINAPI MonitorCtrlHandler( DWORD dwCtrlType );
    static BOOL CreateProcess_(TCHAR * pCmdLine,
	                      CMonitorEvents * pMonitor,
	                      ResyncPerfTask * pPerf);
    
    // public to avoid accessors
    LONG m_OutStandingProcesses ;
    BOOL m_bFullReverseNeeded;
    
private:

    BOOL m_bRegistred;
    
    DWORD            m_dwSig;
    BOOL             m_bInit;
    CStaticCritSec m_cs;
    CCounterEvts     m_CntsEvts;
    CWDMListener     m_WDMListener;

    ResyncPerfTask   m_ResyncTasks[RESYNC_TYPE_MAX];
    DWORD m_dwADAPDelaySec;
    DWORD m_dwLodCtrDelaySec;
    DWORD m_dwTimeToFull;
    DWORD m_dwTimeToKillAdap;
    FILETIME m_FileTime;
};


#endif /**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\sched.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SCHED.H

Abstract:

	Declares the CSched class which is a crude scheduler.

History:

--*/

#ifndef _sched_H_
#define _sched_H_


enum JobType {
    FirstCoreShutdown = 0, 
    FinalCoreShutdown, 
    PossibleStartCore, 
    EOL
};

class CSched
{
private:
    DWORD m_dwDue[EOL];
public:
    CSched();
    void SetWorkItem(JobType jt, DWORD dwMsFromNow);
    DWORD GetWaitPeriod();
    bool IsWorkItemDue(JobType jt);
    void ClearWorkItem(JobType jt);
    void StartCoreIfEssNeeded();

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\strings.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	resource IDs.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _provstub_H_
#define _provstub_H_

#define ID1		101
#define ID2		102
#define ID3		103
#define ID4		104
#define ID5		105
#define ID6		106
#define ID7		107
#define ID8		108
#define ID9		109
#define ID10	110

#define ID_ERROR_SHORT		200
#define ID_ERROR_LONG		201
#define ID_BACKUP_TITLE		202
#define ID_RESTORE_TITLE	203

#define ID_WINMGMT_DESCRIPTION 204
#define ID_WINMGMT_SERVICE     205

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\winmgmt.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    winmgmt.cpp

Abstract:

    the Service main function, initialization routines, ecc

--*/


#include "precomp.h"

#include <winsvc.h>
#include <persistcfg.h>
#include <winntsec.h>

#include "cntserv.h"
#include "winmgmt.h"
#include "sched.h"
#include "resync2.h"
#include <delayimp.h>
#include <malloc.h>
#include <map>

#include "wstlallc.h"

//
//  Defines
//
//***********************************************************************

#define CORE_PROVIDER_UNLOAD_TIMEOUT ( 30 * 1000 )

//***********************************************************************
//
//  Globals
//
//***********************************************************************

HINSTANCE g_hInstance;

//***********************************************************************
//
//  Dll  Entry points and export points
//
//***********************************************************************


BOOL APIENTRY DllMain( HINSTANCE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
                     )
{
    BOOL bRet = TRUE;
    switch(ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hModule;
        DisableThreadLibraryCalls(hModule);
        bRet = CStaticCritSec::anyFailure()?FALSE:TRUE;
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return bRet;
};

//
// 
//  InitialBreak
//
///////////////////////////////////////////////////////////

BOOL
InitialBreak()
{
    HKEY hKey;
    LONG lRet;
    BOOL bRet = FALSE;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        HOME_REG_PATH,
                        0,
                        KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwType;
        DWORD dwVal;
        DWORD dwSize = sizeof(DWORD);
        
        lRet = RegQueryValueEx(hKey,
                               INITIAL_BREAK,
                               NULL,
                               &dwType,
                               (BYTE *)&dwVal,
                               &dwSize);
                               
        if (ERROR_SUCCESS == lRet &&
            dwType == REG_DWORD &&
            dwVal)
        {
             bRet = TRUE;
        }
        
        RegCloseKey(hKey);
    }
    return bRet;
}

//
//  the global structure
//
struct _PROG_RESOURCES g_ProgRes;

void
_PROG_RESOURCES::Init()
{
    m_bOleInitialized = NULL;

    m_pLoginFactory = NULL;
    m_pBackupFactory = NULL;
    
    m_dwLoginClsFacReg = 0;
    m_dwBackupClsFacReg = 0;

    g_fSetup = FALSE;
    g_fDoResync = TRUE;
    
    hMainMutex = NULL;
    bShuttingDownWinMgmt = FALSE;
    gbCoreLoaded = FALSE;

    ServiceStatus = SERVICE_STOPPED;

    ghCoreCanUnload = NULL;
    ghProviderCanUnload = NULL;
    
    ghMofDirChange = NULL;

    szHotMofDirectory = NULL;
        
    pWbemVssWriter = NULL;
    bWbemVssWriterSubscribed = false;
    dwWaitThreadID = GetCurrentThreadId();
};

BOOL 
_PROG_RESOURCES::Phase1Build()
{
    hMainMutex = CreateMutex(NULL, FALSE, NULL);

    g_fSetup = CheckSetupSwitch();

    if ( g_fSetup )
    {
        SetNoShellADAPSwitch();
    }

    // Look in the registry to decide if we will launch a resync perf or not
    g_fDoResync = CheckNoResyncSwitch();

    //
    //  set this to have the Console Control Handler notification
    //
    SetProcessShutdownParameters(0x400,0);

    //
    // set to some defined value parames that might be outstanding if someone killed us
    //
    RegSetDWORD(HKEY_LOCAL_MACHINE,HOME_REG_PATH,DO_THROTTLE,1);    
    
    return hMainMutex?TRUE:FALSE;
};

BOOL 
_PROG_RESOURCES::Phase2Build(HANDLE hTerminateEvt)
{
    ghCoreCanUnload = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_COREDLL_CANSHUTDOWN"));
    if (NULL == ghCoreCanUnload)
    {
        // create a non-named event that nobody will set
        ghCoreCanUnload = CreateEvent(NULL,FALSE,FALSE,NULL);
        if (NULL == ghCoreCanUnload) return FALSE;
    }

    ghProviderCanUnload = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_PROVIDER_CANSHUTDOWN"));
    if (NULL == ghProviderCanUnload)
    {
        // create a non-named event that nobody will set
        ghProviderCanUnload = CreateEvent(NULL,FALSE,FALSE,NULL);
        if (NULL == ghProviderCanUnload) return FALSE;
    }
       
    if (!m_Monitor.Init())
    {
        return FALSE;
    }

    // don't create a writer if during setup
    if (!g_fSetup)
    {
        pWbemVssWriter = new CWbemVssWriter;
        if (!pWbemVssWriter)
        {
            TRACE((LOG_WINMGMT,"WINMGMT could not create the VssWriter\n"));
            return FALSE;
        }
    }

    return TRUE;
}

CForwardFactory g_FactoryLogin(CLSID_InProcWbemLevel1Login);

BOOL
_PROG_RESOURCES::RegisterLogin()
{
    HRESULT sc;
    DWORD dwFlags = CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER;

    g_ProgRes.m_pLoginFactory = &g_FactoryLogin;
    g_ProgRes.m_pLoginFactory->AddRef();
    
    sc = CoRegisterClassObject(CLSID_WbemLevel1Login, 
                               g_ProgRes.m_pLoginFactory,
                               dwFlags,
                               REGCLS_MULTIPLEUSE, 
                               &g_ProgRes.m_dwLoginClsFacReg);
    if(sc != S_OK)
    {
        DEBUGTRACE((LOG_WINMGMT,"Failed to register the "
                            "CLSID_WbemLevel1Login class factory, "
                            "sc = 0x%x\n", sc));
        return FALSE;
    }
    else
    {
        DEBUGTRACE((LOG_WINMGMT, "Registered class factory with flags: 0x%X\n",dwFlags));
        return TRUE;
    }
}

BOOL
_PROG_RESOURCES::RevokeLogin()
{
    if(m_pLoginFactory) 
    {
        CoRevokeClassObject(m_dwLoginClsFacReg);
        m_dwLoginClsFacReg = 0;
        m_pLoginFactory->Release();
        m_pLoginFactory = NULL;
    }
    return TRUE;
}

CForwardFactory g_FactoryBackUp(CLSID_WbemBackupRestore);

BOOL
_PROG_RESOURCES::RegisterBackup()
{
    HRESULT sc;
    DWORD dwFlags = CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER;

    g_ProgRes.m_pBackupFactory = &g_FactoryBackUp;
    g_ProgRes.m_pBackupFactory->AddRef();

    sc = CoRegisterClassObject(CLSID_WbemBackupRestore, 
                               g_ProgRes.m_pBackupFactory,
                               dwFlags,
                               REGCLS_MULTIPLEUSE, 
                               &g_ProgRes.m_dwBackupClsFacReg);
    if(sc != S_OK)
    {
        TRACE((LOG_WINMGMT,"Failed to register the "
                            "Backup/recovery class factory, "
                            "sc = 0x%x\n", sc));
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
_PROG_RESOURCES::RevokeBackup()
{
    if(m_pBackupFactory) 
    {
        CoRevokeClassObject(m_dwBackupClsFacReg);
        m_dwBackupClsFacReg = 0;
        m_pBackupFactory->Release();
        m_pBackupFactory = NULL;
    }
    return TRUE;
}

_PROG_RESOURCES::Phase1Delete(BOOL bIsSystemShutdown)
{

    if (!bIsSystemShutdown)
    {    
        if(ghCoreCanUnload)
        {
            CloseHandle(ghCoreCanUnload);
            ghCoreCanUnload = NULL;
        };
        
        if(ghProviderCanUnload)
        {
            CloseHandle(ghProviderCanUnload);
            ghProviderCanUnload = NULL;
        }
        if(ghMofDirChange)
        {
            CloseHandle(ghMofDirChange);
            ghMofDirChange = NULL;
        }
    }

    if (m_Monitor.IsRegistred())
    {
        m_Monitor.Unregister(bIsSystemShutdown);
    }
    if (!bIsSystemShutdown)
    {
        m_Monitor.Uninit();
        
        if(szHotMofDirectory)
        {
            delete [] szHotMofDirectory;
            szHotMofDirectory = NULL;
        }

    }

    // shut down and delete our writer for volume snapshot backup
    if (pWbemVssWriter && !bIsSystemShutdown)
    {
        if (bWbemVssWriterSubscribed)
        {
            HRESULT hRes = pWbemVssWriter->Unsubscribe();
            if (SUCCEEDED(hRes))
            {
                bWbemVssWriterSubscribed = false;
            }
            else
            {
                TRACE((LOG_WINMGMT,"WINMGMT Could not unsubscribe the VssWriter\n"));
            }
        }

        delete pWbemVssWriter;
        pWbemVssWriter = NULL;
    }

    return TRUE;
}

_PROG_RESOURCES::Phase2Delete(BOOL bIsSystemShutdown)
{

    // do anyway COM cleanup
    // we are on Server now, we can afford it

    RevokeLogin();
    RevokeBackup();
    
    if(m_bOleInitialized)
    {
       CoUninitialize();
       m_bOleInitialized = FALSE;
    }

    return TRUE;
}

BOOL
_PROG_RESOURCES::Phase3Delete()
{
    if (hMainMutex)
    {
        CloseHandle(hMainMutex);
        hMainMutex = NULL;
    }    
    return TRUE;
}

//
//
//  IsShutDown
//
//
/////////////////////////////////////////////////////////////////

BOOL WINAPI IsShutDown(void)
{
    return g_ProgRes.bShuttingDownWinMgmt;
}

//
//
//  ShutDownCore
//
//
/////////////////////////////////////////////////////////////////

bool ShutDownCore(BOOL bProcessShutdown,BOOL bIsSystemShutDown)
{
    SCODE sc = WBEM_E_FAILED;
    HMODULE hCoreModule = LoadLibrary(__TEXT("wbemcore.dll"));
    if(hCoreModule)
    {
        pfnShutDown pfn = (pfnShutDown)GetProcAddress(hCoreModule, "Shutdown");
        if(pfn)
        {
            sc = (pfn)(bProcessShutdown,bIsSystemShutDown);
            DEBUGTRACE((LOG_WINMGMT, "core is being shut down by WinMgmt, it returned 0x%x\n",sc));
        }

        FreeLibrary(hCoreModule);
     }
    return sc == S_OK;
}


//
//
//  void Cleanup
//
//  Revokes Factories and close Ole etc.
//
///////////////////////////////////////////////////////////////////

void Cleanup(BOOL bIsSystemShutDown)
{   
    if (!bIsSystemShutDown)
    {    
        DEBUGTRACE((LOG_WINMGMT,"+ Cleanup(%d), ID = %x\n", bIsSystemShutDown,GetCurrentProcessId()));
    }

    g_ProgRes.Phase1Delete(bIsSystemShutDown);

    // If the core is still loaded, call its shutdown function

    ShutDownCore(TRUE,bIsSystemShutDown);

    if (!bIsSystemShutDown)
    {
        CoFreeUnusedLibrariesEx ( 0 , 0 ) ;
        CoFreeUnusedLibrariesEx ( 0 , 0 ) ;    
    }

    g_ProgRes.Phase2Delete(bIsSystemShutDown);

    if (!bIsSystemShutDown)
    {
        DEBUGTRACE((LOG_WINMGMT,"- Cleanup()\n"));
    }
}

//
//
//  BOOL Initialize
//
//
///////////////////////////////////////////////////////////////

BOOL Initialize(HANDLE hTerminateEvt)
{
    if (NULL == hTerminateEvt) return FALSE;
    // Set the error mode.  This is used to provent the system from putting up dialog boxs to
    // open files

    UINT errormode = SetErrorMode(0);
    errormode |= SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS;
    SetErrorMode(errormode);

    DEBUGTRACE((LOG_WINMGMT,"+ Initialize, pid = %x\n", GetCurrentProcessId()));

    if(!InitHotMofStuff(&g_ProgRes))
        return FALSE;
           
    if (!g_ProgRes.Phase2Build(hTerminateEvt))
        return FALSE;

    // Initialize Ole

    SCODE sc;

    sc = CoInitializeEx(NULL,COINIT_MULTITHREADED);

    if(FAILED(sc))
    {
        ERRORTRACE((LOG_WINMGMT,"WINMGMT Could not initialize Ole\n"));
        return FALSE;
    }
    else
    {
        g_ProgRes.m_bOleInitialized = TRUE;
    }

    //
    //  Call the initialize function in core
    //
    HMODULE hCoreModule = NULL;                
    if (GetModuleHandleEx(0,__TEXT("wbemcore.dll"),&hCoreModule))
    {  
        OnDelete<HMODULE,BOOL(*)(HMODULE),FreeLibrary> flm(hCoreModule);

        HRESULT (STDAPICALLTYPE *pfn)(DWORD);
        pfn = (long (__stdcall *)(DWORD))GetProcAddress(hCoreModule, "Reinitialize");
        if(pfn)
        {
            sc = (*pfn)(0);
            DEBUGTRACE((LOG_WINMGMT, "wbemcore!Reinitialize() returned 0x%x\n",sc));
        }
        else
        {
            DEBUGTRACE((LOG_WINMGMT, "failed to re-initialize core\n"));
            return FALSE; 
        }
    }
    

    g_ProgRes.RegisterLogin();
    g_ProgRes.RegisterBackup();

    g_ProgRes.ServiceStatus = SERVICE_RUNNING;
    
    // initialize our writer for volume snapshot backup
    // this must be after CoInitializeEx and after wbem is initialized
    // (this pointer will be NULL during setup)
    if (g_ProgRes.pWbemVssWriter)
    {
        HRESULT hRes = g_ProgRes.pWbemVssWriter->Initialize();
        if (SUCCEEDED(hRes))
        {
            hRes = g_ProgRes.pWbemVssWriter->Subscribe();
            if (SUCCEEDED(hRes))
            {
                g_ProgRes.bWbemVssWriterSubscribed = true;
            }
            else
            {
                DEBUGTRACE((LOG_WINMGMT,"WINMGMT Could not subscribe the VssWriter\n"));
            }
        }
        else
        {
            DEBUGTRACE((LOG_WINMGMT,"WINMGMT Could not initialize the VssWriter\n"));
        }
    }

    DEBUGTRACE((LOG_WINMGMT,"- Initialize\n"));
    
    return TRUE;
}



//
//
//  WaitingFunction
//
//  DESCRIPTION:
//
//  Here is where we wait for messages and events during WinMgmt execution.
//  We return from here when the program/service is being stopped.
//
//////////////////////////////////////////////////////////////////

void WaitingFunction(HANDLE hTerminate)
{
    DEBUGTRACE((LOG_WINMGMT,"+ WaitingFunction\n"));
    
    CSched sched;
    
    HANDLE hEvents[] = {hTerminate, 
                        g_ProgRes.ghCoreCanUnload,                         
                        g_ProgRes.ghProviderCanUnload,
                        g_ProgRes.ghMofDirChange      // important, must be last entry!!!!
                        };
                        
    int iNumEvents = sizeof(hEvents) / sizeof(HANDLE);
    DWORD dwFlags;
    SCODE sc;
    CPersistentConfig per;
    per.TidyUp();

    sched.SetWorkItem(PossibleStartCore, 60000);   

    //Load any MOFs in the MOF directory if needed...
    LoadMofsInDirectory(g_ProgRes.szHotMofDirectory); 

    // resync the perf counters if 
    // we haven't turned this off for debugging  AND
    // we are not running during setup
    
    if(GLOB_IsResyncAllowed()) 
    {
        ResyncPerf(RESYNC_TYPE_INITIAL);
        GLOB_GetMonitor()->Register();
    }
    
    while(TRUE)
    {
        DWORD dwDelay = sched.GetWaitPeriod();
        DWORD dwObj = WaitForMultipleObjects(iNumEvents, hEvents, FALSE, dwDelay);
                
        switch (dwObj)
        {
            case 0:     // bail out for terminate event
                {
                
                    if (SERVICE_SHUTDOWN != g_ProgRes.ServiceStatus)
                    {
                        DEBUGTRACE((LOG_WINMGMT,"hTerminate set: reason %x\n",g_ProgRes.ServiceStatus));
                    }
                    {
                        CInMutex im(g_ProgRes.hMainMutex);
                        g_ProgRes.bShuttingDownWinMgmt = TRUE;
                    }
                    // call cleanup outside of a Mutex
                    Cleanup((g_ProgRes.ServiceStatus == SERVICE_SHUTDOWN)?TRUE:FALSE);
                }
                return;
            case 1:     // core can unload
                DEBUGTRACE((LOG_WINMGMT,"Got a core can unload event\n"));
                sched.SetWorkItem(FirstCoreShutdown, 30000);   // 30 seconds until next unloac;
                break;
            case 2:     // provider can unload
                {
                    DEBUGTRACE((LOG_WINMGMT,"Got a provider can unload event\n"));                    
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    sched.SetWorkItem(FinalCoreShutdown, CORE_PROVIDER_UNLOAD_TIMEOUT);   // 11 minutes until next unloac;
                }
                break;
            case 3:     // change in the hot mof directory
                {
                    DEBUGTRACE((LOG_WINMGMT,"Got change in the hot mof directory\n"));
                    LoadMofsInDirectory(g_ProgRes.szHotMofDirectory);

                    //Continue to monitor changes
                    if (!FindNextChangeNotification(g_ProgRes.ghMofDirChange))
                    {
                        iNumEvents--;
                    }
                }
                break;
            case WAIT_TIMEOUT:

                DEBUGTRACE((LOG_WINMGMT,"Got a TIMEOUT work item\n"));
                if(sched.IsWorkItemDue(FirstCoreShutdown))
                {

                    // All the clients have left the core and a decent time interval has passed.  Set the
                    // WINMGMT_CORE_CAN_BACKUP event.  When the core is done, it will set the WINMGMT_CORE_BACKUP_DONE
                    // event which will start the final unloading.

                    DEBUGTRACE((LOG_WINMGMT,"Got a FirstCoreShutdown work item\n"));
                    sched.ClearWorkItem(FirstCoreShutdown);
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                }
                if(sched.IsWorkItemDue(FinalCoreShutdown))
                {
                    CInMutex im(g_ProgRes.hMainMutex);
                    DEBUGTRACE((LOG_WINMGMT,"Got a FinalCoreShutdown work item\n"));
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    sched.ClearWorkItem(FinalCoreShutdown);
                }
                if(sched.IsWorkItemDue(PossibleStartCore))
                {                    
                    sched.StartCoreIfEssNeeded();
                    sched.ClearWorkItem(PossibleStartCore);
                }

                break;
        }

    }

}


//***************************************************************************
//
//  MyService::MyService
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

MyService::MyService(DWORD CtrlAccepted):CNtService(CtrlAccepted)
{
    m_hStopEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    
    if(m_hStopEvent == NULL)
    {
        DEBUGTRACE((LOG_WINMGMT,"MyService could not initialize\n"));
    }
}

//***************************************************************************
//
//  MyService::~MyService
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

MyService::~MyService()
{
    if(m_hStopEvent)
        CloseHandle(m_hStopEvent);
}

//***************************************************************************
//
//  DWORD MyService::WorkerThread
//
//  DESCRIPTION:
//
//  Where the service runs.  In this case, the service just waits for
//  the terminate event to be set.
//
//  RETURN VALUE:
//
//  0
//***************************************************************************

DWORD MyService::WorkerThread()
{
    DEBUGTRACE((LOG_WINMGMT,"+ Service::WorkerThread\n"));
    if(!::Initialize(m_hStopEvent))
        return 0;
    WaitingFunction(m_hStopEvent);

    if (SERVICE_SHUTDOWN != g_ProgRes.ServiceStatus )
    {
        DEBUGTRACE((LOG_WINMGMT,"- Service::WorkerThread\n"));
    }
    return 0;
}

//
//
//  VOID MyService::Log
//
///////////////////////////////////////////////////////////////////

VOID MyService::Log(
                        IN LPCSTR lpszMsg)
{
    TRACE((LOG_WINMGMT,lpszMsg));
}

//
//
//  the stop function
//
//////////////////////////////////////////////////////////////////

VOID MyService::Stop(BOOL bSystemShutDownCalled)
{

    if (bSystemShutDownCalled)
    {
        WbemSetMachineShutdown(TRUE);
    }

    g_ProgRes.ServiceStatus = (bSystemShutDownCalled)?SERVICE_SHUTDOWN:SERVICE_STOPPED;
    
    SetEvent(m_hStopEvent);
};

//
// MyService::Pause
//
////////////////////////////////////////////////////////////////////

HRESULT WbemPauseService()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    g_ProgRes.ServiceStatus = SERVICE_PAUSED;
    g_ProgRes.RevokeLogin();
    GLOB_GetMonitor()->Unregister(FALSE);

    SCODE sc = WBEM_E_FAILED;
    HMODULE hCoreModule = LoadLibraryEx(__TEXT("wbemcore.dll"),NULL,0);
    if(hCoreModule)
    {        
        pfnShutDown pfn = (pfnShutDown)GetProcAddress(hCoreModule, "Shutdown");
        if(pfn)
        {
            sc = pfn(FALSE,FALSE);
            DEBUGTRACE((LOG_WINMGMT, "core is being shut down by WinMgmt, it returned 0x%x\n",sc));
        }
        else
            hr = WBEM_E_CRITICAL_ERROR;

        FreeLibrary(hCoreModule);
     }
    else
        hr = WBEM_E_CRITICAL_ERROR;

    return hr;
}

VOID MyService::Pause()
{
    WbemPauseService();
}


//
// MyService::Continue
//
////////////////////////////////////////////////////////////////////

HRESULT WbemContinueService()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    SCODE sc = WBEM_E_FAILED;
    HMODULE hCoreModule = LoadLibraryEx(__TEXT("wbemcore.dll"),NULL,0);
    if(hCoreModule)
    {
        HRESULT (STDAPICALLTYPE *pfn)(DWORD);
        pfn = (long (__stdcall *)(DWORD))GetProcAddress(hCoreModule, "Reinitialize");
        if(pfn)
        {
            sc = (*pfn)(0);
            DEBUGTRACE((LOG_WINMGMT, "core is being resumed: it returned 0x%x\n",sc));
        }
        else
            hr = WBEM_E_CRITICAL_ERROR;

        FreeLibrary(hCoreModule);
     }
    else
        hr = WBEM_E_CRITICAL_ERROR;

    g_ProgRes.RegisterLogin();
    GLOB_GetMonitor()->Register();
    g_ProgRes.ServiceStatus = SERVICE_RUNNING;
    
    return hr;
}

VOID MyService::Continue()
{
    WbemContinueService();
}

//
//
//  this function will be executed before
//  the final SetServiceStatus(SERVICE_STOPPED)
//
//////////////////////////////////////////////////////////

VOID MyService::FinalCleanup()
{
    g_ProgRes.Phase3Delete();

    RegSetDWORD(HKEY_LOCAL_MACHINE,
                 HOME_REG_PATH,
                 TEXT("ProcessID"),
                 0); 
}

//
//
//     publish process ID in the registry
//
////////////////////////////////////////////////////

DWORD 
RegSetDWORD(HKEY hKey,
             TCHAR * pName,
             TCHAR * pValue,
             DWORD dwValue)
{
    HKEY hKey2;
    LONG lRet;

    lRet = RegOpenKeyEx(hKey,
                        pName,
                        0,
                        KEY_WRITE,
                        &hKey2);
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwType = REG_DWORD; 
        DWORD dwSize = sizeof(DWORD);
        
        lRet = RegSetValueEx(hKey2,
                             pValue,
                             NULL,
                             dwType,
                             (BYTE *)&dwValue,
                             dwSize);
                                       
        RegCloseKey(hKey2);
    }
    return lRet;

}
                    

DWORD 
RegGetDWORD(HKEY hKey,
             TCHAR * pName,
             TCHAR * pValue,
             DWORD * pdwValue)
{
    HKEY hKey2;
    LONG lRet;

    if (0 == pdwValue)
        return ERROR_INVALID_PARAMETER;


    lRet = RegOpenKeyEx(hKey,
                        pName,
                        0,
                        KEY_READ,
                        &hKey2);
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType =0;
        lRet = RegQueryValueEx(hKey2,
                             pValue,
                             NULL,
                             &dwType,
                             (BYTE *)pdwValue,
                             &dwSize);
        if (ERROR_SUCCESS == lRet && REG_DWORD != dwType)
        {
            lRet = ERROR_INVALID_DATATYPE;
        }
                                       
        RegCloseKey(hKey2);
    }
    return lRet;

}
                          
//
//
//  Interceptor
//
//
///////////////////////////////////////////////////////////

#ifdef  INSTRUMENTED_BUILD
#ifdef  _X86_

#include <malloc.h>

struct HEAP_ENTRY {
    WORD Size;
    WORD PrevSize;
    BYTE SegmentIndex;
    BYTE Flags;
    BYTE UnusedBytes;
    BYTE SmallTagIndex;
};

#define HEAP_SLOW_FLAGS  0x7d030f60

// only the "header"

typedef struct _HEAP {
    HEAP_ENTRY Entry;
    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
} HEAP;

BOOL   g_FaultHeapEnabled = FALSE;
BOOL   g_FaultFileEnabled = FALSE;
ULONG g_Seed;
ULONG g_Factor  = 100000;
ULONG g_Percent = 0x20;
//ULONG g_RowOfFailures = 10;
//LONG  g_NumFailInARow = 0;
//LONG  g_NumFailedAllocation = 0;
BOOL g_bDisableBreak = FALSE;
LONG g_nSuccConn = 0;

#define SIZE_JUMP_ADR    5
#define SIZE_SAVED_INSTR 12

void
_declspec(naked) Prolog__ReadFile(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
        nop ; // dist        
    }
}


BOOL _I_ReadFile(
  HANDLE hFile,               // handle to file
  LPVOID lpBuffer,            // data buffer
  DWORD nNumberOfBytesToRead, // number of bytes to read
  LPDWORD lpNumberOfBytesRead, // number of bytes read  
  LPOVERLAPPED lpOverlapped   // offset
){
    DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

    LONG Ret = RtlRandomEx(&g_Seed);
    if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
    {
        if (lpNumberOfBytesRead)
            *lpNumberOfBytesRead = 0;
        SetLastError(-1);        
        return FALSE;
    }    
    
    _asm{
        push lpOverlapped;
        push lpNumberOfBytesRead;
        push nNumberOfBytesToRead;
        push lpBuffer;
        push hFile;
        call Prolog__ReadFile;
        mov  bRet,eax
    }

    return bRet;
}


void
_declspec(naked) Prolog__WriteFile(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
    }
}

BOOL _I_WriteFile(
  HANDLE hFile,                    // handle to file
  LPCVOID lpBuffer,                // data buffer
  DWORD nNumberOfBytesToWrite,     // number of bytes to write
  LPDWORD lpNumberOfBytesWritten,  // number of bytes written
  LPOVERLAPPED lpOverlapped        // overlapped buffer
){

    DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

    LONG Ret = RtlRandomEx(&g_Seed);
    if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
    {
        if (lpNumberOfBytesWritten)
            *lpNumberOfBytesWritten = 0;
        SetLastError(-1);        
        return FALSE;
    }    
    
    _asm{
        push lpOverlapped;
        push lpNumberOfBytesWritten;
        push nNumberOfBytesToWrite;
        push lpBuffer;
        push hFile;
        call Prolog__WriteFile;
        mov  bRet,eax
    }

    return bRet;
}


void
_declspec(naked) Prolog__CreateEvent(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist        
    }
}

HANDLE _I_CreateEvent(
  LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
  BOOL bManualReset,                       // reset type
  BOOL bInitialState,                      // initial state
  LPCWSTR lpName                           // object name
)
{
    DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    HANDLE hHandle;

    LONG Ret = RtlRandomEx(&g_Seed);
    if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
    {
        SetLastError(-1);        
        return NULL;
    }

    _asm{
        push lpName;
        push bInitialState;
        push bManualReset;
        push lpEventAttributes
        call Prolog__CreateEvent;
        mov  hHandle,eax
    }
    
    return hHandle;
}


void
_declspec(naked) Prolog__RtlFreeHeap(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
    }
}

#define SPACE_STACK_ALLOC (4*sizeof(ULONG_PTR))

DWORD _I_RtlFreeHeap(VOID * pHeap,DWORD Flags,VOID * pBlock)
{    
    ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
    Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);    
    DWORD dwRet;

    if (pBlock && !(HEAP_SLOW_FLAGS & Flags))
    {
        HEAP_ENTRY * pEntry = (HEAP_ENTRY *)pBlock-1;

              DWORD RealSize = pEntry->Size * sizeof(HEAP_ENTRY);
        DWORD Size = RealSize - pEntry->UnusedBytes;

        ULONG_PTR * pL = (ULONG_PTR *)pBlock;

        if (0 == (pEntry->Flags & 0x01) ||0xf0f0f0f0 == pL[1] )
        {
            if (!g_bDisableBreak)
                   DebugBreak();
        }

        DWORD CanMemset = RealSize-sizeof(HEAP_ENTRY);
        memset(pBlock,0xF0,(CanMemset > SPACE_STACK_ALLOC)?CanMemset-SPACE_STACK_ALLOC:CanMemset);
                
        if (pEntry->Size >=4)
        {            
            RtlCaptureStackBackTrace (1,
                                      (4 == pEntry->Size)?4:6,
                                      (PVOID *)(pEntry+2),
                                      pLong);        
        }

    }

    _asm {
        push pBlock              ;
        push Flags               ;
        push pHeap               ;
        call Prolog__RtlFreeHeap ;
        mov  dwRet,eax           ;
    }

    return dwRet;
}

void
_declspec(naked) Prolog__RtlAllocateHeap(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // to make this distinct
    }
}



VOID * _I_RtlAllocateHeap(VOID * pHeap,DWORD Flags,DWORD Size)
{
    
    ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
    Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);
    VOID * pRet;
    DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);

/*
       if (g_FaultHeapEnabled && g_NumFailInARow)
       {
           InterlockedDecrement(&g_NumFailInARow);
           goto here;
       }
*/       
       
    LONG Ret = RtlRandomEx(&g_Seed);
    if (g_FaultHeapEnabled && (Ret%g_Factor < g_Percent))
    {
//        g_NumFailInARow = g_RowOfFailures;
//here:        
//        InterlockedIncrement(&g_NumFailedAllocation);
        return NULL;
    }
    

    _asm {
        push NewSize                 ;
        push Flags                   ;
        push pHeap                   ;
        call Prolog__RtlAllocateHeap ;
        mov  pRet,eax                ;
    }

    
    if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
    {

       if (NewSize <= 0xffff)
               NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
        
        if (!(HEAP_ZERO_MEMORY & Flags))
        {    
            memset(pRet,0xc0,NewSize-sizeof(HEAP_ENTRY));
        }

        RtlCaptureStackBackTrace(1,
                                                 4,
                                                (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                                               pLong);
        
    }

    return pRet;
    
}

void
_declspec(naked) Prolog__RtlReAllocateHeap(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
        nop ; // dist        
        nop ; // dist            
    }
}


VOID *
_I_RtlReAllocateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD Flags,  // heap reallocation options
  LPVOID lpMem,   // pointer to memory to reallocate
  SIZE_T Size  // number of bytes to reallocate
){
    ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
    Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);
    VOID * pRet;

    DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);
    
    _asm {
        push NewSize                 ;
        push lpMem                   ;
        push Flags                 ;
        push pHeap                   ;
        call Prolog__RtlReAllocateHeap ;
        mov  pRet,eax                ;
    }

    if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
    {

       if (NewSize <= 0xffff)
               NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
        
        RtlCaptureStackBackTrace(1,
                                                 4,
                                                (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                                               pLong);
        
    }


       return pRet;
}

void
_declspec(naked) Prolog__RtlValidateHeap(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
        nop ; // dist        
        nop ; // dist            
        nop ; // dist            
    }
}

BOOL
_I_RtlValidateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD dwFlags,  // heap reallocation options
  LPVOID lpMem   // pointer to memory to validate
){
    ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
    BOOL bRet;

       g_bDisableBreak = TRUE;
    
    _asm {
        push lpMem                   ;
        push dwFlags                 ;
        push pHeap                   ;
        call Prolog__RtlValidateHeap ;
        mov  bRet,eax                ;
    }

       g_bDisableBreak = FALSE;

       return bRet;
}

#if 0
#define MAX_REMEMBER (1024) 

struct CSCCTrace
{
    VOID * p1;
    VOID * p2;
    DWORD Tid;
    ULONG_PTR Trace[5];
} g_CSCCTrace[MAX_REMEMBER];

LONG g_CSCCIndex = -1;

void
_declspec(naked) Prolog__CoSwitchCallContext(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
        nop ; // dist        
        nop ; // dist            
        nop ; // dist            
        nop ; // dist            
    }
}

HRESULT WINAPI
_I_CoSwitchCallContext(IUnknown * pNew,
                     IUnknown ** ppOld)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));

    long nIndex = InterlockedIncrement(&g_CSCCIndex);
    nIndex %= MAX_REMEMBER;
    CSCCTrace * pTrace = &g_CSCCTrace[nIndex];
    pTrace->p1 = pNew;
    if (ppOld)
        pTrace->p2 = *ppOld;
    else
        pTrace->p2 = 0;
    pTrace->Tid =GetCurrentThreadId();

    RtlCaptureStackBackTrace (1,5,(PVOID *)pTrace->Trace,pLong);    
    
    HRESULT hRes;
    _asm {
        push ppOld;        
        push pNew;
        call Prolog__CoSwitchCallContext;
        mov hRes,eax;
    };
    return hRes;
}
#endif


void
_declspec(naked) Prolog__MoveFileW(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
        nop ; // dist        
        nop ; // dist            
        nop ; // dist            
        nop ; // dist            
        nop ; // dist                    
    }
}

BOOL WINAPI
_I_MoveFileW(WCHAR * lpExistingFileName,
                     WCHAR * lpNewFileName)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));

    LONG Ret = RtlRandomEx(&g_Seed);
    if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
    {
        SetLastError(-1);
        return FALSE;
    }    
    
    BOOL bRet;
    
    HRESULT hRes;
    _asm {
        push lpNewFileName;        
        push lpExistingFileName;
        call Prolog__MoveFileW;
        mov bRet,eax;
    };
    return bRet;
}


void
_declspec(naked) Prolog__NtOpenThreadToken(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
        nop ; // dist        
        nop ; // dist            
        nop ; // dist            
        nop ; // dist            
        nop ; // dist                    
        nop ; // dist                            
    }
}

class TokenBackTrace
{
private:
	CStaticCritSec cs_;
	struct Trace
	{
	    DWORD Tid_;
	    PVOID StackTrace_[6];
	    Trace()
	    {
               ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));	    
               Tid_ = GetCurrentThreadId();
               RtlCaptureStackBackTrace (3,6,(PVOID *)StackTrace_,pLong); 
	    }
	};
	typedef std::map<HANDLE,Trace,std::less<HANDLE>, wbem_allocator<Trace> > HandleMap;
	HandleMap map_;
	DWORD TlsIndex_;
	
	struct SetUnsetTls
	{
	       DWORD Idx;
       	SetUnsetTls(TokenBackTrace & TBT)
		{
   		    Idx = TBT.TlsIndex_;
   		    LONG lVal = (LONG)TlsGetValue(Idx);
   		    lVal++;
		    TlsSetValue(Idx,(LPVOID)lVal);
		}
       	~SetUnsetTls()
		{
  		    LONG lVal = (LONG)TlsGetValue(Idx);
  		    lVal--;
		    TlsSetValue(Idx,(LPVOID)lVal);
		}       	
	};
public:
	TokenBackTrace()
	{
       	TlsIndex_ = TlsAlloc();
	};
	~TokenBackTrace()
	{
            TlsFree(TlsIndex_);
	}
	void Add(HANDLE hToken)
	{
           LONG * pLong = (LONG * )_alloca(sizeof(LONG ));

	    //DbgPrintfA(0,"A Tid %08x\n",GetCurrentThreadId());
	    
           SetUnsetTls Tls(*this);
	    CInCritSec ics(&cs_);
	    try
	    {
	        map_.insert(HandleMap::value_type(hToken,Trace()));
	    }
	    catch(CX_Exception &) { }; 
	}
	void Remove(HANDLE hToken)
	{
           SetUnsetTls Tls(*this);
           
	    LONG lVal = (LONG)TlsGetValue(TlsIndex_);
	    if (lVal > 1) return;
	    
	    //RTL_CRITICAL_SECTION * pcs = &cs_;
	    //DbgPrintfA(0,"R Tid %08x\n",GetCurrentThreadId());
	    //if (pcs->LockSemaphore && pcs->LockSemaphore == hToken) return;
	    
           CInCritSec ics(&cs_);
	    if (map_.empty()) return;
           HandleMap::iterator it = map_.find(hToken);
           if (map_.end() != it)
           {
               map_.erase(it);
           }
	}
	void Empty()
	{
           CInCritSec ics(&cs_);
           map_.clear();
	}
} g_TBT;

BOOL WINAPI
_I_NtOpenThreadToken(HANDLE hThread,
                                DWORD DesiredAccess,
                                BOOL bOpenAsSelf,
                                HANDLE * phToken)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));

    
    BOOL bRet;
    HANDLE hToken = NULL;
    HANDLE * phLocToken = &hToken;

    _asm {
      	 push phLocToken;
        push bOpenAsSelf;
        push DesiredAccess;
        push hThread;
        call Prolog__NtOpenThreadToken;
        mov bRet,eax;
    };

    if (phToken) *phToken = hToken;
    
    if (hToken)
    {
        g_TBT.Add(hToken);
    }
    return bRet;
}

void
_declspec(naked) Prolog__NtOpenProcessToken(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist        
    }
}


BOOL WINAPI
_I_NtOpenProcessToken (HANDLE ProcessHandle,
                                     DWORD DesiredAccess,
                                     HANDLE * pTokenHandle)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));

    BOOL bRet;
    HANDLE hToken = NULL;
    HANDLE * phLocToken = &hToken;

    _asm {
      	 push phLocToken;
        push DesiredAccess;
        push ProcessHandle;
        call Prolog__NtOpenProcessToken;
        mov bRet,eax;
    };

    if (pTokenHandle) *pTokenHandle = hToken;
    
    if (hToken)
    {
        g_TBT.Add(hToken);
    }
    return bRet;
}

void
_declspec(naked) Prolog__NtClose(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
    }
}

BOOL WINAPI
_I_NtClose(HANDLE hHandle)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));

    if (hHandle) g_TBT.Remove(hHandle);

    BOOL bRet;
    _asm {
        push hHandle;
        call Prolog__NtClose;
        mov bRet,eax;
    };
    return bRet;
}

void
_declspec(naked) Prolog__DuplicateTokenEx(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
        nop ; // dist        
    }
}

BOOL WINAPI
_I_DuplicateTokenEx(HANDLE hExistingToken, 
                               DWORD dwDesiredAccess, 
                               LPSECURITY_ATTRIBUTES lpTokenAttributes, 
                               SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, 
                               TOKEN_TYPE TokenType, 
                               PHANDLE phNewToken)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));

    BOOL bRet;
    HANDLE hToken = NULL;
    HANDLE * phLocToken = &hToken;

    _asm {
    	 push phLocToken;
    	 push TokenType;
    	 push ImpersonationLevel;
      	 push lpTokenAttributes;
        push dwDesiredAccess;
        push hExistingToken;
        call Prolog__DuplicateTokenEx;
        mov bRet,eax;
    };

    if (phNewToken) *phNewToken = hToken;
    
    if (hToken)
    {
        g_TBT.Add(hToken);
    }
    return bRet;
}

void
_declspec(naked) Prolog__DuplicateHandle(){
    _asm {
        // this is the space for the "saved istructions"
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;        
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        // this is the place for the JMP
        nop ;
        nop ;
        nop ;
        nop ;
        nop ;
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist
        nop ; // dist        
        nop ; // dist        
        nop ; // dist        
        nop ; // dist         
    }
}


BOOL WINAPI
_I_DuplicateHandle( HANDLE hSourceProcessHandle,
                              HANDLE hSourceHandle, 
                              HANDLE hTargetProcessHandle, 
                              LPHANDLE lpTargetHandle, 
                              DWORD dwDesiredAccess,
                              BOOL bInheritHandle,
                              DWORD dwOptions)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));

    BOOL bRet;
    HANDLE hToken = NULL;
    HANDLE * phLocToken = &hToken;

    _asm 
    {
        push dwOptions;
        push bInheritHandle;
        push dwDesiredAccess;
        push phLocToken;
        push hTargetProcessHandle;
        push hSourceHandle;
        push hSourceProcessHandle;
        call Prolog__DuplicateHandle;
        mov bRet,eax;
    };

    if (lpTargetHandle) *lpTargetHandle = hToken;
    
    if (hToken)
    {
        g_TBT.Add(hToken);
    }
    return bRet;
}

void intercept2(WCHAR * Module,
               LPSTR Function,
               VOID * NewRoutine,
               VOID * pPrologStorage,
               DWORD Size)    
{
    FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

    if (OldRoutine)
    {
        MEMORY_BASIC_INFORMATION MemBI;
        DWORD dwOldProtect;
        BOOL bRet, bRet2;
        DWORD dwRet;

        dwRet = VirtualQuery(OldRoutine,&MemBI,sizeof(MemBI));

        bRet = VirtualProtect(MemBI.BaseAddress,
                              MemBI.RegionSize,
                              PAGE_EXECUTE_WRITECOPY,
                              &dwOldProtect);

        dwRet = VirtualQuery(pPrologStorage,&MemBI,sizeof(MemBI));

        bRet2 = VirtualProtect(MemBI.BaseAddress,
                              MemBI.RegionSize,
                              PAGE_EXECUTE_WRITECOPY,
                              &dwOldProtect);

        if (bRet && bRet2)
        {
            VOID * pToJump = (VOID *)NewRoutine;
            BYTE Arr[SIZE_JUMP_ADR] = { 0xe9 };
            
            LONG * pOffset = (LONG *)&Arr[1];
            * pOffset = (LONG)NewRoutine - (LONG)OldRoutine - SIZE_JUMP_ADR ;        
            // save the old code
            
            memcpy(pPrologStorage,OldRoutine,Size);         
            // put the new code
            memset(OldRoutine,0x90,Size);
            memcpy(OldRoutine,Arr,SIZE_JUMP_ADR);
            // adjust the prolog to continue
            * pOffset = (LONG)OldRoutine + Size - (LONG)pPrologStorage - SIZE_SAVED_INSTR - SIZE_JUMP_ADR; // magic for nops
            memcpy((BYTE *)pPrologStorage+SIZE_SAVED_INSTR,Arr,SIZE_JUMP_ADR);
        }
    }
    else
    {
        OutputDebugStringA("GetProcAddress FAIL\n");
    }
}

void unintercept(WCHAR * Module,
                 LPSTR Function,
                 VOID * pPrologStorage,
                 DWORD Size)
{
    FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

    if (OldRoutine)
    {
        memcpy((void *)OldRoutine,pPrologStorage,Size);
    }

}

#endif /*_X86_*/

#ifndef STATUS_POSSIBLE_DEADLOCK
#define STATUS_POSSIBLE_DEADLOCK         (0xC0000194L)
#endif

class CSetVectoredHandler
{
private:
//    static ULONG_PTR Base;
//    static ULONG_PTR Limit;
    PVOID     pVectorHandler;
    enum ExceptionTypes
    {
        StatusAccessViolation,
        CXXException,
        StatusNoMemory,
        OtherExceptions,
        LastException
    };
    static LONG ExceptionCounters[LastException];
/*    
    BOOL GetDllLimits(WCHAR * pDllName)
    {
        UNICODE_STRING DllName;
        RtlInitUnicodeString(&DllName,pDllName);
        PEB_LDR_DATA * pLdr = NtCurrentPeb()->Ldr;
        LIST_ENTRY * pHeadEntry = &pLdr->InLoadOrderModuleList;
        LIST_ENTRY * pEntry = pLdr->InLoadOrderModuleList.Flink;
        BOOL bFound = FALSE;
        while (pHeadEntry != pEntry)
        {
            LDR_DATA_TABLE_ENTRY * pData = CONTAINING_RECORD(pEntry,
                                                               LDR_DATA_TABLE_ENTRY,
                                                               InLoadOrderLinks);
            if (0 == wbem_wcsicmp(DllName.Buffer,pData->BaseDllName.Buffer))
            {
                //OutputDebugStringA("found\n");
                Base = (ULONG_PTR)pData->DllBase;
                Limit = Base + (ULONG_PTR)pData->SizeOfImage;
                bFound = TRUE;
                break;
            }
            pEntry = pEntry->Flink;
        }
        return bFound;
    }
*/    
public:
    CSetVectoredHandler()
    {
        pVectorHandler = NULL;
        //if (GetDllLimits(L"fastprox.dll"))
        //{
            pVectorHandler = AddVectoredExceptionHandler(TRUE,CSetVectoredHandler::VectoredHandler);
        //}
    };
    ~CSetVectoredHandler()
    {
        if (pVectorHandler)
            RemoveVectoredExceptionHandler(pVectorHandler);
    };
    static LONG WINAPI VectoredHandler(PEXCEPTION_POINTERS ExceptionInfo)
    {        
        PEXCEPTION_RECORD pExr = ExceptionInfo->ExceptionRecord;
        PCONTEXT pCxr = ExceptionInfo->ContextRecord; 
        switch (pExr->ExceptionCode)
        {
        case STATUS_PRIVILEGED_INSTRUCTION:
        case STATUS_INVALID_HANDLE:
        case STATUS_STACK_OVERFLOW:
        case STATUS_POSSIBLE_DEADLOCK:               
        case STATUS_ACCESS_VIOLATION:
            InterlockedIncrement(&ExceptionCounters[(LONG)StatusAccessViolation]);
            DebugBreak();              
            break;
        case 0xe06d7363:
            InterlockedIncrement(&ExceptionCounters[(LONG)CXXException]);
            break;               
        case STATUS_NO_MEMORY:
            InterlockedIncrement(&ExceptionCounters[(LONG)StatusNoMemory]);
            break;         
        default:
            InterlockedIncrement(&ExceptionCounters[(LONG)OtherExceptions]);
            break;
        }
        return EXCEPTION_CONTINUE_SEARCH;
    }
} g_C;

LONG CSetVectoredHandler::ExceptionCounters[CSetVectoredHandler::LastException];

#endif


//
//
//  Run The Serivce
//
///////////////////////////////////////////////

void RunService(DWORD dwNumServicesArgs,
             LPWSTR *lpServiceArgVectors)
{
    MyService ThisService(SERVICE_ACCEPT_STOP|SERVICE_ACCEPT_SHUTDOWN|SERVICE_ACCEPT_PAUSE_CONTINUE);
    
    ThisService.Run(SERVICE_NAME,
                    dwNumServicesArgs,
                    lpServiceArgVectors,
                    (void *)&ThisService);

}

//
//
//  ServiceMain
//
///////////////////////////////////////////////////////////

VOID WINAPI
 ServiceMain(DWORD dwNumServicesArgs,
             LPWSTR *lpServiceArgVectors)
{

#ifdef INSTRUMENTED_BUILD
#ifdef _X86_
    intercept2(L"ntdll.dll","RtlFreeHeap",_I_RtlFreeHeap,Prolog__RtlFreeHeap,5);
    intercept2(L"ntdll.dll","RtlAllocateHeap",_I_RtlAllocateHeap,Prolog__RtlAllocateHeap,5);
    intercept2(L"ntdll.dll","RtlReAllocateHeap",_I_RtlReAllocateHeap,Prolog__RtlReAllocateHeap,5);    
    intercept2(L"ntdll.dll","RtlValidateHeap",_I_RtlValidateHeap,Prolog__RtlValidateHeap,7);
    intercept2(L"kernel32.dll","CreateEventW",_I_CreateEvent,Prolog__CreateEvent,6);    
    intercept2(L"kernel32.dll","WriteFile",_I_WriteFile,Prolog__WriteFile,7);
    intercept2(L"kernel32.dll","ReadFile",_I_ReadFile,Prolog__ReadFile,7);
    intercept2(L"kernel32.dll","MoveFileW",_I_MoveFileW,Prolog__MoveFileW,6);
    /*
    intercept2(L"ntdll.dll","NtClose",_I_NtClose,Prolog__NtClose,5);
    intercept2(L"ntdll.dll","NtOpenThreadToken",_I_NtOpenThreadToken,Prolog__NtOpenThreadToken,5);    
    intercept2(L"ntdll.dll","NtOpenProcessToken",_I_NtOpenProcessToken,Prolog__NtOpenProcessToken,5);    
    intercept2(L"advapi32.dll","DuplicateTokenEx",_I_DuplicateTokenEx,Prolog__DuplicateTokenEx,6);
    intercept2(L"kernel32.dll","DuplicateHandle",_I_DuplicateHandle,Prolog__DuplicateHandle,7);    
    */
    g_nSuccConn = 0;
#endif /*_X86_*/
#endif

    RegSetDWORD(HKEY_LOCAL_MACHINE,
                 HOME_REG_PATH,
                 TEXT("ProcessID"),
                 GetCurrentProcessId());

#ifdef DBG
    if (InitialBreak())
    {
        DebugBreak();
    }
#endif

    g_ProgRes.Init();
    g_ProgRes.Phase1Build();

    RunService(dwNumServicesArgs,lpServiceArgVectors);

#ifdef INSTRUMENTED_BUILD
#ifdef _X86_

    unintercept(L"ntdll.dll","RtlFreeHeap",Prolog__RtlFreeHeap,5);    
    unintercept(L"ntdll.dll","RtlAllocateHeap",Prolog__RtlAllocateHeap,5);
    unintercept(L"ntdll.dll","RtlReAllocateHeap",Prolog__RtlReAllocateHeap,5);    
    unintercept(L"ntdll.dll","RtlValidateHeap",Prolog__RtlValidateHeap,7);    
    unintercept(L"kernel32.dll","CreateEventW",Prolog__CreateEvent,6);
    unintercept(L"kernel32.dll","WriteFile",Prolog__WriteFile,7);
    unintercept(L"kernel32.dll","ReadFile",Prolog__ReadFile,7);
    unintercept(L"kernel32.dll","MoveFileW",Prolog__MoveFileW,6);      
/*
    unintercept(L"ntdll.dll","NtOpenThreadToken",Prolog__NtOpenThreadToken,5);    
    unintercept(L"ntdll.dll","NtOpenProcessToken",Prolog__NtOpenProcessToken,5);    
    unintercept(L"ntdll.dll","NtClose",Prolog__NtClose,5);            
    unintercept(L"advapi32.dll","DuplicateTokenEx",Prolog__DuplicateTokenEx,6);    
    unintercept(L"kernel32.dll","DuplicateHandle",Prolog__DuplicateHandle,7);    
*/    
#endif /*_X86_*/
#endif
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\wbemdelta.h ===
#ifndef __WBEMDELTA_H__
#define __WBEMDELTA_H__

#include "precomp.h"
#include <reg.h>
#include <stdio.h>

#define SVC_KEY TEXT("System\\CurrentControlSet\\Services")
#define KNOWN_SERVICES TEXT("KnownSvcs")

#define WBEM_REG_ADAP		__TEXT("Software\\Microsoft\\WBEM\\CIMOM\\ADAP")

#define WBEM_NORESYNCPERF	__TEXT("NoResyncPerf")
#define WBEM_NOSHELL		__TEXT("NoShell")
#define WBEM_WMISETUP		__TEXT("WMISetup")
#define WBEM_ADAPEXTDLL		__TEXT("ADAPExtDll")


//
// version of the function without the actual delta dredge
//
/////////////////////////////////////////////////////////////

DWORD WINAPI
DeltaDredge2(DWORD dwNumServicesArgs,
             LPWSTR *lpServiceArgVectors);


#endif /*__WBEMDELTA_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\winmgmt.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    winmgmt.h

Abstract:

    defines constant useful for the entire project

--*/

#ifndef __WINMGT_H__
#define __WINMGT_H__

#include <cntserv.h>
#include <reg.h>
#include <stdio.h>

#include "resync2.h"
#include "writer.h"

#include <stdio.h>
#include <helper.h>
#include <flexarry.h>

#define SERVICE_NAME TEXT("winmgmt")

#define HOME_REG_PATH TEXT("Software\\Microsoft\\WBEM\\CIMOM")
#define INITIAL_BREAK TEXT("Break")

#define WBEM_REG_ADAP           __TEXT("Software\\Microsoft\\WBEM\\CIMOM\\ADAP")
#define WBEM_REG_REVERSE_KEY   __TEXT("SOFTWARE\\Microsoft\\WBEM\\PROVIDERS\\Performance")
#define WBEM_REG_REVERSE_VALUE __TEXT("Performance Refresh")

#define WBEM_NORESYNCPERF    __TEXT("NoResyncPerf")
#define WBEM_NOSHELL        __TEXT("NoShell")
#define WBEM_WMISETUP        __TEXT("WMISetup")
#define WBEM_ADAPEXTDLL        __TEXT("ADAPExtDll")


#define DO_THROTTLE        __TEXT("ThrottleDrege")

//
// For Fast ShutDown
// 
///////////////////////////////////////

#define SERVICE_SHUTDOWN 0x80000000 

//  prototype for reg code

DWORD RegSetDWORD(HKEY hKey,
                    TCHAR * pName,
                    TCHAR * pValue,
                    DWORD dwValue);

DWORD RegGetDWORD(HKEY hKey,
                    TCHAR * pName,
                    TCHAR * pValue,
                    DWORD * pdwValue);

//
//
//  prototype for the wbemcore!ShutDown function
//
//////////////////////////////////

typedef HRESULT (STDAPICALLTYPE *pfnShutDown)(DWORD,DWORD);

//
// The DeltaDredge Function (implementing the Pre-Delta) will return
//
///////////////////////////////////

#define FULL_DREDGE    2
#define PARTIAL_DREDGE 1
#define NO_DREDGE      0

//
//
/////////////////////////////////////

#define   WMIADAP_DEFAULT_DELAY          240   // 4 minutes
#define   WMIADAP_DEFAULT_DELAY_LODCTR   60    // 1 minute

#define   WMIADAP_DEFAULT_TIMETOFULL     ((DWORD)-1)

#define ADAP_TIMESTAMP_FULL         TEXT("LastFullDredgeTimestamp")
#define ADAP_TIME_TO_FULL             TEXT("TimeToFullDredge")
#define ADAP_TIME_TO_KILL_ADAP   TEXT("TimeToTerminateAdap")

//
// _PROG_RESOURCES
//
// Holds various resource that need to be freed at the end of execution.
//
//////////////////////////////////////////////////////////////////

struct _PROG_RESOURCES
{
    BOOL            m_bOleInitialized;

    IClassFactory*  m_pLoginFactory;
    IClassFactory*  m_pBackupFactory;
    DWORD           m_dwLoginClsFacReg;
    DWORD           m_dwBackupClsFacReg;

    //-----------
    BOOL g_fSetup;
    BOOL g_fDoResync;

    HANDLE hMainMutex;
    BOOL   bShuttingDownWinMgmt;
    BOOL gbCoreLoaded;

    HANDLE ghCoreCanUnload;
    HANDLE ghProviderCanUnload;
    HANDLE ghMofDirChange;

    TCHAR * szHotMofDirectory;

    CMonitorEvents m_Monitor;

    DWORD ServiceStatus;

    CWbemVssWriter* pWbemVssWriter;
    bool bWbemVssWriterSubscribed;
    DWORD dwWaitThreadID;
        

//------------------------------

    void Init();
    BOOL Phase1Build();
    BOOL Phase2Build(HANDLE hTerminate);

    BOOL RegisterLogin();
    BOOL RevokeLogin();
    BOOL RegisterBackup();
    BOOL RevokeBackup();
    
    BOOL Phase1Delete(BOOL bIsSystemShutDown);
    BOOL Phase2Delete(BOOL bIsSystemShutdown);
    BOOL Phase3Delete();
    
};


extern struct _PROG_RESOURCES g_ProgRes;
extern HINSTANCE g_hInstance;

inline
BOOL GLOB_Monitor_IsRegistred()
{
    BOOL bRet;
    g_ProgRes.m_Monitor.Lock();
    bRet = g_ProgRes.m_Monitor.IsRegistred();
    g_ProgRes.m_Monitor.Unlock();    
    return bRet;
};

inline 
CMonitorEvents * GLOB_GetMonitor()
{
    return &g_ProgRes.m_Monitor;
}

//
// Adap might be disallowed because of Setup running
// or because of a registry setting
//
/////////////////////////////////////////////////////
inline 
BOOL GLOB_IsResyncAllowed()
{
    return (g_ProgRes.g_fDoResync && !g_ProgRes.g_fSetup);
}


//
//
//  functions exported from mofdutil.cpp
//
//////////////////////////////////////////////////////////////////

BOOL InitHotMofStuff( IN OUT struct _PROG_RESOURCES * pProgRes);
void LoadMofsInDirectory(const TCHAR *szDirectory);

BOOL CheckSetupSwitch( void );
void SetNoShellADAPSwitch( void );
BOOL CheckNoResyncSwitch( void );

void AddToAutoRecoverList(TCHAR * pFileName);
BOOL IsValidMulti(TCHAR * pMultStr, DWORD dwSize);
BOOL IsStringPresent(TCHAR * pTest, TCHAR * pMultStr);

//
//
// yet an other class factory
//
///////////////////////////////////////////////////////////////////

class CForwardFactory : public IClassFactory
{
protected:
    long m_lRef;
    CLSID m_ForwardClsid;

public:
    CForwardFactory(REFCLSID rForwardClsid) 
        : m_lRef(1), m_ForwardClsid(rForwardClsid)
    {}
    ~CForwardFactory();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown* pUnkOuter, 
                                REFIID riid, void** ppv);
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);
};

//
//
// MyService 
//
//
//////////////////////////////////////////////////////////////////

class MyService : public CNtService
{
public:
    MyService(DWORD CtrlAccepted);
    ~MyService();
    
    // CNtService interface
    DWORD WorkerThread();
    void Stop(BOOL bSystemShutDownCalled);
    void Log(LPCSTR lpszMsg);

    VOID Pause();
    VOID Continue();

    //
    VOID FinalCleanup();
private:

    HANDLE m_hStopEvent;
};

//
//
//  yet another smart mutex
//
//
//////////////////////////////////////////////////////////////////

class CInMutex
{
protected:
    HANDLE m_hMutex;
public:
    CInMutex(HANDLE hMutex) : m_hMutex(hMutex)
    {
        if(m_hMutex)
            WaitForSingleObject(m_hMutex, INFINITE);
    }
    ~CInMutex()
    {
        if(m_hMutex)
            ReleaseMutex(m_hMutex);
    }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\wbemdelta.cpp ===
#include "precomp.h"
#include "arrtempl.h" // for CDeleteMe
#include "md5wbem.h"  // for MD5

#include "winmgmt.h"
#include "wbemdelta.h"

DWORD WINAPI
DeltaDredge2(DWORD dwNumServicesArgs,
             LPWSTR *lpServiceArgVectors)
{
    
    DWORD bDredge = FULL_DREDGE;

    // check the MULTI_SZ key
    LONG lRet;
    HKEY hKey;
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        WBEM_REG_WINMGMT,
                        NULL,
                        KEY_READ,
                        &hKey);
                        
    if (ERROR_SUCCESS == lRet)
    {
        OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm(hKey);
            
        DWORD dwSize = 0;
        DWORD dwType;
        lRet = RegQueryValueEx(hKey,
                               KNOWN_SERVICES,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize);
                               
        if (ERROR_SUCCESS == lRet && REG_MULTI_SZ == dwType  && (dwSize > 2)) // empty MULTI_SZ is 2 bytes
        {
            bDredge = NO_DREDGE;
        }
    }

    return bDredge;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\writer.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

	writer.h

Abstract:

	Volume SnapShot Writer for WMI

History:

	a-shawnb	06-Nov-00	Genesis

--*/

#ifndef _WBEM_WRITER_H_
#define _WBEM_WRITER_H_

#include "precomp.h"
#include "vss.h"
#include "vswriter.h"
#include <sync.h>

class CWbemVssWriter : public CVssWriter
	{
public:
	CWbemVssWriter();
	~CWbemVssWriter();

	HRESULT Initialize();

	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	virtual bool STDMETHODCALLTYPE OnFreeze();

	virtual bool STDMETHODCALLTYPE OnThaw();

	virtual bool STDMETHODCALLTYPE OnAbort();

private:
    IWbemBackupRestoreEx* m_pBackupRestore;
    CCritSec m_Lock;
    HRESULT STDMETHODCALLTYPE LogFailure(HRESULT hr);
    HRESULT m_hResFailure;
    LONG m_FailurePos;
};
	
#endif // _WBEM_WRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\winmgmt2\writer.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    writer.cpp

Abstract:

    Volume SnapShot Writer for WMI

History:

    a-shawnb    06-Nov-00    Created

--*/

#include "precomp.h"
#include "writer.h"
#include <genutils.h> // for EnableAllPrivileges()
#include <malloc.h>
#include <stdio.h>
#include <helper.h>

CWbemVssWriter::CWbemVssWriter() : CVssWriter(), 
                                 m_pBackupRestore(NULL),
                                 m_hResFailure(S_OK),
                                 m_FailurePos(-1)
{
}

CWbemVssWriter::~CWbemVssWriter()
{
    if (m_pBackupRestore)
    {
        m_pBackupRestore->Resume();
        m_pBackupRestore->Release();
        m_pBackupRestore = NULL;
    }
}

HRESULT STDMETHODCALLTYPE
CWbemVssWriter::LogFailure(HRESULT hr)
{
#ifdef DBG
    ERRORTRACE((LOG_WINMGMT,"CWbemVssWriter experienced failure %08x at position %d\n",m_hResFailure,m_FailurePos));
#else
    DEBUGTRACE((LOG_WINMGMT,"CWbemVssWriter experienced failure %08x at position %d\n",m_hResFailure,m_FailurePos));
#endif
    return CVssWriter::SetWriterFailure(hr);
}

// {A6AD56C2-B509-4e6c-BB19-49D8F43532F0}
static VSS_ID s_WRITERID = {0xa6ad56c2, 0xb509, 0x4e6c, 0xbb, 0x19, 0x49, 0xd8, 0xf4, 0x35, 0x32, 0xf0};
static LPCWSTR s_WRITERNAME = L"WMI Writer";

HRESULT CWbemVssWriter::Initialize()
{
    return CVssWriter::Initialize(s_WRITERID, s_WRITERNAME, VSS_UT_SYSTEMSERVICE, VSS_ST_OTHER);
}

extern HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);

#define IF_FAILED_RETURN_FALSE( _hr_ ) \
    if (FAILED(_hr_)) { m_hResFailure = _hr_; m_FailurePos = __LINE__; return false; }

bool STDMETHODCALLTYPE CWbemVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
{
    OnDeleteObjIf<HRESULT,
                 CWbemVssWriter,
                 HRESULT(STDMETHODCALLTYPE CWbemVssWriter::*)(HRESULT),
                 &CWbemVssWriter::LogFailure> CallMe(this,VSS_E_WRITERERROR_RETRYABLE);

    wchar_t wszRepositoryDirectory[MAX_PATH+1];
    HRESULT hr = GetRepositoryDirectory(wszRepositoryDirectory);
    IF_FAILED_RETURN_FALSE(hr);

    hr = pMetadata->AddComponent(    VSS_CT_FILEGROUP,
                                    NULL,
                                    L"WMI",
                                    L"Windows Managment Instrumentation",
                                    NULL,
                                    0, 
                                    false,
                                    false,
                                    false);
    IF_FAILED_RETURN_FALSE(hr);    

    hr = pMetadata->AddFilesToFileGroup(NULL,
                                    L"WMI",
                                    wszRepositoryDirectory,
                                    L"*.*",
                                    true,
                                    NULL);
    IF_FAILED_RETURN_FALSE(hr);    

    hr = pMetadata->SetRestoreMethod(VSS_RME_RESTORE_AT_REBOOT,
                                    NULL,
                                    NULL,
                                    VSS_WRE_NEVER,
                                    true);
    IF_FAILED_RETURN_FALSE(hr);
    
    CallMe.dismiss(); // if returning true, do not set a failure
    return true;
}

bool STDMETHODCALLTYPE CWbemVssWriter::OnPrepareSnapshot()
{
    return true;
}

//
// to debug Volume Snapshot failure in IOStress we introduced 
// some self instrumentation that did relay on RtlCaptureStackBacktrace
// that function works only if there is a proper stack frame
// the general trick to force stack frames on i386 is the usage of _alloca
//
//#ifdef _X86_
//    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
//#endif

// enable generation of stack frames here
#pragma optimize( "y", off )

//
//  Doing the Job on this method, we will have a time-out guarantee
//  We sync the OnFreeze and the OnAbort/OnThaw calls,
//  so that, if a TimeOut occurs, we are not arbitrarly unlocking the repository
//
///////////////////////////////////////////////////////////////

bool STDMETHODCALLTYPE CWbemVssWriter::OnFreeze()
{
    OnDeleteObjIf<HRESULT,
                 CWbemVssWriter,
                 HRESULT(STDMETHODCALLTYPE CWbemVssWriter::*)(HRESULT),
                 &CWbemVssWriter::LogFailure> CallMe(this,VSS_E_WRITERERROR_RETRYABLE);

    CInCritSec ics(&m_Lock);
    
    // m_pBackupRestore should always be NULL coming into this
    if (m_pBackupRestore)
    {
        m_hResFailure = E_UNEXPECTED;
        m_FailurePos = __LINE__;    
        return false;
    }

    HRESULT hr = CoCreateInstance(CLSID_WbemBackupRestore, 0, CLSCTX_INPROC_SERVER,
                                IID_IWbemBackupRestoreEx, (LPVOID *) &m_pBackupRestore);

    IF_FAILED_RETURN_FALSE(hr);
    
    hr = EnableAllPrivileges(TOKEN_PROCESS);

    IF_FAILED_RETURN_FALSE(hr);
        
    hr = m_pBackupRestore->Pause();
    if (FAILED(hr))
    {
        m_pBackupRestore->Release();
        m_pBackupRestore = NULL;
        m_hResFailure = hr;
        m_FailurePos = __LINE__;
        return false;
    }
     
    CallMe.dismiss(); // if returning true, do not set a failure
    return true;    
}

bool STDMETHODCALLTYPE CWbemVssWriter::OnThaw()
{
    OnDeleteObjIf<HRESULT,
                 CWbemVssWriter,
                 HRESULT(STDMETHODCALLTYPE CWbemVssWriter::*)(HRESULT),
                 &CWbemVssWriter::LogFailure> CallMe(this,VSS_E_WRITERERROR_RETRYABLE);

    CInCritSec ics(&m_Lock);
    
    if (!m_pBackupRestore)
    {
        m_hResFailure = E_UNEXPECTED;
        m_FailurePos = __LINE__;    
        // if m_pBackupRestore is NULL, then we haven't been
        // asked to prepare or we failed our preparation
        return false;
    }

    HRESULT hr = m_pBackupRestore->Resume();
    if (FAILED(hr))
    {
        m_hResFailure = hr;
        m_FailurePos = __LINE__;    
    }
    m_pBackupRestore->Release();
    m_pBackupRestore = NULL;

    bool bRet = SUCCEEDED(hr);
    CallMe.dismiss(bRet); // if returning true, do not set a failure
    return bRet;        
}

bool STDMETHODCALLTYPE CWbemVssWriter::OnAbort()
{
    OnDeleteObjIf<HRESULT,
                 CWbemVssWriter,
                 HRESULT(STDMETHODCALLTYPE CWbemVssWriter::*)(HRESULT),
                 &CWbemVssWriter::LogFailure> CallMe(this,VSS_E_WRITERERROR_RETRYABLE);

    CInCritSec ics(&m_Lock);
    
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_pBackupRestore)
    {
        hr = m_pBackupRestore->Resume();
        if (FAILED(hr))
        {
            m_hResFailure = hr;
            m_FailurePos = __LINE__;            
        }
        m_pBackupRestore->Release();
        m_pBackupRestore = NULL;
    }

    bool bRet = SUCCEEDED(hr);
    CallMe.dismiss(bRet); // if returning true, do not set a failure
    return bRet;    
}

#pragma optimize( "", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\cache.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


///////////////////////////////////////////////////////////////////////////////
//
//    Cache.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <winperf.h>
#include <comdef.h>
#include <algorithm>
#include <wbemint.h>
#include <sync.h>     // for CInCritSec
#include <autoptr.h>

#include "Cache.h"
#include "WMIObjCooker.h"
#include "CookerUtils.h"


///////////////////////////////////////////////////////////////////////////////
//
//    CProperty
//    =========
//
//    The base property - used for raw properties and the base 
//    class for the CookedProperty.
//
///////////////////////////////////////////////////////////////////////////////

CProperty::CProperty(LPWSTR wszName, 
                                 long lHandle, CIMTYPE ct ) :
#ifdef _VERBOSE                                 
  m_wszName( NULL ),
#endif  
  m_lPropHandle( lHandle ),
  m_ct( ct )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//    Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
#ifdef _VERBOSE    
    size_t length = wcslen( wszName ) + 1;
    m_wszName = new WCHAR[ length  ];
    if (m_wszName)
        StringCchCopyW( m_wszName, length , wszName);
#endif    
}

CProperty::~CProperty()
{
#ifdef _VERBOSE    
    delete [] m_wszName;
#endif
}

#ifdef _VERBOSE
LPWSTR CProperty::GetName()
{
    return m_wszName?m_wszName:L"";
}
#endif

CIMTYPE CProperty::GetType()
{ 
    return m_ct; 
}

long CProperty::GetHandle()
{
    return m_lPropHandle;
}

///////////////////////////////////////////////////////////////////////////////
//
//    CCookingProperty
//    ================
//
//    The cooked property - used to model the data required to
//    cook a property of a cooked class
//
///////////////////////////////////////////////////////////////////////////////

CCookingProperty::CCookingProperty( LPWSTR wszName, 
                                    DWORD dwCounterType, 
                                    long lPropHandle, 
                                    CIMTYPE ct, 
                                    DWORD dwReqProp,
                                    BOOL bUseWellKnownIfNeeded) : 
  CProperty( wszName, lPropHandle, ct ),
  m_dwCounterType( dwCounterType ),
  m_dwReqProp(dwReqProp),
  m_nTimeFreq( 0 ),
  m_lScale(0),                 // 10^0 = 1
  m_pRawCounterProp( NULL ),
  m_pTimeProp( NULL ),
  m_pFrequencyProp( NULL ),
  m_pBaseProp( NULL ),
  m_nSampleWindow( 0 ),
  m_nTimeWindow( 0 ),
  m_bUseWellKnownIfNeeded(bUseWellKnownIfNeeded)
///////////////////////////////////////////////////////////////////////////////
//
//    Constructor
//
//    Parameters:
//        wszName            - The property name
//        dwCounterType    - The property's counter type
//        lPropHandle        - The cooking property's WMI Access handle
//        ct                - The CIM type of the property
//
///////////////////////////////////////////////////////////////////////////////
{}

CCookingProperty::~CCookingProperty()
{
    delete m_pRawCounterProp;        
    delete m_pTimeProp;
    delete m_pFrequencyProp;
    delete m_pBaseProp;
}


//
//
//
//    Parameters:
//        pCookingClassAccess    - The class definition for the cooking class
//
//    Description:
//        For each property of the class to be cooked
//        we need to find the property of the Raw class needed in the formula
//        The 'Counter' qualifier is always needed,
//        but thereafter we might need the timestap, the base, the frequency, ecc, ecc
//        SOme of these are in the PropertyQualifierSet, but other can be defaulted in the
//        ClassQualifierSet
//
///////////////////////////////////////////////////////////////////////////////
WMISTATUS CCookingProperty::Initialize( IWbemQualifierSet* pCookingPropQualifierSet, 
                                        IWbemObjectAccess* pRawAccess,
                                        IWbemQualifierSet* pCookingClassQSet)
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    _variant_t    vVal;

    // Initialize the raw counter property ("Counter")
    // ===============================================
    dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_RAW_COUNTER, 0, &vVal, NULL );

    if ( SUCCEEDED( dwStatus ) && ( vVal.vt != VT_BSTR ) )
    {
        dwStatus = E_FAIL;
    }

    if ( SUCCEEDED( dwStatus ) )
    {
        // Get the raw data properties
        // ===========================

        CIMTYPE    ct;
        
        long    lHandle = 0;
        WCHAR*    wszRawCounterName = vVal.bstrVal;

        // Get the raw counter property
        // ============================

        dwStatus = pRawAccess->GetPropertyHandle( wszRawCounterName, &ct, &lHandle );

        if ( SUCCEEDED( dwStatus ) )
        {
            m_pRawCounterProp = new CProperty( wszRawCounterName, lHandle, ct );

            if ( NULL == m_pRawCounterProp )
            {
                dwStatus = WBEM_E_OUT_OF_MEMORY;
            }
        }

        // Get the raw base property
        // =========================

        if ( SUCCEEDED( dwStatus ) )
        {
            _variant_t    vProp;
            dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_RAW_BASE, 0, &vProp, NULL );

            if ( SUCCEEDED( dwStatus ) )
            {            
                if ( vProp.vt == VT_BSTR )
                {
                    dwStatus = pRawAccess->GetPropertyHandle( vProp.bstrVal, &ct, &lHandle );

                    if ( SUCCEEDED( dwStatus ) )
                    {
                        m_pBaseProp = new CProperty( vProp.bstrVal, lHandle, ct );

                        if ( NULL == m_pBaseProp )
                        {
                            dwStatus = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                }
                else
                {
                    dwStatus = WBEM_E_TYPE_MISMATCH;
                }
            }
            else
            {
                // the property qualifier set failed, try the class one
                _variant_t varProp; // does not throw, simple container
                dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_BASE, 0, &varProp, NULL );
                
                if ( SUCCEEDED( dwStatus ) )
                {            
                    if ( varProp.vt == VT_BSTR )
                    {
                        dwStatus = pRawAccess->GetPropertyHandle( varProp.bstrVal, &ct, &lHandle );

                        if ( SUCCEEDED( dwStatus ) )
                        {
                            m_pBaseProp = new CProperty( varProp.bstrVal, lHandle, ct );

                            if ( NULL == m_pBaseProp )
                            {
                                dwStatus = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                    }
                    else
                    {
                        dwStatus = WBEM_E_TYPE_MISMATCH;
                    }
                }
                else
                {
                    dwStatus = WBEM_NO_ERROR;
                }
            }
            //
            // no error so far, the BASE qulifier is REQUIRED, but none is found
            //
            if ( SUCCEEDED( dwStatus ) && 
                 IsReq(REQ_BASE) && 
                 (NULL == m_pBaseProp))
            {
                dwStatus = WBEM_E_INVALID_CLASS;
            }
        } 

        // Get the raw timestamp property record
        // =====================================

        if ( SUCCEEDED( dwStatus ) )
        {
            _variant_t vProp2;
            dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_RAW_TIME, 0, &vProp2, NULL );

            if ( SUCCEEDED( dwStatus ) )
            {
                if ( vProp2.vt == VT_BSTR )
                {
                    dwStatus = pRawAccess->GetPropertyHandle( vProp2.bstrVal, &ct, &lHandle );

                    if ( SUCCEEDED( dwStatus ) )
                    {
                        m_pTimeProp = new CProperty( vProp2.bstrVal, lHandle, ct );

                        if ( NULL == m_pTimeProp )
                        {
                            dwStatus = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                }
                else
                {
                    dwStatus = WBEM_E_TYPE_MISMATCH;
                }
            }
            else
            {

                // the property qualifier set failed, try the class one
                
                //PERF_TIMER_TICK 
                //PERF_TIMER_100NS  
                //PERF_OBJECT_TIMER
                
                _variant_t varProp; // does not throw, simple container
                if (m_dwCounterType & PERF_OBJECT_TIMER)
                {
                    dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_TIME_OBJ, 0, &varProp, NULL );
                    if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
                    {
                        dwStatus = WBEM_NO_ERROR;
                        varProp = WMI_COOKER_REQ_TIMESTAMP_PERFTIME;
                    }
                } 
                else if (m_dwCounterType & PERF_TIMER_100NS)
                {
                    dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_TIME_100NS, 0, &varProp, NULL );
                    if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
                    {
                        dwStatus = WBEM_NO_ERROR;
                        varProp = WMI_COOKER_REQ_TIMESTAMP_SYS100NS;
                    }                    
                } else 
                {
                    dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_TIME_SYS, 0, &varProp, NULL );
                    if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
                    {
                        dwStatus = WBEM_NO_ERROR;
                        varProp = WMI_COOKER_REQ_TIMESTAMP_OBJECT;
                    }                    
                }
                
                if ( SUCCEEDED( dwStatus ) )
                {            
                    if ( varProp.vt == VT_BSTR )
                    {
                        dwStatus = pRawAccess->GetPropertyHandle( varProp.bstrVal, &ct, &lHandle );

                        if ( SUCCEEDED( dwStatus ) )
                        {
                            m_pTimeProp = new CProperty( varProp.bstrVal, lHandle, ct );

                            if ( NULL == m_pTimeProp )
                            {
                                dwStatus = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                    }
                    else
                    {
                        dwStatus = WBEM_E_TYPE_MISMATCH;
                    }
                }
                else
                {
                    dwStatus = WBEM_NO_ERROR;
                }
            }

            // get in cascade the frequency property
            if (SUCCEEDED(dwStatus))
            {
                _variant_t VarFreqName; // simple container, does not throw
                dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_RAW_FREQUENCY, 0, &VarFreqName, NULL );
                                
                if (SUCCEEDED(dwStatus))
                { 
                    if (VarFreqName.vt == VT_BSTR)
                    {                    
                        dwStatus = pRawAccess->GetPropertyHandle( VarFreqName.bstrVal, &ct, &lHandle );
                    
                        if (SUCCEEDED(dwStatus))
                        {
                            m_pFrequencyProp = new CProperty( VarFreqName.bstrVal, lHandle, ct );

                            if ( NULL == m_pFrequencyProp )
                            {
                                dwStatus = WBEM_E_OUT_OF_MEMORY;
                            }                    
                        }

                    } else {
                        dwStatus = WBEM_E_TYPE_MISMATCH;
                    }
                } 
                else 
                {
                    if (m_dwCounterType & PERF_OBJECT_TIMER)
                    {
                        dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_FREQ_OBJ, 0, &VarFreqName, NULL );
                        if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
                        {
                            dwStatus = WBEM_NO_ERROR;
                            VarFreqName = WMI_COOKER_REQ_FREQUENCY_PERFTIME;
                        }                        
                    } 
                    else if (m_dwCounterType & PERF_TIMER_100NS)
                    {
                        dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_FREQ_100NS, 0, &VarFreqName, NULL );
                        if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
                        {
                            dwStatus = WBEM_NO_ERROR;
                            VarFreqName = WMI_COOKER_REQ_FREQUENCY_SYS100NS;
                        }                        
                    } else 
                    {
                        dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_FREQ_SYS, 0, &VarFreqName, NULL );
                        if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
                        {
                            dwStatus = WBEM_NO_ERROR;
                            VarFreqName = WMI_COOKER_REQ_FREQUENCY_OBJECT;
                        }                        
                    }

                    
                    if (SUCCEEDED(dwStatus))
                    { 
                        if (VarFreqName.vt == VT_BSTR)
                        {
                            dwStatus = pRawAccess->GetPropertyHandle( VarFreqName.bstrVal, &ct, &lHandle );
                        
                            if (SUCCEEDED(dwStatus))
                            {
                                m_pFrequencyProp = new CProperty( VarFreqName.bstrVal, lHandle, ct );

                                if ( NULL == m_pFrequencyProp )
                                {
                                    dwStatus = WBEM_E_OUT_OF_MEMORY;
                                }                    
                            }

                        } else {
                            dwStatus = WBEM_E_TYPE_MISMATCH;
                        }
                    } else {
                        dwStatus = WBEM_S_NO_ERROR;
                    }
                }
            }
        }

        //
        //  Get the Scale factor from ONLY the property Qualifier
        //
        if ( SUCCEEDED( dwStatus ) )
        {
            _variant_t VarScale; // does not throw, simple container
            dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_SCALE_FACT, 0, &VarScale, NULL );

            if ( SUCCEEDED( dwStatus ) && (V_VT(&VarScale) == VT_I4))             
            {
                m_lScale = VarScale.intVal;                
            }
            else 
            {
                dwStatus = WBEM_S_NO_ERROR;
            }
        }


        // Get the Sample and Time windows value
        // =====================================

        if ( SUCCEEDED( dwStatus ) )
        {
            DWORD    dwSampleStatus = WBEM_NO_ERROR,
                    dwTimeStatus = WBEM_NO_ERROR;

            _variant_t    vSampleProp; // does not throw, simple container
            _variant_t    vTimeProp;   // does not throw, simple container

            dwSampleStatus = pCookingPropQualifierSet->Get( WMI_COOKER_SAMPLE_WINDOW, 0, &vSampleProp, NULL );
            dwTimeStatus = pCookingPropQualifierSet->Get( WMI_COOKER_TIME_WINDOW, 0, &vTimeProp, NULL );


            if ( SUCCEEDED( dwSampleStatus ) && SUCCEEDED( dwTimeStatus ) )
            {
                dwStatus = WBEM_E_INVALID_PROPERTY;
            }
            else if ( SUCCEEDED( dwSampleStatus ) )
            {
                if ( vSampleProp.vt != VT_I4 )
                {
                    dwStatus = E_FAIL;
                }
                else 
                {
                    m_nSampleWindow = vSampleProp.intVal;                    
                }
            }
            else if ( SUCCEEDED( dwTimeStatus ) )
            {
                if ( vTimeProp.vt != VT_I4 )
                    dwStatus = E_FAIL;
                else
                    m_nTimeWindow = vTimeProp.intVal;
            }
            else
            {
                m_nSampleWindow = WMI_DEFAULT_SAMPLE_WINDOW;
            }
        }
    }

    return dwStatus;
}

//
// Description: the RawCooker could easily be a Singleton shared among 
//           all the cooking properties, since it does not mantain state on behaf of the
//           Cooking property
//
///////////////////////////////////////////////////////////////////
WMISTATUS CCookingProperty::Cook( DWORD dwNumSamples, __int64* aRawCounter, __int64* aBaseCounter, __int64* aTimeStamp, __int64* pnResult )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    dwStatus = m_Cooker.CookRawValues( m_dwCounterType,
                                       dwNumSamples,
                                       aTimeStamp,
                                       aRawCounter,
                                       aBaseCounter,
                                       m_nTimeFreq,
                                       m_lScale,
                                       pnResult );

    return dwStatus;
}

CProperty* CCookingProperty::GetRawCounterProperty()
{ 
    return m_pRawCounterProp; 
}

CProperty* CCookingProperty::GetBaseProperty()
{ 
    return m_pBaseProp; 
}

CProperty* CCookingProperty::GetTimeProperty()
{ 
    return m_pTimeProp; 
}

HRESULT 
CCookingProperty::SetFrequency(IWbemObjectAccess * pObjAcc)
{
    if (m_nTimeFreq == 0)
    {
        // get the Frequency from the Raw Object
        if (m_pFrequencyProp)
        {
            __int64 lTmp;
            HRESULT hRes = GetPropValue(m_pFrequencyProp,pObjAcc,lTmp);
            if (SUCCEEDED(hRes)) m_nTimeFreq = lTmp;
            return hRes;         
        } 
        else if (!(m_dwReqProp & REQ_FREQ)) 
        {         
            return WBEM_NO_ERROR;
        } 
        else 
        {        
            LARGE_INTEGER li;
            if (QueryPerformanceFrequency(&li))
            {            
                m_nTimeFreq = li.QuadPart;
                return WBEM_NO_ERROR;                
            } 
            else 
            {
                return  WBEM_E_INVALID_PARAMETER;
            }
            
        }        
    } 
    else 
    {
        return WBEM_NO_ERROR;
    }
    
}

unsigned __int64 CCookingProperty::GetFrequency(void)
{
    return m_nTimeFreq;
}


///////////////////////////////////////////////////////////////////////////////
//
//    CPropertySampleCache
//    ====================
//
//    This class caches the sample data for a single property for a single 
//    instance
//
///////////////////////////////////////////////////////////////////////////////

CPropertySampleCache::CPropertySampleCache():
      m_aRawCounterVals(NULL),
      m_aBaseCounterVals(NULL),
      m_aTimeStampVals(NULL),
      m_dwRefreshID(0)
{
}

CPropertySampleCache::~CPropertySampleCache()
{
    delete [] m_aRawCounterVals;
    delete [] m_aBaseCounterVals;
    delete [] m_aTimeStampVals;
}

WMISTATUS CPropertySampleCache::SetSampleInfo( DWORD dwNumActiveSamples, DWORD dwMinReqSamples )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    m_dwNumSamples = 0;
    m_dwTotSamples = dwNumActiveSamples;

    m_aRawCounterVals = new __int64[dwNumActiveSamples];
    if (!m_aRawCounterVals)
        return WBEM_E_OUT_OF_MEMORY;
    memset( m_aRawCounterVals, 0, sizeof(__int64) *  dwNumActiveSamples );

    m_aBaseCounterVals = new __int64[dwNumActiveSamples];
    if (!m_aBaseCounterVals)
            return WBEM_E_OUT_OF_MEMORY;
    memset( m_aBaseCounterVals, 0, sizeof(__int64) *  dwNumActiveSamples );

    m_aTimeStampVals = new __int64[dwNumActiveSamples];
    if (!m_aTimeStampVals)
            return WBEM_E_OUT_OF_MEMORY;
    memset( m_aBaseCounterVals, 0, sizeof(__int64) *  dwNumActiveSamples );

    return dwStatus;
}


WMISTATUS CPropertySampleCache::SetSampleData( DWORD dwRefreshID, __int64 nRawCounter, __int64 nRawBase, __int64 nTimeStamp )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    if (dwRefreshID <= m_dwRefreshID)
    {
        return dwStatus;
    } 
    else 
    {
        m_dwRefreshID = dwRefreshID;
    }

    if ( m_dwNumSamples < m_dwTotSamples )
    {
        m_dwNumSamples++;
    }
    
    if ( m_dwTotSamples >= 2 ) 
    {
        for (LONG i = (LONG)(m_dwTotSamples-2); i>=0; i--)
        {
            m_aRawCounterVals[i+1] = m_aRawCounterVals[i];
            m_aBaseCounterVals[i+1] = m_aBaseCounterVals[i];
            m_aTimeStampVals[i+1] = m_aTimeStampVals[i];
        }
    }

    m_aRawCounterVals[0] = nRawCounter;
    m_aBaseCounterVals[0] = nRawBase;
    m_aTimeStampVals[0] = nTimeStamp;

    return dwStatus;
}

WMISTATUS CPropertySampleCache::GetData( DWORD* pdwNumSamples, __int64** paRawCounter, __int64** paBaseCounter, __int64** paTimeStamp )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    *pdwNumSamples = m_dwNumSamples;
    *paRawCounter = m_aRawCounterVals;
    *paBaseCounter = m_aBaseCounterVals;
    *paTimeStamp = m_aTimeStampVals;

    return dwStatus;
}

///////////////////////////////////////////////////////////////////////////////
//
//    CCookingInstance
//    ================
//
//    The cooking instance - used to model an instance of a cooked object.  Each 
//    property maintains a cache of values that will be used to compute the 
//    final cooked value.
//
///////////////////////////////////////////////////////////////////////////////

CCookingInstance::CCookingInstance( IWbemObjectAccess *pCookingInstance, DWORD dwNumProps ) :
  m_wszKey( NULL ),
  m_aPropertySamples( NULL ),
  m_pCookingInstance( pCookingInstance ),
  m_pRawInstance( NULL ),
  m_dwNumProps( dwNumProps )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//    Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
    if ( m_pCookingInstance ) 
    {
        m_pCookingInstance->AddRef(); 
        m_wszKey = ::GetKey( m_pCookingInstance );
    }

    if (dwNumProps) 
    {
        // allocation checked in IsValid
        m_aPropertySamples = new CPropertySampleCache[dwNumProps];
    };
}


CCookingInstance::~CCookingInstance()
{

    delete [] m_wszKey;

    if ( NULL != m_pCookingInstance ) 
    {
        m_pCookingInstance->Release(); 
    }

    delete [] m_aPropertySamples;

    if ( NULL != m_pRawInstance ) 
    {
        m_pRawInstance->Release();
    }
}

WMISTATUS CCookingInstance::InitProperty( DWORD dwProp, DWORD dwNumActiveSamples, DWORD dwMinReqSamples )
{
    return m_aPropertySamples[dwProp].SetSampleInfo( dwNumActiveSamples, dwMinReqSamples );
}

WMISTATUS CCookingInstance::SetRawSourceInstance( IWbemObjectAccess* pRawSampleSource )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    if ( NULL != m_pRawInstance )
    {
        m_pRawInstance->Release();
    }

    m_pRawInstance = pRawSampleSource;

    if ( NULL != m_pRawInstance )
    {
        m_pRawInstance->AddRef();
    }

    return dwStatus;
}

WMISTATUS CCookingInstance::GetRawSourceInstance( IWbemObjectAccess** ppRawSampleSource ) 
{ 
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    *ppRawSampleSource = m_pRawInstance;

    if ( NULL != m_pRawInstance )
    {
        m_pRawInstance->AddRef();
    }

    return dwStatus;
}

IWbemObjectAccess* CCookingInstance::GetInstance() 
{ 
    if ( NULL != m_pCookingInstance ) 
        m_pCookingInstance->AddRef();

    return m_pCookingInstance; 
}

WMISTATUS CCookingInstance::AddSample( DWORD dwRefreshStamp, DWORD dwProp, __int64 nRawCounter, __int64 nRawBase, __int64 nTimeStamp )
{
    return m_aPropertySamples[dwProp].SetSampleData( dwRefreshStamp, nRawCounter, nRawBase, nTimeStamp );
}

WMISTATUS CCookingInstance::Refresh( IWbemObjectAccess* pRawData, IWbemObjectAccess** ppCookedData )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    return dwStatus;
}

WMISTATUS CCookingInstance::UpdateSamples()
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;
    
    return dwStatus;
}

WMISTATUS CCookingInstance::CookProperty( DWORD dwProp, CCookingProperty* pProperty )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//    Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;
    
    DWORD        dwNumSamples = 0;
    __int64*    aRawCounter;
    __int64*    aBaseCounter;
    __int64*    aTimeStamp;
    __int64        nResult = 0;

    long lHandle = pProperty->GetHandle();

    dwStatus = m_aPropertySamples[dwProp].GetData( &dwNumSamples, &aRawCounter, &aBaseCounter, &aTimeStamp );

    if ( SUCCEEDED( dwStatus ) )
    {
#ifdef _VERBOSE    
        {
            unsigned __int64 Freq = pProperty->GetFrequency();
            DbgPrintfA(0,"PropName %S sample %d\n"
                            "Raw  %I64d %I64d\n"
                            "Base %I64d %I64d\n"
                              "Time %I64d %I64d\n"
                              "Freq %I64d\n",
                     pProperty->GetName(),dwNumSamples,
                     aRawCounter[0],aRawCounter[1],
                     aBaseCounter[0],aBaseCounter[1],
                     aTimeStamp[0],aTimeStamp[1],
                     Freq);
        }
#endif        
        
        if (SUCCEEDED(dwStatus = pProperty->SetFrequency(m_pRawInstance))){
        
            dwStatus = pProperty->Cook( dwNumSamples, aRawCounter, aBaseCounter, aTimeStamp, &nResult );
        }
#ifdef _VERBOSE            
            DbgPrintfA(0,"Result %I64d dwStatus %08x\n",nResult,dwStatus);
#endif        
    };

    if ( SUCCEEDED( dwStatus ) )
    {
        switch ( pProperty->GetType() )
        {
        case CIM_UINT32:
              dwStatus = m_pCookingInstance->WriteDWORD( lHandle, (DWORD) nResult );
            break;
        case CIM_UINT64:        
            dwStatus = m_pCookingInstance->WriteQWORD( lHandle, nResult );
            break;
        default:
            dwStatus = WBEM_E_TYPE_MISMATCH;
        }
    };

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////
//
//
//    CEnumeratorCache
//
//
/////////////////////////////////////////////////////////////////////////

CEnumeratorCache::CEnumeratorCache() :    
    m_dwEnum( 0 )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//    Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
}

CEnumeratorCache::~CEnumeratorCache()
{
    CInCritSec ics(&m_cs);
    for (DWORD i=0;i<m_apEnumerators.size();i++)
    {
        CEnumeratorManager* pEnumMgr = m_apEnumerators[i];
        if (pEnumMgr) pEnumMgr->Release();
    }
}

WMISTATUS CEnumeratorCache::AddEnum( LPCWSTR wszCookingClass,
                                     IWbemClassObject* pCookedClass, 
                                     IWbemClassObject* pRawClass,
                                     IWbemHiPerfEnum* pCookedEnum, 
                                     IWbemHiPerfEnum* pRawEnum, 
                                     long lIDRaw, 
                                     DWORD* pdwID )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//    Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    CEnumeratorManager* pEnumMgr = new CEnumeratorManager( wszCookingClass, pCookedClass, pRawClass, pCookedEnum, pRawEnum, lIDRaw );
    if (NULL == pEnumMgr) return WBEM_E_OUT_OF_MEMORY;

    CInCritSec ics(&m_cs);    
    if (SUCCEEDED(pEnumMgr->GetInithResult()))
    {    
        DWORD i;
        for (i=0;i<m_apEnumerators.size();i++)
        {
            if(m_apEnumerators[i] == NULL)
            {
                m_apEnumerators[i] = pEnumMgr;
                if (pdwID) 
                {
                    *pdwID = i;
                }
                break;
            }
        }
        // we need to expand the array
        if (i == m_apEnumerators.size())
        {
            try 
            {
                m_apEnumerators.push_back(pEnumMgr);
                if (pdwID) 
                {
                    *pdwID = m_apEnumerators.size()-1;
                }
            } 
            catch (...) 
            {
                pEnumMgr->Release();
                dwStatus = WBEM_E_OUT_OF_MEMORY;
            }
        }

    }
    else
    {
        dwStatus = pEnumMgr->GetInithResult();
    }

    return dwStatus;
}

WMISTATUS CEnumeratorCache::RemoveEnum( DWORD dwID , long * pRawId )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//    Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;


    CInCritSec ics(&m_cs); 
    
    if ( dwID < m_apEnumerators.size() ) 
    {
        CEnumeratorManager* pEnumMgr = m_apEnumerators[dwID];
        m_apEnumerators[dwID] = NULL;

        if (pRawId) *pRawId = pEnumMgr->GetRawId();
        
        pEnumMgr->Release(); 
    } 
    else 
    {
        dwStatus = E_FAIL;
    }
    return dwStatus;
}

WMISTATUS CEnumeratorCache::Refresh(DWORD dwRefreshId)
///////////////////////////////////////////////////////////////////////////////
//
//
//
//    Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
    WMISTATUS    dwStatus = WBEM_NO_ERROR;


    CEnumeratorManager** ppEnumMang =  new CEnumeratorManager*[m_apEnumerators.size()];
    wmilib::auto_buffer<CEnumeratorManager*> rm_(ppEnumMang);
    if (!ppEnumMang)
        return WBEM_E_OUT_OF_MEMORY;
    
    memset(ppEnumMang,0,sizeof(CEnumeratorManager*)*m_apEnumerators.size());
    
    DWORD j=0;
    DWORD i=0;

    {
        CInCritSec ics(&m_cs);
        
        for (i=0;i<m_apEnumerators.size();i++)
        {
            CEnumeratorManager* pEnumMgr = m_apEnumerators[i];
            if (pEnumMgr) 
            {
                pEnumMgr->AddRef();
                ppEnumMang[j] = pEnumMgr;
                j++;
            }
        }
 
    }


    for (i=0;i<j;i++)
    {
        dwStatus = ppEnumMang[i]->Refresh(dwRefreshId);
        if (FAILED(dwStatus))
        {        
            break;
        }
    }

    for (i=0;i<j;i++)
    {
        ppEnumMang[i]->Release();
    }

    return dwStatus;
}


/////////////////////////////////////////////////////////////////////////
//
//
//    CEnumeratorManager
//
//
/////////////////////////////////////////////////////////////////////////



CEnumeratorManager::CEnumeratorManager( LPCWSTR wszCookingClass,
                                        IWbemClassObject* pCookedClass,
                                        IWbemClassObject* pRawClass,
                                        IWbemHiPerfEnum* pCookedEnum, 
                                        IWbemHiPerfEnum* pRawEnum, 
                                        long lRawID ) 
:    m_pCookedClass( pCookedClass ),
    m_pRawEnum(pRawEnum),
    m_pCookedEnum( pCookedEnum ),
    m_pCooker(NULL),
    m_lRawID(lRawID),
    m_dwSignature('mMnE'),
    m_cRef(1),               //-------------- initial refcount
    m_dwVector(0),
    m_wszCookingClassName(NULL)
{
    size_t length = wcslen( wszCookingClass ) + 1;
    m_wszCookingClassName = new WCHAR[ length];

    if ( NULL != m_wszCookingClassName )
        StringCchCopyW( m_wszCookingClassName, length, wszCookingClass );

    _DBG_ASSERT(m_pCookedClass);
    m_pCookedClass->AddRef();

    if ( NULL != m_pRawEnum )
        m_pRawEnum->AddRef();

    if ( NULL != m_pCookedEnum )
        m_pCookedEnum->AddRef();

    _DBG_ASSERT(pRawClass);

    m_IsSingleton = IsSingleton(pRawClass);
    
    m_InithRes = Initialize( pRawClass );
}

CEnumeratorManager::~CEnumeratorManager()
{
    m_dwSignature = 'gmne';

    delete m_wszCookingClassName;

    // one reference is held by the CWMISimpleObjectCooker
    if (m_pCookedClass ) m_pCookedClass->Release();
    if (m_pRawEnum) m_pRawEnum->Release();
    if (m_pCookedEnum)  m_pCookedEnum->Release();
    
    delete m_pCooker;

#ifdef _VERBOSE
     DbgPrintfA(0,"~CEnumeratorManager %08x\n",this);
#endif    
}

LONG CEnumeratorManager::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

LONG CEnumeratorManager::Release()
{
    LONG lRet = InterlockedDecrement(&m_cRef);
    if (lRet == 0) delete this;
    return lRet;
}

//
// called from the constructor
//
WMISTATUS CEnumeratorManager::Initialize( IWbemClassObject* pRawClass )
{
    WMISTATUS    dwStatus;
    HRESULT hr1,hr2;


    IWbemObjectAccess*    pCookedAccess = NULL;
    IWbemObjectAccess*    pRawAccess = NULL;

    hr1 = m_pCookedClass->QueryInterface( IID_IWbemObjectAccess, (void**)&pCookedAccess );
    CReleaseMe    arCookedAccess( pCookedAccess );
        
    hr2 = pRawClass->QueryInterface( IID_IWbemObjectAccess, (void**)&pRawAccess );
    CReleaseMe    arRawAccess( pRawAccess );

    if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
    { 
        m_pCooker = new CWMISimpleObjectCooker( m_wszCookingClassName, 
                                                pCookedAccess, // acquired by CWMISimpleObjectCooker
                                                pRawAccess );
    }

    if (m_pCooker == NULL)
    {
        dwStatus = WBEM_E_OUT_OF_MEMORY;
    } 
    else 
    {
        dwStatus = m_pCooker->GetLastHR();
    }
    
    return dwStatus;
}


//
// returns an hash-ed value of the __RELPATH in a ULONG_PTR with the lower bit stripped
// the lower bit is used to flag the entry when updating the enumerators
//
/////////////////////////////////////////////////////////////////////////////
ULONG_PTR hash_string (WCHAR * pKey)
{
    ULONG_PTR acc    = 0;
    ULONG_PTR i    = 0;
    WCHAR *this_char    = pKey;

    while (*this_char != NULL) {
        acc ^= *(this_char++) << i;
        i = (i + 1) % sizeof (void *);
    }

    return (acc<<1); // so we can save the LOWEST bit
}

//
// this function simply fills out an array of pointers to IWbemObejctAccess
// obtaining them from the RAW-Enumerator
// it also builds an array with hashes of the __RELPATHs of the instances
//
///////////////////////////////////////////////////////////////
WMISTATUS 
CEnumeratorManager::GetRawEnumObjects(std::vector<IWbemObjectAccess*, wbem_allocator<IWbemObjectAccess*> > & refArray,
                                     std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & refObjHashKeys)
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    DWORD    dwRet = 0,
            dwNumRawObjects = 0;

    IWbemObjectAccess**    apObjAccess = NULL;

    dwStatus = m_pRawEnum->GetObjects( 0L, 0, apObjAccess, &dwRet);

    if ( WBEM_E_BUFFER_TOO_SMALL == dwStatus )
    {
        // Set the buffer size
        // ===================
        dwNumRawObjects = dwRet;

        wmilib::auto_buffer<IWbemObjectAccess*> apObjAccess( new IWbemObjectAccess*[dwNumRawObjects]);
        if ( NULL != apObjAccess.get() )
        {
            memset( apObjAccess.get(), 0, dwNumRawObjects * sizeof(IWbemObjectAccess*));            
            dwStatus = m_pRawEnum->GetObjects( 0L, dwNumRawObjects, (IWbemObjectAccess **)apObjAccess.get(), &dwRet );
        }
        else
        {
            dwStatus = WBEM_E_OUT_OF_MEMORY;
        }

        if ( SUCCEEDED( dwStatus ) )
        {
            try
            {
                refArray.reserve(dwNumRawObjects);
                refObjHashKeys.reserve(dwNumRawObjects);
            }
            catch (...)
            {
                 dwStatus = WBEM_E_OUT_OF_MEMORY;
                 dwNumRawObjects = 0;
            }
            
            for (DWORD i=0;i<dwNumRawObjects;i++)
            {
                HRESULT hr1;
                _variant_t VarKey; // does not throw, just container
                hr1 = apObjAccess[i]->Get(L"__RELPATH",0,&VarKey,NULL,NULL);
                if (SUCCEEDED(hr1))
                {
                    DWORD Hash = hash_string(VarKey.bstrVal);
                    refObjHashKeys.push_back(Hash);
                    refArray.push_back(apObjAccess[i]);
                } 
                else 
                {
                    // if we cannot give out the ownership of a pointer, release
                    apObjAccess[i]->Release();
                }                
            }
        }
    }
    
    return dwStatus;
}

//
// the problem that UpdateEnums and Refresh are trying to solve is the following:
// The Cooked enumerator needs 2 Raw values for calculating 1 value.
// the 2 values comes from two distinc enumeration
// the 2 distinct enumeration can give a different resultset
// OLD:  A  B  C  D  E
// NEW:     B  C     E  F  G
// we are adding to the "cooking cache" only the new objects,
// and we are removing the old ones
//
//////////////////////////////////////////////////////////////////////

WMISTATUS 
CEnumeratorManager::UpdateEnums(
    /*out*/ std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & apObjKeyHash)
{
    // cyclic logic:
    // we have a 'circular array' of std::vector
    // and the m_dwVector is the index
    // circular increment of the index will decide 
    // who is the New and who is the Old
    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & Old = m_Delta[m_dwVector];    
    m_dwVector = (m_dwVector+1)%2;
    m_Delta[m_dwVector].clear();
    m_Delta[m_dwVector] = apObjKeyHash;
    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & New = m_Delta[m_dwVector];
    
    DWORD j,k;

    for (j=0;j<New.size();j++)
    {
        BOOL bFound = FALSE;
        for (k=0;k<Old.size();k++)
        {
            if (Old[k] == New[j])
            {
                Old[k] |= 1;
                bFound = TRUE;
                break;
            }           
        }
        if (!bFound)
        {
            New[j] |= 1; // ad the very NEW bit
        }
    }
    
    return WBEM_S_NO_ERROR;

}

WMISTATUS CEnumeratorManager::Refresh( DWORD dwRefreshStamp )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    std::vector<IWbemObjectAccess*, wbem_allocator<IWbemObjectAccess*> > apObjAccess;
    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > apObjHashKeys;

    dwStatus = GetRawEnumObjects( apObjAccess, apObjHashKeys );

    // calculate the Delta of the caches
    if (SUCCEEDED(dwStatus))
    {
        dwStatus = UpdateEnums(apObjHashKeys);
    }

    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & New = m_Delta[m_dwVector];
    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & Old = m_Delta[(m_dwVector-1)%2];

    {    
        CInCritSec ics(&m_cs);
        
        // Merge into the cache    
        if ( SUCCEEDED(dwStatus) )
        {
            //
            //  Elements in the New array with the bit set are really new
            //
            DWORD j;
            for (j=0; j< New.size(); j++)
            {
                if (New[j] & 1)  // test the very new BIT
                {
                    EnumCookId thisEnumCookId;
                    dwStatus = InsertCookingRecord( apObjAccess[j], &thisEnumCookId, dwRefreshStamp );
                    if (SUCCEEDED(dwStatus))
                    {
                        try 
                        {
                            m_mapID[New[j]] = thisEnumCookId;
                        } 
                        catch (...) 
                        {
                            break;
                        }
                    }
                    else 
                    {
                        break;
                    }
                    //remove the bit
                    New[j] &= (~1);
                }
            }

            for (j=0; j<Old.size(); j++)
            {
                if (Old[j] & 1)
                {
                    Old[j] &= (~1); // remove the ALREADY_THERE bit
                }
                else
                {
                    EnumCookId thisEnumCookId;
                    thisEnumCookId = m_mapID[Old[j]];
                    m_mapID.erase(Old[j]);
                    RemoveCookingRecord(&thisEnumCookId);
                }
            }
            m_pCooker->Recalc(dwRefreshStamp);        
        }

    }
    
    // in any case ....
    for (DWORD i=0;i<apObjAccess.size();i++)
    {
        apObjAccess[i]->Release();
    };


    return dwStatus;
}

WMISTATUS 
CEnumeratorManager::InsertCookingRecord(                                         
                                        IWbemObjectAccess* pRawObject,
                                        EnumCookId * pEnumCookId,
                                        DWORD dwRefreshStamp)
///////////////////////////////////////////////////////////////////////////////
//
//
//
//    Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    if (!pRawObject || !pEnumCookId)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    IWbemObjectAccess*    pCookedObject = NULL;

    long lID = 0;

    dwStatus = CreateCookingObject( pRawObject, &pCookedObject );
    CReleaseMe  rm1(pCookedObject);

    if ( SUCCEEDED( dwStatus ) )
    {
        dwStatus = m_pCooker->SetCookedInstance( pCookedObject, &lID );

        if ( SUCCEEDED( dwStatus ) )
        {
            dwStatus = m_pCooker->BeginCooking( lID, pRawObject,dwRefreshStamp);
        }
    }

    if ( SUCCEEDED( dwStatus ) )
    {
        DWORD dwTarget;
        long EnumId = lID;

        dwStatus = m_pCookedEnum->AddObjects( 0L, 1, &EnumId, &pCookedObject );
        if (SUCCEEDED(dwStatus))
        {
            pEnumCookId->CookId = lID;
            pEnumCookId->EnumId = EnumId;
            m_dwUsage++;
        }
        else
        {
            pEnumCookId->CookId = 0;
            pEnumCookId->EnumId = 0;            
        }
    }

    return dwStatus;
}




WMISTATUS CEnumeratorManager::CreateCookingObject( 
        IWbemObjectAccess* pRawObject, 
        IWbemObjectAccess** ppCookedObject )
///////////////////////////////////////////////////////////////////////////////
//
//    Create a new instance of the cooked object and set the key(s) based on the 
//    raw object's key(s) value.
//
//    Parameters:
//    
//        pRawObject        - The new object's corresponding raw object
//        ppCookedObject    - The new cooked object
//
///////////////////////////////////////////////////////////////////////////////        
{
        
    HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject * pCookedInst = NULL;

    hr = m_pCookedClass->SpawnInstance(0,&pCookedInst);
    CReleaseMe rm1(pCookedInst);
    
    if (SUCCEEDED(hr) &&
        !m_IsSingleton)
    {

        // get the 'list' of all the key property
        // if you haven't got it in the past
        if (m_pKeyProps.size() == 0)
        {
            hr = pRawObject->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
            if (SUCCEEDED(hr))
            {
                BSTR bstrName;
                
                while(WBEM_S_NO_ERROR == pRawObject->Next(0,&bstrName,NULL,NULL,NULL))
                {
                    try
                    {
                        m_pKeyProps.push_back(bstrName);
                    }
                    catch (...)
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    };
                    SysFreeString(bstrName);
                };
                
                pRawObject->EndEnumeration();
            }
        }

        // copy all the key properties from the Raw to the cooked instance
        if (m_pKeyProps.size() > 0 && SUCCEEDED(hr))
        {        
            for(int i=0;i<m_pKeyProps.size();i++)
            {
                // does not thorow, just a container
                _variant_t VarVal;
                CIMTYPE ct;
                hr = pRawObject->Get(m_pKeyProps[i],0,&VarVal,&ct,NULL);
                if (SUCCEEDED(hr))
                {
                    hr = pCookedInst->Put(m_pKeyProps[i],0,&VarVal,0);
                    
                    if (FAILED(hr))
                    {
                        break;
                    }
                } 
                else 
                {
                    break;
                }
                VarVal.Clear();
            }
        } else {
        
            hr = WBEM_E_INVALID_CLASS;
            
        }
    };
    
    if (SUCCEEDED(hr)){
        hr = pCookedInst->QueryInterface( IID_IWbemObjectAccess, (void**)ppCookedObject );
    }
 
    return hr;
}

WMISTATUS CEnumeratorManager::RemoveCookingRecord( EnumCookId * pEnumCookID )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//    Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
    if (!pEnumCookID)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    dwStatus = m_pCookedEnum->RemoveObjects( 0L, 1, &pEnumCookID->EnumId );

    m_pCooker->StopCooking(pEnumCookID->CookId);    
    m_pCooker->Remove(pEnumCookID->CookId);

    --m_dwUsage;
    
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\cache.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    Cache.h

Abstract:

	Contains all caching classes and objects.

History:

    a-dcrews	01-Mar-00  	Created
    
    ivanbrug    23-Jun-2000  mostly rewritten

--*/

#ifndef _CACHE_H_
#define _CACHE_H_

#include <windows.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wstlallc.h>
#include <sync.h>

#include "RawCooker.h"
#include "CookerUtils.h"

#include <wstring.h>
#include <map>
#include <vector>
#include <functional>

///////////////////////////////////////////////////////////////////////////////
//
//	Macro Definitions
//
///////////////////////////////////////////////////////////////////////////////

#define WMI_COOKER_CACHE_INCREMENT	8	// The cache size adjustment increment 

///////////////////////////////////////////////////////////////////////////////
//
//	CProperty
//	=========
//
//	The base property - used for raw properties and the base 
//	class for the CookedProperty.
//
///////////////////////////////////////////////////////////////////////////////

class CProperty
{
protected:
#ifdef _VERBOSE	
	LPWSTR				m_wszName;			// The property name
#endif	
	long				m_lPropHandle;		// The property handle
	CIMTYPE				m_ct;

public:
	CProperty( LPWSTR wszName, long lHandle, CIMTYPE ct );
	~CProperty();

#ifdef _VERBOSE
	LPWSTR GetName();
#endif
	CIMTYPE GetType();
	long GetHandle();
};

///////////////////////////////////////////////////////////////////////////////
//
//	CCookingProperty
//	================
//
//	The cooked property - used to model the data required to
//	cook a property of a cooekd class
//
///////////////////////////////////////////////////////////////////////////////

class CCookingProperty : public CProperty
{
	DWORD				m_dwCounterType;	// Counter type
	DWORD               m_dwReqProp;        // which property are needed to perform calculation
	CRawCooker			m_Cooker;			// The cooker object

	CProperty*			m_pRawCounterProp;	// The raw counter property
	CProperty*			m_pTimeProp;		// The raw time property
	CProperty*			m_pFrequencyProp;   // The raw frequency property
	
	CProperty*			m_pBaseProp;		// The raw base property OPTIONAL for most counters

	__int32				m_nSampleWindow;	// The number of samples used for the computation
	__int32				m_nTimeWindow;		// The period used for the samples

	unsigned __int64	m_nTimeFreq;		// The timer frequency;
	long                m_lScale;           // The Scale factor (10 ^ (m_lScale))
    BOOL                m_bUseWellKnownIfNeeded;	

public:
	CCookingProperty( LPWSTR wszName, 
	                  DWORD dwCounterType, 
	                  long lPropHandle, 
	                  CIMTYPE ct,
	                  DWORD dwReqProp,
	                  BOOL bUseWellKnownIfNeeded);
	virtual ~CCookingProperty();

	WMISTATUS Initialize( IWbemQualifierSet* pCookingPropQualifierSet, 
	                      IWbemObjectAccess* pRawAccess,
	                      IWbemQualifierSet* pCookingClassQSet);

	WMISTATUS Cook( DWORD dwNumSamples, 
	                __int64* aRawCounter, 
	                __int64* aBaseCounter, 
	                __int64* aTimeStamp, 
	                __int64* pnResult );

	CProperty* GetRawCounterProperty();
	CProperty* GetBaseProperty();
	CProperty* GetTimeProperty();

    HRESULT SetFrequency(IWbemObjectAccess * pObjAcc);
    unsigned __int64 GetFrequency(void);
    BOOL IsReq(DWORD ReqProp) { return (m_dwReqProp&ReqProp); };

	DWORD NumberOfActiveSamples() { return m_nSampleWindow; };
	DWORD MinSamplesRequired() { return m_nSampleWindow; };

};

///////////////////////////////////////////////////////////////////////////////
//
//	CPropertySampleCache
//	====================
//
//	For every property in each instance, we must maintain a history of
//	previous samples for the cooking.  The type of cooking determines the 
//	number of required samples
//
///////////////////////////////////////////////////////////////////////////////

class CPropertySampleCache
{
	DWORD				m_dwNumSamples;		// The number of current samples
	DWORD				m_dwTotSamples;		// The size of the sample array
	DWORD               m_dwRefreshID;

	__int64*			m_aRawCounterVals;	// The array of raw counter values
	__int64*			m_aBaseCounterVals;	// The array of base counter values
	__int64*			m_aTimeStampVals;	// The array of timestamp values

public:
    CPropertySampleCache();
    ~CPropertySampleCache();

	WMISTATUS SetSampleInfo( DWORD dwNumActiveSamples, DWORD dwMinReqSamples );
	WMISTATUS SetSampleData( DWORD dwRefreshID, __int64 nRawCounter, __int64 nRawBase, __int64 nTimeStamp );
	WMISTATUS GetData( DWORD* pdwNumSamples, __int64** paRawCounter, __int64** paBaseCounter, __int64** paTimeStamp );
};

///////////////////////////////////////////////////////////////////////////////
//
//	CCookingInstance
//	================
//
//	The cooking instance - used to model an instance of a cooked object.  Each 
//	property maintains a cache of values that will be used to compute the 
//	final cooked value.
//
///////////////////////////////////////////////////////////////////////////////

class CCookingInstance
{
	LPWSTR					m_wszKey;						// The instance key

	IWbemObjectAccess*		m_pCookingInstance;				// Cooking instance data
	IWbemObjectAccess*		m_pRawInstance;					// Raw sample source

	CPropertySampleCache*	m_aPropertySamples;				// The cache of property samples for this instance
	DWORD					m_dwNumProps;	
	
public:
	CCookingInstance( IWbemObjectAccess *pCookingInstance, DWORD dwNumProps );
	virtual ~CCookingInstance();

	WMISTATUS InitProperty( DWORD dwProp, DWORD dwNumActiveSamples, DWORD dwMinReqSamples );

	WMISTATUS SetRawSourceInstance( IWbemObjectAccess* pRawSampleSource );
	WMISTATUS GetRawSourceInstance( IWbemObjectAccess** ppRawSampleSource );

	WMISTATUS AddSample( DWORD dwRefresherInc, DWORD dwProp, __int64 nRawCounter, __int64 nRawBase, __int64 nTimeStamp );

	WMISTATUS GetCachedSamples( IWbemObjectAccess** ppOldSample, IWbemObjectAccess** ppNewSample );
	IWbemObjectAccess* GetInstance();

	WMISTATUS UpdateSamples();
	WMISTATUS CookProperty( DWORD dwProp, CCookingProperty* pProperty );

	LPWSTR	GetKey() { return m_wszKey; }
	WMISTATUS Refresh( IWbemObjectAccess* pRawData, IWbemObjectAccess** ppCookedData );

       BOOL IsValid() {
               return (m_dwNumProps && m_aPropertySamples);
       };
};

///////////////////////////////////////////////////////////////////////////////
//
//	CRecord
//	=======
//
///////////////////////////////////////////////////////////////////////////////

template<class T>
class CRecord
{
	long			m_lID;					// Instance ID
	CRecord*		m_pNext;				// The next pointer in the list

	static long		m_lRefIDGen;			// The ID generator
public:
	CRecord() : m_lID( m_lRefIDGen++ ), m_pNext( NULL ) {}
	virtual ~CRecord() {}

	void SetNext( CRecord*	pRecord ) { m_pNext = pRecord; }
	void SetID( long lID ) { m_lID = lID; }

	CRecord* GetNext() { return m_pNext; }
	long GetID() { return m_lID; }

	virtual T* GetData() = 0;
};


///////////////////////////////////////////////////////////////////////////////
//
//	CObjRecord
//	==========
//
//	A hidden class used by the cache to manage elements
//
///////////////////////////////////////////////////////////////////////////////

template<class T>
class CObjRecord : public CRecord<T>
{
	WCHAR*	m_wszKey;
	T*	m_pObj;

public:
	CObjRecord( T* pObj, WCHAR* wszKey ) : m_pObj( pObj ), m_wszKey( NULL ) 
	{
		if ( NULL != wszKey )
		{			
			size_t length = wcslen( wszKey ) + 1;
			m_wszKey = new WCHAR[ length  ];
			if (m_wszKey)
        			StringCchCopyW( m_wszKey, length  , wszKey );
			else
				throw CX_MemoryException();
		}
	}

	~CObjRecord() 
	{ 
		delete m_pObj; 
		delete m_wszKey;
	}

	T* GetData(){ return m_pObj; }

	bool IsValueByKey( WCHAR* wszKey )
	{
		return ( 0 == _wcsicmp( m_wszKey, wszKey ) );
	}
};


///////////////////////////////////////////////////////////////////////////////
//
//	CCache
//	======
//
// BT - base type
// RT - record type
//
///////////////////////////////////////////////////////////////////////////////

template<class BT, class RT>
class CCache
{
	RT*		m_pHead;		// Head of list
	RT*		m_pTail;		// Tail of list
	RT*		m_pEnumNode;	// Enumerator pointer

public:

	CCache();
	virtual ~CCache();

	WMISTATUS Add( BT* pData, WCHAR* wszKey, long* plID );
	WMISTATUS Remove( long lID );
	WMISTATUS RemoveAll();

	WMISTATUS	GetData( long lID, BT** ppData );

	WMISTATUS BeginEnum();
	WMISTATUS Next( BT** ppData );
	WMISTATUS EndEnum();

	bool FindByKey( WCHAR* wszKey, BT* pData );
};

template<class T>
long CRecord<T>::m_lRefIDGen = 0;

template<class BT, class RT>
CCache<BT,RT>::CCache() : m_pHead( NULL ), m_pTail( NULL ), m_pEnumNode( NULL )
{
}

template<class BT, class RT>
CCache<BT,RT>::~CCache() 
{
	RT*	pNode = m_pHead;
	RT*	pNext = NULL;

	while ( NULL != pNode )
	{
		pNext = (RT*)pNode->GetNext();
		delete pNode;
		pNode = pNext;
	}
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::Add( BT *pData, WCHAR* wszKey, long* plID )
{
	WMISTATUS dwStatus = S_OK;

	if ( NULL == pData )
	{
		dwStatus = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED( dwStatus ) )
	{
		RT* pNewRecord = new RT( pData, wszKey );

		if ( NULL != pNewRecord )
		{
			if ( NULL == m_pHead )
			{
				m_pHead = pNewRecord;
				m_pTail = pNewRecord;
			}
			else
			{
				m_pTail->SetNext( pNewRecord );
				m_pTail = pNewRecord;
			}

			*plID = pNewRecord->GetID();
		}
		else
		{
			dwStatus = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return dwStatus;
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::Remove( long lID )
{
	WMISTATUS dwStatus = S_FALSE;

	RT*	pNode = m_pHead;
	RT*	pNext = (RT*)pNode->GetNext();
	RT*	pPrev = NULL;

	while ( NULL != pNode )
	{
		if ( pNode->GetID() == lID )
		{
			if ( NULL == pNext )
				m_pTail = pPrev;

			if ( NULL == pPrev )
				m_pHead = pNext;
			else
				pPrev->SetNext( pNext );

			delete pNode;

			dwStatus = S_OK;
		}

		pPrev = pNode;
		pNode = pNext;

		if ( NULL != pNode )
			pNext = (RT*)pNode->GetNext();
	}

	return dwStatus;
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::RemoveAll()
{
	WMISTATUS dwStatus = S_FALSE;

	RT*	pNode = m_pHead;
	RT*	pNext = NULL;

	while ( NULL != pNode )
	{
		pNext = (RT*)pNode->GetNext();
		delete pNode;
		pNode = pNext;
	}

	m_pHead = m_pTail = NULL;
	
	return dwStatus;
};

template<class BT, class RT>
WMISTATUS	CCache<BT,RT>::GetData( long lID, BT** ppData )
{
	WMISTATUS dwStatus = S_FALSE;

	RT*	pNode = m_pHead;

	while ( NULL != pNode )
	{
		if ( pNode->GetID() == lID )
		{
			*ppData = pNode->GetData();
			dwStatus = S_OK;
			break;
		}
		else
		{
			pNode = (RT*)pNode->GetNext();
		}
	}

	return dwStatus;

};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::BeginEnum()
{
	WMISTATUS dwStatus = S_OK;

	m_pEnumNode = m_pHead;

	return dwStatus;
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::Next( BT** ppData )
{
	WMISTATUS dwStatus = WBEM_S_FALSE;

	if ( NULL != m_pEnumNode )
	{
		*ppData = m_pEnumNode->GetData();
		m_pEnumNode = (RT*)m_pEnumNode->GetNext();
		dwStatus = S_OK;
	}

	return dwStatus;
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::EndEnum()
{
	WMISTATUS dwStatus = S_OK;

	m_pEnumNode = NULL;

	return dwStatus;
};

template<class BT, class RT>
bool CCache<BT,RT>::FindByKey( WCHAR* wszKey, BT* pData )
{
	BT	Data;
	bool bRet = FALSE;

	BeginEnum();

	while( WBEM_S_FALSE != Next( &Data ) )
	{
		if ( pData->IsValueByKey( wszKey ) )
		{
			*pData = Data;
			bRet = TRUE;
			break;
		}
	}

	EndEnum();

	return bRet;
};


//
//  used to add/remove an instance from the coooker
//  and from the fastprox enumerator
//

typedef struct tagEnumCookId {
    long CookId;
    long EnumId;
} EnumCookId;


///////////////////////////////////////////////////////////////
//
//	CEnumeratorManager
//	==================
//
///////////////////////////////////////////////////////////////

class CWMISimpleObjectCooker;

class CEnumeratorManager
// Manages a single enumerator
{
private:
	DWORD          m_dwSignature;
	LONG             m_cRef;
	HRESULT        m_InithRes;
	CCritSec        m_cs;
	
	CWMISimpleObjectCooker*	m_pCooker;			// The class' cooker
	long					m_lRawID;			// RawID
	IWbemHiPerfEnum*		m_pRawEnum;			// The hiperf cooked enumerator
	IWbemHiPerfEnum*		m_pCookedEnum;		// The hiperf cooked enumerator

	IWbemClassObject*	 	m_pCookedClass;		// The class definition for the cooking class

	std::vector<WString,wbem_allocator<WString> >    m_pKeyProps;
	WCHAR*					m_wszCookingClassName;
	BOOL                    m_IsSingleton;

	// to keep track of the differences 
	//  between the raw enum and our enum
	DWORD m_dwUsage;
	std::map< ULONG_PTR , EnumCookId , std::less<ULONG_PTR> ,wbem_allocator<EnumCookId> > m_mapID;
	std::vector< ULONG_PTR , wbem_allocator<ULONG_PTR> > m_Delta[2];
	DWORD m_dwVector;

    // members
	WMISTATUS Initialize( IWbemClassObject* pRawClass );							

	WMISTATUS CreateCookingObject( IWbemObjectAccess* pRawObject, IWbemObjectAccess** ppCookedObject );

	WMISTATUS InsertCookingRecord( IWbemObjectAccess* pRawObject, EnumCookId * pStruct, DWORD dwRefreshStamp );

	WMISTATUS RemoveCookingRecord( EnumCookId * pEnumCookId );

	WMISTATUS GetRawEnumObjects( std::vector<IWbemObjectAccess*, wbem_allocator<IWbemObjectAccess*> > & refArray,
	                             std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & refObjHashKeys);

	WMISTATUS UpdateEnums(std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & apObjAccess);
	
public:
	CEnumeratorManager( LPCWSTR wszCookingClass, IWbemClassObject* pCookedClass, IWbemClassObject* pRawClass, IWbemHiPerfEnum* pCookedEnum, IWbemHiPerfEnum* pRawEnum, long lRawID );
	virtual ~CEnumeratorManager();

	HRESULT GetInithResult(){ return m_InithRes; };

	WMISTATUS Refresh( DWORD dwRefreshStamp );
	long GetRawId(void){  return m_lRawID; };
	LONG AddRef();
	LONG Release();
	
};

///////////////////////////////////////////////////////////////
//
//	CEnumeratorCache
//	================
//
///////////////////////////////////////////////////////////////

class CEnumeratorCache
{
	DWORD				m_dwRefreshStamp;			// The refresh counter
	DWORD				m_dwEnum;					// The enumerator index

	std::vector<CEnumeratorManager*, wbem_allocator<CEnumeratorManager*> > m_apEnumerators;
	CCritSec    m_cs;

	WMISTATUS Initialize();

public:
	CEnumeratorCache();
	virtual ~CEnumeratorCache();

	WMISTATUS AddEnum( 
		LPCWSTR wszCookingClass, 
		IWbemClassObject* pCookedClass, 
		IWbemClassObject* pRawClass,
		IWbemHiPerfEnum* pCookedEnum, 
		IWbemHiPerfEnum* pRawEnum, 
		long lID, 
		DWORD* pdwID );

	WMISTATUS RemoveEnum( DWORD dwID , long * pRawId);

	WMISTATUS Refresh(DWORD dwRefreshStamp);
};

//  
//  Simple Cache based on the std::map
//  It will use the ID semantics:
//  Insertion will return an ID that need to be 
//  used for deletion
//  ids are unique for the lifetime of the Cache object
//

template <class T>
class IdCache 
{
private:
	std::map<DWORD, T, std::less<DWORD>, wbem_allocator<T> > m_map;
	DWORD m_NextId;
	typename std::map<DWORD, T, std::less<DWORD>, wbem_allocator<T> >::iterator m_it;
	CCritSec m_cs;
public:
	IdCache():m_NextId(0){};	
	virtual ~IdCache(){};
	void Lock(){ m_cs.Enter(); }
	void Unlock(){m_cs.Leave();};

	// traditional interfaces
	HRESULT Add( DWORD * pId, T Elem);
	HRESULT GetData(DWORD Id, T * pElem);
	HRESULT Remove(DWORD Id, T * pRemovedElem);

	// before calling this, delete the elements
	HRESULT RemoveAll(void);

	// Enumerator Style
	HRESULT BeginEnum(void);
	HRESULT Next(T * pElem);
	HRESULT EndEnum(void);
};


template <class T>
HRESULT
IdCache<T>::Add( DWORD * pId, T Elem)
{
	HRESULT hr;
	CInCritSec ics(&m_cs);
	if (pId) 
	{
		std::map<DWORD, T , std::less<DWORD>, wbem_allocator<T> >::iterator it = m_map.find(m_NextId);    
		if (it != m_map.end())
			hr =  E_FAIL;
		else 
		{			
		       try 
		       {
				m_map[m_NextId] = Elem;
				*pId = m_NextId;
				InterlockedIncrement((PLONG)&m_NextId);
				hr = WBEM_S_NO_ERROR;			    
		       }
		       catch(...)
		       {
			       hr =  E_FAIL;
		       }
		}		
	} 
	else 
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
	return hr;
}

template <class T>
HRESULT
IdCache<T>::GetData(DWORD Id, T * pElem)
{
	CInCritSec ics(&m_cs);
	HRESULT hr = WBEM_S_NO_ERROR;

	std::map<DWORD, T , std::less<DWORD>, wbem_allocator<T> >::iterator it = m_map.find(Id);    
	if (it != m_map.end())
	    *pElem = (*it).second;
	else 
	   hr = WBEM_E_NOT_FOUND;

	return hr;
}

template <class T>
HRESULT
IdCache<T>::Remove(DWORD Id, T * pRemovedElem)
{
	CInCritSec ics(&m_cs);
	
	HRESULT hr = WBEM_S_NO_ERROR;	
	if (pRemovedElem) 
	{
		std::map<DWORD, T , std::less<DWORD>, wbem_allocator<T> >::iterator it = m_map.find(Id);

		if (it != m_map.end()) 
		{
		    *pRemovedElem =  (*it).second;			
		     m_map.erase(it);
		} else
		     hr = WBEM_E_NOT_FOUND;
	} 
	else
	    hr = WBEM_E_INVALID_PARAMETER;

	return hr;
}

//
// DEVDEV Empty the cache before removing from std::map
//
template <class T>
HRESULT 
IdCache<T>::RemoveAll(void)
{
	CInCritSec ics(&m_cs);	
	m_map.erase(m_map.begin(),m_map.end());

	return  WBEM_S_NO_ERROR;
};

template <class T>
HRESULT 
IdCache<T>::BeginEnum(void)
{
	Lock();
	m_it = m_map.begin();
	return WBEM_S_NO_ERROR;
}

//
//  assume inside CritSec
//
/////////////////////////////
template <class T>
HRESULT
IdCache<T>::Next(T * pElem)
{
	HRESULT hr;
	if (pElem)
	{
		if (m_it == m_map.end())
			hr = WBEM_S_NO_MORE_DATA;
		else 
		{
			*pElem = (*m_it).second;
			++m_it;
			hr = WBEM_S_NO_ERROR;
		}
	} else
		hr = WBEM_E_INVALID_PARAMETER;

	return hr;
}

template <class T>
HRESULT
IdCache<T>::EndEnum(void)
{
    Unlock();
    return WBEM_S_NO_ERROR;
}


#endif //_CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\factory.cpp ===
////////////////////////////////////////////////////////////////////////
//
//    Factory.cpp
//
//    Module:    WMI high performance provider sample code
//
//    This is a standard class factory implementation for the CHiPerfProvider
//    object.  
//
//  History:
//    a-dcrews      12-Jan-99        Created
//
//    
//  Copyright (c) 1999-2001 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Provider.h"
#include "Factory.h"

extern long g_lObjects;
extern long g_lLocks;

//////////////////////////////////////////////////////////////
//
//
//    CClassFactory
//
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//    Standard QueryInterface
//
//    Parameters:
//        riid    - the ID of the requested interface
//        ppv        - a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
{
    if (NULL == ppv) return E_POINTER;
        
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)this;
    else if(riid == IID_IClassFactory)
        *ppv = (LPVOID)(IClassFactory*)this;
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}

STDMETHODIMP CClassFactory::CreateInstance(
        /* [in] */ IUnknown* pUnknownOuter, 
        /* [in] */ REFIID iid, 
        /* [out] */ LPVOID *ppv)
//////////////////////////////////////////////////////////////
//
//    Standard COM CreateInstance
//
//////////////////////////////////////////////////////////////
{
    HRESULT hRes;
    CHiPerfProvider *pProvider = NULL;

    *ppv = NULL;

    // We do not support aggregation
    if (pUnknownOuter) return CLASS_E_NOAGGREGATION;

    // Create the provider object
    pProvider = new CHiPerfProvider;

    if (NULL == pProvider) return E_OUTOFMEMORY;

    // Retrieve the requested interface
    // ================================

    hRes = pProvider->QueryInterface(iid, ppv);
    if (FAILED(hRes))
    {
        delete pProvider;
        return hRes;
    }

    return S_OK;
}

STDMETHODIMP CClassFactory::LockServer(
        /* [in] */ BOOL bLock)
//////////////////////////////////////////////////////////////
//
//    Standard COM LockServer
//
//////////////////////////////////////////////////////////////
{
    if (bLock)
        InterlockedIncrement(&g_lLocks);
    else
        InterlockedDecrement(&g_lLocks);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <stdio.h>
#include <comdef.h>
#include <strsafe.h>

#include <arrtempl.h> 
#include <helper.h>
#include <wbemutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\factory.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    Factory.h

Abstract:

    Standard class factory implementation

History:

    a-dcrews	01-Mar-00	Created

--*/

//////////////////////////////////////////////////////////////
//
//	CClassFactory
//
//////////////////////////////////////////////////////////////

class CClassFactory : public IClassFactory
{
protected:
	long	m_lRef;

public:
	CClassFactory() : m_lRef(0) {}

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IClassFactory COM interfaces
	// ============================

	STDMETHODIMP CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv);	

	STDMETHODIMP LockServer(
		/* [in] */ BOOL bLock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\cookerutils.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//
// CookerUtils.cpp
//

#include "precomp.h"
#include <wbemint.h>
#include "cookerutils.h"
#include "strutils.h"

//////////////////////////////////////////////////////////////
//
//
//    Helper Functions
//
//
//////////////////////////////////////////////////////////////

BOOL IsCookingClass( IWbemClassObject* pCookingClassObject )
{
    HRESULT hResult = WBEM_NO_ERROR;

    IWbemQualifierSet    *pCookingClassQualifierSet = NULL;
    


    hResult = pCookingClassObject->GetQualifierSet( &pCookingClassQualifierSet );
    
    // Verify "AutoCook" qualifier
    // ===========================

    if ( SUCCEEDED( hResult ) )
    {
        CReleaseMe arQualifierSet( (IUnknown*)pCookingClassQualifierSet );

        _variant_t vVal;

        hResult = pCookingClassQualifierSet->Get( WMI_COOKER_AUTOCOOK_QUALIFIER, 0, &vVal, NULL );

        if ( SUCCEEDED( hResult ) )
        {
            if ( vVal.vt != VT_I4  )
            {
                hResult = WBEM_E_INVALID_QUALIFIER;
            } 
            else
            {
                if (WMI_COOKER_VERSION != V_I4(&vVal))
                    hResult = WBEM_E_INVALID_CLASS;                
            }
        }
    }

    return SUCCEEDED( hResult );
}


// Table of the counter types and their Cooking type values
struct _CookingTypeRec
{
    DWORD dwType;
    WCHAR * wcsName;
    DWORD dwReqProp;
}
g_aCookingRecs[] =
{
    0x00000000, L"PERF_COUNTER_RAWCOUNT_HEX", REQ_1VALUE,
    // BEGIN COOKER_ONLY
    0x00000001, L"COOKER_AVERAGE", REQ_2VALUE,
    0x00000002, L"COOKER_MIN", REQ_2VALUE,
    0x00000003, L"COOKER_MAX", REQ_2VALUE,
    0x00000004, L"COOKER_RANGE", REQ_2VALUE,
    0x00000005, L"COOKER_VARIANCE", REQ_2VALUE,
    // END COOKER_ONLY
    0x00000100,    L"PERF_COUNTER_LARGE_RAWCOUNT_HEX", REQ_1VALUE,
    0x00000B00, L"PERF_COUNTER_TEXT", REQ_NONE,
    0x00010000,    L"PERF_COUNTER_RAWCOUNT", REQ_1VALUE,
    0x00010100, L"PERF_COUNTER_LARGE_RAWCOUNT", REQ_1VALUE,
    0x00012000, L"PERF_DOUBLE_RAW", REQ_1VALUE,
    0x00400400,    L"PERF_COUNTER_DELTA", REQ_2VALUE,
    0x00400500,    L"PERF_COUNTER_LARGE_DELTA", REQ_2VALUE,
    0x00410400,    L"PERF_SAMPLE_COUNTER", REQ_2VALUE|REQ_TIME|REQ_FREQ,
    0x00450400, L"PERF_COUNTER_QUEUELEN_TYPE", REQ_2VALUE|REQ_TIME,
    0x00450500, L"PERF_COUNTER_LARGE_QUEUELEN_TYPE", REQ_2VALUE|REQ_TIME,
    0x00550500,    L"PERF_COUNTER_100NS_QUEUELEN_TYPE", REQ_2VALUE|REQ_TIME,
    0x00650500, L"PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE", REQ_2VALUE|REQ_TIME,
    0x10410400,    L"PERF_COUNTER_COUNTER", REQ_2VALUE|REQ_TIME|REQ_FREQ,
    0x10410500,    L"PERF_COUNTER_BULK_COUNT", REQ_2VALUE|REQ_TIME|REQ_FREQ,
    0x20020400, L"PERF_RAW_FRACTION", REQ_1VALUE|REQ_BASE,
    0x20410500,    L"PERF_COUNTER_TIMER", REQ_2VALUE|REQ_TIME,
    0x20470500,    L"PERF_PRECISION_SYSTEM_TIMER", REQ_2VALUE|REQ_TIME,
    0x20510500,    L"PERF_100NSEC_TIMER", REQ_2VALUE|REQ_TIME,
    0x20570500,    L"PERF_PRECISION_100NS_TIMER", REQ_2VALUE|REQ_TIME,
    0x20610500,    L"PERF_OBJ_TIME_TIMER", REQ_2VALUE|REQ_TIME,
    0x20670500, L"PERF_PRECISION_OBJECT_TIMER", REQ_2VALUE|REQ_TIME,
    0x20C20400,    L"PERF_SAMPLE_FRACTION", REQ_2VALUE|REQ_BASE,
    0x21410500,    L"PERF_COUNTER_TIMER_INV", REQ_2VALUE|REQ_TIME,
    0x21510500,    L"PERF_100NSEC_TIMER_INV", REQ_2VALUE|REQ_TIME,
    0x22410500, L"PERF_COUNTER_MULTI_TIMER", REQ_2VALUE|REQ_TIME,
    0x22510500,    L"PERF_100NSEC_MULTI_TIMER", REQ_2VALUE|REQ_TIME,
    0x23410500,    L"PERF_COUNTER_MULTI_TIMER_INV", REQ_2VALUE|REQ_TIME,
    0x23510500, L"PERF_100NSEC_MULTI_TIMER_INV", REQ_2VALUE|REQ_TIME,
    0x30020400,    L"PERF_AVERAGE_TIMER", REQ_2VALUE|REQ_BASE|REQ_FREQ,
    0x30240500,    L"PERF_ELAPSED_TIME", REQ_1VALUE|REQ_TIME|REQ_FREQ,
    0x40000200, L"PERF_COUNTER_NODATA", REQ_NONE,
    0x40020500,    L"PERF_AVERAGE_BULK", REQ_2VALUE|REQ_BASE,
    0x40030401,    L"PERF_SAMPLE_BASE", REQ_NONE,
    0x40030402, L"PERF_AVERAGE_BASE", REQ_NONE,
    0x40030403, L"PERF_RAW_BASE", REQ_NONE,
    0x40030500, L"PERF_PRECISION_TIMESTAMP", REQ_NONE,
    0x40030503,    L"PERF_LARGE_RAW_BASE", REQ_NONE,
    0x42030500,    L"PERF_COUNTER_MULTI_BASE", REQ_NONE,
    0x80000000,    L"PERF_COUNTER_HISTOGRAM_TYPE", REQ_NONE,
};

//
//
// performs a linear search in the above array
//
/////////////////////////////////////////////

HRESULT FindCounterType( WCHAR* pwcsString, DWORD* pdwType, DWORD *pdwReqProp)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    DWORD    dwLeft = 0,
            dwRight = sizeof( g_aCookingRecs ) / sizeof( _CookingTypeRec );

    while ( ( dwLeft < dwRight ) && SUCCEEDED( hRes ) )
    {
        // Found it
        if ( wbem_wcsicmp( g_aCookingRecs[dwLeft].wcsName, pwcsString ) == 0 )
        {
            *pdwType   = g_aCookingRecs[dwLeft].dwType;
            *pdwReqProp = g_aCookingRecs[dwLeft].dwReqProp;
            break;
        }

        dwLeft++;
    }

    if ( dwLeft >= dwRight )
    {
        hRes = WBEM_E_NOT_FOUND;
    }

    return hRes;
}

//
//
//  TRUE if a class has the singleton qualifier set to VARIANT_TRUE
//
////////////////////////////////////////////

BOOL IsSingleton(IWbemClassObject * pCls)
{
    if (pCls)
    {
        HRESULT hr;
        IWbemQualifierSet * pQS = NULL;
        if (SUCCEEDED(hr = pCls->GetQualifierSet(&pQS)))
        {
            CReleaseMe rm1(pQS);            

            _variant_t VarBool;
            hr = pQS->Get(L"singleton",0,&VarBool,NULL);
            
            if (SUCCEEDED(hr) &&
                VarBool.vt == VT_BOOL &&
                V_BOOL(&VarBool) == VARIANT_TRUE)
            {                
                return TRUE;
            }
        }
    }
    return FALSE;
}

//
// returns TRUE if the property qualifier set has the CookingType
// qualifier and if the CookingType is recognized
//
///////////////////////////////////////////////////////////////////

BOOL IsCookingProperty( BSTR strPropName, IWbemClassObject* pCookingClassObject, DWORD* pdwCounterType, DWORD * pdwReqProp )
{
    HRESULT hResult = WBEM_NO_ERROR;

    IWbemQualifierSet*    pPropQualSet = NULL;
    _variant_t    vVal;

    hResult = pCookingClassObject->GetPropertyQualifierSet( (LPCWSTR)strPropName, &pPropQualSet );
    
    if ( SUCCEEDED( hResult ) )
    {
        CReleaseMe    arPropQualSet( (IUnknown*)pPropQualSet );

        hResult = pPropQualSet->Get( WMI_COOKER_COOKING_PROPERTY_ATTRIBUTE, 0, &vVal, NULL );

        if ( SUCCEEDED ( hResult ) )
        {
            if ( vVal.vt == VT_BSTR )
            {
                 hResult = FindCounterType( V_BSTR( &vVal ), pdwCounterType, pdwReqProp );            
            }
            else 
            {
                hResult = E_FAIL;
            }
        }
    }
    
    return SUCCEEDED( hResult );
}


//
//    
//    returns the portion of __RELPATH past the '=' sign
//    return NULL in case of failure
//
///////////////////////////////////////////////////////////////////////////////

LPWSTR GetKey( IWbemObjectAccess* pClassObj )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    LPWSTR    wszKeyName = NULL;
    LPWSTR    wszTempKeyPtr = NULL;
    _variant_t    var;

    dwStatus = pClassObj->Get( L"__RELPATH", 0, &var, NULL, NULL );

    if ( SUCCEEDED( dwStatus ) )
    {
        if ( var.vt != VT_BSTR )
        {
            dwStatus = WBEM_E_FAILED;
        }
        else
        {
            wszTempKeyPtr = wcsstr( var.bstrVal, L"=" );
            wszTempKeyPtr++;

            size_t length =  wcslen( wszTempKeyPtr ) + 1 ;
            wszKeyName = new WCHAR[ length];
            if (wszKeyName)
                StringCchCopyW( wszKeyName, length ,  wszTempKeyPtr );
            else
            {
                // returns NULL
            }
        }
    }

    return wszKeyName;
}

WMISTATUS CopyBlob( IWbemClassObject* pSource, IWbemClassObject* pTarget )
{
    HRESULT dwStatus = E_NOINTERFACE ;
    HRESULT hr1,hr2;
        
    _IWmiObject* pIntTarget = NULL;
    _IWmiObject* pIntSource = NULL;

    hr1 = pTarget->QueryInterface( IID__IWmiObject, (void**)&pIntTarget );
    CReleaseMe arIntTarget( pIntTarget );

    hr2 = pSource->QueryInterface( IID__IWmiObject, (void**)&pIntSource );
    CReleaseMe arIntSource( pIntSource );
    
    if ( SUCCEEDED(hr1) && SUCCEEDED(hr2) )
    {
        dwStatus =  pIntTarget->CopyInstanceData( 0L, pIntSource );
    }

    return dwStatus;
}

//
//
// TRUE if the class/instance derives from Win32_PerfFormattedData
//
/////////////////////////////////////

BOOL IsHiPerfObj(IWbemObjectAccess* pObject)
{
    _variant_t Var;
    HRESULT hr = pObject->Get(L"__SUPERCLASS",0,&Var,NULL,NULL);
    if (SUCCEEDED(hr))
    {
        if (Var.vt == VT_BSTR)
            hr = (0 == wbem_wcsicmp(Var.bstrVal,L"Win32_PerfFormattedData"))?S_OK:E_FAIL; 
        else
          hr = E_FAIL;
    }
    return SUCCEEDED(hr);
}

//
//
// TRUE if an object has the required qualifier to 
// be regarded as an HiPerf CWebminstance
//
////////////////////////////////////////////////

BOOL IsHiPerf( IWbemObjectAccess* pObject )
{
    WMISTATUS    hr = WBEM_NO_ERROR;
    IWbemQualifierSet*    pQualSet = NULL;

    hr = pObject->GetQualifierSet( &pQualSet );
    CReleaseMe    arQualSet( pQualSet );


    // Verify the "Hiperf" class qualifier
    if (SUCCEEDED(hr))
    {
        _variant_t    var;
        hr = pQualSet->Get( WMI_COOKER_HIPERF_QUALIFIER, 0, &var, NULL );
        if ( SUCCEEDED(hr) && ( ( var.vt != VT_BOOL ) || ( var.boolVal != VARIANT_TRUE ) ) )
        {
            hr = WBEM_E_INVALID_QUALIFIER;
        }
    }

    // Verify the "Cooked" class qualifier
    if (SUCCEEDED(hr))
    {
        _variant_t    var;        
        hr = pQualSet->Get( WMI_COOKER_COOKING_QUALIFIER, 0, &var, NULL );
        if ( SUCCEEDED(hr) && ( ( var.vt != VT_BOOL ) || ( var.boolVal != VARIANT_TRUE ) ) )
        {
            hr = WBEM_E_INVALID_QUALIFIER;
        }
    }

    // Verify the "AutoCook" class qualifier
    if (SUCCEEDED(hr))
    {
        _variant_t    var;
        
        hr = pQualSet->Get( WMI_COOKER_AUTOCOOK_QUALIFIER, 0, &var, NULL );
        
        if (SUCCEEDED(hr))
        {
            if ( var.vt != VT_I4 )
            {
                hr = WBEM_E_INVALID_QUALIFIER;
            } 
            else
            {
                if (WMI_COOKER_VERSION != V_I4(&var))
                    hr = WBEM_E_INVALID_CLASS;                
            }
        }
    }

    // Verify the "AutoCook_RawClass" class qualifier
    if (SUCCEEDED(hr))
    {
        _variant_t    var;
        
        hr = pQualSet->Get( WMI_COOKER_RAWCLASS_QUALIFIER, 0, &var, NULL );
        
        if ( SUCCEEDED(hr) && ( var.vt != VT_BSTR ) )
        {
            hr = WBEM_E_INVALID_QUALIFIER;
        }
    }

    // verify the "AutoCook_RawDeafult" class qualifier if there
    if (SUCCEEDED(hr))
    {
        _variant_t    var;
        hr = pQualSet->Get( WMI_COOKER_AUTOCOOK_RAWDEFAULT, 0, &var, NULL );

        if ( SUCCEEDED(hr) )
        {
            if ((var.vt != VT_I4) || 
                (V_I4(&var) != AUTOCOOK_RAWDEFAULT_CURRENT_ACCEPTED))
            {
                hr = WBEM_E_INVALID_QUALIFIER;
            }
            else // good qualifier, see the properties
            {
                HRESULT hr1 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_PERFTIME,0,NULL,NULL,NULL);
                HRESULT hr2 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_SYS100NS,0,NULL,NULL,NULL);
                HRESULT hr3 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_OBJECT  ,0,NULL,NULL,NULL);
                HRESULT hr4 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_PERFTIME,0,NULL,NULL,NULL);
                HRESULT hr5 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_SYS100NS,0,NULL,NULL,NULL);
                HRESULT hr6 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_OBJECT  ,0,NULL,NULL,NULL);

                if (SUCCEEDED(hr1) &&
                    SUCCEEDED(hr2) &&
                    SUCCEEDED(hr3) &&
                    SUCCEEDED(hr4) &&
                    SUCCEEDED(hr5) &&
                    SUCCEEDED(hr6))
                {
                    // ok
                }
                else
                {
                    hr = WBEM_E_INVALID_CLASS;
                }
            }
        }
        else
        {
            // this qualifier is optional
            hr = WBEM_NO_ERROR;
        }
   }
    
    return SUCCEEDED(hr);
}

//
//
// TRUE if the given path points to a class has the required qualifier to 
// be regarded as an HiPerf class
// it also verifies that the AutoCook_RawClass indeed exists and it is hiperf
//
////////////////////////////////////////////////

BOOL IsHiPerf( IWbemServices* pNamespace, LPCWSTR wszObject )
{
    IWbemClassObject* pObject = NULL;

    // Get the WMI object    
    BSTR strObject = SysAllocString(wszObject);
    if (NULL == strObject) return FALSE;
    CSysFreeMe fme(strObject);

    HRESULT hr = pNamespace->GetObject( strObject, 0, NULL, &pObject, NULL );
    CReleaseMe    arObject( pObject );

    if (SUCCEEDED(hr)) 
    {
        IWbemQualifierSet*    pQualSet = NULL;
        hr = pObject->GetQualifierSet( &pQualSet );
        CReleaseMe    arQualSet( pQualSet );

        // Verify the "Hiperf" class qualifier
        if ( SUCCEEDED(hr) )
        {
            _variant_t    var;
            hr = pQualSet->Get( WMI_COOKER_HIPERF_QUALIFIER, 0, &var, NULL );

            if ( SUCCEEDED(hr) && 
                 ( (var.vt != VT_BOOL) || 
                   (var.boolVal != VARIANT_TRUE)) )
            {
                hr = WBEM_E_INVALID_QUALIFIER;
            }
        }

        // Verify the "Cooked" class qualifier
        if ( SUCCEEDED(hr) )
        {
            _variant_t    var;            
            hr = pQualSet->Get( WMI_COOKER_COOKING_QUALIFIER, 0, &var, NULL );
            
            if ( SUCCEEDED(hr) && 
                 ( (var.vt != VT_BOOL) || 
                   (var.boolVal != VARIANT_TRUE)) )
            {
                hr = WBEM_E_INVALID_QUALIFIER;
            }
        }

        // Verify the "AutoCook" class qualifier
        if ( SUCCEEDED(hr) )
        {
            _variant_t    var;    
            hr = pQualSet->Get( WMI_COOKER_AUTOCOOK_QUALIFIER, 0, &var, NULL );
            
            if ( SUCCEEDED(hr) )
            {
                if (var.vt != VT_I4 )
                {
                    hr = WBEM_E_INVALID_QUALIFIER;
                }
                else
                {
                    if (WMI_COOKER_VERSION != V_I4(&var))
                        hr = WBEM_E_INVALID_CLASS;
                }
            }
        }

        // Verify the "AutoCook_RawClass" class qualifier
        // ==============================================

        if ( SUCCEEDED(hr) )
        {        
            _variant_t    varRawClass;
            hr = pQualSet->Get( WMI_COOKER_RAWCLASS_QUALIFIER, 0, &varRawClass, NULL );
            
            if ( SUCCEEDED(hr) )
            {
                if ( varRawClass.vt == VT_BSTR )
                {
                    IWbemClassObject * pRawClass = NULL;
                    hr = pNamespace->GetObject(V_BSTR(&varRawClass),0,NULL,&pRawClass,NULL);
                    CReleaseMe rm1(pRawClass);
                    
                    if (SUCCEEDED(hr))
                    {
                        IWbemQualifierSet * pQS = NULL;
                        hr = pRawClass->GetQualifierSet(&pQS);
                        CReleaseMe rm2(pQS);
                        if (SUCCEEDED(hr))
                        {
                            // verify the hiperf qualifier on the RAW class
                            _variant_t varH;
                            hr = pQS->Get(WMI_COOKER_HIPERF_QUALIFIER, 0, &varH, NULL);
                            if ( SUCCEEDED(hr) && 
                                 ( (varH.vt != VT_BOOL) || 
                                   (varH.boolVal != VARIANT_TRUE)) )
                            {
                                hr = WBEM_E_INVALID_QUALIFIER;
                            };
                        }
                    } 
                    else 
                    {
                        hr = WBEM_E_INVALID_CLASS;
                    }
                } 
                else 
                {
                    hr = WBEM_E_INVALID_QUALIFIER;
                }
            }
        }

        // verify the "AutoCook_RawDeafult" class qualifier if there
        // ==========================================================

        if ( SUCCEEDED(hr) )
        {
            _variant_t    var;
            hr = pQualSet->Get( WMI_COOKER_AUTOCOOK_RAWDEFAULT, 0, &var, NULL );

            if ( SUCCEEDED(hr) )
            {
                if ((var.vt != VT_I4) || 
                    (V_I4(&var) != AUTOCOOK_RAWDEFAULT_CURRENT_ACCEPTED))
                {
                    hr = WBEM_E_INVALID_QUALIFIER;
                }
                else // good qualifier, see the properties
                {
                    HRESULT hr1 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_PERFTIME,0,NULL,NULL,NULL);
                    HRESULT hr2 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_SYS100NS,0,NULL,NULL,NULL);
                    HRESULT hr3 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_OBJECT  ,0,NULL,NULL,NULL);
                    HRESULT hr4 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_PERFTIME,0,NULL,NULL,NULL);
                    HRESULT hr5 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_SYS100NS,0,NULL,NULL,NULL);
                    HRESULT hr6 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_OBJECT  ,0,NULL,NULL,NULL);

                    if (SUCCEEDED(hr1) &&
                        SUCCEEDED(hr2) &&
                        SUCCEEDED(hr3) &&
                        SUCCEEDED(hr4) &&
                        SUCCEEDED(hr5) &&
                        SUCCEEDED(hr6))
                    {
                        // ok
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_CLASS;
                    }
                }
            }
            else
            {
                  // this qualifier is optional
                  hr = WBEM_NO_ERROR;
            }
        }

        return SUCCEEDED(hr);
    
    }    
    return FALSE;    
}

//
//
//    returns pCookingInst->GetQualifierSet()->Get(L"AutoCook_RawClass")
//
//////////////////////////////////


WMISTATUS GetRawClassName( IWbemClassObject* pCookingInst, WCHAR** pwszRawClassName )
{
    WMISTATUS    dwStatus = WBEM_NO_ERROR;

    IWbemQualifierSet*    pQualSet = NULL;    // The Instance qualifier set
    _variant_t                varRawInstName;        // The raw instance name

    dwStatus = pCookingInst->GetQualifierSet( &pQualSet );
    CReleaseMe adQualSet( pQualSet );

    if ( SUCCEEDED( dwStatus ) )
    {
        dwStatus = pQualSet->Get( WMI_COOKER_RAWCLASS_QUALIFIER, 0, &varRawInstName, NULL );

        if ( SUCCEEDED( dwStatus ) )
        {
            if ( VT_BSTR == varRawInstName.vt )
            {
                size_t length = wcslen( varRawInstName.bstrVal ) + 1;
                WCHAR* wszRawClassName = new WCHAR[length];

                if ( NULL != wszRawClassName )
                {
                     StringCchCopyW( wszRawClassName, length , varRawInstName.bstrVal);
                    *pwszRawClassName = wszRawClassName;
                }
                else
                {
                    dwStatus = WBEM_E_OUT_OF_MEMORY;
                }
            }
            else
            {
                dwStatus = WBEM_E_TYPE_MISMATCH;
            }
        }
    }

    return dwStatus;
}

//
//
//    returns pAccess->Get("__CLASS")
//
//////////////////////////////////


WMISTATUS GetClassName( IWbemObjectAccess* pAccess, WCHAR** pwszClassName )
{
    _variant_t    vVal;  
    WMISTATUS dwStatus = pAccess->Get(L"__CLASS", 0, &vVal, NULL, NULL );

    if ( VT_BSTR != V_VT(&vVal)  )
    {
        dwStatus = E_FAIL;
    }

    if ( SUCCEEDED( dwStatus ) )
    {
        size_t length = wcslen( vVal.bstrVal ) + 1;
        WCHAR*    wszClassName = new WCHAR[ length ];

        if ( wszClassName )
        {
            StringCchCopyW( wszClassName, length , vVal.bstrVal );
            *pwszClassName = wszClassName;
        }
        else
        {
            dwStatus = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\cookerutils.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    CookerUtils.h

Abstract:

    Tricks and utilities used by the WMI cooker

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef _COOKERUTILS_H_
#define _COOKERUTILS_H_

typedef DWORD WMISTATUS;	

#include <wbemcli.h>

////////////////////////////////////////////////////////////////
//
//	Macro Definitions
//
////////////////////////////////////////////////////////////////

#define WMI_COOKER_VERSION                          (1)

#define AUTOCOOK_RAWDEFAULT_CURRENT_ACCEPTED        (1)

#define WMI_COOKER_HIPERF_QUALIFIER					L"Hiperf"
#define WMI_COOKER_COOKING_QUALIFIER				L"Cooked"
#define WMI_COOKER_AUTOCOOK_QUALIFIER				L"AutoCook"
#define	WMI_COOKER_RAWCLASS_QUALIFIER				L"AutoCook_RawClass"
#define WMI_COOKER_AUTOCOOK_RAWDEFAULT              L"AutoCook_RawDefault" 

// properties required for AutoCook_RawDefault
#define WMI_COOKER_REQ_TIMESTAMP_PERFTIME           L"TimeStamp_PerfTime"
#define WMI_COOKER_REQ_TIMESTAMP_SYS100NS           L"TimeStamp_Sys100ns"
#define WMI_COOKER_REQ_TIMESTAMP_OBJECT             L"TimeStamp_Object"
#define WMI_COOKER_REQ_FREQUENCY_PERFTIME           L"Frequency_PerfTime"
#define WMI_COOKER_REQ_FREQUENCY_SYS100NS           L"Frequency_Sys100ns"
#define WMI_COOKER_REQ_FREQUENCY_OBJECT             L"Frequency_Object"

#define WMI_COOKER_COUNTER_TYPE						L"CounterType"
#define	WMI_COOKER_COOKING_PROPERTY_ATTRIBUTE		L"CookingType"
#define WMI_COOKER_COOKING_PROPERTY_ATTRIBUTE_TYPE	L"VT_I4"
#define	WMI_COOKER_RAW_COUNTER						L"Counter"
#define	WMI_COOKER_RAW_BASE							L"Base"
#define	WMI_COOKER_RAW_TIME							L"PerfTimeStamp"
#define	WMI_COOKER_RAW_FREQUENCY					L"PerfTimeFreq"
#define WMI_COOKER_SAMPLE_WINDOW					L"SampleWindow"
#define WMI_COOKER_TIME_WINDOW						L"TimeWindow"
#define WMI_COOKER_SCALE_FACT                       L"Scale" 

#define WMI_COOKER_RAW_TIME_SYS                     L"PerfSysTimeStamp"
#define WMI_COOKER_RAW_TIME_100NS                   L"Perf100NSTimeStamp"
#define WMI_COOKER_RAW_TIME_OBJ                     L"PerfObjTimeStamp"
#define WMI_COOKER_RAW_FREQ_SYS                     L"PerfSysTimeFreq"
#define WMI_COOKER_RAW_FREQ_100NS                   L"Perf100NSTimeFreq"
#define WMI_COOKER_RAW_FREQ_OBJ                     L"PerfObjTimeFreq"


////////////////////////////////////////////////////////////////
//
//  Which property have to be defined in the Raw class 
//  for the counter to be cooked
//
////////////////////////////////////////////////////////////////

#define REQ_NONE    0x00
#define REQ_1VALUE  0x01
#define REQ_2VALUE  0x02
#define REQ_TIME    0x04 
#define REQ_FREQ    0x08 
#define REQ_BASE    0x10 


////////////////////////////////////////////////////////////////
//
//	Function Definitions
//
////////////////////////////////////////////////////////////////

BOOL IsSingleton(IWbemClassObject * pCls);

LPWSTR GetKey( IWbemObjectAccess* pObj );

WMISTATUS CopyBlob( IWbemClassObject* pSource, IWbemClassObject* pTarget );

BOOL IsCookingClass( IWbemClassObject* pCookingClassObject );
BOOL IsCookingProperty( BSTR strPropName, IWbemClassObject* pCookingClassObject, DWORD* pdwCounterType, DWORD* pdwReqProp);

BOOL IsHiPerfObj(IWbemObjectAccess* pObject);

BOOL IsHiPerf( IWbemServices* pNamespace, LPCWSTR wszObject );

WMISTATUS GetRawClassName( IWbemClassObject* pCookingInst, WCHAR** pwszRawClassName );

WMISTATUS GetClassName( IWbemObjectAccess* pAccess, WCHAR** pwszClassName );

#endif	// _COOKERUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\provider.cpp ===
////////////////////////////////////////////////////////////////////////
//
//    Provider.cpp
//
//    Module:    WMI high performance provider 
//
//
//  History:
//    a-dcrews      12-Jan-97        Created
//
//    
//  Copyright (c) 1997-2001 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <process.h>
#include <autoptr.h>

#include "Provider.h"
#include "CookerUtils.h"

#include <comdef.h>


//////////////////////////////////////////////////////////////
//
//
//    Global, external and static variables
//
//
//////////////////////////////////////////////////////////////

// The COM object counter (declared in server.cpp)
// ===============================================

extern long g_lObjects;    

//////////////////////////////////////////////////////////////
//
//
//    CHiPerfProvider
//
//
//////////////////////////////////////////////////////////////

CHiPerfProvider::CHiPerfProvider() : m_lRef(0)

{
    // Increment the global COM object counter
    InterlockedIncrement(&g_lObjects);
}

CHiPerfProvider::~CHiPerfProvider()
{
    // Decrement the global COM object counter
    InterlockedDecrement(&g_lObjects);
}

//////////////////////////////////////////////////////////////
//
//                    COM methods
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfProvider::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//    Standard QueryInterface
//
//    Parameters:
//        riid    - the ID of the requested interface
//        ppv        - a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
//ok
{
    if (NULL == ppv) return E_POINTER;
    
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWbemProviderInit*)this;
    else if(riid == IID_IWbemProviderInit)
        *ppv = (LPVOID)(IWbemProviderInit*)this;
    else if (riid == IID_IWbemHiPerfProvider)
        *ppv = (LPVOID)(IWbemHiPerfProvider*)this;
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CHiPerfProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CHiPerfProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}

STDMETHODIMP CHiPerfProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          long lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink)
//////////////////////////////////////////////////////////////////////
//
//  Called once during startup for any one-time initialization.  The 
//    final call to Release() is for any cleanup.
//    
//    The parameters indicate to the provider which namespace it is being 
//    invoked for and which User.  It also supplies a back pointer to 
//    WINMGMT so that class definitions can be retrieved.
//
//    Initialize will create a single template object that can be used 
//    by the provider to spawn instances for QueryInstances.  It will 
//    also initialize our mock data source and set the global ID access 
//    handle.
//    
//    Parameters:
//        wszUser            - The current user.
//        lFlags            - Reserved.
//        wszNamespace    - The namespace for which we are being activated.
//        wszLocale        - The locale under which we are to be running.
//        pNamespace        - An active pointer back into the current namespace
//                            from which we can retrieve schema objects.
//        pCtx            - The user's context object.  We simply reuse this
//                            during any reentrant operations into WINMGMT.
//        pInitSink        - The sink to which we indicate our readiness.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    if (wszNamespace == 0 || pNamespace == 0 || pInitSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    // We now have all the instances ready to go and the name handle 
    // stored.  Tell WINMGMT that we're ready to start 'providing'
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    return WBEM_NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//        pNamespace        - A pointer to the relevant namespace.  Not used.
//        lFlags            - Reserved.
//        ppRefresher        - Receives the requested refresher.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    HRESULT hResult = WBEM_NO_ERROR;

    if ( pNamespace == 0 || ppRefresher == 0 )
        hResult = WBEM_E_INVALID_PARAMETER;

    if ( SUCCEEDED( hResult ) )
    {
        // Construct and initialize a new empty refresher
        // ==============================================

        CRefresher* pNewRefresher = new CRefresher;

        if ( NULL == pNewRefresher )
        {
            hResult = WBEM_E_OUT_OF_MEMORY;
        }
        else if ( !pNewRefresher->IsOK() )
        {
            hResult = WBEM_E_CRITICAL_ERROR;
        }

        if ( SUCCEEDED( hResult ) )
        {
            // Follow COM rules and AddRef() the thing before sending it back
            // ==============================================================

            pNewRefresher->AddRef();
            *ppRefresher = pNewRefresher;
        }
        else
        {
            delete pNewRefresher;
        }
    }
    
    return hResult;
}

STDMETHODIMP CHiPerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to include an object in a refresher.
//
//    Note that the object returned in ppRefreshable is a clone of the 
//    actual instance maintained by the provider.  If refreshers shared
//    a copy of the same instance, then a refresh call on one of the 
//    refreshers would impact the state of both refreshers.  This would 
//    break the refresher rules.    Instances in a refresher are only 
//    allowed to be updated when 'Refresh' is called.
//     
//  Parameters:
//        pNamespace        - A pointer to the relevant namespace in WINMGMT.
//        pTemplate        - A pointer to a copy of the object which is to be
//                            added.  This object itself cannot be used, as
//                            it not owned locally.        
//        pRefresher        - The refresher to which to add the object.
//        lFlags            - Not used.
//        pContext        - Not used here.
//        ppRefreshable    - A pointer to the internal object which was added
//                            to the refresher.
//        plId            - The Object Id (for identification during removal).        
//
//////////////////////////////////////////////////////////////////////
//ok
{
    HRESULT hResult = WBEM_NO_ERROR;

    if ( pNamespace == 0 || pTemplate == 0 || pRefresher == 0 )
        hResult = WBEM_E_INVALID_PARAMETER;

    // Verify hi-perf object
    // =====================

    if ( !IsHiPerfObj( pTemplate ) )
        hResult = WBEM_E_INVALID_CLASS;

    _variant_t VarClass;
    hResult = pTemplate->Get(L"__CLASS",0,&VarClass,NULL,NULL);
    
    if ( SUCCEEDED( hResult ) )
    {
        if (VT_BSTR == V_VT(&VarClass))
        {
            if ( !IsHiPerf( pNamespace, V_BSTR(&VarClass) ) )
            {
                hResult = WBEM_E_INVALID_CLASS;        
            }
        }
        else
        {
            hResult = WBEM_E_INVALID_CLASS;
        }
    }

    if ( SUCCEEDED( hResult ) )
    {
        // The refresher being supplied by the caller is actually
        // one of our own refreshers, so a simple cast is convenient
        // so that we can access private members.
        // =========================================================

        CRefresher *pOurRefresher = ( CRefresher * ) pRefresher;

        // Add the object to the refresher. The ID is set by AddObject
        // ===========================================================
        
        // NB: We are passing a NULL in as the Raw object

        hResult = pOurRefresher->AddInstance( pNamespace, pContext, pTemplate, NULL, ppRefreshable, plId );
    }

    return hResult;
}
   
STDMETHODIMP CHiPerfProvider::CreateRefreshableEnum( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in, string] */ LPCWSTR wszClass,
    /* [in] */ IWbemRefresher* pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext,
    /* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
    /* [out] */ long* plId )
//////////////////////////////////////////////////////////////////////
//
//  Called when an enumerator is being added to a refresher.  The 
//    enumerator will obtain a fresh set of instances of the specified 
//    class every time that refresh is called.
//     
//  Parameters:
//        pNamespace        - A pointer to the relevant namespace.  
//        wszClass        - The class name for the requested enumerator.
//        pRefresher        - The refresher object for which we will add 
//                            the enumerator
//        lFlags            - Reserved.
//        pContext        - Not used here.
//        pHiPerfEnum        - The enumerator to add to the refresher.
//        plId            - A provider specified ID for the enumerator.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    HRESULT hResult = WBEM_NO_ERROR;

    if ( pNamespace == 0 || pRefresher == 0 || pHiPerfEnum == 0 )
        hResult = WBEM_E_INVALID_PARAMETER;

    // Verify hi-perf class
    // =====================

    if ( !IsHiPerf( pNamespace, wszClass ) )
        hResult = WBEM_E_INVALID_CLASS;

    if ( SUCCEEDED( hResult ) )
    {
        // The refresher being supplied by the caller is actually
        // one of our own refreshers, so a simple cast is convenient
        // so that we can access private members.

        CRefresher *pOurRefresher = (CRefresher *) pRefresher;

        // Add the enumerator to the refresher.  The ID is generated by AddEnum
        // ====================================================================

        hResult = pOurRefresher->AddEnum( pNamespace, pContext, wszClass, pHiPerfEnum, plId );
    }

    return hResult;
}

STDMETHODIMP CHiPerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//        pRefresher            - The refresher object from which we are to 
//                                remove the perf object.
//        lId                    - The ID of the object.
//        lFlags                - Not used.
//  
//////////////////////////////////////////////////////////////////////
//ok
{
    HRESULT hResult = WBEM_NO_ERROR;

    if ( pRefresher == 0 )
        hResult = WBEM_E_INVALID_PARAMETER;

    if ( SUCCEEDED( hResult ) )
    {
        // The refresher being supplied by the caller is actually
        // one of our own refreshers, so a simple cast is convenient
        // so that we can access private members.
        // =========================================================

        CRefresher *pOurRefresher = (CRefresher *) pRefresher;

        hResult = pOurRefresher->Remove( lId );
    }

    return hResult;
}

STDMETHODIMP CHiPerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//        pNamespace        - A pointer to the relevant namespace.  This
//                            should not be AddRef'ed.
//        wszClass        - The class name for which instances are required.
//        lFlags            - Reserved.
//        pCtx            - The user-supplied context (not used here).
//        pSink            - The sink to which to deliver the objects.  The objects
//                            can be delivered synchronously through the duration
//                            of this call or asynchronously (assuming we
//                            had a separate thread).  A IWbemObjectSink::SetStatus
//                            call is required at the end of the sequence.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    HRESULT hResult = WBEM_NO_ERROR;

    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        hResult = WBEM_E_INVALID_PARAMETER;

    // Verify hi-perf object
    // =====================

    if ( !IsHiPerf( pNamespace, wszClass ) )
        hResult = WBEM_E_INVALID_CLASS;

    if ( SUCCEEDED( hResult ) )
    {
        IWbemRefresher*    pRefresher = NULL;
        IWbemConfigureRefresher* pConfig = NULL;
        IWbemHiPerfEnum* pHiPerfEnum = NULL;
        IWbemObjectAccess** apAccess = NULL;
        IWbemClassObject** apObject = NULL;

        hResult = CoCreateInstance( CLSID_WbemRefresher, 
                                     NULL, 
                                     CLSCTX_INPROC_SERVER, 
                                     IID_IWbemRefresher, 
                                     (void**) &pRefresher );

        CReleaseMe rm1(pRefresher);

        // Get the refresher configuration interface
        // =========================================

        if ( SUCCEEDED( hResult ) )
        {
            hResult = pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**)&pConfig );
        }
        CReleaseMe rm2(pConfig);

        if ( SUCCEEDED( hResult ) )
        {
            ULONG    uArraySize = 0,
                    uObjRet = 0;

            long    lID = 0;

            hResult = pConfig->AddEnum( pNamespace, wszClass, 0, pCtx, &pHiPerfEnum, &lID );
            CReleaseMe arHiPerfEnum( pHiPerfEnum );

            if ( SUCCEEDED( hResult ) )
            {
                //
                // we needs 2 samples for most of the calculations
                //
                hResult = pRefresher->Refresh( 0L );
                hResult = pRefresher->Refresh( 0L );
            }

            if ( SUCCEEDED( hResult ) )
            {
                hResult = pHiPerfEnum->GetObjects( 0L, 0, NULL, &uObjRet );

                if ( WBEM_E_BUFFER_TOO_SMALL == hResult )
                {
                    uArraySize = uObjRet;

                    wmilib::auto_buffer<IWbemObjectAccess*>  apAccess( new IWbemObjectAccess*[ uObjRet ]);
                    
                    if ( NULL != apAccess.get() )
                    {
                        hResult = pHiPerfEnum->GetObjects( 0L, uArraySize, apAccess.get(), &uObjRet );

                    }
                    else
                    {
                        hResult = WBEM_E_OUT_OF_MEMORY;
                    }

                    if ( SUCCEEDED( hResult ) )
                    {
                        // since IWbemObjectAccess derives from IWbemClassObject cast is OK
                        hResult = pSink->Indicate( uArraySize, (IWbemClassObject **)apAccess.get() );

                        for ( ULONG uIndex = 0; uIndex < uArraySize; uIndex++ )
                        {
                            apAccess[ uIndex ]->Release();
                        }
                    }
                }
            }

            if ( SUCCEEDED( hResult ) )
            {
                pConfig->Remove( lID , 0 );
            }
        }
    }

    pSink->SetStatus(0, hResult, 0, 0);

    return hResult;
} 

STDMETHODIMP CHiPerfProvider::GetObjects( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in] */ long lNumObjects,
    /* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext)
//////////////////////////////////////////////////////////////////////
//
//  Called when a request is made to provide all instances currently 
//    being managed by the provider in the specified namespace.
//     
//  Parameters:
//        pNamespace        - A pointer to the relevant namespace.  
//        lNumObjects        - The number of instances being returned.
//        apObj            - The array of instances being returned.
//        lFlags            - Reserved.
//        pContext        - Not used here.
//
//////////////////////////////////////////////////////////////////////
//ok
{
    // Update objects
    // ==============

    IWbemRefresher*    pRefresher = NULL;
    IWbemConfigureRefresher* pConfig = NULL;
    wmilib::auto_buffer<IWbemClassObject*>    apRefObj(new IWbemClassObject*[lNumObjects]);

    if (0 == apRefObj.get())
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // CoCreate the refresher interface
    // ================================

    HRESULT hResult = CoCreateInstance( CLSID_WbemRefresher, 
                                 NULL, 
                                 CLSCTX_INPROC_SERVER, 
                                 IID_IWbemRefresher, 
                                 (void**) &pRefresher );

    CReleaseMe arRefresher( pRefresher );

    // Get the refresher configuration interface
    // =========================================

    if ( SUCCEEDED( hResult ) )
    {
        hResult = pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**)&pConfig );
    }

    CReleaseMe arConfig( pConfig );

    // Get the object data
    // ===================

    if ( SUCCEEDED( hResult ) )
    {
        long    lIndex = 0,
                lID = 0;

        // Add all of the requested objects to the refresher
        // =================================================

        for ( lIndex = 0; SUCCEEDED( hResult ) && lIndex < lNumObjects; lIndex++ )
        {
            // Verify hi-perf object
            if ( !IsHiPerfObj( apObj[ lIndex ] ) )
                hResult = WBEM_E_INVALID_CLASS;

#ifdef _VERBOSE
            {
                _variant_t VarPath;
                apObj[lIndex]->Get(L"__RELPATH",0,&VarPath,NULL,NULL);
                _variant_t VarName;
                apObj[lIndex]->Get(L"Name",0,&VarName,NULL,NULL);
                DbgPrintfA(0,"%S %S\n",V_BSTR(&VarPath),V_BSTR(&VarName));
            }
#endif            

            if ( SUCCEEDED( hResult ) )
            {
                hResult = pConfig->AddObjectByTemplate( pNamespace, 
                                                        apObj[ lIndex ], 
                                                        0, 
                                                        NULL, 
                                                        &(apRefObj[ lIndex ]), 
                                                        &lID );
                lID = 0;
            }
        }

        if ( SUCCEEDED( hResult ) )
        {
            hResult = pRefresher->Refresh( 0L );
            hResult = pRefresher->Refresh( 0L );
        }

        for ( lIndex = 0; SUCCEEDED( hResult ) && lIndex < lNumObjects; lIndex++ )
        {
            hResult = CopyBlob( apRefObj[lIndex], apObj[lIndex] );
            apRefObj[lIndex]->Release();
        }
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\provider.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    Provider.h

Abstract:

    Implementation of the high performance provider interface

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef _HIPERFPROV_H_
#define _HIPERFPROV_H_

#include <wbemprov.h>
#include "Cache.h"
#include "Refresher.h"

//////////////////////////////////////////////////////////////
//
//
//	Constants and globals
//
//	
//////////////////////////////////////////////////////////////

#define WMI_HPCOOKER_ENUM_FLAG	0x10000000L

//////////////////////////////////////////////////////////////
//
//	CHiPerfProvider
//
//	The provider maintains a single IWbemClassObject to be used 
//	as a template to spawn instances for the Refresher as well
//	as QueryInstances.  It also maintains the static sample 
//	data source which provides all data to the instances.
//
//////////////////////////////////////////////////////////////

class CHiPerfProvider : public IWbemProviderInit, public IWbemHiPerfProvider
{
	long m_lRef;

public:
	CHiPerfProvider();
	~CHiPerfProvider();

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWbemProviderInit COM interface
	// ===============================

	STDMETHODIMP Initialize( 
		/* [unique][in] */ LPWSTR wszUser,
		/* [in] */ long lFlags,
		/* [in] */ LPWSTR wszNamespace,
		/* [unique][in] */ LPWSTR wszLocale,
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink );

	// IWbemHiPerfProvider COM interfaces
	// ==================================

	STDMETHODIMP CreateRefresher( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ long lFlags,
		/* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher );
    
	STDMETHODIMP CreateRefreshableObject( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pContext,
		/* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
		/* [out] */ long __RPC_FAR *plId );
    
	STDMETHODIMP StopRefreshing( 
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lId,
		/* [in] */ long lFlags );

	STDMETHODIMP CreateRefreshableEnum(
		/* [in] */ IWbemServices* pNamespace,
		/* [in, string] */ LPCWSTR wszClass,
		/* [in] */ IWbemRefresher* pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext* pContext,
		/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
		/* [out] */ long* plId);

	STDMETHODIMP QueryInstances( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [string][in] */ WCHAR __RPC_FAR *wszClass,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *pSink );

	STDMETHODIMP GetObjects(
        /* [in] */ IWbemServices* pNamespace,
		/* [in] */ long lNumObjects,
		/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext* pContext);
};


#endif // _HIPERFPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\rawcooker.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    RawCooker.h

Abstract:

    The classes required to perform cooking based on a countertype

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef _RAWCOOKER_H_
#define _RAWCOOKER_H_

#include <wbemint.h>
#include "CookerUtils.h"

//////////////////////////////////////////////////////////////////
//
//	CEquationRecord
//	
//	Contains all of the required information to describe either
//	a predefined or used defined equation
//
//////////////////////////////////////////////////////////////////

typedef __int64* PINT64;

typedef DWORD (APIENTRY PERFCALC)(DWORD, PINT64, PINT64, PINT64, INT64, PINT64);

class CCalcRecord
{
	DWORD		m_dwID;
	PERFCALC	*m_pCalc;

public:
	void Init( DWORD dwID, PERFCALC *pCalc )
	{
		m_dwID = dwID;
		m_pCalc = pCalc;
	}

	DWORD		GetID(){ return m_dwID; }
	PERFCALC*	GetCalc(){ return m_pCalc; }
};

class CCalcTable
{
	long			m_lSize;		// Size of table
	CCalcRecord		m_aTable[7];	// Lookup table

public:
	CCalcTable();
	virtual ~CCalcTable();

	CCalcRecord* GetCalcRecord( DWORD dwCookingType );
};

//////////////////////////////////////////////////////////////////
//
//	CRawCooker
//
//	Represents the cooking mechanism.
//
//////////////////////////////////////////////////////////////////

class CRawCooker : public IWMISimpleCooker
{
	long			m_lRef;				// Reference counter
	
	CCalcTable		m_CalcTable;		// Equation lookup table

	CCalcRecord*	m_pCalcRecord;	// A cache of the last record

public:
	CRawCooker();
	virtual ~CRawCooker();

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWMISimpleCooker COM Interface
	// ==============================

	STDMETHODIMP CookRawValues( 	
		/*[in]	*/	DWORD dwCookingType,
        /*[in] */	DWORD dwNumSamples,
        /*[in] */	__int64* anTimeStamp,
        /*[in] */	__int64* anRawValue,
        /*[in] */	__int64* anBase,
        /*[in] */	__int64 nTimeFrequency,
        /*[in] */   long    Scale,
		/*[out]	*/	__int64* pnResult );

	PERFCALC* GetCalc( DWORD dwCookingType );

	static WMISTATUS APIENTRY _Average( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);

	static WMISTATUS APIENTRY _Min( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);

	static WMISTATUS APIENTRY _Max( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);

	static WMISTATUS APIENTRY _Range( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);
		
	static WMISTATUS APIENTRY _Variance( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);

};

#endif	//_RAWCOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\rawcooker.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


// Cooker.cpp

#include "precomp.h"
#include <winperf.h>
#include "pdh.h"
#include "pdhmsg.h"
#include <pdhicalc.h>

#include "RawCooker.h"

CCalcTable::CCalcTable()
{
    m_lSize = 5;

    // Ordered list based on Perf IDs
    // ==============================

    m_aTable[0].Init( 0x00000001,    CRawCooker::_Average );
    m_aTable[1].Init( 0x00000002,    CRawCooker::_Min );    
    m_aTable[2].Init( 0x00000003,    CRawCooker::_Max );    
    m_aTable[3].Init( 0x00000004,    CRawCooker::_Range );    
    m_aTable[4].Init( 0x00000005,    CRawCooker::_Variance );
    
}

CCalcTable::~CCalcTable()
{
}

CCalcRecord* CCalcTable::GetCalcRecord( DWORD dwCookingType )
{
    CCalcRecord* pCalcRecord = NULL;

    long    left = 0,
            right = m_lSize - 1,
            mid = right / 2;

    DWORD    dwMidVal = 0;

    bool    bFound = FALSE;

    while ( !bFound && ( left <= right ) )
    {
        dwMidVal = m_aTable[mid].GetID();

        if ( dwCookingType < dwMidVal )
        {
            right = mid - 1;
            mid = ( left + right ) / 2;
        }
        else if ( dwCookingType > dwMidVal )
        {
            left = mid + 1;
            mid = ( left + right ) / 2;
        }
        else
        {
            bFound = TRUE;
            pCalcRecord = &m_aTable[mid];
        }
    }

    return pCalcRecord;
}

CRawCooker::CRawCooker() : m_lRef( 1 ), m_pCalcRecord( NULL )
{
}

CRawCooker::~CRawCooker()
{
}

//////////////////////////////////////////////////////////////
//
//                    COM methods
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CRawCooker::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//    Standard QueryInterface
//
//    Parameters:
//        riid    - the ID of the requested interface
//        ppv        - a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
//ok
{
    if (NULL == ppv) return E_POINTER;
       
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWMISimpleCooker*)this;
    else if(riid == IID_IWMISimpleCooker)
        *ppv = (LPVOID)(IWMISimpleCooker*)this;
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CRawCooker::AddRef()
//////////////////////////////////////////////////////////////
//
//    Standard COM AddRef
//
//////////////////////////////////////////////////////////////
//ok
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CRawCooker::Release()
//////////////////////////////////////////////////////////////
//
//    Standard COM Release
//
//////////////////////////////////////////////////////////////
//ok
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}


STDMETHODIMP CRawCooker::CookRawValues(     
        /*[in] */       DWORD dwCookingType,
        /*[in] */       DWORD dwNumSamples,
        /*[in] */    __int64* anTimeStamp,
        /*[in] */    __int64* anRawValue,
        /*[in] */    __int64* anBase,
        /*[in] */    __int64  nTimeFrequency,
        /*[in] */     long   lScale,
        /*[out]*/    __int64* pnResult )
{
    HRESULT hResult = S_OK;

    PDH_STATUS                lRet = 0;
    LPCOUNTERCALC            pCalcFunction = NULL;
    LPCOUNTERSTAT            pStatFunction = NULL;
    PDH_FMT_COUNTERVALUE    fmtValue;
    memset( &fmtValue, 0, sizeof( PDH_FMT_COUNTERVALUE ) );

    if ( AssignCalcFunction( dwCookingType, &pCalcFunction, &pStatFunction ) && ( 2 == dwNumSamples ) )
    {
        PDH_RAW_COUNTER RawValue1;
        PDH_RAW_COUNTER RawValue2;

        RawValue1.CStatus = 0;
        RawValue1.MultiCount = 0;

        RawValue2.CStatus = 0;
        RawValue2.MultiCount = 0;        

        if ((dwCookingType == PERF_RAW_FRACTION) ||
            (dwCookingType == PERF_SAMPLE_FRACTION) ||
            (dwCookingType == PERF_AVERAGE_TIMER) ||
            (dwCookingType == PERF_AVERAGE_BULK)) 
        {
            RawValue1.TimeStamp = *(FILETIME*)&anTimeStamp[0];
            RawValue1.FirstValue = anRawValue[0];
            RawValue1.SecondValue = anBase[0];

            RawValue2.TimeStamp = *(FILETIME*)&anTimeStamp[1];
            RawValue2.FirstValue = anRawValue[1];
            RawValue2.SecondValue = anBase[1];        
        } 
        else 
        {
            RawValue1.TimeStamp = *(FILETIME *)&anBase[0];
            RawValue1.FirstValue = anRawValue[0];
            RawValue1.SecondValue = anTimeStamp[0]; 

            RawValue2.TimeStamp = *(FILETIME *)&anBase[1]; 
            RawValue2.FirstValue = anRawValue[1];
            RawValue2.SecondValue = anTimeStamp[1]; 

        }

        DWORD dwFormat = PDH_FMT_LARGE;
        // do not scale if lScale is 0
        if (!lScale)
        {
            dwFormat |= PDH_FMT_NOSCALE;
        }

        lRet = PdhiComputeFormattedValue( 
                    pCalcFunction,
                    dwCookingType,
                    lScale,
                    dwFormat, //PDH_FMT_NOSCALE | PDH_FMT_LARGE,
                    &RawValue1,
                    &RawValue2,
                    &nTimeFrequency,
                    0,
                    &fmtValue );

        if ( 0 == lRet )
            *pnResult = fmtValue.largeValue;
        else if (lRet == PDH_CALC_NEGATIVE_VALUE ||
                 lRet == PDH_CALC_NEGATIVE_DENOMINATOR) 
        {
            *pnResult = 0;
        } 
        else 
        {
            hResult = lRet; //WBEM_E_FAILED;
        }
    }
    else
    {
        // The last calculation record is cached in an attempt to avoid a new
        // search. A cooking type of zero means "use the last calc record"
        // ==================================================================

        if ( NULL == m_pCalcRecord || ( m_pCalcRecord->GetID() != dwCookingType ) && 
                                      ( m_pCalcRecord->GetID() != 0 ) )
        {
            m_pCalcRecord = m_CalcTable.GetCalcRecord( dwCookingType );

            if ( NULL == m_pCalcRecord )
            {
                hResult = E_FAIL;
            }
        }

        if ( SUCCEEDED( hResult ) )
        {
            // Calculate the result
            // ====================

            PERFCALC*    pCalc = m_pCalcRecord->GetCalc();

            if ( NULL != pCalc )
            {
                hResult = pCalc( dwNumSamples,
                                 anTimeStamp, 
                                 anRawValue,
                                 anBase,
                                 nTimeFrequency, 
                                 pnResult );
            }
        }
    }

    return hResult;
}

//////////////////////////////////////////////////////////////
//
//    Perf Calculations
//
//////////////////////////////////////////////////////////////

WMISTATUS APIENTRY CRawCooker::_Average( DWORD dwNumSamples,
                                         __int64*    anTimeStamp,
                                         __int64*    anRawValue,
                                         __int64*    anBase,
                                         __int64    nTimeFrequency,
                                         __int64*    pnResult)
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    __int64 nVal = 0;

    if ( 0 == dwNumSamples || NULL == pnResult) return WBEM_E_FAILED;

    for ( DWORD dwSample = 0; SUCCEEDED( dwStatus ) && dwSample < dwNumSamples; dwSample++ )
    {
        if ( (0x7FFFFFFFFFFFFFFF - nVal) < anRawValue[dwSample] )
            dwStatus = WBEM_E_INVALID_OPERATION;
        else
            nVal += anRawValue[dwSample];
    }
    
    *pnResult = nVal / dwNumSamples;

    return dwStatus;
}

WMISTATUS APIENTRY CRawCooker::_Min( DWORD dwNumSamples,
                                     __int64*    anTimeStamp,
                                     __int64*    anRawValue,
                                     __int64*    anBase,
                                     __int64    nTimeFrequency,
                                     __int64*    pnResult)
{

    if ( 0 == dwNumSamples || NULL == pnResult) return WBEM_E_FAILED;

    __int64 nVal = anRawValue[0];

    for ( DWORD dwSample = 1;  dwSample < dwNumSamples; dwSample++ )
    {
        if ( anRawValue[dwSample] < nVal )
            nVal = anRawValue[dwSample];
    }
    
    *pnResult = nVal;
    return WBEM_NO_ERROR;

}

WMISTATUS APIENTRY CRawCooker::_Max( DWORD dwNumSamples,
                                     __int64*    anTimeStamp,
                                     __int64*    anRawValue,
                                     __int64*    anBase,
                                     __int64    nTimeFrequency,
                                     __int64*    pnResult)
{

    if ( 0 == dwNumSamples || NULL == pnResult) return WBEM_E_FAILED;


    __int64    nVal = anRawValue[0];

    for ( DWORD dwSample = 1;  dwSample < dwNumSamples; dwSample++ )
    {
        if ( anRawValue[dwSample] > nVal )
            nVal = anRawValue[dwSample];
    }
    
    *pnResult = nVal;

    return WBEM_NO_ERROR;
}

WMISTATUS APIENTRY CRawCooker::_Range( DWORD dwNumSamples,
                                     __int64*    anTimeStamp,
                                     __int64*    anRawValue,
                                     __int64*    anBase,
                                     __int64    nTimeFrequency,
                                     __int64*    pnResult)
{

    if ( 0 == dwNumSamples || NULL == pnResult) return WBEM_E_FAILED;

    __int64    nValMin = anRawValue[0];
    __int64    nValMax = anRawValue[0];


    for ( DWORD dwSample = 1;  dwSample < dwNumSamples; dwSample++ )
    {
        if ( anRawValue[dwSample] > nValMax )
            nValMax = anRawValue[dwSample];
        if ( anRawValue[dwSample] < nValMin )
            nValMin = anRawValue[dwSample];
    }
    
    *pnResult = (nValMax - nValMin);

    return WBEM_NO_ERROR;
}


WMISTATUS APIENTRY CRawCooker::_Variance( DWORD dwNumSamples,
                                     __int64*    anTimeStamp,
                                     __int64*    anRawValue,
                                     __int64*    anBase,
                                     __int64    nTimeFrequency,
                                     __int64*    pnResult)
{

    if ( 0 == dwNumSamples || NULL == pnResult)
    {
        return WBEM_E_FAILED;
    };

    double    SumX_i = 0;
    double    Average = 0;
    
    for ( DWORD dwSample = 0;  dwSample < dwNumSamples; dwSample++ )
    {
        SumX_i += (anRawValue[dwSample]*anRawValue[dwSample]);
        Average += anRawValue[dwSample];
    }
    
    double Tmp = (double(SumX_i/dwNumSamples)  - (double(Average/dwNumSamples)*double(Average/dwNumSamples)));
    *pnResult = __int64(Tmp);

    return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\refresher.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RefreshCooker.h

Abstract:

    The implementation of the refresher

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef	_REFRESHCOOKER_H_
#define _REFRESHCOOKER_H_

#include "Cache.h"
#include "WMIObjCooker.h"

#define WMI_COOKED_ENUM_MASK	0x70000000

typedef CObjRecord<CWMISimpleObjectCooker> TObjectCookerRec;

//
//  a Refresher in the Hi-perf world
//  is a container of Enumerators and Objects-By-Path
//  Since this Refresher is proxy for the Raw Refresher, it holds the Raw one as well
//  All the operations on this Refresher translates into enumerations
//  of the "arrays" of Enumerators and Objects, and then invocation the the distinct
//  refresh-yourself methods.
//  This class offers routine book-keeping function for adding and removing 
//  objects/enumerators from the internal "arrays"
//
///////////////////////////////////////////////////////////////////////
class CRefresher : public IWMIRefreshableCooker, public IWbemRefresher
{
	bool	m_bOK;		// Creation status indicator
	long	m_lRef;		// Object refrence counter

	CCache<CWMISimpleObjectCooker,  TObjectCookerRec>	 m_CookingClassCache; // The cooking class cache

	IWbemRefresher*				m_pRefresher;	
	IWbemConfigureRefresher*	       m_pConfig;		

	CEnumeratorCache			m_EnumCache;

	DWORD                       m_dwRefreshId;

	WMISTATUS SearchCookingClassCache( WCHAR* wszCookingClass, 
			                                             CWMISimpleObjectCooker* & ppObjectCooker );

	WMISTATUS AddRawInstance( IWbemServices* pNamespace,
	                                            IWbemContext * pContext,
	                                            IWbemObjectAccess* pCookingInst, 
	                                            IWbemObjectAccess** ppRawInst );

	WMISTATUS AddRawEnum( IWbemServices* pNamespace, 
	              IWbemContext * pContext,	
			WCHAR * wszRawClassName,
			IWbemHiPerfEnum** ppRawEnum,
			long* plID );

	WMISTATUS CreateObjectCooker( WCHAR* wszCookingClassName,
			IWbemObjectAccess* pCookingAccess, 
			IWbemObjectAccess* pRawAccess,
			CWMISimpleObjectCooker** ppObjectCooker,
			IWbemServices * pNamespace = NULL);

public:

	CRefresher();
	virtual ~CRefresher();
	
	// Non-interface methods
	// =====================

	bool IsOK(){ return m_bOK; }

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWMIRefreshableCooker methods
	// =============================

	STDMETHODIMP AddInstance(
			/*[in]  */ IWbemServices* pNamespace,
			/*[in]  */ IWbemContext * pCtx,
			/*[in]  */ IWbemObjectAccess* pCookingClass,
			/*[in]  */ IWbemObjectAccess* pRefreshableRawInstance,
			/*[out] */ IWbemObjectAccess** ppRefreshableInstance,
			/*[out] */ long* plId
		);

	STDMETHODIMP AddEnum(
			/*[in]  */ IWbemServices* pNamespace,
			/*[in]  */ IWbemContext * pCtx,			
			/*[in,string] */ LPCWSTR szCookingClass,
			/*[in]  */ IWbemHiPerfEnum* pRefreshableEnum,
			/*[out] */ long* plId
		);

	STDMETHODIMP Remove(
			/*[in]  */ long lId
		);

	STDMETHODIMP Refresh();

	// IWbemRefresher methods
	// ======================

	STDMETHODIMP Refresh( /* [in] */ long lFlags );
};

#endif	//_REFRESHCOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\wmicooker.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for wmicooker.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmicooker_h__
#define __wmicooker_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMIRefreshableCooker_FWD_DEFINED__
#define __IWMIRefreshableCooker_FWD_DEFINED__
typedef interface IWMIRefreshableCooker IWMIRefreshableCooker;
#endif 	/* __IWMIRefreshableCooker_FWD_DEFINED__ */


#ifndef __IWMISimpleObjectCooker_FWD_DEFINED__
#define __IWMISimpleObjectCooker_FWD_DEFINED__
typedef interface IWMISimpleObjectCooker IWMISimpleObjectCooker;
#endif 	/* __IWMISimpleObjectCooker_FWD_DEFINED__ */


#ifndef __IWMISimpleCooker_FWD_DEFINED__
#define __IWMISimpleCooker_FWD_DEFINED__
typedef interface IWMISimpleCooker IWMISimpleCooker;
#endif 	/* __IWMISimpleCooker_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "wbemcli.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IWMIRefreshableCooker_INTERFACE_DEFINED__
#define __IWMIRefreshableCooker_INTERFACE_DEFINED__

/* interface IWMIRefreshableCooker */
/* [uuid][object][local][restricted] */ 


EXTERN_C const IID IID_IWMIRefreshableCooker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13ED7E55-8D63-41b0-9086-D0C5C17364C8")
    IWMIRefreshableCooker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddInstance( 
            /* [in] */ IWbemServices *pService,
            /* [in] */ IWbemObjectAccess *pCookingClass,
            /* [in] */ IWbemObjectAccess *pCookingInstance,
            /* [out] */ IWbemObjectAccess **ppRefreshableInstance,
            /* [out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnum( 
            /* [in] */ IWbemServices *pService,
            /* [string][in] */ LPCWSTR szCookingClass,
            /* [in] */ IWbemHiPerfEnum *pRefreshableEnum,
            /* [out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIRefreshableCookerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMIRefreshableCooker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMIRefreshableCooker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMIRefreshableCooker * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddInstance )( 
            IWMIRefreshableCooker * This,
            /* [in] */ IWbemServices *pService,
            /* [in] */ IWbemObjectAccess *pCookingClass,
            /* [in] */ IWbemObjectAccess *pCookingInstance,
            /* [out] */ IWbemObjectAccess **ppRefreshableInstance,
            /* [out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnum )( 
            IWMIRefreshableCooker * This,
            /* [in] */ IWbemServices *pService,
            /* [string][in] */ LPCWSTR szCookingClass,
            /* [in] */ IWbemHiPerfEnum *pRefreshableEnum,
            /* [out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMIRefreshableCooker * This,
            /* [in] */ long lId);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IWMIRefreshableCooker * This);
        
        END_INTERFACE
    } IWMIRefreshableCookerVtbl;

    interface IWMIRefreshableCooker
    {
        CONST_VTBL struct IWMIRefreshableCookerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIRefreshableCooker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIRefreshableCooker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIRefreshableCooker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIRefreshableCooker_AddInstance(This,pService,pCookingClass,pCookingInstance,ppRefreshableInstance,plId)	\
    (This)->lpVtbl -> AddInstance(This,pService,pCookingClass,pCookingInstance,ppRefreshableInstance,plId)

#define IWMIRefreshableCooker_AddEnum(This,pService,szCookingClass,pRefreshableEnum,plId)	\
    (This)->lpVtbl -> AddEnum(This,pService,szCookingClass,pRefreshableEnum,plId)

#define IWMIRefreshableCooker_Remove(This,lId)	\
    (This)->lpVtbl -> Remove(This,lId)

#define IWMIRefreshableCooker_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIRefreshableCooker_AddInstance_Proxy( 
    IWMIRefreshableCooker * This,
    /* [in] */ IWbemServices *pService,
    /* [in] */ IWbemObjectAccess *pCookingClass,
    /* [in] */ IWbemObjectAccess *pCookingInstance,
    /* [out] */ IWbemObjectAccess **ppRefreshableInstance,
    /* [out] */ long *plId);


void __RPC_STUB IWMIRefreshableCooker_AddInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIRefreshableCooker_AddEnum_Proxy( 
    IWMIRefreshableCooker * This,
    /* [in] */ IWbemServices *pService,
    /* [string][in] */ LPCWSTR szCookingClass,
    /* [in] */ IWbemHiPerfEnum *pRefreshableEnum,
    /* [out] */ long *plId);


void __RPC_STUB IWMIRefreshableCooker_AddEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIRefreshableCooker_Remove_Proxy( 
    IWMIRefreshableCooker * This,
    /* [in] */ long lId);


void __RPC_STUB IWMIRefreshableCooker_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIRefreshableCooker_Refresh_Proxy( 
    IWMIRefreshableCooker * This);


void __RPC_STUB IWMIRefreshableCooker_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIRefreshableCooker_INTERFACE_DEFINED__ */


#ifndef __IWMISimpleObjectCooker_INTERFACE_DEFINED__
#define __IWMISimpleObjectCooker_INTERFACE_DEFINED__

/* interface IWMISimpleObjectCooker */
/* [uuid][object][local][restricted] */ 


EXTERN_C const IID IID_IWMISimpleObjectCooker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A239BDF1-0AB1-45a0-8764-159115689589")
    IWMISimpleObjectCooker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ WCHAR *wszCookingClassName,
            /* [in] */ IWbemObjectAccess *pCookingClass,
            /* [in] */ IWbemObjectAccess *pRawClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCookedInstance( 
            /* [in] */ IWbemObjectAccess *pCookedInstance,
            /* [out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCooking( 
            /* [in] */ long lId,
            /* [in] */ IWbemObjectAccess *pSampleInstance,
            /* [in] */ unsigned long dwRefresherId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopCooking( 
            /* [in] */ long lId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Recalc( 
            /* [in] */ unsigned long dwRefresherId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMISimpleObjectCookerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMISimpleObjectCooker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMISimpleObjectCooker * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClass )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ WCHAR *wszCookingClassName,
            /* [in] */ IWbemObjectAccess *pCookingClass,
            /* [in] */ IWbemObjectAccess *pRawClass);
        
        HRESULT ( STDMETHODCALLTYPE *SetCookedInstance )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ IWbemObjectAccess *pCookedInstance,
            /* [out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCooking )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ long lId,
            /* [in] */ IWbemObjectAccess *pSampleInstance,
            /* [in] */ unsigned long dwRefresherId);
        
        HRESULT ( STDMETHODCALLTYPE *StopCooking )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ long lId);
        
        HRESULT ( STDMETHODCALLTYPE *Recalc )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ unsigned long dwRefresherId);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ long lId);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMISimpleObjectCooker * This);
        
        END_INTERFACE
    } IWMISimpleObjectCookerVtbl;

    interface IWMISimpleObjectCooker
    {
        CONST_VTBL struct IWMISimpleObjectCookerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMISimpleObjectCooker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMISimpleObjectCooker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMISimpleObjectCooker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMISimpleObjectCooker_SetClass(This,wszCookingClassName,pCookingClass,pRawClass)	\
    (This)->lpVtbl -> SetClass(This,wszCookingClassName,pCookingClass,pRawClass)

#define IWMISimpleObjectCooker_SetCookedInstance(This,pCookedInstance,plId)	\
    (This)->lpVtbl -> SetCookedInstance(This,pCookedInstance,plId)

#define IWMISimpleObjectCooker_BeginCooking(This,lId,pSampleInstance,dwRefresherId)	\
    (This)->lpVtbl -> BeginCooking(This,lId,pSampleInstance,dwRefresherId)

#define IWMISimpleObjectCooker_StopCooking(This,lId)	\
    (This)->lpVtbl -> StopCooking(This,lId)

#define IWMISimpleObjectCooker_Recalc(This,dwRefresherId)	\
    (This)->lpVtbl -> Recalc(This,dwRefresherId)

#define IWMISimpleObjectCooker_Remove(This,lId)	\
    (This)->lpVtbl -> Remove(This,lId)

#define IWMISimpleObjectCooker_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_SetClass_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ WCHAR *wszCookingClassName,
    /* [in] */ IWbemObjectAccess *pCookingClass,
    /* [in] */ IWbemObjectAccess *pRawClass);


void __RPC_STUB IWMISimpleObjectCooker_SetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_SetCookedInstance_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ IWbemObjectAccess *pCookedInstance,
    /* [out] */ long *plId);


void __RPC_STUB IWMISimpleObjectCooker_SetCookedInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_BeginCooking_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ long lId,
    /* [in] */ IWbemObjectAccess *pSampleInstance,
    /* [in] */ unsigned long dwRefresherId);


void __RPC_STUB IWMISimpleObjectCooker_BeginCooking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_StopCooking_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ long lId);


void __RPC_STUB IWMISimpleObjectCooker_StopCooking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_Recalc_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ unsigned long dwRefresherId);


void __RPC_STUB IWMISimpleObjectCooker_Recalc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_Remove_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ long lId);


void __RPC_STUB IWMISimpleObjectCooker_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_Reset_Proxy( 
    IWMISimpleObjectCooker * This);


void __RPC_STUB IWMISimpleObjectCooker_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMISimpleObjectCooker_INTERFACE_DEFINED__ */


#ifndef __IWMISimpleCooker_INTERFACE_DEFINED__
#define __IWMISimpleCooker_INTERFACE_DEFINED__

/* interface IWMISimpleCooker */
/* [uuid][object][local][restricted] */ 


EXTERN_C const IID IID_IWMISimpleCooker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("510ADF6E-D481-4a64-B74A-CC712E11AA34")
    IWMISimpleCooker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CookRawValues( 
            /* [in] */ DWORD dwCookingType,
            /* [in] */ DWORD dwNumSamples,
            /* [size_is][in] */ __int64 *anTimeStamp,
            /* [size_is][in] */ __int64 *anRawValue,
            /* [size_is][in] */ __int64 *anBase,
            /* [in] */ __int64 nTimeFrequency,
            /* [out] */ __int64 *pnResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMISimpleCookerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMISimpleCooker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMISimpleCooker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMISimpleCooker * This);
        
        HRESULT ( STDMETHODCALLTYPE *CookRawValues )( 
            IWMISimpleCooker * This,
            /* [in] */ DWORD dwCookingType,
            /* [in] */ DWORD dwNumSamples,
            /* [size_is][in] */ __int64 *anTimeStamp,
            /* [size_is][in] */ __int64 *anRawValue,
            /* [size_is][in] */ __int64 *anBase,
            /* [in] */ __int64 nTimeFrequency,
            /* [out] */ __int64 *pnResult);
        
        END_INTERFACE
    } IWMISimpleCookerVtbl;

    interface IWMISimpleCooker
    {
        CONST_VTBL struct IWMISimpleCookerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMISimpleCooker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMISimpleCooker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMISimpleCooker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMISimpleCooker_CookRawValues(This,dwCookingType,dwNumSamples,anTimeStamp,anRawValue,anBase,nTimeFrequency,pnResult)	\
    (This)->lpVtbl -> CookRawValues(This,dwCookingType,dwNumSamples,anTimeStamp,anRawValue,anBase,nTimeFrequency,pnResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMISimpleCooker_CookRawValues_Proxy( 
    IWMISimpleCooker * This,
    /* [in] */ DWORD dwCookingType,
    /* [in] */ DWORD dwNumSamples,
    /* [size_is][in] */ __int64 *anTimeStamp,
    /* [size_is][in] */ __int64 *anRawValue,
    /* [size_is][in] */ __int64 *anBase,
    /* [in] */ __int64 nTimeFrequency,
    /* [out] */ __int64 *pnResult);


void __RPC_STUB IWMISimpleCooker_CookRawValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMISimpleCooker_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\refresher.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


// RefreshCooker.cpp

#include "precomp.h"
#include <wbemint.h>
#include <comdef.h>
#include <autoptr.h>

#include "Refresher.h"
#include "CookerUtils.h"

////////////////////////////////////////////////////////////////////////////
//
//    CRefresher
//    ==========
//
//    The refresher class implements both the IWbemRefresher and the 
//    IWMIRefreshableCooker interfaces.  It contains an instance cache and 
//    an enumerator cache as well as maintaining an internal refresher to
//    track the raw data.
//
////////////////////////////////////////////////////////////////////////////

CRefresher::CRefresher() : 
  m_pRefresher( NULL ),
  m_pConfig( NULL ),
  m_lRef( 0 ),
  m_bOK( FALSE ),
  m_dwRefreshId(0)
{
#ifdef _VERBOSE    
        DbgPrintfA(0,"------------ CRefresher %08x \n",this);
#endif

    WMISTATUS    dwStatus = WBEM_NO_ERROR;

    // Initialize the internal refresher
    // =================================

    dwStatus = CoCreateInstance( CLSID_WbemRefresher, 
                                 NULL, 
                                 CLSCTX_INPROC_SERVER, 
                                 IID_IWbemRefresher, 
                                 (void**) &m_pRefresher );

    // Get the refresher configuration interface
    // =========================================

    if ( SUCCEEDED( dwStatus ) )
    {
        dwStatus = m_pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**)&m_pConfig );
    }

    m_bOK = SUCCEEDED( dwStatus );
}

CRefresher::~CRefresher()
{
    if (m_pRefresher ) m_pRefresher->Release();
    if ( m_pConfig ) m_pConfig->Release();
}

///////////////////////////////////////////////////////////////////////////////
//
//    Private methods
//
///////////////////////////////////////////////////////////////////////////////

WMISTATUS CRefresher::SearchCookingClassCache( 
        WCHAR* wszCookingClass, 
        /*out*/ CWMISimpleObjectCooker* & pObjectCooker_out )
///////////////////////////////////////////////////////////////////////////////
//
//    SearchCookingClassCache enumerates the cache looking for a class name
//    that matches the wszCookingClass parameter
//
//    Parameters:
//        wszCookingClass    - The name of the WMI cooking class 
//        ppObjectCooker    - The instance of the object cooker
//
///////////////////////////////////////////////////////////////////////////////
{
    WMISTATUS    dwStatus = WBEM_E_NOT_FOUND;

    CWMISimpleObjectCooker*    pObjectCooker = NULL;

    // Enumerate through the cache looking for the record
    m_CookingClassCache.BeginEnum();

    while ( S_OK == m_CookingClassCache.Next( &pObjectCooker ) )
    {
        // Compare the names
        // =================
        if ( 0 == wbem_wcsicmp( pObjectCooker->GetCookingClassName(), wszCookingClass ) )
        {
            pObjectCooker_out = pObjectCooker;
            dwStatus = WBEM_NO_ERROR;
            break;
        }
    }

    m_CookingClassCache.EndEnum();

    return dwStatus;
}

WMISTATUS CRefresher::CreateObjectCooker( 
        WCHAR* wszCookingClassName,
        IWbemObjectAccess* pCookingAccess, 
        IWbemObjectAccess* pRawAccess,
        CWMISimpleObjectCooker** ppObjectCooker,
        IWbemServices * pNamespace)
///////////////////////////////////////////////////////////////////////////////
//
//    CreateObjectCooker will create and initialize a new object cooker and add
//    it to the cache
//
//    Parameters:
//        pNamespace        - The namespace pointer where the objects are located
//        pCookingAccess    - The WMI cooking object in need of a cooker
//        wszCookingClassName
//                        - The name of the cooking class
//        ppObjectCooker    - The parameter to pass back the new object cooker
//    
///////////////////////////////////////////////////////////////////////////////
{
    if (NULL == ppObjectCooker) return WBEM_E_INVALID_PARAMETER;
        
    CWMISimpleObjectCooker* pObjectCooker = NULL;
    WCHAR*    wszRawClassName;
    long lID;

    pObjectCooker = new CWMISimpleObjectCooker( wszCookingClassName, pCookingAccess, pRawAccess, pNamespace );

    if ( NULL == pObjectCooker ) return WBEM_E_OUT_OF_MEMORY;

    WMISTATUS  dwStatus = pObjectCooker->GetLastHR();


    // Add the object cooker to the cache
    if ( SUCCEEDED( dwStatus ) )
    {
        dwStatus = m_CookingClassCache.Add( pObjectCooker, wszCookingClassName, &lID );
    }

    if (FAILED(dwStatus))
    {
        delete pObjectCooker;
        pObjectCooker = NULL;
    }

    *ppObjectCooker = pObjectCooker;

    return dwStatus;
}

WMISTATUS CRefresher::AddRawInstance( 
        IWbemServices* pService, 
        IWbemContext * pCtx,
        IWbemObjectAccess* pCookingInst, 
        IWbemObjectAccess** ppRawInst )
///////////////////////////////////////////////////////////////////////////////
//
//    AddRawInstance is called to add the corresponding raw instance of a 
//    cooked object to the internal refresher.  We first extract the key value 
//    from the cooked object and create the raw instance path using the raw
//    class name
//
//    Parameters:
//        pService        - The namespace pointer where the objects are located
//        pCookingInst    - The WMI cooking instance
//        ppRawInst        - The WMI raw instance that was added to the internal 
//                            refresher
//
///////////////////////////////////////////////////////////////////////////////
{
    WMISTATUS    dwStatus = WBEM_NO_ERROR;

    IWbemClassObject*    pObj = NULL;    // The alternate representation of pCookingInst
    _variant_t varRelPath;                    // The RELPATH value
    WCHAR*    wszRawClassName = NULL;        // The name of the raw class
        
    // Get the fully specified instance path for the cooking object
    // ============================================================

    pCookingInst->QueryInterface( IID_IWbemClassObject, (void**)&pObj );
    CReleaseMe    arObj( pObj );

    dwStatus = pObj->Get( L"__RELPATH", 0, &varRelPath, NULL, NULL );

    if ( SUCCEEDED( dwStatus ) )
    {
        // Verify the property type
        // ========================
        if ( varRelPath.vt != VT_BSTR )
        {
            dwStatus = WBEM_E_TYPE_MISMATCH;
        }

        if ( SUCCEEDED( dwStatus ) )
        {
            IWbemClassObject*    pRawInst = NULL;
            WCHAR*                wszKeys = NULL;
            WCHAR*                wszRawInst = NULL;

            // Extract the key name
            // ====================
            wszKeys = wcsstr( varRelPath.bstrVal, L"=" ) + 1;

            // Get the raw class name
            // ======================
            dwStatus = GetRawClassName( pCookingInst, &wszRawClassName );

            if (SUCCEEDED(dwStatus)) 
            {
                wmilib::auto_buffer<WCHAR>    adRawClassName( wszRawClassName );


                // Append the key to the raw class name
                // ====================================
                size_t length = wcslen( wszRawClassName ) + wcslen( wszKeys ) + 10;
                wszRawInst = new WCHAR[ length ];
                if (!wszRawInst)
                    return WBEM_E_OUT_OF_MEMORY;
                wmilib::auto_buffer<WCHAR>    adRawInst( wszRawInst );

                StringCchPrintfW( wszRawInst, length ,  L"%s=%s", wszRawClassName, wszKeys );
            
                // Add a raw instance to the internal refresher
                // ============================================

                dwStatus = m_pConfig->AddObjectByPath( pService, wszRawInst, 0, pCtx, &pRawInst, NULL );
                CReleaseMe    arRawInst( pRawInst );

                if (SUCCEEDED(dwStatus)) {
                    // Return the IWbemObjectAccess interface of the raw instance
                    // ==========================================================
                    dwStatus = pRawInst->QueryInterface( IID_IWbemObjectAccess, (void**)ppRawInst );                    
                }
            }
        }
    }
    
    return dwStatus;
}

WMISTATUS CRefresher::AddRawEnum( 
        IWbemServices* pNamespace, 
        IWbemContext * pCtx,
        WCHAR * wszRawClassName,  
        IWbemHiPerfEnum** ppRawEnum,
        long* plID )
///////////////////////////////////////////////////////////////////////////////
//
//    AddRawEnum is called to add the corresponding raw enumerator to the 
//    internal refrehser.  In order to add the raw enumerator to the refresher,
//    we must determine the raw class name, therefore, we must create a
//    cooking class in order to get the AutoCook_RawClass qualifier.
//
//    Parameters:
//        pNamespace        - The namespace pointer where the objects are located
//        wszRawClassName    - The name of the cooking class
//        ppRawEnum        - The raw WMI enumerator that was added to the 
//                            internal refresher
//        plID            - The refresher ID of the raw enumerator
//
///////////////////////////////////////////////////////////////////////////////
{
    // Add the Raw enumerator to the internal refresher
    WMISTATUS dwStatus = m_pConfig->AddEnum( pNamespace, wszRawClassName, 0, pCtx, ppRawEnum, plID );

#ifdef _VERBOSE
    DbgPrintfA(0,"wszRawClassName %S pEnum %08x hr %08x\n",wszRawClassName,*ppRawEnum,dwStatus);
#endif        

    return dwStatus;
}

///////////////////////////////////////////////////////////////////////////////
//
//                    COM methods
//
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRefresher::QueryInterface(REFIID riid, void** ppv)
///////////////////////////////////////////////////////////////////////////////
//
//    Standard QueryInterface
//
//    Parameters:
//        riid    - the ID of the requested interface
//        ppv        - a pointer to the interface pointer
//
///////////////////////////////////////////////////////////////////////////////
//ok
{
    if (NULL == ppv) return E_POINTER;
        
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWMIRefreshableCooker*)this;
    else if(riid == IID_IWMIRefreshableCooker)
        *ppv = (LPVOID)(IWMIRefreshableCooker*)this;
    else if(riid == IID_IWbemRefresher)
        *ppv = (LPVOID)(IWbemRefresher*)this;
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CRefresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CRefresher::Release()

{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}


STDMETHODIMP CRefresher::AddInstance(
    /*[in]  */ IWbemServices* pNamespace,                    // The object's namespace
    /*[in]  */ IWbemContext * pCtx,                         // The Context             
    /*[in]  */ IWbemObjectAccess* pCookingInstance,            // Cooking class definition
    /*[in]  */ IWbemObjectAccess* pRefreshableRawInstance,    // Raw instance 
    /*[out] */ IWbemObjectAccess** ppRefreshableInstance,    // Cooking instance
    /*[out] */ long* plId )
///////////////////////////////////////////////////////////////////////////////
//
//    AddInstance is called to add a WMI cooking instance to the refresher.  The 
//    refreshable instance is a clone of the WMI instance that is passed in 
//    by pCookingInstance.  Once the instance is cloned, the corresponding raw 
//    instance is added to the internal refresher, and then the cloned 
//    cooked instance and the refreshable raw instance are added to the object
//    cooker.  If a cooker does not already exist in the cooker cache, one 
//    is created.
//
//    Parameters:
//        pNamespace        - The namespace where the objects are located
//      pCtx            - IWbemContext implementation
//        pCookingInstance    - The instance to be cooked
//        pRefreshableRawInstance 
//                        -             U N U S E D   P A R A M
//        ppRefreshableInstance
//                        - The refreshable cooking instance passed back to 
//                            the client                      
//        plId            - The ID of the instance
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hResult = S_OK;

    CWMISimpleObjectCooker*    pObjectCooker = NULL;
    IWbemObjectAccess*        pInternalRawInst = NULL;    // The raw instance for the short term local refresher solution

    // For now, we expect that the pRefreshableRawInstance parameter will be NULL 
    // since we are using an internal refresher to manage the raw instances
    // ==========================================================================

    if ( NULL == pNamespace || NULL == pCookingInstance || NULL != pRefreshableRawInstance )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    IWbemClassObject*    pNewClassObj = NULL;
    IWbemClassObject*    pClassObj = pCookingInstance;
    pClassObj->AddRef();
    CReleaseMe arClassObj( pClassObj );
    
    hResult = pClassObj->Clone( &pNewClassObj );
    if (SUCCEEDED(hResult)) 
    {
        CReleaseMe arNewClassObj( pNewClassObj );
        hResult = pNewClassObj->QueryInterface( IID_IWbemObjectAccess, (void**)ppRefreshableInstance );

        // Add the instance to the object cooker
        if ( SUCCEEDED( hResult ) )
        {

            // Get the raw instance (add it to the internal refresher)
            hResult = AddRawInstance( pNamespace, pCtx, *ppRefreshableInstance, &pInternalRawInst );
            CReleaseMe    arInternalRawInst( pInternalRawInst );

             // Retrieve the class cooker        
            if ( SUCCEEDED( hResult ) )
            {
                WCHAR*    wszClassName = NULL;
                // Get the cooked class' name
                hResult = GetClassName( pCookingInstance, &wszClassName );
                wmilib::auto_buffer<WCHAR>    adaClassName( wszClassName );

                if ( SUCCEEDED( hResult ) )
                {
                
                    // Search for an existing cooking cache object
                    hResult = SearchCookingClassCache( wszClassName, pObjectCooker );

                    // If it does not exist, create a new one
                    if ( FAILED ( hResult ) ) 
                    {
                        hResult = CreateObjectCooker( wszClassName, pCookingInstance, pInternalRawInst, &pObjectCooker, pNamespace );
                    }
                }
            }
        }

        // Add the cooking instance 
        if ( SUCCEEDED( hResult ) )
        {
            hResult = pObjectCooker->SetCookedInstance( *ppRefreshableInstance, plId );

            if ( SUCCEEDED( hResult ) )
            {
                // Add the raw instance to the cooker
                hResult = pObjectCooker->BeginCooking( *plId, pInternalRawInst, m_dwRefreshId );
            }
        }
    }
    
    return hResult;
}

STDMETHODIMP CRefresher::AddEnum(
    /*[in]  */ IWbemServices* pNamespace,
    /*[in]  */ IWbemContext * pContext,
    /*[in, string]  */ LPCWSTR wszCookingClass,
    /*[in]  */ IWbemHiPerfEnum* pRefreshableEnum,
    /*[out] */ long* plId )
///////////////////////////////////////////////////////////////////////////////
//
//    AddEnum is called whenever a new cooked enumerator is added to the 
//    refresher.  WMI passes an IWbemHiPerfEnum object to the provider which
//    will be used for the cooked enumerator.  The corresponding raw enumerator 
//    is obtained when the added to the internal refresher.  Both of these 
//    enumerators as well as a cooking class template is added to the 
//    enumerator cache.
//
//    Parameters:
//        pNamespace        - The namespace where the objects are located
//        wszCookingClass - The name of the enumerators' cooking class 
//        pRefreshableEnum
//                        - The enumerator to be used for the cooked classes
//        plId            - The ID of the enumerator
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hResult = WBEM_NO_ERROR;

    IWbemHiPerfEnum*    pRawEnum = NULL;
    long lRawID = 0;

    // Verify our 'in' parameters
    // ==========================

    if ( NULL == pNamespace || NULL == wszCookingClass || NULL == pRefreshableEnum )
    {
        hResult = WBEM_E_INVALID_PARAMETER;
    }

    if ( SUCCEEDED( hResult ) )
    {
        // Get the cooking object
        // ======================

        IWbemClassObject*    pCookedObject = NULL;
        IWbemClassObject*    pRawObject = NULL;

        BSTR strCookedClassName = SysAllocString( wszCookingClass );
        if (NULL == strCookedClassName) return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe    afCookedClassName( strCookedClassName );

        hResult = pNamespace->GetObject( strCookedClassName, 0, NULL, &pCookedObject, NULL );
        CReleaseMe    arCookedObject( pCookedObject );        

        if ( SUCCEEDED( hResult ) )
        {
            WCHAR*    wszRawClassName = NULL;
            hResult = GetRawClassName( pCookedObject, &wszRawClassName );
            wmilib::auto_buffer<WCHAR> adRawClassName( wszRawClassName );

            if ( SUCCEEDED( hResult ))
            {                
                BSTR strRawClassName = SysAllocString(wszRawClassName);
                if (NULL == strRawClassName) return WBEM_E_OUT_OF_MEMORY;
                CSysFreeMe sfm(strRawClassName);

                hResult = pNamespace->GetObject( strRawClassName, 0, NULL, &pRawObject, NULL );        
                if ( SUCCEEDED( hResult ) )
                {
                    CReleaseMe    arRawObject( pRawObject );
                    // Add the raw enumerator to our internal refresher
                    // ================================================

                    hResult = AddRawEnum( pNamespace, pContext, wszRawClassName, &pRawEnum, &lRawID );
                    CReleaseMe arRawEnum( pRawEnum );

                    if ( SUCCEEDED( hResult ) )
                    {
                        // Add the cooked enumerator to the enumerator cache
                        // =================================================
                        hResult = m_EnumCache.AddEnum( 
                            wszCookingClass, 
                            pCookedObject,    // this is acquired by CWMISimpleObjectCooker and CEnumeratorManager
                            pRawObject,
                            pRefreshableEnum, 
                            pRawEnum, 
                            lRawID, 
                            (DWORD*)plId );
                        // set the three bits 
                        *plId |= WMI_COOKED_ENUM_MASK;
                    }
                }
            }
        }
    }

    return hResult;
}

STDMETHODIMP CRefresher:: Remove(
            /*[in]  */ long lId )
///////////////////////////////////////////////////////////////////////////////
//
//    Remove is used to remove an object from the refresher.  Depending on the
//    object, the corresponding removal is performed.
//    
//    Parameters:
//        lID            - The ID of the object to be removed
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hResult = S_OK;

    // Is it an instance ID?
    // =====================

    if ( lId == ( lId & ~WMI_COOKED_ENUM_MASK ) )
    {
        CWMISimpleObjectCooker*    pCooker = NULL;

        hResult = m_CookingClassCache.BeginEnum();

        while ( S_OK == m_CookingClassCache.Next( &pCooker ) )
        {
            pCooker->Remove( lId );
        }

        hResult = m_CookingClassCache.EndEnum();
    }
    else
    {
        long RawId;
        hResult = m_EnumCache.RemoveEnum( (lId & ~WMI_COOKED_ENUM_MASK) , &RawId );
        if (SUCCEEDED(hResult)){
            m_pConfig->Remove(RawId,0);
        }

    }

    return hResult;
}

STDMETHODIMP CRefresher::Refresh()
///////////////////////////////////////////////////////////////////////////////
//
//    Refresh is called when the refreshers' objects are to be updated.  The 
//    instances are updated by explicitly enumerating through the instance
//    cache.  The enumerators' refresh is performed with the enumerator
//    cache.
//
//    Parameters: (none)
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hResult = S_OK;

    CWMISimpleObjectCooker*    pCooker = NULL;

    // Refresh the internal refresher
    // ==============================

    m_dwRefreshId++;

    hResult = m_pRefresher->Refresh( 0L );

    if ( SUCCEEDED( hResult ) )
    {
        // INSTANCES: Update the instance values for every class
        // =====================================================

        hResult = m_CookingClassCache.BeginEnum();

        while ( S_OK == m_CookingClassCache.Next( &pCooker ) )
        {
            // And update all of the instances
            // ===============================

            pCooker->Recalc(m_dwRefreshId);
        }

        hResult = m_CookingClassCache.EndEnum();

        // ENUMERATORS: Merge and update the values for items in the enumerator
        // ====================================================================

        if ( SUCCEEDED( hResult ) )
        {
            hResult = m_EnumCache.Refresh(m_dwRefreshId);
        }
    }

    return hResult;
}

STDMETHODIMP CRefresher::Refresh( long lFlags )
///////////////////////////////////////////////////////////////////////////////
//
//    This is the IWbemRefresher::Refresh implementation and is simply a call 
//    through.
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hResult = WBEM_NO_ERROR;

    hResult = Refresh();

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\wmiobjcooker.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIObjCooker.h

Abstract:

    The implementation of per object cooking

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef _WMIOBJCOOKER_H_
#define _WMIOBJCOOKER_H_

#include <wbemint.h>
#include <wstlallc.h>
#include "CookerUtils.h"
#include "Cache.h"

#define WMI_DEFAULT_SAMPLE_WINDOW			2

//
//
//
//
//////////////////////////////////////////////////////////////////

WMISTATUS GetPropValue( CProperty* pProp, IWbemObjectAccess* pInstance, __int64 & nResult );


//////////////////////////////////////////////////////////////////
//
//	CWMISimpleObjectCooker
//
//////////////////////////////////////////////////////////////////

class CWMISimpleObjectCooker : public IWMISimpleObjectCooker
{
	long				m_lRef;				// Reference Counter
	HRESULT             m_InitHR;           // to hold the failure within the constructor

	IWbemObjectAccess*	m_pCookingClass;	// The cooking class
	WCHAR*				m_wszClassName;		// The cooking class' name

	IWbemServices * m_pNamespace;	

	// Instance Management
	// ===================

    DWORD m_NumInst;
	IdCache<CCookingInstance *>	m_InstanceCache;	// The cooking instance cache

	// Cooking Property Definition Management
	// ======================================
	
	std::vector<CCookingProperty*, wbem_allocator<CCookingProperty*> > m_apPropertyCache;
	DWORD				m_dwPropertyCacheSize;
	DWORD				m_dwNumProperties;	// The number of properties

	// Private Methods
	// ===============

	WMISTATUS GetData( CCookingProperty* pProperty, 
					   __int64** panRawCounter, 
					   __int64** panRawBase, 
					   __int64** panRawTimeStamp,
					   DWORD* pdwNumEls );

	WMISTATUS UpdateSamples( CCookingInstance* pCookedInstance,DWORD dwRefreshStamp);
	WMISTATUS CookInstance( CCookingInstance* pCookingRecord, DWORD dwRefreshStamp);

public:

	CWMISimpleObjectCooker();
	CWMISimpleObjectCooker( WCHAR* wszCookingClassName, 
	                        IWbemObjectAccess* pCookingClass, 
	                        IWbemObjectAccess* pRawClass,
	                        IWbemServices * pNamespace = NULL);
	virtual ~CWMISimpleObjectCooker();
	
	WCHAR* GetCookingClassName(){ return m_wszClassName; }
	HRESULT GetLastHR(){ return m_InitHR; }

	WMISTATUS SetProperties( IWbemClassObject* pCookingClassObject, IWbemObjectAccess *pRawClass );

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWMISimpleObjectCooker COM Interface
	// ====================================

	STDMETHODIMP SetClass( 
		/*[in]	*/ WCHAR* wszCookingClassName,
		/*[in]  */ IWbemObjectAccess *pCookingClass,
		/*[in]  */ IWbemObjectAccess *pRawClass);
        
	STDMETHODIMP SetCookedInstance( 
		/*[in]  */ IWbemObjectAccess *pCookedInstance,
		/*[out] */ long *plId
		);
        
	STDMETHODIMP BeginCooking( 
		/*[in]  */ long lId,
		/*[in]  */ IWbemObjectAccess *pSampleInstance,
		/*[in]  */ unsigned long dwRefresherId);
        
	STDMETHODIMP StopCooking( 
		/*[in]  */ long lId);
        
	STDMETHODIMP Recalc(/*[in]  */ unsigned long dwRefresherId);
        
	STDMETHODIMP Remove( 
		/*[in]  */ long lId);
        
	STDMETHODIMP Reset();
};

#endif	//_WMIOBJCOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\coreutil.cpp ===
#include <wmiexts.h>
#include <oleauto.h> // for BSTR definition
#include <malloc.h>

#include <helper.h>
#include <autoptr.h>

#include "utilfun.h"

#ifndef COREPROX_POLARITY
#define COREPROX_POLARITY
#endif


#include <wbemint.h>
#include <var.h>

typedef void IWbemCallSecurity;

#ifndef INTERNAL
#define INTERNAL
#endif

#ifndef ADDREF
#define ADDREF
#endif

#ifndef READONLY
#define READONLY
#endif

#ifdef GetContext
#undef GetContext
#endif

#include <coreq.h>
#include <wbemq.h>

typedef void IWmiDbSession;
typedef void IWmiDbController;
typedef void IWmiDbHandle;
typedef void CWbemObject;
typedef void CWbemClass;
typedef void CWbemInstance;

class CWbemNamespace;
typedef void * PF_FilterForwarder;

#define ReleaseIfNotNULL

class CAsyncReq;
class ParsedObjectPath;
class CWmiMerger;

#include <winntsec.h>
#include <wstring.h>
#include <sinks.h>
#include <dynasty.h>
#include <ql.h>
#include <wbemname.h>

#include <wmitask.h>

class CAsyncReq : public CWbemRequest
{
protected:
    CStdSink *m_pHandler;
    long m_lRequestHandle;
};

class CAsyncServiceQueue : public CWbemQueue{
};

/*
class CFlexArray {
private:
   DWORD  m_nSize;
   DWORD  m_nExtent;
   DWORD  m_nGrowByPercent;
   void * m_pArray;
}
*/

/*
typedef 
enum tag_WMI_TASK_TYPE
    {	WMICORE_TASK_NULL	= 0,
	WMICORE_TASK_GET_OBJECT	= 1,
	WMICORE_TASK_GET_INSTANCE	= 2,
	WMICORE_TASK_PUT_INSTANCE	= 3,
	WMICORE_TASK_DELETE_INSTANCE	= 4,
	WMICORE_TASK_ENUM_INSTANCES	= 5,
	WMICORE_TASK_GET_CLASS	= 6,
	WMICORE_TASK_PUT_CLASS	= 7,
	WMICORE_TASK_DELETE_CLASS	= 8,
	WMICORE_TASK_ENUM_CLASSES	= 9,
	WMICORE_TASK_EXEC_QUERY	= 10,
	WMICORE_TASK_EXEC_METHOD	= 11,
	WMICORE_TASK_OPEN	= 12,
	WMICORE_TASK_OPEN_SCOPE	= 13,
	WMICORE_TASK_OPEN_NAMESPACE	= 14,
	WMICORE_TASK_OPEN_COLLECTION	= 15,
	WMICORE_TASK_ADD	= 16,
	WMICORE_TASK_REMOVE	= 17,
	WMICORE_TASK_REFRESH_OBJECT	= 18,
	WMICORE_TASK_RENAME_OBJECT	= 19,
	WMICORE_TASK_ATOMIC_DYN_INST_GET	= 20,
	WMICORE_TASK_ATOMIC_DYN_INST_ENUM	= 21,
	WMICORE_TASK_ATOMIC_DYN_INST_QUERY	= 22,
	WMICORE_TASK_ATOMIC_DYN_INST_PUT	= 23,
	WMICORE_TASK_DYN_CLASS_ENUM	= 24,
	WMICORE_TASK_EXEC_NOTIFICATION_QUERY	= 25,
	WMICORE_TASK_TYPE_SYNC	= 0x1000000,
	WMICORE_TASK_TYPE_SEMISYNC	= 0x2000000,
	WMICORE_TASK_TYPE_ASYNC	= 0x4000000,
	WMICORE_TASK_TYPE_PRIMARY	= 0x10000000,
	WMICORE_TASK_TYPE_SUBTASK	= 0x20000000,
	WMICORE_TASK_TYPE_DEPENDENT	= 0x40000000
    } 	WMI_TASK_TYPE;

typedef 
enum tag_WMICORE_TASK_STATUS
    {	WMICORE_TASK_STATUS_NEW	= 1,
	WMICORE_TASK_STATUS_VALIDATED	= WMICORE_TASK_STATUS_NEW + 1,
	WMICORE_TASK_STATUS_SUSPENDED	= WMICORE_TASK_STATUS_VALIDATED + 1,
	WMICORE_TASK_STATUS_EXECUTING	= WMICORE_TASK_STATUS_SUSPENDED + 1,
	WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS	= WMICORE_TASK_STATUS_EXECUTING + 1,
	WMICORE_TASK_STATUS_TIMED_OUT	= WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS + 1,
	WMICORE_TASK_STATUS_CORE_COMPLETED	= WMICORE_TASK_STATUS_TIMED_OUT + 1,
	WMICORE_TASK_STATUS_CLIENT_COMPLETED	= WMICORE_TASK_STATUS_CORE_COMPLETED + 1,
	WMICORE_TASK_STATUS_CANCELLED	= WMICORE_TASK_STATUS_CLIENT_COMPLETED + 1,
	WMICORE_TASK_STATUS_FAILED	= WMICORE_TASK_STATUS_CANCELLED + 1
    } 	WMICORE_TASK_STATUS;

*/


//typedef void CWbemNamespace;

char * GetTaskStatus(DWORD TaskStatus)
{
    char * p = "<unk>";
    switch(TaskStatus)
    {
        case WMICORE_TASK_STATUS_NEW: p = "WMICORE_TASK_STATUS_NEW"; break;
        case WMICORE_TASK_STATUS_VALIDATED: p = "WMICORE_TASK_STATUS_VALIDATED"; break;
        case WMICORE_TASK_STATUS_SUSPENDED: p = "WMICORE_TASK_STATUS_SUSPENDED"; break;
        case WMICORE_TASK_STATUS_EXECUTING: p = "WMICORE_TASK_STATUS_EXECUTING"; break;
        case WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS: p = "WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS"; break;
        case WMICORE_TASK_STATUS_TIMED_OUT: p = "WMICORE_TASK_STATUS_TIMED_OUT"; break;
        case WMICORE_TASK_STATUS_CORE_COMPLETED: p = "WMICORE_TASK_STATUS_CORE_COMPLETED"; break;
        case WMICORE_TASK_STATUS_CLIENT_COMPLETED: p = "WMICORE_TASK_STATUS_CLIENT_COMPLETED"; break;
        case WMICORE_TASK_STATUS_CANCELLED: p = "WMICORE_TASK_STATUS_CANCELLED"; break;
        case WMICORE_TASK_STATUS_FAILED: p = "WMICORE_TASK_STATUS_FAILED"; 
        break;
    };
    return p;
}

char * GetTaskType(DWORD TaskType)
{
    char * p = "<unk>";
    switch(TaskType & 0xFF)
    {
        case WMICORE_TASK_NULL: p = "WMICORE_TASK_NULL"; break;
        case WMICORE_TASK_GET_OBJECT: p = "WMICORE_TASK_GET_OBJECT"; break;
        case WMICORE_TASK_GET_INSTANCE: p = "WMICORE_TASK_GET_INSTANCE"; break;
        case WMICORE_TASK_PUT_INSTANCE: p = "WMICORE_TASK_PUT_INSTANCE"; break;
        case WMICORE_TASK_DELETE_INSTANCE: p = "WMICORE_TASK_DELETE_INSTANCE"; break;
        case WMICORE_TASK_ENUM_INSTANCES:  p = "WMICORE_TASK_ENUM_INSTANCES"; break;
        case WMICORE_TASK_GET_CLASS:    p = "WMICORE_TASK_GET_CLASS"; break;
        case WMICORE_TASK_PUT_CLASS:    p = "WMICORE_TASK_PUT_CLASS"; break;
        case WMICORE_TASK_DELETE_CLASS: p = "WMICORE_TASK_DELETE_CLASS"; break;
        case WMICORE_TASK_ENUM_CLASSES: p = "WMICORE_TASK_ENUM_CLASSES"; break;
        case WMICORE_TASK_EXEC_QUERY:   p = "WMICORE_TASK_EXEC_QUERY"; break;
        case WMICORE_TASK_EXEC_METHOD:  p = "WMICORE_TASK_EXEC_METHOD"; break;
        case WMICORE_TASK_OPEN:         p = "WMICORE_TASK_OPEN"; break;
        case WMICORE_TASK_OPEN_SCOPE:   p = "WMICORE_TASK_OPEN_SCOPE"; break;
        case WMICORE_TASK_OPEN_NAMESPACE: p = "WMICORE_TASK_OPEN_NAMESPACE"; break;
        case WMICORE_TASK_EXEC_NOTIFICATION_QUERY: p = "WMICORE_TASK_EXEC_NOTIFICATION_QUERY"; break;
    }
    return p;
}

char * GetOpType(DWORD TaskType)
{
    if (TaskType & WMICORE_TASK_TYPE_SYNC)
        return " WMICORE_TASK_TYPE_SYNC";

    if (TaskType & WMICORE_TASK_TYPE_SEMISYNC)
        return " WMICORE_TASK_TYPE_SEMISYNC";

    if (TaskType & WMICORE_TASK_TYPE_ASYNC)
        return " WMICORE_TASK_TYPE_ASYNC";

    if (TaskType & WMICORE_TASK_TYPE_PRIMARY)
        return " WMICORE_TASK_TYPE_PRIMARY";

    if (TaskType & WMICORE_TASK_TYPE_DEPENDENT)
        return " WMICORE_TASK_TYPE_DEPENDENT";

    return "<unk>";
}

void DumpCWmiTask(CWmiTask * pTask_OOP)
{
    DEFINE_CPP_VAR(CWmiTask, MyWmiTask);
    if (ReadMemory((ULONG_PTR)pTask_OOP,&MyWmiTask,sizeof(MyWmiTask),0))
    {
	    CWmiTask * pWmiTask = (CWmiTask *)&MyWmiTask;

	    dprintf("            m_uRefCount        %d\n",pWmiTask->m_uRefCount);        //: 0x3
	    dprintf("            m_uTaskType        %s %s\n",GetTaskType(pWmiTask->m_uTaskType),GetOpType(pWmiTask->m_uTaskType));        //: 0x11000005
	    dprintf("            m_uTaskStatus      %s\n",GetTaskStatus(pWmiTask->m_uTaskStatus));      //: 0x0
	    dprintf("            m_uTaskId          %p\n",pWmiTask->m_uTaskId);          //: 0x17f
	    dprintf("            m_pAsyncClientSink %p\n",pWmiTask->m_pAsyncClientSink); //: (null)
	    dprintf("            m_pReqSink         %p\n",pWmiTask->m_pReqSink);         //: 0x06e0cc80
	    //dprintf("            m_pWorkingFnz      %p\n",pWmiTask->m_pWorkingFnz);      //: 0x01395ed8
	    //dprintf("            m_pUser            %p\n",pWmiTask->m_pUser);            //: (null)
	    //dprintf("            m_pSec             %p\n",pWmiTask->m_pSec);             //: (null)
	    dprintf("            m_pAsyncClientSink %p\n",pWmiTask->m_pAsyncClientSink);  //: (null)
	    dprintf("            m_pNs              %p\n",pWmiTask->m_pNs);              //: 0x0131a198

	    DWORD i;
	    VOID ** ppPointers = (VOID **)_alloca(max(pWmiTask->m_aTaskProviders.m_nSize,pWmiTask->m_aArbitratees.m_nSize));

	    dprintf("            m_aTaskProviders: size %x p %p\n",
	            pWmiTask->m_aTaskProviders.m_nSize,
	            pWmiTask->m_aTaskProviders.m_pArray);
	    if (pWmiTask->m_aTaskProviders.m_nSize)
	    {
	        if (ReadMemory((ULONG_PTR)pWmiTask->m_aTaskProviders.m_pArray,ppPointers,sizeof(void *)*pWmiTask->m_aTaskProviders.m_nSize,NULL))
	        {
	            for(i=0;i<pWmiTask->m_aTaskProviders.m_nSize;i++)
	            {
	                dprintf("              %p - %x\n",ppPointers[i],i);
	                GetVTable((MEMORY_ADDRESS)ppPointers[i]);
	            }
	        }
	    }
	    dprintf("            m_aArbitratees: size %x p %p\n",
	            pWmiTask->m_aArbitratees.m_nSize,
	            pWmiTask->m_aArbitratees.m_pArray);
	    if (pWmiTask->m_aArbitratees.m_nSize)
	    {
	        if (ReadMemory((ULONG_PTR)pWmiTask->m_aArbitratees.m_pArray,ppPointers,sizeof(void *)*pWmiTask->m_aArbitratees.m_nSize,NULL))
	        {
	            for(i=0;i<pWmiTask->m_aArbitratees.m_nSize;i++)
	            {
	                dprintf("              %p - %x\n",ppPointers[i],i);
	                GetVTable((MEMORY_ADDRESS)ppPointers[i]);
	            }        
	        }    
	    }
    }
    else
    {
    	dprintf("RM %p\n",pTask_OOP);
    }
}

DWORD DumpCAsyncReq(ULONG_PTR pAsyncReq_OOP)
{
    DEFINE_CPP_VAR(CAsyncReq,MyCAsyncReq);
    if (ReadMemory((ULONG_PTR)pAsyncReq_OOP,&MyCAsyncReq,sizeof(CAsyncReq),NULL))
    {
	    CAsyncReq * pAsyncReq = (CAsyncReq *)&MyCAsyncReq;

	    GetVTable((MEMORY_ADDRESS)pAsyncReq_OOP);
	    dprintf("          %p m_hWhenDone\n",pAsyncReq->m_hWhenDone);      // Ptr32 to Void
	    dprintf("          %p m_pNext\n",pAsyncReq->m_pNext);          // Ptr32 CCoreExecReq
	    dprintf("          %08x m_lPriority\n",pAsyncReq->m_lPriority);      // Int 4B
	    dprintf("          %d m_fOk\n",pAsyncReq->m_fOk);            // Char
	    dprintf("          %p m_phTask ",pAsyncReq->m_phTask);         // Ptr32 _IWmiCoreHandle
	    if (pAsyncReq->m_phTask){
	        DumpCWmiTask((CWmiTask *)pAsyncReq->m_phTask);
	    }
	    dprintf("          %p m_pContext\n",pAsyncReq->m_pContext);       // Ptr32 IWbemContext
	    dprintf("          %p m_pCA\n",pAsyncReq->m_pCA);            // Ptr32 IWbemCausalityAccess
	    dprintf("          %p m_pCallSec\n",pAsyncReq->m_pCallSec);       // Ptr32 IWbemCallSecurity
	    dprintf("          %p m_pHandler ",pAsyncReq->m_pHandler);       // Ptr32 CStdSink
	    //GetVTable(pAsyncReq->m_pHandler);
	    dprintf("          %08x m_lRequestHandle\n",pAsyncReq->m_lRequestHandle); // Int 4B
    }
    else
    {
        dprintf("RM %p\n",pAsyncReq_OOP);
    }
    return 0;
}

DWORD EnumListNamespaces(VOID * pStructure_OOP,
                      VOID * pLocalStructure)
{
/*
    DEFINE_CPP_VAR(CWbemNamespace, MyWbemNamespace);
    ReadMemory((ULONG_PTR)pNamespace_OOP,&MyWbemNamespace,sizeof(CWbemNamespace),0);
*/

    dprintf("     - CWbemNamespace @  %p\n",pStructure_OOP);

    CWbemNamespace * pName = (CWbemNamespace *)pLocalStructure;
    

    dprintf("            m_bShutDown          %d\n",pName->m_bShutDown);
    dprintf("            Status               %d\n",pName->Status);
    dprintf("            m_uSecondaryRefCount %d\n",pName->m_uSecondaryRefCount);

    //
    WCHAR pBuff[MAX_PATH];
    ReadMemory((ULONG_PTR)pName->m_pThisNamespace,pBuff,sizeof(pBuff),0);
    pBuff[MAX_PATH-1] = 0; // in any case
    dprintf("            m_pThisNamespace     %S\n",pBuff);

    dprintf("            m_pProvFact          %p\n",pName->m_pProvFact);
    dprintf("            m_pCoreSvc           %p\n",pName->m_pCoreSvc);
    dprintf("            m_bRepositOnly       %d\n",pName->m_bRepositOnly);
	dprintf("            m_pRefreshingSvc     %p\n",pName->m_pRefreshingSvc);
	dprintf("            m_bESS               %d\n",pName->m_bESS);

    return 0;
}


void GetThreadInfo(HANDLE hThread,HANDLE hSourceProcess)
{
    HANDLE hThreadThisProc;

    if (DuplicateHandle(hSourceProcess,
                    hThread,
                    GetCurrentProcess(),
                    &hThreadThisProc,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS))
    {

	    NTSTATUS Status;
	    ULONG Long;
	    THREAD_BASIC_INFORMATION TBasicInfo;
	    Status = NtQueryInformationThread(hThreadThisProc,
	                                      ThreadBasicInformation,
	                                      &TBasicInfo,
	                                      sizeof(TBasicInfo),
	                                      &Long);
	                                      
	    if ( Status == 0 )
	    {
	        dprintf("        %p %x.%x\n",TBasicInfo.TebBaseAddress,TBasicInfo.ClientId.UniqueProcess,TBasicInfo.ClientId.UniqueThread);
	    }
	    else
	    {
	       dprintf("    NTSTATUS %08x\n",Status);
	    }

	    CloseHandle(hThreadThisProc);
    }
    else
    {
        dprintf("DuplicateHandle %d\n",GetLastError());
    }
}



void DumpRecord(ULONG_PTR pRecord_OOP,
                HANDLE hSourceProcess,
                pfnDumpRequest DumpRequest)
{

    DEFINE_CPP_VAR(CCoreQueue::CThreadRecord,MyThreadRecord);
    if (ReadMemory((ULONG_PTR)pRecord_OOP,&MyThreadRecord,sizeof(CCoreQueue::CThreadRecord),NULL))
    {
	    CCoreQueue::CThreadRecord * pRecord = (CCoreQueue::CThreadRecord *)&MyThreadRecord;

	    //dprintf("      %p m_pQueue\n",pRecord->m_pQueue);         //: Ptr32 CCoreQueue
	    dprintf("      %p m_pCurrentRequest",pRecord->m_pCurrentRequest);// : Ptr32 CCoreExecReq
	    dprintf(" %d m_bReady",pRecord->m_bReady);         //: Int 4B
	    dprintf(" %d m_bExitNow",pRecord->m_bExitNow);       //: Int 4B
	    dprintf(" %p m_hThread",pRecord->m_hThread);        //: Ptr32 to Void
	    dprintf(" %p m_hAttention\n",pRecord->m_hAttention);     //: Ptr32 to Void
	    GetThreadInfo(pRecord->m_hThread,hSourceProcess);
	    if (pRecord->m_pCurrentRequest)
	    {
	        //DumpCAsyncReq((CAsyncReq *)pRecord->m_pCurrentRequest);
	        if (DumpRequest)
	            DumpRequest((ULONG_PTR)pRecord->m_pCurrentRequest);
	    }
    }
    else
    {
        dprintf("RM %p\n",pRecord_OOP);
    }
}


DECLARE_API( q )
{

    INIT_API();

    ULONG_PTR Addr = GetExpression("wbemcore!g_pAsyncSvcQueue");
    if (Addr) 
    {
        CAsyncServiceQueue * pAsyncQueue = NULL;
        if (ReadMemory(Addr,&pAsyncQueue,sizeof(CAsyncServiceQueue *),0))
       	{
            dprintf("CAsyncServiceQueue %p\n",pAsyncQueue);
	        DEFINE_CPP_VAR(CAsyncServiceQueue,MyAsyncServiceQueue);            
            if (ReadMemory((ULONG_PTR)pAsyncQueue,&MyAsyncServiceQueue,sizeof(CAsyncServiceQueue),NULL))
            {
	            pAsyncQueue = (CAsyncServiceQueue *)&MyAsyncServiceQueue;
	        
	            //m_aThreads       : CFlexArray
	            dprintf("    elems %d pointer %p\n",pAsyncQueue->m_aThreads.m_nSize,pAsyncQueue->m_aThreads.m_pArray);

	            CCoreQueue::CThreadRecord ** pRecord_OOP = (CCoreQueue::CThreadRecord **)_alloca(sizeof(void*)*pAsyncQueue->m_aThreads.m_nSize);
	            if (ReadMemory((ULONG_PTR)pAsyncQueue->m_aThreads.m_pArray,pRecord_OOP,sizeof(void*)*pAsyncQueue->m_aThreads.m_nSize,0))
	            {
		            DWORD i;
		            for (i=0;i<pAsyncQueue->m_aThreads.m_nSize;i++)
		            {
		                dprintf("      -- CThreadRecord %p - %d\n",pRecord_OOP[i],i);
		                DumpRecord((ULONG_PTR)pRecord_OOP[i],hCurrentProcess,DumpCAsyncReq);
		            }
	            }
	            else
	            {
                    dprintf("RM %p\n",pRecord_OOP);
	            }

	            dprintf("    m_pHead %p\n",pAsyncQueue->m_pHead);
	            dprintf("    m_pTail %p\n",pAsyncQueue->m_pTail);
	            // here code for the list
	            CCoreExecReq * pReq = pAsyncQueue->m_pHead;
	            DWORD i = 0;
	            while (pReq)
	            {
	                dprintf(" ---- list - %d\n",i++);
	                DEFINE_CPP_VAR(CCoreExecReq,MyAsyncReq);
	                CCoreExecReq * pReqHERE = GET_CPP_VAR_PTR(CCoreExecReq,MyAsyncReq);
	                if (ReadMemory((ULONG_PTR)pReq,pReqHERE,sizeof(CCoreExecReq),NULL))
	                {
		                //dprintf("   %p %p\n",pReq,pReqHERE->m_pNext);
		                DumpCAsyncReq((ULONG_PTR)pReq);
	                }
	                else
	                {
	                    dprintf("RM %p\n",pReq);
	                    break;
	                }

	                if (pReq == pAsyncQueue->m_pTail)
	                    break;
	                
	                pReq = pReqHERE->m_pNext;                

	                if (CheckControlC())
	                    break;                
	            }
	            //
	   
	            dprintf("    m_lNumThreads   %d \n",pAsyncQueue->m_lNumThreads);
	            dprintf("    m_lNumIdle      %d\n",pAsyncQueue->m_lNumIdle);
	            dprintf("    m_lNumRequests  %d\n",pAsyncQueue->m_lNumRequests);   
	            dprintf("    m_lMaxThreads   %d\n",pAsyncQueue->m_lMaxThreads);    
	            dprintf("    m_lHiPriBound      %d\n",pAsyncQueue->m_lHiPriBound);    
	            dprintf("    m_lHiPriMaxThreads %d\n",pAsyncQueue->m_lHiPriMaxThreads); 
	            dprintf("    m_lStartSlowdownCount  %d\n",pAsyncQueue->m_lStartSlowdownCount);
	            dprintf("    m_lAbsoluteLimitCount  %d\n",pAsyncQueue->m_lAbsoluteLimitCount); 
	            dprintf("    m_lOneSecondDelayCount %d\n",pAsyncQueue->m_lOneSecondDelayCount); 
	            dprintf("    m_dblAlpha  %f\n",pAsyncQueue->m_dblAlpha);
	            dprintf("    m_dblBeta   %f\n",pAsyncQueue->m_dblBeta);
	            dprintf("    m_dwTimeout %x\n",pAsyncQueue->m_dwTimeout);
	            // m_dwOverflowTimeout 
	            // m_lChildPenalty  
	            // m_lSiblingPenalty 
	            // m_lPassingPenalty 	            
	        }
            else
            {
	            dprintf("RM %p\n",pAsyncQueue);
            }
       	}
        else
        {
            dprintf("RM %p\n",Addr);
        }
    } 
    else 
    {
        dprintf("unable to resolve wbemcore!g_pAsyncSvcQueue");
    }
    
}

#include <wmiarbitrator.h>


void Dump_CWmiFinalizer()
{
    DWORD Val;
    ULONG_PTR pAddr;

    pAddr = GetExpression("wbemcore!s_Finalizer_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_Finalizer_ObjectCount             = %d\n",Val);

    pAddr = GetExpression("wbemcore!s_FinalizerCallResult_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_FinalizerCallResult_ObjectCount   = %d\n",Val);
    
    pAddr = GetExpression("wbemcore!s_FinalizerEnum_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_FinalizerEnum_ObjectCount         = %d\n",Val);
    
    pAddr = GetExpression("wbemcore!s_FinalizerEnumSink_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_FinalizerEnumSink_ObjectCount     = %d\n",Val);
    
    pAddr = GetExpression("wbemcore!s_FinalizerInBoundSink_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_FinalizerInBoundSink_ObjectCount  = %d\n\n",Val);
}

void
DumpCProvSink(CProviderSink * pProvSink)
{
	dprintf("            Total Indicates = %d\n", pProvSink->m_lIndicateCount);
	WCHAR pString[MAX_PATH+1];
	pString[MAX_PATH] = 0;
	if (ReadMemory((ULONG_PTR)pProvSink->m_pszDebugInfo,pString,MAX_PATH*sizeof(WCHAR),NULL))
	{
	    dprintf("            Debug Info = %S\n",pString);
	}
    dprintf("            SetStatus called? %d\n", pProvSink->m_bDone);
    dprintf("            hRes = 0x%x\n", pProvSink->m_hRes);
    dprintf("            m_pNextSink = %p\n", pProvSink->m_pNextSink);
}

DECLARE_API( arb )
{

    INIT_API();

    CWmiArbitrator * pArbit_OOP = NULL;
    ULONG_PTR Addr = GetExpression(args);

    if (NULL == Addr)
    {
        Addr = GetExpression("wbemcore!CWmiArbitrator__m_pArb");
        if (Addr)
        {
            if (ReadMemory(Addr,&pArbit_OOP,sizeof(CWmiArbitrator *),0))
            {
            }
            else
            {
                dprintf("RM %p\n",Addr);
            }
        }
        else
        {
            dprintf("unable to resolve wbemcore!CWmiArbitrator__m_pArb\n");
        }
    }
    else
    	pArbit_OOP = (CWmiArbitrator *)Addr;
    
    if (pArbit_OOP) 
    {
        DWORD Val;
        ULONG_PTR pAddr;        

        pAddr = GetExpression("wbemcore!g_nSinkCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total sinks active     = %d\n",Val);
        
        pAddr = GetExpression("wbemcore!g_nStdSinkCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total std sink objects = %d\n",Val);

        pAddr = GetExpression("wbemcore!g_nSynchronousSinkCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total Sync sink objects = %d\n",Val);

        pAddr = GetExpression("wbemcore!g_nProviderSinkCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total Prov sink objects = %d\n",Val);

        pAddr = GetExpression("wbemcore!g_lCoreThreads");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total Core Threads = %d\n",Val);

        pAddr = GetExpression("fastprox!g_lDebugObjCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total Obj-QualSets = %d\n",Val);
                
        Dump_CWmiFinalizer();
    
        DEFINE_CPP_VAR(CWmiArbitrator,varWmiArbitrator);        
        CWmiArbitrator * pArbit = GET_CPP_VAR_PTR(CWmiArbitrator,varWmiArbitrator);
        
        dprintf("CWmiArbitrator %p\n",pArbit_OOP);
        
        if (ReadMemory((ULONG_PTR)pArbit_OOP,pArbit,sizeof(CWmiArbitrator),NULL))
       	{
	        dprintf("    m_lRefCount          %d\n",pArbit->m_lRefCount);
	        dprintf("    m_uTotalTasks        %d\n",pArbit->m_uTotalTasks);
	        dprintf("    m_uTotalPrimaryTasks %d\n",pArbit->m_uTotalPrimaryTasks);

	        DWORD dwTot = pArbit->m_aTasks.m_nSize*sizeof(void*);
	        void ** pMem = new void *[dwTot];
	        DWORD i;

	        dprintf("    m_aTasks P %p S %x\n",pArbit->m_aTasks.m_pArray,pArbit->m_aTasks.m_nSize);
	        
	        if (ReadMemory((ULONG_PTR)pArbit->m_aTasks.m_pArray,pMem,dwTot,0))
	        {
	            for (i=0;i<pArbit->m_aTasks.m_nSize;i++)
	            {
	                dprintf("     - CWmiTask %d - %p\n",i,pMem[i]);
	                if (pMem[i])
	                {
	                    DumpCWmiTask((CWmiTask *)pMem[i]);
	                }
	                else
	                {
	                    dprintf("      <NULL>\n");
	                }
	            }
	        }
	        else
	        {
	            dprintf("RM %p\n",pArbit->m_aTasks.m_pArray);
	        }
	        delete [] pMem;

	        //m_aNamespaces
	        /*
	        DWORD dwTot2 = pArbit->m_aNamespaces.m_nSize*sizeof(void*);
	        void ** pMem2 = new void *[dwTot2];

	        dprintf("    m_aNamespaces P %p S %x\n",pArbit->m_aNamespaces.m_pArray,pArbit->m_aNamespaces.m_nSize);
	        if (ReadMemory((ULONG_PTR)pArbit->m_aNamespaces.m_pArray,pMem2,dwTot2,0))
	        {
	            for (i=0;i<pArbit->m_aNamespaces.m_nSize;i++)
	            {
	                dprintf("     - CWbemNamespace %d - %p\n",i,pMem2[i]);
	                if (pMem2[i])
	                {
	                    DumpCWbemNamespace((CWbemNamespace *)pMem2[i]);
	                }
	            }
	        }
	        else
	        {
	            dprintf("RM %p\n",pArbit->m_aNamespaces.m_pArray);
	        }
	        delete [] pMem2;
	        */
	        ULONG_PTR pListHead_oop = (ULONG_PTR)pArbit_OOP + FIELD_OFFSET(CWmiArbitrator,m_NameSpaceList);

	        EnumLinkedListCB((LIST_ENTRY  *)pListHead_oop,
	                         sizeof(CWmiArbitrator),
	                         FIELD_OFFSET(CWbemNamespace,m_EntryArb), 
	                         EnumListNamespaces); 
       	}
        else
        {
            dprintf("RM %p\n",pArbit_OOP);
        }

    }

    //g_aProviderSinks
    DEFINE_CPP_VAR(CFlexArray,varCFlexArray);
    CFlexArray * pFlexArray = GET_CPP_VAR_PTR(CFlexArray,varCFlexArray);

    Addr = GetExpression("wbemcore!g_aProviderSinks");
    if (Addr)
    {
        if (ReadMemory(Addr,pFlexArray,sizeof(CFlexArray),NULL))
        {
            VOID ** ppPointers = (VOID **)_alloca(pFlexArray->m_nSize*sizeof(void *));
            if (ReadMemory((ULONG_PTR)pFlexArray->m_pArray,ppPointers,pFlexArray->m_nSize*sizeof(void *),NULL))
            {
                for(DWORD i =0 ;i<pFlexArray->m_nSize;i++)
                {
                    
                    dprintf("    - CProviderSink %d - %p\n",i,ppPointers[i]);
                    GetVTable((MEMORY_ADDRESS)ppPointers[i]);

                    DEFINE_CPP_VAR(CProviderSink,varCProviderSink);
                    CProviderSink * pProvSink = GET_CPP_VAR_PTR(CProviderSink,varCProviderSink);
                    if (ppPointers[i] && ReadMemory((ULONG_PTR)ppPointers[i],pProvSink,sizeof(CProviderSink),NULL))
                    {
                        DumpCProvSink(pProvSink);
                    }
                    else
                    {
                        dprintf("RM %p\n",ppPointers[i]);
                    }
                }
            }
        }
    }
       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\server.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  Server.cpp
//
//    Module:    WMI high performance provider sample code
//
//  Generic COM server framework, adapted for the BasicHiPerf provider 
//    sample.  This module contains nothing specific to the BasicHiPerf 
//    provider except what is defined in the section bracketed by the 
//    CLSID SPECIFIC comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//    a-dcrews      12-Jan-99        Adapted for BasicHiPerf.dll
//
//
//  Copyright (c) 1997-2001 Microsoft Corporation, All rights reserved
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <time.h>
#include <initguid.h>
#include <autoptr.h>
#include <helper.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include "wbemprov.h"
#include "Provider.h"
#include "Factory.h"

#define IMPLEMENTED_CLSID           CLSID_HiPerfCooker_v1
#define SERVER_REGISTRY_COMMENT     L"WMI High Performance Cooker"

// {B0A2AB46-F612-4469-BEC4-7AB038BC476C}
DEFINE_GUID(IMPLEMENTED_CLSID, 0xb0a2ab46, 0xf612, 0x4469, 0xbe, 0xc4, 0x7a, 0xb0, 0x38, 0xbc, 0x47, 0x6c);

HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;

//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
     if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    if (NULL == ppv) return E_POINTER;
    
    CClassFactory *pClassFactory = NULL;
    HRESULT hRes;

    //  Verify the caller is asking for our type of object
    // ===================================================

    if (IMPLEMENTED_CLSID == rclsid) 
    {
        // Create the class factory
        // ========================

        pClassFactory = new CClassFactory;

        if (!pClassFactory)
            return E_OUTOFMEMORY;
        
        hRes = pClassFactory->QueryInterface(riid, ppv);
        if (FAILED(hRes))
        {
            delete pClassFactory;
            return hRes;
        }
        hRes = S_OK;
    }
    else 
        hRes = CLASS_E_CLASSNOTAVAILABLE;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT hRes = S_FALSE;

    if (0 == g_lLocks && 0 == g_lObjects)
        hRes = S_OK;

    return hRes;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    WCHAR * Path = new WCHAR[1024];
    wmilib::auto_buffer<WCHAR> rm1_(Path);
    WCHAR * KeyPath = new WCHAR[1024];
    wmilib::auto_buffer<WCHAR> rm2_(KeyPath);

    if (0 == Path || 0 == KeyPath)
    {
        return E_OUTOFMEMORY;
    }
    
    // Get the dll's filename
    // ======================

    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================
    WCHAR * pGuidStr = 0;
    RETURN_ON_ERR(StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr));
    OnDelete<void *,void(*)(void *),CoTaskMemFree> dm(pGuidStr);
    
    StringCchPrintfW(KeyPath, 1024, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes;
    if (ERROR_SUCCESS != RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey)) return E_FAIL;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm(hKey);

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    if (ERROR_SUCCESS != RegCreateKey(hKey, TEXT("InprocServer32"), &hSubkey)) return E_FAIL;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm2(hSubkey);    

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

STDAPI DllUnregisterServer(void)
{

    wchar_t KeyPath[256];

    wchar_t *pGuidStr = 0;

    RETURN_ON_ERR(StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr));
    OnDelete<void *,void(*)(void *),CoTaskMemFree> dm(pGuidStr);
    
    StringCchPrintfW(KeyPath, 256, L"Software\\Classes\\CLSID\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    HKEY hKey;    
    LONG lRes;
    if (ERROR_SUCCESS != RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey))  return E_FAIL;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm(hKey);    

    RegDeleteKeyW(hKey, L"InprocServer32");


    // Delete CLSID GUID key.
    // ======================
    HKEY hKey2; 
    if (ERROR_SUCCESS != RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey2))  return E_FAIL;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm2(hKey2);

    RegDeleteKeyW(hKey2, pGuidStr);


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmicooker\wmiobjcooker.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


// WMIObjCooker.cpp

#include "precomp.h"
#include "WMIObjCooker.h"
#include "RawCooker.h"
#include <comdef.h>
#include <autoptr.h>

//
//
// Assumes pProp validated before entering
//
///////////////////////////////////////////////////////////////////////////////

WMISTATUS GetPropValue( CProperty* pProp, IWbemObjectAccess* pInstance, __int64 & nResult )
{
    _DBG_ASSERT(pProp);
    
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    DWORD dwRes = 0;
    switch( pProp->GetType() )
    {
    case CIM_UINT32:
        {
            dwStatus = pInstance->ReadDWORD( pProp->GetHandle(), &dwRes );
            nResult = dwRes;
        }break;
    case CIM_UINT64:
        {
            dwStatus = pInstance->ReadQWORD( pProp->GetHandle(), (unsigned __int64*)&nResult );            

        }break;
    default:
        dwStatus = WBEM_E_TYPE_MISMATCH;
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////
//
//    CWMISimpleObjectCooker
//
//////////////////////////////////////////////////////////////

CWMISimpleObjectCooker::CWMISimpleObjectCooker( WCHAR* wszCookingClassName, 
                                                IWbemObjectAccess* pCookingClass, 
                                                IWbemObjectAccess* pRawClass, 
                                                IWbemServices * pNamespace ) : 
  m_lRef( 1 ),
  m_pCookingClass( NULL ),
  m_wszClassName(NULL),
  m_pNamespace(NULL),
  m_dwPropertyCacheSize( 16 ),
  m_dwNumProperties( 0 ),
  m_NumInst(0),
  m_InitHR(WBEM_E_INITIALIZATION_FAILURE)  
{
#ifdef _VERBOSE
        DbgPrintfA(0,"+ Cooker %p\n",this);
#endif
    
    if (pNamespace)
    {
        m_pNamespace = pNamespace;
        m_pNamespace->AddRef();
    }

    m_InitHR = SetClass( wszCookingClassName, pCookingClass, pRawClass );

    if (m_pNamespace)
    {
        m_pNamespace->Release();
        m_pNamespace = NULL;
    }
    
}

CWMISimpleObjectCooker::~CWMISimpleObjectCooker()
{
    Reset();

    // Release the cooking class
    if ( m_pCookingClass ) m_pCookingClass->Release(); 
    if (m_pNamespace) m_pNamespace->Release();

    // Delete the property cache
    for (DWORD i=0;i<m_apPropertyCache.size();i++)
    {
        CCookingProperty* pCookProp = m_apPropertyCache[i];
        delete pCookProp;
    }
    
    delete [] m_wszClassName;

#ifdef _VERBOSE    
        DbgPrintfA(0,"- Cooker %p istances left %d\n",this,m_NumInst);
#endif            
}

//////////////////////////////////////////////////////////////
//
//                    COM methods
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CWMISimpleObjectCooker::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//    Standard QueryInterface
//
//    Parameters:
//        riid    - the ID of the requested interface
//        ppv        - a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
//ok
{
    if (NULL == ppv) return E_POINTER;
    if(riid == IID_IUnknown)
    {
        *ppv = (LPVOID)(IUnknown*)(IWMISimpleCooker*)this;
    }
    else if(riid == IID_IWMISimpleCooker)
    {
        *ppv = (LPVOID)(IWMISimpleCooker*)this;
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CWMISimpleObjectCooker::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CWMISimpleObjectCooker::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}

STDMETHODIMP CWMISimpleObjectCooker::SetClass( 
        /*[in]    */ WCHAR* wszCookingClassName,
        /*[in]  */ IWbemObjectAccess *pCookingClassAccess,
        /*[in]  */ IWbemObjectAccess *pRawClass )
{
    HRESULT    hResult = S_OK;
    IWbemClassObject * pClass = NULL;

    // Cannot override the original cooking class for now
    // ==================================================

    if ( ( NULL != m_pCookingClass ) || ( NULL == pCookingClassAccess ) )
        hResult = E_FAIL;

    // what we put here MUST be a class, Singletons are OK
    // if we have an instance, we need to ask WinMgmt for a class
    if (m_pNamespace) 
    {
        _variant_t VarGenus;
        hResult = pCookingClassAccess->Get(L"__GENUS",0,&VarGenus,NULL,NULL);
        
        if (SUCCEEDED(hResult))
        {
            if ((CIM_SINT32 == V_VT(&VarGenus)) &&
                WBEM_GENUS_CLASS == V_I4(&VarGenus))
            {
            } 
            else 
            {                
                BSTR BstrName = SysAllocString(wszCookingClassName);
                if (BstrName)
                {
                    CSysFreeMe sfm(BstrName);
                    m_pNamespace->GetObject(BstrName,0,NULL,&pClass,NULL);            
                }
                else
                {
                    hResult = WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
    }

    IWbemClassObject * pCookingClassAccess2;
    pCookingClassAccess2 = (pClass)?pClass:pCookingClassAccess;

    // Verify and process the cooking class
    // ====================================

    
    if ( SUCCEEDED( hResult ) )
    {
        BOOL bRet;
        bRet = IsCookingClass( pCookingClassAccess );

        if ( bRet )
        {
            // Save the class 
            m_pCookingClass = pCookingClassAccess;
            m_pCookingClass->AddRef();
        } 
        else 
        {
           hResult = WBEM_E_INVALID_CLASS;
        }

        // Set the class name
        if ( SUCCEEDED( hResult ) )
        {
            size_t length = wcslen( wszCookingClassName ) + 1;
            m_wszClassName = new WCHAR[ length ];
            if (m_wszClassName)
                StringCchPrintfW( m_wszClassName, length, wszCookingClassName );
            else
            	hResult = WBEM_E_OUT_OF_MEMORY;
        }

        // Initialize the cooking properties
        if ( SUCCEEDED( hResult ) )
        {
            hResult = SetProperties( pCookingClassAccess2, pRawClass );
        }                
    }
    
    if (pClass)
    {
        pClass->Release();
    }

    return hResult;
}

WMISTATUS CWMISimpleObjectCooker::SetProperties( IWbemClassObject* pCookingClassObject, IWbemObjectAccess *pRawClass )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    BSTR    strPropName = NULL;
    long    lHandle = 0;
    CIMTYPE    ct;
    
    BOOL bAtLeastOne = FALSE;

    IWbemObjectAccess * pCookingClassAccess = NULL;
    dwStatus = pCookingClassObject->QueryInterface(IID_IWbemObjectAccess ,(void **)&pCookingClassAccess);
    if (FAILED(dwStatus)) return dwStatus;
    CReleaseMe rm(pCookingClassAccess );

    // get only once the qualifier set
    IWbemQualifierSet* pCookingClassQSet = NULL;
    dwStatus = pCookingClassObject->GetQualifierSet(&pCookingClassQSet);
    if (FAILED(dwStatus)) return dwStatus;
    CReleaseMe rm1(pCookingClassQSet);

    //
    //  should we be using [TimeStamp|Frequency]_[Time|Sys100ns|Object] ?
    //
    BOOL bUseWellKnownIfNeeded = FALSE;
    dwStatus = pCookingClassQSet->Get(WMI_COOKER_AUTOCOOK_RAWDEFAULT,0,NULL,NULL);
    // we have already verified version and property, just test if it's there
    if ( SUCCEEDED(dwStatus) )
    {
        bUseWellKnownIfNeeded = TRUE;
    }
    else // do not propagate this error
    {
        dwStatus = WBEM_NO_ERROR;
    }
    
    // Enumerate and save the autocook properties
    // ==========================================

    pCookingClassObject->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );
        
    while ( WBEM_S_NO_ERROR == pCookingClassObject->Next(0,&strPropName,NULL,&ct,NULL) &&
            SUCCEEDED(dwStatus))
    {
        CSysFreeMe    afPropName( strPropName );

        DWORD dwCounterType = 0;
        DWORD dwReqProp = 0;

        // Determine if it is an autocook property
        // =======================================

        if ( IsCookingProperty( strPropName, pCookingClassObject, &dwCounterType, &dwReqProp ) )
        {
            m_dwNumProperties++;

            // The property is an autocook; save the Name, ObjectAccess handle, type and cooking object
            // ========================================================================================

            dwStatus = pCookingClassAccess->GetPropertyHandle( strPropName, &ct, &lHandle );

            if ( SUCCEEDED( dwStatus ) )
            {
#ifdef _VERBOSE                
               DbgPrintfA(0,"%S %08x %08x\n",strPropName,dwCounterType,dwReqProp);
#endif                
                CCookingProperty* pProperty = new CCookingProperty( strPropName, 
                                                                    dwCounterType, 
                                                                    lHandle, 
                                                                    ct,
                                                                    dwReqProp,
                                                                    bUseWellKnownIfNeeded);
                if (NULL == pProperty) 
                {
                    dwStatus = WBEM_E_OUT_OF_MEMORY;
                	continue;
                }

                // Initialize the property object
                // ==============================

                IWbemQualifierSet*    pCookingPropQualifierSet = NULL;

                dwStatus = pCookingClassObject->GetPropertyQualifierSet( strPropName, &pCookingPropQualifierSet );
                CReleaseMe arQualifierSet( pCookingPropQualifierSet );

                if ( SUCCEEDED( dwStatus ) )
                {
                    dwStatus = pProperty->Initialize( pCookingPropQualifierSet, pRawClass, pCookingClassQSet );
                }

                // If everything worked out then add the property to the cache
                // ===========================================================

                if ( SUCCEEDED( dwStatus ) )
                {
                    
                    try
                    {
                        m_apPropertyCache.push_back(pProperty);
                        bAtLeastOne = TRUE;                        
                    }
                    catch (...)
                    {
                        dwStatus = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                if (FAILED(dwStatus)) // the std::vector did not get the ownership of the CCookingPropery
                {
                    delete pProperty;
                }
            }
        }
    }

    pCookingClassObject->EndEnumeration();

    if (!bAtLeastOne && (SUCCEEDED(dwStatus)))
    {
        dwStatus = WBEM_E_INVALID_CLASS;
    }

    return dwStatus;
}

STDMETHODIMP CWMISimpleObjectCooker::SetCookedInstance( 
        /*[in]  */ IWbemObjectAccess *pCookedInstance,
        /*[out] */ long *plID)
{
    HRESULT    hResult = S_OK;

    wmilib::auto_ptr<CCookingInstance> pInstance(new CCookingInstance( pCookedInstance, m_apPropertyCache.size() ));

    if ((NULL == pInstance.get()) || !pInstance->IsValid()) return WBEM_E_OUT_OF_MEMORY;

    for ( DWORD dwProp = 0; dwProp < m_apPropertyCache.size() && SUCCEEDED(hResult); dwProp++ )
    {
        CCookingProperty* pProp = m_apPropertyCache[dwProp];

        hResult = pInstance->InitProperty( dwProp, pProp->NumberOfActiveSamples(), pProp->MinSamplesRequired() );
    }

    if (FAILED(hResult)) return hResult;

    // Add new cooked instance
    hResult = m_InstanceCache.Add( (DWORD *)plID, pInstance.get() );
    
    if (FAILED(hResult)) return hResult;

    pInstance.release(); // the cache got the ownership

    m_NumInst++;
    return hResult;
}
        
STDMETHODIMP CWMISimpleObjectCooker::BeginCooking( 
        /*[in]  */ long lId,
        /*[in]  */ IWbemObjectAccess *pSampleInstance,
        /*[in]  */ DWORD dwRefreshStamp)
{
    HRESULT    hResult = S_OK;

    CCookingInstance*    pCookedInstance = NULL;

    // Add an initial sample to the cache
    // ==================================

    hResult = m_InstanceCache.GetData( lId, &pCookedInstance );

    if ( SUCCEEDED( hResult ) )
    {
        if ( NULL != pCookedInstance )
        {
            hResult = pCookedInstance->SetRawSourceInstance( pSampleInstance );

            if ( SUCCEEDED( hResult ) )
            {
                hResult = UpdateSamples( pCookedInstance, dwRefreshStamp );
            }
        }
        else
        {
            hResult = E_FAIL;
        }
    }

    return hResult;
}
        
STDMETHODIMP CWMISimpleObjectCooker::StopCooking( 
        /*[in]  */ long lId)
{
    HRESULT    hResult = S_OK;

    // just test for existence pInstance is a pointer to data still kept by the Cache
    CCookingInstance*    pInstance = NULL;
    hResult = m_InstanceCache.GetData( lId, &pInstance );

    return hResult;
}

        
STDMETHODIMP CWMISimpleObjectCooker::Recalc(DWORD dwRefreshStamp)
{
    HRESULT    hResult = S_OK;

    CCookingInstance*    pInstance = NULL;

    // Cook all of the instances which have a cached sample
    // ====================================================

    m_InstanceCache.BeginEnum();
    OnDeleteObj0<IdCache<CCookingInstance *>,
                 HRESULT (IdCache<CCookingInstance *>:: *)(void),
                 &IdCache<CCookingInstance *>::EndEnum> cEndEnum(&m_InstanceCache);

    DWORD i=0;
    while ( S_OK == m_InstanceCache.Next( &pInstance ) )
    {    
            if ( pInstance )
            {
                hResult = CookInstance( pInstance, dwRefreshStamp );
#ifdef _VERBOSE                    
                 DbgPrintfA(0,"%S %p %d\n",pInstance->GetKey(),pInstance,i++);
#endif                
            }

    }

    return hResult;
}
        
STDMETHODIMP CWMISimpleObjectCooker::Remove( 
        /*[in]  */ long lId)
{
    HRESULT    hResult = S_OK;

    // Remove the specified instance from the cache
    CCookingInstance * pInst = NULL;
    hResult = m_InstanceCache.Remove( lId, &pInst );
    if (pInst)
    {
        delete pInst;
        m_NumInst--;
    }

    return hResult;
}
        
STDMETHODIMP CWMISimpleObjectCooker::Reset()
{
    HRESULT    hResult = S_OK;

    // Remove all of the instances from the cache
    // ==========================================
    CCookingInstance * pInstance = NULL;
    m_InstanceCache.BeginEnum();

    while ( S_OK == m_InstanceCache.Next( &pInstance ) )
    {
        if (pInstance)
        {
            delete pInstance;
            m_NumInst--;
            pInstance = NULL;
        }
    }
        
    m_InstanceCache.EndEnum();

    hResult = m_InstanceCache.RemoveAll();

    return hResult;
}

WMISTATUS CWMISimpleObjectCooker::CookInstance( CCookingInstance* pInstance,
                                                DWORD dwRefreshStamp)
{
    WMISTATUS dwStatus = S_OK;

    if ( SUCCEEDED( dwStatus ) )
    {
        dwStatus = UpdateSamples( pInstance, dwRefreshStamp );

        // Loop through the cooking properties
        // ===================================
        
        for ( DWORD dwProp = 0; dwProp < m_apPropertyCache.size(); dwProp++ )
        {
            // Update the cooking instance property
            // ====================================
            pInstance->CookProperty( dwProp, m_apPropertyCache[dwProp] );
        }
    }

    return dwStatus;
}

WMISTATUS CWMISimpleObjectCooker::UpdateSamples( CCookingInstance* pCookedInstance, DWORD dwRefreshStamp )
{
    WMISTATUS dwStatus = WBEM_NO_ERROR;

    IWbemObjectAccess* pRawInstance = NULL;

    if ( NULL == pCookedInstance )
    {
        dwStatus = WBEM_E_INVALID_PARAMETER;
    }

    if ( SUCCEEDED( dwStatus ) )
    {
        dwStatus = pCookedInstance->GetRawSourceInstance( &pRawInstance );
        CReleaseMe    arRawInstance( pRawInstance );

        if ( NULL == pRawInstance )
        {
            dwStatus = WBEM_E_FAILED;
        }

#ifdef _VERBOSE
        {
            WCHAR pBuff[256];
            _variant_t Var;
            HRESULT hr = pRawInstance->Get(L"__RELPATH",0,&Var,NULL,NULL);
            StringCchPrintfW(pBuff,256,L"%p hr %08x __RELPATH %s Key %s\n",pRawInstance,hr,V_BSTR(&Var),pCookedInstance->GetKey());
            OutputDebugStringW(pBuff);
        }
#endif

        for ( DWORD dwProp = 0; ( SUCCEEDED( dwStatus ) ) && dwProp < m_apPropertyCache.size(); dwProp++ )
        {
            CCookingProperty* pProp = m_apPropertyCache[dwProp];

            CProperty* pRawProp        = pProp->GetRawCounterProperty();
            CProperty* pBaseProp    = pProp->GetBaseProperty();
            CProperty* pTimeProp    = pProp->GetTimeProperty();

            __int64 nRawCounter = 0;
            __int64 nRawBase = 0;
            __int64 nTimeStamp = 0;

            if (NULL == pRawProp) continue; // just go on with the other properties

            dwStatus = GetPropValue( pRawProp, pRawInstance, nRawCounter );

            if ( pBaseProp )
            {
                GetPropValue( pBaseProp, pRawInstance, nRawBase );
            } 
            else if (pProp->IsReq(REQ_BASE))
            {
                nRawBase = 1;
            }

            if ( pTimeProp )
            {
                GetPropValue( pTimeProp, pRawInstance, nTimeStamp );
            } 
            else if (pProp->IsReq(REQ_TIME)) 
            {
                LARGE_INTEGER li;
                QueryPerformanceCounter(&li);
                nTimeStamp = li.QuadPart;
            }

            dwStatus = pCookedInstance->AddSample( dwRefreshStamp, dwProp, nRawCounter, nRawBase, nTimeStamp );

#ifdef _VERBOSE    
                DbgPrintfA(0,"Prop %d status %08x\n"
                                " counter %I64u base %I64u time %I64u\n",
                                dwProp, dwStatus, nRawCounter, nRawBase, nTimeStamp);
#endif    

        }
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\data.h ===
#ifndef __DATA_H__
#define __DATA_H__

#include <objbase.h>

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)


MIDL_DEFINE_GUID(CLSID, CLSID_WmiRepository_SQL,0x89B9BAF8,0x6A06,0x11d3,0xA5,0xFE,0x00,0x10,0x5A,0x0A,0x31,0x02);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiRepository_Jet,0x89B9BAFC,0x6A06,0x11d3,0xA5,0xFE,0x00,0x10,0x5A,0x0A,0x31,0x02);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiRepositoryQuery,0x29129B3F,0x7899,0x4E82,0xA3,0xC3,0xA9,0x67,0x49,0x58,0x9D,0xCE);
MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);
MIDL_DEFINE_GUID(CLSID, CLSID_PseudoSink,0xE002E4F0,0xE6EA,0x11d2,0x9C,0xB3,0x00,0x10,0x5A,0x1F,0x48,0x01);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemClassObjectProxy,0x4590f812,0x1d3a,0x11d0,0x89,0x1f,0x00,0xaa,0x00,0x4b,0x2e,0x24);
MIDL_DEFINE_GUID(CLSID, CLSID_UmiObjectWrapperProxy,0x4E6AC63C,0xBF69,0x495d,0x90,0x00,0xE4,0x5A,0x4E,0x51,0x7B,0x0C);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemEventSubsystem,0x5d08b586,0x343a,0x11d0,0xad,0x46,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_HmmpEventConsumerProvider,0x08a59b5d,0xdd50,0x11d0,0xad,0x6b,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemFilterProxy,0x6c19be35,0x7500,0x11d1,0xad,0x94,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_InProcWbemLevel1Login,0x4fa18276,0x912a,0x11d1,0xad,0x9b,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiFreeFormObject,0x3252F829,0x8694,0x46a8,0xB4,0xCF,0x83,0xF6,0xA0,0xFF,0xEF,0xA9);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiObjectFactory,0x78103FB7,0xAED7,0x4066,0x8B,0xCD,0x30,0xBB,0x27,0xB0,0x23,0x31);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemUMIContextWrapper,0x390150A7,0xAB20,0x45ff,0xA2,0xE0,0x6B,0x98,0x55,0x54,0xCA,0xA8);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiErrorObject,0xE2569DC9,0x38FA,0x4749,0xBE,0xE5,0xA2,0x63,0xE4,0x03,0x35,0x9F);
MIDL_DEFINE_GUID(CLSID, CLSID__UmiErrorObject,0xF7D04323,0x5378,0x40c1,0xB5,0x88,0xC8,0x4F,0x91,0xE2,0xB8,0x2C);
MIDL_DEFINE_GUID(CLSID, CLSID_WinmgmtMofCompiler,0xC10B4771,0x4DA0,0x11d2,0xA2,0xF5,0x00,0xC0,0x4F,0x86,0xFB,0x7D);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemTokenCache,0xdc923725,0x0fdd,0x45e1,0xae,0x74,0xea,0x09,0x18,0x2e,0x73,0x9b);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiESS,0xf3130cdb,0xaa52,0x4c3a,0xab,0x32,0x85,0xff,0xc2,0x3a,0xf9,0xc1);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProvSS,0x4de225bf,0xcf59,0x4cfc,0x85,0xf7,0x68,0xb9,0x0f,0x18,0x53,0x55);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProviderBindingFactory,0xF5A55D36,0x8750,0x432C,0xAB,0x52,0xAD,0x49,0xA0,0x16,0xEA,0xBC);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProviderSharedFactory,0x24F1D9A7,0xB682,0x4CF3,0x88,0x0C,0x18,0xFD,0x90,0xD5,0x5C,0xD6);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProviderDedicatedFactory,0x4b4baaa2,0xaaf3,0x4b08,0x9c,0x9e,0xc4,0x67,0x69,0x60,0x7e,0xba);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProviderInProcFactory,0x8BEBCE8B,0x1AF0,0x4323,0x8B,0x4D,0x36,0x99,0x45,0x67,0xCA,0xE1);
MIDL_DEFINE_GUID(CLSID, CLSID_IWmiCoreServices,0x1860e246,0xe924,0x4f73,0xb2,0xc5,0x93,0xe0,0x57,0x7e,0x3a,0xa1);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiWbemClass,0x0859CCC9,0x209D,0x4110,0x96,0x13,0xDA,0xB6,0xEA,0xF9,0x09,0x3F);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiWbemInstance,0xDD51FE78,0x43E1,0x405a,0xA4,0x4E,0x6C,0x22,0x63,0x91,0xCF,0x0D);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiQuery,0xda1fc6d2,0x40e4,0x4e2f,0xbb,0x42,0xe7,0x0d,0x28,0xc8,0x91,0xb3);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemUMIObjectWrapper,0xC601737E,0x9213,0x489f,0xAD,0xC8,0x92,0x2A,0x89,0x4A,0x4A,0x65);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemEmptyClassObject,0x695B5458,0xD6E9,0x4a6a,0x88,0x1F,0xB6,0x8F,0x95,0x33,0x97,0xD8);
MIDL_DEFINE_GUID(CLSID, CLSID__IWbemCallSec,0x1108be51,0xf58a,0x4cda,0xbb,0x99,0x7a,0x02,0x27,0xd1,0x1d,0x5e);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemConfigureRefreshingSvcs,0xCD1ABFC8,0x6C5E,0x4a8d,0xB9,0x0B,0x2A,0x3B,0x15,0x3B,0x88,0x6D);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemRefresherMgr,0xDCF33DF4,0xB510,0x439f,0x83,0x2A,0x16,0xB6,0xB5,0x14,0xF2,0xA7);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemHostedRefresherMgr,0x288d70f7,0x11c8,0x42d5,0xa6,0x12,0x8e,0x46,0xa7,0xe9,0x22,0xd8);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemComBinding,0xED51D12E,0x511F,0x4999,0x8D,0xCD,0xC2,0xBA,0xC9,0x1B,0xE8,0x6E);
MIDL_DEFINE_GUID(CLSID, CLSID__UmiComBinding,0xD5D3ACEA,0xEEC7,0x4efd,0xA0,0x6D,0xFF,0x54,0xB4,0x27,0x16,0x55);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemLocator,0x4590f811,0x1d3a,0x11d0,0x89,0x1f,0x00,0xaa,0x00,0x4b,0x2e,0x24);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemConnection,0x4c6055d8,0x84b9,0x4111,0xa7,0xd3,0x66,0x23,0x89,0x4e,0xed,0xb3);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemContext,0x674B6698,0xEE92,0x11d0,0xAD,0x71,0x00,0xC0,0x4F,0xD8,0xFD,0xFF);
MIDL_DEFINE_GUID(CLSID, CLSID_UnsecuredApartment,0x49bd2028,0x1523,0x11d1,0xad,0x79,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemClassObject,0x9A653086,0x174F,0x11d2,0xB5,0xF9,0x00,0x10,0x4B,0x70,0x3E,0xFD);
MIDL_DEFINE_GUID(CLSID, CLSID_MofCompiler,0x6daf9757,0x2e37,0x11d2,0xae,0xc9,0x00,0xc0,0x4f,0xb6,0x88,0x20);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemStatusCodeText,0xeb87e1bd,0x3233,0x11d2,0xae,0xc9,0x00,0xc0,0x4f,0xb6,0x88,0x20);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemBackupRestore,0xC49E32C6,0xBC8B,0x11d2,0x85,0xD4,0x00,0x10,0x5A,0x1F,0x83,0x04);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemRefresher,0xc71566f2,0x561e,0x11d1,0xad,0x87,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemObjectTextSrc,0x8D1C559D,0x84F0,0x4bb3,0xA7,0xD5,0x56,0xA7,0x43,0x5A,0x9B,0xA6);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemAdministrativeLocator,0xcb8555cc,0x9128,0x11d1,0xad,0x9b,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemAuthenticatedLocator,0xcd184336,0x9128,0x11d1,0xad,0x9b,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemUnauthenticatedLocator,0x443E7B79,0xDE31,0x11d2,0xB3,0x40,0x00,0x10,0x4B,0xCC,0x4B,0x4A);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemDecoupledRegistrar,0x4cfc7932,0x0f9d,0x4bef,0x9c,0x32,0x8e,0xa2,0xa6,0xb5,0x6f,0xcb);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemDecoupledBasicEventProvider,0xf5f75737,0x2843,0x4f22,0x93,0x3d,0xc7,0x6a,0x97,0xcd,0xa6,0x2f);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemLevel1Login,0x8BC3F05E,0xD86B,0x11d0,0xA0,0x75,0x00,0xC0,0x4F,0xB6,0x88,0x20);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemDCOMTransport,0xF7CE2E13,0x8C90,0x11d1,0x9E,0x7B,0x00,0xC0,0x4F,0xC3,0x24,0xA8);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemLocalAddrRes,0xA1044801,0x8F7E,0x11d1,0x9E,0x7C,0x00,0xC0,0x4F,0xC3,0x24,0xA8);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemUninitializedClassObject,0x7a0227f6,0x7108,0x11d1,0xad,0x90,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemDefPath,0xcf4cc405,0xe2c5,0x4ddd,0xb3,0xce,0x5e,0x75,0x82,0xd8,0xc9,0xfa);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemQuery,0xEAC8A024,0x21E2,0x4523,0xAD,0x73,0xA7,0x1A,0x0A,0xA2,0xF5,0x6A);
MIDL_DEFINE_GUID(CLSID, CLSID_WMIExtension,0xf0975afe,0x5c7f,0x11d2,0x8b,0x74,0x00,0x10,0x4b,0x2a,0xfb,0x41);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemLocator,0x76A64158,0xCB41,0x11d1,0x8B,0x02,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemLocatorEx,0xBF37162F,0x9E73,0x48ed,0xB0,0x09,0x92,0xE2,0xF7,0x32,0x25,0x2F);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemNamedValueSet,0x9AED384E,0xCE8B,0x11d1,0x8B,0x05,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemNamedValueSetEx,0xF9EF137C,0xC934,0x4e55,0x85,0x34,0x20,0x4F,0xEE,0x2E,0xDA,0x77);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectPath,0x5791BC26,0xCE9C,0x11d1,0x97,0xBF,0x00,0x00,0xF8,0x1E,0x84,0x9C);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectPathEx,0x51217565,0xE9CE,0x4534,0xB0,0x68,0x6F,0x50,0xFF,0x77,0xC2,0xC7);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemLastError,0xC2FEEEAC,0xCFCD,0x11d1,0x8B,0x05,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemSink,0x75718C9A,0xF029,0x11d1,0xA1,0xAC,0x00,0xC0,0x4F,0xB6,0xC2,0x23);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemDateTime,0x47DFBE54,0xCF76,0x11d3,0xB3,0x8F,0x00,0x10,0x5A,0x1F,0x47,0x3A);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemRefresher,0xD269BF5C,0xD9C1,0x11d3,0xB3,0x8F,0x00,0x10,0x5A,0x1F,0x47,0x3A);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemServices,0x04B83D63,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemServicesEx,0x62E522DC,0x8CF3,0x40a8,0x8B,0x2E,0x37,0xD5,0x95,0x65,0x1E,0x40);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObject,0x04B83D62,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectEx,0xD6BDAFB2,0x9435,0x491f,0xBB,0x87,0x6A,0xA0,0xF0,0xBC,0x31,0xA2);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectSet,0x04B83D61,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemNamedValue,0x04B83D60,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemNamedValueEx,0xEE10B42E,0x02C0,0x4bef,0x80,0xB1,0xAE,0x94,0x92,0x39,0x1E,0x39);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemQualifier,0x04B83D5F,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemQualifierSet,0x04B83D5E,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemProperty,0x04B83D5D,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemPropertyEx,0x00F2D3B2,0x6AC8,0x4406,0xB9,0x8D,0x2D,0x0E,0xA9,0x57,0xC2,0x91);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemPropertySet,0x04B83D5C,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemMethod,0x04B83D5B,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemMethodSet,0x04B83D5A,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemEventSource,0x04B83D58,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemSecurity,0xB54D66E9,0x2287,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemPrivilege,0x26EE67BC,0x5804,0x11d2,0x8B,0x4A,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemPrivilegeSet,0x26EE67BE,0x5804,0x11d2,0x8B,0x4A,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemRefreshableItem,0x8C6854BC,0xDE4B,0x11d3,0xB3,0x90,0x00,0x10,0x5A,0x1F,0x47,0x3A);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectPathComponents,0xF575AF1A,0xE58D,0x11d3,0xB3,0x91,0x00,0x10,0x5A,0x1F,0x47,0x3A);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemTransaction,0x80B736A1,0x75B0,0x471c,0xA7,0xA4,0x85,0x52,0x91,0x7D,0x85,0x39);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageMsmqSender,0x122D47A6,0xCEEC,0x4de1,0x80,0x56,0xB6,0xD1,0x6F,0x29,0xBC,0x97);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageMsmqReceiver,0x9E007F18,0x9C24,0x4630,0x8B,0x3E,0x61,0xF9,0x62,0x80,0xC5,0x93);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageDcomSender,0x622D47B6,0xCEEC,0x4de1,0x80,0x56,0xB6,0xD1,0x6F,0x29,0xBC,0x97);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageDcomReceiver,0x9F007F18,0x9C24,0x4630,0x8B,0x3E,0x61,0xF9,0x62,0x80,0xC5,0x93);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageMultiSendReceive,0x89F9F7B0,0x8DE3,0x4ae0,0x8B,0x41,0x10,0x9A,0xBA,0xB3,0x21,0x51);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageQueue,0xC89DBDC4,0x5491,0x409a,0x8D,0x00,0xE3,0x45,0x38,0x21,0x1F,0xED);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageQueueManager,0xFF10E656,0x2B7C,0x421e,0xB1,0x45,0x7A,0xB3,0x37,0xFB,0x86,0x5F);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageService,0xCE69CC1E,0x1EC0,0x4847,0x9C,0x0D,0xD2,0xF2,0xD8,0x0D,0x07,0xCF);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiSmartObjectMarshal,0xC169CC11,0x1EC1,0x4847,0x9C,0x0D,0xD2,0xF2,0xD8,0x0D,0x07,0xCF);
MIDL_DEFINE_GUID(CLSID, CLSID_MsiMethodStatusSink,0xFDD70FF2,0x0195,0x11d3,0xA9,0x7D,0x00,0xA0,0xC9,0x95,0x49,0x21);
MIDL_DEFINE_GUID(CLSID, CLSID_MsiProductMethods,0xAB4184C0,0xFDAD,0x11D2,0xA9,0x7B,0x00,0xA0,0xC9,0x95,0x49,0x21);
MIDL_DEFINE_GUID(CLSID, CLSID_MsiSoftwareFeatureMethods,0xE9B5C790,0xFDAD,0x11D2,0xA9,0x7B,0x00,0xA0,0xC9,0x95,0x49,0x21);
MIDL_DEFINE_GUID(CLSID, CLSID_WMIObjectBroker,0x4BA59771,0x8FBF,0x4E67,0x99,0x17,0x3B,0xBB,0x39,0xB7,0x43,0xAB);
MIDL_DEFINE_GUID(CLSID, CLSID_WMIObjectBrokerRegistration,0x9ECF8EC8,0xA9ED,0x47DF,0xBB,0x9A,0x81,0xDC,0xB3,0x69,0x85,0x07);
MIDL_DEFINE_GUID(CLSID, CLSID_CMSnapin,0x0F3621F1,0x23C6,0x11D1,0xAD,0x97,0x00,0xAA,0x00,0xB8,0x8E,0x5A);
MIDL_DEFINE_GUID(CLSID, CLSID_CMSnapinAbout,0xA1B9E020,0x3226,0x11D2,0x88,0x3E,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_NSDrive,0x6E8E0081,0x19CD,0x11D1,0xAD,0x91,0x00,0xAA,0x00,0xB8,0xE0,0x5A);
MIDL_DEFINE_GUID(CLSID, CLSID_NSDriveAbout,0x692A8956,0x1089,0x11D2,0x88,0x37,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_SDSnapin,0xBD95BA60,0x2E26,0xAAD1,0xAD,0x99,0x00,0xAA,0x00,0xB8,0xE0,0x5A);
MIDL_DEFINE_GUID(CLSID, CLSID_SDSnapinAbout,0xA1B9E04A,0x3226,0x11D2,0x88,0x3E,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_WMISnapin,0x5C659257,0xE236,0x11D2,0x88,0x99,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_WMISnapinAbout,0x5C659258,0xE236,0x11D2,0x88,0x99,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_PseudoProvider,0xE002E4EE,0xE6EA,0x11d2,0x9C,0xB3,0x00,0x10,0x5A,0x1F,0x48,0x01);
MIDL_DEFINE_GUID(CLSID, CLSID_KernelTraceProvider,0x9877D8A7,0xFDA1,0x43F9,0xAE,0xEA,0xF9,0x07,0x47,0xEA,0x66,0xB0);
MIDL_DEFINE_GUID(CLSID, CLSID_NCProvider,0x29F06F0C,0xFB7F,0x44A5,0x83,0xCD,0xD4,0x17,0x05,0xD5,0xC5,0x25);
MIDL_DEFINE_GUID(CLSID, CLSID_VSAPlugIn,0x2169E810,0xFE80,0x4107,0xAE,0x18,0x79,0x8D,0x50,0x68,0x4A,0x71);
MIDL_DEFINE_GUID(CLSID, CLSID_VSAToWMIEventProvider,0x13A77B61,0x226B,0x46A9,0x91,0xB9,0x22,0x52,0x12,0x79,0x6D,0x92);
MIDL_DEFINE_GUID(CLSID, CLSID_DcomMsgReceiveStub,0x7879B294,0xBF5F,0x476b,0xAB,0xC9,0x9B,0x1F,0x17,0x61,0x6A,0xFB);

MIDL_DEFINE_GUID(CLSID, CLSID_MyEventProvider, 0x4916157a, 0xfbe7, 0x11d1, 0xae, 0xc4, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


MIDL_DEFINE_GUID(CLSID, UUID_DCOMName, 0xa2f7d6c1, 0x8dcd, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

MIDL_DEFINE_GUID(CLSID, UUID_LocalAddResName, 0xa1044802, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);


MIDL_DEFINE_GUID(CLSID, UUID_LocalAddrType, 0xa1044803, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);


DEFINE_GUID(UUID_LocalAddrTypeName, 0xa1044804, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

DEFINE_GUID(CLSID_WinNTConnectionObject,0x7992c6eb,0xd142,0x4332,0x83,0x1e,0x31,0x54,0xc5,0x0a,0x83,0x16);
DEFINE_GUID(CLSID_LDAPConnectionObject,0x7da2a9c4,0x0c46,0x43bd,0xb0,0x4e,0xd9,0x2b,0x1b,0xe2,0x7c,0x45);



MIDL_DEFINE_GUID(CLSID, CLSID_PerfProvider,0xF00B4404L,0xF8F1,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);
MIDL_DEFINE_GUID(CLSID, CLSID_PerfPropProv, 0x72967903, 0x68ec, 0x11d0, 0xb7, 0x29, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);
MIDL_DEFINE_GUID(CLSID, CLSID_RegistryEventProvider,0xfa77a74e,0xe109,0x11d0,0xad,0x6e,0x00,0xc0,0x4f,0xd8,0xfd,0xff);



MIDL_DEFINE_GUID(CLSID, CLSID__DSSvcExWrap,0xFD2057FA,0x99FE,0x4f10,0x89,0x08,0x9A,0xA2,0xAA,0xB3,0x2A,0x6E);
MIDL_DEFINE_GUID(IID, IID_IWMIRefreshableCooker,0x13ED7E55,0x8D63,0x41b0,0x90,0x86,0xD0,0xC5,0xC1,0x73,0x64,0xC8);
MIDL_DEFINE_GUID(IID, IID_IWMISimpleObjectCooker,0xA239BDF1,0x0AB1,0x45a0,0x87,0x64,0x15,0x91,0x15,0x68,0x95,0x89);
MIDL_DEFINE_GUID(IID, IID_IWMISimpleCooker,0x510ADF6E,0xD481,0x4a64,0xB7,0x4A,0xCC,0x71,0x2E,0x11,0xAA,0x34);


typedef struct _ArrayCLSID {
    //REFGUID Clsid; 
    const GUID * pClsid;
    const char * pStrClsid;
} ArrayCLSID;

extern DWORD g_nClsids;

#endif /*__DATA_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\data.cpp ===
#define INITGUID

#include <data.h>


ArrayCLSID g_ArrayCLSID[] = { 
{ &CLSID_WmiRepository_SQL, "CLSID_WmiRepository_SQL" },
{ &CLSID_WmiRepository_Jet, "CLSID_WmiRepository_Jet" },
{ &CLSID_WmiRepositoryQuery, "CLSID_WmiRepositoryQuery" },
{ &CLSID_UmiDefURL, "CLSID_UmiDefURL" },
{ &CLSID_PseudoSink, "CLSID_PseudoSink" },
{ &CLSID_WbemClassObjectProxy, "CLSID_WbemClassObjectProxy" },
{ &CLSID_UmiObjectWrapperProxy, "CLSID_UmiObjectWrapperProxy" },
{ &CLSID_WbemEventSubsystem, "CLSID_WbemEventSubsystem" },
{ &CLSID_HmmpEventConsumerProvider, "CLSID_HmmpEventConsumerProvider" },
{ &CLSID_WbemFilterProxy, "CLSID_WbemFilterProxy" },
{ &CLSID_InProcWbemLevel1Login, "CLSID_InProcWbemLevel1Login" },
{ &CLSID__WmiFreeFormObject, "CLSID__WmiFreeFormObject" },
{ &CLSID__WmiObjectFactory, "CLSID__WmiObjectFactory" },
{ &CLSID__WbemUMIContextWrapper, "CLSID__WbemUMIContextWrapper" },
{ &CLSID__WmiErrorObject, "CLSID__WmiErrorObject" },
{ &CLSID__UmiErrorObject, "CLSID__UmiErrorObject" },
{ &CLSID_WinmgmtMofCompiler, "CLSID_WinmgmtMofCompiler" },
{ &CLSID_WbemTokenCache, "CLSID_WbemTokenCache" },
{ &CLSID_WmiESS, "CLSID_WmiESS" },
{ &CLSID_WmiProvSS, "CLSID_WmiProvSS" },
{ &CLSID_WmiProviderBindingFactory, "CLSID_WmiProviderBindingFactory" },
{ &CLSID_WmiProviderSharedFactory, "CLSID_WmiProviderSharedFactory" },
{ &CLSID_WmiProviderDedicatedFactory, "CLSID_WmiProviderDedicatedFactory" },
{ &CLSID_WmiProviderInProcFactory, "CLSID_WmiProviderInProcFactory" },
{ &CLSID_IWmiCoreServices, "CLSID_IWmiCoreServices" },
{ &CLSID__WmiWbemClass, "CLSID__WmiWbemClass" },
{ &CLSID__WmiWbemInstance, "CLSID__WmiWbemInstance" },
{ &CLSID__WmiQuery, "CLSID__WmiQuery" },
{ &CLSID__WbemUMIObjectWrapper, "CLSID__WbemUMIObjectWrapper" },
{ &CLSID__WbemEmptyClassObject, "CLSID__WbemEmptyClassObject" },
{ &CLSID__IWbemCallSec, "CLSID__IWbemCallSec" },
{ &CLSID__WbemConfigureRefreshingSvcs, "CLSID__WbemConfigureRefreshingSvcs" },
{ &CLSID__WbemRefresherMgr, "CLSID__WbemRefresherMgr" },
{ &CLSID__WbemHostedRefresherMgr, "CLSID__WbemHostedRefresherMgr" },
{ &CLSID__WbemComBinding, "CLSID__WbemComBinding" },
{ &CLSID__UmiComBinding, "CLSID__UmiComBinding" },
{ &CLSID_WbemLocator, "CLSID_WbemLocator" },
{ &CLSID_WbemConnection, "CLSID_WbemConnection" },
{ &CLSID_WbemContext, "CLSID_WbemContext" },
{ &CLSID_UnsecuredApartment, "CLSID_UnsecuredApartment" },
{ &CLSID_WbemClassObject, "CLSID_WbemClassObject" },
{ &CLSID_MofCompiler, "CLSID_MofCompiler" },
{ &CLSID_WbemStatusCodeText, "CLSID_WbemStatusCodeText" },
{ &CLSID_WbemBackupRestore, "CLSID_WbemBackupRestore" },
{ &CLSID_WbemRefresher, "CLSID_WbemRefresher" },
{ &CLSID_WbemObjectTextSrc, "CLSID_WbemObjectTextSrc" },
{ &CLSID_WbemAdministrativeLocator, "CLSID_WbemAdministrativeLocator" },
{ &CLSID_WbemAuthenticatedLocator, "CLSID_WbemAuthenticatedLocator" },
{ &CLSID_WbemUnauthenticatedLocator, "CLSID_WbemUnauthenticatedLocator" },
{ &CLSID_WbemDecoupledRegistrar, "CLSID_WbemDecoupledRegistrar" },
{ &CLSID_WbemDecoupledBasicEventProvider, "CLSID_WbemDecoupledBasicEventProvider" },
{ &CLSID_WbemLevel1Login, "CLSID_WbemLevel1Login" },
{ &CLSID_WbemDCOMTransport, "CLSID_WbemDCOMTransport" },
{ &CLSID_WbemLocalAddrRes, "CLSID_WbemLocalAddrRes" },
{ &CLSID_WbemUninitializedClassObject, "CLSID_WbemUninitializedClassObject" },
{ &CLSID_WbemDefPath, "CLSID_WbemDefPath" },
{ &CLSID_WbemQuery, "CLSID_WbemQuery" },
{ &CLSID_WMIExtension, "CLSID_WMIExtension" },
{ &CLSID_SWbemLocator, "CLSID_SWbemLocator" },
{ &CLSID_SWbemLocatorEx, "CLSID_SWbemLocatorEx" },
{ &CLSID_SWbemNamedValueSet, "CLSID_SWbemNamedValueSet" },
{ &CLSID_SWbemNamedValueSetEx, "CLSID_SWbemNamedValueSetEx" },
{ &CLSID_SWbemObjectPath, "CLSID_SWbemObjectPath" },
{ &CLSID_SWbemObjectPathEx, "CLSID_SWbemObjectPathEx" },
{ &CLSID_SWbemLastError, "CLSID_SWbemLastError" },
{ &CLSID_SWbemSink, "CLSID_SWbemSink" },
{ &CLSID_SWbemDateTime, "CLSID_SWbemDateTime" },
{ &CLSID_SWbemRefresher, "CLSID_SWbemRefresher" },
{ &CLSID_SWbemServices, "CLSID_SWbemServices" },
{ &CLSID_SWbemServicesEx, "CLSID_SWbemServicesEx" },
{ &CLSID_SWbemObject, "CLSID_SWbemObject" },
{ &CLSID_SWbemObjectEx, "CLSID_SWbemObjectEx" },
{ &CLSID_SWbemObjectSet, "CLSID_SWbemObjectSet" },
{ &CLSID_SWbemNamedValue, "CLSID_SWbemNamedValue" },
{ &CLSID_SWbemNamedValueEx, "CLSID_SWbemNamedValueEx" },
{ &CLSID_SWbemQualifier, "CLSID_SWbemQualifier" },
{ &CLSID_SWbemQualifierSet, "CLSID_SWbemQualifierSet" },
{ &CLSID_SWbemProperty, "CLSID_SWbemProperty" },
{ &CLSID_SWbemPropertyEx, "CLSID_SWbemPropertyEx" },
{ &CLSID_SWbemPropertySet, "CLSID_SWbemPropertySet" },
{ &CLSID_SWbemMethod, "CLSID_SWbemMethod" },
{ &CLSID_SWbemMethodSet, "CLSID_SWbemMethodSet" },
{ &CLSID_SWbemEventSource, "CLSID_SWbemEventSource" },
{ &CLSID_SWbemSecurity, "CLSID_SWbemSecurity" },
{ &CLSID_SWbemPrivilege, "CLSID_SWbemPrivilege" },
{ &CLSID_SWbemPrivilegeSet, "CLSID_SWbemPrivilegeSet" },
{ &CLSID_SWbemRefreshableItem, "CLSID_SWbemRefreshableItem" },
{ &CLSID_SWbemObjectPathComponents, "CLSID_SWbemObjectPathComponents" },
{ &CLSID_SWbemTransaction, "CLSID_SWbemTransaction" },
{ &CLSID_WmiMessageMsmqSender, "CLSID_WmiMessageMsmqSender" },
{ &CLSID_WmiMessageMsmqReceiver, "CLSID_WmiMessageMsmqReceiver" },
{ &CLSID_WmiMessageDcomSender, "CLSID_WmiMessageDcomSender" },
{ &CLSID_WmiMessageDcomReceiver, "CLSID_WmiMessageDcomReceiver" },
{ &CLSID_WmiMessageMultiSendReceive, "CLSID_WmiMessageMultiSendReceive" },
{ &CLSID_WmiMessageQueue, "CLSID_WmiMessageQueue" },
{ &CLSID_WmiMessageQueueManager, "CLSID_WmiMessageQueueManager" },
{ &CLSID_WmiMessageService, "CLSID_WmiMessageService" },
{ &CLSID_WmiSmartObjectMarshal, "CLSID_WmiSmartObjectMarshal" },
{ &CLSID_MsiMethodStatusSink, "CLSID_MsiMethodStatusSink" },
{ &CLSID_MsiProductMethods, "CLSID_MsiProductMethods" },
{ &CLSID_MsiSoftwareFeatureMethods, "CLSID_MsiSoftwareFeatureMethods" },
{ &CLSID_WMIObjectBroker, "CLSID_WMIObjectBroker" },
{ &CLSID_WMIObjectBrokerRegistration, "CLSID_WMIObjectBrokerRegistration" },
{ &CLSID_CMSnapin, "CLSID_CMSnapin" },
{ &CLSID_CMSnapinAbout, "CLSID_CMSnapinAbout" },
{ &CLSID_NSDrive, "CLSID_NSDrive" },
{ &CLSID_NSDriveAbout, "CLSID_NSDriveAbout" },
{ &CLSID_SDSnapin, "CLSID_SDSnapin" },
{ &CLSID_SDSnapinAbout, "CLSID_SDSnapinAbout" },
{ &CLSID_WMISnapin, "CLSID_WMISnapin" },
{ &CLSID_WMISnapinAbout, "CLSID_WMISnapinAbout" },
//{ &CLSID_HmmLocator, "CLSID_HmmLocator" },
//{ &CLSID_ContinousProvider_v1, "CLSID_ContinousProvider_v1" },
//{ &CLSID_IntProv, "CLSID_IntProv" },
{ &CLSID_MyEventProvider, "CLSID_MyEventProvider" },
//{ &CLSID_HiPerfCounter_v1, "CLSID_HiPerfCounter_v1" },
//{ &CLSID_LogicalDiskProv, "CLSID_LogicalDiskProv" },
//{ &CLSID_PERFSRV_v1, "CLSID_PERFSRV_v1" },
//{ &CLSID_HiPerfProvider_v1, "CLSID_HiPerfProvider_v1" },
//{ &CLSID_instprovider, "CLSID_instprovider" },
//{ &CLSID_PROPNAME, "CLSID_PROPNAME" },
//{ &CLSID_TemplateProvider, "CLSID_TemplateProvider" },
//{ &CLSID_TemplateAssocProvider, "CLSID_TemplateAssocProvider" },
//{ &CLSID_TransientProvider, "CLSID_TransientProvider" },
//{ &CLSID_TransientEventProvider, "CLSID_TransientEventProvider" },
//{ &CLSID_UpdConsProvider, "CLSID_UpdConsProvider" },
//{ &CLSID_UpdConsAssocProvider, "CLSID_UpdConsAssocProvider" },
//{ &CLSID_PseudoProvider, "CLSID_PseudoProvider" },
//{ &CLSID_MofConsumer, "CLSID_MofConsumer" },
//{ &CLSID_FwdConsProvider, "CLSID_FwdConsProvider" },
//{ &CLSID_FwdEventProvider, "CLSID_FwdEventProvider" },
//{ &CLSID_FwdAckEventProvider, "CLSID_FwdAckEventProvider" },
//{ &CLSID_KernelTraceProvider, "CLSID_KernelTraceProvider" },
//{ &CLSID_EventInstanceProvider, "CLSID_EventInstanceProvider" },
//{ &CLSID_NCProvider, "CLSID_NCProvider" },
//{ &CLSID_TestBlobDecoder, "CLSID_TestBlobDecoder" },
//{ &CLSID_ModuleScalar, "CLSID_ModuleScalar" },
//{ &CLSID_ModuleArray, "CLSID_ModuleArray" },
//{ &CLSID_ModuleGeneric, "CLSID_ModuleGeneric" },
//{ &CLSID_WbemConsoleConsumer, "CLSID_WbemConsoleConsumer" },
//{ &CLSID_TestEventProvider1, "CLSID_TestEventProvider1" },
//{ &CLSID_WbemActiveScriptConsumer, "CLSID_WbemActiveScriptConsumer" },
//{ &CLSID_WbemSMTPConsumer, "CLSID_WbemSMTPConsumer" },
//{ &CLSID_NewMail, "CLSID_NewMail" },
//{ &CLSID_WbemPagerConsumer, "CLSID_WbemPagerConsumer" },
//{ &CLSID_WbemLogFileConsumer, "CLSID_WbemLogFileConsumer" },
//{ &CLSID_WbemCommandLineConsumer, "CLSID_WbemCommandLineConsumer" },
//{ &CLSID_WbemNTEventLogConsumer, "CLSID_WbemNTEventLogConsumer" },
//{ &CLSID_WbemMsgBoxConsumer, "CLSID_WbemMsgBoxConsumer" },
//{ &CLSID_WbemPerformanceConsumer, "CLSID_WbemPerformanceConsumer" },
//{ &CLSID_VSAPlugIn, "CLSID_VSAPlugIn" },
//{ &CLSID_VSAToWMIEventProvider, "CLSID_VSAToWMIEventProvider" },
//{ &CLSID_FakeLEC, "CLSID_FakeLEC" },
//{ &CLSID_LECObj, "CLSID_LECObj" },
//{ &CLSID_MyEventConsumer, "CLSID_MyEventConsumer" },
//{ &CLSID_IWbemObjectSinkProxyStub, "CLSID_IWbemObjectSinkProxyStub" },
//{ &CLSID_IEnumWbemClassObjectProxyStub, "CLSID_IEnumWbemClassObjectProxyStub" },
//{ &CLSID_IWbemUnboundObjectSinkProxyStub, "CLSID_IWbemUnboundObjectSinkProxyStub" },
//{ &CLSID_IWbemMultiTargetProxyStub, "CLSID_IWbemMultiTargetProxyStub" },
//{ &CLSID_IWbemServicesExProxyStub, "CLSID_IWbemServicesExProxyStub" },
//{ &CLSID_IWbemServicesProxyStub, "CLSID_IWbemServicesProxyStub" },
//{ &CLSID_IWbemComBindingProxyStub, "CLSID_IWbemComBindingProxyStub" },
//{ &CLSID_DCOMAccessControl, "CLSID_DCOMAccessControl" },
//{ &CLSID_kerberosTest, "CLSID_kerberosTest" },
//{ &CLSID_IWbemLocator_Pipes, "CLSID_IWbemLocator_Pipes" },
//{ &CLSID_IWbemLocator_Tcpip, "CLSID_IWbemLocator_Tcpip" },
//{ &CLSID_IWbemAddressResolver_Tcpip, "CLSID_IWbemAddressResolver_Tcpip" },
//{ &CLSID_WbemTcpip, "CLSID_WbemTcpip" },
//{ &CLSID_WbemPipe, "CLSID_WbemPipe" },
{ &CLSID_WinNTConnectionObject, "CLSID_WinNTConnectionObject" },
{ &CLSID_LDAPConnectionObject, "CLSID_LDAPConnectionObject" },
//{ &CLSID_DcomMsgReceiveStub, "CLSID_DcomMsgReceiveStub" },
//{ &CLSID_ReceiveTest, "CLSID_ReceiveTest" },
//{ &CLSID_NT5PerfProvider_V1, "CLSID_NT5PerfProvider_V1" },
//{ &CLSID_Nt5PerProvider_v1, "CLSID_Nt5PerProvider_v1" },
//{ &CLSID_RayMccProv, "CLSID_RayMccProv" },
//{ &CLSID_WmiProvider, "CLSID_WmiProvider" },
//{ &CLSID_HmmClassInfoFilter, "CLSID_HmmClassInfoFilter" },
//{ &CLSID_HmmSql1Filter, "CLSID_HmmSql1Filter" },
//{ &CLSID_SQLOLEDB, "CLSID_SQLOLEDB" },
//{ &CLSID_testprov, "CLSID_testprov" },
//{ &CLSID_AssociationProvider, "CLSID_AssociationProvider" },
//{ &CLSID_RegProvider, "CLSID_RegProvider" },
//{ &CLSID_RegPropProv, "CLSID_RegPropProv" },
{ &CLSID_PerfProvider, "CLSID_PerfProvider" },
{ &CLSID_PerfPropProv, "CLSID_PerfPropProv" },
{ &CLSID_RegistryEventProvider, "CLSID_RegistryEventProvider" },
{ &CLSID__DSSvcExWrap,"CLSID__DSSvcExWrap"}
}; // end g_ArrayCLSID

DWORD g_nClsids = sizeof(g_ArrayCLSID)/sizeof(ArrayCLSID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\dumpwc.cpp ===
#include <wmiexts.h>

#include <oleauto.h>

#include <wbemutil.h>

#ifndef COREPROX_POLARITY
#define COREPROX_POLARITY
#endif

#include <arena.h>
#include <faster.h>
#include <faststr.h>
#include <wbemint.h>
#include <fastcls.h>
#include <var.h>
#include <fastinst.h>
#include <wbemdatapacket.h>

//#include <smartnextpacket.h>

#pragma pack( push )
#pragma pack( 1 )

// IWbemWCOSmartEnum::Next() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_SMARTENUM_NEXT
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_SMARTENUM_NEXT;

typedef WBEM_DATAPACKET_SMARTENUM_NEXT* PWBEM_DATAPACKET_SMARTENUM_NEXT;

// restore packing
#pragma pack( pop )


//#include <objarraypacket.h>

#pragma pack( push )
#pragma pack( 1 )

// IWbemClassObject Array Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_OBJECT_ARRAY
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwNumObjects;	// Number of objects in the array
} WBEM_DATAPACKET_OBJECT_ARRAY;

typedef WBEM_DATAPACKET_OBJECT_ARRAY* PWBEM_DATAPACKET_OBJECT_ARRAY;

// restore packing
#pragma pack( pop )


#pragma pack( push )
#pragma pack( 1 )

// IWbemObjectSink::Indicate() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_OBJECTSINK_INDICATE
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_OBJECTSINK_INDICATE;

typedef WBEM_DATAPACKET_OBJECTSINK_INDICATE* PWBEM_DATAPACKET_OBJECTSINK_INDICATE;

// restore packing
#pragma pack( pop )

#pragma pack( push )
#pragma pack( 1 )

// IWbemObjectSink::Indicate() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_UNBOUNDSINK_INDICATE
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwLogicalConsumerSize;	// Size of Logical Consumer Object
} WBEM_DATAPACKET_UNBOUNDSINK_INDICATE;

#ifdef _WIN64
typedef UNALIGNED WBEM_DATAPACKET_UNBOUNDSINK_INDICATE * PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE;
#else
typedef WBEM_DATAPACKET_UNBOUNDSINK_INDICATE * PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE;
#endif

// restore packing
#pragma pack( pop )

#pragma pack( push )
#pragma pack( 1 )

// IWbemMultiTarget::DeliverEvent() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT;

typedef WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT* PWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT;

// restore packing
#pragma pack( pop )



#include <wbemobjpacket.h>

#include <malloc.h>

#ifndef HEAP_ENTRY

typedef struct _HEAP_ENTRY 
{
    USHORT Size;
    USHORT PreviousSize;
    UCHAR SmallTagIndex;    
    UCHAR Flags;
    UCHAR UnusedBytes;
    UCHAR SegmentIndex;
#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;

#endif

void GetCompressedString(ULONG_PTR pRemoteAddr,
                         BYTE  * pBuff,
                         DWORD Size){

    if (pRemoteAddr) {
                         
        CCompressedString * pCS = (CCompressedString *)_alloca(Size*2);   
        ReadMemory(pRemoteAddr,pCS,Size*2,0);

        pBuff[Size-2]=0;
        pBuff[Size-1]=0;
        if (pCS->m_fFlags == STRING_FLAG_UNICODE){
           WideCharToMultiByte(CP_ACP,0,(WCHAR *)&(pCS->m_cFirstByte),-1,(LPSTR)pBuff,Size-2,NULL,NULL);
        } else {
            memcpy(pBuff,&(pCS->m_cFirstByte),Size-2);
        }
    } else {
        lstrcpyA((LPSTR)pBuff,"<NULL>");
    }

}

/*
protected:
    length_t m_nTotalLength;
    //CDecorationPart m_DecorationPart;
    CClassAndMethods m_ParentPart;
    CClassAndMethods m_CombinedPart;

    int m_nCurrentMethod;
	CLimitationMapping*	m_pLimitMapping;
    friend class CWbemInstance;

*/

/*
    CClassPart m_ClassPart;
    CMethodPart m_MethodPart;
    CWbemClass* m_pClass;
*/


void
DumpClass(CClassPart * pCls){

    BYTE pBuff[256];

    dprintf("     m_pContainer %p m_pParent %p m_pHeader %p\n",pCls->m_pContainer,pCls->m_pParent,pCls->m_pHeader);
    
    DEFINE_CPP_VAR(CClassPart::CClassPartHeader,varHeader);
    CClassPart::CClassPartHeader * pHeader = GET_CPP_VAR_PTR( CClassPart::CClassPartHeader , varHeader );

    if (pCls->m_pHeader){
        ReadMemory((ULONG_PTR)pCls->m_pHeader,pHeader,sizeof(CClassPart::CClassPartHeader),0);

        dprintf("      nLength %x fFlags %02x ptrClassName %08x nDataLength %x\n",pHeader->nLength,pHeader->fFlags,pHeader->ptrClassName,pHeader->nDataLength);
    }

    dprintf("   DL m_nNumStrings %x %08x\n",pCls->m_Derivation.m_nNumStrings,pCls->m_Derivation.m_pnLength);

    dprintf("   QS m_nLength %x m_pOthers %08x m_pHeap %08x\n",pCls->m_Qualifiers.m_nLength,pCls->m_Qualifiers.m_pOthers,pCls->m_Qualifiers.m_pHeap);

    DEFINE_CPP_VAR(CFastHeap,varCFastHeap);
    CFastHeap * pFHeap = GET_CPP_VAR_PTR( CFastHeap , varCFastHeap );
    ReadMemory((ULONG_PTR)pCls->m_Qualifiers.m_pHeap,pFHeap,sizeof(CFastHeap),0);
    dprintf("      FH  m_pHeapData %08x m_pHeapHeader %08x m_pContainer %08x\n",pFHeap->m_pHeapData,pFHeap->m_pHeapHeader,pFHeap->m_pContainer);
    
    dprintf("      m_nPropagationFlag %x m_nRef %x\n",pCls->m_Qualifiers.m_nPropagationFlag,pCls->m_Qualifiers.m_nRef);
    dprintf("      m_pControl %08x m_pContainer %08x m_pSecondarySet %08x\n",pCls->m_Qualifiers.m_pControl,pCls->m_Qualifiers.m_pContainer,pCls->m_Qualifiers.m_pSecondarySet);

    dprintf("      BA m_nSize %x m_astrStrings %08x\n",pCls->m_Qualifiers.m_astrCurrentNames.m_nSize,pCls->m_Qualifiers.m_astrCurrentNames.m_astrStrings);

    int nProp;
    if (pCls->m_Properties.m_pnProps) {

        ReadMemory((ULONG_PTR)pCls->m_Properties.m_pnProps,&nProp,sizeof(int),0);
        dprintf("   PR m_pnProps %08x %x m_pContainer %08x\n",pCls->m_Properties.m_pnProps,nProp,pCls->m_Properties.m_pContainer);

        CPropertyLookup * pPropLook = (CPropertyLookup *)_alloca(nProp*sizeof(CPropertyLookup));
        ReadMemory((ULONG_PTR)pCls->m_Properties.m_pnProps+sizeof(int),pPropLook,nProp*sizeof(CPropertyLookup),0);

        DWORD i;
        for (i=0;i<nProp;i++){

            pBuff[0]=0;
            if ((ULONG_PTR)(pCls->m_Heap.m_pHeapData+pPropLook[i].ptrName) != 0xffffffff){
                GetCompressedString((ULONG_PTR)(pCls->m_Heap.m_pHeapData+pPropLook[i].ptrName),pBuff,sizeof(pBuff));
            }

            DEFINE_CPP_VAR(CPropertyInformation,varCPropertyInformation);
            CPropertyInformation * pPropInfo = GET_CPP_VAR_PTR( CPropertyInformation , varCPropertyInformation );
            ReadMemory((ULONG_PTR)pCls->m_Heap.m_pHeapData+pPropLook[i].ptrInformation,pPropInfo ,sizeof(CPropertyInformation),0);


            dprintf("        prop %d %s Type %08x DataIdx %04x DataOff %08x Origin %08x\n",i,
                                          pBuff,
                                          pPropInfo->nType,
                                          pPropInfo->nDataIndex,
                                          pPropInfo->nDataOffset,
                                          pPropInfo->nOrigin);
            if (CheckControlC())
                break;
        }

    } else {
        dprintf("   PR m_pnProps %08x m_pContainer %08x\n",pCls->m_Properties.m_pnProps,pCls->m_Properties.m_pContainer);
    }    

    CDataTable * pCData = &pCls->m_Defaults;
    dprintf("   DT m_pNullness %08x m_pData %08x m_nLength %x m_nProps %x m_pContainer %08x\n",pCData->m_pNullness,pCData->m_pData,pCData->m_nLength,pCData->m_nProps,pCData->m_pContainer);

    dprintf("   FH m_pHeapData %08x m_pHeapHeader %08x m_pContainer %08x\n",pCls->m_Heap.m_pHeapData,pCls->m_Heap.m_pHeapHeader,pCls->m_Heap.m_pContainer);
    //CHeapHeader m_LocalHeapHeader;
    
    BYTE * pHeap = pCls->m_Heap.m_pHeapData;
    pBuff[0]=0;
    if ((DWORD)(pHeader->ptrClassName) != 0xffffffff){
        GetCompressedString((ULONG_PTR)(pHeap+pHeader->ptrClassName),pBuff,sizeof(pBuff));
    }
    dprintf("      __RELPATH %s\n",pBuff);
    

}

void DecodeStatus(DWORD dwInternalStatus)
{
    if (dwInternalStatus  & WBEM_OBJ_DECORATION_PART) dprintf("WBEM_OBJ_DECORATION_PART ");
    if (dwInternalStatus  & WBEM_OBJ_INSTANCE_PART) dprintf("WBEM_OBJ_INSTANCE_PART ");
    if (dwInternalStatus  & WBEM_OBJ_CLASS_PART) dprintf("WBEM_OBJ_CLASS_PART ");
    if (dwInternalStatus  & WBEM_OBJ_CLASS_PART_INTERNAL) dprintf("WBEM_OBJ_CLASS_PART_INTERNAL ");
    if (dwInternalStatus  & WBEM_OBJ_CLASS_PART_SHARED) dprintf("WBEM_OBJ_CLASS_PART_SHARED ");
};

DECLARE_API(wc) {

    INIT_API();

    DEFINE_CPP_VAR( CWbemClass, varCWbemClass);
    CWbemClass * pCls = GET_CPP_VAR_PTR( CWbemClass , varCWbemClass );
    
    ULONG_PTR pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte){
        ReadMemory(pByte,pCls,sizeof(CWbemClass),0);

        dprintf(" m_nRef %d m_bOwnMemory %d\n",pCls->m_nRef,pCls->m_bOwnMemory);
        dprintf(" m_nCurrentProp %08x m_lEnumFlags %08x m_lExtEnumFlags %08x\n",pCls->m_nCurrentProp,pCls->m_lEnumFlags,pCls->m_lExtEnumFlags);
        dprintf(" m_dwInternalStatus %08x m_pMergedClassObject %08x\n",pCls->m_dwInternalStatus,pCls->m_pMergedClassObject);
        
        BYTE * pData = pCls->m_DecorationPart.m_pfFlags;
        BYTE pBuff1[256];
        GetCompressedString((ULONG_PTR)pCls->m_DecorationPart.m_pcsServer,pBuff1,sizeof(pBuff1));
        BYTE pBuff2[256];
        GetCompressedString((ULONG_PTR)pCls->m_DecorationPart.m_pcsNamespace,pBuff2,sizeof(pBuff2));

        BYTE b=0xff;
        if (pData){
            ReadMemory((ULONG_PTR)pData,&b,sizeof(b),0);
        }
        dprintf("  m_DecorationPart.m_pfFlags %p FLAG %02x\n",pData,b);
        dprintf("  Server: %s Namespace: %s\n",pBuff1,pBuff2);

        dprintf("  m_LockData: m_lLock %d m_lLockCount %d m_dwThreadId %x\n",pCls->m_LockData.m_lLock,pCls->m_LockData.m_lLockCount,pCls->m_LockData.m_dwThreadId);

        dprintf("  m_Lock.m_pData %p\n",pCls->m_Lock.m_pData);

        //dprintf("  m_pBlobControl %08x m_refDataTable %08x m_refDataHeap %08x m_refDerivationList %08x\n",pCls->m_pBlobControl,((void *)&pCls->m_refDataTable),((void *)&pCls->m_refDataHeap),((void *)&pCls->m_refDerivationList));
        dprintf("  m_pBlobControl %p\n",pCls->m_pBlobControl);

        DEFINE_CPP_VAR( CDataTable,varCDataTable);
        CDataTable * pCData = GET_CPP_VAR_PTR(CDataTable,varCDataTable);
        if(pCData){
            ReadMemory((ULONG_PTR)(&(pCls->m_refDataTable)),pCData,sizeof(CDataTable),0);
            dprintf("     m_pNullness %p m_pData %p m_nLength %x m_nProps %x m_pContainer %08x\n",pCData->m_pNullness,pCData->m_pData,pCData->m_nLength,pCData->m_nProps,pCData->m_pContainer);
        }

        DEFINE_CPP_VAR(CFastHeap,varCFastHeap);
        CFastHeap * pFHeap = GET_CPP_VAR_PTR( CFastHeap , varCFastHeap );
        DWORD * pFoo = (DWORD *)&(pCls->m_refDataHeap);
        ReadMemory((ULONG_PTR )pFoo,pFHeap,sizeof(CFastHeap),0);
        dprintf("  FH m_pHeapData %p m_pHeapHeader %p m_pContainer %p\n",pFHeap->m_pHeapData,pFHeap->m_pHeapHeader,pFHeap->m_pContainer);
        
        dprintf("  m_nTotalLength %x\n",pCls->m_nTotalLength);

        dprintf("  m_ParentPart at offset %x\n",(ULONG_PTR)&pCls->m_ParentPart-(ULONG_PTR)pCls);
        dprintf("  m_ParentPart.m_pClassPart at offset %x\n",(ULONG_PTR)&(pCls->m_ParentPart.m_ClassPart)-(ULONG_PTR)pCls);


        DumpClass(&(pCls->m_ParentPart.m_ClassPart));

        dprintf("  m_CombinedPart at offset %x\n",(ULONG_PTR)&pCls->m_CombinedPart-(ULONG_PTR)pCls);

        DumpClass(&(pCls->m_CombinedPart.m_ClassPart));

        dprintf("  m_pClass %08x\n",pCls->m_ParentPart.m_pClass);
        
    } else {
        dprintf("invalid address %s\n",args);
    }

}

void
DumpInstance(CInstancePart * pIns)
{
    dprintf("     m_pContainer %08x m_pHeader %08x\n",pIns->m_pContainer,pIns->m_pHeader);

    dprintf("  DT m_DataTable m_pNullness %08x m_pData %08x\n",pIns->m_DataTable.m_pNullness,pIns->m_DataTable.m_pData);
    dprintf("     m_nLength %x m_nProps %x m_pContainer %08x\n",pIns->m_DataTable.m_nLength,pIns->m_DataTable.m_nProps,pIns->m_DataTable.m_pContainer);

    dprintf("  Q  m_Qualifiers m_nPropagationFlag %08x m_nRef %x m_pControl %08x\n",pIns->m_Qualifiers.m_nPropagationFlag,pIns->m_Qualifiers.m_nRef,pIns->m_Qualifiers.m_pControl);
    dprintf("     m_pContainer %08x m_pSecondarySet %08x\n",pIns->m_Qualifiers.m_pContainer,pIns->m_Qualifiers.m_pSecondarySet);
    CFixedBSTRArray * pArr = &(pIns->m_Qualifiers.m_astrCurrentNames);
    dprintf("     m_nCurrentIndex %x\n",pIns->m_Qualifiers.m_nCurrentIndex);

    DEFINE_CPP_VAR(CInstancePart::CInstancePartHeader,varHeader);
    CInstancePart::CInstancePartHeader * pHeader = GET_CPP_VAR_PTR( CInstancePart::CInstancePartHeader , varHeader );

    if (pIns->m_pHeader)
    {
        if (ReadMemory((ULONG_PTR)pIns->m_pHeader,pHeader,sizeof(CInstancePart::CInstancePartHeader),0))
        {
            dprintf("     nLength %x fFlags %02x ptrClassName %08x \n",pHeader->nLength,pHeader->fFlags,pHeader->ptrClassName);
        }
        else
        {
            dprintf("RM %p\n",pIns->m_pHeader);
        }
    }

    dprintf("  FH m_pHeapData %08x m_pHeapHeader %08x m_pContainer %08x\n",pIns->m_Heap.m_pHeapData,pIns->m_Heap.m_pHeapHeader,pIns->m_Heap.m_pContainer);
    
}


DECLARE_API(wi) 
{

    INIT_API();

    DEFINE_CPP_VAR( CWbemInstance, varCWbemInstance);
    CWbemInstance * pCls = GET_CPP_VAR_PTR( CWbemInstance , varCWbemInstance );
    
    ULONG_PTR pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte)
    {
        if (ReadMemory(pByte,pCls,sizeof(CWbemInstance),0))
        {
            //length_t m_nTotalLength;
            //dprintf("    m_nTotalLength %08x\n",pCls->m_nTotalLength);

            dprintf(" m_nRef %d m_bOwnMemory %d\n",pCls->m_nRef,pCls->m_bOwnMemory);
            dprintf(" m_nCurrentProp %08x m_lEnumFlags %08x m_lExtEnumFlags %08x\n",pCls->m_nCurrentProp,pCls->m_lEnumFlags,pCls->m_lExtEnumFlags);
            dprintf(" m_dwInternalStatus %08x\n",pCls->m_dwInternalStatus);
            DecodeStatus(pCls->m_dwInternalStatus);
            dprintf("\n");
            dprintf(" m_pMergedClassObject %08x\n",pCls->m_pMergedClassObject);
            
            BYTE * pData = pCls->m_DecorationPart.m_pfFlags;
            BYTE pBuff1[256];
            GetCompressedString((ULONG_PTR)pCls->m_DecorationPart.m_pcsServer,pBuff1,sizeof(pBuff1));
            BYTE pBuff2[256];
            GetCompressedString((ULONG_PTR)pCls->m_DecorationPart.m_pcsNamespace,pBuff2,sizeof(pBuff2));

            BYTE b=0xff;
            if (pData){
                ReadMemory((ULONG_PTR)pData,&b,sizeof(b),0);
            }
            dprintf("  m_DecorationPart.m_pfFlags %p FLAG %02x\n",pData,b);
            dprintf("  Server: %s Namespace: %s\n",pBuff1,pBuff2);

            //CClassPart m_ClassPart;
            DumpClass(&(pCls->m_ClassPart));

            //CInstancePart m_InstancePart;
            DumpInstance(&(pCls->m_InstancePart));
            
            //CVar m_CachedKey;
            dprintf("    m_vt %08x m_value %08x m_nStatus %08x m_bCanDelete %08x\n",pCls->m_CachedKey.m_vt,pCls->m_CachedKey.m_value.pUnk,pCls->m_CachedKey.m_nStatus,pCls->m_CachedKey.m_bCanDelete);
        }
        else
        {
            dprintf("RM %p\n",pByte);
        }
    } 
    else 
    {
        dprintf("invalid address %s\n",args);
    }
}


DECLARE_API(cp) {

    INIT_API();

    DEFINE_CPP_VAR( CClassPart, varCClassPart);
    CClassPart * pCls = GET_CPP_VAR_PTR( CClassPart , varCClassPart );
    
    ULONG_PTR pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte){
        ReadMemory(pByte,pCls,sizeof(CClassPart),0);

        DumpClass(pCls);
                
    } else {
        dprintf("invalid address %s\n",args);
    }

}

/*
typedef union
{
    char     cVal;          // VT_I1
    BYTE     bVal;          // VT_UI1
    SHORT    iVal;          // VT_I2
    WORD     wVal;          // VT_UI2
    LONG     lVal;          // VT_I4
    DWORD    dwVal;         // VT_UI4
    VARIANT_BOOL boolVal;   // VT_BOOL    

    float    fltVal;        // VT_R4
    double   dblVal;        // VT_R8

    LPSTR    pStr;          // VT_LPSTR
    LPWSTR   pWStr;         // VT_LPWSTR
    BSTR     Str;           // VT_BSTR      (stored as VT_LPWSTR)
    
    FILETIME Time;          // VT_FILETIME
    BLOB   Blob;            // VT_BLOB        
    LPCLSID  pClsId;        // VT_CLSID
    IUnknown* pUnk;         // VT_UNKNOWN
    IDispatch* pDisp;       // VT_DISPATCH
    CVarVector *pVarVector; // VT_EX_CVARVECTOR
        
}   METAVALUE;

    int m_vt;
    METAVALUE m_value;
    int m_nStatus;    
    BOOL m_bCanDelete;


*/

DECLARE_API(cvar) {

    INIT_API();

    DEFINE_CPP_VAR( CVar, varCVar);
    CVar * pVar = GET_CPP_VAR_PTR( CVar , varCVar );
    
    WCHAR pwBuff[128];
    CHAR  pBuff[128];
    
    ULONG_PTR pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte){
        ReadMemory(pByte,pVar,sizeof(CVar),0);

        switch(pVar->m_vt){
        case VT_I1:
            dprintf("VT_I1 %02x\n",pVar->m_value.cVal);
            break;
        case VT_UI1:
            dprintf("VT_UI1 %02x\n",pVar->m_value.bVal);
            break;

        case VT_I2:
            dprintf("VT_I2 %04x\n",pVar->m_value.iVal);
            break;

        case VT_UI2:
            dprintf("VT_UI2 %04x\n",pVar->m_value.wVal);
            break;

        case VT_I4:
            dprintf("VT_I4 %08x\n",pVar->m_value.lVal);
            break;

        case VT_UI4:
            dprintf("VT_UI4 %08x\n",pVar->m_value.dwVal);
            break;
            
        case VT_BOOL:
            dprintf("VT_BOOL  %04x\n",pVar->m_value.boolVal);
            break;

        case VT_R4:
            dprintf("VT_R4 %f\n",pVar->m_value.fltVal);
            break;
            
        case VT_R8:
            dprintf("VT_R8 %e\n",pVar->m_value.dblVal);
            break;
    
        case VT_LPSTR:
            ReadMemory((ULONG_PTR)pVar->m_value.pStr,pBuff,sizeof(pBuff),0);
            pBuff[sizeof(pBuff)-1]=0;
            dprintf("VT_LPSTR %s\n",pBuff);
            break;
            
        case VT_LPWSTR:
        case VT_BSTR:
            ReadMemory((ULONG_PTR)pVar->m_value.pWStr,pwBuff,sizeof(pwBuff),0);
            pwBuff[sizeof(pwBuff)-1]=0;
            WideCharToMultiByte(CP_ACP,0,pwBuff,-1,pBuff,sizeof(pBuff),NULL,NULL);
            pBuff[sizeof(pBuff)-1]=0;
            dprintf("VT_BSTR %s\n",pBuff);
            break;
/*
    
    FILETIME Time;          // VT_FILETIME
    BLOB   Blob;            // VT_BLOB        
    LPCLSID  pClsId;        // VT_CLSID
    IUnknown* pUnk;         // VT_UNKNOWN
    IDispatch* pDisp;       // VT_DISPATCH
  */    
        case VT_EX_CVARVECTOR:
        //CVarVector *pVarVector; // VT_EX_CVARVECTOR
            dprintf("VT_EX_CVARVECTOR %08x\n",pVar->m_value.pVarVector);
            break;
        default:
            dprintf("m_vt %08x\n",pVar->m_vt);
        }
        
    } else {
        dprintf("invalid address %s\n",args);
    }

}

/*
class POLARITY CVarVector
{
    int         m_nType;
    CFlexArray  m_Array;
    int         m_nStatus;
*/



LPSTR g_QualStrings[] = {
    "", // nothing for index 0
    "key", 
    "",
    "read", 
    "write",
    "volatile",
    "provider",
    "dynamic",
    "cimwin32",
    "DWORD",
    "CIMTYPE"
};

DWORD g_ValLengths[128] =
{
    /* 0*/ 0, 0, 2, 4, 4, 8, 0, 0, 4, 0,
    /*10*/ 0, 2, 0, 4, 0, 0, 1, 1, 2, 4,
    /*20*/ 8, 8, 0, 0, 0, 0, 0, 0, 0, 0,
    /*30*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*40*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*50*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*60*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*70*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*80*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*90*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*100*/0, 4, 4, 2, 0, 0, 0, 0, 0, 0,
    /*110*/0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*120*/0, 0, 0, 0, 0, 0, 0, 0
};

int lstrlenWunal( WCHAR UNALIGNED * pStr)
{
    int ret = 0;
    while (*pStr++) ret++;
    return ret;
};

VOID
ParseBlob(BYTE * pMemOrg,ULONG_PTR Addr)
{
    DWORD ClassPartLength = 0;
    DWORD i;
    BYTE * pMem = pMemOrg;
    BYTE Flags;
    BOOL IsInstance = FALSE;    
    BOOL SkipDecoration = TRUE;

    BYTE BFlags = *pMem;
    pMem++;
    if (OBJECT_FLAG_CLASS & BFlags )
    {
        dprintf("CLASS\n");
    }
    if (OBJECT_FLAG_INSTANCE & BFlags )
    {
        dprintf("INSTANCE\n");
        IsInstance = TRUE;
    }
    if (OBJECT_FLAG_DECORATED & BFlags)
    {
        dprintf("DECORATED\n");
    }
    if (OBJECT_FLAG_LIMITED & BFlags)
    {
        dprintf("LIMITED\n");
    }
    if (OBJECT_FLAG_CLIENT_ONLY & BFlags)
    {
        dprintf("CLIENT_ONLY\n");
    }
    
    if (BFlags & OBJECT_FLAG_DECORATED)
    {
        SkipDecoration = FALSE;
        //dprintf("decoration:\n");
        Flags = *pMem;
        pMem++;
        if (Flags == STRING_FLAG_UNICODE)
        {
            dprintf("SERVER   : %S\n",pMem);
            pMem+=(1+2*lstrlenWunal((WCHAR UNALIGNED *)pMem));
        }
        else
        {
            dprintf("SERVER   : %s\n",pMem);        
            pMem+=(1+lstrlenA((CHAR *)pMem));            
        }
        Flags = *pMem;
        pMem++;
        if (Flags == STRING_FLAG_UNICODE)
        {
            dprintf("namespace: %S\n",pMem);
            pMem+=(1+2*lstrlenWunal((WCHAR UNALIGNED *)pMem));
        }
        else
        {
            dprintf("NAMESPACE: %s\n",pMem);        
            pMem+=(1+lstrlenA((CHAR *)pMem));            
        }
    };

    ClassPartLength = *((DWORD UNALIGNED *)pMem);
    pMem += sizeof(DWORD);
    
    BYTE Unused = *pMem;
    pMem++;

    DWORD HeapPtrName = *((DWORD UNALIGNED *)pMem);
    pMem += sizeof(DWORD);

    DWORD NullDefaultSize = *((DWORD UNALIGNED *)pMem);
    pMem += sizeof(DWORD);

    DWORD DerivationSize = *((DWORD UNALIGNED *)pMem);
    DerivationSize &= 0xFFFF;

    //dprintf("D %08x\n",DerivationSize);
    
    DWORD QualSetSize    = *((DWORD UNALIGNED *)(pMem+DerivationSize));
    //dprintf("Q %08x\n",QualSetSize);
    QualSetSize &= 0xFFFF;
    DWORD NumProps       = *((DWORD UNALIGNED *)(pMem+DerivationSize+QualSetSize));
    
    DWORD UNALIGNED * pPropLookup  = (DWORD UNALIGNED *)(pMem+DerivationSize+QualSetSize+sizeof(DWORD));
    BYTE * pPropLookup_OOP = (BYTE *)Addr + (pMem - pMemOrg) + DerivationSize+QualSetSize;
    BYTE * HeapPtr = pMem + DerivationSize + QualSetSize + sizeof(DWORD) + NumProps*(2*sizeof(DWORD)) + NullDefaultSize;
    BYTE * HeapPtr_OOP = (BYTE *)Addr + (pMem - pMemOrg) + DerivationSize + QualSetSize + sizeof(DWORD) + NumProps*(2*sizeof(DWORD)) + NullDefaultSize;

    //dprintf("CPLen %p N %p D %p Q %p Prop %p Heap %p\n",
    //       ClassPartLength,
    //       NullDefaultSize,
    //       DerivationSize,QualSetSize,NumProps,*((DWORD UNALIGNED *)HeapPtr));

    dprintf("    class_and_method\n");

    dprintf("      class_Part\n");

    if (0xFFFFFFFF != HeapPtrName)
    {
        BYTE * pName = HeapPtr + sizeof(DWORD) + HeapPtrName;
        Flags = *pName;
        pName++;
        if (Flags == STRING_FLAG_UNICODE)
        {
            dprintf("        class   : %S\n",pName);
        }
        else
        {
            dprintf("        class   : %s\n",pName);        
        }        
    }
    else
    {
        dprintf("        class   : %08x\n",HeapPtrName);
    }
    // QualSet
    dprintf("        qualifierset %p\n",Addr+(pMem + DerivationSize - pMemOrg));
    ULONG_PTR pEndQualSet = (ULONG_PTR)pMem + DerivationSize + QualSetSize;
    BYTE * pQualSet = pMem + DerivationSize + sizeof(DWORD);

    //dprintf(" %p %p\n",pQualSet,pEndQualSet);
    while((ULONG_PTR)pQualSet < pEndQualSet)
    {
        DWORD dwHeapPtr = (*((DWORD UNALIGNED *)pQualSet));
        pQualSet += sizeof(DWORD);
        BYTE Flavor = *pQualSet;
        pQualSet += sizeof(BYTE);
        DWORD Type = (*((DWORD UNALIGNED *)pQualSet));
        pQualSet += sizeof(DWORD);
        BYTE * pData = pQualSet;
        pQualSet += g_ValLengths[Type&0x7F];

        if (dwHeapPtr & 0x80000000)
        {
            dprintf("            %s %02x %08x %p\n",g_QualStrings[dwHeapPtr&0x7fffffff],Flavor,Type,*(DWORD UNALIGNED *)pData);
        }
        else
        {
            dprintf("            %s %02x %08x %p\n",HeapPtr+dwHeapPtr+1+sizeof(DWORD),Flavor,Type,*(DWORD UNALIGNED *)pData);        
        }

        if (CheckControlC())
            break;
    }
    // property lookup table
    dprintf("        propertylookup %p\n",pPropLookup_OOP);
    for (i=0;i<NumProps;i++)
    {
        WORD UNALIGNED * pPropInfo = (WORD UNALIGNED *)(HeapPtr+sizeof(DWORD)+pPropLookup[1]);
        dprintf("            %08x %08x %s %08x %04x %08x %08x\n",
                 pPropLookup[0],pPropLookup[1],
                 HeapPtr+pPropLookup[0]+1+sizeof(DWORD),
                 *((DWORD UNALIGNED *)pPropInfo),
                 *(pPropInfo+2),
                 *(DWORD UNALIGNED *)(pPropInfo+3),
                 *(DWORD UNALIGNED *)(pPropInfo+5));
        pPropLookup += 2;
    }
    DWORD dwHeapSize_ClassPart = (*((DWORD UNALIGNED *)HeapPtr))&0x7FFFFFFF;
    dprintf("        Heap %p size %08x\n",HeapPtr_OOP,dwHeapSize_ClassPart);

    dprintf("      method_Part\n");
    BYTE * pMethodPart = HeapPtr + sizeof(DWORD) + dwHeapSize_ClassPart;
    BYTE * pMethodPart_OOP = HeapPtr_OOP + sizeof(DWORD) + dwHeapSize_ClassPart;

    DWORD dwSizeMethodPart = *((DWORD UNALIGNED *)pMethodPart);
    DWORD NumMethods = *((DWORD UNALIGNED *)(pMethodPart+sizeof(DWORD)));
    BYTE * pMethodDescription= pMethodPart + 2*sizeof(DWORD);
    BYTE * pMethodDescription_OOP = pMethodPart_OOP + 2*sizeof(DWORD);

    //BYTE * pHeapMethod_OOP = ;
    dprintf("        num_methods   : %08x\n",NumMethods);
    dprintf("        methods_descr : %p\n",pMethodDescription_OOP);
    //dprintf("        heap          : %p\n");

    BYTE * pCombinedPart = pMethodPart + dwSizeMethodPart;
    BYTE * pCombinedPart_OOP = pMethodPart_OOP + dwSizeMethodPart;

    if (IsInstance)
    {
        dprintf("    instance\n");

        DWORD dwHeapSize = 4 + (*((DWORD UNALIGNED *)HeapPtr)) & 0x7fffffff;
        //BYTE * HeapPtr_OOP 
        BYTE * pInstancePart = HeapPtr+dwHeapSize;
        BYTE * pInstancePart_OOP = HeapPtr_OOP+dwHeapSize;

        DWORD dwSize = *((DWORD UNALIGNED *)pInstancePart);
        pInstancePart += sizeof(DWORD);
        BYTE IFlag = *pInstancePart;
        pInstancePart++;
        DWORD dwClassNameOffset = *((DWORD UNALIGNED *)pInstancePart);
        pInstancePart += sizeof(DWORD);

        BYTE * pDataTable = pInstancePart;
        BYTE * pDataTable_OOP = pInstancePart_OOP + 2*sizeof(DWORD) + sizeof(BYTE);

        DWORD NumBytedNullNess = ((NumProps*2)%8)?(1+((NumProps*2)/8)):((NumProps*2)/8);
        BYTE * pDataTableData = pInstancePart + NumBytedNullNess;
        BYTE * pDataTableData_OOP = pDataTable_OOP + NumBytedNullNess;

        pInstancePart += NullDefaultSize; // this is crucial

        BYTE * pQualSet     = pInstancePart;
        BYTE * pQualSet_OOP = pDataTable_OOP + NullDefaultSize;
        DWORD  dwQualSetSize = *((DWORD UNALIGNED *)pQualSet);
        pInstancePart += dwQualSetSize;
        
        BYTE * pQualSetList = pInstancePart;
        BYTE * pInstanceHeap;
        BYTE * pInstanceHeap_OOP;
        if (0x01 == *pQualSetList)
        {
            // empty qual set OK
            pInstancePart++;
            pInstanceHeap = pInstancePart;
            pInstanceHeap_OOP = pQualSet_OOP+dwQualSetSize+sizeof(BYTE);
        } 
        else if (0x02 == *pQualSetList)
        {
            // multiple qualifier set 
            dprintf("unimplemented");
            return;
        }
        else
        {
            // invalid qualset
        }
        

        //NullDefaultSize

        dprintf("        begin            %p\n",pInstancePart_OOP);
        dprintf("        data_table: null %p data %p\n",pDataTable_OOP,pDataTableData_OOP);
        dprintf("        qual_set         %p\n",pQualSet_OOP);
        dprintf("        heap             %p\n",pInstanceHeap_OOP);
    }
    else
    {
        dprintf("    class_and_method\n");

        dprintf("      start : %p\n",pCombinedPart_OOP);
    
    }
}

DECLARE_API(blob) 
{
    INIT_API();

    char * pArgs = (char *)_alloca(strlen(args)+1);
    lstrcpy(pArgs,args);

    ULONG_PTR pByte = 0;
    ULONG_PTR Size = 0;

    while (isspace(*pArgs)) pArgs++;
    char * pAddress = pArgs;
    //dprintf("%s %s\n",pAddress,pArgs);
        // skip good chars
    while(*pArgs && !isspace(*pArgs)) pArgs++;

    if(*pArgs) // if there are more chars
    {
	    *pArgs = 0; //terminate string
	    pArgs++;
    	// skip spaces
	    while(isspace(*pArgs)) pArgs++;
	    if (*pArgs)
	    {
            //dprintf("%s\n",pArgs);	        
	        Size = GetExpression(pArgs);
	    }
    }
        
    pByte = GetExpression(pAddress);
    if (pByte)
    {        
        if (Size)
        {            
            BYTE * pHereMem = (BYTE *)HeapAlloc(GetProcessHeap(),0,Size*2);
            if (ReadMemory(pByte,pHereMem,Size*2,0))
            {
            //dprintf("    object @ %p size %x\n",pByte,Size);
                ParseBlob(pHereMem,pByte);
            }
            else
            {
                dprintf("RM %p\n",pByte);
            }
            HeapFree(GetProcessHeap(),0,pHereMem);            
        }
        else
        {
            HEAP_ENTRY HeapEntry;
            if (ReadMemory(pByte-(sizeof(HEAP_ENTRY)),&HeapEntry,sizeof(HEAP_ENTRY),0))
            {
                Size = HeapEntry.Size*sizeof(HEAP_ENTRY);

                BYTE * pHereMem = (BYTE *)HeapAlloc(GetProcessHeap(),0,Size);
                if (ReadMemory(pByte,pHereMem,Size,0))
                {
                    ParseBlob(pHereMem,pByte);
                }
                else
                {
                    dprintf("RM %p\n",pByte);
                }
                HeapFree(GetProcessHeap(),0,pHereMem);
            }
            else
            {
                dprintf("RM %p\n",pByte);
            }            
        }
    }

}


DECLARE_API(datap) 
{
    INIT_API();

    ULONG_PTR Addr = GetExpression(args);
    if (Addr)
    {

        DWORD dwSize =  256; // and let's hope
        	                      //sizeof(WBEM_DATAPACKET_HEADER) +
        	                      //sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT) + 
        	                      //sizeof(WBEM_DATAPACKET_OBJECT_ARRAY) +
        	                      //sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
        WBEM_DATAPACKET_HEADER * pData = (WBEM_DATAPACKET_HEADER *)_alloca(dwSize);
        if (ReadMemory(Addr,pData,dwSize,NULL))
        {
            dprintf("    Order %08x\n",pData->dwByteOrdering);
            dprintf("    Header %08x DSize %08x Flags %08x %02x ",
            	        pData->dwSizeOfHeader,
            	        pData->dwDataSize,
            	        pData->dwFlags,
            	        pData->bVersion);
            switch(pData->bPacketType)
            {
	     case WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE:
	     	  {
           	      dprintf("WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE\n");

           	      WBEM_DATAPACKET_OBJECTSINK_INDICATE UNALIGNED * pIndicate = (WBEM_DATAPACKET_OBJECTSINK_INDICATE UNALIGNED *)((BYTE *)pData + pData->dwSizeOfHeader);
                    dprintf("        Header %08x Size %08x\n",pIndicate->dwSizeOfHeader,pIndicate->dwDataSize);

	             WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED * pArrayPacket = (WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED *)((BYTE * )pIndicate+pIndicate->dwSizeOfHeader);
	             dprintf("            Header %08x Size %08x NumObj %08x\n",
	            	          pArrayPacket->dwSizeOfHeader,
	            	          pArrayPacket->dwDataSize,
	            	          pArrayPacket->dwNumObjects);
	             
	             WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED * pObjHeader = (WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED *)((BYTE*)pArrayPacket+pArrayPacket->dwSizeOfHeader);
	             dprintf("                Header %08x dwSizeOfData %08x bObjectType ",pObjHeader->dwSizeOfHeader,pObjHeader->dwSizeOfData);

	             switch(pObjHeader->bObjectType)	
	             {
	             	case WBEMOBJECT_NONE:
	             		dprintf("WBEMOBJECT_NONE\n");
	             		break;
 	              case WBEMOBJECT_CLASS_FULL:
	             		dprintf("WBEMOBJECT_CLASS_FULL\n");
	             		break; 	              	
	              case WBEMOBJECT_INSTANCE_FULL:
	             		dprintf("WBEMOBJECT_INSTANCE_FULL\n");
	             		break;	              	
                     case WBEMOBJECT_INSTANCE_NOCLASS:
	             		dprintf("WBEMOBJECT_INSTANCE_NOCLASS\n");
	             		break;                     	
	             };
	            
	             dprintf("    data: %p\n",Addr+pData->dwSizeOfHeader+pIndicate->dwSizeOfHeader+pArrayPacket->dwSizeOfHeader+pObjHeader->dwSizeOfHeader);                    
	     	  }
	         break;	     	
	     case WBEM_DATAPACKETTYPE_SMARTENUM_NEXT:
	     	  {
           	      dprintf("WBEM_DATAPACKETTYPE_SMARTENUM_NEXT\n");
           	      
	             WBEM_DATAPACKET_SMARTENUM_NEXT UNALIGNED * pSNext = (WBEM_DATAPACKET_SMARTENUM_NEXT UNALIGNED *)((BYTE *)pData + pData->dwSizeOfHeader);
	             dprintf("        Header %08x dwDataSize %08x\n",pSNext->dwSizeOfHeader,pSNext->dwDataSize);

	             WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED * pArrayPacket = (WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED *)((BYTE * )pSNext+pSNext->dwSizeOfHeader);
	             dprintf("            Header %08x Size %08x NumObj %08x\n",
	            	          pArrayPacket->dwSizeOfHeader,
	            	          pArrayPacket->dwDataSize,
	            	          pArrayPacket->dwNumObjects);
	             
	             WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED * pObjHeader = (WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED *)((BYTE*)pArrayPacket+pArrayPacket->dwSizeOfHeader);
	             dprintf("                Header %08x dwSizeOfData %08x bObjectType ",pObjHeader->dwSizeOfHeader,pObjHeader->dwSizeOfData);

	             switch(pObjHeader->bObjectType)	
	             {
	             	case WBEMOBJECT_NONE:
	             		dprintf("WBEMOBJECT_NONE\n");
	             		break;
 	              case WBEMOBJECT_CLASS_FULL:
	             		dprintf("WBEMOBJECT_CLASS_FULL\n");
	             		break; 	              	
	              case WBEMOBJECT_INSTANCE_FULL:
	             		dprintf("WBEMOBJECT_INSTANCE_FULL\n");
	             		break;	              	
                     case WBEMOBJECT_INSTANCE_NOCLASS:
	             		dprintf("WBEMOBJECT_INSTANCE_NOCLASS\n");
	             		break;                     	
	             };
	            
	             dprintf("    data: %p\n",Addr+pData->dwSizeOfHeader+pSNext->dwSizeOfHeader+pArrayPacket->dwSizeOfHeader+pObjHeader->dwSizeOfHeader);
	     	  }
	         break;	     	
	     case WBEM_DATAPACKETTYPE_UNBOUNDSINK_INDICATE:
	     	{
           	    dprintf("WBEM_DATAPACKETTYPE_UNBOUNDSINK_INDICATE\n");	     		
	     		WBEM_DATAPACKET_UNBOUNDSINK_INDICATE UNALIGNED * pUnBoundI = (WBEM_DATAPACKET_UNBOUNDSINK_INDICATE UNALIGNED *)((BYTE *)pData + pData->dwSizeOfHeader);
	     		dprintf("        Header %08x dwDataSize %08x dwLogicalConsumerSize %08x\n",pUnBoundI->dwSizeOfHeader,pUnBoundI->dwDataSize,pUnBoundI->dwLogicalConsumerSize);

	     	}
	        break;	     	
	     case WBEM_DATAPACKETTYPE_MULTITARGET_DELIVEREVENT:
	         {
           	  dprintf("WBEM_DATAPACKETTYPE_MULTITARGET_DELIVEREVENT\n");
           	     WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT UNALIGNED * pMultiTgtEvt = (WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT UNALIGNED *)((BYTE*)pData + pData->dwSizeOfHeader);
           	     dprintf("        Header %08x dwDataSize %08x\n",pMultiTgtEvt->dwSizeOfHeader,pMultiTgtEvt->dwDataSize);

	             WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED * pArrayPacket = (WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED *)((BYTE * )pMultiTgtEvt+pMultiTgtEvt->dwSizeOfHeader);
	             dprintf("            Header %08x Size %08x NumObj %08x\n",
	            	          pArrayPacket->dwSizeOfHeader,
	            	          pArrayPacket->dwDataSize,
	            	          pArrayPacket->dwNumObjects);
	             
	             WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED * pObjHeader = (WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED *)((BYTE*)pArrayPacket+pArrayPacket->dwSizeOfHeader);
	             dprintf("                Header %08x dwSizeOfData %08x bObjectType ",pObjHeader->dwSizeOfHeader,pObjHeader->dwSizeOfData);

	             switch(pObjHeader->bObjectType)	
	             {
	             	case WBEMOBJECT_NONE:
	             		dprintf("WBEMOBJECT_NONE\n");
	             		break;
 	              case WBEMOBJECT_CLASS_FULL:
	             		dprintf("WBEMOBJECT_CLASS_FULL\n");
	             		break; 	              	
	              case WBEMOBJECT_INSTANCE_FULL:
	             		dprintf("WBEMOBJECT_INSTANCE_FULL\n");
	             		break;	              	
                     case WBEMOBJECT_INSTANCE_NOCLASS:
	             		dprintf("WBEMOBJECT_INSTANCE_NOCLASS\n");
	             		break;                     	
	             };
                 
	         }
	         break;	     	
	     case WBEM_DATAPACKETTYPE_LAST:
           	  dprintf("WBEM_DATAPACKETTYPE_LAST\n");
	         break;
            }
            	
        }
        else
        {
            dprintf("RM %p\n",Addr);
        }
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\essutil.cpp ===
#include <wmiexts.h>
#include <malloc.h>

#include <wbemint.h>

#ifdef SetContext
#undef SetContext
#endif

#ifdef GetContext
#undef GetContext
#endif

#ifdef GetExpression
#undef GetExpression
#endif

#include <utilfun.h>

#define COREPROX_POLARITY

#include <esssink.h>
#include <ess.h>
#include <nsrep.h>
#include <equeue.h>

DWORD
CallBackDequeTurns(void * pLocationTurn_OOP,void * pLocationTurn_IP)
{
    CExecLine::CTurn * pTurn_OOP = (CExecLine::CTurn *)(*(void **)pLocationTurn_IP);

    DEFINE_CPP_VAR(CExecLine::CTurn,varCTurn);
    CExecLine::CTurn * pTurn = GET_CPP_VAR_PTR(CExecLine::CTurn,varCTurn);
    
    if (ReadMemory((ULONG_PTR)pTurn_OOP,pTurn,sizeof(CExecLine::CTurn),NULL))
    {
        dprintf("            m_lRef %x m_hEvent %x m_dwOwningThreadId %x\n",pTurn->m_lRef,pTurn->m_hEvent,pTurn->m_dwOwningThreadId);
    }
    else
    {
        dprintf("RM %p\n",pTurn_OOP);
    }
    return 0;
}

void Dump_EventProvRecord(MEMORY_ADDRESS pRecord_OOP)
{
    DEFINE_CPP_VAR(CEventProviderCache::CRecord,varCRecord);
    CEventProviderCache::CRecord * pRecord = GET_CPP_VAR_PTR(CEventProviderCache::CRecord,varCRecord);
    if (ReadMemory((ULONG_PTR)pRecord_OOP,pRecord,sizeof(CEventProviderCache::CRecord),NULL))
    {
        WCHAR pString[64];
        pString[0] = 0;
        pString[63] = 0;
        if (ReadMemory((ULONG_PTR)pRecord->m_strName,pString,sizeof(pString)-2,0))
        {
            dprintf("              m_strName   %S\n",pString);
        }
        else
        {
            dprintf("RM %p\n",pRecord->m_strName);
        }

        dprintf("              m_pProvider  %p\n",pRecord->m_pProvider);
        dprintf("              m_pQuerySink %p\n",pRecord->m_pQuerySink);
        dprintf("              m_pSecurity  %p\n",pRecord->m_pSecurity);
        dprintf("              m_pMainSink  %p\n",pRecord->m_pMainSink);
        dprintf("              m_ExecLine   %p\n",pRecord_OOP + FIELD_OFFSET(CEventProviderCache::CRecord,m_Line));
        PrintDequeCB(pRecord_OOP + FIELD_OFFSET(CEventProviderCache::CRecord,m_Line)+FIELD_OFFSET(CExecLine,m_qTurns),CallBackDequeTurns);
    }
    else
    {
        dprintf("RM %p\n",pRecord_OOP);
    }
}

DWORD
CallBackFilter(void * pKey, void * pValue)
{

    MEMORY_ADDRESS pVTable;
    if (ReadMemory((ULONG_PTR)pKey,&pVTable,sizeof(pVTable),0))
    {    
        BYTE pString[256];
        pString[0]=0;

    #ifdef KDEXT_64BIT
            ULONG64 Displ;
    #else
            ULONG Displ;
    #endif        
        GetSymbol(pVTable,(PCHAR)pString,&Displ);
        if (lstrlenA((CHAR *)pString))
        {
            dprintf("          %s+%x\n",pString,Displ);
            if (strstr((const CHAR *)pString,"CTempFilter"))
            {
                ULONG_PTR pStrLoc = (ULONG_PTR)pKey + FIELD_OFFSET(CTempFilter,m_wszQuery);
                ULONG_PTR pStr_OOP;
                if (ReadMemory(pStrLoc,&pStr_OOP,sizeof(pStr_OOP),0))
                {
                    WCHAR pStringQuery[256];
                    pStringQuery[0] = 0;
                    ULONG lRead = 0;
                    ReadMemory(pStr_OOP,pStringQuery,sizeof(pStringQuery),&lRead);
                    if (lRead)
                    {
                        dprintf("          QUERY: %S\n",pStringQuery);
                    }
                    else
                    {
                        dprintf("RM %p\n",pStr_OOP);
                    }                        
                }
                else
                {
                    dprintf("RM %p\n",pStrLoc);
                }
            }
            else if (strstr((const CHAR *)pString,"CPermanentFilter"))
            {
                ULONG_PTR pStrLoc = (ULONG_PTR)pKey + FIELD_OFFSET(CPermanentFilter,m_pcsQuery);
                ULONG_PTR pStr_OOP;
                if (ReadMemory(pStrLoc,&pStr_OOP,sizeof(pStr_OOP),0))
                {
                    struct CompressedString_ 
                    {
                        BYTE  Flag;
                        CHAR pStringQuery[256];
                    } CompStr;
                    CompStr.pStringQuery[0] = 0;
                    ULONG lRead = 0;
                    ReadMemory(pStr_OOP,&CompStr,sizeof(CompStr),&lRead);
                    if (lRead)
                    {
                        if (CompStr.Flag)
                            dprintf("          QUERY: %S\n",CompStr.pStringQuery);
                        else
                            dprintf("          QUERY: %s\n",CompStr.pStringQuery);
                    }
                    else
                    {
                        dprintf("RM %p\n",pStr_OOP);
                    }                        
                }
                else
                {
                    dprintf("RM %p\n",pStrLoc);
                }                
            }
            else
            {
                dprintf("        UNKNOWN\n");
            }
        }
    }
    else
    {
        dprintf("RM %p\n",pKey);
    }
    return 0;
}

DWORD
CallBackEssNamespace(void * pKey, void * pValue)
{
    WCHAR pName[MAX_PATH+1];
    pName[MAX_PATH] = 0;

    if (pKey && ReadMemory((ULONG_PTR)pKey,pName,MAX_PATH*sizeof(WCHAR),NULL))
    {
        dprintf("      %S\n",pName);
    }

    DEFINE_CPP_VAR(CEssNamespace,varCEssNamespace);
    CEssNamespace * pEssNameSpace = GET_CPP_VAR_PTR(CEssNamespace,varCEssNamespace);

    if (pValue && ReadMemory((ULONG_PTR)pValue,pEssNameSpace,sizeof(CEssNamespace),NULL))
    {
        dprintf("      %p\n",pValue);        
        dprintf("      m_csLevel2: owner %x event %x\n",pEssNameSpace->m_csLevel2.m_dwThreadId,pEssNameSpace->m_csLevel2.m_hEvent);
        dprintf("      m_aDeferredEvents size %x %p\n",pEssNameSpace->m_aDeferredEvents.m_Array.m_nSize,pEssNameSpace->m_aDeferredEvents.m_Array.m_pArray);
        dprintf("      m_wszName          %p\n",pEssNameSpace->m_wszName);
        dprintf("      m_pProviderFactory %p\n",pEssNameSpace->m_pProviderFactory);
        dprintf("      m_pCoreSvc         %p\n",pEssNameSpace->m_pCoreSvc);
        dprintf("      m_pFullSvc         %p\n",pEssNameSpace->m_pFullSvc);
        dprintf("      m_pInternalCoreSvc %p\n",pEssNameSpace->m_pInternalCoreSvc);
        dprintf("      m_pInternalFullSvc %p\n",pEssNameSpace->m_pInternalFullSvc);
        //
        CBindingTable * pBinding = &pEssNameSpace->m_Bindings;
        dprintf("      m_Binding\n");        

        dprintf("        wbemess!CEventFilter\n");        
        _Map * pMapF = (_Map *)((BYTE*)pValue+FIELD_OFFSET(CEssNamespace,m_Bindings)+FIELD_OFFSET(CBindingTable,m_apFilters)+FIELD_OFFSET(CSortedRefedKeyedPointerArray<CEventFilter>,m_t));
        //&pBinding->m_apFilters.m_t;
        PrintMapCB(pMapF,TRUE,CallBackFilter); 
        
        dprintf("        wbemess!CEventConsumer\n");        
        _Map * pMapC = (_Map *)((BYTE*)pValue+FIELD_OFFSET(CEssNamespace,m_Bindings)+FIELD_OFFSET(CBindingTable,m_apConsumers)+FIELD_OFFSET(CSortedRefedKeyedPointerArray<CEventConsumer>,m_t));
        PrintMapCB(pMapC,TRUE,CallBackObj); 

        DWORD NumElCons = pEssNameSpace->m_ConsumerProviderCache.m_apRecords.m_Array.m_nSize;
        VOID * pVoid = pEssNameSpace->m_ConsumerProviderCache.m_apRecords.m_Array.m_pArray;
        VOID **ppPointers = (VOID **)_alloca(NumElCons * sizeof(VOID *));
        dprintf("        wbemess!CConsumerProviderCache %x - %p\n",NumElCons,pVoid);
        if (ReadMemory((ULONG_PTR)pVoid,ppPointers,NumElCons * sizeof(VOID *),NULL))
        {
            for (DWORD i=0;i<NumElCons;i++)
            {
                dprintf("          %x - %p\n",i,ppPointers[i]);
            }
        }

        //m_EventProviderCache
        DWORD NumElProv = pEssNameSpace->m_EventProviderCache.m_aRecords.m_Array.m_nSize;
        pVoid = pEssNameSpace->m_EventProviderCache.m_aRecords.m_Array.m_pArray;
        if (NumElProv > NumElCons)
        	ppPointers = (VOID **)_alloca(NumElProv * sizeof(VOID *));
        dprintf("        wbemess!CEventProviderCache %x - %p\n",NumElProv,pVoid);
        if (ReadMemory((ULONG_PTR)pVoid,ppPointers,NumElProv * sizeof(VOID *),NULL))
        {
            for (DWORD i=0;i<NumElProv;i++)
            {
                dprintf("          %x - %p\n",i,ppPointers[i]);
                Dump_EventProvRecord((MEMORY_ADDRESS)ppPointers[i]);
            }
        }
        
        
        dprintf("          ----------------------- End of Namespace\n");
    }

    return 0;
}

//
// prototype declaration
//
void DumpRecord(ULONG_PTR pRecord_OOP,
                HANDLE hSourceProcess,
                pfnDumpRequest DumpRequest);


DWORD DumpCExecRequest(ULONG_PTR pExecReq_OOP)
{

    DEFINE_CPP_VAR(CEventQueue::CDeliverRequest,varCExecRequest);
    CEventQueue::CDeliverRequest * pExecReq = GET_CPP_VAR_PTR(CEventQueue::CDeliverRequest,varCExecRequest);
    
    ReadMemory((ULONG_PTR)pExecReq_OOP,pExecReq,sizeof(CEventQueue::CDeliverRequest),NULL);

    GetVTable((MEMORY_ADDRESS)pExecReq_OOP);
    dprintf("          %p m_hWhenDone\n",pExecReq->m_hWhenDone);      // Ptr32 to Void
    dprintf("          %p m_pNext\n",pExecReq->m_pNext);          // Ptr32 CCoreExecReq
    dprintf("          %08x m_lPriority\n",pExecReq->m_lPriority);      // Int 4B
    dprintf("          %d m_fOk\n",pExecReq->m_fOk);            // Char
    dprintf("          %p m_pConsumer ",pExecReq->m_pConsumer);         // Ptr32 _IWmiCoreHandle
    if (pExecReq->m_pConsumer){
        GetVTable((MEMORY_ADDRESS)pExecReq->m_pConsumer);    
    }    
    return 0;
}


void
Print_CEventQueue(ULONG_PTR pEventQueue_OOP, HANDLE hCurrentProcess)
{

    DEFINE_CPP_VAR(CEventQueue,varCEventQueue);
    CEventQueue * pEventQueue = GET_CPP_VAR_PTR(CEventQueue,varCEventQueue);
         

    if (ReadMemory(pEventQueue_OOP,pEventQueue,sizeof(CEventQueue),NULL))
    {
        dprintf("    CEventQueue @ %p\n",pEventQueue);
        
        //m_aThreads       : CFlexArray
        dprintf("    elems %d pointer %p\n",pEventQueue->m_aThreads.m_nSize,pEventQueue->m_aThreads.m_pArray);

        CExecQueue::CThreadRecord ** pRecord_OOP = (CExecQueue::CThreadRecord **)_alloca(sizeof(void*)*pEventQueue->m_aThreads.m_nSize);
        if (ReadMemory((ULONG_PTR)pEventQueue->m_aThreads.m_pArray,pRecord_OOP,sizeof(void*)*pEventQueue->m_aThreads.m_nSize,0))
        {

            DWORD i;
            for (i=0;i<pEventQueue->m_aThreads.m_nSize;i++)
            {
                dprintf("      -- CThreadRecord %d\n",i);
                DumpRecord((ULONG_PTR)pRecord_OOP[i],
                           hCurrentProcess,
                           DumpCExecRequest);
            }
        }

        dprintf("    m_pHead %p\n",pEventQueue->m_pHead);
        dprintf("    m_pTail %p\n",pEventQueue->m_pTail);
        // here code for the list
        CEventQueue::CDeliverRequest * pReq = (CEventQueue::CDeliverRequest *)pEventQueue->m_pHead;
            DWORD i = 0;
            while (pReq)
            {
                dprintf(" ---- list - %d\n",i++);
                DEFINE_CPP_VAR(CEventQueue::CDeliverRequest,MyAsyncReq);
                CEventQueue::CDeliverRequest * pReqHERE = GET_CPP_VAR_PTR(CEventQueue::CDeliverRequest,MyAsyncReq);
                ReadMemory((ULONG_PTR)pReq,pReqHERE,sizeof(CEventQueue::CDeliverRequest),NULL);

                //dprintf("   %p %p\n",pReq,pReqHERE->m_pNext);
                DumpCExecRequest((ULONG_PTR)pReq);

                if (pReq == pEventQueue->m_pTail)
                    break;
                
                pReq = (CEventQueue::CDeliverRequest *)pReqHERE->m_pNext;                

                if (CheckControlC())
                    break;                
            }
            //
   
            dprintf("    m_lNumThreads   %d \n",pEventQueue->m_lNumThreads);
            dprintf("    m_lNumIdle      %d\n",pEventQueue->m_lNumIdle);
            dprintf("    m_lNumRequests  %d\n",pEventQueue->m_lNumRequests);   
            dprintf("    m_lMaxThreads   %d\n",pEventQueue->m_lMaxThreads);    
            dprintf("    m_lHiPriBound      %d\n",pEventQueue->m_lHiPriBound);    
            dprintf("    m_lHiPriMaxThreads %d\n",pEventQueue->m_lHiPriMaxThreads); 
            dprintf("    m_lStartSlowdownCount  %d\n",pEventQueue->m_lStartSlowdownCount);
            dprintf("    m_lAbsoluteLimitCount  %d\n",pEventQueue->m_lAbsoluteLimitCount); 
            dprintf("    m_lOneSecondDelayCount %d\n",pEventQueue->m_lOneSecondDelayCount); 
            dprintf("    m_dblAlpha  %f\n",pEventQueue->m_dblAlpha);
            dprintf("    m_dblBeta   %f\n",pEventQueue->m_dblBeta);
            dprintf("    m_dwTimeout %x\n",pEventQueue->m_dwTimeout);
            dprintf("    m_pEss      %p\n",pEventQueue->m_pEss);
            
    }
    else
    {
        dprintf("RM %p\n",pEventQueue_OOP);
    }
}       

DECLARE_API(ess) 
{

    INIT_API();
    
    ULONG_PTR Addr = (ExtensionApis.lpGetExpressionRoutine)("wbemcore!g_pESS");
    VOID * pVoid= NULL;
    if (!Addr)
    {
    	pVoid = (VOID *)(ExtensionApis.lpGetExpressionRoutine)(args);
    }
    if (Addr || pVoid) 
    {
        if (Addr)
            ReadMemory(Addr,&pVoid,sizeof(pVoid),NULL);
    
        DEFINE_CPP_VAR(CEssObjectSink::XNewESS,varImp);
        CEssObjectSink::XNewESS * pImp = GET_CPP_VAR_PTR(CEssObjectSink::XNewESS,varImp);
        if (ReadMemory((ULONG_PTR)pVoid,pImp,sizeof(CEssObjectSink::XNewESS),NULL))
        {
            dprintf(" CEssObjectSink %p\n",pImp->m_pObject);
            DEFINE_CPP_VAR(CEssObjectSink,varCEssObjectSink);
            CEssObjectSink * pEssSink = GET_CPP_VAR_PTR(CEssObjectSink,varCEssObjectSink);
            if (ReadMemory((ULONG_PTR)pImp->m_pObject,pEssSink,sizeof(CEssObjectSink),NULL))
            {
                Print_CEventQueue((ULONG_PTR)pEssSink->m_pEss+FIELD_OFFSET(CEss,m_Queue),hCurrentProcess);
            
                dprintf("    m_pEss          %p\n",pEssSink->m_pEss);
                dprintf("    m_bShutdown     %08x\n",pEssSink->m_bShutdown);
                dprintf("    m_pCoreServices %p\n",pEssSink->m_pCoreServices);
                
                // CEss;
                DEFINE_CPP_VAR(CEss,varCEss);
                CEss * pEss = GET_CPP_VAR_PTR(CEss,varCEss);

                if (ReadMemory((ULONG_PTR)pEssSink->m_pEss,pEss,sizeof(CEss),NULL))
                {
                    _Map * pMap = (_Map *)((BYTE *)pEssSink->m_pEss + FIELD_OFFSET(CEss,m_mapNamespaces));
                    PrintMapCB(pMap,TRUE,CallBackEssNamespace);    
                }
                else
                {
                    dprintf("RM %p err %d\n",pEssSink->m_pEss,GetLastError());
                }
            }
	        else
    	    {
        	    dprintf("RM %p err %d\n",pImp->m_pObject,GetLastError());
	        }            
        }
        else
        {
            dprintf("RM %p err %d\n",Addr,GetLastError());
        }
    }
    else 
    {
        dprintf("invalid address %s\n",args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\heappagi.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappagi.h

Abstract:

    The following definitions are internal to the debug heap manager,
    but are placed in this include file so that debugger extensions
    can reference the same structure definitions.  The following
    definitions are not intended to be referenced externally except
    by debugger extensions.

Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_I_
#define _HEAP_PAGE_I_

#ifdef DEBUG_PAGE_HEAP

#include "heap.h"

#define DPH_INTERNAL_DEBUG      0   // change to 0 or #undef for production code

//
// Stack trace size. 
//
                                
#define DPH_MAX_STACK_LENGTH   16

//
// Capture stacktraces in any context (x86/alpha, fre/chk). On alpha
// the stack acquisition function will fail and no stack trace will be
// acquired but in case we will find a better algorithm the page heap
// code will automatically take advantage of that.
//

#define DPH_CAPTURE_STACK_TRACE 1

//
// DPH_HEAP_BLOCK
//

typedef struct _DPH_HEAP_BLOCK DPH_HEAP_BLOCK, *PDPH_HEAP_BLOCK;

struct _DPH_HEAP_BLOCK {

    //
    //  Singly linked list of allocations (pNextAlloc must be
    //  first member in structure).
    //

    PDPH_HEAP_BLOCK pNextAlloc;

    //
    //   | PAGE_READWRITE          | PAGE_NOACCESS           |
    //   |____________________|___||_________________________|
    //
    //   ^pVirtualBlock       ^pUserAllocation
    //
    //   |---------------- nVirtualBlockSize ----------------|
    //
    //   |---nVirtualAccessSize----|
    //
    //                        |---|  nUserRequestedSize
    //
    //                        |----|  nUserActualSize
    //

    PUCHAR pVirtualBlock;
    SIZE_T  nVirtualBlockSize;

    SIZE_T  nVirtualAccessSize;
    PUCHAR pUserAllocation;
    SIZE_T  nUserRequestedSize;
    SIZE_T  nUserActualSize;
    PVOID  UserValue;
    ULONG  UserFlags;

    PRTL_TRACE_BLOCK StackTrace_;
};


typedef struct _DPH_HEAP_ROOT DPH_HEAP_ROOT, *PDPH_HEAP_ROOT;

struct _DPH_HEAP_ROOT {

    //
    //  Maintain a signature (DPH_HEAP_SIGNATURE) as the
    //  first value in the heap root structure.
    //

    ULONG                 Signature;
    ULONG                 HeapFlags;

    //
    //  Access to this heap is synchronized with a critical section.
    //

    PRTL_CRITICAL_SECTION HeapCritSect;
    ULONG                 nRemoteLockAcquired;

    //
    //  The "VirtualStorage" list only uses the pVirtualBlock,
    //  nVirtualBlockSize, and nVirtualAccessSize fields of the
    //  HEAP_ALLOCATION structure.  This is the list of virtual
    //  allocation entries that all the heap allocations are
    //  taken from.
    //

    PDPH_HEAP_BLOCK  pVirtualStorageListHead;
    PDPH_HEAP_BLOCK  pVirtualStorageListTail;
    ULONG                 nVirtualStorageRanges;
    SIZE_T                 nVirtualStorageBytes;

    //
    //  The "Busy" list is the list of active heap allocations.
    //  It is stored in LIFO order to improve temporal locality
    //  for linear searches since most initial heap allocations
    //  tend to remain permanent throughout a process's lifetime.
    //

    PDPH_HEAP_BLOCK  pBusyAllocationListHead;
    PDPH_HEAP_BLOCK  pBusyAllocationListTail;
    ULONG                 nBusyAllocations;
    SIZE_T                 nBusyAllocationBytesCommitted;

    //
    //  The "Free" list is the list of freed heap allocations, stored
    //  in FIFO order to increase the length of time a freed block
    //  remains on the freed list without being used to satisfy an
    //  allocation request.  This increases the odds of catching
    //  a reference-after-freed bug in an app.
    //

    PDPH_HEAP_BLOCK  pFreeAllocationListHead;
    PDPH_HEAP_BLOCK  pFreeAllocationListTail;
    ULONG                 nFreeAllocations;
    SIZE_T                 nFreeAllocationBytesCommitted;

    //
    //  The "Available" list is stored in address-sorted order to facilitate
    //  coalescing.  When an allocation request cannot be satisfied from the
    //  "Available" list, it is attempted from the free list.  If it cannot
    //  be satisfied from the free list, the free list is coalesced into the
    //  available list.  If the request still cannot be satisfied from the
    //  coalesced available list, new VM is added to the available list.
    //

    PDPH_HEAP_BLOCK  pAvailableAllocationListHead;
    PDPH_HEAP_BLOCK  pAvailableAllocationListTail;
    ULONG                 nAvailableAllocations;
    SIZE_T                 nAvailableAllocationBytesCommitted;

    //
    //  The "UnusedNode" list is simply a list of available node
    //  entries to place "Busy", "Free", or "Virtual" entries.
    //  When freed nodes get coalesced into a single free node,
    //  the other "unused" node goes on this list.  When a new
    //  node is needed (like an allocation not satisfied from the
    //  free list), the node comes from this list if it's not empty.
    //

    PDPH_HEAP_BLOCK  pUnusedNodeListHead;
    PDPH_HEAP_BLOCK  pUnusedNodeListTail;
    ULONG                 nUnusedNodes;

    SIZE_T                 nBusyAllocationBytesAccessible;

    //
    //  Node pools need to be tracked so they can be protected
    //  from app scribbling on them.
    //

    PDPH_HEAP_BLOCK  pNodePoolListHead;
    PDPH_HEAP_BLOCK  pNodePoolListTail;
    ULONG                 nNodePools;
    SIZE_T                 nNodePoolBytes;

    //
    //  Doubly linked list of DPH heaps in process is tracked through this.
    //

    LIST_ENTRY NextHeap;

    //
    // These are extra flags used to control page heap behavior.
    // During heap creation the current value of the global page heap
    // flags (process wise) is written into this field.
    //

    ULONG                 ExtraFlags;

    //
    // Seed for the random generator used to decide from where
    // should we make an allocation (normal or verified heap).
    // The field is protected by the critical section associated
    // with each page heap.
    //

    ULONG                  Seed;

    //
    // `NormalHeap' is used in case we want to combine verified allocations
    // with normal ones. This is useful to minimize memory impact. Without
    // this feature certain processes that are very heap intensive cannot
    // be verified at all.
    //

    PVOID                 NormalHeap;

    //
    // Heap creation stack trace.
    //

    PRTL_TRACE_BLOCK      CreateStackTrace;

    //
    // Thread ID of the first thread inside the heap.
    //

    HANDLE FirstThread;
};


//
// DPH_BLOCK_INFORMATION
//
// This structure is stored in every page heap allocated block.
// This information is not saved if the catch backward overruns
// flag is set.
//

#define DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED   0xABCDAAAA
#define DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED     0xDCBAAAAA
#define DPH_NORMAL_BLOCK_START_STAMP_FREE        (0xABCDAAAA - 1)
#define DPH_NORMAL_BLOCK_END_STAMP_FREE          (0xDCBAAAAA - 1)

#define DPH_PAGE_BLOCK_START_STAMP_ALLOCATED     0xABCDBBBB
#define DPH_PAGE_BLOCK_END_STAMP_ALLOCATED       0xDCBABBBB
#define DPH_PAGE_BLOCK_START_STAMP_FREE          (0xABCDBBBB - 1)
#define DPH_PAGE_BLOCK_END_STAMP_FREE            (0xDCBABBBB - 1)

#define DPH_NORMAL_BLOCK_SUFFIX 	0xA0
#define DPH_PAGE_BLOCK_PREFIX 	    0xB0
#define DPH_PAGE_BLOCK_INFIX 	    0xC0
#define DPH_PAGE_BLOCK_SUFFIX 	    0xD0
#define DPH_NORMAL_BLOCK_INFIX 	    0xE0
#define DPH_FREE_BLOCK_INFIX 	    0xF0

typedef struct _DPH_BLOCK_INFORMATION {

    ULONG StartStamp;

    PVOID Heap;
    SIZE_T RequestedSize;
    SIZE_T ActualSize;

    union {
        LIST_ENTRY FreeQueue;
        USHORT TraceIndex;
    };

    PVOID StackTrace_;
    
    ULONG EndStamp;

    //
    // (SilviuC): This structure needs to be 8-byte aligned.
    // If it is not, applications expecting aligned blocks will get
    // unaligned ones because this structure will prefix their
    // allocations. Internet Explorer is one such application
    // that stops working in these conditions.
    //

} DPH_BLOCK_INFORMATION, * PDPH_BLOCK_INFORMATION;

//
// Error reasons used in debug messages
//

#define DPH_SUCCESS                           0x0000
#define DPH_ERROR_CORRUPTED_START_STAMP       0x0001
#define DPH_ERROR_CORRUPTED_END_STAMP         0x0002
#define DPH_ERROR_CORRUPTED_HEAP_POINTER      0x0004
#define DPH_ERROR_CORRUPTED_PREFIX_PATTERN    0x0008
#define DPH_ERROR_CORRUPTED_SUFFIX_PATTERN    0x0010
#define DPH_ERROR_RAISED_EXCEPTION            0x0020
#define DPH_ERROR_NO_NORMAL_HEAP              0x0040
#define DPH_ERROR_CORRUPTED_INFIX_PATTERN     0x0080
#define DPH_ERROR_DOUBLE_FREE                 0x0100


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_I_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\provutil.cpp ===
/*++

Copyright (c) 2001-2001  Microsoft Corporation

Module Name:

    provutil.cpp
    
Revision History:

    ivanbrug     jan 2001 created

--*/

#include <wmiexts.h>
#include <utilfun.h>
#include <malloc.h>

#ifndef POLARITY
#define POLARITY
#endif

#include <wbemint.h>

#ifdef SetContext
#undef SetContext
#endif

#include <ProvSubS.h>

//#include <provregdecoupled.h>
//#include <provdcaggr.h>

typedef ULONG_PTR CServerObject_DecoupledClientRegistration_Element;
typedef ULONG_PTR CDecoupledAggregator_IWbemProvider;

#include <provfact.h>
#include <provwsv.h>
#include <provcache.h>

//
//
// Dump the Provider cache
//

typedef WCHAR * WmiKey;
typedef void *  WmiElement;
typedef WmiAvlTree<WmiKey,WmiElement>::WmiAvlNode  Node;

/*
class Node {
public:
    VOID * m_Key;
    Node * m_Left;
    Node * m_Right;
    Node * m_Parent;
    int    m_Status;
    VOID * m_Element;
};
*/

class NodeBind;
VOID DumpTreeBind(NodeBind * pNode_OOP,DWORD * pCount,BOOL * pbStop);

VOID
DumpTree(Node * pNode_OOP,DWORD * pCount,BOOL * pbStop)
{
    if (!pNode_OOP)
        return;

    if (CheckControlC())
    {
        if(pbStop)
            *pbStop = TRUE;
    }

    if (pbStop)
    {
        if (*pbStop) 
            return;
    }
    
    DEFINE_CPP_VAR(Node,MyNode);
    WCHAR pBuff[MAX_PATH+1];
    Node * pNode = GET_CPP_VAR_PTR(Node,MyNode);
    BOOL bRet;

    if (ReadMemory((ULONG_PTR)pNode_OOP,pNode,sizeof(Node),NULL))
    {
        
        DumpTree(pNode->m_Left,pCount,pbStop);
        
        //dprintf("--------\n");
        
        if (pCount) {
            *pCount++;
        };
                
        dprintf("    (L %p R %p P %p) %p\n",
                 //pNode->m_Key,
                 pNode->m_Left,
                 pNode->m_Right,
                 pNode->m_Parent,
                 pNode->m_State);                 
                 

        if (pNode->m_Key)
        {
            ReadMemory((ULONG_PTR)pNode->m_Key,pBuff,MAX_PATH*sizeof(WCHAR),NULL);
            pBuff[MAX_PATH] = 0;
            dprintf("    %S\n",pBuff);
        }

        dprintf("    - %p real %p\n",pNode->m_Element,((ULONG_PTR *)pNode->m_Element-4));
        if (pNode->m_Element)
        {
            GetVTable((MEMORY_ADDRESS)(pNode->m_Element));
            //
            // attention to the vtable trick !!!!
            //                  
            DEFINE_CPP_VAR(CServerObject_BindingFactory,MyFactory);
            CServerObject_BindingFactory * pBindF = GET_CPP_VAR_PTR(CServerObject_BindingFactory,MyFactory);
            ULONG_PTR AddrInner = (ULONG_PTR)((ULONG_PTR *)pNode->m_Element-4);
            if (ReadMemory(AddrInner,pBindF,sizeof(CServerObject_BindingFactory),NULL))
            {
                DumpTreeBind((NodeBind *)pBindF->m_Cache.m_Root,pCount,pbStop);
            }
            else
            {
                dprintf("RM %p\n",AddrInner);
            }
        }
        DumpTree(pNode->m_Right,pCount,pbStop);
    }    
    else
    {
        dprintf("RM %p\n",pNode_OOP);
    }
}

 
template <typename WmiElement, typename WmiKey> struct WmiBasicNode
{
        WmiElement m_Element ;
        WmiKey m_Key ;
        WmiBasicNode *m_Left ;
        WmiBasicNode *m_Right ;
        WmiBasicNode *m_Parent ;
};

typedef WmiBasicNode<void *, void *> VoidPtrNode;

VOID
DumpTreeVoidNode(VoidPtrNode * pNode_OOP,DWORD * pCount,BOOL * pbStop)
{
    if (!pNode_OOP) return;

    //dprintf("-%p\n",pNode_OOP);
    if (CheckControlC()){ if(pbStop) *pbStop = TRUE; }
    if (pbStop) { if (*pbStop) return; }
    
    DEFINE_CPP_VAR(VoidPtrNode,MyNode);
    VoidPtrNode * pNode = GET_CPP_VAR_PTR(VoidPtrNode,MyNode);
    BOOL bRet;
    
    static WCHAR pBuff[MAX_PATH+1];
    
    if (ReadMemory((ULONG_PTR)pNode_OOP,pNode,sizeof(VoidPtrNode),NULL))
    {
        
        DumpTreeVoidNode((VoidPtrNode *)pNode->m_Left,pCount,pbStop);
        
        //dprintf("--------\n");
        
        if (pCount) { *pCount++; };
                
        dprintf("        (L %p R %p P %p)\n",
                 pNode->m_Left,
                 pNode->m_Right,
                 pNode->m_Parent);                 
                 
        dprintf("        - Element %p\n",pNode->m_Element);
        if (pNode->m_Element)
        {
            GetVTable((MEMORY_ADDRESS)(pNode->m_Element));
            
            DEFINE_CPP_VAR(CInterceptor_IWbemProvider,varProv);
            CInterceptor_IWbemProvider * pProv = GET_CPP_VAR_PTR(CInterceptor_IWbemProvider,varProv);
            BOOL bRet;
            if (ReadMemory((ULONG_PTR)pNode->m_Element,pProv,sizeof(CInterceptor_IWbemProvider),NULL))
            {
                if (pProv->m_Key.m_Provider)
                {
                    ReadMemory((ULONG_PTR)pProv->m_Key.m_Provider,pBuff,MAX_PATH*sizeof(WCHAR),NULL);
                    pBuff[MAX_PATH] = 0;
                    dprintf("            Provider: %S\n",pBuff);
                }
                else
                {
                    dprintf("            Provider: %p\n",0);
                }
                dprintf("            Hosting : %08x\n",pProv->m_Key.m_Hosting);
                if (pProv->m_Key.m_Group)
                {
                    ReadMemory((ULONG_PTR)pProv->m_Key.m_Group,pBuff,MAX_PATH*sizeof(WCHAR),NULL);
                    pBuff[MAX_PATH] = 0;
                    dprintf("            Group   : %S\n",pBuff);            
                }
                else
                {
                    dprintf("            Group   : %p\n",0);
                }
                
            }
            else
            {
                dprintf("RM %p\n",pNode->m_Element);
            }
        }
       
        DumpTreeVoidNode((VoidPtrNode *)pNode->m_Right,pCount,pbStop);
    }    
    else
    {
        dprintf("RM %p\n",pNode_OOP);
    }
}



typedef WmiAvlTree<long,long>::WmiAvlNode NodeLong;

VOID
DumpTreeNodeLong(NodeLong * pNodeLong_OOP,DWORD * pCount,BOOL * pbStop)
{
    if (!pNodeLong_OOP)
        return;

    if (CheckControlC()) { if(pbStop) *pbStop = TRUE; }
    if (pbStop) { if (*pbStop) return; }
    
    DEFINE_CPP_VAR(NodeLong,MyNode);
    NodeLong * pNode = GET_CPP_VAR_PTR(NodeLong,MyNode);
    BOOL bRet;

    if (ReadMemory((ULONG_PTR)pNodeLong_OOP,pNode,sizeof(NodeLong),NULL))
    {
        DumpTreeNodeLong((NodeLong *)pNode->m_Left,pCount,pbStop);
       
        if (pCount) {
            *pCount++;
        };
                
        dprintf("    (L %p R %p P %p) %p\n",
                 pNode->m_Left,
                 pNode->m_Right,
                 pNode->m_Parent,
                 pNode->m_State);                 
                 
        dprintf("    - pid %p ProviderController %p\n",pNode->m_Key,pNode->m_Element);
        if (pNode->m_Element)
        {
            GetVTable((MEMORY_ADDRESS)(pNode->m_Element));

            DEFINE_CPP_VAR(ProviderController,varCtrl);
            ProviderController * pCtrl = GET_CPP_VAR_PTR(ProviderController,varCtrl);
            if (ReadMemory((ULONG_PTR)pNode->m_Element,pCtrl,sizeof(ProviderController),NULL))
            {
                DWORD dwCount = 0;
                BOOL bStop = FALSE;
                DumpTreeVoidNode((VoidPtrNode *)pCtrl->m_Container.m_Root,&dwCount,&bStop);
            }
            else
            {
                dprintf("RM %p\n",pNode->m_Element);
            }
        }
       
        DumpTreeNodeLong((NodeLong *)pNode->m_Right,pCount,pbStop);
    }    
    else
    {
        dprintf("RM %p\n",pNodeLong_OOP);
    }
}


DECLARE_API(pc) 
{

    INIT_API();

    ULONG_PTR Addr = GetExpression("wbemcore!CCoreServices__m_pProvSS");
    if (Addr) 
    {
        CServerObject_ProviderSubSystem * pProvSS_OOP = NULL;
        if (ReadMemory(Addr,&pProvSS_OOP,sizeof(void *),NULL))
        {
            dprintf("pProvSS %p\n",pProvSS_OOP);
            BOOL bRet;
            DEFINE_CPP_VAR(CServerObject_ProviderSubSystem,MyProvSS);
            CServerObject_ProviderSubSystem * pProvSS = GET_CPP_VAR_PTR(CServerObject_ProviderSubSystem,MyProvSS);

            if (ReadMemory((ULONG_PTR)pProvSS_OOP,pProvSS,sizeof(CServerObject_ProviderSubSystem),NULL))
            {
                DEFINE_CPP_VAR(CWbemGlobal_IWmiFactoryController_Cache,MyCacheNode);
                CWbemGlobal_IWmiFactoryController_Cache * pNodeCache = NULL; //GET_CPP_VAR_PTR(CWbemGlobal_IWmiFactoryController_Cache CacheNode,MyCacheNode);

                pNodeCache = &pProvSS->m_Cache;

                //dprintf("  root %p\n",pNodeCache->m_Root);
                DWORD Count = 0;
                BOOL  bStop = FALSE;
                DumpTree((Node *)pNodeCache->m_Root,&Count,&bStop);
                //dprintf("traversed %d nodes\n",Count);
            }            
            else
            {
                  dprintf("RM %p\n",pProvSS_OOP);
            }            
        }
        else
          {
              dprintf("RM %p\n",Addr);
          }
    } 
    else 
    {
        dprintf("invalid address %s\n",args);
    }
    
    Addr = GetExpression("wmiprvsd!ProviderSubSystem_Globals__s_HostedProviderController");
    if (Addr)
    {
        if (ReadMemory(Addr,&Addr,sizeof(ULONG_PTR),NULL))
        {
            dprintf("CWbemGlobal_HostedProviderController %p\n",Addr);
            DEFINE_CPP_VAR(CWbemGlobal_HostedProviderController,varHostedCtrl);
            CWbemGlobal_HostedProviderController * pHostedCtrl = GET_CPP_VAR_PTR(CWbemGlobal_HostedProviderController,varHostedCtrl);
            if (ReadMemory(Addr,pHostedCtrl,sizeof(CWbemGlobal_HostedProviderController),NULL))
            {
                DWORD dwCount = 0;
                BOOL bStop = FALSE;
                DumpTreeNodeLong((NodeLong *)pHostedCtrl->m_Container.m_Root,&dwCount,&bStop);
            }
            else
            {
                dprintf("RM %p\n",Addr);
            }
        }
        else
        {
           dprintf("RM %p\n",Addr);        
        }
    }
    else
    {
        dprintf("unable to resolve wmiprvsd!ProviderSubSystem_Globals__s_HostedProviderController\n");
    }
    
}

//
//
// CServerObject_BindingFactory
//
//////////////

class NodeBind 
{
public:
    ProviderCacheKey m_Key;
    NodeBind * m_Left;
    NodeBind * m_Right;
    NodeBind * m_Parent;
    int    m_State;
    //WmiCacheController<ProviderCacheKey>::WmiCacheElement 
    void * m_Element;
};


VOID
DumpTreeBind(NodeBind * pNode_OOP,DWORD * pCount,BOOL * pbStop)
{

    //dprintf("%p ????\n",pNode_OOP);

    if (!pNode_OOP)
        return;

    if (CheckControlC())
    {
        if(pbStop)
            *pbStop = TRUE;
    }

    if (pbStop)
    {
        if (*pbStop) 
            return;
    }
    
    DEFINE_CPP_VAR(NodeBind,MyNode);
    static WCHAR pBuff[MAX_PATH+1];
    NodeBind * pNode = GET_CPP_VAR_PTR(NodeBind,MyNode);
    BOOL bRet;

    if (ReadMemory((ULONG_PTR)pNode_OOP,pNode,sizeof(NodeBind),NULL))
    {
        
        DumpTreeBind(pNode->m_Left,pCount,pbStop);
        
        //dprintf("--------\n");
        
        if (pCount) {
            *pCount++;
        };
                
        dprintf("      - (L %p R %p P %p) %p\n",
                 pNode->m_Left,
                 pNode->m_Right,
                 pNode->m_Parent,
                 pNode->m_State);                 
                 

        if (pNode->m_Key.m_Provider)
        {
            ReadMemory((ULONG_PTR)pNode->m_Key.m_Provider,pBuff,MAX_PATH*sizeof(WCHAR),NULL);
            pBuff[MAX_PATH] = 0;
            dprintf("        Provider: %S\n",pBuff);
        }
        else
        {
            dprintf("        Provider: %p\n",0);
        }
        dprintf("        Hosting : %08x\n",pNode->m_Key.m_Hosting);
        if (pNode->m_Key.m_Group)
        {
            ReadMemory((ULONG_PTR)pNode->m_Key.m_Group,pBuff,MAX_PATH*sizeof(WCHAR),NULL);
            pBuff[MAX_PATH] = 0;
            dprintf("        Group   : %S\n",pBuff);            
        }
        else
        {
            dprintf("        Group   : %p\n",0);
        }

        dprintf("        - %p\n",pNode->m_Element);
        if (pNode->m_Element)
        {
            GetVTable((MEMORY_ADDRESS)(pNode->m_Element));
        }

        DumpTreeBind(pNode->m_Right,pCount,pbStop);

    }    
    else
    {
        dprintf("RM %p\n",pNode_OOP);
    }
}




DECLARE_API(pf) 
{

    INIT_API();
    
    ULONG_PTR Addr = GetExpression(args);
    if (Addr) 
    {
        DEFINE_CPP_VAR(CServerObject_BindingFactory,MyFactory);
        CServerObject_BindingFactory * pBindF = GET_CPP_VAR_PTR(CServerObject_BindingFactory,MyFactory);
        BOOL bRet;
        bRet = ReadMemory(Addr,pBindF,sizeof(CServerObject_BindingFactory),NULL);
        if (bRet)
        {
            dprintf("        root %p\n",pBindF->m_Cache.m_Root);
            DWORD Count = 0;
            BOOL  bStop = FALSE;
            DumpTreeBind((NodeBind *)pBindF->m_Cache.m_Root,&Count,&bStop);
        }
    }
    else 
    {
        dprintf("invalid address %s\n",args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

    //
    //  This field gives the size of the current block in allocation
    //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    //  equals the size in bytes).
    //
    //  Except if this is part of a virtual alloc block then this
    //  value is the difference between the commit size in the virtual
    //  alloc entry and the what the user asked for.
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

#if defined(_WIN64)
    PVOID SubSegment;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
//  This block describes extra information that might be at the end of a
//  busy block.
//  Note: The heap code is assuming that:
//      sizeof( HEAP_ENTRY_EXTRA ) == sizeof( HEAP_ENTRY )
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    SIZE_T AlignRound;
    SIZE_T AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    union {

        USHORT FreeListsInUseTerminate;
        USHORT DecommitCount;
    } u2;

    USHORT AllocatorBackTraceIndex;

    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //
    
    PVOID FrontEndHeap;
    
    USHORT FrontHeapLockCount;
    UCHAR FrontEndHeapType;
    UCHAR LastSegmentIndex;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

//#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
//#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
//#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

//
// Page heap external interface.
//

#include <heappage.h>

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\heappage.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.h

Abstract:

    External interface for page heap manager.
    
Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
#define DEBUG_PAGE_HEAP 1
#endif

//silviuc: #include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others. It can be changed on the fly (after heap creation) to direct
//     allocations in one heap or another.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the N/A page at the beginning of the block.
//
// PAGE_HEAP_UNALIGNED_ALLOCATIONS
//
//     For historical reasons (related to RPC) by default page heap
//     aligns allocations at 8 byte boundaries. With this flag set
//     this does not happen and we can catch instantly off by one
//     errors for unaligned allocations.
//
// PAGE_HEAP_SMART_MEMORY_USAGE
//
//     This flag reduces the committed memory consumption in half
//     by using decommitted ranges (reserved virtual space) instead
//     of N/A committed pages. This flag is disabled by catch backward
//     overruns.
//
// PAGE_HEAP_USE_SIZE_RANGE
//
//     Use page heap for allocations in the size range specified by:
//     RtlpDphSizeRangeStart..RtlpDphSizeRangeEnd.
//
// PAGE_HEAP_USE_DLL_RANGE
//
//     Use page heap for allocations in the address range specified by:
//     RtlpDphDllRangeStart..RtlpDphDllRangeEnd. If the stack trace
//     of the allocation contains one address in this range then
//     allocation will be made from page heap.
//
// PAGE_HEAP_USE_RANDOM_DECISION
//
//     Use page heap if we randomly decide so.
//
// PAGE_HEAP_USE_DLL_NAMES
//
//     Use page heap if allocation call was generated from on of the
//     target dlls.
//
// PAGE_HEAP_USE_FAULT_INJECTION
//
//     Fault inject heap allocation calls based on a simple 
//     probabilistic model (see FaultProbability and FaultTimeOut).
//
// PAGE_HEAP_PROTECT_META_DATA
//
//     Keep page heap metadata read only if we are not executing inside
//     the page heap code.
//
// PAGE_CHECK_NO_SERIALIZE_ACCESS
//
//     Additional checks for multi-threaded access for no_serialize
//     heaps. This flag can trigger false positives in MPheap. It needs
//     to be used only on processes that do not use MPheap-like heaps.
//
// PAGE_HEAP_USE_READONLY
//
//     The page following (or preceding) the user allocation is marked
//     RO instead of NA. This is useful when testing RPC servers which
//     by design during unmarshalling might go off by a few bytes when 
//     probing parameters. This is so for performance reasons.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_NO_UMDH_SUPPORT           0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040 // obsolete
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800
#define PAGE_HEAP_PROTECT_META_DATA         0x1000
#define PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS 0x2000
#define PAGE_HEAP_NO_LOCK_CHECKS            0x4000
#define PAGE_HEAP_USE_READONLY              0x8000

//
// Is page heap enabled for this process?
//

extern BOOLEAN RtlpDebugPageHeap;

//
// `RtlpDphGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation. This variable 
// might get its value from the `PageHeap' ImageFileOptions
// registry key. 
//

extern ULONG RtlpDphGlobalFlags;

//
// Page heap global flags. They might be read from the
// `ImageFileOptions' registry key.
//

extern ULONG RtlpDphSizeRangeStart;
extern ULONG RtlpDphSizeRangeEnd;
extern ULONG RtlpDphDllRangeStart;
extern ULONG RtlpDphDllRangeEnd;
extern ULONG RtlpDphRandomProbability;
extern WCHAR RtlpDphTargetDlls[];

//
// If not zero controls the probability with which
// allocations will be failed on purpose by page heap
// manager. Timeout represents the initial period during
// process initialization when faults are not allowed.
//

extern ULONG RtlpDphFaultProbability;
extern ULONG RtlpDphFaultTimeOut;

//
// Stuff needed for per dll logic implemented in the loader
//

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

//
// Functions needed to turn on/off fault injection.
// They are needed in the loader so that allocations
// succeed while in LdrLoadDll code path.
//

VOID
RtlpDphDisableFaultInjection (
    );

VOID
RtlpDphEnableFaultInjection (
    );

#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\heaputil.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    heaputil.cpp
    
Revision History:

    ivanbrug     oct 2000 created

--*/

#include <wmiexts.h>
#include <utilfun.h>
#include <malloc.h>

/*
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0


typedef struct _HEAP_ENTRY {

    //
    //  This field gives the size of the current block in allocation
    //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    //  equals the size in bytes).
    //
    //  Except if this is part of a virtual alloc block then this
    //  value is the difference between the commit size in the virtual
    //  alloc entry and the what the user asked for.
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;


typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;
*/


typedef ULONG_PTR ERESOURCE_THREAD;
typedef ERESOURCE_THREAD *PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    union {
        LONG OwnerCount;
        ULONG TableSize;
    };

} OWNER_ENTRY, *POWNER_ENTRY;


typedef void * PKSEMAPHORE;
typedef void * PKEVENT;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    OWNER_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG_PTR CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

//typedef void * PRTL_TRACE_BLOCK;

#include "heap.h"
#include "heappagi.h"

#define HE_VERBOSITY_FLAGS   1
#define HE_VERBOSITY_NUMERIC 2
#define HE_VERBOSITY_VTABLE  4

#if defined(_X86_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8

#elif defined(_IA64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 16

#elif defined(_AMD64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 16

#else
    #error  // platform not defined
#endif


//
//
//
//
//

typedef DWORD (__stdcall * fnCallBack)(ULONG_PTR pParam1,ULONG_PTR pParam2);

DWORD g_UsedInHeap = 0;

void
PrintHeapEntry(HEAP_ENTRY * pEntry,void * pAddr)
{

    BYTE varEntry[sizeof(HEAP_ENTRY)+2*sizeof(void *)];
    LIST_ENTRY * pListEntry = (LIST_ENTRY *)((HEAP_ENTRY *)varEntry+1);

    DWORD PrintSize = 0;
    BOOL bIsPossiblePageHeap = FALSE;
    if (pEntry->Flags & HEAP_ENTRY_BUSY)
    {
        // re-read the entry, to get if it's on the LookAside
        if (ReadMemory((MEMORY_ADDRESS)pAddr,varEntry,sizeof(varEntry),NULL))
        {
#ifdef WIN64            
            if (0xf0f0f0f0f0f0f0f0 == (ULONG_PTR)pListEntry->Blink )
#else
            if (0xf0f0f0f0 == (ULONG_PTR)pListEntry->Blink )
#endif          
            {
                PrintSize = 0xf7eef7ee;
            }
            else 
            {
                PrintSize = (pEntry->Size<<HEAP_GRANULARITY_SHIFT)-pEntry->UnusedBytes;
                g_UsedInHeap += PrintSize;
            }

            DWORD Sign = *((DWORD *)pListEntry);
            //dprintf("Sign %08x\n",Sign);
            if (0xabcdaaaa == Sign)
            {
                bIsPossiblePageHeap = TRUE;
            }            
        }
        else
        {
            PrintSize = (pEntry->Size<<HEAP_GRANULARITY_SHIFT)-pEntry->UnusedBytes;
            g_UsedInHeap += PrintSize;            
        }
    }
    else
    {
        PrintSize = 0xf7eef7ee;
    }

    dprintf("      %p: %04x . %04x [%02x] - (%x)\n",
            pAddr,pEntry->Size,pEntry->PreviousSize,pEntry->Flags,PrintSize);

    if (bIsPossiblePageHeap)
    {
        //dprintf("Possible %p\n",(MEMORY_ADDRESS)((BYTE*)pAddr+sizeof(HEAP_ENTRY)+sizeof(DPH_BLOCK_INFORMATION)));
        GetVTable((MEMORY_ADDRESS)((BYTE*)pAddr+sizeof(HEAP_ENTRY)+sizeof(DPH_BLOCK_INFORMATION)));
    }
    else
        GetVTable((MEMORY_ADDRESS)((BYTE*)pAddr+sizeof(HEAP_ENTRY)));    
};

//
//
// print the HEAP_ENTRY structure
//

DECLARE_API(he) {

    INIT_API();

    DEFINE_CPP_VAR( HEAP_ENTRY, varHEAP_ENTRY);
    HEAP_ENTRY * pEntry = GET_CPP_VAR_PTR( HEAP_ENTRY , varHEAP_ENTRY );
    memset(pEntry,0xfe,sizeof(HEAP_ENTRY));
    
    MEMORY_ADDRESS pByte = GetExpression(args);
    
    if (pByte)
    {
        if (ReadMemory((MEMORY_ADDRESS)pByte,pEntry ,sizeof(HEAP_ENTRY),NULL))
        {
            PrintHeapEntry(pEntry,(void *)pByte);
        }
        else
        {
            dprintf("RM %p\n",pByte);
        }
    } else {
        dprintf("invalid HEAP_ENTRY address %s\n",args);
    }
}

//
// HEAP_ENTRY list
// finds the beginning of the "list" of HEAP_ENTRYs
//

DECLARE_API(heb) {

    INIT_API();
    
    MEMORY_ADDRESS pEntry = GetExpression(args);
    
    if (pEntry){
       HEAP_ENTRY HeapEntry;
       ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0);

       PrintHeapEntry(&HeapEntry,(void *)pEntry);

       while (HeapEntry.PreviousSize)
       {
           pEntry = (MEMORY_ADDRESS)((HEAP_ENTRY*)pEntry - HeapEntry.PreviousSize);
           if (ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0))
           {
               PrintHeapEntry(&HeapEntry,(void *)pEntry);
           }
           else
           {
               dprintf("RM %p\n",pEntry);
               break;
           }

           if (CheckControlC())
               break;           
       }

       dprintf(" begin %08x\n",pEntry);
    } else {
        dprintf("invalid address %s\n",args);
    };

}

//
//
//  HEAP_ENTRY forward
//  
//////////////////////////////////////////////////////

DECLARE_API(hef) {

    INIT_API();

    DWORD BeginNum=0;

    MEMORY_ADDRESS pEntry = GetExpression(args);

    if (pEntry)
    {
       HEAP_ENTRY HeapEntry;
       ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0);

       PrintHeapEntry(&HeapEntry,(void *)pEntry);

       while (!(HeapEntry.Flags & HEAP_ENTRY_LAST_ENTRY))
       {
           pEntry = (MEMORY_ADDRESS)((HEAP_ENTRY*)pEntry + HeapEntry.Size);
           if (ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0))
           {
                 PrintHeapEntry(&HeapEntry,(void *)pEntry);
           }
           else
           {
               dprintf("RM %p\n",pEntry);
               break;
           }
                      
           if (CheckControlC())
               break;
           
       }

       dprintf(" end %08x\n",pEntry);
    } else {
        dprintf("invalid address %s\n",args);
    };

}

DWORD EnumEntries(HEAP_ENTRY * pEntry,DWORD * pSize,fnCallBack CallBack,ULONG_PTR Addr){

       DWORD i=0;
       HEAP_ENTRY HeapEntry;
       DWORD Size=0;
       ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0);

       if (CallBack)
       {
           CallBack((ULONG_PTR)pEntry,Addr);
       }
       else
       {
           PrintHeapEntry(&HeapEntry,pEntry);
       };

       while (!(HeapEntry.Flags & HEAP_ENTRY_LAST_ENTRY))
       {
           if (0 == HeapEntry.Size)
           {
               dprintf("HEAP_ENTRY %p with zero Size\n",pEntry);
               break;
           }
           pEntry = (HEAP_ENTRY*)pEntry + HeapEntry.Size;
           if (ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0))
           {
               if (CallBack)
               {
                   CallBack((ULONG_PTR)pEntry,Addr);
               }
               else
               {
                   PrintHeapEntry(&HeapEntry,pEntry);
               };
           }
           else
           {
               dprintf("RM %p\n",pEntry);
               break;
           }

           i++;
           Size += ((HeapEntry.Size<<HEAP_GRANULARITY_SHIFT)-HeapEntry.UnusedBytes);

           if (CheckControlC())
               break;
           
       }

    if (pSize){
        *pSize = Size;
    }

    return i;
}

void
PrintHEAP_SEGMENT(HEAP_SEGMENT * pSeg_OOP, 
                  fnCallBack CallBack, 
                  ULONG_PTR Addr)
{
    DEFINE_CPP_VAR( HEAP_SEGMENT, varHEAP_SEGMENT);
    HEAP_SEGMENT * pSeg = GET_CPP_VAR_PTR( HEAP_SEGMENT , varHEAP_SEGMENT );

    BOOL bRet = ReadMemory((MEMORY_ADDRESS)pSeg_OOP,pSeg ,sizeof(HEAP_SEGMENT),0);

    if (bRet)
    {
        if (!CallBack)
            dprintf("    Flags %08x HEAP %p\n",pSeg->Flags,pSeg->Heap);

        //SIZE_T LargestUnCommittedRange;

        //PVOID BaseAddress;
        //ULONG NumberOfPages;
        //PHEAP_ENTRY FirstEntry;
        //PHEAP_ENTRY LastValidEntry;

        //ULONG NumberOfUnCommittedPages;
            DWORD unComm = pSeg->NumberOfUnCommittedRanges;
        //PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
        //USHORT AllocatorBackTraceIndex;
        //USHORT Reserved;
        //PHEAP_ENTRY LastEntryInSegment;

        HEAP_UNCOMMMTTED_RANGE UncRange;   
        HEAP_UNCOMMMTTED_RANGE * pUncRange = pSeg->UnCommittedRanges;
        HEAP_ENTRY ** pCommRange = (HEAP_ENTRY **)_alloca(sizeof(HEAP_ENTRY *)*(unComm+1));

        DWORD Size=0;
        DWORD Num=0;

        pCommRange[0] = (HEAP_ENTRY *)pSeg->FirstEntry;

        Num = EnumEntries(pCommRange[0],&Size,CallBack,Addr);

        if (!CallBack)
            dprintf("    - %p Size %p entries %d \n",pCommRange[0],Size,Num);
            
        for (DWORD i=0; i<unComm; i++)
        {

            
            bRet = ReadMemory((MEMORY_ADDRESS)pUncRange,&UncRange,sizeof(UncRange),NULL);
            if (bRet)
            {
                pUncRange = UncRange.Next;                
                pCommRange[1+i] = (HEAP_ENTRY *)(UncRange.Address + UncRange.Size);

                if (NULL == pUncRange)
                {
                    if ((ULONG_PTR)pCommRange[1+i] == (ULONG_PTR)pSeg->LastValidEntry)
                        break;
                }
               
                Num = EnumEntries(pCommRange[1+i],&Size,CallBack,Addr);

                if (!CallBack)
                    dprintf("    - %p Size %p entries %d\n",pCommRange[1+i],Size,Num);
            }
            else
            {
                dprintf("RM %p\n",pUncRange);
            }
        }
    } else {
        dprintf("RM %p\n",pSeg_OOP);
    }

}

//
//
// Dump the HEAP_SEGMENT
//

DECLARE_API(hs) {

    INIT_API();
        
    MEMORY_ADDRESS pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte)
    {
        PrintHEAP_SEGMENT((HEAP_SEGMENT *)pByte,NULL,NULL);
    } 
    else 
    {
        dprintf("invalid address %s\n",args);
    }
}

//
// Define heap lookaside list allocation functions.
//

struct SLIST_HEADER_ 
{
    SLIST_HEADER_ * Next;
    ULONG_PTR       Align;
};

typedef struct _HEAP_LOOKASIDE {
    SLIST_HEADER_ ListHead;

    USHORT Depth;
    USHORT MaximumDepth;

    ULONG TotalAllocates;
    ULONG AllocateMisses;
    ULONG TotalFrees;
    ULONG FreeMisses;

    ULONG LastTotalAllocates;
    ULONG LastAllocateMisses;

    ULONG Counters[2];
#ifdef _IA64_
    DWORD Pad[3];
#else
    DWORD Pad;
#endif

} HEAP_LOOKASIDE, *PHEAP_LOOKASIDE;



void Dump_LookAside(ULONG_PTR pLookAside_OOP)
{
    DWORD dwSize = sizeof(HEAP_LOOKASIDE) * HEAP_MAXIMUM_FREELISTS ;

    BYTE * pData = new BYTE[dwSize];

    if (pData)
    {
        if (ReadMemory(pLookAside_OOP,pData,dwSize,NULL))
        {
            DWORD i;
            HEAP_LOOKASIDE * pLookasideArray = (HEAP_LOOKASIDE *)pData;

            
            BYTE varHEAP_ENTRY[sizeof(HEAP_ENTRY)+sizeof(SLIST_HEADER_)];
            HEAP_ENTRY * pEntry = GET_CPP_VAR_PTR( HEAP_ENTRY , varHEAP_ENTRY );
            SLIST_HEADER_ * pSListEntry = (SLIST_HEADER_ *)(pEntry+1);

            char Fill[8];
            memset(Fill,0xf0,8);
            
            for(i=0;i<HEAP_MAXIMUM_FREELISTS;i++)
            {                
                ULONG_PTR pTmp;                
                SLIST_HEADER_ * pHead_OOP = pLookasideArray[i].ListHead.Next;
#ifdef _IA64_                               
                pTmp = (ULONG_PTR)pHead_OOP;
                pTmp>>=25;
                pTmp<<=4;
                pHead_OOP = (SLIST_HEADER_ *)pTmp;
#endif
                
                dprintf("    LookAside[%x] - %p Depth %x Maximum %x\n",
                       i,
                       pHead_OOP, //pLookasideArray[i].ListHead.Next,
                       pLookasideArray[i].Depth,
                       pLookasideArray[i].MaximumDepth);
                
                //dprintf("size %x %p\n",sizeof(HEAP_LOOKASIDE),pHead_OOP);
                USHORT Depth = 0;
                while(pHead_OOP)
                {
                       HEAP_ENTRY * pEntry_OOP = (HEAP_ENTRY *)pHead_OOP-1;

                       if (ReadMemory((MEMORY_ADDRESS)pEntry_OOP,pEntry,sizeof(varHEAP_ENTRY),NULL))
                       {
                           ULONG_PTR pToWrite = sizeof(ULONG_PTR) + (ULONG_PTR)pHead_OOP;
                           WriteMemory(pToWrite,Fill,sizeof(ULONG_PTR),0);

                           pHead_OOP = pSListEntry->Next; 
                           PrintHeapEntry(pEntry,pEntry_OOP);
                       }
                       else
                       {
                           dprintf("RM %d\n",GetLastError());
                            break;
                       }
                       Depth++;
                       if (Depth > pLookasideArray[i].MaximumDepth)
                       {
                            dprintf("MaximumDepth exceeded\n");
                            break;

                       }
                };
            }
        }
        else
        {
            dprintf("RM %d\n",GetLastError());
        }
        delete [] pData;
    }

}

#define HEAP_FRONT_LOOKASIDE        1
#define HEAP_FRONT_LOWFRAGHEAP      2

//
// prepares the Lookaside list for dump
//
DECLARE_API(lhp) 
{
    INIT_API();

    DEFINE_CPP_VAR( HEAP, varHEAP);
    HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );    
    MEMORY_ADDRESS pByte = GetExpression(args);
    DWORD i;

    if (pByte)
    {     
        if (ReadMemory(pByte,pHeap ,sizeof(HEAP),NULL))
        {

            //dprintf("-----  LookAside %p\n",pHeap->FrontEndHeap);
            if (1 == pHeap->FrontEndHeapType) 
                Dump_LookAside((ULONG_PTR)pHeap->FrontEndHeap);
            else
                dprintf("_HEAP FrontEndHeapType %d not recognized \n",pHeap->FrontEndHeapType);
        }
        else
        {
            dprintf("RM %p %d\n",pByte,GetLastError());
        }
    }
    else
    {
        dprintf("invalid heap address %s\n",args);
    }
}

//
//  Low fragmentation heap data structures
//

typedef struct _BLOCK_ENTRY : HEAP_ENTRY 
{
    USHORT LinkOffset;
    USHORT Reserved2;

} BLOCK_ENTRY, *PBLOCK_ENTRY;



typedef struct _INTERLOCK_SEQ {

    union {

        struct {
            
            union {

                struct {

                    USHORT Depth;
                    USHORT FreeEntryOffset;
                };
                volatile ULONG OffsetAndDepth;
            };
            volatile ULONG  Sequence;
        };

        volatile LONGLONG Exchg;
    };

} INTERLOCK_SEQ, *PINTERLOCK_SEQ;

struct _HEAP_USERDATA_HEADER;

typedef struct _HEAP_SUBSEGMENT {
    
    PVOID Bucket;
    
    volatile struct _HEAP_USERDATA_HEADER * UserBlocks;
    
    INTERLOCK_SEQ AggregateExchg;

    union {

        struct {
            USHORT BlockSize;
            USHORT FreeThreshold;
            USHORT BlockCount;
            UCHAR  SizeIndex;
            UCHAR  AffinityIndex;
        };

        ULONG Alignment[2];
    };
    
    SINGLE_LIST_ENTRY SFreeListEntry;
    volatile ULONG Lock;

} HEAP_SUBSEGMENT, *PHEAP_SUBSEGMENT;

typedef struct _HEAP_USERDATA_HEADER {

    union {
        
        SINGLE_LIST_ENTRY SFreeListEntry;
        PHEAP_SUBSEGMENT SubSegment;
    };

    PVOID HeapHandle;

    ULONG_PTR SizeIndex;
    ULONG_PTR Signature;

} HEAP_USERDATA_HEADER, *PHEAP_USERDATA_HEADER;


typedef union _HEAP_BUCKET_COUNTERS{

    struct {
        
        volatile ULONG  TotalBlocks;
        volatile ULONG  SubSegmentCounts;
    };

    volatile LONGLONG Aggregate64;

} HEAP_BUCKET_COUNTERS, *PHEAP_BUCKET_COUNTERS;

//
//  The HEAP_BUCKET structure handles same size allocations 
//

typedef struct _HEAP_BUCKET {

    HEAP_BUCKET_COUNTERS Counters;

    USHORT BlockUnits;
    UCHAR SizeIndex;
    UCHAR UseAffinity;
    
    LONG Conversions;

} HEAP_BUCKET, *PHEAP_BUCKET;

//
//  LFH heap uses zones to allocate sub-segment descriptors. This will preallocate 
//  a large block and then for each individual sub-segment request will move the 
//  water mark pointer with a non-blocking operation
//

typedef struct _LFH_BLOCK_ZONE {

    LIST_ENTRY ListEntry;
    PVOID      FreePointer;
    PVOID      Limit;

} LFH_BLOCK_ZONE, *PLFH_BLOCK_ZONE;

#define FREE_CACHE_SIZE  16

typedef struct _HEAP_LOCAL_SEGMENT_INFO {

    PHEAP_SUBSEGMENT Hint;
    PHEAP_SUBSEGMENT ActiveSubsegment;

    PHEAP_SUBSEGMENT CachedItems[ FREE_CACHE_SIZE ];
    SLIST_HEADER SListHeader;

    SIZE_T BusyEntries;
    SIZE_T LastUsed;

} HEAP_LOCAL_SEGMENT_INFO, *PHEAP_LOCAL_SEGMENT_INFO;

#define HEAP_BUCKETS_COUNT      128  

typedef struct _HEAP_LOCAL_DATA {
    
    //
    //  We reserve the 128 bytes below to avoid sharing memory
    //  into the same cacheline on MP machines
    //

    UCHAR Reserved[128];

    volatile PLFH_BLOCK_ZONE CrtZone;
    struct _LFH_HEAP * LowFragHeap;

    HEAP_LOCAL_SEGMENT_INFO SegmentInfo[HEAP_BUCKETS_COUNT];
    SLIST_HEADER DeletedSubSegments;

    ULONG Affinity;
    ULONG Reserved1;

} HEAP_LOCAL_DATA, *PHEAP_LOCAL_DATA;

//
//  Fixed size large block cache data structures & definitions
//  This holds in S-Lists the blocks that can be free, but it
//  delay the free until no other thread is doing a heap operation
//  This helps reducing the contention on the heap lock,
//  improve the scalability with a relatively low memory footprint
//

#define HEAP_LOWEST_USER_SIZE_INDEX 7
#define HEAP_HIGHEST_USER_SIZE_INDEX 18

#define HEAP_USER_ENTRIES (HEAP_HIGHEST_USER_SIZE_INDEX - HEAP_LOWEST_USER_SIZE_INDEX + 1)

typedef struct _USER_MEMORY_CACHE {

    SLIST_HEADER UserBlocks[ HEAP_USER_ENTRIES ];

    ULONG FreeBlocks;
    ULONG Sequence;

    ULONG MinDepth[ HEAP_USER_ENTRIES ];
    ULONG AvailableBlocks[ HEAP_USER_ENTRIES ];
    
} USER_MEMORY_CACHE, *PUSER_MEMORY_CACHE;

typedef struct _LFH_HEAP {
    
    RTL_CRITICAL_SECTION Lock;

    LIST_ENTRY SubSegmentZones;
    SIZE_T ZoneBlockSize;
    HANDLE Heap;
    LONG Conversions;
    LONG ConvertedSpace;

    ULONG SegmentChange;           //  
    ULONG SegmentCreate;           //  Various counters (optional)
    ULONG SegmentInsertInFree;     //   
    ULONG SegmentDelete;           //     

    USER_MEMORY_CACHE UserBlockCache;

    //
    //  Bucket data
    //

    HEAP_BUCKET Buckets[HEAP_BUCKETS_COUNT];

    //
    //  The LocalData array must be the last field in LFH structures
    //  The sizes of the array is choosen depending upon the
    //  number of processors.
    //

    HEAP_LOCAL_DATA LocalData[1];

} LFH_HEAP, *PLFH_HEAP;


/*
    MEMORY_ADDRESS Addr = GetExpression(args);
    if (NULL == Addr)
    {
        dprintf("unable to resolve %s\n",args);
        return;
    }
    HEAP_USERDATA_HEADER UserData;
    if (ReadMemory(Addr,&UserData,sizeof(UserData),NULL))
    {
        dprintf("    Next %p HeapHandle %p SizeIndex %p Signature %p\n",
                   UserData.SFreeListEntry.Next,
                   UserData.HeapHandle,     
                   UserData.SizeIndex,
                   UserData.Signature);
        BLOCK_ENTRY * pBlkEntry = (BLOCK_ENTRY *)((HEAP_USERDATA_HEADER*)Addr+1);
        while(pBlkEntry)
        {
            BLOCK_ENTRY BlkEntry;
            
            if (ReadMemory((ULONG_PTR)pBlkEntry,&BlkEntry,sizeof(BlkEntry),NULL))
            {                
                dprintf("        %p : %08x %02x %02x %02x %02x - %04x %04x\n",
                            pBlkEntry,
                            *(DWORD *)&BlkEntry.Size,
                            BlkEntry.SmallTagIndex,
                            BlkEntry.Flags,
                            BlkEntry.UnusedBytes,
                            BlkEntry.SegmentIndex,
                            BlkEntry.LinkOffset,
                            BlkEntry.Reserved2);
                
                GetVTable((MEMORY_ADDRESS)((BYTE*)pBlkEntry+sizeof(BLOCK_ENTRY)));
                
                if (1 == BlkEntry.SmallTagIndex)
                {
                    pBlkEntry = (BLOCK_ENTRY *)((HEAP_ENTRY *)pBlkEntry+BlkEntry.LinkOffset);
                }
                else
                {
                    pBlkEntry = 0;
                }
            }
            else
            {
                dprintf("RM %p\n",pBlkEntry);
                break;
            }
        }
    }
    else
    {
        dprintf("RM %p\n");
    }
*/

void Print_HEAP_SUBSEGMENT( HEAP_SUBSEGMENT * pSubSeg_OOP,BOOL bHere)
{
    HEAP_SUBSEGMENT HeapSubSeg;
    HEAP_SUBSEGMENT * pSubSegHERE = &HeapSubSeg;
    if (NULL == pSubSeg_OOP) return;

    if (bHere)
    {
        pSubSegHERE = pSubSeg_OOP;
    }
    else
    {
        if (!ReadMemory((ULONG_PTR)pSubSeg_OOP,&HeapSubSeg,sizeof(HeapSubSeg),0))
        {
            dprintf("RM %p\n",pSubSeg_OOP);
            return;
        }
    }
        dprintf("  - Bkt %p Blk %p D %04x F %04x S %08x\n",
                   pSubSegHERE->Bucket,
                   pSubSegHERE->UserBlocks,
                   pSubSegHERE->AggregateExchg.Depth,
                   pSubSegHERE->AggregateExchg.FreeEntryOffset,
                   pSubSegHERE->AggregateExchg.Sequence);
        dprintf("    Bs %04x FT %04x BC %04x S %02x A %02x Lock %08x\n",
                pSubSegHERE->BlockSize,
                pSubSegHERE->FreeThreshold,
                pSubSegHERE->BlockCount,
                pSubSegHERE->SizeIndex,
                pSubSegHERE->AffinityIndex,
                pSubSegHERE->Lock);

        if (0 == pSubSegHERE->AggregateExchg.Depth) return;
        
        struct EntryTable : HEAP_ENTRY 
        {
            ULONG_PTR vTable;
        } Entry;
        HEAP_ENTRY * pEntry_OOP = (HEAP_ENTRY *)((HEAP_USERDATA_HEADER *)pSubSegHERE->UserBlocks+1);
        DWORD Count = 0;
        do
        {
            if (ReadMemory((ULONG_PTR)pEntry_OOP,&Entry,sizeof(Entry),NULL))
            {
                dprintf("      %p: %04x . %04x [%02x] - (%x)\n",
                           pEntry_OOP,1+pSubSegHERE->SizeIndex,0,
                           Entry.Flags,
                           (sizeof(HEAP_ENTRY))*( pSubSegHERE->BlockSize)-Entry.UnusedBytes);
                GetVTable(Entry.vTable);
                pEntry_OOP += ( pSubSegHERE->BlockSize );
                Count++;
            }
            else
            {
                dprintf("RM %p\n",pEntry_OOP);
                break;
            }
        } while(1 == Entry.SmallTagIndex && Count < pSubSegHERE->AggregateExchg.Depth);

}

DWORD EnumListCrtZone(VOID * pZone_OOP,
                                      VOID * pBlockZone)
{
    LFH_BLOCK_ZONE CrtZone;
    LFH_BLOCK_ZONE * pBlockZone_OOP = (LFH_BLOCK_ZONE *)pZone_OOP;
    if (ReadMemory((ULONG_PTR)pBlockZone_OOP,&CrtZone,sizeof(CrtZone),NULL))
    {
        ULONG_PTR Size = (ULONG_PTR)CrtZone.FreePointer - (ULONG_PTR)pBlockZone_OOP;
        BYTE * pMem = (BYTE *)HeapAlloc(GetProcessHeap(),0,Size);
        if (pMem)
        {
            ULONG_PTR AddrCrtZone = (ULONG_PTR)pBlockZone_OOP;
            if (ReadMemory(AddrCrtZone,pMem,(ULONG)Size,NULL))
            {
                HEAP_SUBSEGMENT * pSubSeg = (HEAP_SUBSEGMENT *)((LFH_BLOCK_ZONE *)pMem + 1);
                HEAP_SUBSEGMENT * pSubSegEnd = (HEAP_SUBSEGMENT *)((BYTE *)pSubSeg+Size);

                HEAP_SUBSEGMENT * pSubSeg_OOP = (HEAP_SUBSEGMENT *)((LFH_BLOCK_ZONE *)AddrCrtZone+1);
                while (pSubSeg < pSubSegEnd )
                {
                    //dprintf("SS - %p\n",pSubSeg_OOP);
                    Print_HEAP_SUBSEGMENT(pSubSeg,TRUE);
                    pSubSeg++;
                    pSubSeg_OOP++;
                }
            }
            HeapFree(GetProcessHeap(),0,pMem);
        }
    }
    else
    {
        dprintf("RM %p\n",pBlockZone_OOP);
    }
    return 0;    
}

void Print_LFH(LFH_HEAP * pLFH_OOP)
{
    ULONG_PTR AddrAff = GetExpression("ntdll!RtlpHeapMaxAffinity");
    if (AddrAff)
    {
        ULONG Affinity = 0;
        if (ReadMemory(AddrAff,&Affinity,sizeof(Affinity),0))            
        {
            ULONG_PTR SizeRead = sizeof(LFH_HEAP) + Affinity*sizeof(HEAP_LOCAL_DATA);
            LFH_HEAP * pLFH = (LFH_HEAP *)HeapAlloc(GetProcessHeap(),0,SizeRead);
            if (NULL == pLFH) return;

            if (ReadMemory((ULONG_PTR)pLFH_OOP,pLFH,(ULONG)SizeRead,0))
            {
                dprintf("LFH_HEAP %p\n",pLFH_OOP);

               LIST_ENTRY  * pListHead_oop = &pLFH_OOP->SubSegmentZones;
               EnumLinkedListCB(pListHead_oop,
                                          sizeof(LFH_BLOCK_ZONE),
                                          FIELD_OFFSET(LFH_BLOCK_ZONE,ListEntry), 
                                         EnumListCrtZone);                 

/*
                for (DWORD i=0;i<HEAP_USER_ENTRIES;i++)
                {
                    dprintf("    HEAP_USERDATA_HEADER - %d\n",i);
                    HEAP_USERDATA_HEADER * pUsrDataHdr = (HEAP_USERDATA_HEADER *)pLFH->UserBlockCache.UserBlocks[i].Next.Next;

                    dprintf("      Next %p Available %x\n",pUsrDataHdr,pLFH->UserBlockCache.AvailableBlocks[i]);

                    HEAP_USERDATA_HEADER UsrDataHdr;
                    UsrDataHdr.SFreeListEntry.Next = NULL;
                    for (;pUsrDataHdr;pUsrDataHdr = (HEAP_USERDATA_HEADER *)UsrDataHdr.SFreeListEntry.Next)
                    {
                        if (ReadMemory((ULONG_PTR)pUsrDataHdr,&UsrDataHdr,sizeof(UsrDataHdr),NULL))
                        {
                            dprintf("        ----\n");
                            dprintf("        Next %p\n",UsrDataHdr.SFreeListEntry.Next);
                            dprintf("        HeapHandle %p\n",UsrDataHdr.HeapHandle);
                            dprintf("        SizeIndex %p\n",UsrDataHdr.SizeIndex);
                            dprintf("        Signature %p\n",UsrDataHdr.Signature);
                        }
                        else
                        {
                            dprintf("RM %p\n",pUsrDataHdr);
                        }
                    }
                }
*/

                //
                // Buckets
                //
/*
                dprintf("    Buckets\n");
                dprintf("    #    BUnt S A Conv TotBlk SubSegCnt\n");
                for (DWORD i = 0; i < HEAP_BUCKETS_COUNT; i++) 
                {
                      //+0x000 Counters : _HEAP_BUCKET
                      dprintf("    %02x - %04x %02x %02x %p %08x  %08x\n",
                                 i,
                                 pLFH->Buckets[i].BlockUnits,
                                 pLFH->Buckets[i].SizeIndex,
                                 pLFH->Buckets[i].UseAffinity,
                                 pLFH->Buckets[i].Conversions,
                                 pLFH->Buckets[i].Counters.TotalBlocks,
                                 pLFH->Buckets[i].Counters.SubSegmentCounts);
                }
*/

                for (DWORD i = 0; i <= Affinity; i++) 
                {
                    if (0 == i)
                        dprintf("  HEAP_LOCAL_DATA - NO AFFINITY\n");
                    else
                        dprintf("  HEAP_LOCAL_DATA - AFFINITY %d\n",i-1);
                    
                    dprintf("        @ %p CrtZone %p LFHeap %p  Affinity %x\n",
                               (ULONG_PTR)pLFH_OOP + (ULONG_PTR)&pLFH->LocalData[i] - (ULONG_PTR)pLFH,
                               pLFH->LocalData[i].CrtZone,
                               pLFH->LocalData[i].LowFragHeap,
                               pLFH->LocalData[i].Affinity);

                    //Print_BLOCK_ZONE((LFH_BLOCK_ZONE *)pLFH->LocalData[i].CrtZone);
                    
                    HEAP_LOCAL_DATA * pLocData = &pLFH->LocalData[i];

                    dprintf("        #   Hint     Active   Next   BusyEntries LastUsed\n");
                    for (DWORD j=0;j<HEAP_BUCKETS_COUNT;j++)
                    {
                        dprintf("        %02x  %p %p %p %08x %08x\n",
                                   j,
                                   pLocData->SegmentInfo[j].Hint,
                                   pLocData->SegmentInfo[j].ActiveSubsegment,
                                   pLocData->SegmentInfo[j].SListHeader, //.Next, //.next
                                   pLocData->SegmentInfo[j].BusyEntries,
                                   pLocData->SegmentInfo[j].LastUsed);
                        //Print_HEAP_SUBSEGMENT(pLocData->SegmentInfo[j].Hint,FALSE);
                        //Print_HEAP_SUBSEGMENT(pLocData->SegmentInfo[j].ActiveSubsegment,FALSE);
                    }
                    
                }                
            }
            else
            {
                dprintf("RM %p\n",pLFH_OOP);
            }
            HeapFree(GetProcessHeap(),0,pLFH);
        }
        else
        {
            dprintf("RM %p\n",AddrAff);
        }
    }
    else
    {
        dprintf("unable to resolve ntdll!RtlpHeapMaxAffinity\n");
    }
}

DECLARE_API(lfhp)
{
    INIT_API();
    
    MEMORY_ADDRESS Addr = GetExpression(args);
    if (NULL == Addr)
    {
        dprintf("unable to resolve %s\n",args);
        return;
    }

    DEFINE_CPP_VAR( HEAP, varHEAP);
    HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );    

    if (ReadMemory(Addr,pHeap ,sizeof(HEAP),NULL))
    {

        //dprintf("-----  LookAside %p\n",pHeap->FrontEndHeap);
        //Dump_LookAside((ULONG_PTR)pHeap->FrontEndHeap);
        if (HEAP_FRONT_LOWFRAGHEAP == pHeap->FrontEndHeapType )
        {
            Print_LFH((LFH_HEAP*)pHeap->FrontEndHeap);
        }
        else
        {
            dprintf("Unrecognized FrontEndHeapType %d\n",pHeap->FrontEndHeapType);
        }
    }
    else
    {
        dprintf("RM %p\n",Addr);
    }    
    
}

//
//
// dump the HEAP, incomplete
//
//

DECLARE_API(hp) 
{
    INIT_API();

    g_UsedInHeap = 0;

    DEFINE_CPP_VAR( HEAP, varHEAP);
    HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );    
    MEMORY_ADDRESS pByte = GetExpression(args);
    DWORD i;

    if (pByte)
    {     
        if (ReadMemory(pByte,pHeap ,sizeof(HEAP),NULL))
        {            
            for (i=0;i<HEAP_MAXIMUM_SEGMENTS;i++)
            {
                if (pHeap->Segments[i])
                    PrintHEAP_SEGMENT(pHeap->Segments[i],NULL,NULL);
                    //dprintf(" seg %i - %p\n",i,pHeap->Segments[i]);
                
            }
            dprintf("Used Bytes %p\n",g_UsedInHeap);
        }
        else
        {
            dprintf("RM %p %d\n",pByte,GetLastError());
        }
    }
    else
    {
        dprintf("invalid address %s\n",args);
    }
}

//
//
//
/////////////////////////////////////////////////////////////

DWORD       g_BlockSize;
ULONG_PTR * g_pBlockBlob;
ULONG g_NumMatch;

DWORD CallBackSearch(ULONG_PTR pHeapEntry_OOP,ULONG_PTR Addr)
{
    if (!g_pBlockBlob)
    {
        dprintf("no GLOBAL search block\n");
        return STATUS_NO_MEMORY;
    }
    HEAP_ENTRY Entry;
    if (ReadMemory(pHeapEntry_OOP,&Entry,sizeof(HEAP_ENTRY),NULL))
    {
        HEAP_ENTRY * pEntry = (HEAP_ENTRY *)&Entry;        
        DWORD Size = (pEntry->Flags & HEAP_ENTRY_BUSY)?(pEntry->Size<<HEAP_GRANULARITY_SHIFT)-pEntry->UnusedBytes:0;
        if (Size)
        {
            if (Size < g_BlockSize)
            {
                ULONG_PTR * pData = (ULONG_PTR *)g_pBlockBlob;
                ReadMemory(pHeapEntry_OOP+sizeof(HEAP_ENTRY),pData,Size,NULL);
                
                // here is the assumption that pointers are aligned
                DWORD nTimes = Size/sizeof(ULONG_PTR);
                DWORD i;
                for (i=0;i<nTimes;i++)
                {
                    if (Addr == pData[i])
                    {
                        dprintf("- %p off %p\n",pHeapEntry_OOP,sizeof(ULONG_PTR)*i);
                        PrintHeapEntry((HEAP_ENTRY *)pEntry,(void *)pHeapEntry_OOP);
                        g_NumMatch++;
                    }
                }
            }
            else
            {
                dprintf("        entry %p too big\n",pHeapEntry_OOP);
            }
        }         
    }
    else
    {
        dprintf("RM %p\n",pHeapEntry_OOP);
    }
    return 0;
}

//
//
// search the HEAP, incomplete
//
///////////////////////////////////////////////

DECLARE_API(shp) 
{
    INIT_API();

    DEFINE_CPP_VAR( HEAP, varHEAP);
    HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );    
    

    char * pArgs = (char *)args;
    while(isspace(*pArgs)) pArgs++;

    MEMORY_ADDRESS pByte = GetExpression(pArgs);

    while(!isspace(*pArgs)) pArgs++;

    MEMORY_ADDRESS Addr = GetExpression(pArgs);
    
    DWORD i;

    if (pByte && Addr)
    {
        g_BlockSize = 0x10000*sizeof(HEAP_ENTRY);
        g_pBlockBlob = (ULONG_PTR *)VirtualAlloc(NULL,g_BlockSize,MEM_COMMIT,PAGE_READWRITE);

        if (!g_pBlockBlob)
        {
            dprintf("VirtualAlloc err %d\n",GetLastError());
            return;
        }        
             
        if (ReadMemory(pByte,pHeap ,sizeof(HEAP),NULL))
        {

            g_NumMatch = 0;
            for (i=0;i<HEAP_MAXIMUM_SEGMENTS;i++)
            {
                if (pHeap->Segments[i])
                    PrintHEAP_SEGMENT(pHeap->Segments[i],CallBackSearch,(ULONG_PTR)Addr);
                //    dprintf(" seg %i - %p\n",i,pHeap->Segments[i]);
                
            }
            dprintf("%d matches found\n",g_NumMatch);
        }
        else
        {
            dprintf("RM %p %d\n",pByte,GetLastError());
        }

        if (g_pBlockBlob)
        {
            VirtualFree(g_pBlockBlob,0,MEM_RELEASE);
            g_pBlockBlob = NULL;
            g_BlockSize = 0;
        }
    }
    else
    {
        dprintf("invalid heap address pair in%s\n",args);
    }
}

//
//  decode heap flags
//
/*
#define HEAP_NO_SERIALIZE               0x00000001      // winnt
#define HEAP_GROWABLE                   0x00000002      // winnt
#define HEAP_GENERATE_EXCEPTIONS        0x00000004      // winnt
#define HEAP_ZERO_MEMORY                0x00000008      // winnt
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010      // winnt
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020      // winnt
#define HEAP_FREE_CHECKING_ENABLED      0x00000040      // winnt
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080      // winnt

#define HEAP_SETTABLE_USER_VALUE        0x00000100
#define HEAP_SETTABLE_USER_FLAG1        0x00000200
#define HEAP_SETTABLE_USER_FLAG2        0x00000400
#define HEAP_SETTABLE_USER_FLAG3        0x00000800

#define HEAP_CLASS_0                    0x00000000      // process heap
#define HEAP_CLASS_1                    0x00001000      // private heap
#define HEAP_CLASS_2                    0x00002000      // Kernel Heap
#define HEAP_CLASS_3                    0x00003000      // GDI heap
#define HEAP_CLASS_4                    0x00004000      // User heap
#define HEAP_CLASS_5                    0x00005000      // Console heap
#define HEAP_CLASS_6                    0x00006000      // User Desktop heap
#define HEAP_CLASS_7                    0x00007000      // Csrss Shared heap
#define HEAP_CLASS_8                    0x00008000      // Csr Port heap
*/
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000



void DecodeFlags(ULONG Flags)
{
    dprintf("           Flags: %08x ",Flags);
    if (Flags & HEAP_NO_SERIALIZE)
           dprintf("HEAP_NO_SERIALIZE ");
    if (Flags & HEAP_GROWABLE)
        dprintf("HEAP_GROWABLE ");
    if (Flags & HEAP_GENERATE_EXCEPTIONS)
        dprintf("HEAP_GENERATE_EXCEPTIONS ");
    if (Flags & HEAP_ZERO_MEMORY)
        dprintf("HEAP_ZERO_MEMORY ");
    
    if (Flags & HEAP_REALLOC_IN_PLACE_ONLY)
        dprintf("HEAP_REALLOC_IN_PLACE_ONLY ");
    if (Flags & HEAP_TAIL_CHECKING_ENABLED)
        dprintf("HEAP_TAIL_CHECKING_ENABLED ");
    if (Flags & HEAP_FREE_CHECKING_ENABLED)
        dprintf("HEAP_FREE_CHECKING_ENABLED ");
    if (Flags & HEAP_DISABLE_COALESCE_ON_FREE)
        dprintf("HEAP_DISABLE_COALESCE_ON_FREE ");
    
    if (Flags & HEAP_SETTABLE_USER_VALUE)
        dprintf("HEAP_SETTABLE_USER_VALUE ");    
    if (Flags & HEAP_SETTABLE_USER_FLAG1)
        dprintf("HEAP_SETTABLE_USER_FLAG1 ");
    if (Flags & HEAP_SETTABLE_USER_FLAG2)
        dprintf("HEAP_SETTABLE_USER_FLAG2 ");
    if (Flags & HEAP_SETTABLE_USER_FLAG3)
        dprintf("HEAP_SETTABLE_USER_FLAG3 ");

    if (Flags & HEAP_CLASS_MASK)
        dprintf("HEAP_CLASS %d",(Flags&HEAP_CLASS_MASK)>>12);
/*    
    if (Flags & HEAP_CLASS_1)
        dprintf("HEAP_CLASS_1 ");
    if (Flags & HEAP_CLASS_2)
        dprintf("HEAP_CLASS_2 ");
    if (Flags & HEAP_CLASS_3)
        dprintf("HEAP_CLASS_3 ");
    if (Flags & HEAP_CLASS_4)
        dprintf("HEAP_CLASS_4 ");
    if (Flags & HEAP_CLASS_5)
        dprintf("HEAP_CLASS_5 ");
    if (Flags & HEAP_CLASS_6)
        dprintf("HEAP_CLASS_6 ");
    if (Flags & HEAP_CLASS_7)
        dprintf("HEAP_CLASS_7 ");
*/        

    //if (Flags & HEAP_CAPTURE_STACK_BACKTRACES)
    //    dprintf("HEAP_CAPTURE_STACK_BACKTRACES ");    
    if (Flags &HEAP_SKIP_VALIDATION_CHECKS)
        dprintf("HEAP_SKIP_VALIDATION_CHECKS ");
    if (Flags &HEAP_VALIDATE_ALL_ENABLED)
        dprintf("HEAP_VALIDATE_ALL_ENABLED ");
    if (Flags &HEAP_VALIDATE_PARAMETERS_ENABLED)
        dprintf("HEAP_VALIDATE_PARAMETERS_ENABLED ");
    if (Flags &HEAP_LOCK_USER_ALLOCATED)
        dprintf("HEAP_LOCK_USER_ALLOCATED ");

    if (Flags &HEAP_FLAG_PAGE_ALLOCS)
        dprintf("HEAP_FLAG_PAGE_ALLOCS "); 
    if (Flags &HEAP_PROTECTION_ENABLED)
        dprintf("HEAP_PROTECTION_ENABLED "); 
    if (Flags &HEAP_BREAK_WHEN_OUT_OF_VM)
        dprintf("HEAP_BREAK_WHEN_OUT_OF_VM "); 
    if (Flags &HEAP_NO_ALIGNMENT)
        dprintf("HEAP_NO_ALIGNMENT ");     
    
    //if (Flags &)
    //    dprintf(" ");    
    dprintf("\n");
}

//
//  Get all the heaps
//

DECLARE_API(hps)
{
    INIT_API();

    PEB * pPeb = NULL;
    PEB   ThisPeb;
    GetPeb(hCurrentProcess,&pPeb);

    if(!pPeb)
    {
#ifdef  _WIN64
        pPeb = (PEB *)0x6fbfffde000;
#else
        pPeb = (PEB *)0x7ffdf000;
#endif
    }
    
    if (pPeb)
    {
        ReadMemory((MEMORY_ADDRESS)pPeb,&ThisPeb,sizeof(PEB),0);
        void ** pHeaps = (void**)_alloca(ThisPeb.NumberOfHeaps*sizeof(void*));
        DWORD i,j;
        ULONG_PTR TotCommitSize = 0;
        ULONG_PTR TotVirtSize = 0;        

        if (ReadMemory((MEMORY_ADDRESS)ThisPeb.ProcessHeaps,pHeaps,ThisPeb.NumberOfHeaps*sizeof(void*),0))
        {
            for(i=0;i<ThisPeb.NumberOfHeaps;i++)
            {
                DEFINE_CPP_VAR( HEAP, varHEAP);
                HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );
                ULONG_PTR TotHeapCommitSize = 0;
                ULONG_PTR TotHeapVirtSize = 0;

                if (ReadMemory((MEMORY_ADDRESS)pHeaps[i],pHeap ,sizeof(HEAP),0))
                {
                    for (j=0;j<HEAP_MAXIMUM_SEGMENTS;j++)
                    {
                        if (pHeap->Segments[j])
                        {
                            DEFINE_CPP_VAR( HEAP_SEGMENT, varHEAP_SEGMENT);
                            HEAP_SEGMENT * pHeapSeg = GET_CPP_VAR_PTR( HEAP_SEGMENT , varHEAP_SEGMENT ); 

                            if (ReadMemory((MEMORY_ADDRESS)pHeap->Segments[j],pHeapSeg,sizeof(HEAP_SEGMENT),0))
                            {
                                dprintf("       - %p (C %p - R %p)\n",
                                        pHeap->Segments[j],
                                        (pHeapSeg->NumberOfPages - pHeapSeg->NumberOfUnCommittedPages) * PAGE_SIZE,
                                        (pHeapSeg->NumberOfPages) * PAGE_SIZE);
                                
                                TotHeapCommitSize += ((pHeapSeg->NumberOfPages - pHeapSeg->NumberOfUnCommittedPages) * PAGE_SIZE);
                                TotHeapVirtSize += ((pHeapSeg->NumberOfPages) * PAGE_SIZE);
                                // now print the beggining of a committed range
                                dprintf("            CR %p\n",pHeapSeg->BaseAddress);
                                HEAP_UNCOMMMTTED_RANGE * pUncomm_OOP = pHeapSeg->UnCommittedRanges;
                                for (DWORD i=0;i<pHeapSeg->NumberOfUnCommittedRanges && pUncomm_OOP;i++)                                    
                                {
                                    HEAP_UNCOMMMTTED_RANGE UncommRange;
                                    if (ReadMemory((MEMORY_ADDRESS)pUncomm_OOP,&UncommRange,sizeof(HEAP_UNCOMMMTTED_RANGE),NULL))
                                    {
                                        if (UncommRange.Next)
                                        {
                                            pUncomm_OOP = UncommRange.Next;
                                        }
                                        ULONG_PTR RangeAddr = (ULONG_PTR)UncommRange.Address+UncommRange.Size;
                                        if (RangeAddr != (ULONG_PTR)pHeapSeg->LastEntryInSegment)
                                        dprintf("            CR %p\n",RangeAddr);
                                    }
                                    else
                                    {
                                        dprintf("RM %p\n",pHeapSeg->UnCommittedRanges);
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                dprintf("RM %p\n",pHeap->Segments[j]);
                            }
                        }
                    }
                }
                else
                {
                    dprintf("RM %p\n",pHeaps[i]);
                    pHeap = NULL;
                }                    
                dprintf("       HEAP %p - %p\n",pHeaps[i],TotHeapCommitSize);
                if (pHeap)
                {
                    DecodeFlags(pHeap->Flags|pHeap->ForceFlags);
                    dprintf("           FrontEndHeapType %d\n",pHeap->FrontEndHeapType);
                }
                TotCommitSize += TotHeapCommitSize;
                TotVirtSize += TotHeapVirtSize;
            }
            dprintf("      -- Tot C %p Tot R %p\n",TotCommitSize, TotVirtSize);
           }
        else
        {
            dprintf("RM %p\n",ThisPeb.ProcessHeaps);
        }
    }
    else
    {
        dprintf("unable to get PEB\n");
    }
}


//
//  reverse heap free list
//
//////////////////

DWORD
CallBackFreeList(VOID * pStructure_OOP,
                 VOID * pLocalCopy)
{
    HEAP_FREE_ENTRY * pFreeEntry = (HEAP_FREE_ENTRY *)pLocalCopy;

    dprintf("    %p (%p,%p): %04x - %04x [%02x] %02x %02x (%x)\n",
            pStructure_OOP,
            pFreeEntry->FreeList.Flink,
            pFreeEntry->FreeList.Blink,
            pFreeEntry->Size,
            pFreeEntry->PreviousSize,
            pFreeEntry->Flags,
            pFreeEntry->Index,
            pFreeEntry->Mask,
            pFreeEntry->Size*sizeof(HEAP_ENTRY));
            
    return 0;    
}


DECLARE_API( rllc )
{
    INIT_API();

    MEMORY_ADDRESS Addr = GetExpression(args);

    if (Addr)
    {
        EnumReverseLinkedListCB((LIST_ENTRY *)Addr,
                                sizeof(HEAP_FREE_ENTRY),
                                FIELD_OFFSET(HEAP_FREE_ENTRY,FreeList),
                                CallBackFreeList);
    }
    else
    {
        dprintf("cannot resolve %s\n",args);
    }
}

//
//
//  Print the Free Lists of the Heap
//
/////////////////////////////////////////////////

DWORD
CallBackFreeList2(VOID * pStructure_OOP,
                 VOID * pLocalCopy)
{
    HEAP_FREE_ENTRY * pFreeEntry = (HEAP_FREE_ENTRY *)pLocalCopy;

    dprintf("    %p (%p,%p): %04x - %04x [%02x] %02x %02x (%x)",
            pStructure_OOP,
            pFreeEntry->FreeList.Flink,
            pFreeEntry->FreeList.Blink,
            pFreeEntry->Size,
            pFreeEntry->PreviousSize,
            pFreeEntry->Flags,
            pFreeEntry->Index,
            pFreeEntry->Mask,
            pFreeEntry->Size*sizeof(HEAP_ENTRY));

    MEMORY_ADDRESS pEntry = (MEMORY_ADDRESS)pStructure_OOP;
    
    HEAP_ENTRY HeapEntry;
    ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0);

    while (HeapEntry.PreviousSize)
    {
        pEntry = (MEMORY_ADDRESS)((HEAP_ENTRY*)pEntry - HeapEntry.PreviousSize);
        if (ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0))
        {               
        }
        else
        {
            dprintf("RM %p\n",pEntry);
            break;
        }

        if (CheckControlC())
           break;           
    }
    dprintf(" -B %p\n",pEntry);            
    return 0;    
}

#define EmptyFull( expr ) (( expr )?'F':'-')

DECLARE_API( hpf )
{
    INIT_API();

    DEFINE_CPP_VAR( HEAP, varHEAP);
    HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );    
    MEMORY_ADDRESS pByte = GetExpression(args);

    if (pByte)
    {     
        if (ReadMemory(pByte,pHeap ,sizeof(HEAP),NULL))
        {
                dprintf("        --   00 01 02 03 04 05 06 07\n");
            DWORD nBytes = HEAP_MAXIMUM_FREELISTS / 8 ;
            for (DWORD i=0;i<nBytes;i++)
            {
                BYTE Set = pHeap->u.FreeListsInUseBytes[i];
                dprintf("        %02x :  %c  %c  %c  %c  %c  %c  %c  %c\n",8*i,
                          EmptyFull(Set & 0x01),EmptyFull(Set & 0x02),EmptyFull(Set & 0x04),EmptyFull(Set & 0x08),
                          EmptyFull(Set & 0x10),EmptyFull(Set & 0x20),EmptyFull(Set & 0x40),EmptyFull(Set & 0x80));
            }
                dprintf("        ------------\n");           
            
            HEAP * pHeap_OOP = (HEAP *)pByte;        
            for (DWORD i=0;i<HEAP_MAXIMUM_FREELISTS;i++)
            {
                dprintf("    FreeList[%x] @ %p\n",i,&pHeap_OOP->FreeLists[i]);
                EnumReverseLinkedListCB((LIST_ENTRY *)&pHeap_OOP->FreeLists[i],
                                       sizeof(HEAP_FREE_ENTRY),
                                       FIELD_OFFSET(HEAP_FREE_ENTRY,FreeList),
                                       CallBackFreeList2);                
            }
        }
        else
        {
            dprintf("RM %p\n",pByte);
        }
    }
    else
    {
        dprintf("invalid address %s\n",args);
    }
    
}

//
// dumps the DPH_HEAP_ROOT
//
///////////////////////////////////////

DECLARE_API( php )
{
    INIT_API();

    char * pHeapAddr = (char *)args;
    while (isspace(*pHeapAddr)) pHeapAddr++;

    char * pNext = pHeapAddr;
    while (!isspace(*pNext)) pNext++; // skipt the Heap Addr
    if (*pNext)
    {
        *pNext = 0;
        pNext++;
    }        
    MEMORY_ADDRESS Addr = GetExpression(pHeapAddr);    
    while (isspace(*pNext)) pNext++; // skip the other spaces
    MEMORY_ADDRESS SearchAddr = 0;
    if (*pNext == 's' ||*pNext == 'S')
    {
        pNext++; // skip the 's'
        if (*pNext)
        {
            while(isspace(*pNext)) pNext++; // skip the spaces
            SearchAddr = GetExpression(pNext);
        } 
    }

    //dprintf("heap %p addr %p\n",Addr,SearchAddr);

    if (Addr)
    {

        g_BlockSize = 0x10000*sizeof(HEAP_ENTRY);
        g_pBlockBlob = NULL;
        if (SearchAddr)
            g_pBlockBlob = (ULONG_PTR *)VirtualAlloc(NULL,g_BlockSize,MEM_COMMIT,PAGE_READWRITE);

        if (SearchAddr && !g_pBlockBlob)
        {
            dprintf("VirtualAlloc err %d\n",GetLastError());
            return;
        }        

        HEAP Heap;
        DPH_HEAP_ROOT HeapPage;
        if (0 == SearchAddr)
            dprintf("  HEAP @ %p\n",Addr);
        if (ReadMemory((MEMORY_ADDRESS)Addr,&Heap,sizeof(HEAP),NULL))
        {
            if (Heap.ForceFlags & HEAP_FLAG_PAGE_ALLOCS)
            {
                Addr += PAGE_SIZE;
                dprintf("  DPH_HEAP_ROOT @ %p\n",Addr);
                if (ReadMemory((MEMORY_ADDRESS)Addr,&HeapPage,sizeof(DPH_HEAP_ROOT),NULL))
                {
                    DPH_HEAP_BLOCK HeapBlock;                
                    DPH_HEAP_BLOCK * pNextBlock;

                    if (0 == SearchAddr)
                    {
                        pNextBlock = HeapPage.pVirtualStorageListHead;
                        dprintf("    - pVirtualStorageListHead\n");                    
                        while(pNextBlock)
                        {

                            if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
                            {
                                dprintf("    %p - (%p) B %p S %p \n",
                                       pNextBlock,
                                       HeapBlock.pNextAlloc,
                                       HeapBlock.pVirtualBlock,
                                       HeapBlock.nVirtualBlockSize);
                                pNextBlock = HeapBlock.pNextAlloc;
                            }
                            else
                            {
                                pNextBlock = NULL;
                            }
                        }
                    }
                
                    pNextBlock = HeapPage.pBusyAllocationListHead;
                    if (0 == SearchAddr)
                        dprintf("    - pBusyAllocationListHead\n");
                    while(pNextBlock)
                    {
                        if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
                        {
                            if (0 == SearchAddr)
                            {
                                dprintf("    %p - (%p) %x %x %x U %p S %p\n",
                                       pNextBlock,
                                       HeapBlock.pNextAlloc,
                                       ULONG_PTR(HeapBlock.pVirtualBlock)/PAGE_SIZE,
                                       HeapBlock.nVirtualBlockSize/PAGE_SIZE,
                                       HeapBlock.nVirtualAccessSize/PAGE_SIZE,
                                       HeapBlock.pUserAllocation,
                                       HeapBlock.StackTrace_);
                                GetVTable((MEMORY_ADDRESS)HeapBlock.pUserAllocation+sizeof(DPH_BLOCK_INFORMATION));
                            }
                            else // do the real search
                            {
                                MEMORY_ADDRESS Size = (MEMORY_ADDRESS)HeapBlock.pVirtualBlock+HeapBlock.nVirtualAccessSize-(MEMORY_ADDRESS)HeapBlock.pUserAllocation;
                                if (ReadMemory((MEMORY_ADDRESS)HeapBlock.pUserAllocation,g_pBlockBlob,(ULONG)Size,NULL))
                                {
                                    Size /= sizeof(ULONG_PTR);
                                    BOOL bFound = FALSE;
                                    for (ULONG_PTR j =0;j<Size;j++)
                                    {
                                        if (SearchAddr == g_pBlockBlob[j])
                                        {
                                            bFound = TRUE;
                                            dprintf("    OFF %p\n",j*sizeof(ULONG_PTR));
                                        }
                                    }
                                    if (bFound)
                                    {
                                        dprintf("    B   %p\n",HeapBlock.pUserAllocation);
                                    }
                                }
                                else
                                {
                                    dprintf("RM %p\n",HeapBlock.pUserAllocation);
                                }
                            }
                            pNextBlock = HeapBlock.pNextAlloc;
                        }
                        else
                        {
                            pNextBlock = NULL;
                        }
                    }

                    if (0 == SearchAddr)
                    {                    
                        pNextBlock = HeapPage.pFreeAllocationListHead;
                        dprintf("    - pFreeAllocationListHead\n");
                        while(pNextBlock)
                        {
                            if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
                            {
                                dprintf("    %p - (%p) %x %x %x U %p S %p\n",
                                       pNextBlock,
                                       HeapBlock.pNextAlloc,
                                       ULONG_PTR(HeapBlock.pVirtualBlock)/PAGE_SIZE,
                                       HeapBlock.nVirtualBlockSize/PAGE_SIZE,
                                       HeapBlock.nVirtualAccessSize/PAGE_SIZE,
                                       HeapBlock.pUserAllocation,
                                       HeapBlock.StackTrace_);
                                pNextBlock = HeapBlock.pNextAlloc;
                            }
                            else
                            {
                                pNextBlock = NULL;
                            }
                        }
                    }

                    if (0 == SearchAddr)
                    {                    
                        pNextBlock = HeapPage.pAvailableAllocationListHead;
                        dprintf("    - pAvailableAllocationListHead\n");
                        while(pNextBlock)
                        {

                            if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
                            {
                                dprintf("    %p - (%p) B %p S %p \n",
                                       pNextBlock,
                                       HeapBlock.pNextAlloc,
                                       HeapBlock.pVirtualBlock,
                                       HeapBlock.nVirtualBlockSize);
                                pNextBlock = HeapBlock.pNextAlloc;
                            }
                            else
                            {
                                pNextBlock = NULL;
                            }
                        }
                    }

                    if (0 == SearchAddr)
                    {
                        pNextBlock = HeapPage.pNodePoolListHead;
                        dprintf("    - pNodePoolListHead\n");
                        while(pNextBlock)
                        {

                            if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
                            {
                                dprintf("    %p - (%p) B %p S %p \n",
                                       pNextBlock,
                                       HeapBlock.pNextAlloc,
                                       HeapBlock.pVirtualBlock,
                                       HeapBlock.nVirtualBlockSize);
                                pNextBlock = HeapBlock.pNextAlloc;
                            }
                            else
                            {
                                pNextBlock = NULL;
                            }
                        }
                    }                    

                    dprintf("  NormalHeap @ %p\n",HeapPage.NormalHeap);
                    if (ReadMemory((ULONG_PTR)HeapPage.NormalHeap,&Heap ,sizeof(HEAP),NULL))
                    {
                        for (DWORD h=0;h<HEAP_MAXIMUM_SEGMENTS;h++)
                        {
                            if (Heap.Segments[h])
                            {
                                if (SearchAddr)
                                    PrintHEAP_SEGMENT(Heap.Segments[h],CallBackSearch,(ULONG_PTR)SearchAddr);
                                else
                                    PrintHEAP_SEGMENT(Heap.Segments[h],NULL,NULL);
                            }
                        }
                    }
                    else
                    {
                        dprintf("RM %p\n",HeapPage.NormalHeap);
                    }
                    
                }
                else
                {
                    dprintf("RM %p\n",Addr);
                }

            }
            else
            {
                DecodeFlags(Heap.ForceFlags|Heap.Flags);
            }
        }
        else
        {
            dprintf("RM %p\n",Addr);
        }

        if (g_pBlockBlob)
        {
            VirtualFree(g_pBlockBlob,g_BlockSize,MEM_RELEASE);
            g_pBlockBlob = NULL;
            g_BlockSize = 0;
        }
        
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
}

//
//
//  virtual_query helper
//
///////////////////////////////////////////////////////////////

char * GetState(DWORD State)
{
    switch(State)
    {
    case MEM_COMMIT:
        return "MEM_COMMIT";
    case MEM_RESERVE:
        return "MEM_RESERVE";
    case MEM_FREE:
        return "MEM_FREE";
    };
    return "";
}

char * GetType(DWORD Type)
{
    switch(Type)
    {
    case MEM_IMAGE:
        return "MEM_IMAGE";
    case MEM_MAPPED:
        return "MEM_MAPPED";
    case MEM_PRIVATE:
        return "MEM_PRIVATE";
    }
    return "";
}

char * GetProtect(DWORD Protect)
{
    switch(Protect)
    {
    case PAGE_NOACCESS:
        return "PAGE_NOACCESS";
    case PAGE_READONLY:
        return "PAGE_READONLY";
    case PAGE_READWRITE:
        return "PAGE_READWRITE";
    case PAGE_WRITECOPY:
        return "PAGE_WRITECOPY";
    case PAGE_EXECUTE:
        return "PAGE_EXECUTE";
    case PAGE_EXECUTE_READ:
        return "PAGE_EXECUTE_READ";
    case PAGE_EXECUTE_READWRITE:
        return "PAGE_EXECUTE_READWRITE";
    case PAGE_EXECUTE_WRITECOPY:
        return "PAGE_EXECUTE_WRITECOPY";
    case PAGE_GUARD:
        return "PAGE_GUARD";
    case PAGE_NOCACHE:
        return "PAGE_NOCACHE";
    case PAGE_WRITECOMBINE:
        return "PAGE_WRITECOMBINE";
    }
    return "<unk>";
}

//
//
//  VirtualQueryEx
//
//
//  vq -a address
//  vq -f filter <all address space>
//
///////////////////////////////////////////

DECLARE_API(vq)
{
    INIT_API();

    MEMORY_ADDRESS pVA = 0;
    MEMORY_ADDRESS Filter = (MEMORY_ADDRESS)-1;
    DWORD FilterSize = 0;
    BOOL bAll = TRUE;

    char * pCurrent = (char *)args;
    
    if(0 < strlen(pCurrent))
    {
        while (isspace(*pCurrent)) pCurrent++;
        if ('-' == *pCurrent  ||
            '/'  == *pCurrent)
        {
            pCurrent++;
            while (isspace(*pCurrent)) pCurrent++;
            if ('a' == *pCurrent)
            {
                pCurrent++;
                while (*pCurrent && isspace(*pCurrent)) pCurrent++;
                pVA = GetExpression(pCurrent);
                bAll = FALSE;
            } 
            else if ('f' == *pCurrent)
            {
                pCurrent++;
                while (*pCurrent && isspace(*pCurrent)) pCurrent++;
                Filter = GetExpression(pCurrent);   
                dprintf("FILTER %08x\n",Filter);
            }
            else if ('s' == *pCurrent)
            {
                pCurrent++;
                while (*pCurrent && isspace(*pCurrent)) pCurrent++;
                FilterSize = (DWORD)GetExpression(pCurrent);   
                dprintf("Size %08x\n",FilterSize);
            }            
            else
            {
                dprintf("usage: -a ADDR\n"
                        "usage: -F Filter <all address space>\n");
            }
        }
    }
    else
    {
        dprintf("no param\n");
    }


    ULONG_PTR Tot = 0; 
    MEMORY_BASIC_INFORMATION MemInfo;
    SIZE_T dwRet = 0;
    
    do
    {
        dwRet = VirtualQueryEx(hCurrentProcess,(LPCVOID)pVA,&MemInfo,sizeof(MemInfo));
    
        if (dwRet && 
            (MemInfo.AllocationProtect & Filter) && 
            (MemInfo.RegionSize > FilterSize))
        {
            dprintf("    Base %p Size %p Alloc %p Prot %s  %s %s %s\n",
                MemInfo.BaseAddress,
                MemInfo.RegionSize,                
                MemInfo.AllocationBase,
                GetProtect(MemInfo.AllocationProtect),
                GetState(MemInfo.State),
                GetProtect(MemInfo.Protect),
                GetType(MemInfo.Type));
            Tot += MemInfo.RegionSize;
        }
        
        pVA = (ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)MemInfo.RegionSize;
        
        if (CheckControlC())
            break;
    } while (dwRet && bAll);

    dprintf("    Total %p\n",Tot);

}

//
//
//
//

#ifdef KDEXT_64BIT

struct _HEAP_ENTRY_64 
{
   WORD Size         ;
   WORD PreviousSize ;
   BYTE SegmentIndex ;
   BYTE Flags        ;
   BYTE UnusedBytes  ;
   BYTE SmallTagIndex;
   ULONG64 Pointer;
};

#endif /*KDEXT_64BIT*/

DECLARE_API(hef64)
{
    INIT_API();
#ifdef KDEXT_64BIT

    _HEAP_ENTRY_64 HeapEntry;
    ULONG64  MemAddr = GetExpression(args);
    ULONG64  pVTable = 0;

    if (MemAddr)
    {
        if (ReadMemory(MemAddr,&HeapEntry,sizeof(HeapEntry),NULL))
        {
            dprintf("    %p: %04x - %04x [%02x] (%x)\n",MemAddr,HeapEntry.Size,HeapEntry.PreviousSize,HeapEntry.Flags,HeapEntry.Size*sizeof(_HEAP_ENTRY_64)-HeapEntry.UnusedBytes);
            GetVTable(MemAddr + sizeof(_HEAP_ENTRY_64));
            MemAddr = MemAddr+HeapEntry.Size*sizeof(_HEAP_ENTRY_64);
                        
            // 0x10 is LAST_ENTRY
            while(!(HeapEntry.Flags & 0x10))
            {
                if (ReadMemory(MemAddr,&HeapEntry,sizeof(HeapEntry),NULL))
                {
                    dprintf("    %p: %04x - %04x [%02x] (%x)\n",MemAddr,HeapEntry.Size,HeapEntry.PreviousSize,HeapEntry.Flags,HeapEntry.Size*sizeof(_HEAP_ENTRY_64)-HeapEntry.UnusedBytes);
                    GetVTable(MemAddr + sizeof(_HEAP_ENTRY_64));                    
                    MemAddr = MemAddr+HeapEntry.Size*sizeof(_HEAP_ENTRY_64);
                }
                else
                {
                    dprintf("RM %p\n",MemAddr);
                    break;
                }
                if (CheckControlC())
                    break;
            }
            dprintf("last %p\n",MemAddr);
        }
        else
        {
            dprintf("RM %p\n",MemAddr);
        }
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
    
#endif /*KDEXT_64BIT*/    
}

DECLARE_API(heb64)
{
    INIT_API();
#ifdef KDEXT_64BIT

    _HEAP_ENTRY_64 HeapEntry;
    ULONG64  MemAddr = GetExpression(args);
    ULONG64  pVTable = 0;

    if (MemAddr)
    {
        if (ReadMemory(MemAddr,&HeapEntry,sizeof(HeapEntry),NULL))
        {
            dprintf("    %p: %04x - %04x [%02x] (%x)\n",MemAddr,HeapEntry.Size,HeapEntry.PreviousSize,HeapEntry.Flags,HeapEntry.Size*sizeof(_HEAP_ENTRY_64)-HeapEntry.UnusedBytes);
            GetVTable(MemAddr + sizeof(_HEAP_ENTRY_64));
            MemAddr = MemAddr - HeapEntry.PreviousSize*sizeof(_HEAP_ENTRY_64);
                        
            // 0x10 is LAST_ENTRY
            while(HeapEntry.PreviousSize)
            {
                if (ReadMemory(MemAddr,&HeapEntry,sizeof(HeapEntry),NULL))
                {
                    dprintf("    %p: %04x - %04x [%02x] (%x)\n",MemAddr,HeapEntry.Size,HeapEntry.PreviousSize,HeapEntry.Flags,HeapEntry.Size*sizeof(_HEAP_ENTRY_64)-HeapEntry.UnusedBytes);
                    GetVTable(MemAddr + sizeof(_HEAP_ENTRY_64));                    
                    MemAddr = MemAddr - HeapEntry.PreviousSize*sizeof(_HEAP_ENTRY_64);
                }
                else
                {
                    dprintf("RM %p\n",MemAddr);
                    break;
                }
                if (CheckControlC())
                    break;
            }
                                    
            dprintf("last %p\n",MemAddr);
        }
        else
        {
            dprintf("RM %p\n",MemAddr);
        }
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
    
#endif /*KDEXT_64BIT*/    
}


DECLARE_API(hps64)
{
    INIT_API();
#ifdef KDEXT_64BIT

    ULONG64 Peb = GetExpression(args);

    if (!Peb)
    {
        Peb = 0x6fbfffde000;
    }

    ULONG NumberOfHeapsOffset;
    ULONG HeapsOffset;
    
    ULONG SegmentsOffset;    
    
    if ( Peb &&
         (0 == GetFieldOffset("ntdll!_PEB","NumberOfHeaps",&NumberOfHeapsOffset)) &&
         (0 == GetFieldOffset("ntdll!_PEB","ProcessHeaps",&HeapsOffset)) &&
         (0 == GetFieldOffset("ntdll!_HEAP","Segments",&SegmentsOffset)))
    {
        //dprintf(" %x %x\n",NumberOfHeapsOffset,HeapsOffset);
        ULONG nHeaps;
        ULONG64 MemAddr;
        if (ReadMemory(Peb+NumberOfHeapsOffset,&nHeaps,sizeof(ULONG),NULL))
        {
            //dprintf("nHeaps %08x\n",nHeaps);
            ReadMemory(Peb+HeapsOffset,&MemAddr,sizeof(ULONG64),NULL);
            ULONG64 * pHeaps = (ULONG64 *)_alloca(sizeof(ULONG64)*(DWORD)nHeaps);
            ReadMemory(MemAddr,pHeaps,sizeof(ULONG64)*(DWORD)nHeaps,NULL);

            //  +0x0a0 Segments         : [64] 0x000006fb`f9fa0c50

            ULONG64 Segments[64];
                        
            for(ULONG i=0;i<nHeaps;i++)
            {
                if (ReadMemory(pHeaps[i]+SegmentsOffset,Segments,sizeof(Segments),NULL))
                {
                    for (DWORD j=0;j<64;j++)
                    {
                        if (Segments[j])
                        {
                            dprintf("        S %p\n",Segments[j]);
                        }
                        if (CheckControlC())
                            break;                        
                    }
                }
                dprintf("    %p\n",pHeaps[i]);
                
                if (CheckControlC())
                    break;                
            }
        }
        else
        {
            dprintf("RM %p\n",Peb+NumberOfHeapsOffset);
        }
    }
    else
    {
        dprintf("check symbols for ntdll.dll or validate %p as PEB\n",Peb);
    }
#endif /*KDEXT_64BIT*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\repositutil.cpp ===
#include <wmiexts.h>

#include <utilfun.h>

#include <wbemint.h>
#include <tchar.h>

#include <sync.h>
#include <flexq.h>
#include <arrtempl.h>
#include <newnew.h>

#include <malloc.h>

#ifndef POLARITY
#define POLARITY
#endif

#ifndef RELEASE_ME
#define RELEASE_ME
#endif

#ifndef DELETE_ME
#define DELETE_ME
#endif

#ifndef INTERNAL
#define INTERNAL
#endif

#include <wstring.h>
#include <filecach.h>

#include <flexq.h>
#include <arrtempl.h>
#include <hiecache.h>
#include <creposit.h>

void
DumpMemManager(ULONG_PTR pByte)
{
        DEFINE_CPP_VAR( CTempMemoryManager, varCTempMemoryManager);
        CTempMemoryManager * pTmpAll = GET_CPP_VAR_PTR( CTempMemoryManager , varCTempMemoryManager );

        ReadMemory(pByte,pTmpAll,sizeof(CTempMemoryManager),0);

        dprintf("    m_dwTotalUsed       %08x\n",pTmpAll->m_dwTotalUsed);
        dprintf("    m_dwTotalAllocated  %08x\n",pTmpAll->m_dwTotalAllocated);
        dprintf("    m_dwNumAllocations  %08x\n",pTmpAll->m_dwNumAllocations);
        dprintf("    m_dwNumMisses       %08x\n",pTmpAll->m_dwNumMisses);

        DEFINE_CPP_VAR( CFlexArray, varArr);
        CFlexArray * pArr = GET_CPP_VAR_PTR(CFlexArray,varArr);
        
        DWORD i;
        ReadMemory((ULONG_PTR)pTmpAll->m_pAllocations,pArr,sizeof(CFlexArray),0);

        CTempMemoryManager::CAllocation ** pAllocs = (CTempMemoryManager::CAllocation **)_alloca(pArr->m_nSize*sizeof(void*));
        ReadMemory((ULONG_PTR)pArr->m_pArray,pAllocs,pArr->m_nSize*sizeof(void*),0);

        dprintf("    m_pArray %p %d\n",pArr->m_pArray,pArr->m_nSize);
        DWORD dwTotal = 0;
        for (i=0;i<pArr->m_nSize;i++)        
        {
            dprintf("    CAllocation %d - %p\n",i,pAllocs[i]);

            DEFINE_CPP_VAR( CTempMemoryManager::CAllocation, varCAllocation );
            CTempMemoryManager::CAllocation * pCAll = GET_CPP_VAR_PTR( CTempMemoryManager::CAllocation, varCAllocation );

            ReadMemory((ULONG_PTR)pAllocs[i],pCAll,sizeof(CTempMemoryManager::CAllocation),0);
            
            dprintf("      m_dwAllocationSize %p\n",pCAll->m_dwAllocationSize);
            dprintf("      m_dwUsed           %p\n",pCAll->m_dwUsed);
            dprintf("      m_dwFirstFree      %p\n",pCAll->m_dwFirstFree);
            dwTotal += pCAll->m_dwAllocationSize;

        }
        dprintf("      TOT %p\n",dwTotal);

}

//
//
// dumps the CTempMemoryManagers in repdrvfs
//
//////////////////////////////////////////////////////

DECLARE_API(tmpall) 
{
    INIT_API();

    ULONG_PTR pByte = GetExpression(args);

    if (pByte)
    {
        DumpMemManager(pByte);
        return;
    }
    
    pByte = GetExpression("repdrvfs!g_Manager");
    dprintf("repdrvfs!g_Manager @ %p\n",pByte);
    if (pByte)
    {
        DumpMemManager(pByte);
    }
}

//
//
//  this enum is copyed from btr.h
//
//

    enum { const_DefaultPageSize = 0x2000, const_CurrentVersion = 0x101 };

    enum {
        PAGE_TYPE_IMPOSSIBLE = 0x0,       // Not supposed to happen
        PAGE_TYPE_ACTIVE = 0xACCC,        // Page is active with data
        PAGE_TYPE_DELETED = 0xBADD,       // A deleted page on free list
        PAGE_TYPE_ADMIN = 0xADDD,         // Page zero only

        // All pages
        OFFSET_PAGE_TYPE = 0,             // True for all pages
        OFFSET_PAGE_ID = 1,               // True for all pages
        OFFSET_NEXT_PAGE = 2,             // True for all pages (Page continuator)

        // Admin Page (page zero) only
        OFFSET_LOGICAL_ROOT = 3,          // Root of database
        };

#define PS_PAGE_SIZE  (8192)

#define MIN_ARRAY_KEYS (256)
/*
void
DumpFile(HANDLE hFile,DWORD * pPage)
{
    // read the AdminPage
    BOOL bRet;
    DWORD nRead;
    bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

    if (bRet && (PS_PAGE_SIZE == nRead))
    {
        dprintf("    A %08x %08x %08x R %08x F %08x T %08x %08x %08x\n",
                pPage[OFFSET_PAGE_TYPE],
                pPage[OFFSET_PAGE_ID],
                pPage[OFFSET_NEXT_PAGE],
                pPage[OFFSET_LOGICAL_ROOT],
                pPage[OFFSET_FREE_LIST_ROOT],
                pPage[OFFSET_TOTAL_PAGES],
                pPage[OFFSET_PAGE_SIZE],
                pPage[OFFSET_IMPL_VERSION ]);
    }
    else
    {
        dprintf(" ReadFile %d\n",GetLastError());
    }

    // read the other pages
    DWORD i;
    DWORD dwTotPages = pPage[OFFSET_TOTAL_PAGES];
    for (i=1;i<dwTotPages;i++)
    {
        bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

        if (bRet && (PS_PAGE_SIZE == nRead))
        {
            dprintf("   %02x %08x %08x %08x - P %08x %08x %08x %08x\n",
                i,
                pPage[OFFSET_PAGE_TYPE],
                pPage[OFFSET_PAGE_ID],
                pPage[OFFSET_NEXT_PAGE],
                pPage[OFFSET_NEXT_PAGE+1], // Parent
                pPage[OFFSET_NEXT_PAGE+2], // NumKey
                pPage[OFFSET_NEXT_PAGE+2+pPage[OFFSET_NEXT_PAGE+2]], // UserData
                pPage[OFFSET_NEXT_PAGE+2+pPage[OFFSET_NEXT_PAGE+2]+1]); //ChildPageMap
        }
    }
    DWORD dwFileSize = GetFileSize(hFile,NULL);
    if (dwFileSize != (dwTotPages)*PS_PAGE_SIZE)
    {
        dprintf("    filesize %d expected %d\n",dwFileSize,((1+dwTotPages)*PS_PAGE_SIZE));
    }
}
*/

void PrintDWORDS(DWORD * pDW,DWORD nSize)
{
    DWORD i;
    for (i=0;i<(nSize/4);i++)
    {
        dprintf("    %08x  %08x %08x %08x %08x\n",i,
                pDW[0+i*4],pDW[1+i*4],pDW[2+i*4],pDW[3+i*4]);
    }

    if (nSize%4)
    {
        DWORD dwPAD[4];
        memset(dwPAD,0xff,sizeof(dwPAD));
        memcpy(dwPAD,pDW+i*4,(nSize%4)*sizeof(DWORD));
        
        dprintf("    %08x  %08x %08x %08x %08x\n",i,
                    dwPAD[0],dwPAD[1],dwPAD[2],dwPAD[3]);
    }
}

void PrintWORDS(WORD * pDW,DWORD nSize)
{
    DWORD i;
    for (i=0;i<(nSize/8);i++)
    {
        dprintf("    %08x  %04x %04x %04x %04x %04x %04x %04x %04x\n",i,
                pDW[0+i*8],pDW[1+i*8],pDW[2+i*8],pDW[3+i*8],
                pDW[4+i*8],pDW[5+i*8],pDW[6+i*8],pDW[7+i*8]);
    }

    if (nSize%8)
    {
        WORD dwPAD[8];
        memset(dwPAD,0xff,sizeof(dwPAD));
        memcpy(dwPAD,pDW+i*8,(nSize%8)*sizeof(WORD));
        
        dprintf("    %08x  %04x %04x %04x %04x %04x %04x %04x %04x\n",i,
                    dwPAD[0],dwPAD[1],dwPAD[2],dwPAD[3],
                    dwPAD[4],dwPAD[5],dwPAD[6],dwPAD[7]);
    }
}


void
DumpPage(DWORD * pPage)
{
    
    if (TRUE)
    {
        // here we've read the page

        if (0xACCC != pPage[OFFSET_PAGE_TYPE])
        {
            return;
        }
        
        dprintf("    SIGN %08x PAGE %08x NEXT %08x\n",
                pPage[OFFSET_PAGE_TYPE],pPage[OFFSET_PAGE_ID],pPage[OFFSET_NEXT_PAGE]);
        pPage+=3;

        dprintf("    PAR  %08x NUM  %08x\n",pPage[0],pPage[1]);
        DWORD dwParent = pPage[0];
        DWORD dwNumKey = pPage[1];
        pPage+=2;

        //DWORD dwAlloc = (dwNumKey<=MIN_ARRAY_KEYS)?MIN_ARRAY_KEYS:dwNumKey;

        //DWORD * m_pdwUserData     = HeapAlloc(GetProcessHeap(),0,sizeof(DWORD) *());
        //DWORD * m_pdwChildPageMap = HeapAlloc(GetProcessHeap(),0,sizeof(DWORD) *(1+));
        //WORD * m_pwKeyLookup     =  HeapAlloc(GetProcessHeap(),0,sizeof(WORD) * ());

        // dwNumKey   DWORD USER_DATA        
        // dwNumKey+1 DWORD CHILD_PAGE_MAP
        // dwNumKey   WORD  KEY_LOOKUP
        dprintf("    User Data\n");
        PrintDWORDS(pPage,dwNumKey);

        pPage+=dwNumKey;
        dprintf("    Child PageMap\n");
        PrintDWORDS(pPage,dwNumKey+1);
        
        pPage+=(dwNumKey+1);
        WORD * pKeyLookup = (WORD *)pPage;
        dprintf("    Key Lookup\n");
        PrintWORDS((WORD *)pPage,dwNumKey);

        WORD * pWPage = ((WORD *)pPage + dwNumKey);
        dprintf("    KEY CODE %08x\n",*pWPage);

        DWORD dwKeyUsed = *pWPage;
        pWPage++;
        WORD * pKeyCodes = pWPage;
        dprintf("    Key Codes\n");
        PrintWORDS((WORD *)pWPage,dwKeyUsed);

        pWPage += dwKeyUsed;
        DWORD dwNumStrings = *pWPage++; 
        dprintf("    NUM STRINGS %08x\n",dwNumStrings);

        WORD * ArrayOffsets = pWPage;
        dprintf("    Strings Offsets\n");
        PrintWORDS((WORD *)pWPage,dwNumStrings);
        
        pWPage += dwNumStrings;
        DWORD dwPoolUsed = *pWPage++;
        dprintf("    POOL USED %08x\n",dwPoolUsed);

        //
        DWORD i;
        LPSTR pStrings = (LPSTR)pWPage;

        for (i=0;i<dwNumStrings;i++)
        {
            dprintf("    %08x %04x %s\n",i,ArrayOffsets[i],pStrings+ArrayOffsets[i]);
        }
        //
        // better view
        //
        for (i=0;i<dwNumKey;i++)
        {
            DWORD j;
            WORD NumToken = pKeyCodes[pKeyLookup[i]];
            dprintf("        ( ");
            for (j=0;j<NumToken;j++)
            {
                dprintf("%04x ",pKeyCodes[pKeyLookup[i]+1+j]);
            }
            dprintf(")\n"); 

            dprintf("        - "); 
            for (j=0;j<NumToken;j++)
            {
                //pStrings+ArrayOffsets[i]
                dprintf("%s\\",pStrings+ArrayOffsets[pKeyCodes[pKeyLookup[i]+1+j]]);
            }
            dprintf("\n"); 
        }
    }
}


/*
void
DumpAllPages(HANDLE hFile,DWORD * pPage)
{
    // read the AdminPage
    BOOL bRet;
    DWORD nRead;
    bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

    if (bRet && (PS_PAGE_SIZE == nRead))
    {
        dprintf("    A %08x %08x %08x R %08x F %08x T %08x %08x %08x\n",
                pPage[OFFSET_PAGE_TYPE],
                pPage[OFFSET_PAGE_ID],
                pPage[OFFSET_NEXT_PAGE],
                pPage[OFFSET_LOGICAL_ROOT],
                pPage[OFFSET_FREE_LIST_ROOT],
                pPage[OFFSET_TOTAL_PAGES],
                pPage[OFFSET_PAGE_SIZE],
                pPage[OFFSET_IMPL_VERSION ]);
    }
    else
    {
        dprintf(" ReadFile %d\n",GetLastError());
        return;
    }

    // read the other pages
    DWORD i;
    DWORD dwTotPages = pPage[OFFSET_TOTAL_PAGES];
    for (i=1;i<dwTotPages;i++)
    {
        DumpPage(hFile,i,pPage);
    }
    DWORD dwFileSize = GetFileSize(hFile,NULL);
    if (dwFileSize != (dwTotPages)*PS_PAGE_SIZE)
    {
        dprintf("    filesize %d expected %d\n",dwFileSize,((1+dwTotPages)*PS_PAGE_SIZE));
    }
}
*/

//
// performs the same operations of CPageFile::ReadMap with a buffer
//

struct debugCPageFile
{
        DWORD dwSign;
        DWORD dwTrans;
        DWORD dwPhysical;
        DWORD dwNumPagesA;
        DWORD * pPagesA;
        DWORD dwPagesFreeList;
        DWORD * pFreePages;
        DWORD dwSignTail;    

        BYTE * pEnd;

    debugCPageFile(BYTE * pMap)
    {
            DWORD * pCurrent = (DWORD *)pMap;
              dwSign = *pCurrent++;
              dwTrans = *pCurrent++;
              dwPhysical = *pCurrent++;
              dwNumPagesA = *pCurrent++;
              pPagesA = pCurrent;
              pCurrent+=dwNumPagesA;
              dwPagesFreeList = *pCurrent++;
               pFreePages = pCurrent;
               pCurrent += dwPagesFreeList;
              dwSignTail = *pCurrent++;
              pEnd = (BYTE *)pCurrent;
    };
    BYTE * getEnd(){ return pEnd; }
};

struct debugBtrPage
{
    DWORD dwPageType;
    DWORD dwPageId;
    DWORD dwNextPage;
    DWORD dwLogicalRoot;
    debugBtrPage(BYTE * pBtr)
    {
        DWORD * pdwCurrent = (DWORD *)pBtr;
        dwPageType = *pdwCurrent++;
        dwPageId = *pdwCurrent++;
        dwNextPage = *pdwCurrent++;
        dwLogicalRoot = *pdwCurrent++;
    }
};

#define MAP_LEADING_SIGNATURE   0xABCD
#define MAP_TRAILING_SIGNATURE  0xDCBA

void
Dump_Map(HANDLE hFile)
{
    HANDLE hFileMap = NULL;
    BYTE * pMap = NULL;

    DWORD dwSize = 0;
    
    dwSize = GetFileSize(hFile,NULL);
    hFileMap = CreateFileMapping(hFile,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSize,
                                    NULL);
    if (hFileMap)
    {
        pMap = (BYTE *)MapViewOfFile(hFileMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hFileMap) %d\n",GetLastError());
        goto cleanup;
    };

    dwSize = GetFileSize(hFile,NULL);
    hFileMap = CreateFileMapping(hFile,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSize,
                                    NULL);

    if (hFileMap)
    {
        pMap = (BYTE *)MapViewOfFile(hFileMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hFileMapFre) %d\n",GetLastError());
        goto cleanup;
    };

    if (pMap)
    {
         debugCPageFile a(pMap);
         dprintf("    m_ObjPF\n");
        dprintf("    %08x SIGN HEAD\n",a.dwSign);
        dprintf("    %08x Trans\n",a.dwTrans);
        dprintf("    %08x m_dwPhysPagesA\n",a.dwPhysical);
        dprintf("    %08x m_aPageMapA.size()\n",a.dwNumPagesA);
        PrintDWORDS(a.pPagesA,a.dwNumPagesA);
        dprintf("    %08x m_aPhysFreeListA.size()\n",a.dwPagesFreeList);
        PrintDWORDS(a.pFreePages,a.dwPagesFreeList);
        dprintf("    %08x SIGN TAIL\n",a.dwSignTail); 

        debugCPageFile b(a.getEnd());
         dprintf("    m_BTreePF\n");        
        dprintf("    %08x SIGN HEAD\n",b.dwSign);
        dprintf("    %08x Trans\n",b.dwTrans);
        dprintf("    %08x m_dwPhysPagesA\n",b.dwPhysical);
        dprintf("    %08x m_aPageMapA.size()\n",b.dwNumPagesA);
        PrintDWORDS(b.pPagesA,b.dwNumPagesA);
        dprintf("    %08x m_aPhysFreeListA.size()\n",b.dwPagesFreeList);
        PrintDWORDS(a.pFreePages,b.dwPagesFreeList);
        dprintf("    %08x SIGN TAIL\n",b.dwSignTail);         
    }

cleanup:
    if (pMap)
        UnmapViewOfFile(pMap);
    if (hFileMap)
        CloseHandle(hFileMap);
};

void
Dump_AdminPage(BYTE * pMap,BYTE * pObj)
{
    if (pMap && pObj)
    {
         debugCPageFile a(pMap);
        
        DWORD i;
        DWORD AdminIndex = 0;        
        do {
            if (WMIREP_INVALID_PAGE == a.pPagesA[AdminIndex] ||
                WMIREP_RESERVED_PAGE  == a.pPagesA[AdminIndex])
            {
                dprintf("BAD dwNextAdminPage %08x index %x\n",a.pPagesA[AdminIndex],AdminIndex);
                break;
            }
            BYTE * pAdminPage = pObj + (a.pPagesA[AdminIndex]*PS_PAGE_SIZE);
            VarObjHeapAdminPage * pAdmin = (VarObjHeapAdminPage *)pAdminPage;
            AdminIndex = pAdmin->dwNextAdminPage;
            dprintf("    ver %08x Next %08x Ent %08x\n",pAdmin->dwVersion,pAdmin->dwNextAdminPage,pAdmin->dwNumberEntriesOnPage);
            VarObjHeapFreeList * pFreeEntry = (VarObjHeapFreeList *)(pAdmin+1);
            dprintf("                    dwPageId dwFreeSp dwCRC32\n");
            if (pAdmin->dwNumberEntriesOnPage > (PS_PAGE_SIZE/sizeof(VarObjHeapFreeList)))
            {
                dprintf("Suspicious dwNumberEntriesOnPage %08x on page %x\n",pAdmin->dwNumberEntriesOnPage,AdminIndex);
                break;
            }
            for (i=0;i<pAdmin->dwNumberEntriesOnPage;i++)
            {
                dprintf("         %08x - %08x %08x %08X\n",i,pFreeEntry->dwPageId,pFreeEntry->dwFreeSpace,pFreeEntry->dwCRC32);
                pFreeEntry++;
            }
        } while(AdminIndex);
    }
};

void
Dump_Index(BYTE * pMap,BYTE * pBtr)
{
    if (pMap && pBtr)
    {
        debugCPageFile a0(pMap);
        debugCPageFile a(a0.getEnd());
        
        BYTE * pStart = pBtr + (a.pPagesA[0]*PS_PAGE_SIZE);
        debugBtrPage b(pStart);
        dprintf("        %08x %08x %08x %08x - %08X\n",b.dwPageType,b.dwPageId,b.dwNextPage,b.dwLogicalRoot,a.pPagesA[0]);

        //other pages
        DWORD i;
        for (i=0;i<a.dwNumPagesA;i++)
        {
            dprintf("        ---- %08x - %08x\n",i,a.pPagesA[i]);
            if (WMIREP_INVALID_PAGE != a.pPagesA[i] &&
                WMIREP_RESERVED_PAGE != a.pPagesA[i])
            {
                pStart = pBtr + (a.pPagesA[i]*PS_PAGE_SIZE);
                DumpPage((DWORD *)pStart );
            }
        }
    }
}

#define INDEX_FILE         _T("\\FS\\index.btr")
#define HEAP_FILE           _T("\\FS\\Objects.data")
#define FILE_MAP_1 _T("\\FS\\mapping1.map")
#define FILE_MAP_2 _T("\\FS\\mapping2.map")
#define FILE_MAP_VER   _T("\\FS\\mapping.ver")

#define REG_WBEM   _T("Software\\Microsoft\\WBEM\\CIMOM")
#define REG_DIR _T("Repository Directory")

HANDLE 
GetRepositoryFile(TCHAR * pFileName)
{
    HKEY hKey;
    LONG lRet;
    HANDLE hFile = INVALID_HANDLE_VALUE;    

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_WBEM,
                        NULL,
                        KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS == lRet)
    {
        TCHAR pPath[MAX_PATH];
        DWORD dwType;
        DWORD dwLen = MAX_PATH;
        lRet = RegQueryValueEx(hKey,
                               REG_DIR,
                               NULL,
                               &dwType,
                               (BYTE*)pPath,
                               &dwLen);
        if (ERROR_SUCCESS == lRet)
        {
            TCHAR pPath2[MAX_PATH];
            
            ExpandEnvironmentStrings(pPath,pPath2,MAX_PATH);
            lstrcat(pPath2,pFileName);

            hFile = CreateFile(pPath2,
                               GENERIC_READ,
                               FILE_SHARE_WRITE|FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                // this is the OK path
            }
            else
            {
                dprintf("CreateFile(%s) %d\n",pPath2,GetLastError());
            }
        }
        else
        {
            dprintf("unable to RegQueryValueEx: %d\n",GetLastError());
        }    
        RegCloseKey(hKey);
    }
    else
    {
        dprintf("unable to RegOpenKeyEx: %d\n",GetLastError());
    }    

    return hFile;
}

//
//  Dumps the .MAP file as a CPageFile
//
/////////////////////////////////////////////

DECLARE_API(fmap)
{
    INIT_API();
        
    HANDLE hFile;
    hFile = GetRepositoryFile(FILE_MAP_VER);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        DWORD dwWhichFile;
        DWORD nRead;
        if (ReadFile(hFile,&dwWhichFile,sizeof(DWORD),&nRead,NULL))
        {
            TCHAR * pFileName = (0 == dwWhichFile)?FILE_MAP_1:FILE_MAP_2;
            HANDLE hFileWithMaps = GetRepositoryFile(pFileName);
            if (INVALID_HANDLE_VALUE !=  hFileWithMaps)
            {
                Dump_Map(hFileWithMaps);
                CloseHandle(hFileWithMaps);
            }
            else
            {
                dprintf("GetRepositoryFile(%S) %d\n",pFileName,GetLastError());
            }
        }
        else
        {
            dprintf("ReadFile %d\n",GetLastError());
        }
        CloseHandle(hFile);
    }
    else
    {
        dprintf("GetRepositoryFile(%S) %d\n",FILE_MAP_VER,GetLastError());
    }
}

//
// Dump the Admin page of the objects.data
//
//////////////////////////////////////////

DECLARE_API(varobj)
{
    INIT_API();

    HANDLE hFileWhich = INVALID_HANDLE_VALUE; 
    HANDLE hFileMap = INVALID_HANDLE_VALUE; 
    HANDLE hFileObj = INVALID_HANDLE_VALUE;
    HANDLE hMappingMap = NULL;
    HANDLE hMappingObj = NULL;
    DWORD dwSizeMap = 0;
    DWORD dwSizeObj = 0;    
    BYTE * pMap;
    BYTE * pObj;    

    hFileWhich = GetRepositoryFile(FILE_MAP_VER);
    if (INVALID_HANDLE_VALUE == hFileWhich)
    {
        goto Cleanup;
    }

    DWORD dwWhichFile;
    DWORD nRead;
    if (FALSE == ReadFile(hFileWhich,&dwWhichFile,sizeof(DWORD),&nRead,NULL))
    {
        goto Cleanup;
    }
    TCHAR * pFileName = (0 == dwWhichFile)?FILE_MAP_1:FILE_MAP_2;
    
    hFileMap =    GetRepositoryFile(pFileName);    

    if (INVALID_HANDLE_VALUE == hFileMap)
    {
        goto Cleanup;
    }

    dwSizeMap = GetFileSize(hFileMap,NULL);
    hMappingMap = CreateFileMapping(hFileMap,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeMap,
                                    NULL);
    if (hFileMap)
    {
        pMap = (BYTE *)MapViewOfFile(hMappingMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hMappingMap) %d\n",GetLastError());
        goto Cleanup;
    };
            
    hFileObj = GetRepositoryFile(HEAP_FILE);
    if (INVALID_HANDLE_VALUE == hFileObj)
    {
        //dprintf("");        
        goto Cleanup;
    }

    dwSizeObj = GetFileSize(hFileObj,NULL);
    hMappingObj = CreateFileMapping(hFileObj,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeObj,
                                    NULL);
    if (hMappingObj)
    {
        pObj = (BYTE *)MapViewOfFile(hMappingObj,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hMappingObj) %d\n",GetLastError());
        goto Cleanup;
    };

    if (pMap && pObj)
    {
        Dump_AdminPage(pMap,pObj);
    }
    
Cleanup:
    if (pMap)
        UnmapViewOfFile(pMap);
    if (hMappingMap)
        CloseHandle(hMappingMap);
    if (INVALID_HANDLE_VALUE != hFileMap)
     CloseHandle(hFileMap);      
    if (pObj)
        UnmapViewOfFile(pObj);
    if (hMappingObj)
        CloseHandle(hMappingObj);
    if (INVALID_HANDLE_VALUE != hFileObj)
        CloseHandle(hFileObj);
    if (INVALID_HANDLE_VALUE != hFileWhich)
        CloseHandle(hFileWhich);
    
}


//
// Dump the Admin page of the btr
//
//////////////////////////////////////////

DECLARE_API(btr)
{
    INIT_API();

    HANDLE hFileWhich = INVALID_HANDLE_VALUE; 
    HANDLE hFileMap = INVALID_HANDLE_VALUE; 
    HANDLE hFileBtr = INVALID_HANDLE_VALUE;
    HANDLE hMappingMap = NULL;
    HANDLE hMappingBtr = NULL;
    DWORD dwSizeMap = 0;
    DWORD dwSizeBtr = 0;    
    BYTE * pMap;
    BYTE * pBtr;    
    
    hFileWhich = GetRepositoryFile(FILE_MAP_VER);
    if (INVALID_HANDLE_VALUE == hFileWhich)
    {
        goto Cleanup;
    }

    DWORD dwWhichFile;
    DWORD nRead;
    if (FALSE == ReadFile(hFileWhich,&dwWhichFile,sizeof(DWORD),&nRead,NULL))
    {
        goto Cleanup;
    }
    TCHAR * pFileName = (0 == dwWhichFile)?FILE_MAP_1:FILE_MAP_2;
    
    hFileMap =    GetRepositoryFile(pFileName);    
    
    dwSizeMap = GetFileSize(hFileMap,NULL);
    hMappingMap = CreateFileMapping(hFileMap,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeMap,
                                    NULL);
    if (hFileMap)
    {
        pMap = (BYTE *)MapViewOfFile(hMappingMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hMappingMap) %d\n",GetLastError());
        goto Cleanup;
    };
            
    hFileBtr = GetRepositoryFile(INDEX_FILE);
    if (INVALID_HANDLE_VALUE == hFileBtr)
    {
        //dprintf("");        
        goto Cleanup;
    }

    dwSizeBtr = GetFileSize(hFileBtr,NULL);
    hMappingBtr = CreateFileMapping(hFileBtr,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeBtr,
                                    NULL);
    if (hMappingBtr)
    {
        pBtr = (BYTE *)MapViewOfFile(hMappingBtr,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hMappingBtr) %d\n",GetLastError());
        goto Cleanup;
    };

    if (pMap && pBtr)
    {
        Dump_Index(pMap,pBtr);
    }
    
Cleanup:
    if (pMap)
        UnmapViewOfFile(pMap);
    if (hMappingMap)
        CloseHandle(hMappingMap);
    if (INVALID_HANDLE_VALUE != hFileMap)
     CloseHandle(hFileMap);      
    if (pBtr)
        UnmapViewOfFile(pBtr);
    if (hMappingBtr)
        CloseHandle(hMappingBtr);
    if (INVALID_HANDLE_VALUE != hFileBtr)
        CloseHandle(hFileBtr);
    if (INVALID_HANDLE_VALUE != hFileWhich)
        CloseHandle(hFileWhich);    
}



//
//
//  dumps the g_FileCache
//
//


/*
DWORD WINAPI 
CallBackWriteInst(VOID * pData1)
{
    DEFINE_CPP_VAR(CWriteFileInstruction,varCWriteFileInstruction);
    CWriteFileInstruction * pWriteInst = GET_CPP_VAR_PTR(CWriteFileInstruction,varCWriteFileInstruction);
    
    if (ReadMemory((ULONG_PTR)pData1,pWriteInst,sizeof(CWriteFileInstruction),NULL))
    {
        dprintf("      m_lStageOffset %p m_bCommitted %d\n",pWriteInst->m_lStageOffset,pWriteInst->m_bCommitted);
        dprintf("      m_dwLen %08x m_Location.m_nFileId %02x m_Location.m_lStartOffset %I64x\n",pWriteInst->m_dwLen,pWriteInst->m_Location.m_nFileId,pWriteInst->m_Location.m_lStartOffset);
        dprintf("      m_lZOrder %x m_bReuse %02x\n",pWriteInst->m_lZOrder,pWriteInst->m_bReuse);
    }
    return 0;
}

void DumpLongStage(ULONG_PTR Addr, // FileCache OOP pointer
                   CFileCache * pFileCache, // inproc pointer
                   ULONG_PTR Verbose) 
{
               //
               //  CAbstractSource
               //
            dprintf("    + CLongFileStagingFile %p\n",Addr+FIELD_OFFSET(CFileCache,m_AbstractSource)); 
               CAbstractFileSource * pAbsS = &pFileCache->m_AbstractSource;
            CLongFileStagingFile * pLongStage = &pAbsS->m_Stage;
            CLongFileStagingFile * pLongStag_OOP = (CLongFileStagingFile *)(Addr + FIELD_OFFSET(CFileCache,m_AbstractSource) + FIELD_OFFSET(CAbstractFileSource,m_Stage));
            
               // CStageMgr members
               dprintf("        m_hFile %x m_hFlushFile %x\n",pLongStage->m_hFile,pLongStage->m_hFlushFile);
            //long m_lFirstFreeOffset;

            //CCritSec m_cs;
            dprintf("        m_qToWrite\n");
            _List * pList_OOP = (_List *)((BYTE *)pLongStag_OOP + FIELD_OFFSET(CLongFileStagingFile,m_qToWrite));
            PrintListCB(pList_OOP,CallBackWriteInst);
            
            dprintf("        m_stReplacedInstructions\n");
            pList_OOP = (_List *)((BYTE *)pLongStag_OOP + FIELD_OFFSET(CLongFileStagingFile,m_stReplacedInstructions));
            PrintListCB(pList_OOP,NULL);
            
            dprintf("        m_qTransaction\n");
            pList_OOP = (_List *)((BYTE *)pLongStag_OOP + FIELD_OFFSET(CLongFileStagingFile,m_qTransaction));
            PrintListCB(pList_OOP,CallBackWriteInst);

            
            dprintf("        TransIdx %I64d m_lTransactionStartOffset %x\n",pLongStage->m_nTransactionIndex,pLongStage->m_lTransactionStartOffset);
            //BYTE m_TransactionHash[16];
            dprintf("        bInTransaction %d bFailedBefore %d lStatus %d\n",pLongStage->m_bInTransaction,pLongStage->m_bFailedBefore,pLongStage->m_lStatus);
            //pStage->m_lMaxFileSize;
            //pStage->m_lAbortTransactionFileSize;
            // bool m_bMustFail;
            // bool m_bNonEmptyTransaction;

        if (Verbose)
        {
            // the multimap has the compare function
            _Map * pMapStarts = (_Map *)((BYTE*)pLongStag_OOP + sizeof(void *) + FIELD_OFFSET(CLongFileStagingFile,m_mapStarts));
            dprintf("          m_mapStarts\n");
            dprintf("          std::multimap< { CFileLocation::m_nFileId, CFileLocation::m_lStartOffset }, CWriteFileInstruction* >\n");
            PrintMapCB(pMapStarts,TRUE,NULL);
                    
            _Map * pMapEnds = (_Map *)((BYTE*)pLongStag_OOP + sizeof(void *) + FIELD_OFFSET(CLongFileStagingFile,m_mapEnds));
            dprintf("          m_mapEnds\n");                    
            dprintf("          std::multimap< { CFileLocation::m_nFileId, CFileLocation::m_lStartOffset }, CWriteFileInstruction* >\n");
            PrintMapCB(pMapEnds,TRUE,NULL);
        }
}

DECLARE_API( stage )
{
    INIT_API();

    ULONG_PTR Addr = 0;
    
    ULONG_PTR Verbose = GetExpression(args);
    
    Addr = GetExpression("repdrvfs!g_Glob");
    if (Addr)
    {
        Addr += FIELD_OFFSET(CGlobals,m_FileCache);
    }
     
    if (Addr) 
    {
        DEFINE_CPP_VAR(CFileCache,varCFileCache);
        CFileCache * pFileCache = GET_CPP_VAR_PTR(CFileCache,varCFileCache);

        dprintf("CFileCache @ %p\n",Addr);

        if (ReadMemory((ULONG_PTR)Addr,pFileCache,sizeof(CFileCache),0))
        {
            DumpLongStage(Addr,pFileCache,Verbose);
        }
        else
        {
            dprintf("RM %p\n",Addr);
        }
    }
    else
    {
        dprintf("unable to resolve repdrvfs!g_Glob\n");
    }
    
}

*/

/*
DECLARE_API( filec_old )
{

    INIT_API();

    ULONG_PTR Addr = 0;
    
    if (0 != strlen(args))
    {
        Addr = GetExpression(args);
    }
    else
    {
        Addr = GetExpression("repdrvfs!g_Glob");
        if (Addr)
        {
            Addr += FIELD_OFFSET(CGlobals,m_FileCache);
        }
    }
    
    if (Addr) 
    {
        DEFINE_CPP_VAR(CFileCache,varCFileCache);
        CFileCache * pFileCache = GET_CPP_VAR_PTR(CFileCache,varCFileCache);

        dprintf("CFileCache @ %p\n",Addr);

        if (ReadMemory((ULONG_PTR)Addr,pFileCache,sizeof(CFileCache),0))
        {
            dprintf("    m_lRef %d\n",pFileCache->m_lRef);

            DumpLongStage(Addr,pFileCache,TRUE);
                    
            //
            //  CObjectHeap
            //
            dprintf("    + CObjectHeap %p\n",Addr+FIELD_OFFSET(CFileCache,m_ObjectHeap));
            CObjectHeap * pObjectHeap_OOP = (CObjectHeap *)(Addr+FIELD_OFFSET(CFileCache,m_ObjectHeap));
            
            DEFINE_CPP_VAR(CFileHeap,varCFileHeap);
            CFileHeap * pFileHeap = GET_CPP_VAR_PTR(CFileHeap,varCFileHeap);

            CFileHeap * pFileHeap_OOP = (CFileHeap *)((ULONG_PTR)pObjectHeap_OOP+FIELD_OFFSET(CObjectHeap,m_Heap));
            dprintf("    +++ CFileHeap %p\n",pFileHeap_OOP);

            if (ReadMemory((ULONG_PTR)pFileHeap_OOP,pFileHeap,sizeof(CFileHeap),NULL))
            {

                DEFINE_CPP_VAR(CAbstractFile,varCAbstractFile);
                CAbstractFile * pAbstract = GET_CPP_VAR_PTR(CAbstractFile,varCAbstractFile);
            
                dprintf("        m_pMainFile    %p\n",pFileHeap->m_pMainFile);                
                ReadMemory((ULONG_PTR)pFileHeap->m_pMainFile,pAbstract,sizeof(CAbstractFile),NULL);
                dprintf("          m_pStage %p m_nId %d\n",pAbstract->m_pStage,pAbstract->m_nId);                
                
                dprintf("        m_pFreeFile    %p\n",pFileHeap->m_pFreeFile);
                ReadMemory((ULONG_PTR)pFileHeap->m_pFreeFile,pAbstract,sizeof(CAbstractFile),NULL);
                dprintf("          m_pStage %p m_nId %d\n",pAbstract->m_pStage,pAbstract->m_nId);
               
                dprintf("        m_mapFree\n");
                dprintf("        std::map< DWORD , { CRecordInfo::m_dwIndex, CRecordInfo::m_nOffset } >\n");
                _Map * pMapFree = (_Map *)((BYTE *)pFileCache->m_ObjectHeap.m_pHeap+FIELD_OFFSET(CFileHeap,m_mapFree));
                PrintMapCB(pMapFree,TRUE,NULL);

                dprintf("        m_mapFreeOffset\n");
                dprintf("        std::map< TOffset , DWORD >\n");
                _Map * pMapOffset = (_Map *)((BYTE *)pFileCache->m_ObjectHeap.m_pHeap+FIELD_OFFSET(CFileHeap,m_mapFreeOffset));
                PrintMapCB(pMapOffset,TRUE,NULL);
            }
            else
            {
                dprintf("RM %p %d\n",Addr,GetLastError());
            }

            CBtrIndex * pBtrIndex_OOP = (CBtrIndex *)((ULONG_PTR)pObjectHeap_OOP+FIELD_OFFSET(CObjectHeap,m_Index));
            dprintf("    +++ CBtrIndex %p\n",pBtrIndex_OOP);
            
        }
        else
        {
            dprintf("RM %p %d\n",Addr,GetLastError());
        }
    }
    else
    {
        dprintf("cannot resolve repdrvfs!g_Glob\n");
    }
}
*/

/*
    long m_lRef;
    BOOL m_bInit;
    CPageSource m_TransactionManager;
    CObjectHeap m_ObjectHeap;
*/

void
Print_CPageCache(ULONG_PTR pPageCache_OOP)
{
    DEFINE_CPP_VAR(CPageCache,varCPageCache);
    CPageCache * pPageCache = GET_CPP_VAR_PTR(CPageCache,varCPageCache);    

    dprintf("                + CPageCache @ %p\n",pPageCache_OOP);
    
    if (ReadMemory(pPageCache_OOP,pPageCache,sizeof(CPageCache),NULL))
    {
/*
    DWORD   m_dwStatus;

    DWORD   m_dwPageSize;
    DWORD   m_dwCacheSize;

    DWORD   m_dwCachePromoteThreshold;
    DWORD   m_dwCacheSpillRatio;

    DWORD   m_dwLastFlushTime;
    DWORD   m_dwWritesSinceFlush;
    DWORD   m_dwLastCacheAccess;
    DWORD   m_dwReadHits;
    DWORD   m_dwReadMisses;
    DWORD   m_dwWriteHits;
    DWORD   m_dwWriteMisses;

    HANDLE  m_hFile;

    std::vector <SCachePage *, wbem_allocator<SCachePage *> > m_aCache;
*/
//        dprintf("                m_dwStatus       %08x\n",pPageCache->m_dwStatus);
        dprintf("                m_dwPageSize   %08x\n",pPageCache->m_dwPageSize);
        dprintf("                m_dwCacheSize %08x\n",pPageCache->m_dwCacheSize);
        dprintf("                m_hFile %p\n",pPageCache->m_hFile);

        _Vector * pVector;
        ULONG_PTR Size;
        SCachePage ** ppSCachePage;

        pVector = (_Vector *)&pPageCache->m_aCache;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(SCachePage *);
        dprintf("                m_aCache - S %x - P %p\n",Size,pVector->_First);
        ppSCachePage = new SCachePage *[Size];
        if(ppSCachePage)
        {
            if (ReadMemory((ULONG_PTR)pVector->_First,ppSCachePage,sizeof(SCachePage *)*Size,NULL))
            {
                for (ULONG_PTR i=0;i<Size;i++)
                {
                    //dprintf("                - %p - %d\n",ppSCachePage[i],i);
                    
                    DEFINE_CPP_VAR(SCachePage,varSCachePage);
                    SCachePage * pSCachePage = GET_CPP_VAR_PTR(SCachePage,varSCachePage);

                    if (ReadMemory((ULONG_PTR)ppSCachePage[i],pSCachePage,sizeof(SCachePage),NULL))
                    {
                        dprintf("                  D %d %08x - %p\n",pSCachePage->m_bDirty,pSCachePage->m_dwPhysId,pSCachePage->m_pPage);
                    }
                };
            }
            delete [] ppSCachePage;
        };
        
    }
    else
    {
        dprintf("RM %p\n",pPageCache_OOP);
    }    
};

void
Print_CPageFile(ULONG_PTR pPageFile_OOP, BOOL bVerbose)
{
    DEFINE_CPP_VAR(CPageFile,varCPageFile);
    CPageFile * pPageFile = GET_CPP_VAR_PTR(CPageFile,varCPageFile);    

    dprintf("        + CPageFile @ %p\n",pPageFile_OOP);
    
    if (ReadMemory(pPageFile_OOP,pPageFile,sizeof(CPageFile),NULL))
    {
/*
    LONG              m_lRef;
    DWORD             m_dwStatus;
    DWORD             m_dwPageSize;

    CRITICAL_SECTION  m_cs;

    WString      m_sDirectory;
    WString      m_sMapFile;
    WString      m_sMainFile;

    CPageCache       *m_pCache;
    BOOL              m_bInTransaction;
    DWORD             m_dwLastCheckpoint;
    DWORD             m_dwTransVersion;

    // Generation A Mapping
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPageMapA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPhysFreeListA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aLogicalFreeListA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aReplacedPagesA;
    DWORD m_dwPhysPagesA;

    // Generation B Mapping
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPageMapB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPhysFreeListB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aLogicalFreeListB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aReplacedPagesB;
    DWORD m_dwPhysPagesB;
*/

        dprintf("            m_lRef       %08x\n",pPageFile->m_lRef);
//        dprintf("            m_dwStatus   %08x\n",pPageFile->m_dwStatus);
        dprintf("            m_dwPageSize %08x\n",pPageFile->m_dwPageSize);

//        dprintf("            m_pCache           %p\n",pPageFile->m_pCache);
//        Print_CPageCache((ULONG_PTR)pPageFile->m_pCache);
        dprintf("            m_bInTransaction   %08x\n",pPageFile->m_bInTransaction);
        dprintf("            m_dwLastCheckpoint %08x\n",pPageFile->m_dwLastCheckpoint);
        dprintf("            m_dwTransVersion   %08x\n",pPageFile->m_dwTransVersion);

        _Vector * pVector;
        ULONG_PTR Size;
        DWORD * pDW;

        pVector = (_Vector *)&pPageFile->m_aPageMapA;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aPageMapA         - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
            pDW = new DWORD[Size];
            if(pDW)
            {
                if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
                {
                    PrintDWORDS(pDW,Size);
                }
                delete [] pDW;
            };
        }
        
        pVector = (_Vector *)&pPageFile->m_aPhysFreeListA;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aPhysFreeListA    - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {
            pDW = new DWORD[Size];
            if(pDW)
            {
                if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
                {
                    PrintDWORDS(pDW,Size);
                }
                delete [] pDW;
            };
        };
        
        pVector = (_Vector *)&pPageFile->m_aLogicalFreeListA;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aLogicalFreeListA - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {
         pDW = new DWORD[Size];
         if(pDW)
         {
             if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
             {
                 PrintDWORDS(pDW,Size);
             }
             delete [] pDW;
         };
        }

        pVector = (_Vector *)&pPageFile->m_aReplacedPagesA;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aReplacedPagesA   - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
            pDW = new DWORD[Size];
            if(pDW)
            {
                if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
                {
                    PrintDWORDS(pDW,Size);
                }
                delete [] pDW;
            };
        }
        
        dprintf("            m_dwPhysPagesA     %08x\n",pPageFile->m_dwPhysPagesA);

        pVector = (_Vector *)&pPageFile->m_aPageMapB;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aPageMapB         - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
            pDW = new DWORD[Size];
            if(pDW)
            {
                if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
                {
                    PrintDWORDS(pDW,Size);
                }
                delete [] pDW;
            };
        }
        
        pVector = (_Vector *)&pPageFile->m_aPhysFreeListB;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aPhysFreeListB    - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
            pDW = new DWORD[Size];
            if(pDW)
            {
                if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
                {
                    PrintDWORDS(pDW,Size);
                }
                delete [] pDW;
            };
        }
        
        pVector = (_Vector *)&pPageFile->m_aLogicalFreeListB;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aLogicalFreeListB - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
            pDW = new DWORD[Size];
            if(pDW)
            {
                if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
                {
                    PrintDWORDS(pDW,Size);
                }
                delete [] pDW;
            };
        }

        pVector = (_Vector *)&pPageFile->m_aReplacedPagesB;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aReplacedPagesB   - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
            pDW = new DWORD[Size];
            if(pDW)
            {
                if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
                {
                    PrintDWORDS(pDW,Size);
                }
                delete [] pDW;
            };
        }
        
        dprintf("            m_dwPhysPagesB     %08x\n",pPageFile->m_dwPhysPagesB);

    }
    else
    {
        dprintf("RM %p\n",pPageFile_OOP);
    }
}

DECLARE_API( filec )
{

    INIT_API();

    ULONG_PTR Addr = 0;
    
    if (0 != strlen(args))
    {
        Addr = GetExpression(args);
    }
    else
    {
        Addr = GetExpression("repdrvfs!g_Glob");
        if (Addr)
        {
            Addr += FIELD_OFFSET(CGlobals,m_FileCache);
        }
    }
    
    if (Addr) 
    {
        DEFINE_CPP_VAR(CFileCache,varCFileCache);
        CFileCache * pFileCache = GET_CPP_VAR_PTR(CFileCache,varCFileCache);

        dprintf("CFileCache @ %p\n",Addr);

        if (ReadMemory((ULONG_PTR)Addr,pFileCache,sizeof(CFileCache),0))
        {
            dprintf("    m_lRef %d m_bInit %d\n",pFileCache->m_lRef,pFileCache->m_bInit);

            //
            // CPageSource
            //
            dprintf("    + CPageSource %p\n",Addr+FIELD_OFFSET(CFileCache,m_TransactionManager));
            CPageSource * pPageSource_OOP = (CPageSource *)(Addr+FIELD_OFFSET(CFileCache,m_TransactionManager)); 

            CPageSource * pPageSource = (CPageSource *)((BYTE *)pFileCache+FIELD_OFFSET(CFileCache,m_TransactionManager));

            //dprintf();
            dprintf("        m_dwStatus          %08x\n",pPageSource->m_dwStatus);            
            dprintf("        m_dwPageSize        %08x\n",pPageSource->m_dwPageSize);
            dprintf("        m_dwCacheSize       %08x\n",pPageSource->m_dwCacheSize);
            dprintf("        m_dwCacheSpillRatio %08x\n",pPageSource->m_dwCacheSpillRatio);            
            dprintf("        m_dwLastCheckpoint  %08x\n",pPageSource->m_dwLastCheckpoint);
            
//            dprintf("        m_dwCheckpointInterval %08x\n",pPageSource->m_dwCheckpointInterval);
            //    WString m_sDirectory;
            //    WString m_sBTreeMap;
            //    WString m_sObjMap;
            // CPageFile *
            dprintf("        m_BTreePF\n");
            Print_CPageFile((ULONG_PTR)pPageSource_OOP+FIELD_OFFSET(CPageSource,m_BTreePF),FALSE);

            dprintf("        m_ObjPF\n");
            Print_CPageFile((ULONG_PTR)pPageSource_OOP+FIELD_OFFSET(CPageSource,m_ObjPF),FALSE);

            dprintf("        m_hFileMap1         %x\n",pPageSource->m_hFileMap1);
            dprintf("        m_hFileMap2         %x\n",pPageSource->m_hFileMap2);            
            dprintf("        m_hFileMapVer       %x\n",pPageSource->m_hFileMapVer);
            dprintf("        m_dwFileMapVer      %08x\n",pPageSource->m_dwFileMapVer);  
                  
            //
            //  CObjectHeap
            //
            dprintf("    + CObjectHeap %p\n",Addr+FIELD_OFFSET(CFileCache,m_ObjectHeap));
            CObjectHeap * pObjectHeap_OOP = (CObjectHeap *)(Addr+FIELD_OFFSET(CFileCache,m_ObjectHeap));
            
            DEFINE_CPP_VAR(CVarObjHeap,varCVarObjHeap);
            CVarObjHeap * pVarObjHeap = GET_CPP_VAR_PTR(CVarObjHeap,varCVarObjHeap);

            CVarObjHeap * pVarObjHeap_OOP = (CVarObjHeap *)((ULONG_PTR)pObjectHeap_OOP+FIELD_OFFSET(CObjectHeap,m_Heap));
            dprintf("    +++ CVarObjHeap %p\n",pVarObjHeap_OOP);

            if (ReadMemory((ULONG_PTR)pVarObjHeap_OOP,pVarObjHeap,sizeof(CVarObjHeap),NULL))
            {
                // this pagefile is the same as CPageSource::m_pObjPF
                VarObjAdminPageEntry ** ppEntries = (VarObjAdminPageEntry **)_alloca(sizeof(VarObjAdminPageEntry *)*pVarObjHeap->m_aAdminPages.m_nSize);
              
                if (ReadMemory((ULONG_PTR)pVarObjHeap->m_aAdminPages.m_pArray,ppEntries,sizeof(VarObjAdminPageEntry *)*pVarObjHeap->m_aAdminPages.m_nSize,NULL))
                {
                    dprintf("        admin pages\n");
                    for(DWORD i=0;i<pVarObjHeap->m_aAdminPages.m_nSize;i++)
                    {
                        //VarObjAdminPageEntry
                        //dprintf("        - %x P %p\n",i,ppEntries[i]);
                        VarObjAdminPageEntry Entry;
                        if (ReadMemory((ULONG_PTR)ppEntries[i],&Entry,sizeof(Entry),NULL))
                        {
                            dprintf("        %08x %p %d\n",Entry.dwPageId,Entry.pbPage,Entry.bDirty);
                        }
                        else
                        {
                            dprintf("RM %p\n",ppEntries[i]);
                        }
                    }
                }
                else
                {
                    dprintf("RM %p\n",pVarObjHeap->m_aAdminPages.m_pArray);
                }
            }
            else
            {
                dprintf("RM %p %d\n",pVarObjHeap_OOP,GetLastError());
            }

            DEFINE_CPP_VAR(CBtrIndex,varCBtrIndex);
            CBtrIndex * pBtrIndex = GET_CPP_VAR_PTR(CBtrIndex,varCBtrIndex);

            CBtrIndex * pBtrIndex_OOP = (CBtrIndex *)((ULONG_PTR)pObjectHeap_OOP+FIELD_OFFSET(CObjectHeap,m_Index));
            dprintf("    +++ CBtrIndex %p\n",pBtrIndex_OOP);

            if (ReadMemory((ULONG_PTR)pBtrIndex_OOP,pBtrIndex,sizeof(CBtrIndex),NULL))
            {
            }
            else
            {
                dprintf("RM %p %d\n",pBtrIndex_OOP,GetLastError());
            }
            
        }
        else
        {
            dprintf("RM %p %d\n",Addr,GetLastError());
        }
    }
    else
    {
        dprintf("cannot resolve repdrvfs!g_Glob\n");
    }
}


DWORD
Dump_CClassRecord(void * pKey,void * pData)
{

    //dprintf("Dump_CClassRecord\n");

    DEFINE_CPP_VAR(CClassRecord,MyClassRecord);
    CClassRecord * pClassRecord = GET_CPP_VAR_PTR(CClassRecord,MyClassRecord);

    if (pData)
    {
        ReadMemory((ULONG_PTR)pData,pClassRecord,sizeof(CClassRecord),NULL);
        WCHAR pName[MAX_PATH];
        ReadMemory((ULONG_PTR)pClassRecord->m_wszClassName,pName,MAX_PATH,NULL);
        pName[MAX_PATH-1]=0;
        dprintf("    %p - %S\n",pClassRecord->m_pClassDef,pName);
    }
    return 0;
}

DWORD
Dump_CHierarchyCacheMap(void * pKey,void * pData)
{
    //dprintf("Dump_CHierarchyCacheMap\n");
    DEFINE_CPP_VAR(CHierarchyCache,MyHierarchyCache);
    CHierarchyCache * pHieCache = GET_CPP_VAR_PTR(CHierarchyCache,MyHierarchyCache);

    if (pKey)
    {
        WCHAR pString[MAX_PATH+1];
        pString[MAX_PATH]=0;
        if (ReadMemory((MEMORY_ADDRESS)pKey,pString,MAX_PATH*sizeof(WCHAR),NULL))
        {
            dprintf("    - %S\n",pString);
        }
    }
    if (pData)
    {
        DWORD Num;
        PrintMapCB((_Map *)((ULONG_PTR)pData+FIELD_OFFSET(CHierarchyCache,m_map)),TRUE,Dump_CClassRecord);
    }

    return 0;
};

//
//
//  dumps the Forest Cache
//
//


DECLARE_API( forestc )
{
    INIT_API();
    ULONG_PTR Addr = 0;
    
    if (0 != strlen(args))
    {
        Addr = GetExpression(args);
    }
    else
    {
        Addr = GetExpression("repdrvfs!g_Glob");
        if (Addr)
        {
            Addr += FIELD_OFFSET(CGlobals,m_ForestCache);
        }       
    }
        
    if (Addr) 
    {
        CForestCache * pForestCache_OOP = (CForestCache *)Addr;

        if (pForestCache_OOP)
        {
            dprintf("CForestCache @ %p\n",pForestCache_OOP);
            
            DEFINE_CPP_VAR(CForestCache,varCForestCache);
            CForestCache * pForestCache = GET_CPP_VAR_PTR(CForestCache,varCForestCache);
            ReadMemory((ULONG_PTR)pForestCache_OOP,pForestCache,sizeof(CForestCache),0);


            
            DWORD Num;
            PrintMapCB((_Map *)((ULONG_PTR)pForestCache_OOP+FIELD_OFFSET(CForestCache,m_map)),TRUE,Dump_CHierarchyCacheMap);

            dprintf(" CClassRecord list\n");

            CClassRecord * pCRec = pForestCache->m_pMostRecentlyUsed;
            Num = 0;
            while(pCRec)
            {
                DEFINE_CPP_VAR(CClassRecord,CRec);
                
                ReadMemory((ULONG_PTR)pCRec,&CRec,sizeof(CClassRecord),0);
                pCRec = ((CClassRecord *)&CRec)->m_pLessRecentlyUsed;
                dprintf("    %d - %p\n",Num,pCRec);
                Num++;
                if (CheckControlC())
                    break;
            };
            dprintf("    T %d CClassRecord\n",Num);
            
        }
        
    } else {
        dprintf(" unable to resolve repdrvfs!g_Glob\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\threadutil.cpp ===
#include <wmiexts.h>
#include <utilfun.h>
#include <malloc.h>
#include <Sddl.h>


void GetTeb(HANDLE hThread,TEB ** ppTeb)
{
	NTSTATUS Status;
	ULONG Long;
	THREAD_BASIC_INFORMATION TBasicInfo;
	Status = NtQueryInformationThread(hThread,
	                                  ThreadBasicInformation,
	                                  &TBasicInfo,
	                                  sizeof(TBasicInfo),
	                                  &Long);
	                                      
	if ( Status == 0 )
	{
	    //dprintf("        %p %x.%x\n",TBasicInfo.TebBaseAddress,TBasicInfo.ClientId.UniqueProcess,TBasicInfo.ClientId.UniqueThread);
	    if (ppTeb)
	    {
	        *ppTeb = TBasicInfo.TebBaseAddress;
	    }
	}
	else
	{
	   dprintf("    NtQueryInformationThread %08x\n",Status);
	}
}

void GetCid(HANDLE hThread,CLIENT_ID * pCid)
{
	NTSTATUS Status;
	ULONG Long;
	THREAD_BASIC_INFORMATION TBasicInfo;
	Status = NtQueryInformationThread(hThread,
	                                  ThreadBasicInformation,
	                                  &TBasicInfo,
	                                  sizeof(TBasicInfo),
	                                  &Long);
	                                      
	if ( Status == 0 )
	{
	    //dprintf("        %p %x.%x\n",TBasicInfo.TebBaseAddress,TBasicInfo.ClientId.UniqueProcess,TBasicInfo.ClientId.UniqueThread);
	    if (pCid)
	    {
	        memcpy(pCid,&TBasicInfo.ClientId, sizeof(CLIENT_ID));
	    }
	}
	else
	{
	   dprintf("    NtQueryInformationThread %08x\n",Status);
	}
}

void GetPeb(HANDLE hSourceProcess, PEB ** ppPeb, ULONG_PTR * pId)
{
    NTSTATUS Status;
    ULONG Long;
    PROCESS_BASIC_INFORMATION PBasicInfo;
    Status = NtQueryInformationProcess(hSourceProcess,
	                                  ProcessBasicInformation,
	                                  &PBasicInfo,
	                                  sizeof(PBasicInfo),
	                                  &Long);
	                                      
    if ( Status == 0 )
    {
        if (ppPeb)
        {
            *ppPeb = PBasicInfo.PebBaseAddress;
        }
        if (pId)
        {
            *pId = PBasicInfo.UniqueProcessId;
        }
    }
    else
    {
       dprintf("    NTSTATUS %08x\n",Status);
    }
 }

//
void PrintHandleBackTrace(HANDLE hHandle,WCHAR * pFileName)
{
    WCHAR pPath[MAX_PATH+1];
    GetEnvironmentVariableW(L"windir",pPath,MAX_PATH);
    lstrcatW(pPath,L"\\system32\\");
    lstrcatW(pPath,pFileName);
    
    HANDLE hFile = NULL; 
    hFile = CreateFileW(pPath,
                       GENERIC_READ,
                       FILE_SHARE_READ|FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,NULL);
                       
    if (INVALID_HANDLE_VALUE != hFile)
    {
	    DWORD dwSize = GetFileSize(hFile,NULL);
    	HANDLE hFileMap = CreateFileMapping(hFile,
                                            NULL,
                                            PAGE_READONLY,
                                            0,
                                            dwSize,
                                            NULL);
        if (hFileMap)
        {
       		HANDLE * pHandle = (HANDLE *)MapViewOfFile(hFileMap,
                                        FILE_MAP_READ,
                                        0,0,0);
            
            if(pHandle)
            {
                //dprintf("hEvent %p dwSize %x\n",hEvent,dwSize);
                DWORD SizeRecord = 8*sizeof(HANDLE);
                DWORD nRecord = dwSize/SizeRecord;
                HANDLE * pThisHandle = NULL;
                DWORD i;

                if (hHandle)
                {
	                for(i=0;i<nRecord;i++)
	                {
	                    if (hHandle == pHandle[(SizeRecord/sizeof(HANDLE))*(nRecord-1-i)])
	                    {
	                        pThisHandle = &pHandle[(SizeRecord/sizeof(HANDLE))*(nRecord-1-i)];
	                        break;
	                    }
	                    else
	                    {
	                        //dprintf(" %d %p\n",nRecord-1-i,pHandle[(SizeRecord/sizeof(HANDLE))*(nRecord-1-i)]);
	                    }
	                }
	                if(pThisHandle)
	                {
	                    dprintf(" found rec %x handle %p\n",nRecord-1-i,*pThisHandle);
	                    PrintStackTrace((ULONG_PTR)pThisHandle+sizeof(HANDLE),7,FALSE);
	                }
	                else
	                {
	                    dprintf("handle %x not found\n",hHandle);
	                }
                }
                else // print all of them
                {
                    dprintf("all records\n");
	                for(i=0;i<nRecord;i++)
	                {
		                pThisHandle = &pHandle[(SizeRecord/sizeof(HANDLE))*(nRecord-1-i)];
		                dprintf(" ------ %p\n",*pThisHandle);
   	                    PrintStackTrace((ULONG_PTR)pThisHandle+sizeof(HANDLE),7,FALSE);
   	                    
   	                    if (CheckControlC())
   	                        break;
                    }                    
                }
                UnmapViewOfFile(pHandle);
            }
            else
            {
	            dprintf("MapViewOfFile %d\n",GetLastError());
            }
            CloseHandle(hFileMap);
        }
        else
        {
	        dprintf("CreateFileMapping %d\n",GetLastError());
        };
        
        CloseHandle(hFile);
    }
    else
    {
        dprintf("CreateFile %S %d\n",pPath,GetLastError());
    }

}

//

DECLARE_API( refcnt )
{
    INIT_API();
    PrintHandleBackTrace(NULL,L"refcount.dat");
}

//

DECLARE_API( evtst )
{
    INIT_API();

    MEMORY_ADDRESS Addr = GetExpression(args);
    HANDLE hEvent = (HANDLE)Addr;

    if (hEvent)
    {
        PrintHandleBackTrace(hEvent,L"events.dat");
    }
}

#define INCREMENT_ALLOC (4*1024)

char * g_HandleType[] = 
{
    "",
    "",
    "",
    "",
    "Token", // 4
    "Process", // 5
    "Thread", //6
    "",
    "",
    "Event", // 9
    "",
    "Mutant", // 11
    "",
    "Semaphore", // 13
    "",
    "", // 15
    "", 
    "",
    "",
    "",
    "Key", // 20
    "Port", //21 
    "WaitablePort", // 22
    "",
    "",
    "", 
    "",
    "",
    "File", // 28
    "WmiGuid", // 29
    "",
    "",
    "",
    "", 
    "",
    "",
    ""
};

DECLARE_API( tokens )
{
    INIT_API();

    if (g_KD)
    {
        dprintf("user-mode support only\n");
        return;
    }    

    NTSTATUS Status;
    SYSTEM_HANDLE_INFORMATION * pSysHandleInfo = NULL;
    DWORD dwSize = INCREMENT_ALLOC;
    DWORD nReturned;

    ULONG_PTR lProcId;
    GetPeb(hCurrentProcess,NULL,&lProcId);
    USHORT ProcId = (USHORT)lProcId;


alloc_again:

    pSysHandleInfo = (SYSTEM_HANDLE_INFORMATION *)HeapAlloc(GetProcessHeap(),0,dwSize);

    if (pSysHandleInfo)
    {
        Status = NtQuerySystemInformation(SystemHandleInformation,
                                          pSysHandleInfo,
                                          dwSize,
                                          &nReturned);
    }
    else
    {
         goto leave;
    }

    if (STATUS_INFO_LENGTH_MISMATCH == Status)
    {
        HeapFree(GetProcessHeap(),0,pSysHandleInfo);
        dwSize += INCREMENT_ALLOC;
        goto alloc_again;
    }
    else if (0 == Status)
    {
        // we have all the handles
        // SYSTEM_HANDLE_TABLE_ENTRY_INFO

        for (DWORD i=0; i < pSysHandleInfo->NumberOfHandles; i++)
        {
            if (ProcId == pSysHandleInfo->Handles[i].UniqueProcessId)
            {
                //dprintf("handle: %x type %x\n",
               	//     pSysHandleInfo->Handles[i].HandleValue,
                //	 pSysHandleInfo->Handles[i].ObjectTypeIndex);
                if (4 == pSysHandleInfo->Handles[i].ObjectTypeIndex) 
                {
                    HANDLE hToken;
                    if (DuplicateHandle(hCurrentProcess,
                    	            (HANDLE)pSysHandleInfo->Handles[i].HandleValue,
                    	            GetCurrentProcess(),
                    	            &hToken,
                    	            TOKEN_QUERY,FALSE,0)) //TOKEN_QUERY 
                    {
                        dprintf("Token: %x\n",pSysHandleInfo->Handles[i].HandleValue);
                        struct Info : public _TOKEN_USER 
                        {
                            BYTE m_[SECURITY_MAX_SID_SIZE];
                        } Token_User_;
                        DWORD dwLen = sizeof(Token_User_);
                        if (GetTokenInformation(hToken,
                        	                TokenUser,
                        	                &Token_User_,
                        	                dwLen,
                        	                &dwLen))
                        {
                            LPTSTR pSidString;
                            if (ConvertSidToStringSid(Token_User_.User.Sid,&pSidString))
                            {
                                dprintf("    Sid  : %s\n",pSidString);
                                LocalFree(pSidString);
                            }
                        }
                        else
                        {
                            dprintf("    Sid  : err %d\n",GetLastError());
                        }
                        TOKEN_TYPE TokenType_;
                        dwLen = sizeof(TokenType_); 
                        if (GetTokenInformation(hToken,
                        	                 TokenType,
                        	                 &TokenType_,
                        	                 dwLen,
                        	                &dwLen))
                        {
                            dprintf("    Type : %d\n",TokenType_);
                        }
                        else
                        {
                            dprintf("    Type : err %d\n",GetLastError());
                        }                         
                        SECURITY_IMPERSONATION_LEVEL ImpLevel;
                        dwLen = sizeof(ImpLevel);                        
                        if (GetTokenInformation(hToken,
                        	                 TokenImpersonationLevel,
                        	                 &ImpLevel,
                        	                 dwLen,
                        	                &dwLen))
                        {
                            dprintf("    Level: %d\n",ImpLevel);
                        }
                        else
                        {
                            dprintf("    Level: <UNDEFINED>\n",GetLastError());
                        }     
                        CloseHandle(hToken);
                    }
                    else
                    {
                        dprintf("DuplicateHandle %x err %d\n",pSysHandleInfo->Handles[i].HandleValue,GetLastError());
                    }
                }
            }
            if (CheckControlC())
                break;
        }
    }
    else
    {
        dprintf("");
    }

leave:   
    if (pSysHandleInfo)
    {
        HeapFree(GetProcessHeap(),0,pSysHandleInfo);
    }
    return;
}

//
//
// Invoke a function in the remote process
//
//////////////////////////////////////////

DECLARE_API( inv )
{
    INIT_API();

    int Len = strlen(args);
    CHAR * pArgs = (CHAR *)_alloca((Len+1));
    lstrcpy(pArgs,(CHAR *)args);
    
    MEMORY_ADDRESS pFunction = 0;
    MEMORY_ADDRESS pArgument = 0;
    
    while (isspace(*pArgs))
    {
        pArgs++;
    }
     
    CHAR * pSaved = pArgs;
    
    while(!isspace(*pArgs)) pArgs++;
    // terminate string, if possible    
    if (isspace(*pArgs))
    {
        *pArgs = 0;
        pArgs++;
    }
    else
    {
        pArgs = NULL;
    }

    pFunction = GetExpression(pSaved);

    if (pArgs)
    {
        pArgument = GetExpression(pArgs);
    }

    dprintf("invoking %s(%p) @ %p\n",pSaved,pArgument,pFunction);

    DWORD dwID;
    HANDLE hThread = CreateRemoteThread(hCurrentProcess,
                                        NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE )pFunction,
                                        (LPVOID)pArgument,
                                        0,
                                        &dwID);
    if (hThread)
    {
        CLIENT_ID Cid;
        GetCid(hThread,&Cid);

        DEBUG_EVENT de;
        BOOL bRet = FALSE;
        BOOL StatusRemoteThreadCreated = FALSE;

wait_again:

        bRet = WaitForDebugEvent(&de,INFINITE);

        if (bRet)
        {            
    	            switch(de.dwDebugEventCode)
    	            {
    	            case OUTPUT_DEBUG_STRING_EVENT:
    	                {
    	                    OUTPUT_DEBUG_STRING_INFO * pDbgStr = &de.u.DebugString;
    	                    WCHAR * pData = new WCHAR[pDbgStr->nDebugStringLength+1];
    	                    if(pDbgStr->fUnicode)
    	                    {
    	                        ReadMemory((ULONG_PTR)pDbgStr->lpDebugStringData,pData,pDbgStr->nDebugStringLength*sizeof(WCHAR),NULL);
    	                        dprintf("%S",pData);    	                        
    	                    }
    	                    else
    	                    {
    	                        ReadMemory((ULONG_PTR)pDbgStr->lpDebugStringData,pData,pDbgStr->nDebugStringLength*sizeof(CHAR),NULL);
    	                        dprintf("%s",pData);
    	                    }
    	                    delete [] pData;
    	                }

                      	bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                       	if (bRet)
                      	{
  	                        goto wait_again;
  	                    }
    	                break;
    	            case CREATE_THREAD_DEBUG_EVENT:
    	                if ((DWORD)((DWORD_PTR)Cid.UniqueProcess) == de.dwProcessId &&
        	        		(DWORD)((DWORD_PTR)Cid.UniqueThread) == de.dwThreadId)
        	    		{
        	    		    if (!StatusRemoteThreadCreated)
        	    		    {
            	    		    StatusRemoteThreadCreated = TRUE;
        	    		    }
        	    		}
        	    		else
        	    		{
		                    dprintf("%x.%x != %x.%x\n",
        	                    de.dwProcessId,de.dwThreadId,
            	                (DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread));
        	    		}
    	            	bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                   		if (bRet)
                  		{
	                       	goto wait_again;
 	                    };
    	                break;
    	            case CREATE_PROCESS_DEBUG_EVENT:
    	            case EXIT_PROCESS_DEBUG_EVENT:

          	            //dprintf("DebugEventCode %08x for %x.%x\n",de.dwDebugEventCode,de.dwProcessId,de.dwThreadId);
   	                	bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                   		if (bRet)
                  		{
	                       	goto wait_again;
 	                    };
          	            break;
    	            case EXCEPTION_DEBUG_EVENT:
    	                {
    	                    EXCEPTION_DEBUG_INFO  * pExcDebug = &de.u.Exception;
    	                    dprintf("%08x %08x FIRST? %d\n",
    	                            pExcDebug->ExceptionRecord.ExceptionCode,
    	                            pExcDebug->ExceptionRecord.ExceptionAddress,
    	                            pExcDebug->dwFirstChance);
    	                    bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_TERMINATE_THREAD);
    	                    if (bRet)
         	             	{
  	        	                goto wait_again;
  	            	        }
    	                }
    	                break;
    	            case EXIT_THREAD_DEBUG_EVENT:
    	                if ((DWORD)((DWORD_PTR)Cid.UniqueProcess) == de.dwProcessId &&
                  	        (DWORD)((DWORD_PTR)Cid.UniqueThread) == de.dwThreadId)
    	                {
    	                    if (StatusRemoteThreadCreated)
    	                    {
    	                        // ok
    	                    }
    	                    else
    	                    {
        	                    dprintf("EXIT_THREAD_DEBUG_EVENT %x.%x =?= %x.%x\n",
        	                            de.dwProcessId,de.dwThreadId,(DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread));
    	                    }
    	                    //
    	                    // we are done
    	                    //
    	                }
    	                else
    	                {
    	                	bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                       		if (bRet)
                      		{
  	                        	goto wait_again;
	  	                    }    	                
    	                }
    	                break;
    	            case LOAD_DLL_DEBUG_EVENT:
    	            case UNLOAD_DLL_DEBUG_EVENT:
    	                //dprintf("DebugEventCode %08x for %x.%x CONTINUE\n",de.dwDebugEventCode,de.dwProcessId,de.dwThreadId);
    	                bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                       	if (bRet)
                      	{
  	                        goto wait_again;
  	                    }
                        break;
    	            default:
    	                dprintf("DebugEventCode %08x\n ?????",de.dwDebugEventCode);        
    	                //ContinueDebugEvent((DWORD)Cid.UniqueProcess,(DWORD)Cid.UniqueThread,DBG_TERMINATE_THREAD);
    	            }    	                         
        }
        else
        {
            dprintf("WaitForDebugEvent err: %d\n",GetLastError());
        }
                
        CloseHandle(hThread);
    }
    else
    {
        dprintf("CreateRemoteThread %d\n",GetLastError());
    }

}

//
//
//
////////////////////////////////////////////////////////////

struct ContextParam {
    LIST_ENTRY * pHeadOutParam;
    ULONG Offset_Cid;
    ULONG Offset_Image;    
};

struct PidResolution {
	LIST_ENTRY Entry;
	BYTE Image[20];
	DWORD Pid;
};

DWORD
EnumListProcess(VOID * pStructure_OOP,
              VOID * pLocalStructure,
              VOID * Context)
{
    //dprintf("%p %p %p\n",pStructure_OOP,pLocalStructure,Context);
    ContextParam * pContext = (ContextParam *)Context;
    
    PidResolution * pRes = (PidResolution *)HeapAlloc(GetProcessHeap(),0,sizeof(PidResolution));
    //dprintf("%p\n",pRes);
    if (pRes)
    {        
        InsertTailList(pContext->pHeadOutParam,&pRes->Entry);
        memcpy(pRes->Image,(BYTE *)pLocalStructure+pContext->Offset_Image,16);
        pRes->Image[16] = 0;
        pRes->Pid = *(DWORD *)((BYTE *)pLocalStructure+pContext->Offset_Cid);
    }
    //dprintf("EPROCESS %p Cid: %x image %s\n",pStructure_OOP,pRes->Pid,pRes->Image);
    return 0;
}


DWORD GetProcList(LIST_ENTRY * pHeadOut)
{
    //dprintf("GetProcList\n");
    
    MEMORY_ADDRESS pProcessEntry = GetExpression("nt!PsActiveProcessHead");

    ULONG Offset_Entry = 0;
    ULONG Offset_Cid = 0;
    ULONG Offset_Image = 0;    

    if (!(0 == GetFieldOffset("nt!_EPROCESS","ActiveProcessLinks",&Offset_Entry) &&
        0 == GetFieldOffset("nt!_EPROCESS","UniqueProcessId",&Offset_Cid) &&
        0 == GetFieldOffset("nt!_EPROCESS","ImageFileName",&Offset_Image)))
    {
        dprintf("bad symbols\n");
    }
    
    if (pProcessEntry)
    {
        ContextParam Context_ = {pHeadOut,Offset_Cid,Offset_Image};
        EnumLinkedListCB((LIST_ENTRY  *)pProcessEntry,
	                         Offset_Image + 16, // sizeof(EPROCESS)
	                         Offset_Entry,	   // FILED_OFFSET(ActiveProcessLinks) 
	                         (pfnCallBack2)EnumListProcess,
	                         &Context_); 
    }
    else
    {
        dprintf("unable to obtain %s\n","nt!PsActiveProcessHead");
    }
    return 0;
}

DWORD FreeProcList(LIST_ENTRY * HeadProcess)
{
    while (!IsListEmpty(HeadProcess))
    {
        LIST_ENTRY * pEntry = HeadProcess->Flink;
        RemoveEntryList(pEntry);
        HeapFree(GetProcessHeap(),0,pEntry);
    }
    return 0;
}

PidResolution * FindProcList(LIST_ENTRY * HeadProcess,DWORD Cid)
{
    for (LIST_ENTRY * pEntry = HeadProcess->Flink;pEntry != HeadProcess;pEntry = pEntry->Flink)
    {        
        PidResolution * pRes = CONTAINING_RECORD(pEntry,PidResolution,Entry);
        if (Cid == pRes->Pid)
        	return pRes;
    }
    return 0;
}

DECLARE_API( tcp_ports )
{
    INIT_API();

    if (!g_KD)
    {
        dprintf("KD support only\n");
        return;
    }

    MEMORY_ADDRESS pTable = GetExpression("tcpip!AddrObjTable");
    MEMORY_ADDRESS pNumEntry = GetExpression("tcpip!AddrObjTableSize");

    ULONG Offset_next = 0;
    ULONG Offset_addr = 0;        
    ULONG Offset_port = 0;
    ULONG Offset_owningpid = 0;
    ULONG Offset_proto = 0;

    if (!(0 == GetFieldOffset("tcpip!AddrObj","ao_next",&Offset_next) &&
        0 == GetFieldOffset("tcpip!AddrObj","ao_port",&Offset_port) &&
        0 == GetFieldOffset("tcpip!AddrObj","ao_owningpid",&Offset_owningpid) &&
        0 == GetFieldOffset("tcpip!AddrObj","ao_addr",&Offset_addr) &&
        0 == GetFieldOffset("tcpip!AddrObj","ao_prot",&Offset_proto) ))
    {
        dprintf("bad symbols\n");
        return;
    }

    LIST_ENTRY HeadProcess = {&HeadProcess,&HeadProcess};

    GetProcList(&HeadProcess);
    
    if (pTable)
    {
        ULONG_PTR TableAddr;
        if (ReadMemory(pTable,&TableAddr,sizeof(TableAddr),NULL))
        {
            DWORD NumEntry;
            if (ReadMemory(pNumEntry,&NumEntry,sizeof(NumEntry),NULL))
            {
                ULONG_PTR * pArray = (ULONG_PTR *)_alloca(NumEntry*sizeof(ULONG_PTR));
                if (ReadMemory(TableAddr,pArray,NumEntry*sizeof(ULONG_PTR),NULL))
                {
                    BYTE * pStorage = (BYTE *)_alloca(Offset_owningpid + sizeof(DWORD));
                    for(DWORD i=0;i<NumEntry;i++)
                    {
                        //dprintf(" - bucket %x\n",i);
                        ULONG_PTR pAddObj_OOP = pArray[i];
                        while (pAddObj_OOP)
                        {
                            //dprintf("    AddrObj %p\n",pAddObj_OOP);
                            if (ReadMemory(pAddObj_OOP,pStorage,Offset_owningpid + sizeof(DWORD),NULL))
                            {
                                pAddObj_OOP = *(ULONG_PTR *)(pStorage+Offset_next);
                                WORD Port = *(WORD *)(pStorage+Offset_port);
                                DWORD Process = *(DWORD *)(pStorage+Offset_owningpid);                            
                                BYTE Protocol = *(BYTE *)(pStorage+Offset_proto);

                                PidResolution * pRes = FindProcList(&HeadProcess,Process);
                                if (pRes)
                                {
                                    dprintf(" Cid: %x image %s\n",pRes->Pid,pRes->Image);
                                }
                                BYTE AddrByte[4];
                                memcpy(AddrByte,pStorage+Offset_addr,4);
                                // ntohs
                                WORD Port2 = ((Port & 0xFF) <<8);
                                WORD Port3 = ((Port & 0xFF00) >> 8);
                                Port = Port2 | Port3;
                                dprintf("    addr: %d.%d.%d.%d port: %d proto: %x \n",
                                	  AddrByte[0],
                                	  AddrByte[1],
                                	  AddrByte[2],
                                	  AddrByte[3],Port,Protocol);
                            }
						    else
						    {
                                pAddObj_OOP = 0;
						        dprintf("RM %p\n",pTable);
						    }                
                             
                        }
                    }
                }
			    else
			    {
			        dprintf("RM %p\n",pTable);
			    }                
            }
		    else
		    {
		        dprintf("RM %p\n",pTable);
		    }
        }
        else
        {
            dprintf("RM %p\n",pTable);
        }
    }
    else
    {
        dprintf("unable to get %s\n","tcpip!AddrObjTable");
    }

    FreeProcList(&HeadProcess);
}


//
// prototype here
//
BOOL GetVTable(MEMORY_ADDRESS pThis_OOP);

//
//
//  Dumps the thread list with some info on OLE and RPC
//
//

typedef enum tagOLETLSFLAGS
{
    OLETLS_LOCALTID             = 0x01,   // This TID is in the current process.
    OLETLS_UUIDINITIALIZED      = 0x02,   // This Logical thread is init'd.
    OLETLS_INTHREADDETACH       = 0x04,   // This is in thread detach. Needed
                                          // due to NT's special thread detach
                                          // rules.
    OLETLS_CHANNELTHREADINITIALZED = 0x08,// This channel has been init'd
    OLETLS_WOWTHREAD            = 0x10,   // This thread is a 16-bit WOW thread.
    OLETLS_THREADUNINITIALIZING = 0x20,   // This thread is in CoUninitialize.
    OLETLS_DISABLE_OLE1DDE      = 0x40,   // This thread can't use a DDE window.
    OLETLS_APARTMENTTHREADED    = 0x80,   // This is an STA apartment thread
    OLETLS_MULTITHREADED        = 0x100,  // This is an MTA apartment thread
    OLETLS_IMPERSONATING        = 0x200,  // This thread is impersonating
    OLETLS_DISABLE_EVENTLOGGER  = 0x400,  // Prevent recursion in event logger
    OLETLS_INNEUTRALAPT         = 0x800,  // This thread is in the NTA
    OLETLS_DISPATCHTHREAD       = 0x1000, // This is a dispatch thread
    OLETLS_HOSTTHREAD           = 0x2000, // This is a host thread
    OLETLS_ALLOWCOINIT          = 0x4000, // This thread allows inits
    OLETLS_PENDINGUNINIT        = 0x8000, // This thread has pending uninit
    OLETLS_FIRSTMTAINIT         = 0x10000,// First thread to attempt an MTA init
    OLETLS_FIRSTNTAINIT         = 0x20000,// First thread to attempt an NTA init
    OLETLS_APTINITIALIZING      = 0x40000 // Apartment Object is initializing
}  OLETLSFLAGS;


void PrintOleFlags(DWORD dwFlags)
{
    if (dwFlags & OLETLS_LOCALTID) dprintf("OLETLS_LOCALTID ");
    if (dwFlags & OLETLS_WOWTHREAD) dprintf("OLETLS_WOWTHREAD ");
    if (dwFlags & OLETLS_THREADUNINITIALIZING ) dprintf("OLETLS_THREADUNINITIALIZING ");
    if (dwFlags & OLETLS_DISABLE_OLE1DDE) dprintf("OLETLS_DISABLE_OLE1DDE ");
    if (dwFlags & OLETLS_APARTMENTTHREADED) dprintf("OLETLS_APARTMENTTHREADED ");
    if (dwFlags & OLETLS_MULTITHREADED) dprintf("OLETLS_MULTITHREADED ");
    if (dwFlags & OLETLS_IMPERSONATING) dprintf("OLETLS_IMPERSONATING ");
    if (dwFlags & OLETLS_DISABLE_EVENTLOGGER) dprintf("OLETLS_DISABLE_EVENTLOGGER ");
    if (dwFlags & OLETLS_INNEUTRALAPT ) dprintf("OLETLS_INNEUTRALAPT ");
    if (dwFlags & OLETLS_DISPATCHTHREAD) dprintf("OLETLS_DISPATCHTHREAD ");
    if (dwFlags & OLETLS_HOSTTHREAD) dprintf("OLETLS_HOSTTHREAD ");
    if (dwFlags & OLETLS_ALLOWCOINIT ) dprintf("OLETLS_ALLOWCOINIT ");    
    if (dwFlags & OLETLS_PENDINGUNINIT ) dprintf("OLETLS_PENDINGUNINIT ");
    if (dwFlags & OLETLS_FIRSTMTAINIT) dprintf("OLETLS_FIRSTMTAINIT ");
    if (dwFlags & OLETLS_FIRSTNTAINIT) dprintf("OLETLS_FIRSTNTAINIT ");
    if (dwFlags & OLETLS_APTINITIALIZING) dprintf("OLETLS_APTINITIALIZING ");    
}

//
//
//   rpcrt4!THREAD
//   ole32!SOleTlsData
//

void 
DumpRpcOle(ULONG_PTR pRpc,ULONG_PTR pOle)
{
    if (pRpc)
    {

        ULONG OffsetContext;
        ULONG_PTR pRpcLRPC = 0;
        if (0 != GetFieldOffset("rpcrt4!THREAD","Context",&OffsetContext))
        {
        #ifdef _WIN64
            OffsetContext = 0x18;
        #else
            OffsetContext = 0x10;
        #endif
        }
        
        ReadMemory(pRpc+OffsetContext,&pRpcLRPC,sizeof(ULONG_PTR),0);
        
        ULONG_PTR pFirstVoid = 0;
        ReadMemory((ULONG_PTR)pRpcLRPC,&pFirstVoid,sizeof(ULONG_PTR),0);

        BYTE pString[256];
	    pString[0]=0;

#ifdef KDEXT_64BIT
        ULONG64 Displ;
#else
        ULONG Displ;
#endif
        if (pFirstVoid)
    	    GetSymbol(pFirstVoid,(PCHAR)pString,&Displ);
	    if (lstrlenA((CHAR *)pString))
	    {
	        dprintf("        %s+%x %p\n",pString,Displ,pRpcLRPC);
	        if (strstr((const char *)pString,"LRPC_SCALL"))
	        {
	            ULONG OffsetCID;
	            if (0 != GetFieldOffset("rpcrt4!LRPC_SCALL","ClientId",&OffsetCID))
        		{
#ifdef _WIN64
		            OffsetCID = 0x100;
#else
        		    OffsetCID = 0xa0;
#endif
        		}
                CLIENT_ID CID;
                ReadMemory(pRpcLRPC+OffsetCID,&CID,sizeof(CLIENT_ID),NULL);
                dprintf("        - - - - called from: %x.%x\n",CID.UniqueProcess,CID.UniqueThread);
        		
	        }
	    } 
	    else
	    {        
            dprintf("        rpcrt4!THREAD.Context %p\n",pRpcLRPC);
        }
    }
    if (pOle)
    {
        ULONG OffsetCallContext;
        ULONG_PTR pCallCtx = 0;
        if (0 != GetFieldOffset("ole32!SOleTlsData","pCallContext",&OffsetCallContext))
        {
        #ifdef _WIN64
            OffsetCallContext = 0x88;
        #else
            OffsetCallContext = 0x54;
        #endif
        }
        ULONG OffsetdwFlags;
        DWORD dwFlags;
        if (0 != GetFieldOffset("ole32!SOleTlsData","dwFlags",&OffsetdwFlags))
        {
        #ifdef _WIN64
            OffsetdwFlags = 0x14;
        #else
            OffsetdwFlags = 0xc;
        #endif
        }        
        
        ReadMemory(pOle+OffsetCallContext,&pCallCtx,sizeof(ULONG_PTR),0);

        ReadMemory(pOle+OffsetdwFlags,&dwFlags,sizeof(DWORD),0);
        
        dprintf("        ole32!SOleTlsData::pCallContext %p\n",pCallCtx);
        if (pCallCtx)
            GetVTable(pCallCtx);

        dprintf("            ");
        PrintOleFlags(dwFlags);
        dprintf("\n");
    }
}

//
//
// call HeapFree(GetProcessHeap) on the OUT pointers
//
//////////////////////////////////////////////////////

DWORD
GetThreadArrays(HANDLE hCurrentProcess,
                DWORD * pdwThreads,
                SYSTEM_EXTENDED_THREAD_INFORMATION ** ppExtThreadInfo,
                TEB *** pppTebs)
{

    if (!pdwThreads || !ppExtThreadInfo || !pppTebs)
    {
        return ERROR_INVALID_PARAMETER;
    };

    NTSTATUS Status;
    DWORD dwInc = 8*1024;
    DWORD dwSize = dwInc;
    VOID * pData = NULL;
    DWORD dwReturned;

loop_realloc:    
    pData = HeapAlloc(GetProcessHeap(),0,dwSize);
    if (!pData)
    {
        return ERROR_OUTOFMEMORY;
    }
    
    Status = NtQuerySystemInformation(SystemExtendedProcessInformation,
                                      pData,
                                      dwSize,
                                      &dwReturned);
                                      
    if (STATUS_INFO_LENGTH_MISMATCH == Status)
    {
        HeapFree(GetProcessHeap(),0,pData);    
        dwSize += dwInc;
        goto loop_realloc;
    } 
    else if (STATUS_SUCCESS == Status)
    {
        // here we have the snapshot:parse it
        SYSTEM_PROCESS_INFORMATION * pProcInfo = (SYSTEM_PROCESS_INFORMATION *)pData;
        SYSTEM_EXTENDED_THREAD_INFORMATION * pThreadInfo;

        // get the process id;
        
        ULONG_PTR IdProc;
        GetPeb(hCurrentProcess,NULL,&IdProc);
        
        while (TRUE)
        {
            //dprintf("    process %p curr %p\n",pProcInfo->UniqueProcessId,IdProc);
            if (IdProc == (ULONG_PTR)pProcInfo->UniqueProcessId)
            {
                DWORD Threads = pProcInfo->NumberOfThreads;
                *pdwThreads = Threads;
                DWORD i;
                pThreadInfo = (SYSTEM_EXTENDED_THREAD_INFORMATION *)((ULONG_PTR)pProcInfo+sizeof(SYSTEM_PROCESS_INFORMATION));

                SYSTEM_EXTENDED_THREAD_INFORMATION * pOutThreadInfo = NULL;
                TEB ** ppOutTebs = NULL;
                
                pOutThreadInfo = (SYSTEM_EXTENDED_THREAD_INFORMATION *)HeapAlloc(GetProcessHeap(),0,Threads*sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION));
                if (pOutThreadInfo)
                {
                    ppOutTebs = (TEB **)HeapAlloc(GetProcessHeap(),0,Threads*sizeof(TEB *));
                    if (!ppOutTebs)
                    {
                        HeapFree(GetProcessHeap(),0,pOutThreadInfo);
	                    Status = ERROR_OUTOFMEMORY;
    	                Threads = 0; // to stop loop            
                    }
                    else
                    {
                        memcpy(pOutThreadInfo,pThreadInfo,Threads*sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION));
                    }
                }
                else
                {
                    Status = ERROR_OUTOFMEMORY;
                    Threads = 0; // to stop loop
                }
                                               
                for (i=0;i<Threads;i++)
                {
                    //dprintf("    %x.%x\n",pThreadInfo->ThreadInfo.ClientId.UniqueProcess,pThreadInfo->ThreadInfo.ClientId.UniqueThread);

                    NTSTATUS StatusThread;
                    HANDLE hThread;
                    OBJECT_ATTRIBUTES Obja = {sizeof( OBJECT_ATTRIBUTES ), 0, 0, 0 ,0 };
                        
                    StatusThread = NtOpenThread(&hThread,THREAD_QUERY_INFORMATION,&Obja,&(pThreadInfo->ThreadInfo.ClientId));
                    if (((NTSTATUS)0L) == StatusThread)
                    {
                        TEB * pTeb = NULL;
                        GetTeb(hThread,&pTeb);

                        ppOutTebs[i] = pTeb;
                        
                        CloseHandle(hThread);
                    }
                    else
                    {
                        dprintf("NtOpenThread %d\n",StatusThread);
                    }
                    
                    pThreadInfo++;
                }
                // once found our process, 
                // don't bother with the others
                *pppTebs = ppOutTebs;
                *ppExtThreadInfo = pOutThreadInfo;
                Status = NO_ERROR;
                break;
            }
            if (0 == pProcInfo->NextEntryOffset)
            {
                break;
            }
            else
            {
                pProcInfo = (SYSTEM_PROCESS_INFORMATION *)((ULONG_PTR)pProcInfo+pProcInfo->NextEntryOffset);
            }
        }
        
    } 
    else // other cases
    {
        dprintf("NtQuerySystemInformation %08x\n",Status);
        return Status;
    }

    return Status;
}


DECLARE_API(t)
{
    INIT_API();

    DWORD dwThreads;
    TEB ** ppTebs = NULL;
    SYSTEM_EXTENDED_THREAD_INFORMATION * pSysThreadInfo = NULL;

    // get the offsets only once 
    ULONG OffsetRPC;
    ULONG_PTR pRpcThread;
    if (0 != GetFieldOffset("ntdll!TEB","ReservedForNtRpc",&OffsetRPC))
    {
    #ifdef _WIN64
        OffsetRPC = 0x1698;
    #else
        OffsetRPC = 0xf1c;
    #endif
    }    
    ULONG OffsetOLE;
    ULONG_PTR pOleThread;
    if (0 != GetFieldOffset("ntdll!TEB","ReservedForOle",&OffsetOLE))
    {
    #ifdef _WIN64
        OffsetOLE = 0x1758;
    #else
        OffsetOLE = 0xf80;
    #endif                        
    }

    DWORD dwErr;
    MEMORY_ADDRESS pCurrentTEB = GetExpression(args);

    dwErr = GetThreadArrays(hCurrentProcess,&dwThreads,
                                    &pSysThreadInfo,&ppTebs);
    if (NO_ERROR == dwErr)
    {
        for (DWORD i=0;i<dwThreads;i++)
        {            
            TEB * pTeb = ppTebs[i];
            if (pCurrentTEB)
            {
            	if (pTeb != (TEB *)pCurrentTEB)
            	    continue;
            }

            SYSTEM_EXTENDED_THREAD_INFORMATION * pThreadInfo = &pSysThreadInfo[i];
            
            if (ReadMemory((ULONG_PTR)pTeb+OffsetOLE,&pOleThread,sizeof(ULONG_PTR),0) &&
                ReadMemory((ULONG_PTR)pTeb+OffsetRPC,&pRpcThread,sizeof(ULONG_PTR),0))
            {

                        NT_TIB NtTib;
                        ReadMemory((ULONG_PTR)pTeb,&NtTib,sizeof(NT_TIB),NULL);

                        dprintf("    %03d %x.%x Addr: %p TEB:  %p FiberData %p\n"
                                "                   limit %p base  %p\n"
                                "                   RPC   %p OLE   %p\n",
                                i,
                                pThreadInfo->ThreadInfo.ClientId.UniqueProcess,pThreadInfo->ThreadInfo.ClientId.UniqueThread,
                                pThreadInfo->Win32StartAddress,
                                pTeb,NtTib.FiberData,
                                NtTib.StackLimit,NtTib.StackBase,
                                pRpcThread,
                                pOleThread);

#ifdef _WIN64

//   +0x1788 DeallocationBStore : (null)
//   +0x1790 BStoreLimit      : 0x000006fb`faba2000

                        ULONG_PTR lDeAlloc;
                        ULONG_PTR lBPLimit;
                        ULONG Offset_DeallocationBStore = 0x1788;
                        ReadMemory((ULONG_PTR)pTeb+Offset_DeallocationBStore,&lDeAlloc,sizeof(ULONG_PTR),0);

                        ULONG Offset_BStoreLimit = 0x1790;
                        ReadMemory((ULONG_PTR)pTeb+Offset_BStoreLimit,&lBPLimit,sizeof(ULONG_PTR),0);

                        dprintf("               DAll  %p BStL %p\n",lDeAlloc,lBPLimit);
#endif

                        DumpRpcOle(pRpcThread,pOleThread);
            }
            else
            {
                dprintf("RM %p %p\n",(ULONG_PTR)pTeb+OffsetOLE,(ULONG_PTR)pTeb+OffsetRPC);
            }
        }                
    }

    if (ppTebs)
        HeapFree(GetProcessHeap(),0,ppTebs);
    if (pSysThreadInfo)
        HeapFree(GetProcessHeap(),0,pSysThreadInfo);


}


DECLARE_API(srt)
{
    INIT_API();

    DWORD dwThreads;
    TEB ** ppTebs;
    SYSTEM_EXTENDED_THREAD_INFORMATION * pSysThreadInfo;

    MEMORY_ADDRESS Addr = GetExpression(args);
    ULONG_PTR * ThreadMem = NULL;
    ULONG_PTR Size = 0;

    if (NO_ERROR == GetThreadArrays(hCurrentProcess,&dwThreads,
                                    &pSysThreadInfo,&ppTebs))
    {
        for (DWORD i=0;i<dwThreads;i++)
        {
            TEB * pTeb = ppTebs[i];
            SYSTEM_EXTENDED_THREAD_INFORMATION * pThreadInfo = &pSysThreadInfo[i];

            TEB Teb;
            
            ReadMemory((ULONG_PTR)pTeb,&Teb,sizeof(TEB),NULL);

#ifndef _IA64_            
            ULONG_PTR Base  = (ULONG_PTR)Teb.NtTib.StackBase;
#else
            ULONG_PTR Base  = (ULONG_PTR)Teb.BStoreLimit;
#endif
            ULONG_PTR Limit = (ULONG_PTR)Teb.NtTib.StackLimit;
            ULONG_PTR CurrSize = Base-Limit;

            //dprintf("searching %p between %p and %p\n",Addr,Limit,Base);

            if (CurrSize > Size)
            {
                Size = CurrSize;
                if (ThreadMem)
                {
                    HeapFree(GetProcessHeap(),0,ThreadMem);
                    ThreadMem = NULL;
                }
                ThreadMem = (ULONG_PTR *)HeapAlloc(GetProcessHeap(),0,Size);
                
            }
            if (ThreadMem)
            {
                if (ReadMemory(Limit,ThreadMem,(ULONG)CurrSize,NULL))
                {
                    for(DWORD j=0;j<CurrSize/sizeof(ULONG_PTR);j++)
                    {
                        if (Addr == ThreadMem[j])
                        {
                            dprintf("    %x.%x  %p\n",
                                    pThreadInfo->ThreadInfo.ClientId.UniqueProcess,pThreadInfo->ThreadInfo.ClientId.UniqueThread,
                                    Limit+((ULONG_PTR)&ThreadMem[j]-(ULONG_PTR)ThreadMem));
                        }
                    }
                }
            };            
        }

        HeapFree(GetProcessHeap(),0,ppTebs);
        HeapFree(GetProcessHeap(),0,pSysThreadInfo);
        
    }    

    if (ThreadMem)
        HeapFree(GetProcessHeap(),0,ThreadMem);
}


#if defined(_X86_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8

#elif defined(_IA64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 16

#elif defined(_AMD64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 16

#else
    #error  // platform not defined
#endif


BYTE s_Prolog[] = { 0x8b, 0xd0 };

// repeat this
BYTE s_Body[] = {
 0xb8, 0xFF, 0xFF, 0xFF, 0xFF,
 0x8b, 0x48, 0x04,
 0x8b, 0x58, 0x08,
 0x3b, 0xcb,
 0x74, 0x07,
 0x8b, 0x03,
 0x83, 0xc3, 0x04,
 0xeb, 0xf5,
};
// stop repeat

BYTE s_Epilog[] = {
 0x8b, 0xc2,
 0xcc,
 0xba, 0xEE, 0xEE, 0xEE, 0xEE,
 0xff, 0xe2,
 0x90,            
 0x90,
};


DECLARE_API(ksrt)
{
    INIT_API();

    if (!g_KD)
    {
        dprintf("KD support only\n");
        return;
    }

    char * pArgs = (char *)args;
    while(isspace(*pArgs)) pArgs++;

    MEMORY_ADDRESS EProcess = GetExpression(pArgs);

    while(!isspace(*pArgs)) pArgs++;
    while(isspace(*pArgs)) pArgs++;

    char * pValue = pArgs; 
    MEMORY_ADDRESS SearchFor = GetExpression(pValue);

    while(!isspace(*pArgs)) pArgs++;
    while(isspace(*pArgs)) pArgs++;

    MEMORY_ADDRESS PrintPageIn = 0;
    if (pArgs != pValue+strlen(pValue))
    {
        PrintPageIn = GetExpression(pArgs);
    }

    dprintf("[DBG] %p %p %p\n",EProcess,SearchFor,PrintPageIn );
    
    ULONG OffsetProcessThreadList;
    
    if (0 != GetFieldOffset("nt!_KPROCESS","ThreadListHead",&OffsetProcessThreadList))
    {
    #ifdef _WIN64
        OffsetProcessThreadList = 0x088;
    #else
        OffsetProcessThreadList = 0x050;
    #endif    
    }
    
    ULONG OffsetThreadThreadList;
    if (0 != GetFieldOffset("nt!_KTHREAD","ThreadListEntry",&OffsetThreadThreadList))
    {
    #ifdef _WIN64
        OffsetThreadThreadList = 0x320;
    #else
        OffsetThreadThreadList = 0x1b0; 
    #endif    
    }

    ULONG OffsetThreadTEB;
    if (0 != GetFieldOffset("nt!_KTHREAD","Teb",&OffsetThreadTEB))
    {
    #ifdef _WIN64
        OffsetThreadTEB = 0x070;
    #else
        OffsetThreadTEB = 0x020;        
    #endif    
    }
    
    if (EProcess)
    {
#ifdef _X86_    
        BYTE * pMemory = NULL;
        BYTE * pNext;
        if (PrintPageIn)
        {
            pMemory = (BYTE *)HeapAlloc(GetProcessHeap(),0,4*1024);
            pNext = pMemory;
            if (NULL == pMemory)
            {
            	PrintPageIn = 0;
            }
            else
            {
                memset(pMemory,0x90,4*1024);
                memcpy(pMemory,s_Prolog,sizeof(s_Prolog));
                pNext+=sizeof(s_Prolog);
            }
        }
        dprintf("pMemory %p\n",pMemory);
#endif        
                	
        LIST_ENTRY HeadList;
        LIST_ENTRY * pListEntry = &HeadList;
        EProcess += OffsetProcessThreadList;

        DWORD SizeToRead = max(OffsetThreadTEB,OffsetThreadThreadList)+sizeof(LIST_ENTRY);
        ULONG_PTR KThreadAddr;
        ULONG_PTR Teb;
        
        ULONG_PTR * pKTHREAD = (ULONG_PTR *)_alloca(SizeToRead);
     
        if (ReadMemory(EProcess,&HeadList,sizeof(LIST_ENTRY),NULL))
        {
            DWORD i = 0;        
            while ((LIST_ENTRY *)EProcess != pListEntry->Flink)
            {
                //dprintf("pListEntry->Flink %p\n",pListEntry->Flink);
                
                KThreadAddr = (ULONG_PTR)pListEntry->Flink - (ULONG_PTR)OffsetThreadThreadList;
                if (ReadMemory((ULONG_PTR)KThreadAddr,pKTHREAD,SizeToRead,NULL))
                {
                    // do useful work
                    Teb = *((ULONG_PTR *)((BYTE *)pKTHREAD+OffsetThreadTEB));
                    dprintf("    %d - _KTHREAD %p TEB %p\n",i++,KThreadAddr,Teb);

                    if (PrintPageIn)
                    {
#ifdef _X86_                    
                        memcpy(pNext,s_Body,sizeof(s_Body));
                        *(ULONG_PTR *)(pNext+1) = Teb;
                        pNext+=sizeof(s_Body);
#endif                        
                    }
                    else
                    {
	                    NT_TIB ThreadTib;
	                    if (ReadMemory(Teb,&ThreadTib,sizeof(NT_TIB),NULL))
	                    {
	                        dprintf("        EL %p B %p L %p F %p\n",ThreadTib.ExceptionList,ThreadTib.StackBase,ThreadTib.StackLimit,ThreadTib.FiberData);

	                        ULONG_PTR Current = (ULONG_PTR)ThreadTib.StackLimit;
	                        ULONG_PTR nPages = (ULONG_PTR)ThreadTib.StackBase-(ULONG_PTR)ThreadTib.StackLimit;
	                        nPages /= PAGE_SIZE;
	                        ULONG_PTR j;
	                        for (j=0;j<nPages;j++)
	                        {
	                            ULONG_PTR pPage[PAGE_SIZE/sizeof(ULONG_PTR)];
	                            if (ReadMemory(Current,pPage,sizeof(pPage),NULL))
	                            {
	                                for(DWORD k=0;k<(PAGE_SIZE/sizeof(ULONG_PTR));k++)
	                                {
	                                    if(SearchFor == pPage[k])
	                                    {
	                                        dprintf("            %p\n",Current+k*sizeof(ULONG_PTR));
	                                    }
						                if (CheckControlC())
	                    					break;                                    
	                                }
	                            }
	                            else
	                            {
	                                dprintf("    page @ %p not paged-in\n",Current);
	                            }
	                            Current += PAGE_SIZE;
	                            
				                if (CheckControlC())
	            			        break;                            
	                        }
	                    }
	                    else
	                    {
	                        dprintf("    RM Teb %p\n",Teb);
	                    }
                    }
                    
                    // equivalent of i++
                    pListEntry = (LIST_ENTRY *)((BYTE *)pKTHREAD+OffsetThreadThreadList);                    
                }
                else
                {
                    dprintf("RM %p\n",KThreadAddr);
                    break;
                }
                if (CheckControlC())
                    break;
            }
        }
        else
        {
            dprintf("RM %p\n",EProcess);
        }

#ifdef _X86_    
        if (pMemory)
        {
            memcpy(pNext,s_Epilog,sizeof(s_Epilog));
            pNext+=sizeof(s_Epilog);
            ULONG_PTR nDW = (ULONG_PTR)pNext-(ULONG_PTR)pMemory;

            dprintf("writing %p bytes to %p\n",nDW,PrintPageIn);
            WriteMemory(PrintPageIn,pMemory,nDW,NULL);
            /*
            nDW/=sizeof(DWORD);
            DWORD * pDW = (DWORD *) pMemory;
            for (ULONG_PTR i =0;i<(nDW+1);i++)
            {
                if (0 == i%8)
                	dprintf("\n");            
                dprintf("%08x ",pDW[i]);

            }
            dprintf("\n");
            */
            // dprintf the whole content
        	HeapFree(GetProcessHeap(),0,pMemory);
        }
#endif        
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
}


#ifdef i386
#define MAGIC_START (16+2)
#endif

char *
GetCall(ULONG_PTR Addr, BOOL pPrint = TRUE)
{
    static char pBuff[1024];
    
#ifdef KDEXT_64BIT
    ULONG64   ThisAddr = Addr-2;
#else
    ULONG_PTR ThisAddr = Addr-2;
#endif    
    
    Disasm(&ThisAddr,pBuff,FALSE);
    if (strstr(pBuff,"call"))
    {
        if (pPrint)
            dprintf("    %s\n",pBuff);
        return pBuff;
    }

    ThisAddr = Addr-3;
    Disasm(&ThisAddr,pBuff,FALSE);
    if (strstr(pBuff,"call"))
    {
        if (pPrint)
            dprintf("    %s\n",pBuff);
        return pBuff;   
    }

    ThisAddr = Addr-5;
    Disasm(&ThisAddr,pBuff,FALSE);
    if (strstr(pBuff,"call"))
    {
        if (pPrint)    
            dprintf("    %s\n",pBuff);
        return pBuff;   
    }

    ThisAddr = Addr-6;
    Disasm(&ThisAddr,pBuff,FALSE);
    if (strstr(pBuff,"call"))
    {
        if (pPrint)    
            dprintf("    %s\n",pBuff);
        return pBuff;   
    }

    return NULL;
}

DECLARE_API(bs0)
{

#ifdef i386
    INIT_API();

    MEMORY_ADDRESS pTeb = GetExpression(args);
    if (pTeb)
    {
        NT_TIB Tib;
        ReadMemory(pTeb,&Tib,sizeof(Tib),NULL);
        dprintf("    exception %p base %p limit %p\n",
                Tib.ExceptionList,Tib.StackBase,Tib.StackLimit);
                       
        ULONG_PTR dwSize = (ULONG_PTR)Tib.StackBase-(ULONG_PTR)Tib.StackLimit;
        BYTE * pStack = new BYTE[dwSize];
        ULONG_PTR OldEBP = 0;

        if (pStack)
        {
            ULONG_PTR * pBase  = (ULONG_PTR *)(pStack+dwSize);
            ULONG_PTR * pLimit = (ULONG_PTR *)pStack;
            
            if (ReadMemory((ULONG_PTR)Tib.StackLimit,pStack,(ULONG_PTR)Tib.StackBase-(ULONG_PTR)Tib.StackLimit,NULL))
            {
	            ULONG_PTR EBP = (ULONG_PTR)(Tib.StackBase)-(MAGIC_START*sizeof(ULONG_PTR));
	            ULONG_PTR * pEBP = (ULONG_PTR *)pBase-MAGIC_START;
	            BOOL bGoOn = TRUE;
	            BOOL bRpcRt4Fix = FALSE;

	            while(bGoOn)
	            {
	                dprintf("%p %p\n",pEBP[0],pEBP[1]);
	                char * pFunction = GetCall(pEBP[1]);
	                BOOL bFound = FALSE;

	                if (pFunction)
	                {
	                    if (strstr(pFunction,"ComInvokeWithLockAndIPID"))
	                    {
	                        EBP -= 0x70;
	                    }
	                }
	                else // try to move back
	                {
	                    pEBP--;
	                    EBP = OldEBP;
	                }
	                
	                dprintf("looking for %p = cmp %p \n",EBP,pEBP[0]);                
	                
	                if (!bRpcRt4Fix)
	                {
		                if (pEBP[0] < (ULONG_PTR)Tib.StackLimit || pEBP[0] > (ULONG_PTR)Tib.StackBase)
		                {
		                    bRpcRt4Fix = TRUE;
		                    // rpcrt4 call_stack fix
		                    EBP = (ULONG_PTR)(Tib.StackBase) - 0x6c;
		                }
	                }
	                dprintf("looking for %p\n",EBP);                
	                
	                while ((ULONG_PTR)pEBP > (ULONG_PTR)pLimit){
	                    if (*pEBP-- == EBP){
	                        bFound = TRUE;
	                        break;
	                    }
	                }
	                if (bFound)
	                {
	                    pEBP++;
	                    OldEBP = EBP;
	                    EBP = (ULONG_PTR)(Tib.StackBase)-((ULONG_PTR)pBase-(ULONG_PTR)pEBP);
	                }
	                else
	                {
	                    bGoOn = FALSE;
	                }
	            }
            }            
            delete [] pStack;
        }
        
    }
    else
    {
        dprintf("%s cannot be interpreted\b",args);
    }
#endif    
}    


DECLARE_API(bs)
{

#ifdef i386
    INIT_API();
    char * pArgs = (char *)args;
    MEMORY_ADDRESS pTeb = GetExpression(args);

    while (isspace(*pArgs)) pArgs++; // skip leading spaces
    while (!isspace(*pArgs)) pArgs++; // skip the TEB
    while (isspace(*pArgs)) pArgs++; // skip other spaces

    MEMORY_ADDRESS pCurrentESP = GetExpression(pArgs);
    
    if (pTeb)
    {
        NT_TIB Tib;
        ReadMemory(pTeb,&Tib,sizeof(Tib),NULL);
        dprintf("    exception %p base %p limit %p\n",
                Tib.ExceptionList,Tib.StackBase,Tib.StackLimit);
                       
        ULONG_PTR dwSize = (ULONG_PTR)Tib.StackBase-(ULONG_PTR)Tib.StackLimit;
        BYTE * pStack = new BYTE[dwSize];

        if (pStack)
        {
            ULONG_PTR * pBase  = (ULONG_PTR *)(pStack+dwSize);
            ULONG_PTR * pLimit = (ULONG_PTR *)pStack;
            if (ReadMemory((ULONG_PTR)Tib.StackLimit,pStack,(ULONG_PTR)Tib.StackBase-(ULONG_PTR)Tib.StackLimit,NULL))
            {
                dwSize = dwSize/sizeof(ULONG_PTR);
                ULONG_PTR * pStack2 = (ULONG_PTR *)pStack;
                ULONG_PTR i = (dwSize-1);
                while(i)
                {
                    char * pInstr = GetCall(pLimit[i],FALSE);
                    if (pInstr)
                    {
                        if (strstr(pInstr,"__SEH_"))
                        {
                            // skip those
                        }
                        else
                        {
                            if ((ULONG_PTR)Tib.StackBase > pLimit[i-1] && pLimit[i-1] > (ULONG_PTR)Tib.StackLimit)
                            {
                                dprintf("                     ");
                                GetVTable((MEMORY_ADDRESS)((ULONG_PTR)Tib.StackLimit+i*sizeof(ULONG_PTR)));
                                pInstr = strstr(pInstr,"call");
			                    dprintf("[%p] %p %p - %s",
			                          (ULONG_PTR)Tib.StackLimit+(i-1)*sizeof(ULONG_PTR),
			                          pLimit[i-1],
			                          pLimit[i],
			                          pInstr);
                            }
                        }
                    }
                    i--;
                    if (pCurrentESP) // the user specified a end address
                    {
                        if (((ULONG_PTR)Tib.StackLimit+(i-1)*sizeof(ULONG_PTR)) < pCurrentESP)
                        	break;
                    }
                }
            }
            else
            {
                dprintf("RM %p\n",Tib.StackLimit);
            }
            delete [] pStack;
        }
    }
    else
    {
        dprintf("cannot interpret,%s\b",args);
    }
#endif    
}
//
// given the TEB, prints the ExceptionList
//

struct _C9_REGISTRATION_RECORD
{
    _C9_REGISTRATION_RECORD * prev;
    void * handler;
    void * scopetable;
    void * trylevel;
    void * pSpare0;    
    void * pSpare1;      
};

//
// _C9_REGISTRATION_RECORD.scopetable points to an array of _SCOPETABLE_ENTRY
//

 struct _SCOPETABLE_ENTRY {
    ULONG_PTR enclosing_level;
    VOID * filter;              
    VOID * specific_handler;    
 };

DECLARE_API(el)
{
    INIT_API();

#ifndef _X86_
    dprintf("unsupported on this platform\n");
    return;
#endif
    
    MEMORY_ADDRESS pTeb = GetExpression(args);
    if (pTeb)
    {
        NT_TIB Tib;
        if (ReadMemory(pTeb,&Tib,sizeof(Tib),NULL))
        {
            //Tib.ExceptionList,Tib.StackBase,Tib.StackLimit);
            _C9_REGISTRATION_RECORD ExRegRec;
            ExRegRec.prev = (_C9_REGISTRATION_RECORD *)Tib.ExceptionList;
            do 
            {
   	            _C9_REGISTRATION_RECORD   * pThis = ExRegRec.prev;
	            if (ReadMemory((MEMORY_ADDRESS)pThis,&ExRegRec,sizeof(ExRegRec),NULL))
	            {
                    dprintf("  %p (%p %p %p %p)\n",pThis,ExRegRec.prev,ExRegRec.handler,ExRegRec.scopetable,ExRegRec.trylevel);

#ifdef KDEXT_64BIT
                    ULONG64 Displ;
#else
                    ULONG Displ;
#endif
                    char pString[256];
                    pString[0]=0;
             	    GetSymbol((ULONG_PTR)ExRegRec.handler,(PCHAR)pString,&Displ);
	                if (lstrlenA((CHAR *)pString))
              	        dprintf("    %s+%x\n",pString,Displ);

                    
                    if (!GetCall((ULONG_PTR)ExRegRec.pSpare1))
                    {
                        GetCall((ULONG_PTR)ExRegRec.pSpare0);
                    }
	            }
	            else
	            {
	                dprintf("RM %p\n",Tib.ExceptionList);
	                break;
	            }
            } while((ULONG_PTR)(-1) != (ULONG_PTR)ExRegRec.prev);
        }
        else
        {
            dprintf("RM %p\n",pTeb);
        }
    }
    else
    {
        dprintf("invalid TEB %s\n",args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\utilfun.h ===
#ifndef __UTILFUN_H__
#define __UTILFUN_H__

//
//
//  attempt to imitate the std::tree structures
//

class _BRN {
public:
	_BRN * _Left;
	_BRN * _Parent;
	_BRN * _Right;
	ULONG_PTR Values[3]; // Key Value Color
};

class _BRN_HEAD {
public:
	_BRN * _Left;
	_BRN * _Parent;
	_BRN * _Right;
};


class _QM {
public:
    _BRN * _Left;
	_BRN * _Parent;
	_BRN * _Right;
};

class _Map {
public:
	ULONG_PTR Unused;
	_QM * pQm;
	bool  b;
	ULONG_PTR Size;
};

//
//
//
class _Node_List {
public:
    _Node_List * _Next;
    _Node_List * _Prev;
    void *       _Value;
};

class _List {
public:
    void * _Allocator;
    _Node_List * _Head;
    SIZE_T _Size;
};

class _Vector {
public:
    void * _Allocator;
    void * _First;
    void * _Last;
    void * _End;    
};

class _Deque {
public:
	class iterator {
	public:
		void * _First;
		void * _Last;
		void * _Next;
		void * _Map;		
	};
	void * _Allocator;
	iterator _First, _Last;
	void * _Map;
	SIZE_T _Mapsize, _Size;
};

typedef DWORD (WINAPI * pfnCallBack1)(VOID * pData1);
typedef DWORD (WINAPI * pfnCallBack2)(VOID * pData1,VOID * pData2);
typedef DWORD (WINAPI * pfnCallBack3)(VOID * pData1,VOID * pData2,VOID * pContext);

void
PrintMapCB(_Map * pMap,BOOL Verbose, pfnCallBack2 CallBack);

void
PrintMap(_Map * pMap,BOOL Verbose);

DWORD
CallBackObj(void * pKey, void * pValue);

void
PrintListCB(_List * pList_OOP, pfnCallBack1 CallBack);

void 
PrintDequeCB(MEMORY_ADDRESS pDeque_OOP,pfnCallBack2 CallBack);

BOOL
GetVTable(MEMORY_ADDRESS pThis_OOP);

void
EnumReverseLinkedListCB(IN LIST_ENTRY  * pListHead,
                        IN DWORD         cbSizeOfStructure,
                        IN DWORD         cbListEntryOffset,
                        IN pfnCallBack2  CallBack);

void
EnumLinkedListCB(IN LIST_ENTRY  * pListHead,
                 IN DWORD         cbSizeOfStructure,
                 IN DWORD         cbListEntryOffset,
                 IN pfnCallBack2  CallBack,
                 IN VOID * Context = NULL);

//
// For Dumping CThreadRecord
//
typedef DWORD (WINAPI * pfnDumpRequest)(ULONG_PTR pRequest);

#endif /*__UTILFUN_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\utilfun.cpp ===
#include <wmiexts.h>
#include <malloc.h>
#include <objbase.h>
#include <obase.h>

//IID_IStdIdentity {0000001B-0000-0000-C000-000000000046}
const GUID IID_IStdIdentity = {0x0000001B,0x0000,0x0000,{0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

#include <data.h>

#include <utilfun.h>

DECLARE_API(iid) {

    INIT_API();

    GUID CurrUUID;
    
    MEMORY_ADDRESS pUUID = 0;
    pUUID = GetExpression(args);
    if (pUUID){
        ReadMemory(pUUID,&CurrUUID,sizeof(GUID),0);

        WCHAR pszClsID[40];
        StringFromGUID2(CurrUUID,pszClsID,40);
        WCHAR pszFullPath[MAX_PATH];
        lstrcpyW(pszFullPath,L"Interface\\");
        lstrcatW(pszFullPath,pszClsID);

        char pDataA[MAX_PATH];
        HKEY hKey;
        LONG lRes;

        lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                             pszFullPath,
                             0,
                             KEY_READ,
                             &hKey);

        if (lRes == ERROR_SUCCESS){
            DWORD dwType;
            WCHAR pData[MAX_PATH];
            DWORD dwSize=sizeof(pData);
            
            lRes = RegQueryValueExW(hKey,
                                    NULL, // default
                                    NULL,
                                    &dwType,
                                    (BYTE *)pData,
                                    &dwSize);
            if (lRes == ERROR_SUCCESS) {
                
                WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                dprintf("   IID_%s\n",pDataA);
            }
            RegCloseKey(hKey);
            
        } else {
            
            if (IsEqualGUID(CurrUUID,IID_IMarshal)){
            
               dprintf("    IID_IMarshal\n");
               
            } else if (IsEqualGUID(CurrUUID,IID_IStdIdentity)) {
            
               dprintf("    IID_IStdIdentity\n");    
               
            } else if (IsEqualGUID(CurrUUID,IID_ICallFactory)) {
            
               dprintf("    IID_ICallFactory\n");    
               
            } else {
            
               WideCharToMultiByte(CP_ACP,0,pszClsID,-1,pDataA,sizeof(pDataA),NULL,NULL);
               dprintf("unable to open key %s\n",pDataA);
               
            }
        }

    } else {
      dprintf("unable to resolve %s\n",args);
    }

}

extern ArrayCLSID g_ArrayCLSID[];

DECLARE_API(clsid) {

    INIT_API();

    GUID CurrUUID;
    
    MEMORY_ADDRESS pUUID = 0;
    pUUID = GetExpression(args);
    if (pUUID){
        ReadMemory(pUUID,&CurrUUID,sizeof(GUID),0);

        WCHAR pszClsID[40];
        StringFromGUID2(CurrUUID,pszClsID,40);

        // look-up known
        DWORD i;
        for (i=0;i<g_nClsids;i++){
            if(IsEqualGUID(CurrUUID,*g_ArrayCLSID[i].pClsid)){
                dprintf("    CLSID : %s\n",g_ArrayCLSID[i].pStrClsid);
                break;
            }
        }
        
        WCHAR pszFullPath[MAX_PATH];
        lstrcpyW(pszFullPath,L"CLSID\\");
        lstrcatW(pszFullPath,pszClsID);

        char pDataA[MAX_PATH];
        HKEY hKey;
        LONG lRes;

        lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                             pszFullPath,
                             0,
                             KEY_READ,
                             &hKey);

        if (lRes == ERROR_SUCCESS){
            DWORD dwType;
            WCHAR pData[MAX_PATH];
            DWORD dwSize=sizeof(pData);
            
            lRes = RegQueryValueExW(hKey,
                                    NULL, // default
                                    NULL,
                                    &dwType,
                                    (BYTE *)pData,
                                    &dwSize);
            if (lRes == ERROR_SUCCESS) {
                
                WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                dprintf("    ProgID %s\n",pDataA);
                
            };
            RegCloseKey(hKey);
            
            // no open InProcServer32
            WCHAR pszFullPathDll[MAX_PATH];
            lstrcpyW(pszFullPathDll,pszFullPath);
            lstrcatW(pszFullPathDll,L"\\InprocServer32");

            lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                                 pszFullPathDll,
                                 0,
                                 KEY_READ,
                                 &hKey);
            if (lRes == ERROR_SUCCESS){

                dwSize = sizeof(pData);
                lRes = RegQueryValueExW(hKey,
                                        NULL, // default
                                        NULL,
                                        &dwType,
                                        (BYTE *)pData,
                                        &dwSize);
                                    
                if (lRes == ERROR_SUCCESS) {
                
                    WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                    dprintf("    Path: %s\n",pDataA);
                
                };
            
                RegCloseKey(hKey);
            }
            
        } else {
            
            WideCharToMultiByte(CP_ACP,0,pszClsID,-1,pDataA,sizeof(pDataA),NULL,NULL);
            dprintf("unable to open key %s\n",pDataA);
               
        }

    } else {
      dprintf("unable to resolve %s\n",args);
    }

}

//
//
// Dumps a SAFE_ARRAY
//
//

DECLARE_API(sa) {

    INIT_API();

    SAFEARRAY SA;
    
    MEMORY_ADDRESS pSA = 0;
    pSA = GetExpression(args);
    
    if (pSA){
        ReadMemory(pSA,&SA,sizeof(SA),0);

        dprintf(" cDims %d cbElements %d pvData %08x\n",SA.cDims,SA.cbElements,SA.pvData);
        dprintf("rgsabound.cElements %d lLbound %d\n",SA.rgsabound[0].cElements,SA.rgsabound[0].lLbound);
        
    } else {
        dprintf("invalid address %s\n",args);
    }
}

//
//   help for the extension
//   may commands are not listed here
//
//

DECLARE_API(help) {

    INIT_API();

    dprintf("     WMI debugger extension\n");
    dprintf("     iid     : print the human readable IID_xxx\n");
    dprintf("     clsid   : print the human readable CLSID_xxx\n");
    dprintf("     rot     : print the human readable rpcss!gpClassTable\n");
    dprintf("     gpl     : print the human readable rpcss!gpProcessList\n");
    dprintf("     gipid   : print the global list of IPIDEntry\n");   
    dprintf("     goxid   : print the global list of OXIDEntry\n");
    dprintf("     ipidl   : print the list of IPIDEntry for CStdIdentiry\n");
    dprintf("     srtbl   : print the list of secure reference IPID in ole32!gSRFTbl\n");        
    dprintf("     llc     : print linked list count\n");     
    dprintf("     cs      : print the list of CRITICAL_SECTION\n");    
    dprintf("     std_map : print the first 3 DWORD of a std::map<K,V>\n");
    dprintf("     std_queue: print the first ULONG_PTR of a std::queue<V>\n");    
    dprintf("     std_deque: print the first ULONG_PTR of a std::deque<V>\n");    
    //dprintf("     mapobj  : print a std::map<IUnk,bool>\n");    
    dprintf("     -------- HEAP family\n");
    dprintf("     he      : print the HEAP_ENTRY\n");  
    dprintf("     hef     : walks the HEAP_ENTRY list forward\n");
    dprintf("     hef     : walks the HEAP_ENTRY list backward\n");    
    dprintf("     hs      : print the HEAP_SEGMENT\n");
    dprintf("     hp      : print the HEAP\n");    
    dprintf("     lhp     : <HEAP> prints the LookAside list for the HEAP\n");        
    dprintf("     hps     : print a summary for all the HEAP in the process\n");
    dprintf("     shp     : <HEAP> <ADDR> search heap HEAP for address ADDR\n");    
    dprintf("     rllc    : <ADDR> prints the free list in reverse order\n");
    dprintf("     hpf     : <HEAP> prints the free list of the heap at HEAP\n");    
    dprintf("     php     : <HEAP> [s ADDR] prints the pageheap and searches\n");      
    dprintf("     -------- FASTPROX family\n");    
    dprintf("     wc      : print the human readable WbemClass\n");
    dprintf("     wi      : print the human readable WbemClass\n");    
    dprintf("     blob    : ADDR [size] print (part of) the ClassObject BLOB\n");    
    dprintf("     datap   : ADDR print the WBEMDATA marshaling BLOB\n");    
    dprintf("     cp      : print the human readable CClassPart\n");    
    dprintf("     cvar    : print the CVar\n");     
    dprintf("     -------- WBEMCORE\n");
    dprintf("     q       : print wbemcore!g_pAsyncSvcQueue\n"); 
    dprintf("     arb     : print wbemcore!CWmiArbitrator__m_pArb\n");
    dprintf("     -------- REPDRVFS\n");
    dprintf("     tmpall  : print the Allocators in repdrvfs\n");    
    dprintf("     forestc : [Addr] print the repdrvfs!CForestCache at Addr\n");
    dprintf("     filec   : [Addr] print repdrvfs!CFileCache at Addr\n");
    dprintf("     fmap    : \\fs\\[objects|index].map dumps the .MAP file from disk \n");
    dprintf("     btr     : dumps the index.btr/index.map file from disk \n");    
    dprintf("     varobj  : dumps part of objects.data file from disk \n");    
    dprintf("     -------- THREAD family\n");
    dprintf("     t       : print RPC and OLE data for each thread\n");
    dprintf("     inv     : <addr> [param] invokes a function in the remote thread\n");
    dprintf("     bs      : <teb> rebuilds the stack from the info in the TEB\n");
    dprintf("     st      : <addr> <num> prints the num DWORD saved by RtlCaptureStackBackTrace\n");
    dprintf("     lpp     : print linked list and unassemble backtrace\n");    
    dprintf("     vq      : -a <addr> | -f Flag : calls VirtualQuery on the addr\n");
    dprintf("     srt     : <addr> searches the stacks of all threads for addr\n");    
    dprintf("     ksrt    : <addr> searches the stacks of all threads for addr - KD only\n");    
    dprintf("     el      : <TEB> prints the exception list of the current thread x86 only\n");
    dprintf("     -------- ESS\n");
    dprintf("     ess     : print wbemcore!g_pNewESS\n"); 
    dprintf("     -------- PROVSS\n");
    dprintf("     pc      : print wbemcore!CCoreServices__m_pProvSS\n"); 
    dprintf("     pf      : print CServerObject_BindingFactory\n");
    dprintf("     -------- 32-K-64\n");
    dprintf("     hef64   : <addr> HEAP_ENTRY list forward\n");
    dprintf("     heb64   : <addr> HEAP_ENTRY list backward\n");
    dprintf("     hps64   : print heap summary\n");
    dprintf("     cs64    : print CritSec list\n");    
}

void
EnumLinkedListCB(IN LIST_ENTRY  * pListHead,
                 IN DWORD         cbSizeOfStructure,
                 IN DWORD         cbListEntryOffset,
                 IN pfnCallBack2  CallBack,
                 IN VOID * Context)
{
    LIST_ENTRY   ListHead;
    LIST_ENTRY * pListEntry;
    DWORD        cItems = 0;
    
    void * pStorage = (void *)_alloca(cbSizeOfStructure);
    LIST_ENTRY * pListEntryLocal = (LIST_ENTRY *)((BYTE *)pStorage + cbListEntryOffset);
       
    if (ReadMemory((ULONG_PTR)pListHead,&ListHead,sizeof(LIST_ENTRY),NULL))
    {

        if (CallBack)
        {
        }
        else
        {
            dprintf("    H %p -> %p <-\n",ListHead.Flink,ListHead.Blink);
        }
        
	    for ( pListEntry  = ListHead.Flink;
	          pListEntry != pListHead;)
	    {
	        if (CheckControlC())
                break;

	        ULONG_PTR pStructure_OOP = (ULONG_PTR)((BYTE *) pListEntry - cbListEntryOffset);

	        // make a local copy of the debuggee structure
	        if (ReadMemory(pStructure_OOP,pStorage,cbSizeOfStructure,NULL))
	        {
                if (CallBack)
                {
                    //dprintf("    CallBack %p\n",CallBack);
                    if (NULL == Context)
                    {
                        CallBack((VOID *)pStructure_OOP,pStorage);
                    }
                    else
                    {
                        //dprintf("    CallBackEx %p %p\n",CallBack,Context);                    
                        pfnCallBack3 CallBackEx = (pfnCallBack3)CallBack;
                        CallBackEx((VOID *)pStructure_OOP,pStorage,Context);
                    }
                }
                else
                {
                    dprintf("    %p -> %p <- - %p\n",pListEntryLocal->Flink,pListEntryLocal->Blink,pStructure_OOP);
                }
	        
	            pListEntry = pListEntryLocal->Flink;
	            cItems++;	        
	        }
	        else
	        {
	            dprintf("RM %p\n",pStructure_OOP);
                break;
	        }	       
	    } 

        dprintf( "%d entries traversed\n", cItems );
    }
    else
    {
        dprintf("RM %p\n",pListHead);
    }    

}

void
EnumReverseLinkedListCB(IN LIST_ENTRY  * pListHead,
                        IN DWORD         cbSizeOfStructure,
                        IN DWORD         cbListEntryOffset,
                        IN pfnCallBack2  CallBack)
{
    LIST_ENTRY   ListHead;
    LIST_ENTRY * pListEntry;
    DWORD        cItems = 0;
    
    void * pStorage = (void *)_alloca(cbSizeOfStructure);
    LIST_ENTRY * pListEntryLocal = (LIST_ENTRY *)((BYTE *)pStorage + cbListEntryOffset);
       
    if (ReadMemory((ULONG_PTR)pListHead,&ListHead,sizeof(LIST_ENTRY),NULL))
    {

        if (CallBack)
        {
        }
        else
        {
            dprintf("    H %p -> %p <-\n",ListHead.Flink,ListHead.Blink);
        }
        
	    for ( pListEntry  = ListHead.Blink;
	          pListEntry != pListHead;)
	    {
	        if (CheckControlC())
                break;

	        ULONG_PTR pStructure_OOP = (ULONG_PTR)((BYTE *) pListEntry - cbListEntryOffset);

	        // make a local copy of the debuggee structure
	        if (ReadMemory(pStructure_OOP,pStorage,cbSizeOfStructure,NULL))
	        {
                if (CallBack)
                {
                    CallBack((VOID *)pStructure_OOP,pStorage);
                }
                else
                {
                    dprintf("    %p -> %p <- - %p\n",pListEntryLocal->Flink,pListEntryLocal->Blink,pStructure_OOP);
                }
	        
	            pListEntry = pListEntryLocal->Blink;
	            cItems++;	        
	        }
	        else
	        {
	            dprintf("RM %p\n",pStructure_OOP);
                break;
	        }	       
	    } 

        dprintf( "%d entries traversed\n", cItems );
    }
    else
    {
        dprintf("RM %p\n",pListHead);
    }    

}


//
//
// NO-OP callback just for getting the number of items
//
///////////////////////////////////////////////////////////

DWORD
CallBackListCount(VOID * pStructure_OOP,
                  VOID * pLocalCopy)
{
    return 0;
}

DECLARE_API( llc )
{
    INIT_API();

    MEMORY_ADDRESS Addr = GetExpression(args);

    if (Addr)
    {
        EnumLinkedListCB((LIST_ENTRY *)Addr,sizeof(LIST_ENTRY),0,CallBackListCount);
    }
    else
    {
        dprintf("cannot resolve %s\n",args);
    }
}

void
PrintStackTrace(MEMORY_ADDRESS ArrayAddr_OOP,DWORD dwNum,BOOL bOOP)
{
    MEMORY_ADDRESS * pArray;
    BOOL bRet = FALSE;
    if (bOOP)
    {
        pArray = ( MEMORY_ADDRESS *)_alloca(dwNum*sizeof(MEMORY_ADDRESS));
        bRet = ReadMemory(ArrayAddr_OOP,pArray,dwNum*sizeof(MEMORY_ADDRESS),NULL);
    }
    else
    {
        pArray = (MEMORY_ADDRESS *)ArrayAddr_OOP;
        bRet = TRUE;
    }
    
    if (bRet)
    {
        DWORD i;
        for (i=0;i<dwNum;i++)
        {
	        BYTE pString[256];
	        pString[0] = 0;

#ifdef KDEXT_64BIT        
	        ULONG64 Displ = 0;
#else
    	    ULONG Displ = 0;
#endif
            if (pArray[i])
            {
	        	GetSymbol(pArray[i],(PCHAR)pString,&Displ);
		        pString[255] = 0;
    		    dprintf("    %s+%x\n",pString,Displ);
    	    }
        }
    }
}

//
// printf stack trace
//
DECLARE_API( st )
{
    INIT_API();
    
    int Len = strlen(args);
    CHAR * pArgs = (CHAR *)_alloca((Len+1));
    lstrcpy(pArgs,(CHAR *)args);

    MEMORY_ADDRESS NumInst = 6;
    MEMORY_ADDRESS pAddr = 0;
    
    while (isspace(*pArgs))
    {
        pArgs++;
    }
     
    CHAR * pFirst = pArgs;
    
    while(!isspace(*pArgs)) pArgs++;
    // terminate string, if possible    
    if (isspace(*pArgs))
    {
        *pArgs = 0;
        pArgs++;
    }
    else
    {
        pArgs = NULL;
    }

    pAddr = GetExpression(pFirst);

    if (pArgs)
    {
        NumInst = GetExpression(pArgs);
    }

    if (pAddr)
    {
        dprintf("StackTrace @ %p num %d\n",pAddr,NumInst);
        PrintStackTrace(pAddr,(DWORD)NumInst,TRUE);
    }
    else
    {
        dprintf("usage: address num\n");
    }    
}

//
//
//  this is the CallBack called by the enumerator
//  of a Double-Liked list of objects with
//  struct _Instrument 
//  {
//      LIST_ENTRY ListEntry;
//      ULONG_PTR  ArrayFuncts[32];
//  }
//
//////////////////////////////////////////////////////////

DWORD
CallBackCreateStacks(VOID * pStructure_OOP,
                     VOID * pLocalStructure)
{
    dprintf("    ----- %p \n",pStructure_OOP);
    PrintStackTrace((ULONG_PTR)((BYTE *)pLocalStructure+sizeof(LIST_ENTRY)),6,FALSE);
    return 0;
} 

DECLARE_API( lpp )
{
    INIT_API();

    MEMORY_ADDRESS Addr = GetExpression(args);
    
    if (Addr)
    {
	    EnumLinkedListCB((LIST_ENTRY *)Addr,
	                     sizeof(LIST_ENTRY)+32*sizeof(ULONG_PTR),
	                     0,
	                     CallBackCreateStacks);
    }
    else
    {
        dprintf("cannot resolve %s\n",args);
    }

}   

//
//
//
/////////////

void PrintDequeCB(MEMORY_ADDRESS pDeque_OOP,pfnCallBack2 pCallBack)
{
    _Deque Deque;
    if (ReadMemory(pDeque_OOP,&Deque,sizeof(Deque),NULL))
    {
        dprintf("    std::deque @ %p _Allocator %p head %p tail %p _Size %p\n",pDeque_OOP,Deque._Allocator,Deque._First._Next,Deque._Last._Next,Deque._Size);
        ULONG_PTR Size = Deque._Size;
        ULONG_PTR ByteSize = (ULONG_PTR)Deque._Last._Next-(ULONG_PTR)Deque._First._Next;
        ULONG_PTR pArray_OOP = (ULONG_PTR)Deque._First._Next;
        BYTE * pArray = NULL;
        if (Size)
            pArray = (BYTE *)HeapAlloc(GetProcessHeap(),0,ByteSize);
        if (pArray)
        {
            ULONG_PTR SizeElem = ByteSize/Size;
            if (ReadMemory(pArray_OOP,pArray,(ULONG)ByteSize,0))
            {
                for (ULONG_PTR i=0;i<Size;i++)
                {
                    dprintf("        %p -[%p] %p\n",i,pArray_OOP+i*SizeElem,*((void **)(&pArray[i*SizeElem])));
                    if (pCallBack)
                    {
                        // address OOP and address of the In-Proc opy of the memory are passed down
                        pCallBack((void *)(pArray_OOP+i*SizeElem),(void *)(&pArray[i*SizeElem]));
                    }    
                }
            }
            else
            {
                dprintf("RM %p\n",pArray_OOP);
            }
            HeapFree(GetProcessHeap(),0,pArray);
        }
    }
    else
    {
        dprintf("RM %p\n",pDeque_OOP);
    }
}

//
//
// prints a generic std::deque
//
////////////////////////////////////


DECLARE_API( std_deque )
{

    INIT_API();

    _Deque * pDeque = (_Deque *)GetExpression( args );

    if (pDeque)
    {   
        PrintDequeCB((MEMORY_ADDRESS)pDeque,NULL);        
    } 
    else 
    {
        dprintf("invalid address %s\n",args);
    }
    
}



// left parent right

BOOL
IsNil(_BRN * pNode){

    _BRN_HEAD BRN;
    ReadMemory((ULONG_PTR)pNode,&BRN,sizeof(_BRN_HEAD),NULL);

	return ((BRN._Left == NULL) && 		    
			(BRN._Right == NULL));
}

void 
PrintTree(_BRN * pNode,
          DWORD * pNum,
          BOOL Verbose,
          ULONG_PTR Size,
          pfnCallBack2 CallBack){

    //dprintf(" Node %p\n",pNode);
    _BRN BRN;
    if (ReadMemory((ULONG_PTR)pNode,&BRN,sizeof(_BRN),NULL))
    {    
		if (!IsNil(BRN._Left)){
			PrintTree(BRN._Left,pNum,Verbose,Size,CallBack);
		};

	    if (CheckControlC())
	        return;
	    
	    if (pNum){
	      (*pNum)++;
	    }

	    if (*pNum > Size) 
	    {
	        dprintf("invalid tree\n");
	        return;
	    }
	         
	    if (Verbose) {
		    dprintf("    %p %p (%p,%p,%p) - %p %p %p\n",
		             (*pNum)-1,
		             pNode,
		             BRN._Left,BRN._Parent,BRN._Right,
		             BRN.Values[0],
		             BRN.Values[1],
		             BRN.Values[2]);
		    if (CallBack)
		    {
		        //dprintf("CAllBack\n");
		        CallBack((VOID *)BRN.Values[0],(VOID *)BRN.Values[1]);
		    }
		}

		if (!IsNil(BRN._Right)){
			PrintTree(BRN._Right,pNum,Verbose,Size,CallBack);
		};
	}
	else
	{
	    dprintf("    RM %p err %d\n",pNode,GetLastError());
	}
}


void
PrintMapCB(_Map * pMap,BOOL Verbose, pfnCallBack2 CallBack)
{

    _Map MAP;
    
    if (ReadMemory((ULONG_PTR)pMap,&MAP,sizeof(_Map),NULL))
    {
        if (MAP.pQm)
        {
            dprintf("    std::map at %p : size %p\n",pMap,MAP.Size);
                        
            _QM QM;
                                 
            if (ReadMemory((ULONG_PTR)MAP.pQm,&QM,sizeof(QM),NULL))
            {
	            if (QM._Parent && !IsNil(QM._Parent))
	            {
	                DWORD Num = 0;
	                PrintTree(QM._Parent,&Num,Verbose,MAP.Size,CallBack);
	                dprintf("    traversed %d nodes\n",Num);
	            }
            } 
            else
            {
                dprintf("RM %p err %d\n",MAP.pQm,GetLastError());
            }
        } else {
           dprintf("empty tree\n");
        }
    }
    else
    {
        dprintf("RM %p\n",pMap);
    }
}


//
//
// prints a generic std::map
//
////////////////////////////////////


DECLARE_API( std_map )
{

    INIT_API();

    _Map * pMap = (_Map *)GetExpression( args );

    if (pMap){
    
        PrintMapCB(pMap,TRUE,NULL);
        
    } else {
        dprintf("invalid address %s\n",args);
    }
    
}

void
PrintListCB(_List * pList_OOP, pfnCallBack1 CallBack)
{
    _List List;
    if (ReadMemory((ULONG_PTR)pList_OOP,&List,sizeof(_List),NULL))
    {
        dprintf("    std::queue @ %p _Allocator %p _Head %p _Size %p\n",pList_OOP,List._Allocator,List._Head,List._Size);
        _Node_List NodeList;
        
        if (ReadMemory((ULONG_PTR)List._Head,&NodeList,sizeof(_Node_List),NULL))
        {
	        _Node_List * pNodeList = NodeList._Next;
	        
	        DWORD i = 0;
	        
	        while (pNodeList != List._Head)
	        {
	            if (CheckControlC())
	                break;
	                
	            if (ReadMemory((ULONG_PTR)pNodeList,&NodeList,sizeof(_Node_List),NULL))
	            {
	                dprintf("    %x %p (%p, %p) - %p\n",i++,pNodeList,NodeList._Next,NodeList._Prev,NodeList._Value);
	                if (CallBack)
	                {
	                    CallBack(NodeList._Value);
	                }

	                pNodeList = NodeList._Next; 
	            }
	            else
	            {
	                dprintf("RM %p\n",pNodeList);
	            }
	        }
        }
        else
	    {
	        dprintf("RM %p\n",List._Head);
	    }        
    }
    else
    {
        dprintf("RM %p\n",pList_OOP);
    }
}


//
//
//  prints a generic std::list
//
//////////////////////////////////////

DECLARE_API( std_queue)
{
    INIT_API();

    _List * pList = (_List *)GetExpression( args );

    if (pList){
    
        PrintListCB(pList,NULL);
        
    } else {
        dprintf("invalid address %s\n",args);
    }

}

//
//
//  this is for Pat
//  he has a std::map<pObject,BOOL>
//
//////////////////////////////////////////////////

DWORD
CallBackObj(void * pKey, void * pValue)
{
    GetVTable((MEMORY_ADDRESS)pKey);
    return 0;
}

DECLARE_API( mapobj )
{

    INIT_API();


    _Map * pMap = (_Map *)GetExpression( args );

    if (pMap){
    
        PrintMapCB(pMap,TRUE,CallBackObj);
        
    } else {
        dprintf("invalid address %s\n",args);
    }
    
}


void PrintIID(GUID & CurrUUID){

        WCHAR pszClsID[40];
        StringFromGUID2(CurrUUID,pszClsID,40);
        WCHAR pszFullPath[MAX_PATH];
        lstrcpyW(pszFullPath,L"Interface\\");
        lstrcatW(pszFullPath,pszClsID);

        char pDataA[MAX_PATH];
        HKEY hKey;
        LONG lRes;

        lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                             pszFullPath,
                             0,
                             KEY_READ,
                             &hKey);

        if (lRes == ERROR_SUCCESS){
            DWORD dwType;
            WCHAR pData[MAX_PATH];
            DWORD dwSize=sizeof(pData);
            
            lRes = RegQueryValueExW(hKey,
                                    NULL, // default
                                    NULL,
                                    &dwType,
                                    (BYTE *)pData,
                                    &dwSize);
            if (lRes == ERROR_SUCCESS) {
                
                WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                dprintf("        IID_%s\n",pDataA);
            }
            RegCloseKey(hKey);
            
        } else {
            
            if (IsEqualGUID(CurrUUID,IID_IMarshal)){
            
               dprintf("        IID_IMarshal\n");
               
            } else if (IsEqualGUID(CurrUUID,IID_IStdIdentity)) {
            
               dprintf("        IID_IStdIdentity\n");    
               
            } else if (IsEqualGUID(CurrUUID,IID_ICallFactory)) {
            
               dprintf("        IID_ICallFactory\n");    
               
            } else {
            
               WideCharToMultiByte(CP_ACP,0,pszClsID,-1,pDataA,sizeof(pDataA),NULL,NULL);
               dprintf("        %s\n",pDataA);
               
            }
        }

}

class OXIDEntry;
class CCtxComChnl;
class IRCEntry;

typedef GUID IPID;

typedef enum tagIPIDFLAGS
{
    IPIDF_CONNECTING     = 0x1,     // ipid is being connected
    IPIDF_DISCONNECTED   = 0x2,     // ipid is disconnected
    IPIDF_SERVERENTRY    = 0x4,     // SERVER IPID vs CLIENT IPID
    IPIDF_NOPING         = 0x8,     // dont need to ping the server or release
    IPIDF_COPY           = 0x10,    // copy for security only
    IPIDF_VACANT         = 0x80,    // entry is vacant (ie available to reuse)
    IPIDF_NONNDRSTUB     = 0x100,   // stub does not use NDR marshaling
    IPIDF_NONNDRPROXY    = 0x200,   // proxy does not use NDR marshaling
    IPIDF_NOTIFYACT      = 0x400,   // notify activation on marshal/release
    IPIDF_TRIED_ASYNC    = 0x800,   // tried to call this server interface async
    IPIDF_ASYNC_SERVER   = 0x1000,  // server implements an async interface
    IPIDF_DEACTIVATED    = 0x2000,  // IPID has been deactivated
    IPIDF_WEAKREFCACHE   = 0x4000,  // IPID holds weak references in refcache
    IPIDF_STRONGREFCACHE = 0x8000   // IPID holds strong references in refcache
} IPIDFLAGS;

typedef struct tagIPIDEntry
{
    struct tagIPIDEntry *pNextIPID;  // next IPIDEntry for same object

// WARNING: next 6 fields must remain in their respective locations
// and in the same format as the IPIDTmp structure above.
    DWORD                dwFlags;      // flags (see IPIDFLAGS)
    ULONG                cStrongRefs;  // strong reference count
    ULONG                cWeakRefs;    // weak reference count
    ULONG                cPrivateRefs; // private reference count
    void                *pv;           // real interface pointer
    IUnknown            *pStub;        // proxy or stub pointer
    OXIDEntry           *pOXIDEntry;   // ptr to OXIDEntry in OXID Table
// WARNING: previous 7 fields must remain in their respective locations
// and in the same format as the IPIDTmp structure above.

    IPID                 ipid;         // interface pointer identifier
    IID                  iid;          // interface iid
    CCtxComChnl         *pChnl;        // channel pointer
    IRCEntry            *pIRCEntry;    // reference cache line
    struct tagIPIDEntry *pOIDFLink;    // In use OID list
    struct tagIPIDEntry *pOIDBLink;
} IPIDEntry;

void PrintIPIDFlags(DWORD Flags)
{
    if (Flags & IPIDF_CONNECTING) dprintf("IPIDF_CONNECTING ");
    if (Flags & IPIDF_DISCONNECTED) dprintf("IPIDF_DISCONNECTED ");
    if (Flags & IPIDF_SERVERENTRY) dprintf("IPIDF_SERVERENTRY ");    
    if (Flags & IPIDF_NOPING) dprintf("IPIDF_NOPING ");         
    if (Flags & IPIDF_COPY) dprintf("IPIDF_COPY ");   
    if (Flags & IPIDF_VACANT) dprintf("IPIDF_VACANT ");
    if (Flags & IPIDF_NONNDRSTUB) dprintf("IPIDF_NONNDRSTUB ");
    if (Flags & IPIDF_NONNDRPROXY) dprintf("IPIDF_NONNDRPROXY ");
    if (Flags & IPIDF_NOTIFYACT) dprintf("IPIDF_NOTIFYACT ");
    if (Flags & IPIDF_TRIED_ASYNC) dprintf("IPIDF_TRIED_ASYNC ");
    if (Flags & IPIDF_ASYNC_SERVER) dprintf("IPIDF_ASYNC_SERVER ");
    if (Flags & IPIDF_DEACTIVATED) dprintf("IPIDF_DEACTIVATED ");
    if (Flags & IPIDF_WEAKREFCACHE) dprintf("IPIDF_WEAKREFCACHE ");
    if (Flags & IPIDF_WEAKREFCACHE) dprintf("IPIDF_WEAKREFCACHE ");
};

void DumpIPID(IPIDEntry & IpId)
{
	dprintf("    pNextIPID    %p\n",IpId.pNextIPID);
	dprintf("    dwFlags      "); PrintIPIDFlags(IpId.dwFlags); dprintf("\n");
	dprintf("    cStrongRefs  %08x\n",IpId.cStrongRefs);  
	dprintf("    cWeakRefs    %08x\n",IpId.cWeakRefs);
	dprintf("    cPrivateRefs %08x\n",IpId.cPrivateRefs);
	dprintf("    pv           %p\n",IpId.pv);
	GetVTable((ULONG_PTR)IpId.pv);
	dprintf("    pStub        %p\n",IpId.pStub);
	dprintf("    pOXIDEntry   %p\n",IpId.pOXIDEntry);
	PrintIID(IpId.ipid);
	PrintIID(IpId.iid);
	dprintf("    pChnl        %p\n",IpId.pChnl);
	dprintf("    pIRCEntry    %p\n",IpId.pIRCEntry);
	//dprintf("    pOIDFLink    %p\n",IpId.pOIDFLink);
	//dprintf("    pOIDBLink    %p\n",IpId.pOIDBLink);
}

DECLARE_API( gipid )
{
    INIT_API();

    char * pString = (CHAR *)args;
    CLSID ClsidToSearch;
    BOOL bClsIdFound = FALSE;
    if (pString)
    {
        while (isspace((char)pString)) pString++;
        WCHAR pClsid[64];
        DWORD nChar = 0;
        for (;*pString && nChar < 64;nChar++,pString++)
        {
            pClsid[nChar] = (WCHAR)(*pString);
        }
        pClsid[nChar] = 0;
        
        if (SUCCEEDED(CLSIDFromString(pClsid,&ClsidToSearch)))
            bClsIdFound = TRUE;
    }

    IPIDEntry  gIpId;
    MEMORY_ADDRESS Addr  = GetExpression("ole32!CIPIDTable___oidListHead");
    if (Addr)
    {
        dprintf("ole32!CIPIDTable___oidListHead @ %p\n",Addr);

        DWORD nItems = 0;
        gIpId.pOIDFLink = (IPIDEntry *)Addr;
        do
        {
            MEMORY_ADDRESS pCurrentIPID = (MEMORY_ADDRESS)gIpId.pOIDFLink;
		    if (ReadMemory(pCurrentIPID,&gIpId,sizeof(gIpId),NULL))
		    {
		        if (bClsIdFound)
		        {
		            if (0 == memcmp(&gIpId.ipid,&ClsidToSearch,sizeof(CLSID)))
		            {
                        DumpIPID(gIpId);                
		            }
		        }
		        else
		        {
    		        if (nItems > 0) 
    		        {
    		            dprintf("  -------- tagIPIDEntry %p - %x\n",pCurrentIPID,nItems-1);
                        DumpIPID(gIpId);
    		        }		        
    		        nItems++;
		        }
		    }
		    else
		    {
		        dprintf("RM %p\n",Addr);
		        break;
		    }
			if (CheckControlC())
                break;		    
        } while (Addr != (MEMORY_ADDRESS)gIpId.pOIDFLink);
    }
    else
    {
        dprintf("uanble to resolve ole32!CIPIDTable___oidListHead\n");
    }    
}

typedef GUID MOXID;
typedef ULONG64 MID;
typedef void CComApartment;
typedef void CChannelHandle;
typedef void MIDEntry;
typedef void IRemUnknown;

class OXIDEntry
{
private:    
    OXIDEntry          *_pNext;         // next entry on free/inuse list
    OXIDEntry          *_pPrev;         // previous entry on inuse list
    DWORD               _dwPid;         // process id of server
    DWORD               _dwTid;         // thread id of server
    MOXID               _moxid;         // object exporter identifier + machine id
    MID                 _mid;           // copy of our _pMIDEntry's mid value
    IPID                _ipidRundown;   // IPID of IRundown and Remote Unknown
    DWORD               _dwFlags;       // state flags
    HWND                _hServerSTA;    // HWND of server
    CComApartment      *_pParentApt;    // Parent apartment, not ref counted
public:
    // CODEWORK: channel accessing this member variable directly
    CChannelHandle     *_pRpc;          // Binding handle info for server
private:
    void               *_pAuthId;       // must be held till rpc handle is freed
    DUALSTRINGARRAY    *_pBinding;      // protseq and security strings.
    DWORD               _dwAuthnHint;   // authentication level hint.
    DWORD               _dwAuthnSvc;    // index of default authentication service.
    MIDEntry           *_pMIDEntry;     // MIDEntry for machine where server lives
    IRemUnknown        *_pRUSTA;        // proxy for Remote Unknown
    LONG                _cRefs;         // count of IPIDs using this OXIDEntry
    HANDLE              _hComplete;     // set when last outstanding call completes
    LONG                _cCalls;        // number of calls dispatched
    LONG                _cResolverRef;  //References to resolver
    DWORD               _dwExpiredTime; // rundown timer ID for STA servers
    COMVERSION          _version;       // COM version of the machine
    unsigned long       _ulMarshaledTargetInfoLength; // credman credentials length
    unsigned char       *_pMarshaledTargetInfo; // credman credentials

    
};

void PrintDSA(DUALSTRINGARRAY * pDSA_OOP)
{
    if (pDSA_OOP)
    {
        DUALSTRINGARRAY DSA;
        if (ReadMemory((ULONG_PTR)pDSA_OOP,&DSA,sizeof(DSA),NULL))
        {
            DWORD Size = sizeof(DUALSTRINGARRAY)+(1+DSA.wNumEntries)*sizeof(WCHAR);
            DUALSTRINGARRAY * pDSA = (DUALSTRINGARRAY *)_alloca(Size);
            if (ReadMemory((ULONG_PTR)pDSA_OOP,pDSA,Size,0))
            {
                dprintf("          %S\n",pDSA->aStringArray);
            }
            else
            {
                dprintf("RM %p\n",pDSA_OOP);
            }                        
        }
        else
        {
            dprintf("RM %p\n",pDSA_OOP);
        }
    }
}

void PrintOxid(OXIDEntry * pEntry)
{
    // _pNext           
    // _pPrev           
    dprintf("        _dwPid       %x\n",pEntry->_dwPid);
    dprintf("        _dwTid       %x\n",pEntry->_dwTid);  
    dprintf("        _moxid\n");          
    PrintIID(pEntry->_moxid);
    dprintf("        _mid         %016x\n",pEntry->_mid);         
    dprintf("        _ipidRundown\n");
    PrintIID(pEntry->_ipidRundown);
    dprintf("        _dwFlags     %08x\n",pEntry->_dwFlags);
    dprintf("        _hServerSTA  %p\n",pEntry->_hServerSTA);
    dprintf("        _pParentApt  %p\n",pEntry->_pParentApt);   
    dprintf("        _pRpc        %p\n",pEntry->_pRpc);   
    dprintf("        _pAuthId     %p\n",pEntry->_pAuthId);
    dprintf("        _pBinding    %p\n",pEntry->_pBinding);
    PrintDSA(pEntry->_pBinding);
    dprintf("        _dwAuthnHint %x\n",pEntry->_dwAuthnHint);
    dprintf("        _dwAuthnSvc  %x\n",pEntry->_dwAuthnSvc);
    dprintf("        _pMIDEntry   %p\n",pEntry->_pMIDEntry);
    dprintf("        _pRUSTA      %p\n",pEntry->_pRUSTA);
    dprintf("        _cRefs       %x\n",pEntry->_cRefs);
    dprintf("        _hComplete   %x\n",pEntry->_hComplete);
    dprintf("        _cCalls      %x\n",pEntry->_cCalls);
    dprintf("        _cResolverRef %x\n",pEntry->_cResolverRef);
    // _dwExpiredTime   
    // _version         
    // _ulMarshaledTargetInfoLength
    // _pMarshaledTargetInfo  
}

DECLARE_API( goxid )
{
    INIT_API();
    ULONG_PTR Addr     = GetExpression("ole32!gOXIDTbl");
    if (NULL == Addr)
    {
        dprintf("unable to resolve ole32!gOXIDTbl\n");
        return;
    }
    struct OxidTable
    {
        DWORD _cExpired;
        OXIDEntry _InUseHead;
        OXIDEntry _ExpireHead;
        OXIDEntry _CleanupHead;
    } _OxidTable;
    if (ReadMemory(Addr,&_OxidTable,sizeof(_OxidTable),NULL))
    {
        OXIDEntry * pHead_OOP;
        DWORD nEntry;
        
        
        pHead_OOP = (OXIDEntry *)GetExpression("ole32!COXIDTable::_InUseHead");
        nEntry = 0;

        dprintf("ole32!gOXIDTbl:_InUseHead %p\n",pHead_OOP);

        ULONG_PTR AddrToRead = (ULONG_PTR)pHead_OOP;
        do
        {
            if (ReadMemory(AddrToRead,&_OxidTable._InUseHead,sizeof(OXIDEntry),NULL))
            {
                if (nEntry)
                {
                   dprintf("    OXIDEntry %p - %d\n",AddrToRead,nEntry-1);
                   PrintOxid(&_OxidTable._InUseHead);
                }
                AddrToRead = (ULONG_PTR)_OxidTable._InUseHead._pNext;                
            }
            else
            {
                dprintf("RM %p\n",AddrToRead);
            }
            nEntry++;
			if (CheckControlC())
                break;		                
        }
        while (pHead_OOP != _OxidTable._InUseHead._pNext);
        
        pHead_OOP = (OXIDEntry *)GetExpression("ole32!COXIDTable::_ExpireHead");        
        nEntry = 0;
        dprintf("ole32!gOXIDTbl:_ExpireHead %p\n",pHead_OOP);        

        AddrToRead = (ULONG_PTR)pHead_OOP;
        do
        {
            if (ReadMemory(AddrToRead,&_OxidTable._InUseHead,sizeof(OXIDEntry),NULL))
            {
                if (nEntry)
                {
                   dprintf("    OXIDEntry %p - %d\n",AddrToRead,nEntry-1);
                   PrintOxid(&_OxidTable._InUseHead);
                }
                AddrToRead = (ULONG_PTR)_OxidTable._InUseHead._pNext;                
            }
            else
            {
                dprintf("RM %p\n",AddrToRead);
            }
            nEntry++;
			if (CheckControlC())
                break;		                
        }
        while (pHead_OOP != _OxidTable._InUseHead._pNext);
        
        
        pHead_OOP = (OXIDEntry *)GetExpression("ole32!COXIDTable::_CleanupHead");        
        nEntry = 0;
        dprintf("ole32!gOXIDTbl:_InUseHead %p\n",pHead_OOP);        

        AddrToRead = (ULONG_PTR)pHead_OOP;
        do
        {
            if (ReadMemory(AddrToRead,&_OxidTable._InUseHead,sizeof(OXIDEntry),NULL))
            {
                if (nEntry)
                {
                   dprintf("    OXIDEntry %p - %d\n",AddrToRead,nEntry-1);
                   PrintOxid(&_OxidTable._InUseHead);
                }
                AddrToRead = (ULONG_PTR)_OxidTable._InUseHead._pNext;                
            }
            else
            {
                dprintf("RM %p\n",AddrToRead);
            }
            nEntry++;
			if (CheckControlC())
                break;		                
        }
        while (pHead_OOP != _OxidTable._InUseHead._pNext);


    }
    else
    {
        dprintf("RM %p\n",Addr);
    }
}

DECLARE_API( ipidl )
{
    INIT_API();

    IPIDEntry  IpId;
    MEMORY_ADDRESS Addr = GetExpression(args);
    
    if (Addr) 
    {
    
        DWORD nCount=0;

        while (Addr &&
               ReadMemory(Addr,&IpId,sizeof(IpId),NULL))
        {
            dprintf("    -- %x\n",nCount);
            DumpIPID(IpId);

            Addr = (MEMORY_ADDRESS)IpId.pNextIPID;
            nCount++;

            if (CheckControlC())
                break;
            
        };        
    } 
    else 
    {
        dprintf(" unable to resolve %s\n",args);
    }
    
}


void PrintCLSID(GUID & CurrUUID){

        WCHAR pszClsID[40];
        StringFromGUID2(CurrUUID,pszClsID,40);

        // look-up known
        DWORD i;
        for (i=0;i<g_nClsids;i++){
            if(IsEqualGUID(CurrUUID,*g_ArrayCLSID[i].pClsid)){
                dprintf("    CLSID  %s\n",g_ArrayCLSID[i].pStrClsid);
                break;
            }
        }
        
        WCHAR pszFullPath[MAX_PATH];
        lstrcpyW(pszFullPath,L"CLSID\\");
        lstrcatW(pszFullPath,pszClsID);

        char pDataA[MAX_PATH];
        HKEY hKey;
        LONG lRes;

        lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                             pszFullPath,
                             0,
                             KEY_READ,
                             &hKey);

        if (lRes == ERROR_SUCCESS){
            DWORD dwType;
            WCHAR pData[MAX_PATH];
            DWORD dwSize=sizeof(pData);
            
            lRes = RegQueryValueExW(hKey,
                                    NULL, // default
                                    NULL,
                                    &dwType,
                                    (BYTE *)pData,
                                    &dwSize);
            if (lRes == ERROR_SUCCESS) {
                
                WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                dprintf("    ProgID %s\n",pDataA);
                
            };
            RegCloseKey(hKey);
            
            // no open InProcServer32
            WCHAR pszFullPathDll[MAX_PATH];
            lstrcpyW(pszFullPathDll,pszFullPath);
            lstrcatW(pszFullPathDll,L"\\InprocServer32");

            lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                                 pszFullPathDll,
                                 0,
                                 KEY_READ,
                                 &hKey);
            if (lRes == ERROR_SUCCESS){

                dwSize = sizeof(pData);
                lRes = RegQueryValueExW(hKey,
                                        NULL, // default
                                        NULL,
                                        &dwType,
                                        (BYTE *)pData,
                                        &dwSize);
                                    
                if (lRes == ERROR_SUCCESS) {
                
                    WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                    dprintf("    Path: %s\n",pDataA);
                
                };
            
                RegCloseKey(hKey);
            }
            
        } else {
            
            WideCharToMultiByte(CP_ACP,0,pszClsID,-1,pDataA,sizeof(pDataA),NULL,NULL);
            dprintf("    CLSID %s\n",pDataA);
               
        }


}

class CTableElement;

class CHashTable
{
private:    
    DWORD _cBuckets;
    DWORD _cElements;
    CTableElement **_buckets;
    CTableElement *_last;
};

typedef int EnumEntryType;
typedef void CSharedLock;
typedef void CServerTable;
class CProcess;

class CServerList
{
public:
    void * _first;
    void * _last;        
};

class CServerTableEntry{
private:
    void * pvtable;
    DWORD _references;
    CServerTableEntry * _pnext;

    //CLSID _GUID;
    unsigned __int64 _id1;
    unsigned __int64 _id2;

    EnumEntryType       _EntryType;

    CSharedLock       * _pParentTableLock;
    CServerTable      * _pParentTable;
    LONG                _lThreadToken;
    DWORD               _dwProcessId;
    HANDLE              _hProcess;
    CProcess*           _pProcess;
    void              * _pvRunAsHandle;
    BOOL                _bSuspendedClsid;
    BOOL                _bSuspendedApplication;

    // the _bRetired flag exists per-running process/application

    CServerList         _ServerList;
    //CSharedLock         _ServerLock;

    
};

/*
0:008> dt rpcss!CServerListEntry 000a2608
   +0x008 _flink           : (null)
   +0x00c _blink           : (null)
   +0x000 __VFN_table : 0x757f3a58
   +0x004 _references      :
   +0x010 _pServerTableEntry : 0x000a3e38
   +0x014 _pServerProcess  : 0x00092568
   +0x018 _hRpc            : (null)
   +0x01c _ipid            : _GUID {0000dc01-0304-0000-905a-1b00ffec5639}
   +0x02c _Context         : 0x2 ''
   +0x02d _State           : 0 ''
   +0x02e _NumCalls        : 0
   +0x030 _RegistrationKey : 0x10
   +0x034 _lThreadToken    : 0
   +0x038 _SubContext      : 0 ''
   +0x03c _lSingleUseStatus : 0
   +0x040 _dwServerFaults  : 0
*/

struct CServerListEntry
{
    void * pvtable;
    DWORD  _references;    
    void * _flink;
    void * _blink;
    void * _pServerTableEntry;
    void * _pServerProcess;
    void * _hRpc;
    GUID   _ipid;    
};

/*
0:002> dt rpcss!CServerTableEntry 6fb`ffcdb170
   +0x000 __VFN_table : 0x00000000`702a2b60
   +0x008 _references      :
   +0x010 _pnext           : (null)
   +0x018 _id              : 0x11d0f196`61738644
   +0x020 _id2             : 0xc119d94f`c0005399
   +0x028 _EntryType       : 0 ( ENTRY_TYPE_CLASS )
   +0x030 _pParentTableLock : 0x000006fb`ffc9d590
   +0x038 _pParentTable    : 0x000006fb`ffc9d700
   +0x040 _bComPlusProcess : 0
   +0x044 _lThreadToken    : 0
   +0x048 _dwProcessId     : 0
   +0x050 _hProcess        : (null)
   +0x058 _pProcess        : (null)
   +0x060 _pvRunAsHandle   : (null)
   +0x068 _bSuspendedClsid : 0
   +0x06c _bSuspendedApplication : 0
   +0x070 _ServerList      : CServerList
   +0x080 _ServerLock      : CSharedLock
*/

DECLARE_API( rot )
{

    INIT_API();

    CHashTable * pChashTable;
    MEMORY_ADDRESS Addr = GetExpression("rpcss!gpClassTable");
    if (Addr) 
    {
        CHashTable * pChashTable;    
        CHashTable MyHashTable;
        
        if (ReadMemory(Addr,&pChashTable,sizeof(CHashTable *),0))
        {
            dprintf("CServerTable %p\n",pChashTable);
            
            if (ReadMemory((ULONG_PTR)pChashTable,&MyHashTable,sizeof(CHashTable),NULL))
            {
                CTableElement ** StackArray = (CTableElement **)_alloca(MyHashTable._cBuckets * sizeof(CTableElement *));
                
                ReadMemory((ULONG_PTR)MyHashTable._buckets,StackArray,MyHashTable._cBuckets * sizeof(CTableElement *),NULL);            

                DWORD i;
                for (i=0;i<MyHashTable._cBuckets;i++)
                {
                    CServerTableEntry * pEntry = (CServerTableEntry *)StackArray[i];
                    
                    while (pEntry)
                     {                
                        CheckControlC();
                        CServerTableEntry ClassEntry;
                        if (ReadMemory((ULONG_PTR)pEntry,&ClassEntry,sizeof(ClassEntry),NULL))
                        {                    
                            dprintf("CServerTableEntry %p\n",pEntry);
                            PrintCLSID(*(GUID *)(&(ClassEntry._id1)));
                            //dprintf("    _hProcess %x\n",ClassEntry._hProcess);                        
                            //dprintf("    _dwProcessId %d\n",ClassEntry._dwProcessId);
                            dprintf("    _ServerList %p %p\n",ClassEntry._ServerList._first,ClassEntry._ServerList._last);

                            CServerListEntry * pSrvListEntry = CONTAINING_RECORD(ClassEntry._ServerList._first,CServerListEntry,_flink);
                            while(pSrvListEntry)
                            {
                                CServerListEntry SrvListEntry;
                                if (ReadMemory((ULONG_PTR)pSrvListEntry,&SrvListEntry,sizeof(SrvListEntry),NULL))
                                {
                                    dprintf("      CServerListEntry %p\n",pSrvListEntry);
                                    dprintf("           _pServerTableEntry %p\n",SrvListEntry._pServerTableEntry);
                                    dprintf("           _pServerProcess    %p\n",SrvListEntry._pServerProcess);
                                    dprintf("           _hRpc              %p\n",SrvListEntry._hRpc);
                                    WCHAR TmpGuid[64];
                                    StringFromGUID2(SrvListEntry._ipid,TmpGuid,64);
                                    dprintf("           _ipid              %S\n",TmpGuid);
                                    pSrvListEntry = (CServerListEntry *)SrvListEntry._flink;
                                }
                                else
                                {
                                    dprintf("RM %p\n",pSrvListEntry);
                                    pSrvListEntry = NULL;
                                }
                            }
                            
                            pEntry = ClassEntry._pnext;
                        }
                        else
                        {
                            dprintf("RM %p\n",pEntry);
                            pEntry = NULL;
                        }
                    }
                }
            }
            else
            {
                dprintf("RM %p\n",pChashTable);    
            }
        }
        else
        {
            dprintf("RM %p\n",Addr);
        }
    } 
    else 
    {
        dprintf("unable to resolve rpcss!gpClassTable");
    }
    
}

class CBList
{
public:
    ULONG   _ulmaxData;
    ULONG   _ulcElements;
    PVOID  *_data;
};

class CReferencedObject
{
public:
    ULONG _references;
    virtual ~CReferencedObject(){};
};

class CToken;
class ScmProcessReg;
class CList;

class CListElement
{
public:
    CListElement *_flink;
    CListElement *_blink;
};

class CClassReg : public CListElement
{
public :
    GUID    _Guid;
    DWORD   _Reg;
};

class CList
{
private:
    CListElement *_first;
    CListElement *_last;
};

class CProcess : public CReferencedObject
{
private:

    DWORD               _cClientReferences;
    CToken             *_pToken;
    WCHAR              *_pwszWinstaDesktop;
    RPC_BINDING_HANDLE  _hProcess;
    BOOL                _fCacheFree;
    DUALSTRINGARRAY    *_pdsaLocalBindings;
    DUALSTRINGARRAY    *_pdsaRemoteBindings;
    ULONG               _ulClasses;
    ScmProcessReg      *_pScmProcessReg;
    DUALSTRINGARRAY    *_pdsaCustomProtseqs;
    void               *_pvRunAsHandle;
    DWORD               _procID;
    volatile DWORD      _dwFlags;
    void*               _pSCMProcessInfo;
    GUID                _guidProcessIdentifier;
    HANDLE              _hProcHandle;
    FILETIME            _ftCreated;
    DWORD64             _dwCurrentBindingsID;
    DWORD               _dwAsyncUpdatesOutstanding; // for debug purposes?

    void                *_pvFirstROTEntry;

    BOOL                _fReadCustomProtseqs;
    CBList              _blistOxids;
    CBList              _blistOids;
    CList               _listClasses;

    DWORD               _cDropTargets;
};


DECLARE_API(gpl)
{
    INIT_API();    
    //dt rpcss!gpProcessList 
    ULONG_PTR Addr = GetExpression("rpcss!gpProcessList");
    if (Addr)
    {
        CBList * pList_OOP;
        if (ReadMemory(Addr,&pList_OOP,sizeof(ULONG_PTR),NULL))
        {
            CBList List;
            if (ReadMemory((ULONG_PTR)pList_OOP,&List,sizeof(List),0))
            {
                PVOID * ppData = new PVOID[List._ulmaxData];
                if (ppData)
                {
                    if (ReadMemory((ULONG_PTR)List._data,ppData,sizeof(PVOID)*List._ulmaxData,NULL))
                    {
                        for (ULONG_PTR i=0;i<List._ulmaxData;i++)
                        {
                            CProcess * pProc = (CProcess *)ppData[i];
                            if (pProc)
                            {
                                CProcess Proc;
                                if (ReadMemory((ULONG_PTR)pProc,&Proc,sizeof(Proc),0))
                                {
                                    dprintf("  CProcess %p\n",pProc);
                                    dprintf("      _procID %08x BINDING_HANDLE %p\n",Proc._procID,Proc._hProcess);

                                    CClassReg ClassRegInst;
                                    CClassReg * pFirst = (CClassReg *)Proc._listClasses._first;
                                    while(pFirst)
                                    {
                                        if (ReadMemory((ULONG_PTR)pFirst,&ClassRegInst,sizeof(ClassRegInst),0))
                                        {
                                            PrintCLSID(ClassRegInst._Guid);
                                            pFirst = (CClassReg *)ClassRegInst._flink;
                                        }
                                        else
                                        {
                                            dprintf("RM %p\n",pFirst);
                                            break;
                                        }
                                    }
                                    
                                }
                                else
                                {
                                    dprintf("RM %p\n",pProc);
                                }
                            }
                        }
                    }
                    else
                    {
                        dprintf("RM %p\n",List._data);
                    }
                    delete [] ppData;
                }
            }
            else
            {
                dprintf("RM %p\n",pList_OOP);
            }        
        }
        else
        {
            dprintf("RM %p\n",Addr);
        }
    }
    else
    {
        dprintf("unable to resolve rpcss!gpProcessList");
    }
}


typedef struct SHashChain
{
    struct SHashChain *pNext;       // ptr to next node in chain
    struct SHashChain *pPrev;       // ptr to prev node in chain
} SHashChain;


typedef struct SNameHashNode
{
    SHashChain       chain;         // double linked list ptrs
    DWORD            dwHash;        // hash value of the key
    ULONG            cRef;          // count of references
    IPID             ipid;          // ipid holding the reference
    SECURITYBINDING  sName;         // user name
} SNameHashNode;


class  COleStaticMutexSem;
class CStaticRWLock;

class CHashTable2
{
public:
    virtual ~CHashTable2(){};
    
    COleStaticMutexSem *_pExLock;     // exclusive lock
    CStaticRWLock      *_pRWLock;     // read-write lock
    SHashChain         *_buckets;     // ptr to array of double linked lists
    ULONG               _cCurEntries; // current num entries in the table
    ULONG               _cMaxEntries; // max num entries in the table at 1 time
};

void PrintNameNode(SNameHashNode * pNode)
{
	dprintf("    dwHash %08x\n",pNode->dwHash);        // hash value of the key
	dprintf("    cRef   %08x\n",pNode->cRef);          // count of references
	dprintf("    ipid\n");
	PrintIID(pNode->ipid);          // ipid holding the reference
	dprintf("    sName  %S\n",&pNode->sName.aPrincName);    
}


#define NUM_HASH_BUCKETS 23

DECLARE_API( srtbl )
{

    INIT_API();

    CHashTable2 * pChashTable;
    MEMORY_ADDRESS Addr = GetExpression("ole32!gSRFTbl");
    if (Addr) 
    {
        dprintf("CNameHashTable %p\n",Addr);        
        CHashTable2 MyHashTable;            
        if (ReadMemory((ULONG_PTR)Addr,&MyHashTable,sizeof(CHashTable2),NULL))
        {
            SHashChain * StackArray = (SHashChain *)_alloca(NUM_HASH_BUCKETS * sizeof(SHashChain));
            
            ReadMemory((ULONG_PTR)MyHashTable._buckets,StackArray,NUM_HASH_BUCKETS * sizeof(SHashChain),NULL);

            DWORD i;
            SHashChain * pEntry_OOP = (SHashChain *)MyHashTable._buckets;
            for (i=0;i < NUM_HASH_BUCKETS;pEntry_OOP++,i++)
            {
                SHashChain * pEntry = StackArray[i].pNext;    
                //dprintf("%p %p\n",pEntry_OOP,pEntry);
                while (pEntry != pEntry_OOP)
                {  
                    if (CheckControlC()) break;
                    
                    struct _NameNode : SNameHashNode 
                    {
                        WCHAR UserName[256];
                    } Node;
                    Node.UserName[0] = 0;
                    if (ReadMemory((ULONG_PTR)pEntry,&Node,sizeof(Node),NULL))
                    {
                        dprintf("SNameHashNode %p\n",pEntry);
                        PrintNameNode(&Node);
                        pEntry = Node.chain.pNext;
                    }
                    else
                    {
                        dprintf("RM %p\n");
                        break;
                    }
                }
            }
        }
        else
        {
            dprintf("RM %p\n",Addr);
        }        
    } 
    else 
    {
        dprintf("unable to resolve ole32!gSRFTbl");
    }
    
}



/*
struct RTL_CRITICAL_SECTION_DEBUG {
   USHORT Type;             //: 0x0
   USHORT CreatorBackTraceIndex; //: 0x0
   CRITICAL_SECTION * CriticalSection;  //: 0x77fcae40
   LIST_ENTRY ProcessLocksList; //:
   DWORD EntryCount;       //: 0x0
   DWORD ContentionCount;  //: 0x0
   DWORD Spare[2];         //:0x0
};
*/

//
//
//  CallBack for enumeration of critical section
//
//
/////////////////////////////////////////////////////////////

DWORD
EnumListCritSec(VOID * pStructure_OOP,
                VOID * pLocalStructure)
{

    RTL_CRITICAL_SECTION_DEBUG * pDebugInfo = (RTL_CRITICAL_SECTION_DEBUG *)pLocalStructure;
    dprintf("    CS %p DI %p \n",pDebugInfo->CriticalSection,pStructure_OOP);

    RTL_CRITICAL_SECTION CritSec;

    if (ReadMemory((ULONG_PTR)pDebugInfo->CriticalSection,&CritSec,sizeof(RTL_CRITICAL_SECTION),NULL))
    {
        dprintf("       - %p %x %x %x\n",
                CritSec.DebugInfo,
                CritSec.LockCount,
                CritSec.RecursionCount,
                CritSec.OwningThread);
    }
    else
    {
         dprintf("RM %p\n",pDebugInfo->CriticalSection);
    }
    return 0;
}

#define ARRAY_TO_GO_BACK   16

DWORD
EnumListCritSec2(VOID * pStructure_OOP,
                VOID * pLocalStructure)
{

    RTL_CRITICAL_SECTION_DEBUG * pDebugInfo = (RTL_CRITICAL_SECTION_DEBUG *)pLocalStructure;
    dprintf("    CS %p DI %p \n",pDebugInfo->CriticalSection,pStructure_OOP);

    struct _TmpStr {
        ULONG_PTR    Array[ARRAY_TO_GO_BACK];
        RTL_CRITICAL_SECTION CritSec;
    } TmpStr;

    if (ReadMemory(((ULONG_PTR)pDebugInfo->CriticalSection) - FIELD_OFFSET(_TmpStr,CritSec),&TmpStr,sizeof(_TmpStr),NULL))
    {
        dprintf("       - %p %x %x %x\n",
                TmpStr.CritSec.DebugInfo,
                TmpStr.CritSec.LockCount,
                TmpStr.CritSec.RecursionCount,
                TmpStr.CritSec.OwningThread);

        for (int i=(ARRAY_TO_GO_BACK-1);i>=0;i--)
        {
            if (GetVTable((MEMORY_ADDRESS)TmpStr.Array[i]))
            {
                break; // don't be too verbose
            }
        }
    }
    else
    {
         dprintf("RM around %p\n",pDebugInfo->CriticalSection);
    }
    return 0;
}


DECLARE_API( cs )
{
    INIT_API();

    MEMORY_ADDRESS Addr = GetExpression("ntdll!RtlCriticalSectionList");

    MEMORY_ADDRESS bGoAndFindVTable = TRUE;

    if (!Addr)
    {
        Addr = GetExpression(args);
    }
    else
    {
        bGoAndFindVTable = GetExpression(args);
    }
    
    if (Addr) 
    {
        if (bGoAndFindVTable)
        {
	        EnumLinkedListCB((LIST_ENTRY  *)Addr,
	                         sizeof(RTL_CRITICAL_SECTION_DEBUG),
	                         FIELD_OFFSET(RTL_CRITICAL_SECTION_DEBUG,ProcessLocksList),	                         
	                         EnumListCritSec2);        
        }
        else
        {       
	        EnumLinkedListCB((LIST_ENTRY  *)Addr,
	                         sizeof(RTL_CRITICAL_SECTION_DEBUG),
	                         FIELD_OFFSET(RTL_CRITICAL_SECTION_DEBUG,ProcessLocksList),	                         
	                         EnumListCritSec);
        }	                         
    } 
    else 
    {
        dprintf("unable to resolve ntdll!RtlCriticalSectionList\n");
    }
    
}


BOOL
GetVTable(MEMORY_ADDRESS pThis_OOP){

    MEMORY_ADDRESS pVTable;
    ReadMemory(pThis_OOP,&pVTable,sizeof(pVTable),0);
    
    BYTE pString[256];
    pString[0]=0;

#ifdef KDEXT_64BIT
        ULONG64 Displ;
#else
        ULONG Displ;
#endif
    
    GetSymbol(pVTable,(PCHAR)pString,&Displ);
    if (lstrlenA((CHAR *)pString))
    {
        dprintf("          %s+%x\n",pString,Displ);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/*
kd> dt ntdll!RTL_CRITICAL_SECTION
   +0x000 DebugInfo        : Ptr64 _RTL_CRITICAL_SECTION_DEBUG
   +0x008 LockCount        : Int4B
   +0x00c RecursionCount   : Int4B
   +0x010 OwningThread     : Ptr64 Void
   +0x018 LockSemaphore    : Ptr64 Void
   +0x020 SpinCount        : Uint8B
kd> dt ntdll!_RTL_CRITICAL_SECTION_DEBUG
   +0x000 Type             : Uint2B
   +0x002 CreatorBackTraceIndex : Uint2B
   +0x008 CriticalSection  : Ptr64 _RTL_CRITICAL_SECTION
   +0x010 ProcessLocksList : _LIST_ENTRY
   +0x020 EntryCount       : Uint4B
   +0x024 ContentionCount  : Uint4B
   +0x028 Spare            : [2] Uint4B
kd>
*/

#ifdef KDEXT_64BIT

struct _LIST_ENTRY_64
{
    ULONG64 Flink;
    ULONG64 Blink;
};

struct _RTL_CRITICAL_SECTION_64 
{
   ULONG64 DebugInfo;
   DWORD   LockCount;
   DWORD   RecursionCount;
   ULONG64 OwningThread;
   ULONG64 LockSemaphore;
   ULONG64 SpinCount;
};

struct _RTL_CRITICAL_SECTION_DEBUG_64
{
   WORD    Type;             
   WORD    CreatorBackTraceIndex;
   ULONG64 CriticalSection;  
   _LIST_ENTRY_64 ProcessLocksList;
   DWORD EntryCount;     
   DWORD ContentionCount;
   DWORD Spare;
};

#endif /*KDEXT_64BIT*/

DECLARE_API(cs64)
{
    INIT_API();
#ifdef KDEXT_64BIT

    _RTL_CRITICAL_SECTION_DEBUG_64 DebugInfo;
    _RTL_CRITICAL_SECTION_64 CritSec;
    _LIST_ENTRY_64 ListEntry;
    ULONG64  MemAddr = GetExpression(args);

    if (MemAddr)
    {
        ULONG64 AddrHead = MemAddr;
        if (ReadMemory(MemAddr,&ListEntry,sizeof(ListEntry),NULL))
        {
            DebugInfo.ProcessLocksList.Flink = ListEntry.Flink;
            while (DebugInfo.ProcessLocksList.Flink != AddrHead)
            {
        		if (CheckControlC())
        		    break;

        		MemAddr = DebugInfo.ProcessLocksList.Flink - FIELD_OFFSET(_RTL_CRITICAL_SECTION_DEBUG_64,ProcessLocksList);

        		if (ReadMemory((MEMORY_ADDRESS)MemAddr,&DebugInfo,sizeof(DebugInfo),NULL))
        		{
        		    dprintf("    C %p D %p\n",DebugInfo.CriticalSection,MemAddr);
        		    
                    if (ReadMemory((MEMORY_ADDRESS)DebugInfo.CriticalSection,&CritSec,sizeof(CritSec),NULL))
                    {
                        dprintf("    - CS %p %x %x %p\n",
                                CritSec.DebugInfo,
                                CritSec.LockCount,
                                CritSec.RecursionCount,
                                CritSec.OwningThread);
                    }
                    else
                    {
                        dprintf("RM %p\n",DebugInfo.CriticalSection);
                    }
        		}
        		else
        		{
        		    break;
        		}
            }
        }
        else
        {
            dprintf("RM %p\n",MemAddr);
        }
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
    
#endif /*KDEXT_64BIT*/    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\a51fib.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51_FIBER__H_
#define __A51_FIBER__H_

class CFiberTask
{
public:
    virtual ~CFiberTask(){}
    virtual HRESULT Execute() = 0;
};

void* CreateFiberForTask(CFiberTask* pTask);
void ReturnFiber(void* pFiber);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\wmiexts.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wmiexts.h

Author:

    Ivan Brugiolo
    
Revision History:

--*/

# ifndef _WMIEXTS_H_
# define _WMIEXTS_H_

#ifdef _WIN64
  #define KDEXT_64BIT
#else
  #define KDEXT_32BIT
#endif

#ifdef KDEXT_64BIT
  #define MEMORY_ADDRESS ULONG64
#else
  #define MEMORY_ADDRESS ULONG_PTR
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>

#ifdef PowerSystemMaximum
#undef PowerSystemMaximum
#endif

#include <windows.h>
#include <wdbgexts.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <stdlib.h>


//
// To obtain the private & protected members of C++ class,
// fake the "private" keyword
//
#define private    public
#define protected  public


//
// Turn off dllexp et al so this DLL won't export tons of unnecessary garbage.
//



/************************************************************
 *   Macro Definitions
 ************************************************************/

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
extern USHORT g_MajorVersion;
extern USHORT g_MinorVersion;

extern BOOL g_KD;


#define moveBlock(dst, src, size)\
__try {\
    ReadMemory( (ULONG_PTR)(src), (PVOID)&(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#define MoveWithRet(dst, src, retVal)\
__try {\
    ReadMemory( (ULONG_PTR)(src), (PVOID)&(dst), sizeof(dst), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return  retVal;\
}

#define MoveBlockWithRet(dst, src, size, retVal)\
__try {\
    ReadMemory( (ULONG_PTR)(src), (PVOID)&(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return retVal;\
}

#ifdef _WIN64
#define INIT_API()                                                                       \
    LPSTR lpArgumentString = (LPSTR)args;                                                \
  	ExtensionCurrentProcess = hCurrentProcess;                                           
#else
#define INIT_API()                                                                       \
    LPSTR lpArgumentString = (LPSTR)args;                                                \
  	ExtensionCurrentProcess = hCurrentProcess;                                           \
   	if (ExtensionApis.nSize != sizeof(WINDBG_EXTENSION_APIS)){                           \
   	    WINDBG_OLD_EXTENSION_APIS * pOld = (WINDBG_OLD_EXTENSION_APIS *)&ExtensionApis;  \
   	    *pOld = *((WINDBG_OLD_EXTENSION_APIS *)dwProcessor);                             \
	}
#endif	


# define BoolValue( b) ((b) ? "    TRUE" : "   FALSE")


#define DumpDword( symbol )                                     \
        {                                                       \
            ULONG_PTR dw = 0;                                   \
            if (ExtensionApis.nSize != sizeof(WINDBG_EXTENSION_APIS)){ \
                dw = GetExpression( "&" symbol );               \
            } else {                                            \
                dw = GetExpression( symbol );                   \
            };                                                  \
			                                                    \
            ULONG_PTR dwValue = 0;                              \
            if ( dw )                                           \
            {                                                   \
                if ( ReadMemory( (ULONG_PTR) dw,                \
                                 &dwValue,                      \
                                 sizeof(dwValue),               \
                                 NULL ))                        \
                {                                               \
                    dprintf( "\t" symbol "   = %8d (0x%p)\n",   \
                             dwValue,                           \
                             dwValue );                         \
                }                                               \
            }                                                   \
        }


//
// C++ Structures typically require the constructors and most times
//  we may not have default constructors
//  => trouble in defining a copy of these struct/class inside the
//     Debugger extension DLL for debugger process
// So we will define them as CHARACTER arrays with appropriate sizes.
// This is okay, since we are not really interested in structure as is,
//  however, we will copy over data block from the debuggee process to
//  these structure variables in the debugger process.
//
# define DEFINE_CPP_VAR( className, classVar) \
   CHAR  classVar[sizeof(className)]

# define GET_CPP_VAR_PTR( className, classVar) \
   (className * ) &classVar

//
//
// commonly used functions
//
////////////////////////////////////////////////////////////////

void GetPeb(HANDLE hSourceProcess, PEB ** ppPeb, ULONG_PTR * pId = NULL);
void GetTeb(HANDLE hThread,TEB ** ppTeb);
void GetCid(HANDLE hThread,CLIENT_ID * pCid);

void PrintStackTrace(MEMORY_ADDRESS ArrayAddr_OOP,DWORD dwNum,BOOL bOOP);

#ifndef KDEXT_64BIT

/**

   Routine to get offset of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.

 **/

__inline
ULONG
GetFieldOffset (
   IN LPCSTR     Type,
   IN LPCSTR     Field,
   OUT PULONG   pOffset
   )
{
   FIELD_INFO flds = {
       (PUCHAR)Field,
       (PUCHAR)"",
       0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0,
       NULL};

   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM),
      (PUCHAR)Type,
      DBG_DUMP_NO_PRINT,
      0,
      NULL,
      NULL,
      NULL,
      1,
      &flds
   };

   ULONG Err;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   return Err;
}



#endif

# endif //  _WMIEXTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\a51fib.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <wbemcomn.h>
#include "a51fib.h"
#include <tls.h>

void CALLBACK A51FiberBase(void* p)
{
    CFiberTask* pTask = (CFiberTask*)p;
    pTask->Execute();

    //
    // No need to clean up --- it's the job of our caller
    //
}

void* CreateFiberForTask(CFiberTask* pTask)
{
    return CreateFiber(0, A51FiberBase, pTask);
}

void ReturnFiber(void* pFiber)
{
    DeleteFiber(pFiber);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\a51rep.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51PROV__H_
#define __A51PROV__H_

#include <windows.h>
#include <wbemidl.h>
#include <unk.h>
#include <wbemcomn.h>
#include <sync.h>
#include <reposit.h>
#include <wmiutils.h>
#include <objpath.h>
#include <filecach.h>
#include <hiecache.h>
#include <corex.h>
#include "a51fib.h"
#include "creposit.h"

class CAutoTransaction;
class CDbIterator;
class CRepEvent
{
public:
	DWORD m_dwType;
	WString m_wszArg1;
       WString m_wszNamespace;
	_IWmiObject* m_pObj1;
	_IWmiObject* m_pObj2;

	CRepEvent(DWORD dwType, LPCWSTR wszNamespace, LPCWSTR wszArg1, 
                _IWmiObject* pObj1, _IWmiObject* pObj2);
	virtual ~CRepEvent();
};

class CEventCollector
{
protected:
    CUniquePointerArray<CRepEvent> m_apEvents;
    bool m_bNamespaceOnly;
    CCritSec m_csLock;

public:
    CEventCollector() : m_bNamespaceOnly(false){ }
    ~CEventCollector() { }
    bool AddEvent(CRepEvent* pEvent);
    void SetNamespaceOnly(bool bNamespaceOnly) 
        {m_bNamespaceOnly = bNamespaceOnly;}
    bool IsNamespaceOnly() {return m_bNamespaceOnly;}

    HRESULT SendEvents(_IWmiCoreServices* pCore);

    void DeleteAllEvents();

    void TransferEvents(CEventCollector &aEventsToTransfer);

    int GetSize() { return m_apEvents.GetSize(); }
};
    


class CSession : public CUnkBase<IWmiDbSessionEx, &IID_IWmiDbSessionEx>
{
friend CAutoTransaction;
private:
    CEventCollector m_aTransactedEvents;
    bool m_bInWriteTransaction;

public:
    CSession(CLifeControl* pControl = NULL) : TUnkBase(pControl), m_bInWriteTransaction(false) {}

    virtual ~CSession();

    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE GetObject(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE GetObjectDirect(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

    HRESULT STDMETHODCALLTYPE PutObject(
         IWmiDbHandle *pScope,
         REFIID riid,
        LPVOID pObj,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE DeleteObject(
         IWmiDbHandle *pScope,
         DWORD dwFlags,
         REFIID riid,
         LPVOID pObj
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
         IWmiDbHandle *pScope,
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        DWORD *dwMessageFlags,
        IWmiDbIterator **ppQueryResult
        );
    HRESULT STDMETHODCALLTYPE RenameObject(
         IWbemPath *pOldPath,
         IWbemPath *pNewPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE Enumerate(
         IWmiDbHandle *pScope,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbIterator **ppQueryResult
        );

    HRESULT STDMETHODCALLTYPE AddObject(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE RemoveObject (
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE SetDecoration(
         LPWSTR lpMachineName,
         LPWSTR lpNamespacePath
        );

    HRESULT STDMETHODCALLTYPE SupportsQueries( 
         DWORD *dwQuerySupportLevel
         ) {return WBEM_E_FAILED;};

    HRESULT STDMETHODCALLTYPE GetObjectByPath(
         IWmiDbHandle *pScope,
         LPCWSTR wszPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

	HRESULT STDMETHODCALLTYPE DeleteObjectByPath(
		IWmiDbHandle *pScope,
		LPCWSTR wszObjectPath,
		DWORD dwFlags
    );

    HRESULT STDMETHODCALLTYPE ExecQuerySink(
		IWmiDbHandle *pScope,
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWbemObjectSink* pSink,
        DWORD *dwMessageFlags
        );

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

	HRESULT STDMETHODCALLTYPE BeginWriteTransaction(DWORD dwFlags);

    HRESULT STDMETHODCALLTYPE BeginReadTransaction(DWORD dwFlags);

	HRESULT STDMETHODCALLTYPE CommitTransaction(DWORD dwFlags);

	HRESULT STDMETHODCALLTYPE AbortTransaction(DWORD dwFlags);
protected:
	HRESULT InternalBeginTransaction(bool bWriteOperation);
	HRESULT InternalAbortTransaction(bool bWriteOperation);
	HRESULT InternalCommitTransaction(bool bWriteOperation);
};
class CLocalizationUpgrade;

class CNamespaceHandle : public CUnkBase<IWmiDbHandle, &IID_IWmiDbHandle>
{
friend CLocalizationUpgrade;
protected:

    static long s_lActiveRepNs;

    CRepository * m_pRepository;
    WString m_wsNamespace;
    WString m_wsScope;
    WString m_wsFullNamespace;
    WCHAR m_wszMachineName[MAX_COMPUTERNAME_LENGTH+1];

    WCHAR m_wszClassRootDir[MAX_PATH];
    long m_lClassRootDirLen;

    WCHAR m_wszInstanceRootDir[MAX_PATH];
    long m_lInstanceRootDirLen;

    CHierarchyCache* m_pClassCache;

    _IWmiObject* m_pNullClass;
    bool m_bCached;

	bool m_bUseIteratorLock;

public:
    CNamespaceHandle(CLifeControl* pControl, CRepository * pRepository);
    ~CNamespaceHandle();
    

    STDMETHOD(GetHandleType)(DWORD* pdwType) {*pdwType = 0; return S_OK;}

    HRESULT Initialize(LPCWSTR wszNamespace, LPCWSTR wszScope = NULL);
    HRESULT Initialize2(LPCWSTR wszNamespace, LPCWSTR wszNamespaceHash);

    HRESULT GetObject(
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT GetObjectDirect(
         IWbemPath *pPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

    HRESULT PutObject(
         REFIID riid,
        LPVOID pObj,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult,
		CEventCollector &aEvents
        );

    HRESULT DeleteObject(
         DWORD dwFlags,
         REFIID riid,
         LPVOID pObj,
		 CEventCollector &aEvents
        );

    HRESULT ExecQuery(
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        DWORD *dwMessageFlags,
        IWmiDbIterator **ppQueryResult
        );

    HRESULT GetObjectByPath(
        LPWSTR wszPath,
        DWORD dwFlags,
        REFIID riid,
        LPVOID *pObj
       );

    HRESULT ExecQuerySink(
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWbemObjectSink* pSink,
        DWORD *dwMessageFlags
        );

	HRESULT DeleteObjectByPath(DWORD dwFlags, LPWSTR wszPath, CEventCollector &aEvents);
    HRESULT GetErrorStatus();
    void SetErrorStatus(HRESULT hres);

	HRESULT CreateSystemClasses(CFlexArray &aSystemClasses);

	void TellIteratorNotToLock() { m_bUseIteratorLock = false; }

protected:
    HRESULT GetObjectHandleByPath(LPWSTR wszBuffer, DWORD dwFlags,
            DWORD dwRequestedHandleType, IWmiDbHandle **ppResult);
    HRESULT PutInstance(_IWmiObject* pInst, DWORD dwFlags, CEventCollector &aEvents);
    HRESULT PutClass(_IWmiObject* pClass, DWORD dwFlags, CEventCollector &aEvents);
    HRESULT ConstructClassRelationshipsDir(LPCWSTR wszClassName,
                                CFileName& wszDirPath);
    HRESULT WriteParentChildRelationship(LPCWSTR wszChildFileName, 
                                LPCWSTR wszParentName);
    HRESULT ExecClassQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                            IWbemObjectSink* pSink, DWORD dwFlags);
    HRESULT ExecInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 

                                LPCWSTR wszClassName, bool bDeep,
                                IWbemObjectSink* pSink);
    HRESULT GetClassDirect(LPCWSTR wszClassName, REFIID riid, void** ppObj,
                            bool bClone, __int64* pnTime,
                            bool* pbRead, bool *pbSystemClass);
	HRESULT DeleteInstance(LPCWSTR wszClassName, LPCWSTR wszKey, CEventCollector &aEvents);
	HRESULT DeleteInstanceByFile(LPCWSTR wszFilePath, _IWmiObject* pClass, 
                            bool bClassDeletion, CEventCollector &aEvents);
	HRESULT DeleteClass(LPCWSTR wszClassName, CEventCollector &aEvents,bool bDisableEvents);
	HRESULT DeleteClassInstances(LPCWSTR wszClassName, _IWmiObject* pClass, CEventCollector &aEvents);
    HRESULT FileToSystemClass(LPCWSTR wszFileName, _IWmiObject** ppClass, 
                            bool bClone, __int64* pnTime = NULL);
    HRESULT FileToClass(LPCWSTR wszFileName, _IWmiObject** ppClass, 
                            bool bClone, __int64* pnTime, 
							bool *pbSystemClass);
    HRESULT FileToInstance(_IWmiObject* pClass,
					   LPCWSTR wszFileName, 
					   BYTE *pRetrievedBlob,
					   DWORD dwSize,
					   _IWmiObject** ppInstance,
                       bool bMustBeThere = false);
    HRESULT WriteInstanceReferences(_IWmiObject* pInst, LPCWSTR wszClassName,
                                    LPCWSTR wszFilePath);
    HRESULT WriteInstanceReference(LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringClass,
                            LPCWSTR wszReferringProp, LPWSTR wszReference);
    HRESULT ExecClassRefQuery(LPCWSTR wszQuery, LPCWSTR wszClassName,
                                                    IWbemObjectSink* pSink);
    HRESULT ExecReferencesQuery(LPCWSTR wszQuery, IWbemObjectSink* pSink);
    HRESULT ExecInstanceRefQuery(LPCWSTR wszQuery, LPCWSTR wszClassName,
                                    LPCWSTR wszKey, IWbemObjectSink* pSink);
    HRESULT GetReferrerFromFile(LPCWSTR wszReferenceFile,
                                LPWSTR wszReferrerRelFile, 
                                LPWSTR* pwszReferrerNamespace,
                                LPWSTR* pwszReferrerClass,
                                LPWSTR* pwszReferrerProp);
    HRESULT DeleteInstanceReference(LPCWSTR wszOurFilePath,
                                            LPWSTR wszReference);
    HRESULT DeleteInstanceReferences(_IWmiObject* pInst, LPCWSTR wszFilePath);

    HRESULT EnumerateClasses(IWbemObjectSink* pSink,
                                LPCWSTR wszSuperClass, LPCWSTR wszAncestor,
                                bool bClone, bool bDontIncludeAncestorInResultSet);
    HRESULT ListToEnum(CWStringArray& wsClasses, 
                                        IWbemObjectSink* pSink, bool bClone);

    bool Hash(LPCWSTR wszName, LPWSTR wszHash);
    HRESULT InstanceToFile(IWbemClassObject* pInst, LPCWSTR wszClassName,
                            LPCWSTR wszFileName1, LPCWSTR wszFileName2,
							__int64 nClassTime);
    HRESULT ConstructInstanceDefName(CFileName& wszInstanceDefName, LPCWSTR wszKey);
    HRESULT ClassToFile(_IWmiObject* pSuperClass, _IWmiObject* pClass, 
                        LPCWSTR wszFileName, __int64 nFakeUpdateTime = 0);
    HRESULT ComputeKeyFromPath(LPWSTR wszPath, LPWSTR wszKey, size_t dwKeyLen,
                                LPWSTR* pwszClassName, bool* pbIsClass,
                                LPWSTR* pwszNamespace = NULL);
    HRESULT ParseKey(LPWSTR wszKeyStart, LPWSTR* pwcRealStart,
                                    LPWSTR* pwcNextKey);

    HRESULT GetInstanceByKey(LPCWSTR wszClassName, LPCWSTR wszKey,
                                REFIID riid, void** ppObj);
    HRESULT WriteClassRelationships(_IWmiObject* pClass, LPCWSTR wszFileName);
    HRESULT ConstructParentChildFileName(LPCWSTR wszChildFileName, 
                                    LPCWSTR wszParentName,
                                    CFileName& wszParentChildFileName);
    HRESULT DeleteDerivedClasses(LPCWSTR wszClassName, CEventCollector &aEvents, bool bDisableEvents);
    HRESULT EraseParentChildRelationship(LPCWSTR wszChildFileName, 
                                        LPCWSTR wszParentName);
    HRESULT EraseClassRelationships(LPCWSTR wszClassName,
                                _IWmiObject* pClass, LPCWSTR wszFileName);
    HRESULT GetClassByHash(LPCWSTR wszHash, bool bClone, _IWmiObject** ppClass,
                            __int64* pnTime, bool* pbRead,
							bool *pbSystemClass);
    HRESULT DeleteClassByHash(LPCWSTR wszHash, CEventCollector &aEvents,bool bDisableEvents);
    HRESULT DeleteClassInternal(LPCWSTR wszClassName,
    	                 _IWmiObject* pClass,
                         LPCWSTR wszFileName, 
                         CEventCollector &aEvents,
						 bool bSystemClass,
						 bool bDisableEvents);
    HRESULT GetChildHashes(LPCWSTR wszClassName, CWStringArray& wsChildHashes);
    HRESULT GetChildDefs(LPCWSTR wszClassName, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone);
    HRESULT ConstructClassDefFileName(LPCWSTR wszClassName, CFileName& wszFileName);
    HRESULT ConstructClassDefFileNameFromHash(LPCWSTR wszHash, 
                                            CFileName& wszFileName);
    HRESULT ConstructClassRelationshipsDirFromHash(LPCWSTR wszHash, 
                                        CFileName& wszDirPath);
    HRESULT GetChildHashesByHash(LPCWSTR wszHash, CWStringArray& wsChildHashes);
    HRESULT GetChildDefsByHash(LPCWSTR wszHash, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone);
    HRESULT FireEvent(CEventCollector &aEvents, DWORD dwType, LPCWSTR wszArg1, _IWmiObject* pObj1, 
                                    _IWmiObject* pObj2 = NULL);
    HRESULT DeleteInstanceAsScope(_IWmiObject* pInst, CEventCollector &aEvents);
	HRESULT EnumerateChildNamespaces(LPCWSTR wsRootNamespace, 
														  CWStringArray &aNamespaces,
														  CEventCollector &aEvents);

    HRESULT DeleteInstanceSelf(LPCWSTR wszFilePath, _IWmiObject* pInst,
                                bool bClassDeletion);
    HRESULT ConstructReferenceDir(LPWSTR wszTargetPath, CFileName& wszDir);
    HRESULT ConstructReferenceDirFromKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey, CFileName& wszReferenceDir);
    HRESULT ConstructReferenceFileName(LPWSTR wszReference,
                        LPCWSTR wszReferringFile, CFileName& wszReferenceFile);
    HRESULT ConstructKeyRootDirFromClass(CFileName& wszDir, LPCWSTR wszClassName);
    HRESULT ConstructKeyRootDirFromKeyRoot(CFileName& wszDir, 
                                                    LPCWSTR wszKeyRootClass);
    HRESULT ConstructLinkDirFromClass(CFileName& wszDir, LPCWSTR wszClassName);
    HRESULT DeleteInstanceLink(_IWmiObject* pInst, 
                                LPCWSTR wszInstanceDefFilePath);
    HRESULT GetKeyRoot(LPCWSTR wszClass, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass);
    HRESULT ConstructInstDefNameFromLinkName(CFileName& wszInstanceDefName,
                                             LPCWSTR wszInstanceLinkName);
    HRESULT ExecDeepInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash,
                                IWbemObjectSink* pSink);
    HRESULT ExecShallowInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash, 
                                IWbemObjectSink* pSink);
    HRESULT ConstructLinkDirFromClassHash(CFileName& wszDir, LPCWSTR wszClassHash);
    HRESULT ConstructClassReferenceFileName(LPCWSTR wszReferredToClass,
                                LPCWSTR wszReferringFile, 
                                LPCWSTR wszReferringProp,
                                CFileName& wszFieName);
    HRESULT WriteClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp);
    HRESULT EraseClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp);
    //CFileCache* GetFileCache();
	
	HRESULT CanClassBeUpdatedCompatible(DWORD dwFlags, LPCWSTR wszClassName, 
                _IWmiObject *pOldClass, _IWmiObject *pNewClass);
    HRESULT DeleteInstanceBackReferences(LPCWSTR wszFilePath);
    HRESULT ConstructReferenceDirFromFilePath(LPCWSTR wszFilePath, 
                                                CFileName& wszReferenceDir);

	HRESULT ClassHasChildren(LPCWSTR wszClassName);
	HRESULT ClassHasInstances(LPCWSTR wszClassName);
	HRESULT ClassHasInstancesFromClassHash(LPCWSTR wszClassHash);
    HRESULT ClassHasInstancesInScopeFromClassHash(
                            LPCWSTR wszInstanceRootDir, LPCWSTR wszClassHash);

	HRESULT UpdateClassCompatible(_IWmiObject* pSuperClass, 
                LPCWSTR wszClassName, _IWmiObject *pNewClass, 
                _IWmiObject *pOldClass, __int64 nFakeUpdateTime = 0);
	HRESULT UpdateClassCompatibleHash(_IWmiObject* pSuperClass, 
                LPCWSTR wszClassHash, _IWmiObject *pClass, 
                _IWmiObject *pOldClass, __int64 nFakeUpdateTime = 0);
	HRESULT UpdateClassSafeForce(_IWmiObject* pSuperClass, DWORD dwFlags, 
                LPCWSTR wcsClassName, _IWmiObject *pOldClass, 
                _IWmiObject *pNewClass, CEventCollector &aEvents);
	HRESULT UpdateClassAggressively(_IWmiObject* pSuperClass, DWORD dwFlags, 
                LPCWSTR wszClassName, _IWmiObject *pNewClass, 
                _IWmiObject *pOldClass, 
                CEventCollector &aEvents);
	HRESULT UpdateChildClassAggressively(DWORD dwFlags, LPCWSTR wszClassHash, 
                _IWmiObject *pNewClass, 
                CEventCollector &aEvents);
	};

class CDbIterator : public CUnkBase2<IWmiDbIterator, &IID_IWmiDbIterator,
                                     IWbemObjectSink, &IID_IWbemObjectSink>
{
protected:
    CCritSec m_cs;
    CRefedPointerQueue<IWbemClassObject> m_qObjects;
    long m_lCurrentIndex;
    void* m_pExecFiber;
    CFiberTask* m_pExecReq;
    HRESULT m_hresStatus;
    
    void* m_pMainFiber;
    DWORD m_dwNumRequested;

    HRESULT m_hresCancellationStatus;
    bool m_bExecFiberRunning;
	bool m_bUseLock;

public:
    CDbIterator(CLifeControl* pControl, bool bUseLock);
    ~CDbIterator();

     STDMETHOD(Cancel) (DWORD dwFlags, void* pFiber);

     STDMETHOD(NextBatch)(
      DWORD dwNumRequested,
      DWORD dwTimeOutSeconds,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
      REFIID riid,
      void* pFiber,
      DWORD *pdwNumReturned,
      LPVOID *ppObjects
     );

    void SetExecFiber(void* pFiber, CFiberTask* pReq);
    
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, 
                                    BSTR, IWbemClassObject*);
};

//
// implements swprintf(pDest,L"%s\\%s",Src1,pSrc2)
//
///////////////////////////////////////////////////////////////////

void inline Cat2Str(WCHAR * pDest, WCHAR * pSrc1, LPCWSTR pSrc2)
{
	while(*pSrc1)
		*pDest++ = *pSrc1++;
	*pDest++ = L'\\';
	while(*pSrc2)
		*pDest++ = *pSrc2++;	
        *pDest = 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wmiexts\wmiexts.cpp ===
/*++


Module Name:

    wmiext.cxx

Abstract:

    This module contains the default ntsd debugger extensions for


Author:

    Ivan Brugiolo 17-05-2000

Revision History:

--*/

#include "wmiexts.h"

# undef DBG_ASSERT



/************************************************************
 *   Debugger Utility Functions
 ************************************************************/



WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

USHORT  g_MajorVersion;
USHORT  g_MinorVersion;

BOOL gChkTarget = FALSE;

BOOL g_KD = FALSE;

DWORD g_AddressSize = sizeof(ULONG_PTR);
BOOL g_bUnextend = FALSE;

/************************************************************
 * The WinDBG required Export
 ************************************************************/
 
LPEXT_API_VERSION
ExtensionApiVersion(
    void
    )

/*++

Function Description:

    Windbg calls this function to match between the version of windbg and the
    extension. If the versions doesn't match, windbg will not load the 
extension.

--*/

{
    static EXT_API_VERSION ApiVersion =
#ifdef KDEXT_64BIT
       { 5, 0, EXT_API_VERSION_NUMBER64, 0 };
#else
       { 5, 0, EXT_API_VERSION_NUMBER, 0 };
#endif       
        

    return &ApiVersion;
}


void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )

/*++

Function Description:

    When windbg loads the extension, it first call this function. You can
    perform various intialization here.

Arguments:

    lpExtensionApis - A structure that contains the callbacks to functions that
        I can use to do standard operation. I must store this in a global
        variable called 'ExtensionApis'.

    MajorVersion - Indicates if target machine is running checked build or 
free.
        0x0C - Checked build.
        0x0F - Free build.

    MinorVersion - The Windows NT build number (for example, 1381 for NT4).

--*/

{
    ExtensionApis = *lpExtensionApis;
    g_MajorVersion = MajorVersion;
    g_MinorVersion = MinorVersion;


    gChkTarget = MajorVersion == 0x0c ? TRUE : FALSE;

#ifdef KDEXT_64BIT
    KDDEBUGGER_DATA64 KdDebuggerData;
#else
    KDDEBUGGER_DATA32 KdDebuggerData;
#endif

    KdDebuggerData.Header.OwnerTag = KDBG_TAG;
    KdDebuggerData.Header.Size = sizeof( KdDebuggerData );

    if (Ioctl( IG_GET_DEBUGGER_DATA, &KdDebuggerData, sizeof( KdDebuggerData ) ))
    {
        g_KD = 1;
    }

    if (sizeof(ULONG64) == sizeof(ULONG_PTR)) //IsPtr64())
    {
        g_AddressSize = 8;
        g_bUnextend = FALSE;
    }
    else
    {
        g_AddressSize = 4;
        g_bUnextend = TRUE;
    }    
}


void
CheckVersion( void )

/*++

Function Description:

    This function is called before every command. It gives the extension
    a chance to compare between the versions of the target and the extension.
    In this demo, I don't do much with that.

--*/

{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\a51rep.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <ql.h>
#include <time.h>
#include "a51rep.h"
#include <md5.h>
#include <objpath.h>
#include "lock.h"
#include <persistcfg.h>
#include "a51fib.h"
#include "RepositoryPackager.h"


class CAutoTransaction
{

    CSession *m_pSession;
    bool m_bWriteOperation;
    bool m_bStarted;
    bool m_bAbortForestCacheToo;

public:
	CAutoTransaction(CSession *pSession, bool bAbortForestCacheToo) 
		: m_bStarted(false), m_pSession(pSession), m_bAbortForestCacheToo(bAbortForestCacheToo) 
	{ 
	}
	~CAutoTransaction()
	{
		if (m_bStarted)
			InternalAbortTransaction();
	}
	DWORD InternalBeginTransaction(bool bWriteOperation) 
	{ 
		m_bWriteOperation = bWriteOperation; 
		m_bStarted = true;
		DWORD dwRet = m_pSession->InternalBeginTransaction(m_bWriteOperation); 
		if (dwRet)
			m_bStarted = false;	//Don't want to revert if we failed to begin!
		return dwRet;
	}
	DWORD InternalAbortTransaction()
	{
		m_bStarted = false;
		if (m_bAbortForestCacheToo)
		{
			g_Glob.m_ForestCache.AbortTransaction();
		}
		return m_pSession->InternalAbortTransaction(m_bWriteOperation);
	}
	DWORD InternalCommitTransaction()
	{
		m_bStarted = false;
		return m_pSession->InternalCommitTransaction(m_bWriteOperation);
	}
	
};

//**************************************************************************************************

HRESULT STDMETHODCALLTYPE CSession::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWmiDbSession || 
                riid == IID_IWmiDbSessionEx)
    {
        AddRef();
        *ppv = this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CSession::Release()
{
    return CUnkBase<IWmiDbSessionEx, &IID_IWmiDbSessionEx>::Release();
}

CSession::~CSession()
{
}
    

HRESULT STDMETHODCALLTYPE CSession::GetObject(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    try
    {
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
            if (!lock.Lock())
                return WBEM_E_FAILED;
        }
        if (g_bShuttingDown)
        {
            return WBEM_E_SHUTTING_DOWN;
        }
    
        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

        hres = pNs->GetObject(pPath, dwFlags, dwRequestedHandleType, 
                                        ppResult);

        InternalCommitTransaction(false);
        return hres;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}


HRESULT STDMETHODCALLTYPE CSession::GetObjectDirect(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
    try
    {
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
            if (!lock.Lock())
                return WBEM_E_FAILED;            
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

        hres = pNs->GetObjectDirect(pPath, dwFlags, riid, pObj);
        InternalCommitTransaction(false);

        return hres;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT STDMETHODCALLTYPE CSession::GetObjectByPath(
     IWmiDbHandle *pScope,
     LPCWSTR wszObjectPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
    try
    {
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
            if (!lock.Lock())
                return WBEM_E_FAILED;            
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

        DWORD dwLen = wcslen(wszObjectPath)+1;
        LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
        if (wszPath == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        StringCchCopyW(wszPath, dwLen, wszObjectPath);

        CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));
        hres = pNs->GetObjectByPath(wszPath, dwFlags, riid, pObj);
        InternalCommitTransaction(false);

        return hres;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}
    


HRESULT STDMETHODCALLTYPE CSession::PutObject(
     IWmiDbHandle *pScope,
     REFIID riid,
    LPVOID pObj,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    CAutoWriteLock lock(&g_readWriteLock);
    try
    {
        HRESULT hres;
        long lRes;
        CAutoTransaction transaction(this, true);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
            if (!lock.Lock())
                return WBEM_E_FAILED;            
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            hres = transaction.InternalBeginTransaction(true);
            if(hres != ERROR_SUCCESS)
                return hres;
            g_Glob.m_ForestCache.BeginTransaction();
        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;


        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                transaction.InternalAbortTransaction();
            }
            return pNs->GetErrorStatus();
        }

        hres =  pNs->PutObject(riid, pObj, dwFlags, dwRequestedHandleType, ppResult, *aEvents);
        
        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                transaction.InternalAbortTransaction();
            }
            else
            {
                hres = transaction.InternalCommitTransaction();
                if(hres == ERROR_SUCCESS)
                {
                    g_Glob.m_ForestCache.CommitTransaction();
                    lock.Unlock();
                    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
                    CReleaseMe rm(pSvcs);
                    aNonTransactedEvents.SendEvents(pSvcs);
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }
    
        return hres;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT STDMETHODCALLTYPE CSession::DeleteObject(
     IWmiDbHandle *pScope,
     DWORD dwFlags,
     REFIID riid,
     LPVOID pObj
    )
{
    CAutoWriteLock lock(&g_readWriteLock);
    try
    {
        HRESULT hres;
        long lRes;
        CAutoTransaction transaction(this, false);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
            if (!lock.Lock())
                return WBEM_E_FAILED;            
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            hres = transaction.InternalBeginTransaction(true);
            if(hres != ERROR_SUCCESS)
                return hres;

        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                transaction.InternalAbortTransaction();
            }
            return pNs->GetErrorStatus();
        }

        hres = pNs->DeleteObject(dwFlags, riid, pObj, *aEvents);

        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                transaction.InternalAbortTransaction();
            }
            else
            {
                hres = transaction.InternalCommitTransaction();
                if(hres == ERROR_SUCCESS)
                {
                    lock.Unlock();
                    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
                    CReleaseMe rm(pSvcs);
                    aNonTransactedEvents.SendEvents(pSvcs);                    
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }

        return hres;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT STDMETHODCALLTYPE CSession::DeleteObjectByPath(
     IWmiDbHandle *pScope,
     LPCWSTR wszObjectPath,
     DWORD dwFlags
    )
{
    CAutoWriteLock lock(&g_readWriteLock);
    try
    {
        HRESULT hres;
        long lRes;
        CAutoTransaction transaction(this, false);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
            if (!lock.Lock())
                return WBEM_E_FAILED;            
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            hres = transaction.InternalBeginTransaction(true);
            if(hres != ERROR_SUCCESS)
                return hres;

        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                transaction.InternalAbortTransaction();
            }
            return pNs->GetErrorStatus();
        }
        DWORD dwLen = wcslen(wszObjectPath)+1;
        LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
        if (wszPath == NULL)
        {
            if(!m_bInWriteTransaction)
            {
                transaction.InternalAbortTransaction();
            }
            return WBEM_E_OUT_OF_MEMORY;
        }
        StringCchCopyW(wszPath, dwLen, wszObjectPath);

        CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));

        hres = pNs->DeleteObjectByPath(dwFlags, wszPath, *aEvents);

        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                transaction.InternalAbortTransaction();
            }
            else
            {
                hres = transaction.InternalCommitTransaction();
                if(hres == ERROR_SUCCESS)
                {
                    lock.Unlock();
                    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
                    CReleaseMe rm(pSvcs);
                    aNonTransactedEvents.SendEvents(pSvcs);                    
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }

        return hres;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT STDMETHODCALLTYPE CSession::ExecQuery(
     IWmiDbHandle *pScope,
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    DWORD *dwMessageFlags,
    IWmiDbIterator **ppQueryResult
    )
{
    try
    {
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
            if (!lock.Lock())
                return WBEM_E_FAILED;            
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

        //If we are in a transaction, we have to get a message to the iteratir
        //on create so it does not mess around with the locks!
        if (m_bInWriteTransaction)
            pNs->TellIteratorNotToLock();

        hres = pNs->ExecQuery(pQuery, dwFlags,
                 dwRequestedHandleType, dwMessageFlags, ppQueryResult);
        InternalCommitTransaction(false);

        return hres;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT STDMETHODCALLTYPE CSession::ExecQuerySink(
     IWmiDbHandle *pScope,
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
     IWbemObjectSink* pSink,
    DWORD *dwMessageFlags
    )
{
    try
    {
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
            if (!lock.Lock())
                return WBEM_E_FAILED;            
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

        hres = pNs->ExecQuerySink(pQuery, dwFlags,
                 dwRequestedHandleType, pSink, dwMessageFlags);

        InternalCommitTransaction(false);
        return hres;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}
                    
    
HRESULT STDMETHODCALLTYPE CSession::RenameObject(
     IWbemPath *pOldPath,
     IWbemPath *pNewPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
#ifdef DBG
    DebugBreak();
#endif
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::Enumerate(
     IWmiDbHandle *pScope,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbIterator **ppQueryResult
    )
{
#ifdef DBG
    DebugBreak();
#endif
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::AddObject(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
#ifdef DBG
    DebugBreak();
#endif
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::RemoveObject (
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags
    )
{
#ifdef DBG
    DebugBreak();
#endif
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::SetDecoration(
     LPWSTR lpMachineName,
     LPWSTR lpNamespacePath
    )
{
    //
    // As the default driver, we really don't care.
    //

    return WBEM_S_NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CSession::BeginWriteTransaction(DWORD dwFlags)
{
    if (CLock::NoError != g_readWriteLock.WriteLock())
        return WBEM_E_FAILED;
    
    if (g_bShuttingDown)
    {
        g_readWriteLock.WriteUnlock();
        return WBEM_E_SHUTTING_DOWN;
    }

    HRESULT hres = InternalBeginTransaction(true);
    if(hres != ERROR_SUCCESS)
    {
        g_readWriteLock.WriteUnlock();
        return hres;
    }

    m_bInWriteTransaction = true;
    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::BeginReadTransaction(DWORD dwFlags)
{
    if (CLock::NoError != g_readWriteLock.ReadLock())
        return WBEM_E_FAILED;
    
    if (g_bShuttingDown)
    {
        g_readWriteLock.ReadUnlock();
        return WBEM_E_SHUTTING_DOWN;
    }

    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::CommitTransaction(DWORD dwFlags)
{
    if (m_bInWriteTransaction)
    {
        long lRes = g_Glob.m_FileCache.CommitTransaction();
		_ASSERT(lRes == 0, L"Commit transaction failed");

        CRepository::WriteOperationNotification();

        m_bInWriteTransaction = false;

        //Copy the event list and delete the original.  We need to deliver
        //outside the write lock.
        CEventCollector aTransactedEvents;
        aTransactedEvents.TransferEvents(m_aTransactedEvents);

        g_readWriteLock.WriteUnlock();

        _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
        CReleaseMe rm(pSvcs);
        aTransactedEvents.SendEvents(pSvcs);
        aTransactedEvents.DeleteAllEvents();
    }
    else
    {
        if (m_aTransactedEvents.GetSize())
        {
            _ASSERT(false, L"Read transaction has events to send");
        }
        g_readWriteLock.ReadUnlock();
   }
    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::AbortTransaction(DWORD dwFlags)
{
    if (m_bInWriteTransaction)
    {
        m_bInWriteTransaction = false;
        g_Glob.m_FileCache.AbortTransaction();
        m_aTransactedEvents.DeleteAllEvents();
        g_readWriteLock.WriteUnlock();
    }
    else
    {
        if (m_aTransactedEvents.GetSize())
        {
            _ASSERT(false, L"Read transaction has events to send");
        }
        g_readWriteLock.ReadUnlock();
    }
    return ERROR_SUCCESS;
}


HRESULT CSession::InternalBeginTransaction(bool bWriteOperation)
{
	if (bWriteOperation)
	{
		long lRes = g_Glob.m_FileCache.BeginTransaction();
		return A51TranslateErrorCode(lRes);
	}
	else
		return ERROR_SUCCESS;
}
HRESULT CSession::InternalAbortTransaction(bool bWriteOperation)
{
	if (bWriteOperation)
	{
		g_Glob.m_FileCache.AbortTransaction();
	}

    return ERROR_SUCCESS;
}
HRESULT CSession::InternalCommitTransaction(bool bWriteOperation)
{
    DWORD dwres = ERROR_SUCCESS;


	if (bWriteOperation)
	{
		long lRes = g_Glob.m_FileCache.CommitTransaction();
		_ASSERT(lRes == 0, L"Commit transaction failed");
		CRepository::WriteOperationNotification();
	}
	else
	{
		CRepository::ReadOperationNotification();
	}

    return dwres;
}

//
//
//
//
///////////////////////////////////////////////////////////////////////

long CNamespaceHandle::s_lActiveRepNs = 0;

CNamespaceHandle::CNamespaceHandle(CLifeControl* pControl,CRepository * pRepository)
    : TUnkBase(pControl), m_pClassCache(NULL),
       m_pNullClass(NULL), m_bCached(false), m_pRepository(pRepository),
       m_bUseIteratorLock(true)
{    
    m_pRepository->AddRef();
    // unrefed pointer to a global
    InterlockedIncrement(&s_lActiveRepNs);
}

CNamespaceHandle::~CNamespaceHandle()
{
    if(m_pClassCache)
    {
        // give-up our own reference
        // m_pClassCache->Release();
        // remove from the Forest cache this namespace
        g_Glob.m_ForestCache.ReleaseNamespaceCache(m_wsNamespace, m_pClassCache);
    }

    m_pRepository->Release();
    if(m_pNullClass)
        m_pNullClass->Release();
    InterlockedDecrement(&s_lActiveRepNs);
}

HRESULT CNamespaceHandle::GetErrorStatus()
{
    return m_pClassCache->GetError();
}

void CNamespaceHandle::SetErrorStatus(HRESULT hres)
{
    m_pClassCache->SetError(hres);
}

HRESULT CNamespaceHandle::Initialize(LPCWSTR wszNamespace, LPCWSTR wszScope)
{
    HRESULT hres;

    m_wsNamespace = wszNamespace;
    m_wsFullNamespace = L"\\\\.\\";
    m_wsFullNamespace += wszNamespace;

    StringCchCopyW(m_wszMachineName,MAX_COMPUTERNAME_LENGTH+1, g_Glob.GetComputerName());

    if(wszScope)
        m_wsScope = wszScope;

    //
    // Ask the forest for the cache for this namespace
    //

    m_pClassCache = g_Glob.m_ForestCache.GetNamespaceCache(WString(wszNamespace));
    if(m_pClassCache == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(m_wszClassRootDir, MAX_PATH, g_Glob.GetRootDir());

    //
    // Append namespace-specific prefix
    //

    StringCchCatW(m_wszClassRootDir, MAX_PATH, L"\\NS_");

    //
    // Append hashed namespace name
    //

    if (!Hash(wszNamespace, m_wszClassRootDir + wcslen(m_wszClassRootDir)))
        return WBEM_E_OUT_OF_MEMORY;
    m_lClassRootDirLen = wcslen(m_wszClassRootDir);

    //
    // Constuct the instance root dir
    //

    if(wszScope == NULL)
    {
        //
        // Basic namespace --- instances go into the root of the namespace
        //

        StringCchCopyW(m_wszInstanceRootDir, MAX_PATH, m_wszClassRootDir);
        m_lInstanceRootDirLen = m_lClassRootDirLen;
    }   
    else
    {
        StringCchCopyW(m_wszInstanceRootDir, MAX_PATH, m_wszClassRootDir);
        StringCchCatW(m_wszInstanceRootDir, MAX_PATH, L"\\" A51_SCOPE_DIR_PREFIX);
        if(!Hash(m_wsScope, 
                 m_wszInstanceRootDir + wcslen(m_wszInstanceRootDir)))
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        m_lInstanceRootDirLen = wcslen(m_wszInstanceRootDir);
    }
        

    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::Initialize2(LPCWSTR wszNamespace, LPCWSTR wszNamespaceHash)
{
    HRESULT hres;

    m_wsNamespace = wszNamespace;
    m_wsFullNamespace = L"\\\\.\\";
    m_wsFullNamespace += wszNamespace;

    StringCchCopyW(m_wszMachineName,MAX_COMPUTERNAME_LENGTH+1, g_Glob.GetComputerName());

    //
    // Ask the forest for the cache for this namespace
    //

    m_pClassCache = g_Glob.m_ForestCache.GetNamespaceCache(WString(wszNamespace));
    if(m_pClassCache == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(m_wszClassRootDir, MAX_PATH, g_Glob.GetRootDir());

    //
    // Append namespace-specific prefix
    //

    StringCchCatW(m_wszClassRootDir, MAX_PATH, L"\\NS_");

    //
    // Append hashed namespace name
    //

    StringCchCatW(m_wszClassRootDir, MAX_PATH, wszNamespaceHash);
    m_lClassRootDirLen = wcslen(m_wszClassRootDir);

    //
    // Constuct the instance root dir
    //

    StringCchCopyW(m_wszInstanceRootDir, MAX_PATH, m_wszClassRootDir);
    m_lInstanceRootDirLen = m_lClassRootDirLen;
    return WBEM_S_NO_ERROR;
}


HRESULT CNamespaceHandle::GetObject(
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    HRESULT hres;

    if((dwRequestedHandleType & WMIDB_HANDLE_TYPE_COOKIE) == 0)
    {
#ifdef DBG
        DebugBreak();
#endif
        return E_NOTIMPL;
    }

    DWORD dwLen = 0;
    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);
    if(FAILED(hres) && hres != WBEM_E_BUFFER_TOO_SMALL)
        return hres;

    WCHAR* wszBuffer = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
    if(wszBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszBuffer, dwLen * sizeof(WCHAR));

    if(FAILED(pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszBuffer)))
        return WBEM_E_FAILED;

    return GetObjectHandleByPath(wszBuffer, dwFlags, dwRequestedHandleType, 
        ppResult);
}

HRESULT CNamespaceHandle::GetObjectHandleByPath(
     LPWSTR wszBuffer,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszBuffer) + 1;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen*sizeof(WCHAR));

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    HRESULT hres = ComputeKeyFromPath(wszBuffer, wszKey, dwLen, &wszClassName, 
                                        &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    //
    // Check if it exists (except for ROOT --- it's fake)
    //

    _IWmiObject* pObj = NULL;
    if(m_wsNamespace.Length() > 0)
    {
        hres = GetInstanceByKey(wszClassName, wszKey, IID__IWmiObject, 
            (void**)&pObj);
        if(FAILED(hres))
            return hres;
    }
    CReleaseMe rm1(pObj);

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl,m_pRepository);
    if (pNewHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pNewHandle->AddRef();
    CReleaseMe rm2(pNewHandle);

    //
    // Check if this is a namespace or not
    //

    if(pObj == NULL || pObj->InheritsFrom(L"__Namespace") == S_OK)
    {
        //
        // It's a namespace.  Open a basic handle pointing to it
        //

        WString wsName = m_wsNamespace;
        if(wsName.Length() > 0)
            wsName += L"\\";
        wsName += wszKey;
    
        hres = pNewHandle->Initialize(wsName);

        //
        // Since our namespace is for real, tell the cache that it is now valid.
        // The cache might have been invalidated if this namespace was deleted 
        // in the past
        //
        if (SUCCEEDED(hres))
            pNewHandle->SetErrorStatus(S_OK);
    }
    else
    {
        // 
        // It's a scope.  Construct the new scope name by appending this 
        // object's path to our own scope
        //

        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);
        hres = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
        if(FAILED(hres))
            return hres;
        if(V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;

        WString wsScope = m_wsScope;
        if(wsScope.Length() > 0)
            wsScope += L":";
        wsScope += V_BSTR(&v);

        hres = pNewHandle->Initialize(m_wsNamespace, wsScope);
    }
        
    if(FAILED(hres))
        return hres;

    return pNewHandle->QueryInterface(IID_IWmiDbHandle, (void**)ppResult);
}

HRESULT CNamespaceHandle::ComputeKeyFromPath(LPWSTR wszPath, LPWSTR wszKey, size_t dwKeyLen,
                                            TEMPFREE_ME LPWSTR* pwszClass,
                                            bool* pbIsClass,
                                            TEMPFREE_ME LPWSTR* pwszNamespace)
{
    HRESULT hres;

    *pbIsClass = false;

    //
    // Get and skip the namespace portion.
    //

    if(wszPath[0] == '\\' || wszPath[0] == '/')
    {
        //
        // Find where the server portion ends
        //

        WCHAR* pwcNextSlash = wcschr(wszPath+2, wszPath[0]);
        if(pwcNextSlash == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
        
        //
        // Find where the namespace portion ends
        //

        WCHAR* pwcColon = wcschr(pwcNextSlash, L':');
        if(pwcColon == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
    
        if(pwszNamespace)
        {
            DWORD dwLen = pwcColon - pwcNextSlash;
            *pwszNamespace = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
            if(*pwszNamespace == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            
            *pwcColon = 0;
            StringCchCopyW(*pwszNamespace, dwLen, pwcNextSlash+1);
        }

        //
        // Advance wszPath to beyond the namespace portion
        //

        wszPath = pwcColon+1;
    }
    else if(pwszNamespace)
    {
        *pwszNamespace = NULL;
    }

    // Get the first key

    WCHAR* pwcFirstEq = wcschr(wszPath, L'=');
    if(pwcFirstEq == NULL)
    {
        //
        // It's a class!
        //

        *pbIsClass = true;
        // path to the "class" to distinguish from its  instances
        wszKey[0] = 1;
        wszKey[1] = 0;

        size_t dwLen = wcslen(wszPath) + 1;
        *pwszClass = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
        if(*pwszClass == NULL)
        {
            if(pwszNamespace)
                TempFree(*pwszNamespace);
            return WBEM_E_OUT_OF_MEMORY;
        }
        StringCchCopyW(*pwszClass, dwLen, wszPath);
        return S_OK;
    }

    WCHAR* pwcFirstDot = wcschr(wszPath, L'.');

    if(pwcFirstDot == NULL || pwcFirstDot > pwcFirstEq)
    {
        // No name on the first key

        *pwcFirstEq = 0;

        size_t dwLen = wcslen(wszPath)+1;
        *pwszClass = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
        if(*pwszClass == NULL)
        {
            if(pwszNamespace)
                TempFree(*pwszNamespace);
            return WBEM_E_OUT_OF_MEMORY;
        }
        StringCchCopyW(*pwszClass, dwLen, wszPath);
    
        WCHAR* pwcThisKey = NULL;
        WCHAR* pwcEnd = NULL;
        hres = ParseKey(pwcFirstEq+1, &pwcThisKey, &pwcEnd);
        if(FAILED(hres))
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return hres;
        }
        if(*pwcEnd != NULL)
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return WBEM_E_INVALID_OBJECT_PATH;
        }

        StringCchCopyW(wszKey, dwKeyLen, pwcThisKey);
        return S_OK;
    }

    //
    // Normal case
    //

    //
    // Get all the key values
    //

    struct CKeyStruct
    {
        WCHAR* m_pwcValue;
        WCHAR* m_pwcName;
    } * aKeys = (CKeyStruct*)TempAlloc(sizeof(CKeyStruct[256]));

    if (0==aKeys)
    {
        if(pwszNamespace)
            TempFree(*pwszNamespace);
      return WBEM_E_OUT_OF_MEMORY;
    }
    CTempFreeMe release_aKeys(aKeys);

    DWORD dwNumKeys = 0;

    *pwcFirstDot = NULL;

    size_t dwLen = wcslen(wszPath)+1;
    *pwszClass = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
    if(*pwszClass == NULL)
    {
        if(pwszNamespace)
            TempFree(*pwszNamespace);
        return WBEM_E_OUT_OF_MEMORY;
    }

    StringCchCopyW(*pwszClass, dwLen, wszPath);

    WCHAR* pwcNextKey = pwcFirstDot+1;

    do
    {
        pwcFirstEq = wcschr(pwcNextKey, L'=');
        if(pwcFirstEq == NULL)
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return WBEM_E_INVALID_OBJECT_PATH;
        }
        
        *pwcFirstEq = 0;

        aKeys[dwNumKeys].m_pwcName = pwcNextKey;
        hres = ParseKey(pwcFirstEq+1, &(aKeys[dwNumKeys].m_pwcValue), 
                            &pwcNextKey);
        if(FAILED(hres))
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return hres;
        }
        dwNumKeys++;

        //Maximum number of compound keys in the repository is now set to 256!
        if (dwNumKeys == 256)
            return WBEM_E_INVALID_OBJECT_PATH;
    }
    while(*pwcNextKey);

    if(*pwcNextKey != 0)
    {
        TempFree(*pwszClass);
        if(pwszNamespace)
            TempFree(*pwszNamespace);

        return WBEM_E_INVALID_OBJECT_PATH;
    }
    
    //
    // We have the array of keys --- sort it
    //

    DWORD dwCurrentIndex = 0;
    while(dwCurrentIndex < dwNumKeys-1)
    {
        if(wbem_wcsicmp(aKeys[dwCurrentIndex].m_pwcName, 
                        aKeys[dwCurrentIndex+1].m_pwcName) > 0)
        {
            CKeyStruct Temp = aKeys[dwCurrentIndex];
            aKeys[dwCurrentIndex] = aKeys[dwCurrentIndex+1];
            aKeys[dwCurrentIndex+1] = Temp;
            if(dwCurrentIndex)
                dwCurrentIndex--;
            else
                dwCurrentIndex++;
        }
        else
            dwCurrentIndex++;
    }

    //
    // Now generate the result
    //
    
    WCHAR* pwcKeyEnd = wszKey;
    for(DWORD i = 0; i < dwNumKeys; i++)
    {
        StringCchCopyW(pwcKeyEnd, dwKeyLen - (pwcKeyEnd - wszKey), aKeys[i].m_pwcValue);
        pwcKeyEnd += wcslen(aKeys[i].m_pwcValue);
        if(i < dwNumKeys-1)
            *(pwcKeyEnd++) = -1;
    }
    *pwcKeyEnd = 0;
    return S_OK;
}

HRESULT CNamespaceHandle::ParseKey(LPWSTR wszKeyStart, LPWSTR* pwcRealStart,
                                    LPWSTR* pwcNextKey)
{
    if (wszKeyStart[0] == L'\'')
    {
        WCHAR wcStart = wszKeyStart[0];
        WCHAR* pwcRead = wszKeyStart+1;
        WCHAR* pwcWrite = wszKeyStart+1;
        while(*pwcRead && *pwcRead != wcStart)  // wcStart contains the single quote
        {
            // there is no escaping for backslash
            *(pwcWrite++) = *(pwcRead++);
        }
        if(*pwcRead == 0)
            return WBEM_E_INVALID_OBJECT_PATH;

        *pwcWrite = 0;
        if(pwcRealStart)
            *pwcRealStart = wszKeyStart+1;

        //
        // Check separator
        //
    
        if(pwcRead[1] && pwcRead[1] != L',')
            return WBEM_E_INVALID_OBJECT_PATH;
            
        if(pwcNextKey)
        {
            //
            // If there is a separator, skip it.  Don't skip end of string!
            //

            if(pwcRead[1])
                *pwcNextKey = pwcRead+2;
            else
                *pwcNextKey = pwcRead+1;
        }        
    }
    else if(wszKeyStart[0] == L'"' )
    {
        WCHAR wcStart = wszKeyStart[0];
        WCHAR* pwcRead = wszKeyStart+1;
        WCHAR* pwcWrite = wszKeyStart+1;
        while(*pwcRead && *pwcRead != wcStart)  
        {
            if((*pwcRead == '\\') && (*(pwcRead+1) != 'x') && (*(pwcRead+1) != 'X'))
                pwcRead++;

            *(pwcWrite++) = *(pwcRead++);
        }
        if(*pwcRead == 0)
            return WBEM_E_INVALID_OBJECT_PATH;

        *pwcWrite = 0;
        if(pwcRealStart)
            *pwcRealStart = wszKeyStart+1;

        //
        // Check separator
        //
    
        if(pwcRead[1] && pwcRead[1] != L',')
            return WBEM_E_INVALID_OBJECT_PATH;
            
        if(pwcNextKey)
        {
            //
            // If there is a separator, skip it.  Don't skip end of string!
            //

            if(pwcRead[1])
                *pwcNextKey = pwcRead+2;
            else
                *pwcNextKey = pwcRead+1;
        }
    }
    else
    {
        if(pwcRealStart)
            *pwcRealStart = wszKeyStart;
        WCHAR* pwcComma = wcschr(wszKeyStart, L',');
        if(pwcComma == NULL)
        {
            if(pwcNextKey)
                *pwcNextKey = wszKeyStart + wcslen(wszKeyStart);
        }
        else
        {
            *pwcComma = 0;
            if(pwcNextKey)
                *pwcNextKey = pwcComma+1;
        }
    }

    return S_OK;
}
            

HRESULT CNamespaceHandle::GetObjectDirect(
     IWbemPath *pPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
    HRESULT hres;

    DWORD dwLen = 0;
    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);

    LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
    if (wszPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));

    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszPath);
    if(FAILED(hres))
        return hres;


    return GetObjectByPath(wszPath, dwFlags, riid, pObj);
}

HRESULT CNamespaceHandle::GetObjectByPath(
     LPWSTR wszPath,
     DWORD dwFlags,
     REFIID riid,
     LPVOID *pObj
    )
{
    HRESULT hres;

    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszPath)+1;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen*sizeof(WCHAR));

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    hres = ComputeKeyFromPath(wszPath, wszKey, dwLen, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    if(bIsClass)
    {
        return GetClassDirect(wszClassName, riid, pObj, true, NULL, NULL, NULL);
    }
    else
    {
        return GetInstanceByKey(wszClassName, wszKey, riid, pObj);
    }
}

HRESULT CNamespaceHandle::GetInstanceByKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey,
                                REFIID riid, void** ppObj)
{
    HRESULT hres;

    //
    // Get the class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    //
    // Construct directory path
    //

    CFileName wszFilePath;
    if (wszFilePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszFilePath, wszClassName);
    if(FAILED(hres))
        return hres;

    //
    // Construct the file path
    //

    int nLen = wcslen(wszFilePath);
    wszFilePath[nLen] = L'\\';

    CFileName tmpFilePath;
    if (tmpFilePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructInstanceDefName(tmpFilePath, wszKey);
    if(FAILED(hres))
        return hres;
    StringCchCopyW(wszFilePath+nLen+1, wszFilePath.Length()-nLen-1, tmpFilePath);
    
    //
    // Get the object from that file
    //

    _IWmiObject* pInst;
    hres = FileToInstance(NULL, wszFilePath, NULL, 0, &pInst);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pInst);

    //
    // Return
    //

    return pInst->QueryInterface(riid, (void**)ppObj);
}

HRESULT CNamespaceHandle::GetClassByHash(LPCWSTR wszHash, bool bClone, 
                                            _IWmiObject** ppClass,
                                            __int64* pnTime,
                                            bool* pbRead,
                                            bool *pbSystemClass)
{
    HRESULT hres;

    //
    // Check the cache first
    //

    *ppClass = m_pClassCache->GetClassDefByHash(wszHash, bClone, pnTime, pbRead, pbSystemClass);
    if(*ppClass)
        return S_OK;

    //
    // Not found --- construct the file name and read it
    //

    if(pbRead)
        *pbRead = true;

    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileNameFromHash(wszHash, wszFileName);
    if(FAILED(hres))
        return hres;

    CFileName wszFilePath;
    if (wszFilePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    Cat2Str(wszFilePath, m_wszClassRootDir, wszFileName);

    hres = FileToClass(wszFilePath, ppClass, bClone, pnTime, pbSystemClass);
    if(FAILED(hres))
        return hres;

    return S_OK;
}

    
HRESULT CNamespaceHandle::GetClassDirect(LPCWSTR wszClassName,
                                REFIID riid, void** ppObj, bool bClone,
                                __int64* pnTime, bool* pbRead, 
                                bool *pbSystemClass)
{
    HRESULT hres;

    if(wszClassName == NULL || wcslen(wszClassName) == 0)
    {
        if(m_pNullClass == NULL)
        {
            hres = CoCreateInstance(CLSID_WbemClassObject, NULL, 
                        CLSCTX_INPROC_SERVER,
                        IID__IWmiObject, (void **)&m_pNullClass);
            if (FAILED(hres))
                return hres;
        }

        IWbemClassObject* pRawObj;
        hres = m_pNullClass->Clone(&pRawObj);
        if (FAILED(hres))
            return hres;
        CReleaseMe rm(pRawObj);
        if(pnTime)
            *pnTime = 0;
        if(pbRead)
            *pbRead = false;

        return pRawObj->QueryInterface(riid, ppObj);
    }

    _IWmiObject* pClass;

    //
    // Check the cache first
    //

    pClass = m_pClassCache->GetClassDef(wszClassName, bClone, pnTime, pbRead);
    if(pClass)
    {
        CReleaseMe rm1(pClass);
        return pClass->QueryInterface(riid, ppObj);
    }

    if(pbRead)
        *pbRead = true;

    //
    // Construct the path for the file
    //

    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileName(wszClassName, wszFileName);
    if(FAILED(hres))
        return hres;

    CFileName wszFilePath;
    if (wszFilePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    Cat2Str(wszFilePath, m_wszClassRootDir, wszFileName);

    //
    // Read it from the file
    //

    hres = FileToClass(wszFilePath, &pClass, bClone, pnTime, pbSystemClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    return pClass->QueryInterface(riid, ppObj);
}

HRESULT CNamespaceHandle::FileToInstance(_IWmiObject* pClass,
                                     LPCWSTR wszFileName, 
                                     BYTE *pRetrievedBlob,
                                     DWORD dwSize,
                                     _IWmiObject** ppInstance, 
                                     bool bMustBeThere)
{
    HRESULT hres;

    //
    // Read the data from the file
    //

	BYTE* pBlob = NULL;
	if (pRetrievedBlob == NULL)
	{
		long lRes = g_Glob.m_FileCache.ReadObject(wszFileName, &dwSize, &pBlob, 
											 bMustBeThere);
		if(lRes != ERROR_SUCCESS)
		{
			return A51TranslateErrorCode(lRes);
		}
		pRetrievedBlob = pBlob;
	}

    CTempFreeMe tfm1(pBlob, dwSize);

    _ASSERT(dwSize > sizeof(__int64), L"Instance blob too short");
    if(dwSize <= sizeof(__int64))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Extract the class hash
    //

    WCHAR wszClassHash[MAX_HASH_LEN+1];
    DWORD dwClassHashLen = MAX_HASH_LEN*sizeof(WCHAR);
    memcpy(wszClassHash, pRetrievedBlob, MAX_HASH_LEN*sizeof(WCHAR));
    wszClassHash[MAX_HASH_LEN] = 0;

    __int64 nInstanceTime;
    memcpy(&nInstanceTime, pRetrievedBlob + dwClassHashLen, sizeof(__int64));

    __int64 nOldClassTime;
    memcpy(&nOldClassTime, pRetrievedBlob + dwClassHashLen + sizeof(__int64), 
            sizeof(__int64));

    BYTE* pInstancePart = pRetrievedBlob + dwClassHashLen + sizeof(__int64)*2;
    DWORD dwInstancePartSize = dwSize - dwClassHashLen - sizeof(__int64)*2;

    //
    // Get the class def
    //

    _IWmiObject* pRetrievedClass = NULL;
    if (pClass == NULL)
    {
        __int64 nClassTime;
        bool bRead;
        bool bSystemClass = false;
        hres = GetClassByHash(wszClassHash, false, &pRetrievedClass, &nClassTime, &bRead, &bSystemClass);
        if(FAILED(hres))
            return hres;
        pClass = pRetrievedClass;
    }
    CReleaseMe rm1(pRetrievedClass);

#ifdef A51_CHECK_TIMESTAMPS
    _ASSERT(nClassTime <= nInstanceTime, L"Instance is older than its class");
    _ASSERT(nClassTime == nOldClassTime, L"Instance verified with the wrong "
                        L"class definition");
#endif

    //
    // Construct the instance
    //
                    
    _IWmiObject* pInst = NULL;
    hres = pClass->MergeAndDecorate(WMIOBJECT_MERGE_FLAG_INSTANCE, 
                                                        dwInstancePartSize, pInstancePart,
                                                        m_wszMachineName, m_wsNamespace, &pInst);
    if(FAILED(hres))
        return hres;

    *ppInstance = pInst;
    return S_OK;
}


HRESULT CNamespaceHandle::FileToSystemClass(LPCWSTR wszFileName, 
                                    _IWmiObject** ppClass, bool bClone,
                                    __int64* pnTime)
{
    //
    // Note: we must always clone the result of the system class retrieval,
    // since it will be decorated by the caller
    //

    return GetClassByHash(wszFileName + (wcslen(wszFileName) - MAX_HASH_LEN), 
                            true, 
                            ppClass, pnTime, NULL, NULL);
}
HRESULT CNamespaceHandle::FileToClass(LPCWSTR wszFileName, 
                                    _IWmiObject** ppClass, bool bClone,
                                    __int64* pnTime, bool *pbSystemClass)
{
    HRESULT hres;

    //
    // Read the data from the file
    //

    __int64 nTime;
    DWORD dwSize;
    BYTE* pBlob;
    VARIANT vClass;

	long lRes = g_Glob.m_FileCache.ReadObject(wszFileName, &dwSize, &pBlob);
	if(lRes != ERROR_SUCCESS)
	{
		//We didn't find it here, so lets try and find it in the default namespace!
		//If we are not in the __SYSTEMCLASS namespace then we need to call into that...
		if((lRes == ERROR_FILE_NOT_FOUND) && g_pSystemClassNamespace && wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0)
		{
			hres = g_pSystemClassNamespace->FileToSystemClass(wszFileName, ppClass, bClone, &nTime);
			if (FAILED(hres))
				return hres;

            if (pnTime)
                *pnTime = nTime;

            //need to cache this item in the local cache
            hres = (*ppClass)->Get(L"__CLASS", 0, &vClass, NULL, NULL);
            if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
                return WBEM_E_INVALID_OBJECT;
            CClearMe cm1(&vClass);

                     // redecorate the obejct, from __SYSTEMCLASS namespace to the current one
            (*ppClass)->SetDecoration(m_wszMachineName, m_wsNamespace);

            m_pClassCache->AssertClass((*ppClass), V_BSTR(&vClass), bClone, nTime, true);

            if (pbSystemClass)
                *pbSystemClass = true;


            return hres;
        }
        else
            return A51TranslateErrorCode(lRes);
    }

    CTempFreeMe tfm1(pBlob, dwSize);

    _ASSERT(dwSize > sizeof(__int64), L"Class blob too short");
    if(dwSize <= sizeof(__int64))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Read off the superclass name
    //

    DWORD dwSuperLen;
    memcpy(&dwSuperLen, pBlob, sizeof(DWORD));
    LPWSTR wszSuperClass = (WCHAR*)TempAlloc(dwSuperLen*sizeof(WCHAR)+2);
    if (wszSuperClass == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm1(wszSuperClass, dwSuperLen*sizeof(WCHAR)+2);

    wszSuperClass[dwSuperLen] = 0;
    memcpy(wszSuperClass, pBlob+sizeof(DWORD), dwSuperLen*sizeof(WCHAR));
    DWORD dwPrefixLen = sizeof(DWORD) + dwSuperLen*sizeof(WCHAR);

    memcpy(&nTime, pBlob + dwPrefixLen, sizeof(__int64));

    //
    // Get the superclass
    //

    _IWmiObject* pSuperClass;
    __int64 nSuperTime;
    bool bRead;
    hres = GetClassDirect(wszSuperClass, IID__IWmiObject, (void**)&pSuperClass,
                            false, &nSuperTime, &bRead, NULL);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;

    CReleaseMe rm1(pSuperClass);

#ifdef A51_CHECK_TIMESTAMPS
    _ASSERT(nSuperTime <= nTime, L"Parent class is older than child");
#endif

    DWORD dwClassLen = dwSize - dwPrefixLen - sizeof(__int64);
    _IWmiObject* pNewObj;
    hres = pSuperClass->MergeAndDecorate(WMIOBJECT_MERGE_FLAG_CLASS, 
                                                                 dwClassLen, pBlob + dwPrefixLen + sizeof(__int64), 
                                                                 m_wszMachineName, m_wsNamespace,
                                                                 &pNewObj);
    if(FAILED(hres))
        return hres;

    //
    // Cache it!
    //

    hres = pNewObj->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;
    CClearMe cm1(&vClass);

    m_pClassCache->AssertClass(pNewObj, V_BSTR(&vClass), bClone, nTime, false);

    *ppClass = pNewObj;
    if(pnTime)
        *pnTime = nTime;
    if (pbSystemClass)
        *pbSystemClass = false;

    return S_OK;
}

HRESULT CNamespaceHandle::PutObject(
     REFIID riid,
    LPVOID pObj,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult,
    CEventCollector &aEvents
    )
{
    HRESULT hres;

    _IWmiObject* pObjEx = NULL;
    ((IUnknown*)pObj)->QueryInterface(IID__IWmiObject, (void**)&pObjEx);
    CReleaseMe rm1(pObjEx);
    
    if(pObjEx->IsObjectInstance() == S_OK)
    {
        hres = PutInstance(pObjEx, dwFlags, aEvents);
    }
    else
    {
        hres = PutClass(pObjEx, dwFlags, aEvents);
    }

    if(FAILED(hres))
        return hres;

    if(ppResult)
    {
        //
        // Got to get a handle
        //

        VARIANT v;
        hres = pObjEx->Get(L"__RELPATH", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;

        hres = GetObjectHandleByPath(V_BSTR(&v), 0, WMIDB_HANDLE_TYPE_COOKIE, 
            ppResult);
        if(FAILED(hres))
            return hres;
    }
    return S_OK;
}

HRESULT CNamespaceHandle::PutInstance(_IWmiObject* pInst, DWORD dwFlags, 
                                        CEventCollector &aEvents)
{
    HRESULT hres;

    bool bDisableEvents = ((dwFlags & WMIDB_DISABLE_EVENTS)?true:false);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
    // Get the class so we can compare to make sure it is the same class used to
    // create the instance
    //

    _IWmiObject* pClass = NULL;
    __int64 nClassTime;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, &nClassTime, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm2(pClass);

    if(wszClassName[0] != L'_')
    {
        hres = pInst->IsParentClass(0, pClass);
        if(FAILED(hres))
            return hres;

        if(hres == WBEM_S_FALSE)
            return WBEM_E_INVALID_CLASS;
    }

    //
    // Get the path
    //

    VARIANT var;
    VariantInit(&var);
    hres = pInst->Get(L"__relpath", 0, &var, 0, 0);
    if (FAILED(hres))
        return hres;
    CClearMe cm2(&var);
    DWORD dwLen = (wcslen(V_BSTR(&var)) + 1) ;
    LPWSTR strKey = (WCHAR*)TempAlloc(dwLen* sizeof(WCHAR));
    if(strKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(strKey, dwLen* sizeof(WCHAR));

    bool bIsClass;
    LPWSTR __wszClassName = NULL;
    hres = ComputeKeyFromPath(V_BSTR(&var), strKey, dwLen, &__wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(__wszClassName);

    //
    // Get the old copy
    //

    _IWmiObject* pOldInst = NULL;
    hres = GetInstanceByKey(wszClassName, strKey, IID__IWmiObject, 
            (void**)&pOldInst);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;
    CReleaseMe rm1(pOldInst);

    if ((dwFlags & WBEM_FLAG_CREATE_ONLY) && (hres != WBEM_E_NOT_FOUND))
        return WBEM_E_ALREADY_EXISTS;
    else if ((dwFlags & WBEM_FLAG_UPDATE_ONLY) && (hres != WBEM_S_NO_ERROR))
        return WBEM_E_NOT_FOUND;

    if(pOldInst)
    {
        // 
        // Check that this guy is of the same class as the new one
        //

        //
        // Get the class name
        //
    
        VARIANT vClass2;
        hres  = pOldInst->Get(L"__CLASS", 0, &vClass2, NULL, NULL);
        if(FAILED(hres))
            return hres;
        if(V_VT(&vClass2) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;
    
        CClearMe cm3(&vClass2);

        if(wbem_wcsicmp(V_BSTR(&vClass2), wszClassName))
            return WBEM_E_INVALID_CLASS;
    }

    //
    // Construct the hash for the file
    //

    CFileName wszInstanceHash;
    if (wszInstanceHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if(!Hash(strKey, wszInstanceHash))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Construct the path to the instance file in key root
    //

    CFileName wszInstanceFilePath;
    if (wszInstanceFilePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszInstanceFilePath, wszClassName);
    if(FAILED(hres))
        return hres;

    StringCchCatW(wszInstanceFilePath, wszInstanceFilePath.Length() , L"\\" A51_INSTDEF_FILE_PREFIX);
    StringCchCatW(wszInstanceFilePath, wszInstanceFilePath.Length(), wszInstanceHash);

    //
    // Construct the path to the link file under the class
    //

    CFileName wszInstanceLinkPath;
    if (wszInstanceLinkPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszInstanceLinkPath, wszClassName);
    if(FAILED(hres))
        return hres;

    StringCchCatW(wszInstanceLinkPath, wszInstanceLinkPath.Length(), L"\\" A51_INSTLINK_FILE_PREFIX);
    StringCchCatW(wszInstanceLinkPath, wszInstanceLinkPath.Length(), wszInstanceHash);

    //
    // Clean up what was there, if anything
    //

    if(pOldInst)   
    {
        //
        // Just delete it, but be careful not to delete the scope!
        //

        hres = DeleteInstanceSelf(wszInstanceFilePath, pOldInst, false);
        if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
            return hres;
    }
        
    //
    // Create the actual instance def under key root
    //

    hres = InstanceToFile(pInst, wszClassName, wszInstanceFilePath, wszInstanceLinkPath, nClassTime);
    if(FAILED(hres))
        return hres;

    //
    // Write the references
    //

    hres = WriteInstanceReferences(pInst, wszClassName, wszInstanceFilePath);
    if(FAILED(hres))
        return hres;
    
    if(!bDisableEvents)
    {
        //
        // Fire Event
        //
    
        if(pInst->InheritsFrom(L"__Namespace") == S_OK)
        {
            //
            // Get the namespace name
            //

            VARIANT vClass2;
            VariantInit(&vClass2);
            CClearMe cm3(&vClass2);

            hres = pInst->Get(L"Name", 0, &vClass2, NULL, NULL);
            if(FAILED(hres) || V_VT(&vClass2) != VT_BSTR)
                return WBEM_E_INVALID_OBJECT;

            if(pOldInst)
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceModification,
                            V_BSTR(&vClass2), pInst, pOldInst);
            }
            else
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceCreation, 
                            V_BSTR(&vClass2), pInst);
            }
        }
        else
        {
            if(pOldInst)
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceModification, 
                            wszClassName, pInst, pOldInst);
            }
            else
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceCreation, 
                            wszClassName, pInst);
            }
        }
    }

    return S_OK;
}

HRESULT CNamespaceHandle::GetKeyRoot(LPCWSTR wszClass, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass)
{
    HRESULT hres;

    //
    // Look in the cache first
    //

    hres = m_pClassCache->GetKeyRoot(wszClass, pwszKeyRootClass);
    if(hres == S_OK)
        return S_OK;
    else if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // Walk up the tree getting classes until you hit an unkeyed one
    //

    WString wsThisName = wszClass;
    WString wsPreviousName;

    while(1)
    {
        _IWmiObject* pClass = NULL;

        hres = GetClassDirect(wsThisName, IID__IWmiObject, (void**)&pClass, 
                                false, NULL, NULL, NULL);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pClass);

        //
        // Check if this class is keyed
        //

        unsigned __int64 i64Flags = 0;
        hres = pClass->QueryObjectFlags(0, WMIOBJECT_GETOBJECT_LOFLAG_KEYED,
                                        &i64Flags);
        if(FAILED(hres))
            return hres;
    
        if(i64Flags == 0)
        {
            //
            // It is not keyed --- the previous class wins!
            //

            if(wsPreviousName.Length() == 0)    
                return WBEM_E_CANNOT_BE_ABSTRACT;

            DWORD dwLen = wsPreviousName.Length()+1;
            *pwszKeyRootClass = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
            if (*pwszKeyRootClass == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            StringCchCopyW(*pwszKeyRootClass, dwLen, (LPCWSTR)wsPreviousName);
            return S_OK;
        }

        //
        // It is keyed --- get the parent and continue;
        //

        VARIANT vParent;
        VariantInit(&vParent);
        CClearMe cm(&vParent);
        hres = pClass->Get(L"__SUPERCLASS", 0, &vParent, NULL, NULL);
        if(FAILED(hres))
            return hres;

        if(V_VT(&vParent) != VT_BSTR)
        {
            //
            // We've reached the top --- return this class
            //
        
            DWORD dwLen = wsThisName.Length()+1;
            *pwszKeyRootClass = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
            if (*pwszKeyRootClass == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            StringCchCopyW(*pwszKeyRootClass, dwLen, (LPCWSTR)wsThisName);
            return S_OK;
        }

        wsPreviousName = wsThisName;
        wsThisName = V_BSTR(&vParent);
    }

    // Never here

#ifdef DBG
    DebugBreak();
#endif
    return WBEM_E_CRITICAL_ERROR;
}

HRESULT CNamespaceHandle::ConstructKeyRootDirFromClass(CFileName& wszDir,
                                            LPCWSTR wszClassName)
{
    HRESULT hres;

    //
    // NULL class stands for "meta-class"
    //

    if(wszClassName == NULL)
        return ConstructKeyRootDirFromKeyRoot(wszDir, L"");

    //
    // Figure out the key root for the class
    //

    LPWSTR wszKeyRootClass = NULL;

    hres = GetKeyRoot(wszClassName, &wszKeyRootClass);
    if(FAILED(hres))
        return hres;
    if(wszKeyRootClass == NULL)
    {
        // Abstract class --- bad error
        return WBEM_E_INVALID_CLASS;
    }
    CTempFreeMe tfm(wszKeyRootClass, (wcslen(wszKeyRootClass)+1)*sizeof(WCHAR));

    return ConstructKeyRootDirFromKeyRoot(wszDir, wszKeyRootClass);
}


HRESULT CNamespaceHandle::ConstructKeyRootDirFromKeyRoot(CFileName& wszDir, 
                                                LPCWSTR wszKeyRootClass)
{
    StringCchCopyW(wszDir, wszDir.Length(), m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    StringCchCopyW(wszDir+m_lInstanceRootDirLen+1, wszDir.Length()-m_lInstanceRootDirLen-1, A51_KEYROOTINST_DIR_PREFIX);
    if(!Hash(wszKeyRootClass, 
             wszDir+m_lInstanceRootDirLen+wcslen(A51_KEYROOTINST_DIR_PREFIX)+1))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

HRESULT CNamespaceHandle::ConstructLinkDirFromClass(CFileName& wszDir, 
                                                LPCWSTR wszClassName)
{
    StringCchCopyW(wszDir, wszDir.Length(), m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    StringCchCopyW(wszDir+m_lInstanceRootDirLen+1, wszDir.Length()-m_lInstanceRootDirLen-1, A51_CLASSINST_DIR_PREFIX);
    if(!Hash(wszClassName, 
             wszDir+m_lInstanceRootDirLen+wcslen(A51_CLASSINST_DIR_PREFIX)+1))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

HRESULT CNamespaceHandle::ConstructLinkDirFromClassHash(CFileName& wszDir, 
                                                LPCWSTR wszClassHash)
{
    StringCchCopyW(wszDir, wszDir.Length(), m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    StringCchCopyW(wszDir+m_lInstanceRootDirLen+1, wszDir.Length()-m_lInstanceRootDirLen-1, A51_CLASSINST_DIR_PREFIX);
    StringCchCatW(wszDir, wszDir.Length(), wszClassHash);

    return S_OK;
}
    

HRESULT CNamespaceHandle::WriteInstanceReferences(_IWmiObject* pInst, 
                                                    LPCWSTR wszClassName,
                                                    LPCWSTR wszFilePath)
{
    HRESULT hres;

    hres = pInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    VARIANT v;
    BSTR strName;
    while((hres = pInst->Next(0, &strName, &v, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);
        CClearMe cm(&v);

        if(V_VT(&v) == VT_BSTR)
        {
            hres = WriteInstanceReference(wszFilePath, wszClassName, strName, 
                                        V_BSTR(&v));
            if(FAILED(hres))
                return hres;
        }
    }

    if(FAILED(hres))
        return hres;

    pInst->EndEnumeration();
    
    return S_OK;
}

// NOTE: will clobber wszTargetPath
HRESULT CNamespaceHandle::ConstructReferenceDir(LPWSTR wszTargetPath,
                                            CFileName& wszReferenceDir)
{
    //
    // Deconstruct the target path name so that we could get a directory
    // for it
    //

    DWORD dwKeySpace = (wcslen(wszTargetPath)+1) ;
    LPWSTR wszKey = (LPWSTR)TempAlloc(dwKeySpace* sizeof(WCHAR));
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm2(wszKey, dwKeySpace* sizeof(WCHAR));

    LPWSTR wszClassName = NULL;
    LPWSTR wszTargetNamespace = NULL;
    bool bIsClass;
    HRESULT hres = ComputeKeyFromPath(wszTargetPath, wszKey, dwKeySpace,&wszClassName,
                                        &bIsClass, &wszTargetNamespace);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName);
    wszTargetPath = NULL; // invalidated by parsing

    CTempFreeMe tfm3(wszTargetNamespace);

    //
    // Check if the target namespace is the same as ours
    //

    CNamespaceHandle* pTargetHandle = NULL;
    if(wszTargetNamespace && wbem_wcsicmp(wszTargetNamespace, m_wsNamespace))
    {
        //
        // It's different --- open it!
        //

        hres = m_pRepository->GetNamespaceHandle(wszTargetNamespace,
                                &pTargetHandle);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Unable to open target namespace "
                "'%S' in namespace '%S'\n", wszTargetNamespace,
                (LPCWSTR)m_wsNamespace));
            return hres;
        }
    }
    else
    {
        pTargetHandle = this;
        pTargetHandle->AddRef();
    }

    CReleaseMe rm1(pTargetHandle);

    if(bIsClass)
    {
        return pTargetHandle->ConstructReferenceDirFromKey(NULL, wszClassName, 
                                            wszReferenceDir);
    }
    else
    {
        return pTargetHandle->ConstructReferenceDirFromKey(wszClassName, wszKey,
                                            wszReferenceDir);
    }
}

HRESULT CNamespaceHandle::ConstructReferenceDirFromKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey, CFileName& wszReferenceDir)
{
    HRESULT hres;

    //
    // Construct the class directory for this instance
    //

    hres = ConstructKeyRootDirFromClass(wszReferenceDir, wszClassName);
    if(FAILED(hres))
        return hres;

    int nLen = wcslen(wszReferenceDir);
    StringCchCopyW(wszReferenceDir+nLen, wszReferenceDir.Length()-nLen, L"\\" A51_INSTREF_DIR_PREFIX);
    nLen += 1 + wcslen(A51_INSTREF_DIR_PREFIX);

    //
    // Write instance hash
    //

    if(!Hash(wszKey, wszReferenceDir+nLen))
        return WBEM_E_OUT_OF_MEMORY;

    return S_OK;
}

    

    
    
    
// NOTE: will clobber wszReference
HRESULT CNamespaceHandle::ConstructReferenceFileName(LPWSTR wszReference,
                        LPCWSTR wszReferringFile, CFileName& wszReferenceFile)
{
    HRESULT hres = ConstructReferenceDir(wszReference, wszReferenceFile);
    if(FAILED(hres))
        return hres;
    wszReference = NULL; // invalid

    //
    // It is basically 
    // irrelevant, we should use a randomly constructed name.  Right now, we
    // use a hash of the class name of the referrer --- THIS IS A BUG, THE SAME
    // INSTANCE CAN POINT TO THE SAME ENDPOINT TWICE!!
    //

    StringCchCatW(wszReferenceFile, wszReferenceFile.Length(), L"\\"A51_REF_FILE_PREFIX);
    DWORD dwLen = wcslen(wszReferenceFile);
    if (!Hash(wszReferringFile, wszReferenceFile+dwLen))
        return WBEM_E_OUT_OF_MEMORY;
    return S_OK;
}

// NOTE: will clobber wszReference
HRESULT CNamespaceHandle::WriteInstanceReference(LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringClass,
                            LPCWSTR wszReferringProp, LPWSTR wszReference)
{
    HRESULT hres;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
    if (wszReferenceFile == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceFileName(wszReference, wszReferringFile, 
                                wszReferenceFile);
    if(FAILED(hres))
    {
        if(hres == WBEM_E_NOT_FOUND)
        {
            //
            // Oh joy. A reference to an instance of a *class* that does not
            // exist (not a non-existence instance, those are normal).
            // Forget it (BUGBUG)
            //

            return S_OK;
        }
        else
            return hres;
    }
    
    //
    // Construct the buffer
    //

    DWORD dwTotalLen = 4 * sizeof(DWORD) + 
                (wcslen(wszReferringClass) + wcslen(wszReferringProp) + 
                    wcslen(wszReferringFile) - g_Glob.GetRootDirLen() + 
                    wcslen(m_wsNamespace) + 4) 
                        * sizeof(WCHAR);

    BYTE* pBuffer = (BYTE*)TempAlloc(dwTotalLen);
    if (pBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwTotalLen);

    BYTE* pCurrent = pBuffer;
    DWORD dwStringLen;

    //
    // Write namespace name
    //

    dwStringLen = wcslen(m_wsNamespace);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    memcpy(pCurrent, m_wsNamespace, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write the referring class name
    //

    dwStringLen = wcslen(wszReferringClass);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringClass, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write referring property name
    //

    dwStringLen = wcslen(wszReferringProp);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringProp, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write referring file name minus the database root path. Notice that we 
    // cannot skip the namespace-specific prefix lest we break cross-namespace
    // associations
    //

    dwStringLen = wcslen(wszReferringFile) - g_Glob.GetRootDirLen();
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringFile + g_Glob.GetRootDirLen(), 
        sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // All done --- create the file
    //

    long lRes = g_Glob.m_FileCache.WriteObject(wszReferenceFile, NULL, dwTotalLen,
                    pBuffer);
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);
    
    return S_OK;
}

    
    
    
    

    
    
    



HRESULT CNamespaceHandle::PutClass(_IWmiObject* pClass, DWORD dwFlags, 
                                        CEventCollector &aEvents)
{
    HRESULT hres;

    bool bDisableEvents = ((dwFlags & WMIDB_DISABLE_EVENTS)?true:false);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pClass->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres))
    	return hres;
    else if ((V_VT(&vClass) != VT_BSTR) || 
        !V_BSTR(&vClass) || !wcslen(V_BSTR(&vClass)))
    {
        return WBEM_E_INVALID_OBJECT;
    }

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
    // Check to make sure this class was created from a valid parent class
    //

    VARIANT vSuperClass;

    hres  = pClass->Get(L"__SUPERCLASS", 0, &vSuperClass, NULL, NULL);
    if (FAILED(hres))
        return hres;
    CClearMe cm2(&vSuperClass);

    _IWmiObject* pSuperClass = NULL;
    if ((V_VT(&vSuperClass) == VT_BSTR) && V_BSTR(&vSuperClass) && 
        wcslen(V_BSTR(&vSuperClass)))
    {
        LPCWSTR wszSuperClassName = V_BSTR(&vSuperClass);

        // do not clone
        hres = GetClassDirect(wszSuperClassName, IID__IWmiObject, 
                                (void**)&pSuperClass, false, NULL, NULL, NULL); 
        if (hres == WBEM_E_NOT_FOUND)
            return WBEM_E_INVALID_SUPERCLASS;
        if (FAILED(hres))
            return hres;

        if(wszClassName[0] != L'_')
        {
            hres = pClass->IsParentClass(0, pSuperClass);
            if(FAILED(hres))
                return hres;
            if(hres == WBEM_S_FALSE)
                return WBEM_E_INVALID_SUPERCLASS;
        }
    }
    CReleaseMe rm(pSuperClass);

    //
    // Retrieve the previous definition, if any
    //

    _IWmiObject* pOldClass = NULL;
    __int64 nOldTime = 0;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pOldClass,
                            false, &nOldTime, NULL, NULL); // do not clone
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;
    CReleaseMe rm1(pOldClass);

    if ((dwFlags & WBEM_FLAG_CREATE_ONLY) && (hres !=  WBEM_E_NOT_FOUND))
        return WBEM_E_ALREADY_EXISTS;

    if ((dwFlags & WBEM_FLAG_UPDATE_ONLY) && (FAILED(hres)))
        return WBEM_E_NOT_FOUND;

    //
    // If the class exists, we need to check the update scenarios to make sure 
    // we do not break any
    //

    bool bNoClassChangeDetected = false;
    if (pOldClass)
    {
        hres = pClass->CompareDerivedMostClass(0, pOldClass);
        if ((hres != WBEM_S_FALSE) && (hres != WBEM_S_NO_ERROR))
            return hres;
        else if (hres == WBEM_S_NO_ERROR)
            bNoClassChangeDetected = true;
    }

    if (!bNoClassChangeDetected)
    {
        if (pOldClass != NULL) 
        {
            hres = CanClassBeUpdatedCompatible(dwFlags, wszClassName, pOldClass,
                                                pClass);            
            if(FAILED(hres))
            {
                if((dwFlags & WBEM_FLAG_UPDATE_SAFE_MODE) == 0 &&
                    (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0)
                {
                    // Can't compatibly, not allowed any other way
                    return hres;
                }

                if(hres != WBEM_E_CLASS_HAS_CHILDREN &&
                    hres != WBEM_E_CLASS_HAS_INSTANCES)
                {
                    // some serious failure!
                    return hres;
                }

                //
                // This is a safe mode or force mode update which takes more 
                // than a compatible update to carry out the operation
                //

                return UpdateClassSafeForce(pSuperClass, dwFlags, wszClassName, 
                                            pOldClass, pClass, aEvents);
            }
        }

        //
        // Either there was no previous copy, or it is compatible with the new
        // one, so we can perform a compatible update
        //

        hres = UpdateClassCompatible(pSuperClass, wszClassName, pClass, 
                                            pOldClass, nOldTime);
        if (FAILED(hres))
            return hres;

    }

    if(!bDisableEvents)
    {
        if(pOldClass)
        {
            hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassModification, 
                                wszClassName, pClass, pOldClass);
        }
        else
        {
            hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassCreation, 
                                wszClassName, pClass);
        }
    }

    return S_OK;
}

HRESULT CNamespaceHandle::UpdateClassCompatible(_IWmiObject* pSuperClass, 
            LPCWSTR wszClassName, _IWmiObject *pClass, _IWmiObject *pOldClass, 
            __int64 nFakeUpdateTime)
{
    HRESULT hres;

    //
    // Construct the path for the file
    //
    CFileName wszHash;
    if (wszHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    return UpdateClassCompatibleHash(pSuperClass, wszHash, pClass, pOldClass, 
                                        nFakeUpdateTime);
}

HRESULT CNamespaceHandle::UpdateClassCompatibleHash(_IWmiObject* pSuperClass,
            LPCWSTR wszClassHash, _IWmiObject *pClass, _IWmiObject *pOldClass, 
            __int64 nFakeUpdateTime)
{
    HRESULT hres;

    CFileName wszFileName;
    CFileName wszFilePath;
    if ((wszFileName == NULL) || (wszFilePath == NULL))
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(wszFileName, wszFileName.Length(), A51_CLASSDEF_FILE_PREFIX);
    StringCchCatW(wszFileName, wszFileName.Length(), wszClassHash);

    StringCchCopyW(wszFilePath, wszFilePath.Length(), m_wszClassRootDir);
    StringCchCatW(wszFilePath, wszFilePath.Length(), L"\\");
    StringCchCatW(wszFilePath, wszFilePath.Length(), wszFileName);

    //
    // Write it into the file
    //

    hres = ClassToFile(pSuperClass, pClass, wszFilePath, 
                        nFakeUpdateTime);
    if(FAILED(hres))
        return hres;

    //
    // Add all needed references --- parent, pointers, etc    
    //

    if (pOldClass)
    {
        VARIANT v;
        VariantInit(&v);
        hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        CClearMe cm(&v);

        if(SUCCEEDED(hres))
        {
            hres = EraseClassRelationships(V_BSTR(&v), pOldClass, wszFileName);
        }
        if (FAILED(hres))
            return hres;
    }

    hres = WriteClassRelationships(pClass, wszFileName);

    return hres;

}



HRESULT CNamespaceHandle::UpdateClassSafeForce(_IWmiObject* pSuperClass,
            DWORD dwFlags, LPCWSTR wszClassName, _IWmiObject *pOldClass, 
            _IWmiObject *pNewClass, CEventCollector &aEvents)
{
    HRESULT hres = UpdateClassAggressively(pSuperClass, dwFlags, wszClassName, 
                                        pNewClass, pOldClass, aEvents);

    // 
    // If this is a force mode update and we failed for anything other than 
    // out of memory then we should delete the class and try again.
    //

    if (FAILED(hres) && 
        (hres != WBEM_E_OUT_OF_MEMORY) && 
        (hres != WBEM_E_CIRCULAR_REFERENCE) &&
        (hres != WBEM_E_UPDATE_TYPE_MISMATCH) &&
        (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE))
    {
        //
        // We need to delete the class and try again.
        //

        hres = DeleteClass(wszClassName, aEvents,false);
        if(FAILED(hres))
            return hres;

        //Write class as though it did not exist
        hres = UpdateClassCompatible(pSuperClass, wszClassName, pNewClass, NULL);
    }

    return hres;
}

HRESULT CNamespaceHandle::UpdateClassAggressively(_IWmiObject* pSuperClass,
           DWORD dwFlags, LPCWSTR wszClassName, _IWmiObject *pNewClass, 
           _IWmiObject *pOldClass, CEventCollector &aEvents)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    if ((dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0)
    {
        //
        // If we have instances we need to quit as we cannot update them.
        // 

        hres = ClassHasInstances(wszClassName);
        if(FAILED(hres))
            return hres;

        if (hres == WBEM_S_NO_ERROR)
            return WBEM_E_CLASS_HAS_INSTANCES;

        _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code!");
    }
    else if (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE)
    {
        //
        // We need to delete the instances
        //

        hres = DeleteClassInstances(wszClassName, pOldClass, aEvents);
        if(FAILED(hres))
            return hres;
    }

    //
    // Retrieve all child classes and update them
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashes(wszClassName, wsChildHashes);
    if(FAILED(hres))
        return hres;

    for (int i = 0; i != wsChildHashes.Size(); i++)
    {
        hres = UpdateChildClassAggressively(dwFlags, wsChildHashes[i], 
                                    pNewClass, aEvents);
        if (FAILED(hres))
            return hres;
    }

    //
    // Now we need to write the class back, update class refs etc.
    //

    hres = UpdateClassCompatible(pSuperClass, wszClassName, pNewClass, 
                                        pOldClass);
    if(FAILED(hres))
        return hres;

    //
    // Generate the class modification event...
    //

    if(!(dwFlags & WMIDB_DISABLE_EVENTS))
    {
        hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassModification, wszClassName, pNewClass, pOldClass);
    }

    return S_OK;
}

HRESULT CNamespaceHandle::UpdateChildClassAggressively(DWORD dwFlags, 
            LPCWSTR wszClassHash, _IWmiObject *pNewParentClass, 
            CEventCollector &aEvents)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    dwFlags &= (WBEM_FLAG_UPDATE_FORCE_MODE | WBEM_FLAG_UPDATE_SAFE_MODE);

    if ((dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0)
    {
        hres = ClassHasInstancesFromClassHash(wszClassHash);
        if(FAILED(hres))
            return hres;

        if (hres == WBEM_S_NO_ERROR)
            return WBEM_E_CLASS_HAS_INSTANCES;

        _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code!");
    }

    //
    // Get the old class definition
    //

    _IWmiObject *pOldClass = NULL;
    hres = GetClassByHash(wszClassHash, true, &pOldClass, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pOldClass);

    if (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE)
    {
        //
        // Need to delete all its instances, if any
        //

        VARIANT v;
        VariantInit(&v);
        hres = pOldClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        if(FAILED(hres))
            return hres;

        CClearMe cm(&v);

        hres = DeleteClassInstances(V_BSTR(&v), pOldClass, aEvents);
        if(FAILED(hres))
            return hres;
    }

    //
    // Update the existing class definition to work with the new parent class
    //

    _IWmiObject *pNewClass = NULL;
    hres = pNewParentClass->Update(pOldClass, dwFlags, &pNewClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pNewClass);

    //
    // Now we have to recurse through all child classes and do the same
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashesByHash(wszClassHash, wsChildHashes);
    if(FAILED(hres))
        return hres;

    for (int i = 0; i != wsChildHashes.Size(); i++)
    {
        hres = UpdateChildClassAggressively(dwFlags, wsChildHashes[i], 
                                    pNewClass, aEvents);
        if (FAILED(hres))
            return hres;
    }

    // 
    // Now we need to write the class back, update class refs etc
    //


    hres = UpdateClassCompatibleHash(pNewParentClass, wszClassHash, 
                                            pNewClass, pOldClass);
    if(FAILED(hres))
        return hres;

    return S_OK;
}

HRESULT CNamespaceHandle::CanClassBeUpdatedCompatible(DWORD dwFlags, 
        LPCWSTR wszClassName, _IWmiObject *pOldClass, _IWmiObject *pNewClass)
{
    HRESULT hres;

    HRESULT hresError = WBEM_S_NO_ERROR;

    //
    // Do we have subclasses?
    //

    hres = ClassHasChildren(wszClassName);
    if(FAILED(hres))
        return hres;

    if(hres == WBEM_S_NO_ERROR)
    {
        hresError = WBEM_E_CLASS_HAS_CHILDREN;
    }
    else
    {
        _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code");
    
        //
        // Do we have instances belonging to this class?  Don't even need to
        // worry about sub-classes because we know we have none at this point!
        //
    
        hres = ClassHasInstances(wszClassName);
        if(FAILED(hres))
            return hres;

        if(hres == WBEM_S_NO_ERROR)
        {
            hresError = WBEM_E_CLASS_HAS_INSTANCES;
        }
        else
        {
            _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code");

            //
            // No nothing!
            //

            return WBEM_S_NO_ERROR;
        }
    }

    _ASSERT(hresError != WBEM_S_NO_ERROR, L"");

    //
    // We have either subclasses or instances.
    // Can we reconcile this class safely?
    //

    hres = pOldClass->ReconcileWith(
                        WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE, pNewClass);

    if(hres == WBEM_S_NO_ERROR)
    {
        // reconcilable, so OK
        return WBEM_S_NO_ERROR;
    }
    else if(hres == WBEM_E_FAILED) // awful, isn't it
    {
        // irreconcilable
        return hresError;
    }
    else
    {
        return hres;
    }
}

HRESULT CNamespaceHandle::FireEvent(CEventCollector &aEvents, 
                                    DWORD dwType, LPCWSTR wszArg1,
                                    _IWmiObject* pObj1, _IWmiObject* pObj2)
{
    try
    {
        CRepEvent *pEvent = new CRepEvent(dwType, m_wsFullNamespace, wszArg1, 
                                            pObj1, pObj2);
        if (pEvent == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if (!aEvents.AddEvent(pEvent))
        {
            delete pEvent;
            return WBEM_E_OUT_OF_MEMORY;
        }
        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT CNamespaceHandle::WriteClassRelationships(_IWmiObject* pClass,
                                                LPCWSTR wszFileName)
{
    HRESULT hres;

    //
    // Get the parent
    //

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);

    if(FAILED(hres))
        return hres;

    if(V_VT(&v) == VT_BSTR)
        hres = WriteParentChildRelationship(wszFileName, V_BSTR(&v));
    else
        hres = WriteParentChildRelationship(wszFileName, L"");

    if(FAILED(hres))
        return hres;

    //
    // Write references
    //

    hres = pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);

        hres = WriteClassReference(pClass, wszFileName, strName);
        if(FAILED(hres))
            return hres;
    }

    pClass->EndEnumeration();

    if(FAILED(hres))
        return hres;

    return S_OK;
}

HRESULT CNamespaceHandle::WriteClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp)
{
    HRESULT hres;

    //
    // Figure out the class we are pointing to
    //

    DWORD dwSize = 0;
    DWORD dwFlavor = 0;
    CIMTYPE ct;
    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, 0,
            &ct, &dwFlavor, &dwSize, NULL);
    if(dwSize == 0)
        return WBEM_E_OUT_OF_MEMORY;

    LPWSTR wszQual = (WCHAR*)TempAlloc(dwSize);
    if(wszQual == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszQual, dwSize);

    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, dwSize,
            &ct, &dwFlavor, &dwSize, wszQual);
    if(FAILED(hres))
        return hres;
    
    //
    // Parse out the class name
    //

    WCHAR* pwcColon = wcschr(wszQual, L':');
    if(pwcColon == NULL)
        return S_OK; // untyped reference requires no bookkeeping

    LPCWSTR wszReferredToClass = pwcColon+1;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
    if (wszReferenceFile == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassReferenceFileName(wszReferredToClass, 
                                wszReferringFile, wszReferringProp,
                                wszReferenceFile);
    if(FAILED(hres))
        return hres;

    //
    // Create the empty file
    //

    long lRes = g_Glob.m_FileCache.WriteLink(wszReferenceFile);
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    return S_OK;
}

HRESULT CNamespaceHandle::WriteParentChildRelationship(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName)
{
    CFileName wszParentChildFileName;
    if (wszParentChildFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres = ConstructParentChildFileName(wszChildFileName,
                                                wszParentName,
                                                wszParentChildFileName);

    //
    // Create the file
    //

    long lRes = g_Glob.m_FileCache.WriteLink(wszParentChildFileName);
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    return S_OK;
}

HRESULT CNamespaceHandle::ConstructParentChildFileName(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName,
                            CFileName& wszParentChildFileName)
{
    //
    // Construct the name of the directory where the parent class keeps its
    // children
    //

    HRESULT hres = ConstructClassRelationshipsDir(wszParentName, 
                                                    wszParentChildFileName);
    if(FAILED(hres))
        return hres;

    //
    // Append the filename of the child, but substituting the child-class prefix
    // for the class-def prefix
    //

    StringCchCatW(wszParentChildFileName, wszParentChildFileName.Length(), L"\\" A51_CHILDCLASS_FILE_PREFIX);
    StringCchCatW(wszParentChildFileName, wszParentChildFileName.Length(),
        wszChildFileName + wcslen(A51_CLASSDEF_FILE_PREFIX));

    return S_OK;
}


HRESULT CNamespaceHandle::ConstructClassRelationshipsDir(LPCWSTR wszClassName,
                                CFileName& wszDirPath)
{
    StringCchCopyW(wszDirPath, wszDirPath.Length(), m_wszClassRootDir);
    StringCchCopyW(wszDirPath + m_lClassRootDirLen, wszDirPath.Length() - m_lClassRootDirLen, L"\\" A51_CLASSRELATION_DIR_PREFIX);
    
    if(!Hash(wszClassName, 
        wszDirPath + m_lClassRootDirLen + 1 + wcslen(A51_CLASSRELATION_DIR_PREFIX)))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    return S_OK;
}

HRESULT CNamespaceHandle::ConstructClassRelationshipsDirFromHash(
                                LPCWSTR wszHash, CFileName& wszDirPath)
{
    StringCchCopyW(wszDirPath, wszDirPath.Length(), m_wszClassRootDir);
    StringCchCopyW(wszDirPath + m_lClassRootDirLen, wszDirPath.Length()-m_lClassRootDirLen, L"\\" A51_CLASSRELATION_DIR_PREFIX);
    StringCchCopyW(wszDirPath + m_lClassRootDirLen + 1 +wcslen(A51_CLASSRELATION_DIR_PREFIX),
            wszDirPath.Length() - m_lClassRootDirLen - 1 - wcslen(A51_CLASSRELATION_DIR_PREFIX), 
            wszHash);
    return S_OK;
}

HRESULT CNamespaceHandle::ConstructClassReferenceFileName(
                                LPCWSTR wszReferredToClass,
                                LPCWSTR wszReferringFile, 
                                LPCWSTR wszReferringProp,
                                CFileName& wszFileName)
{
    HRESULT hres;

    hres = ConstructClassRelationshipsDir(wszReferredToClass, wszFileName);
    if(FAILED(hres))
        return hres;

    //
    // Extract the portion of the referring file containing the class hash
    //

    WCHAR* pwcLastUnderscore = wcsrchr(wszReferringFile, L'_');
    if(pwcLastUnderscore == NULL)
        return WBEM_E_CRITICAL_ERROR;
    LPCWSTR wszReferringClassHash = pwcLastUnderscore+1;

    StringCchCatW(wszFileName, wszFileName.Length(), L"\\" A51_REF_FILE_PREFIX);
    StringCchCatW(wszFileName, wszFileName.Length(), wszReferringClassHash);
    return S_OK;
}

HRESULT CNamespaceHandle::DeleteObject(
     DWORD dwFlags,
     REFIID riid,
     LPVOID pObj,
     CEventCollector &aEvents
    )
{
#ifdef DBG
    DebugBreak();
#endif
    return E_NOTIMPL;
}

HRESULT CNamespaceHandle::DeleteObjectByPath(DWORD dwFlags,    LPWSTR wszPath, 
                                                CEventCollector &aEvents)
{

    bool bDisableEvents = ((dwFlags & WMIDB_DISABLE_EVENTS)?true:false);
    
    HRESULT hres;

    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszPath)+1;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen*sizeof(WCHAR));

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    hres = ComputeKeyFromPath(wszPath, wszKey, dwLen, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    if(bIsClass)
    {
        return DeleteClass(wszClassName, aEvents, bDisableEvents);
    }
    else
    {
        return DeleteInstance(wszClassName, wszKey, aEvents);
    }
}

HRESULT CNamespaceHandle::DeleteInstance(LPCWSTR wszClassName, LPCWSTR wszKey, 
                                            CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pClass);

    //
    // Create its directory
    //

    CFileName wszFilePath;
    if (wszFilePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszFilePath, wszClassName);
    if(FAILED(hres))
        return hres;
    
    //
    // Construct the path for the file
    //

    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructInstanceDefName(wszFileName, wszKey);
    if(FAILED(hres))
        return hres;

    StringCchCatW(wszFilePath, wszFilePath.Length(), L"\\");
    StringCchCatW(wszFilePath, wszFilePath.Length(), wszFileName);

    _IWmiObject* pInst;
    hres = FileToInstance(NULL, wszFilePath, NULL, 0, &pInst);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pInst);

    if(pInst->InheritsFrom(L"__Namespace") == S_OK)
    {
        //Make sure this is not a deletion of the root\default namespace
        VARIANT vName;
        VariantInit(&vName);
        CClearMe cm1(&vName);
        hres = pInst->Get(L"Name", 0, &vName, NULL, NULL);
        if(FAILED(hres))
            return WBEM_E_INVALID_OBJECT;

        LPCWSTR wszName = V_BSTR(&vName);
        if ((wbem_wcsicmp(m_wsFullNamespace, L"\\\\.\\root") == 0) && (wbem_wcsicmp(wszName, L"default") == 0))
            return WBEM_E_ACCESS_DENIED;
    }
    hres = DeleteInstanceByFile(wszFilePath, pInst, false, aEvents);
    if(FAILED(hres))
        return hres;

    //
    // Fire an event
    //

    if(pInst->InheritsFrom(L"__Namespace") == S_OK)
    {
        //
        // There is no need to do anything --- deletion of namespaces
        // automatically fires events in DeleteInstanceByFile (because we need
        // to accomplish it in the case of deleting a class derived from 
        // __NAMESPACE.
        //

    }
    else
    {
        hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceDeletion, wszClassName,
                        pInst);
    }

    return S_OK;
}

HRESULT CNamespaceHandle::DeleteInstanceByFile(LPCWSTR wszFilePath, 
                                _IWmiObject* pInst, bool bClassDeletion,
                                CEventCollector &aEvents)
{
    HRESULT hres;

    hres = DeleteInstanceSelf(wszFilePath, pInst, bClassDeletion);
    if(FAILED(hres))
        return hres;

    hres = DeleteInstanceAsScope(pInst, aEvents);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        return hres;
    }

    return S_OK;
}

HRESULT CNamespaceHandle::DeleteInstanceSelf(LPCWSTR wszFilePath, 
                                            _IWmiObject* pInst,
                                            bool bClassDeletion)
{
    HRESULT hres;

    //
    // Delete the file
    //

    long lRes = g_Glob.m_FileCache.DeleteObject(wszFilePath);
   	_ASSERT(lRes != ERROR_FILE_NOT_FOUND, L"WinMgmt: CNamespaceHandle::DeleteInstanceSelf: DeleteObject returned NOT_FOUND!\n");
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    hres = DeleteInstanceLink(pInst, wszFilePath);
   	_ASSERT(lRes != ERROR_FILE_NOT_FOUND, L"WinMgmt: CNamespaceHandle::DeleteInstanceSelf: DeleteInstanceLink returned NOT_FOUND!\n");
    if(FAILED(hres))
        return hres;

    hres = DeleteInstanceReferences(pInst, wszFilePath);
   	_ASSERT(lRes != ERROR_FILE_NOT_FOUND, L"WinMgmt: CNamespaceHandle::DeleteInstanceSelf: DeleteInstanceReferences returned NOT_FOUND!\n");
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    if(bClassDeletion)
    {
        //
        // We need to remove all dangling references to this instance, 
        // because they make no sense once the class is deleted --- we don't
        // know what key structure the new class will even have.  In the future,
        // we'll want to move these references to some class-wide location
        //

        hres = DeleteInstanceBackReferences(wszFilePath);
	   	_ASSERT(lRes != ERROR_FILE_NOT_FOUND, L"WinMgmt: CNamespaceHandle::DeleteInstanceSelf: DeleteInstanceBackReferences returned NOT_FOUND!\n");
        if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
            return hres;
    }

    return S_OK;
}

HRESULT CNamespaceHandle::ConstructReferenceDirFromFilePath(
                                LPCWSTR wszFilePath, CFileName& wszReferenceDir)
{
    //
    // It's the same, only with INSTDEF_FILE_PREFIX replaced with 
    // INSTREF_DIR_PREFIX
    //

    CFileName wszEnding;
    if (wszEnding == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    WCHAR* pwcLastSlash = wcsrchr(wszFilePath, L'\\');
    if(pwcLastSlash == NULL)
        return WBEM_E_FAILED;
    
    StringCchCopyW(wszEnding, wszEnding.Length(), pwcLastSlash + 1 + wcslen(A51_INSTDEF_FILE_PREFIX));

    StringCchCopyW(wszReferenceDir, wszReferenceDir.Length(), wszFilePath);
    wszReferenceDir[(pwcLastSlash+1)-wszFilePath] = 0;

    StringCchCatW(wszReferenceDir, wszReferenceDir.Length(), A51_INSTREF_DIR_PREFIX);
    StringCchCatW(wszReferenceDir, wszReferenceDir.Length(), wszEnding);
    return S_OK;
}

HRESULT CNamespaceHandle::DeleteInstanceBackReferences(LPCWSTR wszFilePath)
{
    HRESULT hres;

    CFileName wszReferenceDir;
    if (wszReferenceDir == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceDirFromFilePath(wszFilePath, wszReferenceDir);
    if(FAILED(hres))
        return hres;
    StringCchCatW(wszReferenceDir, wszReferenceDir.Length(), L"\\");

    CFileName wszReferencePrefix;
    if (wszReferencePrefix == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszReferencePrefix, wszReferencePrefix.Length(), wszReferenceDir);
    StringCchCatW(wszReferencePrefix, wszReferencePrefix.Length(), A51_REF_FILE_PREFIX);

    // Prepare a buffer for file path
    CFileName wszFullFileName;
    if (wszFullFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(wszFullFileName, wszFullFileName.Length(), wszReferenceDir);
    long lDirLen = wcslen(wszFullFileName);

    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Enumerate all files in it

    void* hSearch;

    long lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszReferencePrefix, &hSearch);
    if (lRes == ERROR_FILE_NOT_FOUND)
        return ERROR_SUCCESS;
    else if (lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    while ((lRes = g_Glob.m_FileCache.IndexEnumerationNext(hSearch, wszFileName)) == ERROR_SUCCESS)
    {
        StringCchCopyW(wszFullFileName+lDirLen, wszFullFileName.Length()-lDirLen, wszFileName);

        lRes = g_Glob.m_FileCache.DeleteObject(wszFullFileName);
	   	_ASSERT(lRes != ERROR_FILE_NOT_FOUND, L"WinMgmt: CNamespaceHandle::DeleteInstanceBackReferences: DeleteObject returned NOT_FOUND!\n");
        if(lRes != ERROR_SUCCESS)
        {
            ERRORTRACE((LOG_WBEMCORE, "Cannot delete reference file '%S' with "
                "error code %d\n", wszFullFileName, lRes));
            lRes = ERROR_INVALID_OPERATION;    //trigger the correct error!
        }
    }
    
    g_Glob.m_FileCache.IndexEnumerationEnd(hSearch);

    if(lRes == ERROR_NO_MORE_FILES)
    {
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return A51TranslateErrorCode(lRes);
    }
    return S_OK;
}



HRESULT CNamespaceHandle::DeleteInstanceLink(_IWmiObject* pInst,
                                                LPCWSTR wszInstanceDefFilePath)
{
    HRESULT hres;

    //
    // Get the class name
    //
    
    VARIANT vClass;
    VariantInit(&vClass);
    CClearMe cm1(&vClass);
    
    hres = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_OBJECT;

    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
    // Construct the link directory for the class
    //

    CFileName wszInstanceLinkPath;
    if (wszInstanceLinkPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszInstanceLinkPath, wszClassName);
    if(FAILED(hres))
        return hres;

    StringCchCatW(wszInstanceLinkPath, wszInstanceLinkPath.Length(), L"\\" A51_INSTLINK_FILE_PREFIX);

    //
    // It remains to append the instance-specific part of the file name.  
    // Convineintly, it is the same material as was used for the def file path,
    // so we can steal it.  ALERT: RELIES ON ALL PREFIXES ENDING IN '_'!!
    //

    WCHAR* pwcLastUnderscore = wcsrchr(wszInstanceDefFilePath, L'_');
    if(pwcLastUnderscore == NULL)
        return WBEM_E_CRITICAL_ERROR;

    StringCchCatW(wszInstanceLinkPath, wszInstanceLinkPath.Length(), pwcLastUnderscore+1);

    //
    // Delete the file
    //

    long lRes = g_Glob.m_FileCache.DeleteLink(wszInstanceLinkPath);
   	_ASSERT(lRes != ERROR_FILE_NOT_FOUND, L"WinMgmt: CNamespaceHandle::DeleteInstanceLink: DeleteLink returned NOT_FOUND!\n");
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    return S_OK;
}

    


HRESULT CNamespaceHandle::DeleteInstanceAsScope(_IWmiObject* pInst, CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // For now, just check if it is a namespace
    //

    hres = pInst->InheritsFrom(L"__Namespace");
    if(FAILED(hres))
        return hres;

    if(hres != S_OK) // not a namespace
        return S_FALSE;

    CFileName wszFullNameHash;
    if (wszFullNameHash == NULL)
    {
    	return WBEM_E_OUT_OF_MEMORY;
    }

    WString wsFullName = m_wsNamespace;
    wsFullName += L"\\";

    VARIANT vName;
    VariantInit(&vName);
    CClearMe cm(&vName);
    hres = pInst->Get(L"Name", 0, &vName, NULL, NULL);
    if(FAILED(hres))
        return hres;
    if(V_VT(&vName) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    wsFullName += V_BSTR(&vName);

    //Add this namespace to the list
    CWStringArray aChildNamespaces;
	if (aChildNamespaces.Add(wsFullName) != 0)
		return WBEM_E_OUT_OF_MEMORY;
	
    //Now enumerate all child namespaces and do the same for each of them!
    hres = EnumerateChildNamespaces(wsFullName, aChildNamespaces, aEvents);
    if (FAILED(hres))
    	return hres;

    //Fire the namespace deletion event for this namespace
    hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceDeletion, V_BSTR(&vName), pInst);
    if (FAILED(hres))
    	return hres;
    
    //Loop through the namespaces deleting them and firing events
    while (aChildNamespaces.Size())
    {
    	wchar_t *wszNamespace = aChildNamespaces[aChildNamespaces.Size()-1];

	    //Generate the full namespace hash of this namespace
		StringCchCopyW(wszFullNameHash, MAX_PATH, g_Glob.GetRootDir());
	    StringCchCatW(wszFullNameHash, MAX_PATH, L"\\NS_");
	    if (!Hash(wszNamespace, wszFullNameHash + wcslen(wszFullNameHash)))
	        return WBEM_E_OUT_OF_MEMORY;

        LONG lRes = g_Glob.m_FileCache.DeleteNode(wszFullNameHash);
	    hres = A51TranslateErrorCode(lRes);
		if (FAILED(hres))
			break;
	
    	aChildNamespaces.RemoveAt(aChildNamespaces.Size()-1);
    }

    return hres;
}

HRESULT CNamespaceHandle::EnumerateChildNamespaces(LPCWSTR wsRootNamespace, 
														  CWStringArray &aNamespaces,
														  CEventCollector &aEvents)
{
	//We know the namespace we need to look under, we know the class key root, so we
	//can enumerate all the instances of that class and do a FileToInstance on them all.  From
	//that we can add the event and the entry to the namespace list, and do the enumeration
	//of child namespaces on them
	LONG lRes = 0;
	HRESULT hRes = 0;
	CFileName wsNamespaceHash;
	if (wsNamespaceHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CFileName wszInstancePath;
	if (wszInstancePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CFileName wszChildNamespacePath;
	if (wszChildNamespacePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	CNamespaceHandle *pNs = new CNamespaceHandle(m_pControl, m_pRepository);
	if (pNs == NULL)
	    return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<CNamespaceHandle> cdm(pNs);
    hRes = pNs->Initialize(wsRootNamespace);
    if (FAILED(hRes))
        return hRes;

	//Create the hashed path to the Key Root for the namespace
	StringCchCopyW(wsNamespaceHash, MAX_PATH, g_Glob.GetRootDir());
	StringCchCatW(wsNamespaceHash, MAX_PATH, L"\\NS_");
	if (!Hash(wsRootNamespace, wsNamespaceHash + wcslen(wsNamespaceHash)))
        return WBEM_E_OUT_OF_MEMORY;
	StringCchCatW(wsNamespaceHash, MAX_PATH, L"\\" A51_KEYROOTINST_DIR_PREFIX);
	if (!Hash(L"__namespace", wsNamespaceHash + wcslen(wsNamespaceHash)))
        return WBEM_E_OUT_OF_MEMORY;
	StringCchCatW(wsNamespaceHash, MAX_PATH, L"\\" A51_INSTDEF_FILE_PREFIX);

	//Enumerate all the objects
	LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.ObjectEnumerationBegin(wsNamespaceHash, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
    	BYTE *pBlob = NULL;
    	DWORD dwSize = 0;
        while(1)
        {
            lRes = g_Glob.m_FileCache.ObjectEnumerationNext(pEnumHandle, wsNamespaceHash, &pBlob, &dwSize);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                lRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
                break;
            
        	//Get the instance
            _IWmiObject* pInstance = NULL;
            hRes = pNs->FileToInstance(NULL, wsNamespaceHash, pBlob, dwSize, &pInstance, true);

        	//Free the blob
            g_Glob.m_FileCache.ObjectEnumerationFree(pEnumHandle, pBlob);

            if (FAILED(hRes))
            	break;
            CReleaseMe rm2(pInstance);


            //Extract the string from the object
    	    VARIANT vName;
    	    VariantInit(&vName);
    	    CClearMe cm(&vName);
    	    hRes = pInstance->Get(L"Name", 0, &vName, NULL, NULL);
    	    if(FAILED(hRes))
    	        break;
    	    if(V_VT(&vName) != VT_BSTR)
    	    {
    	    	hRes = WBEM_E_INVALID_OBJECT;
    	        break;
    	    }

    		//Create the full namespace path
    		StringCchCopyW(wszChildNamespacePath, MAX_PATH, wsRootNamespace);
    		StringCchCatW(wszChildNamespacePath, MAX_PATH, L"\\");
    		StringCchCatW(wszChildNamespacePath, MAX_PATH, V_BSTR(&vName));


    		//Add it to the namespace list
    		if (aNamespaces.Add(wszChildNamespacePath) != 0)
    		{
    			hRes = WBEM_E_OUT_OF_MEMORY;
    			break;
    		}
    		
    		//Call this method again to recurse into it
       		hRes = EnumerateChildNamespaces(wszChildNamespacePath, aNamespaces, aEvents);
    		if (FAILED(hRes))
    		    break;

    		//Fire the event
            hRes = pNs->FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceDeletion, V_BSTR(&vName), pInstance);
    		if (FAILED(hRes))
    		    break;
        }

        g_Glob.m_FileCache.ObjectEnumerationEnd(pEnumHandle);
    }
    else
    {
    	if (lRes == ERROR_FILE_NOT_FOUND)
    		lRes = ERROR_SUCCESS;
    }

    if (lRes)
        hRes = A51TranslateErrorCode(lRes);

    if (SUCCEEDED(hRes))
    {
        //Invalidate class cache for this namespace
        pNs->m_pClassCache->Clear();
        pNs->m_pClassCache->SetError(WBEM_E_INVALID_NAMESPACE);
    }
    return hRes;
}

HRESULT CNamespaceHandle::DeleteInstanceReferences(_IWmiObject* pInst, 
                                                LPCWSTR wszFilePath)
{
    HRESULT hres;

    hres = pInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    VARIANT v;
    while((hres = pInst->Next(0, NULL, &v, NULL, NULL)) == S_OK)
    {
        CClearMe cm(&v);

        if(V_VT(&v) == VT_BSTR)
        {
            hres = DeleteInstanceReference(wszFilePath, V_BSTR(&v));
            if(FAILED(hres))
                return hres;
        }
    }

    if(FAILED(hres))
        return hres;

    pInst->EndEnumeration();
    return S_OK;
}
    
// NOTE: will clobber wszReference
HRESULT CNamespaceHandle::DeleteInstanceReference(LPCWSTR wszOurFilePath,
                                            LPWSTR wszReference)
{
    HRESULT hres;

    CFileName wszReferenceFile;
    if (wszReferenceFile == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceFileName(wszReference, wszOurFilePath, wszReferenceFile);
    if(FAILED(hres))
    {
        if(hres == WBEM_E_NOT_FOUND)
        {
            //
            // Oh joy. A reference to an instance of a *class* that does not
            // exist (not a non-existence instance, those are normal).
            // Forget it (BUGBUG)
            //

            return S_OK;
        }
        else
            return hres;
    }

    long lRes = g_Glob.m_FileCache.DeleteObject(wszReferenceFile);
    if(lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);
    else
        return WBEM_S_NO_ERROR;
}


HRESULT CNamespaceHandle::DeleteClassByHash(LPCWSTR wszHash, CEventCollector &aEvents, bool bDisableEvents)
{
    HRESULT hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    bool bSystemClass = false;
    hres = GetClassByHash(wszHash, false, &pClass, NULL, NULL, &bSystemClass);
    CReleaseMe rm1(pClass);
    if(FAILED(hres))
        return hres;

    //
    // Get the actual class name
    //

    VARIANT v;
    hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm1(&v);

    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_CLASS;

    //
    // Construct definition file name
    //

    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileNameFromHash(wszHash, wszFileName);
    if(FAILED(hres))
        return hres;

    return DeleteClassInternal(V_BSTR(&v), pClass, wszFileName, aEvents, bSystemClass, bDisableEvents);
}
    
HRESULT CNamespaceHandle::DeleteClass(LPCWSTR wszClassName, 
                                 CEventCollector &aEvents,
                                 bool bDisableEvents)
{
    HRESULT hres;

    //
    // Construct the path for the file
    //

    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileName(wszClassName, wszFileName);
    if(FAILED(hres))
        return hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    bool bSystemClass = false;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, NULL, NULL, &bSystemClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    return DeleteClassInternal(wszClassName, pClass, wszFileName, aEvents, bSystemClass, bDisableEvents);
}

HRESULT CNamespaceHandle::DeleteClassInternal(LPCWSTR wszClassName,
                                              _IWmiObject* pClass,
                                              LPCWSTR wszFileName,
                                              CEventCollector &aEvents,
                                              bool bSystemClass,
                                              bool bDisableEvents)
{
    HRESULT hres;

    CFileName wszFilePath;
    if (wszFilePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    Cat2Str(wszFilePath, m_wszClassRootDir, wszFileName);

    //
    // Delete all derived classes
    //

    hres = DeleteDerivedClasses(wszClassName, aEvents, bDisableEvents);

    if(FAILED(hres))
        return hres;

    //
    // Delete all instances.  Only fire events if namespaces are deleted
    //

    bool bNamespaceOnly = aEvents.IsNamespaceOnly();
    aEvents.SetNamespaceOnly(true);
    hres = DeleteClassInstances(wszClassName, pClass, aEvents);
    if(FAILED(hres))
        return hres;
    aEvents.SetNamespaceOnly(bNamespaceOnly);

    if (!bSystemClass)
    {
        //
        // Clean up references
        //

        hres = EraseClassRelationships(wszClassName, pClass, wszFileName);
        if(FAILED(hres))
            return hres;

        //
        // Delete the file
        //


        long lRes = g_Glob.m_FileCache.DeleteObject(wszFilePath);
        _ASSERT(lRes != ERROR_FILE_NOT_FOUND, L"WinMgmt: CNamespaceHandle::DeleteClassInternal: DeleteObject returned NOT_FOUND!\n");
        if(lRes != ERROR_SUCCESS)
            return A51TranslateErrorCode(lRes);

        //Delete any entrails that exist under the CR_<hash> node.  Change c:\windows\....\NS_<HASH>\CD_<HASH> to ...\CR_<HASH>
        wszFilePath[wcslen(wszFilePath)-MAX_HASH_LEN-2] = L'R';
        lRes = g_Glob.m_FileCache.DeleteNode(wszFilePath);
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = 0;
        if (lRes != ERROR_SUCCESS)
            return A51TranslateErrorCode(lRes);
    }

    m_pClassCache->InvalidateClass(wszClassName);

    if (!bDisableEvents)
    {
        //
        // Fire an event
        //
        hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassDeletion, wszClassName, pClass);
    }

    return S_OK;
}

HRESULT CNamespaceHandle::DeleteDerivedClasses(LPCWSTR wszClassName, 
                                         CEventCollector &aEvents,
                                         bool bDisableEvents)
{
    HRESULT hres;

    CWStringArray wsChildHashes;
    hres = GetChildHashes(wszClassName, wsChildHashes);
    if(FAILED(hres))
        return hres;

    for(int i = 0; i < wsChildHashes.Size(); i++)
    {
    
        hres = DeleteClassByHash(wsChildHashes[i], aEvents, bDisableEvents);

        if(FAILED(hres) && (hres != WBEM_E_NOT_FOUND))
        {
            return hres;
        }
    }

    return S_OK;
}

HRESULT CNamespaceHandle::GetChildDefs(LPCWSTR wszClassName, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone)
{
    CFileName wszHash;
    if (wszHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;
    return GetChildDefsByHash(wszHash, bRecursive, pSink, bClone);
}

HRESULT CNamespaceHandle::GetChildDefsByHash(LPCWSTR wszHash, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone)
{
    HRESULT hres;

    long lStartIndex = m_pClassCache->GetLastInvalidationIndex();

    //
    // Get the hashes of the child filenames
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashesByHash(wszHash, wsChildHashes);
    if(FAILED(hres))
        return hres;

    //
    // Get their class definitions
    //

    for(int i = 0; i < wsChildHashes.Size(); i++)
    {
        LPCWSTR wszChildHash = wsChildHashes[i];

        _IWmiObject* pClass = NULL;
        hres = GetClassByHash(wszChildHash, bClone, &pClass, NULL, NULL, NULL);
        if (WBEM_E_NOT_FOUND == hres)
        {
            hres = S_OK;
            continue;
        }
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pClass);

        hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
        if(FAILED(hres))
            return hres;
        
        //
        // Continue recursively if indicated
        //

        if(bRecursive)
        {
            hres = GetChildDefsByHash(wszChildHash, bRecursive, pSink, bClone);
            if(FAILED(hres))
                return hres;
        }
    }

    //
    // Mark cache completeness
    //

    m_pClassCache->DoneWithChildrenByHash(wszHash, bRecursive, lStartIndex);
    return S_OK;
}

    
HRESULT CNamespaceHandle::GetChildHashes(LPCWSTR wszClassName, 
                                        CWStringArray& wsChildHashes)
{
    CFileName wszHash;
    if (wszHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    return GetChildHashesByHash(wszHash, wsChildHashes);
}

HRESULT CNamespaceHandle::GetChildHashesByHash(LPCWSTR wszHash, 
                                        CWStringArray& wsChildHashes)
{
    HRESULT hres;
    long lRes;

    //Try retrieving the system classes namespace first...
    if (g_pSystemClassNamespace && (wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0))
    {
        hres = g_pSystemClassNamespace->GetChildHashesByHash(wszHash, wsChildHashes);
        if (FAILED(hres))
            return hres;
    }

    //
    // Construct the prefix for the children classes
    //

    CFileName wszChildPrefix;
    if (wszChildPrefix == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDirFromHash(wszHash, wszChildPrefix);
    if(FAILED(hres))
        return hres;

    StringCchCatW(wszChildPrefix, wszChildPrefix.Length(), L"\\" A51_CHILDCLASS_FILE_PREFIX);

    //
    // Enumerate all such files in the cache
    //

    void* pHandle = NULL;
    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszChildPrefix, &pHandle);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return ERROR_SUCCESS;
	else if (lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);
    
    while((lRes = g_Glob.m_FileCache.IndexEnumerationNext(pHandle, wszFileName)) == ERROR_SUCCESS)
    {
        if (wsChildHashes.Add(wszFileName + wcslen(A51_CHILDCLASS_FILE_PREFIX)) != CWStringArray::no_error)
        {
        	lRes = ERROR_OUTOFMEMORY;
        	break;
        }
    }

    g_Glob.m_FileCache.IndexEnumerationEnd(pHandle);

    if(lRes != ERROR_NO_MORE_FILES && lRes != S_OK)
        return A51TranslateErrorCode(lRes);
    else
        return S_OK;
}

HRESULT CNamespaceHandle::ClassHasChildren(LPCWSTR wszClassName)
{
    CFileName wszHash;
    if (wszHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;
    
    HRESULT hres;
    long lRes;

    //Try retrieving the system classes namespace first...
    if (g_pSystemClassNamespace && (wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0))
    {
        hres = g_pSystemClassNamespace->ClassHasChildren(wszClassName);
        if (FAILED(hres) || (hres == WBEM_S_NO_ERROR))
            return hres;
    }
    //
    // Construct the prefix for the children classes
    //

    CFileName wszChildPrefix;
    if (wszChildPrefix == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDirFromHash(wszHash, wszChildPrefix);
    if(FAILED(hres))
        return hres;

    StringCchCatW(wszChildPrefix, wszChildPrefix.Length(), L"\\" A51_CHILDCLASS_FILE_PREFIX);

    void* pHandle = NULL;

    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszChildPrefix, &pHandle);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return WBEM_S_FALSE;
	if (lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);

    g_Glob.m_FileCache.IndexEnumerationEnd(pHandle);

    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ClassHasInstances(LPCWSTR wszClassName)
{
    CFileName wszHash;
    if (wszHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    return ClassHasInstancesFromClassHash(wszHash);
}

HRESULT CNamespaceHandle::ClassHasInstancesFromClassHash(LPCWSTR wszClassHash)
{
    HRESULT hres;
    long lRes;

    //
    // Check the instances in this namespace first.  The instance directory in
    // default scope is the class directory of the namespace
    //

    hres = ClassHasInstancesInScopeFromClassHash(m_wszClassRootDir, 
                                                    wszClassHash);
    if(hres != WBEM_S_FALSE)
        return hres;

    return WBEM_S_FALSE;
}
        
HRESULT CNamespaceHandle::ClassHasInstancesInScopeFromClassHash(
                            LPCWSTR wszInstanceRootDir, LPCWSTR wszClassHash)
{
    CFileName wszFullDirName;
    if (wszFullDirName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszFullDirName, wszFullDirName.Length(), wszInstanceRootDir);
    StringCchCatW(wszFullDirName, wszFullDirName.Length(), L"\\" A51_CLASSINST_DIR_PREFIX);
    StringCchCatW(wszFullDirName, wszFullDirName.Length(), wszClassHash);
    StringCchCatW(wszFullDirName, wszFullDirName.Length(), L"\\" A51_INSTLINK_FILE_PREFIX);

    void* pHandle = NULL;

	LONG lRes;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszFullDirName, &pHandle);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return WBEM_S_FALSE;
	if (lRes != ERROR_SUCCESS)
	{
		return A51TranslateErrorCode(lRes);
	}

	if(pHandle)
	    g_Glob.m_FileCache.IndexEnumerationEnd(pHandle);

    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::EraseParentChildRelationship(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName)
{
    CFileName wszParentChildFileName;
    if (wszParentChildFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres = ConstructParentChildFileName(wszChildFileName,
                                                wszParentName,
                                                wszParentChildFileName);
    if (FAILED(hres))
        return hres;
    //
    // Delete the file
    //

    long lRes = g_Glob.m_FileCache.DeleteLink(wszParentChildFileName);
   	_ASSERT(lRes != ERROR_FILE_NOT_FOUND, L"WinMgmt: CNamespaceHandle::EraseParentChildRelationship: DeleteLink returned NOT_FOUND!\n");
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    return S_OK;
}

HRESULT CNamespaceHandle::EraseClassRelationships(LPCWSTR wszClassName,
                            _IWmiObject* pClass, LPCWSTR wszFileName)
{
    HRESULT hres;

    //
    // Get the parent
    //

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);


    if(FAILED(hres))
        return hres;

    if(V_VT(&v) == VT_BSTR)
        hres = EraseParentChildRelationship(wszFileName, V_BSTR(&v));
    else
        hres = EraseParentChildRelationship(wszFileName, L"");

    if(FAILED(hres))
        return hres;

    //
    // Erase references
    //

    hres = pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);

        hres = EraseClassReference(pClass, wszFileName, strName);
        if(FAILED(hres) && (hres != WBEM_E_NOT_FOUND))
            return hres;
    }

    pClass->EndEnumeration();

    return S_OK;
}

HRESULT CNamespaceHandle::EraseClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp)
{
    HRESULT hres;

    //
    // Figure out the class we are pointing to
    //

    DWORD dwSize = 0;
    DWORD dwFlavor = 0;
    CIMTYPE ct;
    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, 0,
            &ct, &dwFlavor, &dwSize, NULL);
    if(dwSize == 0)
        return WBEM_E_OUT_OF_MEMORY;

    LPWSTR wszQual = (WCHAR*)TempAlloc(dwSize);
    if(wszQual == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszQual, dwSize);

    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, dwSize,
            &ct, &dwFlavor, &dwSize, wszQual);
    if(FAILED(hres))
        return hres;
    
    //
    // Parse out the class name
    //

    WCHAR* pwcColon = wcschr(wszQual, L':');
    if(pwcColon == NULL)
        return S_OK; // untyped reference requires no bookkeeping

    LPCWSTR wszReferredToClass = pwcColon+1;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
    if (wszReferenceFile == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassReferenceFileName(wszReferredToClass, 
                                wszReferringFile, wszReferringProp,
                                wszReferenceFile);
    if(FAILED(hres))
        return hres;

    //
    // Delete the file
    //

    long lRes = g_Glob.m_FileCache.DeleteLink(wszReferenceFile);
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    return S_OK;
}

HRESULT CNamespaceHandle::DeleteClassInstances(LPCWSTR wszClassName, 
                                               _IWmiObject* pClass,
                                               CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // Find the link directory for this class
    //

    CFileName wszLinkDir;
    if (wszLinkDir == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszLinkDir, wszClassName);
    if(FAILED(hres))
        return hres;
    
    // 
    // Enumerate all links in it
    //

    CFileName wszSearchPrefix;
    if (wszSearchPrefix == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszSearchPrefix, wszSearchPrefix.Length(), wszLinkDir);
    StringCchCatW(wszSearchPrefix, wszSearchPrefix.Length(), L"\\" A51_INSTLINK_FILE_PREFIX);


    //
    // Prepare a buffer for instance definition file path
    //

    CFileName wszFullFileName;
    if (wszFullFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = ConstructKeyRootDirFromClass(wszFullFileName, wszClassName);
    if(FAILED(hres))
    {
        if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
            return WBEM_S_NO_ERROR;

        return hres;
    }

    long lDirLen = wcslen(wszFullFileName);
    wszFullFileName[lDirLen] = L'\\';
    lDirLen++;

    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    void* hSearch;
    long lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszSearchPrefix, &hSearch);
    if (lRes == ERROR_FILE_NOT_FOUND)
        return ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    CFileName tmpFullFileName;
    if (tmpFullFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    while((lRes = g_Glob.m_FileCache.IndexEnumerationNext(hSearch, wszFileName)) == ERROR_SUCCESS)
    {
        hres = ConstructInstDefNameFromLinkName(tmpFullFileName, wszFileName);
        if(FAILED(hres))
            break;
        StringCchCopyW(wszFullFileName+lDirLen, wszFullFileName.Length()-lDirLen, tmpFullFileName);

        _IWmiObject* pInst;
        hres = FileToInstance(NULL, wszFullFileName, NULL, 0, &pInst);
        if(FAILED(hres))
            break;

        CReleaseMe rm1(pInst);

        //
        // Delete the instance, knowing that we are deleting its class. That
        // has an affect on how we deal with the references
        //

        hres = DeleteInstanceByFile(wszFullFileName, pInst, true, aEvents);
        if(FAILED(hres))
            break;
    }

    g_Glob.m_FileCache.IndexEnumerationEnd(hSearch);

    if (hres != ERROR_SUCCESS)
        return hres;

    if(lRes != ERROR_NO_MORE_FILES && lRes != S_OK)
    {
        return A51TranslateErrorCode(lRes);
    }

    return S_OK;
}

class CExecQueryObject : public CFiberTask
{
protected:
    IWbemQuery* m_pQuery;
    CDbIterator* m_pIter;
    CNamespaceHandle* m_pNs;
    DWORD m_lFlags;

public:
    CExecQueryObject(CNamespaceHandle* pNs, IWbemQuery* pQuery, 
                        CDbIterator* pIter, DWORD lFlags)
        : m_pQuery(pQuery), m_pIter(pIter), m_pNs(pNs), m_lFlags(lFlags)
    {
        m_pQuery->AddRef();
        m_pNs->AddRef();

        //
        // Does not AddRef the iterator --- iterator owns and cleans up the req
        //
    }

    ~CExecQueryObject()
    {
        if(m_pQuery)
            m_pQuery->Release();
        if(m_pNs)
            m_pNs->Release();
    }
    
    HRESULT Execute()
    {
        HRESULT hres = m_pNs->ExecQuerySink(m_pQuery, m_lFlags, 0, m_pIter, NULL);
        m_pIter->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
        return hres;
    }
};


HRESULT CNamespaceHandle::ExecQuery(
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    DWORD *dwMessageFlags,
    IWmiDbIterator **ppQueryResult
    )
{
    CDbIterator* pIter = new CDbIterator(m_pControl, m_bUseIteratorLock);
    m_bUseIteratorLock = true;
    if (pIter == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pIter->AddRef();
    CReleaseMe rm1((IWmiDbIterator*)pIter);

    //
    // Create a fiber execution object
    //

    CExecQueryObject* pReq = new CExecQueryObject(this, pQuery, pIter, dwFlags);
    if(pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Create a fiber for it
    //

    void* pFiber = CreateFiberForTask(pReq);
    if(pFiber == NULL)
    {
        delete pReq;
        return WBEM_E_OUT_OF_MEMORY;
    }

    pIter->SetExecFiber(pFiber, pReq);

    return pIter->QueryInterface(IID_IWmiDbIterator, (void**)ppQueryResult);
}

HRESULT CNamespaceHandle::ExecQuerySink(
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWbemObjectSink* pSink,
    DWORD *dwMessageFlags
    )
{
    try
    {
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;
        
        HRESULT hres;

        LPWSTR wszQuery = NULL;
        hres = pQuery->GetAnalysis(WMIQ_ANALYSIS_QUERY_TEXT, 0, (void**)&wszQuery);
        if (FAILED(hres))
            return hres;

        DWORD dwLen = wcslen(wszQuery) + 1;
        LPWSTR strParse = (LPWSTR)TempAlloc(dwLen * sizeof(wchar_t));
        if(strParse == NULL)
        {
            pQuery->FreeMemory(wszQuery);
            return WBEM_E_OUT_OF_MEMORY;
        }
        CTempFreeMe tfm(strParse, dwLen * sizeof(wchar_t));
        StringCchCopyW(strParse, dwLen, wszQuery);

         if(!wbem_wcsicmp(wcstok(strParse, L" "), L"references"))
        {
            hres = ExecReferencesQuery(wszQuery, pSink);
            pQuery->FreeMemory(wszQuery);
            return hres;
        }

        QL_LEVEL_1_RPN_EXPRESSION* pExpr = NULL;
        CTextLexSource Source(wszQuery);
        QL1_Parser Parser(&Source);
        int nRet = Parser.Parse(&pExpr);
        CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

        pQuery->FreeMemory(wszQuery);

        if (nRet == QL1_Parser::OUT_OF_MEMORY)
            return WBEM_E_OUT_OF_MEMORY;
        if (nRet != QL1_Parser::SUCCESS)
            return WBEM_E_FAILED;

        if(!wbem_wcsicmp(pExpr->bsClassName, L"meta_class"))
        {
            return ExecClassQuery(pExpr, pSink, dwFlags);
        }
        else
        {
            return ExecInstanceQuery(pExpr, pExpr->bsClassName, 
                                     (dwFlags & WBEM_FLAG_SHALLOW ? false : true), 
                                        pSink);
        }
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}


HRESULT CNamespaceHandle::ExecClassQuery(QL_LEVEL_1_RPN_EXPRESSION* pExpr, 
                                            IWbemObjectSink* pSink,
                                            DWORD dwFlags)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;

    HRESULT hres = ERROR_SUCCESS;

    //
    // Optimizations:
    //

    LPCWSTR wszClassName = NULL;
    LPCWSTR wszSuperClass = NULL;
    LPCWSTR wszAncestor = NULL;
    bool bDontIncludeAncestorInResultSet = false;

    if(pExpr->nNumTokens == 1)
    {
        QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens;
        if(!wbem_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__SUPERCLASS") &&
            pToken->nOperator == QL1_OPERATOR_EQUALS)
        {
            wszSuperClass = V_BSTR(&pToken->vConstValue);
        }
        else if(!wbem_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__THIS") &&
            pToken->nOperator == QL1_OPERATOR_ISA)
        {
            wszAncestor = V_BSTR(&pToken->vConstValue);
        }
        else if(!wbem_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__CLASS") &&
            pToken->nOperator == QL1_OPERATOR_EQUALS)
        {
            wszClassName = V_BSTR(&pToken->vConstValue);
        }
    }
    else if (pExpr->nNumTokens == 3)
    {
        //
        // This is a special optimisation used for deep enumeration of classes,
        // and is expecting a query of:
        //   select * from meta_class where __this isa '<class_name>' 
        //                                  and __class <> '<class_name>'
        // where the <class_name> is the same class iin both cases.  This will 
        // set the wszAncestor to <class_name> and propagate a flag to not 
        // include the actual ancestor in the list.
        //

        QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens;

        if ((pToken[0].nTokenType == QL1_OP_EXPRESSION) &&
            (pToken[1].nTokenType == QL1_OP_EXPRESSION) &&
            (pToken[2].nTokenType == QL1_AND) &&
            (pToken[0].nOperator == QL1_OPERATOR_ISA) &&
            (pToken[1].nOperator == QL1_OPERATOR_NOTEQUALS) &&
            (wbem_wcsicmp(pToken[0].PropertyName.GetStringAt(0), L"__THIS") == 0) &&
            (wbem_wcsicmp(pToken[1].PropertyName.GetStringAt(0), L"__CLASS") == 0) 
            &&
            (wcscmp(V_BSTR(&pToken[0].vConstValue), 
                    V_BSTR(&pToken[1].vConstValue)) == 0)
           )
        {
            wszAncestor = V_BSTR(&pToken[0].vConstValue);
            bDontIncludeAncestorInResultSet = true;
        }
    }

    if(wszClassName)
    {
        _IWmiObject* pClass = NULL;
        hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass,
                                true, NULL, NULL, NULL);
        if(hres == WBEM_E_NOT_FOUND)
        {
            //
            // Class not there --- but that's success for us!
            //
            if (dwFlags & WBEM_FLAG_VALIDATE_CLASS_EXISTENCE)
                return hres;
            else
                return S_OK;
        }
        else if(FAILED(hres))
        {
            return hres;
        }
        else 
        {
            CReleaseMe rm1(pClass);

            //
            // Get the class
            //

            hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
            if(FAILED(hres))
                return hres;

            return S_OK;
        }
    }
    if (dwFlags & WBEM_FLAG_VALIDATE_CLASS_EXISTENCE)
    {
        _IWmiObject* pClass = NULL;
        if (wszSuperClass)
            hres = GetClassDirect(wszSuperClass, IID__IWmiObject, (void**)&pClass, false, NULL, NULL, NULL);
        else if (wszAncestor)
            hres = GetClassDirect(wszAncestor, IID__IWmiObject, (void**)&pClass, false, NULL, NULL, NULL);
        if (FAILED(hres))
            return hres;
        if (pClass)
            pClass->Release();
    }
    
    hres = EnumerateClasses(pSink, wszSuperClass, wszAncestor, true, 
                                bDontIncludeAncestorInResultSet);
    if(FAILED(hres))
        return hres;
    
    return S_OK;
}

HRESULT CNamespaceHandle::EnumerateClasses(IWbemObjectSink* pSink,
                                LPCWSTR wszSuperClass, LPCWSTR wszAncestor,
                                bool bClone, 
                                bool bDontIncludeAncestorInResultSet)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    CWStringArray wsClasses;
    HRESULT hres;

    //
    // If superclass is given, check if its record is complete wrt children
    //

    if(wszSuperClass)
    {
        hres = m_pClassCache->EnumChildren(wszSuperClass, false, wsClasses);
        if(hres == WBEM_S_FALSE)
        {
            //
            // Not in cache --- get the info from files
            //

            return GetChildDefs(wszSuperClass, false, pSink, bClone);
        }
        else
        {
            if(FAILED(hres))
                return hres;
                
            return ListToEnum(wsClasses, pSink, bClone);
        }
    }
    else
    {
        if(wszAncestor == NULL)
            wszAncestor = L"";

        hres = m_pClassCache->EnumChildren(wszAncestor, true, wsClasses);
        if(hres == WBEM_S_FALSE)
        {
            //
            // Not in cache --- get the info from files
            //

            hres = GetChildDefs(wszAncestor, true, pSink, bClone);
            if(FAILED(hres))
                return hres;

            if(*wszAncestor && !bDontIncludeAncestorInResultSet)
            {
                //
                // The class is derived from itself
                //

                _IWmiObject* pClass =  NULL;
                hres = GetClassDirect(wszAncestor, IID__IWmiObject, 
                        (void**)&pClass, bClone, NULL, NULL, NULL);
                if(FAILED(hres))
                    return hres;
                CReleaseMe rm1(pClass);

                hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
                if(FAILED(hres))
                    return hres;
            }

            return S_OK;
        }
        else
        {
            if(FAILED(hres))
                return hres;

            if(*wszAncestor && !bDontIncludeAncestorInResultSet)
            {
              int nRet = wsClasses.Add(wszAncestor);
              if (nRet!= CWStringArray::no_error)
                  return WBEM_E_OUT_OF_MEMORY;
            }
            return ListToEnum(wsClasses, pSink, bClone);
        }
    }
}
    
HRESULT CNamespaceHandle::ListToEnum(CWStringArray& wsClasses, 
                                        IWbemObjectSink* pSink, bool bClone)
{
    HRESULT hres;

    for(int i = 0; i < wsClasses.Size(); i++)
    {
        _IWmiObject* pClass = NULL;
        if(wsClasses[i] == NULL || wsClasses[i][0] == 0)
            continue;

        hres = GetClassDirect(wsClasses[i], IID__IWmiObject, (void**)&pClass, 
                                bClone, NULL, NULL, NULL);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_NOT_FOUND)
            {
                // That's OK --- class got removed
            }
            else
                return hres;
        }
        else
        {
            CReleaseMe rm1(pClass);
            hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ExecInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassName, bool bDeep,
                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    WCHAR wszHash[MAX_HASH_LEN+1];
    if(!Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    if(bDeep)
        hres = ExecDeepInstanceQuery(pQuery, wszHash, pSink);
    else
        hres = ExecShallowInstanceQuery(pQuery, wszHash, pSink);

    if(FAILED(hres))
        return hres;
        
    return S_OK;
}

HRESULT CNamespaceHandle::ExecDeepInstanceQuery(
                                QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash,
                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    //
    // Get all our instances
    //

    hres = ExecShallowInstanceQuery(pQuery, wszClassHash, pSink);
    if(FAILED(hres))
        return hres;

    CWStringArray awsChildHashes;

    //
    // Check if the list of child classes is known to the cache
    //

    hres = m_pClassCache->EnumChildKeysByKey(wszClassHash, awsChildHashes);
    if (hres == WBEM_S_FALSE)
    {
        //
        // OK --- get them from the disk
        //

        hres = GetChildHashesByHash(wszClassHash, awsChildHashes);
    }
    
    if (FAILED(hres))
    {
        return hres;
    }

    //
    // We have our hashes --- call them recursively
    //

    for(int i = 0; i < awsChildHashes.Size(); i++)
    {
        LPCWSTR wszChildHash = awsChildHashes[i];
        hres = ExecDeepInstanceQuery(pQuery, wszChildHash, pSink);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}
        
HRESULT CNamespaceHandle::ExecShallowInstanceQuery(
                                QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash, 
                                IWbemObjectSink* pSink)
{    
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;

    HRESULT hres;

    // 
    // Enumerate all files in the link directory
    //

    CFileName wszSearchPrefix;
    if (wszSearchPrefix == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClassHash(wszSearchPrefix, wszClassHash);
    if(FAILED(hres))
        return hres;

    StringCchCatW(wszSearchPrefix, wszSearchPrefix.Length(), L"\\" A51_INSTLINK_FILE_PREFIX);

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassByHash(wszClassHash, false, &pClass, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    CFileName fn;
    if (fn == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    void* hSearch;
    long lRes = g_Glob.m_FileCache.ObjectEnumerationBegin(wszSearchPrefix, &hSearch);
    if (lRes == ERROR_FILE_NOT_FOUND)
        return S_OK;
    else if (lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    BYTE *pBlob = NULL;
    DWORD dwSize = 0;

    while ((hres == ERROR_SUCCESS) && 
           (lRes = g_Glob.m_FileCache.ObjectEnumerationNext(hSearch, fn, &pBlob, &dwSize) == ERROR_SUCCESS))
    {
        _IWmiObject* pInstance = NULL;

        hres = FileToInstance(pClass, fn, pBlob, dwSize, &pInstance, true);

        CReleaseMe rm2(pInstance);

        if (SUCCEEDED(hres))
            hres = pSink->Indicate(1, (IWbemClassObject**)&pInstance);
		
        g_Glob.m_FileCache.ObjectEnumerationFree(hSearch, pBlob);
    }

    g_Glob.m_FileCache.ObjectEnumerationEnd(hSearch);

    if (lRes == ERROR_NO_MORE_FILES)
        return S_OK;
    else if (lRes)
        return A51TranslateErrorCode(lRes);
    else
        return hres;
}

HRESULT CNamespaceHandle::ExecReferencesQuery(LPCWSTR wszQuery, 
                                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    //
    // Make a copy for parsing
    //
    size_t dwLen = wcslen(wszQuery)+1;
    LPWSTR wszParse = new WCHAR[dwLen];
    if (wszParse == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(wszParse);
    StringCchCopyW(wszParse, dwLen, wszQuery);

    //
    // Extract the path of the target object.
    //

    //
    // Find the first brace
    //

    WCHAR* pwcStart = wcschr(wszParse, L'{');
    if(pwcStart == NULL)
        return WBEM_E_INVALID_QUERY;

    //
    // Find the beginning of the path
    //

    while(*pwcStart && iswspace(*pwcStart)) pwcStart++;
    if(!*pwcStart)
        return WBEM_E_INVALID_QUERY;

    pwcStart++;
    
    //
    // Find the ending curly brace
    //

    WCHAR* pwc = pwcStart;
    WCHAR wcCurrentQuote = 0;
    while(*pwc && (wcCurrentQuote || *pwc != L'}'))
    {
        if(wcCurrentQuote)
        {
            if(*pwc == L'\\')
            {
                pwc++;
            }
            else if(*pwc == wcCurrentQuote)
                wcCurrentQuote = 0;
        }
        else if(*pwc == L'\'' || *pwc == L'"')
            wcCurrentQuote = *pwc;

        pwc++;
    }

    if(*pwc != L'}')
        return WBEM_E_INVALID_QUERY;

    //
    // Find the end of the path
    //
    
    WCHAR* pwcEnd = pwc-1;
    while(iswspace(*pwcEnd)) pwcEnd--;

    pwcEnd[1] = 0;
    
    LPWSTR wszTargetPath = pwcStart;
    if(wszTargetPath == NULL)
        return WBEM_E_INVALID_QUERY;

    //
    // Parse the path
    //

    dwLen = (wcslen(wszTargetPath)+1) ;
    LPWSTR wszKey = (LPWSTR)TempAlloc(dwLen* sizeof(WCHAR));
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen* sizeof(WCHAR));

    LPWSTR wszClassName = NULL;
    bool bIsClass;
    hres = ComputeKeyFromPath(wszTargetPath, wszKey, dwLen, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));
    
    if(bIsClass)
    {
        //
        // Need to execute an instance reference query to find all instances
        // pointing to this class
        //

        hres = ExecInstanceRefQuery(wszQuery, NULL, wszClassName, pSink);
        if(FAILED(hres))
            return hres;

        hres = ExecClassRefQuery(wszQuery, wszClassName, pSink);
        if(FAILED(hres))
            return hres;
    }
    else
    {
        hres = ExecInstanceRefQuery(wszQuery, wszClassName, wszKey, pSink);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}

HRESULT CNamespaceHandle::ExecInstanceRefQuery(LPCWSTR wszQuery, 
                                                LPCWSTR wszClassName,
                                                LPCWSTR wszKey,
                                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    //
    // Find the instance's ref dir.
    //

    CFileName wszReferenceDir;
    if (wszReferenceDir == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceDirFromKey(wszClassName, wszKey, wszReferenceDir);
    if(FAILED(hres))
        return hres;

    CFileName wszReferenceMask;
    if (wszReferenceMask == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszReferenceMask, wszReferenceMask.Length(), wszReferenceDir);
    StringCchCatW(wszReferenceMask, wszReferenceMask.Length(), L"\\" A51_REF_FILE_PREFIX);

    //
    // Prepare a buffer for file path
    //

    CFileName wszFullFileName;
    if (wszFullFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(wszFullFileName, wszFullFileName.Length(), wszReferenceDir);
    StringCchCatW(wszFullFileName, wszFullFileName.Length(), L"\\");
    long lDirLen = wcslen(wszFullFileName);

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    CFileName wszReferrerFileName;
    if (wszReferrerFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(wszReferrerFileName, wszReferrerFileName.Length(), g_Glob.GetRootDir());

    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    // 
    // Enumerate all files in it
    //

    void* hSearch;
    long lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszReferenceMask, &hSearch);
    if (lRes == ERROR_FILE_NOT_FOUND)
        return S_OK;
    else if (lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    while((lRes = g_Glob.m_FileCache.IndexEnumerationNext(hSearch, wszFileName)) == ERROR_SUCCESS)
    {
        StringCchCopyW(wszFullFileName+lDirLen, wszFullFileName.Length()-lDirLen,wszFileName);

        LPWSTR wszReferrerClass = NULL;
        LPWSTR wszReferrerProp = NULL;
        LPWSTR wszReferrerNamespace = NULL;
        hres = GetReferrerFromFile(wszFullFileName, wszReferrerFileName + g_Glob.GetRootDirLen(), &wszReferrerNamespace, &wszReferrerClass, &wszReferrerProp);
        if(FAILED(hres))
            continue;
        CVectorDeleteMe<WCHAR> vdm1(wszReferrerClass);
        CVectorDeleteMe<WCHAR> vdm2(wszReferrerProp);
        CVectorDeleteMe<WCHAR> vdm3(wszReferrerNamespace);

        // Check if the namespace of the referring object is the same as ours
        CNamespaceHandle* pReferrerHandle = NULL;
        if(wbem_wcsicmp(wszReferrerNamespace, m_wsNamespace))
        {
            // Open the other namespace
            hres = m_pRepository->GetNamespaceHandle(wszReferrerNamespace, &pReferrerHandle);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_WBEMCORE, "Unable to open referring namespace '%S' in namespace '%S'\n", wszReferrerNamespace, (LPCWSTR)m_wsNamespace));
                hresGlobal = hres;
                continue;
            }
        }
        else
        {
            pReferrerHandle = this;
            pReferrerHandle->AddRef();
        }

        CReleaseMe rm1(pReferrerHandle);


        _IWmiObject* pInstance = NULL;
        hres = pReferrerHandle->FileToInstance(NULL, wszReferrerFileName, NULL, 0, &pInstance);
        if(FAILED(hres))
        {
            // Oh well --- continue;
            hresGlobal = hres;
        }
        else
        {
            CReleaseMe rm2(pInstance);
            hres = pSink->Indicate(1, (IWbemClassObject**)&pInstance);
            if(FAILED(hres))
            {
                hresGlobal = hres;
                break;
            }
        }
    }

    g_Glob.m_FileCache.IndexEnumerationEnd(hSearch);

    if (hresGlobal != ERROR_SUCCESS)
        return hresGlobal;
    if(lRes == ERROR_NO_MORE_FILES)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return A51TranslateErrorCode(lRes);
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::GetReferrerFromFile(LPCWSTR wszReferenceFile,
                            LPWSTR wszReferrerRelFile, 
                            LPWSTR* pwszReferrerNamespace,
                            LPWSTR* pwszReferrerClass,
                            LPWSTR* pwszReferrerProp)
{
    //
    // Get the entire buffer from the file
    //

    BYTE* pBuffer = NULL;
    DWORD dwBufferLen = 0;
    long lRes = g_Glob.m_FileCache.ReadObject(wszReferenceFile, &dwBufferLen,
                                            &pBuffer);
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);
    CTempFreeMe tfm(pBuffer, dwBufferLen);

    if(dwBufferLen == 0)
        return WBEM_E_OUT_OF_MEMORY;

    BYTE* pCurrent = pBuffer;
    DWORD dwStringLen;

    //
    // Get the referrer namespace
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerNamespace = new WCHAR[dwStringLen+1];
    if (*pwszReferrerNamespace == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    (*pwszReferrerNamespace)[dwStringLen] = 0;
    memcpy(*pwszReferrerNamespace, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;
    
    //
    // Get the referrer class name
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerClass = new WCHAR[dwStringLen+1];
    if (*pwszReferrerClass == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    (*pwszReferrerClass)[dwStringLen] = 0;
    memcpy(*pwszReferrerClass, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Get the referrer property
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerProp = new WCHAR[dwStringLen+1];
    if (*pwszReferrerProp == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    (*pwszReferrerProp)[dwStringLen] = 0;
    memcpy(*pwszReferrerProp, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Get referrer file path
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    wszReferrerRelFile[dwStringLen] = 0;
    memcpy(wszReferrerRelFile, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    return S_OK;
}
    

HRESULT CNamespaceHandle::ExecClassRefQuery(LPCWSTR wszQuery, 
                                                LPCWSTR wszClassName,
                                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres = ERROR_SUCCESS;

    //Execute against system class namespace first
    if (g_pSystemClassNamespace && (wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0))
    {
        hres = g_pSystemClassNamespace->ExecClassRefQuery(wszQuery, wszClassName, pSink);
        if (FAILED(hres))
            return hres;
    }
            
    //
    // Find the class's ref dir.
    //

    CFileName wszReferenceDir;
    if (wszReferenceDir == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDir(wszClassName, wszReferenceDir);

    CFileName wszReferenceMask;
    if (wszReferenceMask == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszReferenceMask, wszReferenceMask.Length(), wszReferenceDir);
    StringCchCatW(wszReferenceMask, wszReferenceMask.Length(), L"\\" A51_REF_FILE_PREFIX);

    CFileName wszFileName;
    if (wszFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    // 
    // Enumerate all files in it
    //

    void* hSearch;
    long lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszReferenceMask, &hSearch);
    if (lRes == ERROR_FILE_NOT_FOUND)
        return S_OK;
    else if (lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    while ((hres == ERROR_SUCCESS) && ((lRes = g_Glob.m_FileCache.IndexEnumerationNext(hSearch, wszFileName) == ERROR_SUCCESS)))
    {
        //  
        // Extract the class hash from the name of the file
        //

        LPCWSTR wszReferrerHash = wszFileName + wcslen(A51_REF_FILE_PREFIX);
        
        //
        // Get the class from that hash
        //

        _IWmiObject* pClass = NULL;
        hres = GetClassByHash(wszReferrerHash, true, &pClass, NULL, NULL, NULL);
        if(hres == WBEM_E_NOT_FOUND)
        {
            hres = ERROR_SUCCESS;
            continue;
        }

        CReleaseMe rm1(pClass);
        if (hres == ERROR_SUCCESS)
            hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
    }
    g_Glob.m_FileCache.IndexEnumerationEnd(hSearch);


    if (hres != ERROR_SUCCESS)
        return hres;
    if(lRes == ERROR_NO_MORE_FILES)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return A51TranslateErrorCode(lRes);
    }
    return S_OK;
}

bool CNamespaceHandle::Hash(LPCWSTR wszName, LPWSTR wszHash)
{
    return A51Hash(wszName, wszHash);
}

HRESULT CNamespaceHandle::InstanceToFile(IWbemClassObject* pInst, 
                            LPCWSTR wszClassName, LPCWSTR wszFileName1, LPCWSTR wszFileName2,
                            __int64 nClassTime)
{
    HRESULT hres;

    //
    // Allocate enough space for the buffer
    //

    _IWmiObject* pInstEx;
    pInst->QueryInterface(IID__IWmiObject, (void**)&pInstEx);
    CReleaseMe rm1(pInstEx);

    DWORD dwInstancePartLen = 0;
    hres = pInstEx->Unmerge(0, 0, &dwInstancePartLen, NULL);

    //
    // Add enough room for the class hash
    //

    DWORD dwClassHashLen = MAX_HASH_LEN * sizeof(WCHAR);
    DWORD dwTotalLen = dwInstancePartLen + dwClassHashLen + sizeof(__int64)*2;

    BYTE* pBuffer = (BYTE*)TempAlloc(dwTotalLen);
    if (pBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwTotalLen);

    //
    // Write the class hash
    //

    if(!Hash(wszClassName, (LPWSTR)pBuffer))
        return WBEM_E_OUT_OF_MEMORY;

    memcpy(pBuffer + dwClassHashLen, &g_nCurrentTime, sizeof(__int64));
    g_nCurrentTime++;

    memcpy(pBuffer + dwClassHashLen + sizeof(__int64), &nClassTime, 
            sizeof(__int64));

    //
    // Unmerge the instance into a buffer
    // 

    DWORD dwLen;
    hres = pInstEx->Unmerge(0, dwInstancePartLen, &dwLen, 
                            pBuffer + dwClassHashLen + sizeof(__int64)*2);
    if(FAILED(hres))
        return hres;

    //
    // Write to the file only as much as we have actually used!
    //

    long lRes = g_Glob.m_FileCache.WriteObject(wszFileName1, wszFileName2, 
                    dwClassHashLen + sizeof(__int64)*2 + dwLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);
    
    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ClassToFile(_IWmiObject* pParentClass, 
                _IWmiObject* pClass, LPCWSTR wszFileName, 
                __int64 nFakeUpdateTime)
{
    HRESULT hres;

    //
    // Get superclass name
    //

    VARIANT vSuper;
    hres = pClass->Get(L"__SUPERCLASS", 0, &vSuper, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CClearMe cm1(&vSuper);

    LPCWSTR wszSuper;
    if(V_VT(&vSuper) == VT_BSTR)
        wszSuper = V_BSTR(&vSuper);
    else
        wszSuper = L"";

    VARIANT vClassName;
    hres = pClass->Get(L"__CLASS", 0, &vClassName, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm2(&vClassName);

    LPCWSTR wszClassName;
    if(V_VT(&vClassName) == VT_BSTR)
        wszClassName = V_BSTR(&vClassName);
    else
        wszClassName = L"";

    //
    // Get unmerge length
    //

    DWORD dwUnmergedLen = 0;
    hres = pClass->Unmerge(0, 0, &dwUnmergedLen, NULL);

    //
    // Add enough space for the parent class name and the timestamp
    //

    DWORD dwSuperLen = sizeof(DWORD) + wcslen(wszSuper)*sizeof(WCHAR);

    DWORD dwLen = dwUnmergedLen + dwSuperLen + sizeof(__int64);

    BYTE* pBuffer = (BYTE*)TempAlloc(dwLen);
    if (pBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwLen);

    //
    // Write superclass name
    //

    DWORD dwActualSuperLen = wcslen(wszSuper);
    memcpy(pBuffer, &dwActualSuperLen, sizeof(DWORD));
    memcpy(pBuffer + sizeof(DWORD), wszSuper, wcslen(wszSuper)*sizeof(WCHAR));

    //
    // Write the timestamp
    //

    if(nFakeUpdateTime == 0)
    {
        nFakeUpdateTime = g_nCurrentTime;
        g_nCurrentTime++;
    }

    memcpy(pBuffer + dwSuperLen, &nFakeUpdateTime, sizeof(__int64));

    //
    // Write the unmerged portion
    //

    BYTE* pUnmergedPortion = pBuffer + dwSuperLen + sizeof(__int64);
    hres = pClass->Unmerge(0, dwUnmergedLen, &dwUnmergedLen, 
                            pUnmergedPortion);
    if(FAILED(hres))
        return hres;

    //
    // Stash away the real length
    //

    DWORD dwFileLen = dwUnmergedLen + dwSuperLen + sizeof(__int64);

    long lRes = g_Glob.m_FileCache.WriteObject(wszFileName, NULL, dwFileLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return A51TranslateErrorCode(lRes);

    //
    // To properly cache the new class definition, first invalidate it
    //

    hres = m_pClassCache->InvalidateClass(wszClassName);
    if(FAILED(hres))
        return hres;

    //
    // Now, remerge the unmerged portion back in
    //

    if(pParentClass == NULL)
    {
        //
        // Get the empty class
        //

        hres = GetClassDirect(NULL, IID__IWmiObject, (void**)&pParentClass, 
                                false, NULL, NULL, NULL);
        if(FAILED(hres))
            return hres;
    }
    else
        pParentClass->AddRef();
    CReleaseMe rm0(pParentClass);

    _IWmiObject* pNewObj;
    hres = pParentClass->MergeAndDecorate(WMIOBJECT_MERGE_FLAG_CLASS, 
                                                                  dwUnmergedLen, pUnmergedPortion, 
                                                                  m_wszMachineName, m_wsNamespace,
                                                                  &pNewObj);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pNewObj);

    hres = m_pClassCache->AssertClass(pNewObj, wszClassName, false, 
                                        nFakeUpdateTime, false); 
    if(FAILED(hres))
        return hres;

    return WBEM_S_NO_ERROR;
}


HRESULT CNamespaceHandle::ConstructInstanceDefName(CFileName& wszInstanceDefName,
                                                    LPCWSTR wszKey)
{
    StringCchCopyW(wszInstanceDefName, wszInstanceDefName.Length(), A51_INSTDEF_FILE_PREFIX);
    if(!Hash(wszKey, wszInstanceDefName + wcslen(A51_INSTDEF_FILE_PREFIX)))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ConstructInstDefNameFromLinkName(
                                                    CFileName& wszInstanceDefName,
                                                    LPCWSTR wszInstanceLinkName)
{
    StringCchCopyW(wszInstanceDefName, wszInstanceDefName.Length(), A51_INSTDEF_FILE_PREFIX);
    StringCchCatW(wszInstanceDefName, wszInstanceDefName.Length(),
        wszInstanceLinkName + wcslen(A51_INSTLINK_FILE_PREFIX));
    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ConstructClassDefFileName(LPCWSTR wszClassName, 
                                            CFileName& wszFileName)
{
    StringCchCopyW(wszFileName, wszFileName.Length(), A51_CLASSDEF_FILE_PREFIX);
    if(!Hash(wszClassName, wszFileName+wcslen(A51_CLASSDEF_FILE_PREFIX)))
        return WBEM_E_INVALID_OBJECT;
    return WBEM_S_NO_ERROR;
}

HRESULT CNamespaceHandle::ConstructClassDefFileNameFromHash(LPCWSTR wszHash, 
                                            CFileName& wszFileName)
{
    StringCchCopyW(wszFileName, wszFileName.Length(), A51_CLASSDEF_FILE_PREFIX);
    StringCchCatW(wszFileName, wszFileName.Length(), wszHash);
    return WBEM_S_NO_ERROR;
}

//=============================================================================
//
// CNamespaceHandle::CreateSystemClasses
//
// We are in a pseudo namespace.  We need to determine if we already have
// the system classes in this namespace.  The system classes that we create
// are those that exist in all namespaces, and no others.  If they do not exist
// we create them.
// The whole creation process happens within the confines of a transaction
// that we create and own within this method.
//
//=============================================================================
HRESULT CNamespaceHandle::CreateSystemClasses(CFlexArray &aSystemClasses)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    //Now we need to determine if the system classes already exist.  Lets do this by looking for the __thisnamespace
    //class!
    {
        _IWmiObject *pObj = NULL;
        hRes = GetClassDirect(L"__thisnamespace", IID__IWmiObject, (void**)&pObj, false, NULL, NULL, NULL);
        if (SUCCEEDED(hRes))
        {
            //All done!  They already exist!
            pObj->Release();
            return WBEM_S_NO_ERROR;
        }
        else if (hRes != WBEM_E_NOT_FOUND)
        {
            //Something went bad, so we just fail!
            return hRes;
        }
    }

    //There are no system classes so we need to create them.
    hRes = A51TranslateErrorCode(g_Glob.m_FileCache.BeginTransaction());
    if (FAILED(hRes))
        return hRes;
	
    CEventCollector eventCollector;
    _IWmiObject *Objects[256];
    _IWmiObject **ppObjects = NULL;
    ULONG uSize = 256;
    
    if (SUCCEEDED(hRes) && aSystemClasses.Size())
    {
        //If we have a system-class array we need to use that instead of using the ones retrieved from the core
        //not doing so will cause a mismatch.  We retrieved these as part of the upgrade process...
        uSize = aSystemClasses.Size();
        ppObjects = (_IWmiObject**)&aSystemClasses[0];
    }
    else if (SUCCEEDED(hRes))
    {
        //None retrieved from upgrade process so we must be a clean install.  Therefore we should 
        //get the list from the core...
        _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
        CReleaseMe rm(pSvcs);        
        hRes = pSvcs->GetSystemObjects(GET_SYSTEM_STD_OBJECTS, &uSize, Objects);
        ppObjects = Objects;
    }
    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            IWbemClassObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = ppObjects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    hRes = PutObject(IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS, 0, 0, eventCollector);
                    pObj->Release();
                    if (FAILED(hRes))
                    {
                        ERRORTRACE((LOG_WBEMCORE, "Creation of system class failed during repository creation <0x%X>!\n", hRes));
                    }
                }
            }
            ppObjects[i]->Release();
        }
    }

    //Clear out the array that was sent to us.
    aSystemClasses.Empty();

    if (FAILED(hRes))
    {
        g_Glob.m_FileCache.AbortTransaction();
    }
    else
    {
        long lResInner;
        hRes = A51TranslateErrorCode(lResInner = g_Glob.m_FileCache.CommitTransaction());
        _ASSERT(hRes == 0, L"Commit transaction failed");

        CRepository::WriteOperationNotification();
    }
    return hRes;
}

class CSystemClassDeletionSink : public CUnkBase<IWbemObjectSink, &IID_IWbemObjectSink>
{
    CWStringArray &m_aChildNamespaces;
public:
    CSystemClassDeletionSink(CWStringArray &aChildNamespaces) 
        : m_aChildNamespaces(aChildNamespaces) 
    {
    }
    ~CSystemClassDeletionSink() 
    {
    }
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        HRESULT hRes;
        for (int i = 0; i != lNumObjects; i++)
        {
            if (apObjects[i] != NULL)
            {
                _IWmiObject *pInst = NULL;
                hRes = apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pInst);
                if (FAILED(hRes))
                    return hRes;
                CReleaseMe rm(pInst);

                BSTR strKey = NULL;
                hRes = pInst->GetKeyString(0, &strKey);
                if(FAILED(hRes))
                    return hRes;
                CSysFreeMe sfm(strKey);
                if (wcslen(strKey) == 0)
                {
                    _ASSERT(0, "Key is empty!\n");
                }
                if (m_aChildNamespaces.Add(strKey) != CWStringArray::no_error)
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }

        return WBEM_S_NO_ERROR;
    }
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, BSTR, IWbemClassObject*) 
    { 
        return WBEM_S_NO_ERROR; 
    }

};

//=============================================================================
//=============================================================================
CDbIterator::CDbIterator(CLifeControl* pControl, bool bUseLock)
        : TUnkBase(pControl), m_lCurrentIndex(0), m_hresStatus(WBEM_S_FALSE),
            m_pMainFiber(NULL), m_pExecFiber(NULL), m_dwNumRequested(0),
            m_pExecReq(NULL), m_hresCancellationStatus(WBEM_S_NO_ERROR),
            m_bExecFiberRunning(false), m_bUseLock(bUseLock)
{
}

CDbIterator::~CDbIterator()
{
    if(m_pExecFiber)
        Cancel(0, NULL);
    if(m_pExecReq)
        delete m_pExecReq;

    CRepository::ReadOperationNotification();
}

void CDbIterator::SetExecFiber(void* pFiber, CFiberTask* pReq)
{
    m_pExecFiber = pFiber;
    m_pExecReq = pReq;
}

STDMETHODIMP CDbIterator::Cancel(DWORD dwFlags, void* pFiber)
{
    CInCritSec ics(&m_cs);

    m_qObjects.Clear();

    //
    // Mark the iterator as cancelled and allow the execution fiber to resume
    // and complete --- that guarantees that any memory it allocated will be
    // cleaned up.  The exception to this rule is if the fiber has not started
    // execution yet; in that case, we do not want to switch to it, as it would
    // have to run until the first Indicate to find out that it's been
    // cancelled.  (In the normal case, the execution fiber is suspended    
    // inside Indicate, so when we switch back we will immediately give it
    // WBEM_E_CALL_CANCELLED so that it can clean up and return)
    //

    m_hresCancellationStatus = WBEM_E_CALL_CANCELLED;

    if(m_pExecFiber)
    {
        if(m_bExecFiberRunning)
        {
            _ASSERT(m_pMainFiber == NULL && m_pExecFiber != NULL, 
                    L"Fiber trouble");

            //
            // Make sure the calling thread has a fiber
            //

            m_pMainFiber = pFiber;
            if(m_pMainFiber == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            {
                CAutoReadLock lock(&g_readWriteLock);

                if (m_bUseLock)
                {
                    if (!lock.Lock())
                         return WBEM_E_FAILED;                    
                }

                SwitchToFiber(m_pExecFiber);
            }
        }
        
        // 
        // At this point, the executing fiber is dead.  We know, because in the
        // cancelled state we do not switch to the main fiber in Indicate. 
        //

        ReturnFiber(m_pExecFiber);
        m_pExecFiber = NULL;
    }

    return S_OK;
}

STDMETHODIMP CDbIterator::NextBatch(
      DWORD dwNumRequested,
      DWORD dwTimeOutSeconds,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
      REFIID riid,
      void* pFiber,
      DWORD *pdwNumReturned,
      LPVOID *ppObjects
     )
{
    CInCritSec ics(&m_cs);

    _ASSERT(SUCCEEDED(m_hresCancellationStatus), L"Next called after Cancel");
    
    m_bExecFiberRunning = true;

    //
    // Wait until it's over or the right number of objects has been received
    //

    if(m_qObjects.GetQueueSize() < dwNumRequested)
    {
        _ASSERT(m_pMainFiber == NULL && m_pExecFiber != NULL, L"Fiber trouble");

        //
        // Make sure the calling thread has a fiber
        //

        m_pMainFiber = pFiber;
        if(m_pMainFiber == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        m_dwNumRequested = dwNumRequested;

        //
        // We need to acquire the read lock for the duration of the continuation
        // of the retrieval
        //

        {
            CAutoReadLock lock(&g_readWriteLock);

            if (m_bUseLock)
            {
                if (!lock.Lock())
                {
                    m_pMainFiber = NULL;                
                    return WBEM_E_FAILED;                
                }
            }
            if (g_bShuttingDown)
            {
                m_pMainFiber = NULL;
                return WBEM_E_SHUTTING_DOWN;
            }

            SwitchToFiber(m_pExecFiber);
        }

        m_pMainFiber = NULL;
    }

    //
    // We have as much as we are going to have!
    //
    
    DWORD dwReqIndex = 0;
    while(dwReqIndex < dwNumRequested)
    {
        if(0 == m_qObjects.GetQueueSize())
        {
            //
            // That's it --- we waited for production, so there are simply no 
            // more objects in the enumeration
            //

            *pdwNumReturned = dwReqIndex;
            return m_hresStatus;
        }

        IWbemClassObject* pObj = m_qObjects.Dequeue();
        CReleaseMe rm1(pObj);
        pObj->QueryInterface(riid, ppObjects + dwReqIndex);

        dwReqIndex++;
    }

    //
    // Got everything
    //

    *pdwNumReturned= dwNumRequested;
    return S_OK;
}

HRESULT CDbIterator::Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
    if(FAILED(m_hresCancellationStatus))
    {
        //
        // Screw-up --- the fiber called back with Indicate even after we 
        // cancelled! Oh well.
        //
        
        _ASSERT(false, L"Execution code ignored cancel return code!");
        return m_hresCancellationStatus;
    }

    //
    // Add the objects received to the array
    //

    for(long i = 0; i < lNumObjects; i++)
    {
        m_qObjects.Enqueue(apObjects[i]);
    }

    //
    // Check if we have compiled enough for the current request and should
    // therefore interrupt the gatherer
    //

    if(m_qObjects.GetQueueSize() >= m_dwNumRequested)
    {
        //
        // Switch us back to the original fiber
        //

        SwitchToFiber(m_pMainFiber);
    }

    return m_hresCancellationStatus;
}

HRESULT CDbIterator::SetStatus(long lFlags, HRESULT hresResult, 
                                    BSTR, IWbemClassObject*)
{
    _ASSERT(m_hresStatus == WBEM_S_FALSE, L"SetStatus called twice!");
    _ASSERT(lFlags == WBEM_STATUS_COMPLETE, L"SetStatus flags invalid");

    m_hresStatus = hresResult;

    //
    // Switch us back to the original thread, we are done
    //

    m_bExecFiberRunning = false;
    SwitchToFiber(m_pMainFiber);

    return WBEM_S_NO_ERROR;
}



    
            


CRepEvent::CRepEvent(DWORD dwType, 
                                   LPCWSTR wszNamespace, 
                                   LPCWSTR wszArg1, 
                                  _IWmiObject* pObj1, 
                                  _IWmiObject* pObj2):
    m_wszNamespace(wszNamespace),
    m_wszArg1(wszArg1),
    m_pObj1(NULL),
    m_pObj2(NULL)
    
{
    m_dwType = dwType;
    if (pObj1)
    {
        m_pObj1 = pObj1;
        pObj1->AddRef();
    }
    if (pObj2)
    {
        m_pObj2 = pObj2;
        pObj2->AddRef();
    }
}

CRepEvent::~CRepEvent()
{
    if (m_pObj1)
        m_pObj1->Release();
    if (m_pObj2)
        m_pObj2->Release();
};

HRESULT CEventCollector::SendEvents(_IWmiCoreServices* pCore)
{
    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    for (int i = 0; i != m_apEvents.GetSize(); i++)
    {
        CRepEvent *pEvent = m_apEvents[i];

        _IWmiObject* apObjs[2];
        apObjs[0] = pEvent->m_pObj1;
        apObjs[1] = pEvent->m_pObj2;

        HRESULT hres = pCore->DeliverIntrinsicEvent(
                pEvent->m_wszNamespace, pEvent->m_dwType, NULL, 
                pEvent->m_wszArg1, NULL, (pEvent->m_pObj2?2:1), apObjs);
        if(FAILED(hres))
            hresGlobal = hres;
    }

    return hresGlobal;
}

bool CEventCollector::AddEvent(CRepEvent* pEvent)
{
    CInCritSec ics(&m_csLock);

    if(m_bNamespaceOnly)
    {
        if(pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceCreation &&
           pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceDeletion &&
           pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceModification)
        {
            delete pEvent;
            return true;
        }
    }

    bool bRet = (m_apEvents.Add(pEvent) >= 0);
    return bRet;
}

void CEventCollector::DeleteAllEvents()
{
    CInCritSec ics(&m_csLock);

    m_bNamespaceOnly = false;
    m_apEvents.RemoveAll();
}

void CEventCollector::TransferEvents(CEventCollector &aEventsToTransfer)
{
    m_bNamespaceOnly = aEventsToTransfer.m_bNamespaceOnly;

    while(aEventsToTransfer.m_apEvents.GetSize())
    {
        CRepEvent *pEvent = 0;
        aEventsToTransfer.m_apEvents.RemoveAt(0, &pEvent);

        m_apEvents.Add(pEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\a51tools.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <wbemcomn.h>
#include <statsync.h>
#include "a51tools.h"

__int64 g_nCurrentTime = 1;

__int64 g_nReadFailures = 0;
__int64 g_nWriteFailures = 0;

//
// FILE_ATTRIBUTE_NOT_CONTENT_INDEXED is not actually supported on CreateFile,
// contrary to the docs.  However, also contrary to the docs, it is inherited
// from the parent directory
//

#define A51_FILE_CREATION_FLAGS 0 //FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

CTempMemoryManager g_Manager;

void* TempAlloc(DWORD dwLen)
{
    return g_Manager.Allocate(dwLen);
}
    
void TempFree(void* p, DWORD dwLen)
{
    g_Manager.Free(p, dwLen);
}

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen)
{
    return Manager.Allocate(dwLen);
}
    
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen)
{
    Manager.Free(p, dwLen);
}


HRESULT A51TranslateErrorCode(long lRes)
{
    if (lRes == ERROR_SUCCESS)
        return WBEM_S_NO_ERROR;

    switch(lRes)
    {
    case ERROR_FILE_NOT_FOUND:
        return WBEM_E_NOT_FOUND;

    case ERROR_OUTOFMEMORY:
    case ERROR_NOT_ENOUGH_MEMORY:
        return WBEM_E_OUT_OF_MEMORY;

    case ERROR_NOT_ENOUGH_QUOTA:
    case ERROR_DISK_FULL:
        return WBEM_E_OUT_OF_DISK_SPACE;

    case ERROR_SERVER_SHUTDOWN_IN_PROGRESS:
        return WBEM_E_SHUTTING_DOWN;

    default:
        return WBEM_E_FAILED;
    }
}

long __stdcall EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA)
{
    if(!CreateDirectoryW(wszPath, NULL))
    {
        long lRes = GetLastError();
        if(lRes != ERROR_ALREADY_EXISTS)
            return lRes;
        else
            return ERROR_SUCCESS;
    }
    else
        return ERROR_SUCCESS;
}


static WCHAR g_HexDigit[] = 
{ L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9',
  L'A', L'B', L'C', L'D', L'E', L'F'
};
       
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash)
{
    //
    // Have to upper-case everything
    //

    DWORD dwBufferSize = wcslen(wszName)*2+2;
    LPWSTR wszBuffer = (WCHAR*)TempAlloc(dwBufferSize);
    if (wszBuffer == NULL)
        return false;
    CTempFreeMe vdm(wszBuffer, dwBufferSize);

    wbem_wcsupr(wszBuffer, wszName);

    BYTE RawHash[16];
    MD5::Transform((void*)wszBuffer, wcslen(wszBuffer)*2, RawHash);

    WCHAR* pwc = wszHash;
    for(int i = 0; i < 16; i++)
    {
        *(pwc++) = g_HexDigit[RawHash[i]/16];
        *(pwc++) = g_HexDigit[RawHash[i]%16];
    }
    *pwc = 0;
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\btr.cpp ===
//***************************************************************************
//
//  BTR.CPP
//
//  WMI disk-based B-tree implementation for repository index
//
//  raymcc  15-Oct-00    Prepared for Whistler Beta 2 to reduce file count
//
//***************************************************************************

#include "precomp.h"
#include <wbemcomn.h>
#include <reposit.h>
#include <stdlib.h>
#include <math.h>
#include "pagemgr.h"
#include "btr.h"
#include <arena.h>

#define MAX_WORD_VALUE          0xFFFF
#define MAX_TOKENS_PER_KEY      32
#define MAX_FLUSH_INTERVAL      4000

//#define MAX_PAGE_HISTORY        1024

/*

Notes:

 (a) Modify allocators to special case for page-size
 (b) Modify WriteIdxPage to not rewrite if no deltas
 (c) ERROR_PATH_NOT_FOUND if starting enum has no presence; GPF presently
 (d) Do a history of page hits and see if caching would be helpful

*/

//static WORD History[MAX_PAGE_HISTORY] = {0};

LONG g_lAllocs = 0;

//***************************************************************************
//
//  _BtrMemAlloc
//
//***************************************************************************
// ok
LPVOID WINAPI _BtrMemAlloc(
    SIZE_T dwBytes  // number of bytes to allocate
    )
{
    // Lookaside for items of page size, default array size, default
    // string pool size
    g_lAllocs++;
    return HeapAlloc(CWin32DefaultArena::GetArenaHeap(), HEAP_ZERO_MEMORY, dwBytes);
}

//***************************************************************************
//
//  _BtrMemReAlloc
//
//***************************************************************************
// ok
LPVOID WINAPI _BtrMemReAlloc(
    LPVOID pOriginal,
    DWORD dwNewBytes
    )
{
    return HeapReAlloc(CWin32DefaultArena::GetArenaHeap(), HEAP_ZERO_MEMORY, pOriginal, dwNewBytes);
}

//***************************************************************************
//
//  _BtrMemFree
//
//***************************************************************************
// ok
BOOL WINAPI _BtrMemFree(LPVOID pMem)
{
    if (pMem == 0)
        return TRUE;
    g_lAllocs--;
    return HeapFree(CWin32DefaultArena::GetArenaHeap(), 0, pMem);
}




//***************************************************************************
//
//  CBTreeFile::CBTreeFile
//
//***************************************************************************
// ok
CBTreeFile::CBTreeFile()
{
    m_dwPageSize = 0;
    m_dwLogicalRoot = 0;
}

//***************************************************************************
//
//  CBTreeFile::CBTreeFile
//
//***************************************************************************
//  ok
CBTreeFile::~CBTreeFile()
{
    // if CPageSource__CommitTrans fails, we leak a handle
    // since Shutdown is not called
    if (m_pFile)
    	m_pFile->Release();
}


//***************************************************************************
//
//  CBTreeFile::Shutdown
//
//***************************************************************************
//  ok
DWORD CBTreeFile::Shutdown(DWORD dwShutDownFlags)
{

    m_dwPageSize = 0;
    m_dwLogicalRoot = 0;

    if (m_pFile)
    {
    	m_pFile->Release();
    	m_pFile = NULL;
    }
    
    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeFile::WriteAdminPage
//
//  Rewrites the admin page.  There is no need to update the pagesize,
//  version, etc.
//
//***************************************************************************
//  ok
DWORD CBTreeFile::WriteAdminPage()
{
    LPDWORD pPageZero = 0;
    DWORD dwRes = GetPage(0, (LPVOID *) &pPageZero);
    if (dwRes)
        return dwRes;

    pPageZero[OFFSET_LOGICAL_ROOT] = m_dwLogicalRoot;

    dwRes = PutPage(pPageZero, PAGE_TYPE_ADMIN);
    _BtrMemFree(pPageZero);
    return dwRes;
}

//***************************************************************************
//
//  CBTreeFile::SetRootPage
//
//***************************************************************************
//
DWORD CBTreeFile::SetRootPage(DWORD dwNewRoot)
{
    m_dwLogicalRoot = dwNewRoot;
    return WriteAdminPage();
}


//***************************************************************************
//
//  CBTreeFile::Init
//
//  The real "constructor" which opens the file
//
//***************************************************************************
// ok
DWORD CBTreeFile::Init(
    DWORD dwPageSize,
    LPWSTR pszFilename,
	CPageSource* pSource
    )
{
    DWORD dwLastError = 0;

	m_pTransactionManager = pSource;

    m_dwPageSize = dwPageSize;

	long lRes = pSource->GetBTreePageFile(&m_pFile);
    if(lRes != ERROR_SUCCESS)
		return lRes;

    return ReadAdminPage();
}


//***************************************************************************
//
//  CBTreeFile::ReadAdminPage
//
//***************************************************************************
// ok
DWORD CBTreeFile::ReadAdminPage()
{
    LPDWORD pPageZero = 0;
    DWORD dwRes = 0;

    dwRes = GetPage(0, (LPVOID *) &pPageZero);
	if (dwRes == ERROR_FILE_NOT_FOUND)
	{
		//First read of admin page fails so we need to set it up
		dwRes = Setup();
		m_dwLogicalRoot = 0;
	}
    else if (dwRes == ERROR_SUCCESS)
	{
		m_dwLogicalRoot = pPageZero[OFFSET_LOGICAL_ROOT];

		_BtrMemFree(pPageZero);
	}

    return dwRes;
}


//***************************************************************************
//
//  CBTreeFile::Setup
//
//  Sets up the 0th page (Admin page)
//
//***************************************************************************
// ok
DWORD CBTreeFile::Setup()
{
    DWORD dwRes;
	DWORD dwRoot = 0;

    // First two pages, admin & free list root

    LPDWORD pPageZero = (LPDWORD) _BtrMemAlloc(m_dwPageSize);

    if (pPageZero == 0)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    memset(pPageZero, 0, m_dwPageSize);

    // Map the page

    pPageZero[OFFSET_PAGE_TYPE] = PAGE_TYPE_ADMIN;
    pPageZero[OFFSET_PAGE_ID] = 0;
    pPageZero[OFFSET_NEXT_PAGE] = 0;

    pPageZero[OFFSET_LOGICAL_ROOT] = 0;


	dwRes = m_pFile->NewPage(1, 1, &dwRoot);

    // Write it out
	if (dwRes == ERROR_SUCCESS)
		dwRes = PutPage(pPageZero, PAGE_TYPE_ADMIN);

Exit:
    _BtrMemFree(pPageZero);

    return dwRes;
}


//***************************************************************************
//
//  CBTreeFile::Dump
//
//  Debug helper
//
//***************************************************************************
// ok
void CBTreeFile::Dump(FILE *f)
{
	/*
    SetFilePointer(m_hFile, 0, 0, FILE_BEGIN);
    LPDWORD pPage = (LPDWORD) new BYTE[m_dwPageSize];
    DWORD dwPage = 0;
    DWORD dwTotalKeys = 0;

    fprintf(f, "---BEGIN PAGE SOURCE DUMP---\n");
    fprintf(f, "In memory part:\n");
    fprintf(f, "  m_dwPageSize = %d (0x%X)\n", m_dwPageSize, m_dwPageSize);
    fprintf(f, "  m_hFile = 0x%p\n", m_hFile);
    fprintf(f, "  m_dwNextFreePage = %d\n", m_dwNextFreePage);
    fprintf(f, "  m_dwTotalPages = %d\n", m_dwTotalPages);
    fprintf(f, "  m_dwLogicalRoot = %d\n", m_dwLogicalRoot);
    fprintf(f, "---\n");

    DWORD dwTotalFree = 0;
    DWORD dwOffs = 0;

    while (1)
    {
        DWORD dwRead = 0;
        BOOL bRes = ReadFile(m_hFile, pPage, m_dwPageSize, &dwRead, 0);
        if (dwRead != m_dwPageSize)
            break;

        fprintf(f, "Dump of page %d:\n", dwPage++);
        fprintf(f, "  Page type = 0x%X", pPage[OFFSET_PAGE_TYPE]);

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_IMPOSSIBLE)
            fprintf(f, "   PAGE_TYPE_IMPOSSIBLE\n");

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_DELETED)
        {
            fprintf(f, "   PAGE_TYPE_DELETED\n");
            fprintf(f, "     <page num check = %d>\n", pPage[1]);
            fprintf(f, "     <next free page = %d>\n", pPage[2]);
            dwTotalFree++;
        }

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_ACTIVE)
        {
            fprintf(f, "   PAGE_TYPE_ACTIVE\n");
            fprintf(f, "     <page num check = %d>\n", pPage[1]);

            SIdxKeyTable *pKT = 0;
            DWORD dwKeys = 0;
            DWORD dwRes = SIdxKeyTable::Create(pPage, &pKT);
            if (dwRes == 0)
            {
                pKT->Dump(f, &dwKeys);
                pKT->Release();
                dwTotalKeys += dwKeys;
            }
            else
            {
                fprintf(f,  "<INVALID Page Decode>\n");
            }
        }

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_ADMIN)
        {
            fprintf(f, "   PAGE_TYPE_ADMIN\n");
            fprintf(f, "     Page Num           = %d\n", pPage[1]);
            fprintf(f, "     Next Page          = %d\n", pPage[2]);
            fprintf(f, "     Logical Root       = %d\n", pPage[3]);
            fprintf(f, "     Free List Root     = %d\n", pPage[4]);
            fprintf(f, "     Total Pages        = %d\n", pPage[5]);
            fprintf(f, "     Page Size          = %d (0x%X)\n", pPage[6], pPage[6]);
            fprintf(f, "     Impl Version       = 0x%X\n", pPage[7]);
        }
    }

    delete [] pPage;

    fprintf(f, "Total free pages detected by scan = %d\n", dwTotalFree);
    fprintf(f, "Total active keys = %d\n", dwTotalKeys);
    fprintf(f, "---END PAGE DUMP---\n");
	*/
}

//***************************************************************************
//
//  CBTreeFile::GetPage
//
//  Reads an existing page; does not support seeking beyond end-of-file
//
//***************************************************************************
//  ok
DWORD CBTreeFile::GetPage(
    DWORD dwPage,
    LPVOID *pPage
    )
{
    DWORD dwRes;

    if (pPage == 0)
        return ERROR_INVALID_PARAMETER;

    // Allocate some memory

    LPVOID pMem = _BtrMemAlloc(m_dwPageSize);
    if (!pMem)
        return ERROR_NOT_ENOUGH_MEMORY;

    long lRes = m_pFile->GetPage(dwPage, 0, pMem);
    if (lRes != ERROR_SUCCESS)
    {
        _BtrMemFree(pMem);
        return lRes;
    }

    *pPage = pMem;
    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeFile::PutPage
//
//  Always rewrites; the file extent was grown when the page was allocated
//  with NewPage, so the page already exists and the write should not fail
//
//***************************************************************************
//  ok
DWORD CBTreeFile::PutPage(
    LPVOID pPage,
    DWORD dwType
    )
{
    // Force the page to confess its identity

    DWORD *pdwHeader = LPDWORD(pPage);
    DWORD dwPageId = pdwHeader[OFFSET_PAGE_ID];
    pdwHeader[OFFSET_PAGE_TYPE] = dwType;

    long lRes = m_pFile->PutPage(dwPageId, 0, pPage);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeFile::NewPage
//
//  Allocates a new page, preferring the free list
//
//***************************************************************************
//  ok
DWORD CBTreeFile::NewPage(LPVOID *pRetPage)
{
    DWORD dwRes;

    if (pRetPage == 0)
        return ERROR_INVALID_PARAMETER;
    *pRetPage = 0;

    LPDWORD pNewPage = (LPDWORD) _BtrMemAlloc(m_dwPageSize);
    if (pNewPage == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

	DWORD dwPage = 0;
	dwRes = m_pFile->NewPage(0, 1, &dwPage);
	if (dwRes != ERROR_SUCCESS)
	{
		_BtrMemFree(pNewPage);
		return dwRes;
	}

    memset(pNewPage, 0, m_dwPageSize);
    pNewPage[OFFSET_PAGE_ID] = dwPage;
    *pRetPage = pNewPage;

    return ERROR_SUCCESS;;
}

//***************************************************************************
//
//  CBTreeFile::FreePage
//
//  Called to delete or free a page.  If the last page is the one
//  being freed, then the file is truncated.
//
//***************************************************************************
//  ok
DWORD CBTreeFile::FreePage(
    LPVOID pPage
    )
{
    LPDWORD pCast = LPDWORD(pPage);
    DWORD dwPageId = pCast[OFFSET_PAGE_ID];

	return FreePage(dwPageId);
}

//***************************************************************************
//
//  CBTreeFile::FreePage
//
//***************************************************************************
//
DWORD CBTreeFile::FreePage(
    DWORD dwId
    )
{
	return m_pFile->FreePage(0, dwId);
}

//***************************************************************************
//
//  SIdxKeyTable::GetRequiredPageMemory
//
//  Returns the amount of memory required to store this object in a
//  linear page
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::GetRequiredPageMemory()
{
    DWORD dwTotal = m_pStrPool->GetRequiredPageMemory();

    // Size of the key lookup table & its sizing DWORD, and
    // add in the child page & user data

    dwTotal += sizeof(DWORD) + sizeof(WORD) * m_dwNumKeys;
    dwTotal += sizeof(DWORD) + sizeof(DWORD) * m_dwNumKeys;     // User data
    dwTotal += sizeof(DWORD) + sizeof(DWORD) * (m_dwNumKeys+1); // Child pages

    // Add in the key encoding table

    dwTotal += sizeof(WORD) + sizeof(WORD) * m_dwKeyCodesUsed;

    // Add in per page overhead
    //
    // Signature, Page Id, Next Page, Parent Page
    dwTotal += sizeof(DWORD) * 4;

    // (NOTE A): Add some safety margin...
    dwTotal += sizeof(DWORD) * 2;

    return dwTotal;
}

//***************************************************************************
//
//  SIdxKeyTable::StealKeyFromSibling
//
//  Transfers a key from the sibling via the parent in a sort of rotation:
//
//          10
//     1  2    12  13 14
//
//  Where <this> is node (1,2) and sibling is (12,13).  A single rotation
//  moves 10 into (1,2) and grabs 12 from the sibling to replace it,
//
//           12
//    1 2 10     13 14
//
//  We repeat this until minimum load of <this> is above const_MinimumLoad.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::StealKeyFromSibling(
    SIdxKeyTable *pParent,
    SIdxKeyTable *pSibling
    )
{
    DWORD dwData, dwChild;
    WORD wID;
    LPSTR pszKey = 0;
	DWORD dwRes = 0;

    DWORD dwSiblingId = pSibling->GetPageId();
    DWORD dwThisId = GetPageId();


    for (WORD i = 0; i < WORD(pParent->GetNumKeys()); i++)
    {
        DWORD dwChildA = pParent->GetChildPage(i);
        DWORD dwChildB = pParent->GetChildPage(i+1);

        if (dwChildA == dwThisId && dwChildB == dwSiblingId)
        {
            dwRes = pParent->GetKeyAt(i, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pParent->GetUserData(i);

            dwRes = FindKey(pszKey, &wID);
			if ((dwRes != 0) && (dwRes != ERROR_NOT_FOUND))
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}
            dwRes = AddKey(pszKey, wID, dwData);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}

            dwRes = pParent->RemoveKey(i);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}
            _BtrMemFree(pszKey);

            dwRes = pSibling->GetKeyAt(0, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pSibling->GetUserData(0);
            dwChild = pSibling->GetChildPage(0);
            dwRes = pSibling->RemoveKey(0);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}

            SetChildPage(wID+1, dwChild);

            dwRes = pParent->AddKey(pszKey, i, dwData);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            pParent->SetChildPage(i, dwThisId);
            pParent->SetChildPage(i+1, dwSiblingId);
            _BtrMemFree(pszKey);
            break;
        }
        else if (dwChildA == dwSiblingId && dwChildB == dwThisId)
        {
            dwRes = pParent->GetKeyAt(i, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pParent->GetUserData(i);

            dwRes = FindKey(pszKey, &wID);
			if ((dwRes != 0) && (dwRes != ERROR_NOT_FOUND))
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}
            dwRes = AddKey(pszKey, wID, dwData);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}

            dwRes = pParent->RemoveKey(i);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}
            _BtrMemFree(pszKey);

            WORD wSibId = (WORD) pSibling->GetNumKeys() - 1;
            dwRes = pSibling->GetKeyAt(wSibId, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pSibling->GetUserData(wSibId);
            dwChild = pSibling->GetChildPage(wSibId+1);
            dwRes = pSibling->RemoveKey(wSibId);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}

            SetChildPage(wID, dwChild);

            dwRes = pParent->AddKey(pszKey, i, dwData);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}
            pParent->SetChildPage(i, dwSiblingId);
            pParent->SetChildPage(i+1, dwThisId);
            _BtrMemFree(pszKey);
            break;
        }
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::Collapse
//
//  Collapses the contents of a node and its sibling into just one
//  node and adjusts the parent.
//
//  Precondition:  The two siblings can be successfully collapsed
//  into a single node, accomodate a key migrated from the parent
//  and still safely fit into a single node.  Page sizes are not
//  checked here.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Collapse(
    SIdxKeyTable *pParent,
    SIdxKeyTable *pDoomedSibling
    )
{
    WORD wId;
    DWORD dwRes;
    LPSTR pszKey = 0;
    DWORD dwData;
    DWORD dwChild;
    BOOL bExtra = FALSE;

    DWORD dwSiblingId = pDoomedSibling->GetPageId();
    DWORD dwThisId = GetPageId();

    // Locate the node in the parent which points to the two
    // siblings.  Since we don't know which sibling this is,
    // we have to take into account the two possibilites.
    // Is <this> the right side or the left?
    //
    //              10  20  30  40
    //             |   |   |   |  |
    //             x  Sib This x  x
    //
    //        vs.
    //              10  20  30 40
    //             |   |   |  |  |
    //            x  This Sib x  x
    //
    //  We then migrate the key down into the current node
    //  and remove it from the parent.  We steal the first
    //
    // ======================================================

    for (WORD i = 0; i < WORD(pParent->GetNumKeys()); i++)
    {
        DWORD dwChildA = pParent->GetChildPage(i);
        DWORD dwChildB = pParent->GetChildPage(i+1);

        if (dwChildA == dwSiblingId && dwChildB == dwThisId)
        {
            dwRes = pParent->GetKeyAt(i, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pParent->GetUserData(i);
            dwRes = pParent->RemoveKey(i);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            pParent->SetChildPage(i, dwThisId);
            dwChild = pDoomedSibling->GetLastChildPage();
            dwRes = AddKey(pszKey, 0, dwData);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            SetChildPage(0, dwChild);
            _BtrMemFree(pszKey);
            bExtra = FALSE;
            break;
        }
        else if (dwChildA == dwThisId && dwChildB == dwSiblingId)
        {
            dwRes = pParent->GetKeyAt(i, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pParent->GetUserData(i);
            dwRes = pParent->RemoveKey(i);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            pParent->SetChildPage(i, dwThisId);
            dwRes = FindKey(pszKey, &wId);
			if ((dwRes != 0) && (dwRes != ERROR_NOT_FOUND))
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            dwRes = AddKey(pszKey, wId, dwData);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            _BtrMemFree(pszKey);
            bExtra = TRUE;
            break;
        }
    }

    // Move all info from sibling into the current node.
    // ==================================================

    DWORD dwNumSibKeys = pDoomedSibling->GetNumKeys();

    for (WORD i = 0; i < WORD(dwNumSibKeys); i++)
    {
        LPSTR pKeyStr = 0;
        dwRes = pDoomedSibling->GetKeyAt(i, &pKeyStr);
        if (dwRes)
            return dwRes;

        DWORD dwUserData = pDoomedSibling->GetUserData(i);

        dwRes = FindKey(pKeyStr, &wId);
        if (dwRes != ERROR_NOT_FOUND)
        {
            _BtrMemFree(pKeyStr);
            return ERROR_BAD_FORMAT;
        }

        dwRes = AddKey(pKeyStr, wId, dwUserData);
		if (dwRes != 0)
		{
            _BtrMemFree(pKeyStr);
			return dwRes;
		}

        dwChild = pDoomedSibling->GetChildPage(i);
        SetChildPage(wId, dwChild);
        _BtrMemFree(pKeyStr);
    }

    if (bExtra)
        SetChildPage(WORD(GetNumKeys()), pDoomedSibling->GetLastChildPage());

    pDoomedSibling->ZapPage();

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::GetRightSiblingOf
//  SIdxKeyTable::GetRightSiblingOf
//
//  Searches the child page pointers and returns the sibling of the
//  specified page.  A return value of zero indicates there was not
//  sibling of the specified value in the direction requested.
//
//***************************************************************************
//
DWORD SIdxKeyTable::GetRightSiblingOf(
    DWORD dwId
    )
{
    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (m_pdwChildPageMap[i] == dwId)
            return m_pdwChildPageMap[i+1];
    }

    return 0;
}

DWORD SIdxKeyTable::GetLeftSiblingOf(
    DWORD dwId
    )
{
    for (DWORD i = 1; i < m_dwNumKeys+1; i++)
    {
        if (m_pdwChildPageMap[i] == dwId)
            return m_pdwChildPageMap[i-1];
    }

    return 0;

}


//***************************************************************************
//
//  SIdxKeyTable::Redist
//
//  Used when inserting and performing a node split.
//  Precondition:
//  (a) The current node is oversized
//  (b) <pParent> is ready to receive the new median key
//  (c) <pNewSibling> is completely empty and refers to the lesser node (left)
//  (d) All pages have assigned numbers
//
//  We move the nodes from <this> into the <pNewSibling> until both
//  are approximately half full.  The median key is moved into the parent.
//  May fail if <pNewSibling> cannot allocate memory for the new stuff.
//
//  If any errors occur, the entire sequence should be considered as failed
//  and the pages invalid.
//
//***************************************************************************
//
DWORD SIdxKeyTable::Redist(
    SIdxKeyTable *pParent,
    SIdxKeyTable *pNewSibling
    )
{
    DWORD dwRes;
    WORD wID;

    if (pParent == 0 || pNewSibling == 0)
        return ERROR_INVALID_PARAMETER;

    if (m_dwNumKeys < 3)
    {
        return ERROR_INVALID_DATA;
    }

    // Find median key info and put it into parent.

    DWORD dwToTransfer = m_dwNumKeys / 2;

    while (dwToTransfer--)
    {
        // Get 0th key

        LPSTR pStr = 0;
        dwRes = GetKeyAt(0, &pStr);
        if (dwRes)
            return dwRes;

        DWORD dwUserData = GetUserData(0);

        // Move stuff into younger sibling

        dwRes = pNewSibling->FindKey(pStr, &wID);
        if (dwRes != ERROR_NOT_FOUND)
        {
            _BtrMemFree(pStr);
            return dwRes;
        }

        dwRes = pNewSibling->AddKey(pStr, wID, dwUserData);
        _BtrMemFree(pStr);

        if (dwRes)
            return dwRes;

        DWORD dwChildPage = GetChildPage(0);
        pNewSibling->SetChildPage(wID, dwChildPage);
        dwRes = RemoveKey(0);
		if (dwRes)
			return dwRes;
    }

    pNewSibling->SetChildPage(WORD(pNewSibling->GetNumKeys()), GetChildPage(0));

    // Next key is the median key, which migrates to the parent.

    LPSTR pStr = 0;
    dwRes = GetKeyAt(0, &pStr);
    if (dwRes)
        return dwRes;
    DWORD dwUserData = GetUserData(0);

    dwRes = pParent->FindKey(pStr, &wID);
    if (dwRes != ERROR_NOT_FOUND)
    {
        _BtrMemFree(pStr);
        return dwRes;
    }

    dwRes = pParent->AddKey(pStr, wID, dwUserData);
    _BtrMemFree(pStr);

    if (dwRes)
        return dwRes;

    dwRes = RemoveKey(0);
	if (dwRes != 0)
		return dwRes;

    // Patch in the various page pointers

    pParent->SetChildPage(wID, pNewSibling->GetPageId());
    pParent->SetChildPage(wID+1, GetPageId());

    // Everything else is already okay

    return NO_ERROR;
}


//***************************************************************************
//
//  SIdxKeyTable::SIdxKeyTable
//
//***************************************************************************
//  ok
SIdxKeyTable::SIdxKeyTable()
{
    m_dwRefCount = 0;
    m_dwPageId = 0;
    m_dwParentPageId = 0;

    m_dwNumKeys = 0;                // Num keys
    m_pwKeyLookup = 0;              // Offset of key into key-lookup-table
    m_dwKeyLookupTotalSize = 0;     // Elements in array
    m_pwKeyCodes = 0;               // Key encoding table
    m_dwKeyCodesTotalSize = 0;      // Total elements in array
    m_dwKeyCodesUsed = 0;           // Elements used
    m_pStrPool = 0;                 // The pool associated with this key table

    m_pdwUserData = 0;              // Stores user DWORDs for each key
    m_pdwChildPageMap = 0;          // Stores the child page map (num keys + 1)
}

//***************************************************************************
//
//***************************************************************************
//
DWORD SIdxKeyTable::Clone(
    OUT SIdxKeyTable **pRetCopy
    )
{
    SIdxKeyTable *pCopy = new SIdxKeyTable;
    if (!pCopy)
        return ERROR_NOT_ENOUGH_MEMORY;

    pCopy->m_dwRefCount = 1;
    pCopy->m_dwPageId = m_dwPageId;
    pCopy->m_dwParentPageId = m_dwParentPageId;
    pCopy->m_dwNumKeys = m_dwNumKeys;

    pCopy->m_pwKeyLookup = (WORD *)_BtrMemAlloc(sizeof(WORD) * m_dwKeyLookupTotalSize);
    if (pCopy->m_pwKeyLookup == 0)
    {
    	delete pCopy;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(pCopy->m_pwKeyLookup, m_pwKeyLookup, sizeof(WORD) * m_dwKeyLookupTotalSize);
    pCopy->m_dwKeyLookupTotalSize = m_dwKeyLookupTotalSize;

    pCopy->m_pdwUserData = (DWORD *)_BtrMemAlloc(sizeof(DWORD) * m_dwKeyLookupTotalSize);
    if (pCopy->m_pdwUserData == 0)
    {
    	delete pCopy;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(pCopy->m_pdwUserData, m_pdwUserData, sizeof(DWORD) * m_dwKeyLookupTotalSize);

    pCopy->m_pdwChildPageMap = (DWORD *) _BtrMemAlloc(sizeof(DWORD) * (m_dwKeyLookupTotalSize+1));
    if (pCopy->m_pdwChildPageMap == 0)
    {
    	delete pCopy;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(pCopy->m_pdwChildPageMap, m_pdwChildPageMap, sizeof(DWORD) * (m_dwKeyLookupTotalSize+1));

    pCopy->m_dwKeyCodesTotalSize = m_dwKeyCodesTotalSize;
    pCopy->m_pwKeyCodes = (WORD *) _BtrMemAlloc(sizeof(WORD) * m_dwKeyCodesTotalSize);
    if (pCopy->m_pwKeyCodes == 0)
    {
    	delete pCopy;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(pCopy->m_pwKeyCodes, m_pwKeyCodes, sizeof(WORD)* m_dwKeyCodesTotalSize);
    pCopy->m_dwKeyCodesUsed = m_dwKeyCodesUsed;

    if (m_pStrPool->Clone(&pCopy->m_pStrPool) != 0)
    {
    	delete pCopy;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *pRetCopy = pCopy;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::~SIdxKeyTable
//
//***************************************************************************
//
SIdxKeyTable::~SIdxKeyTable()
{
    if (m_pwKeyCodes)
        _BtrMemFree(m_pwKeyCodes);
    if (m_pwKeyLookup)
        _BtrMemFree(m_pwKeyLookup);
    if (m_pdwUserData)
        _BtrMemFree(m_pdwUserData);
    if (m_pdwChildPageMap)
        _BtrMemFree(m_pdwChildPageMap);
    if (m_pStrPool)
        delete m_pStrPool;
}

//***************************************************************************
//
//  SIdxKeyTable::GetKeyAt
//
//  Precondition: <wID> is correct
//  The only real case of failure is that the return string cannot be allocated.
//
//  Return values:
//      NO_ERROR
//      ERROR_NOT_ENOUGH_MEMORY
//      ERROR_INVALID_PARAMETER
//
//***************************************************************************
//  tested
DWORD SIdxKeyTable::GetKeyAt(
    WORD wID,
    LPSTR *pszKey
    )
{
    if (wID >= m_dwNumKeys || pszKey == 0)
        return ERROR_INVALID_PARAMETER;

    WORD wStartOffs = m_pwKeyLookup[wID];
    WORD wNumTokens = m_pwKeyCodes[wStartOffs];

    LPSTR Strings[MAX_TOKENS_PER_KEY];
    DWORD dwTotalLengths = 0;

    for (DWORD i = 0; i < DWORD(wNumTokens); i++)
    {
        Strings[i] = m_pStrPool->GetStrById(m_pwKeyCodes[wStartOffs+1+i]);
        dwTotalLengths += strlen(Strings[i]);
    }
	size_t _len = dwTotalLengths + 1 + wNumTokens;
    LPSTR pszFinalStr = (LPSTR) _BtrMemAlloc(_len);
    if (!pszFinalStr)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pszFinalStr = 0;

    for (DWORD i = 0; i < DWORD(wNumTokens); i++)
    {
        if (i > 0)
            StringCchCatA(pszFinalStr, _len, "\\");
        StringCchCatA(pszFinalStr, _len, Strings[i]);
    }

    *pszKey = pszFinalStr;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxStringPool::FindStr
//
//  Finds a string in the pool, if present and returns the assigned
//  offset.  Uses a binary search.
//
//  Return codes:
//      NO_ERROR            The string was found
//      ERROR_NOT_FOND
//
//***************************************************************************
// tested
DWORD SIdxStringPool::FindStr(
    IN  LPSTR pszSearchKey,
    OUT WORD *pwStringNumber,
    OUT WORD *pwPoolOffset
    )
{
    if (m_dwNumStrings == 0)
    {
        *pwStringNumber = 0;
        return ERROR_NOT_FOUND;
    }

    // Binary search current node for key match.
    // =========================================

    int nPosition = 0;
    int l = 0, u = int(m_dwNumStrings) - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        // m is the current key to consider 0...n-1

        LPSTR pszCandidateKeyStr = m_pStringPool+m_pwOffsets[m];
        int nRes = strcmp(pszSearchKey, pszCandidateKeyStr);

        // Decide which way to cut the array in half.
        // ==========================================

        if (nRes < 0)
        {
            u = m - 1;
            nPosition = u + 1;
        }
        else if (nRes > 0)
        {
            l = m + 1;
            nPosition = l;
        }
        else
        {
            // If here, we found the darn thing.  Life is good.
            // Populate the key unit.
            // ================================================
            if (pwStringNumber)
                *pwStringNumber = WORD(m);
            if (pwPoolOffset)
                *pwPoolOffset = m_pwOffsets[m];
            return NO_ERROR;
        }
    }

    // Not found, if here.  We record where the key should have been
    // and tell the user the unhappy news.
    // ==============================================================

    *pwStringNumber = WORD(short(nPosition));  // The key would have been 'here'
    return ERROR_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
//
DWORD SIdxStringPool::Clone(
    SIdxStringPool **pRetCopy
    )
{
    SIdxStringPool *pCopy = new SIdxStringPool;
    if (pCopy == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    pCopy->m_dwNumStrings = m_dwNumStrings;
    pCopy->m_pwOffsets = (WORD *) _BtrMemAlloc(sizeof(WORD)*m_dwOffsetsSize);
    if (pCopy->m_pwOffsets == 0)
    {
    	delete pCopy;
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(pCopy->m_pwOffsets, m_pwOffsets, sizeof(WORD)*m_dwOffsetsSize);

    pCopy->m_dwOffsetsSize = m_dwOffsetsSize;

    pCopy->m_pStringPool = (LPSTR) _BtrMemAlloc(m_dwPoolTotalSize);
    if (pCopy->m_pStringPool == 0)
    {
    	delete pCopy;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(pCopy->m_pStringPool, m_pStringPool, m_dwPoolTotalSize);
    pCopy->m_dwPoolTotalSize = m_dwPoolTotalSize;

    pCopy->m_dwPoolUsed = m_dwPoolUsed;

    *pRetCopy = pCopy;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxStringPool::DeleteStr
//
//  Removes a string from the pool and pool index.
//  Precondition:  <wStringNum> is known to be valid by virtue of a prior
//  call to <FindStr>.
//
//  Return values:
//  NO_ERROR            <Cannot fail if precondition is met>.
//
//***************************************************************************
//
DWORD SIdxStringPool::DeleteStr(
    WORD wStringNum,
    int *pnAdjuster
    )
{
    if (pnAdjuster)
        *pnAdjuster = 0;

    // Find the address of the string to be removed.
    // =============================================

    DWORD dwTargetOffs = m_pwOffsets[wStringNum];
    LPSTR pszDoomed = m_pStringPool+dwTargetOffs;
    DWORD dwDoomedStrLen = strlen(pszDoomed) + 1;

    // Copy all subsequent strings over the top and shorten the heap.
    // Special case if this already the last string
    // ==============================================================
    DWORD dwStrBytesToMove = DWORD(m_pStringPool+m_dwPoolUsed - pszDoomed - dwDoomedStrLen);

    if (dwStrBytesToMove)
        memmove(pszDoomed, pszDoomed+dwDoomedStrLen, dwStrBytesToMove);

    m_dwPoolUsed -= dwDoomedStrLen;

    // Remove this entry from the array.
    // =================================

    DWORD dwArrayElsToMove = m_dwNumStrings - wStringNum - 1;
    if (dwArrayElsToMove)
    {
        memmove(m_pwOffsets+wStringNum, m_pwOffsets+wStringNum+1, dwArrayElsToMove * sizeof(WORD));
        if (pnAdjuster)
            *pnAdjuster = -1;
    }
    m_dwNumStrings--;

    // For all remaining elements, adjust offsets that were affected.
    // ==============================================================
    for (DWORD dwTrace = 0; dwTrace < m_dwNumStrings; dwTrace++)
    {
        if (m_pwOffsets[dwTrace] > dwTargetOffs)
            m_pwOffsets[dwTrace] -= WORD(dwDoomedStrLen);
    }

    // Adjust sizes.
    // =============
    return NO_ERROR;
}


//***************************************************************************
//
//  SIdxStringPool::AddStr
//
//  Adds a string to the pool. Assumes it is known prior to the call that
//  the string isn't present.
//
//  Parameters:
//    pszString           The string to add
//    pwAssignedOffset    Returns the offset code assigned to the string
//  Return values:
//    NO_ERROR
//    ERROR_NOT_ENOUGH_MEMORY
//
//***************************************************************************
// ok
DWORD SIdxStringPool::AddStr(
    LPSTR pszString,
    WORD  wInsertPos,
    int *pnAdjuster
    )
{
    if (pnAdjuster)
        *pnAdjuster = 0;

    // Precondition: String doesn't exist in the table

    // Determine if the pool is too small for another string.
    // If so, extend it.
    // ======================================================

    DWORD dwRequired = strlen(pszString)+1;
    DWORD dwPoolFree = m_dwPoolTotalSize - m_dwPoolUsed;

    if (m_dwPoolUsed + dwRequired - 1 > MAX_WORD_VALUE)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if (dwRequired > dwPoolFree)
    {
        // Try to grow the pool
        // ====================
        LPVOID pTemp = _BtrMemReAlloc(m_pStringPool, m_dwPoolTotalSize * 2);
        if (!pTemp) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        m_dwPoolTotalSize *= 2;
        m_pStringPool = (LPSTR) pTemp;
    }

    // If array too small, reallocate to larger one
    // ============================================

    if (m_dwNumStrings == m_dwOffsetsSize)
    {
        // Realloc; double current size
        LPVOID pTemp = _BtrMemReAlloc(m_pwOffsets, m_dwOffsetsSize * sizeof(WORD) * 2);
        if (!pTemp)
            return ERROR_NOT_ENOUGH_MEMORY;
        m_dwOffsetsSize *= 2;
        m_pwOffsets = PWORD(pTemp);
    }

    // If here, no problem. We have enough space for everything.
    // =========================================================

    LPSTR pszInsertAddr = m_pStringPool+m_dwPoolUsed;
    DWORD dwInsertOffs = m_dwPoolUsed;
    StringCchCopyA(pszInsertAddr, m_dwPoolTotalSize-m_dwPoolUsed, pszString);
    m_dwPoolUsed += dwRequired;

    // If here, there is enough room.
    // ==============================

    DWORD dwToBeMoved = m_dwNumStrings - wInsertPos;

    if (dwToBeMoved)
    {
        memmove(&m_pwOffsets[wInsertPos+1], &m_pwOffsets[wInsertPos], sizeof(WORD)*dwToBeMoved);
        if (pnAdjuster)
            *pnAdjuster = 1;
    }

    m_pwOffsets[wInsertPos] = WORD(dwInsertOffs);
    m_dwNumStrings++;

    return NO_ERROR;
}


//***************************************************************************
//
//  ParseIntoTokens
//
//  Parses a slash separated string into separate tokens in preparation
//  for encoding into the string pool.  Call FreeStringArray on the output
//  when no longer needed.
//
//  No more than MAX_TOKEN_PER_KEY are supported.  This means that
//  if backslashes are used, no more than MAX_TOKEN_PER_KEY units can
//  be parsed out.
//
//  Returns:
//    ERROR_INVALID_PARAMETER
//    ERROR_NOT_ENOUGH_MEMORY
//    NO_ERROR
//
//***************************************************************************
//  ok
DWORD ParseIntoTokens(
    IN  LPSTR pszSource,
    OUT DWORD *pdwTokenCount,
    OUT LPSTR **pszTokens
    )
{
    LPSTR Strings[MAX_TOKENS_PER_KEY];
    DWORD dwParseCount = 0, i = 0;
    DWORD dwSourceLen = strlen(pszSource);
    LPSTR *pszRetStr = 0;
    DWORD dwRet;

    if (pszSource == 0 || *pszSource == 0)
        return ERROR_INVALID_PARAMETER;

    LPSTR pszTempBuf = (LPSTR) _BtrMemAlloc(dwSourceLen+1);
    if (!pszTempBuf)
        return ERROR_NOT_ENOUGH_MEMORY;

    LPSTR pszTracer = pszTempBuf;

    for (;;)
    {
        *pszTracer = *pszSource;
        if (*pszTracer == '\\' || *pszTracer == 0)
        {
            *pszTracer = 0;   // Replace with null terminator
			size_t _TempBufLen = strlen(pszTempBuf)+1;
            LPSTR pszTemp2 = (LPSTR) _BtrMemAlloc(_TempBufLen);
            if (pszTemp2 == 0)
            {
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }

            if (dwParseCount == MAX_TOKENS_PER_KEY)
            {
                _BtrMemFree(pszTemp2);
                dwRet = ERROR_INVALID_DATA;
                goto Error;
            }

            StringCchCopyA(pszTemp2, _TempBufLen, pszTempBuf);
            Strings[dwParseCount++] = pszTemp2;
            pszTracer = pszTempBuf;
            pszTracer--;
        }

        if (*pszSource == 0)
            break;

        pszTracer++;
        pszSource++;
    }

    // If here, we at least parsed one string.
    // =======================================
    pszRetStr = (LPSTR *) _BtrMemAlloc(sizeof(LPSTR) * dwParseCount);
    if (pszRetStr == 0)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    memcpy(pszRetStr, Strings, sizeof(LPSTR) * dwParseCount);
    *pdwTokenCount = dwParseCount;
    *pszTokens = pszRetStr;

    _BtrMemFree(pszTempBuf);

    return NO_ERROR;

Error:
    for (i = 0; i < dwParseCount; i++)
        _BtrMemFree(Strings[i]);
    *pdwTokenCount = 0;

    _BtrMemFree(pszTempBuf);

    return dwRet;
}


//***************************************************************************
//
//  FreeTokenArray
//
//  Cleans up the array returned by ParseIntoTokens.
//
//***************************************************************************
//  ok
void FreeTokenArray(
    DWORD dwCount,
    LPSTR *pszStrings
    )
{
    for (DWORD i = 0; i < dwCount; i++)
        _BtrMemFree(pszStrings[i]);
    _BtrMemFree(pszStrings);
}


//***************************************************************************
//
//  SIdxKeyTable::ZapPage
//
//  Empties the page completely of all keys, codes, strings
//
//***************************************************************************
//  ok
void SIdxKeyTable::ZapPage()
{
    m_pStrPool->Empty();
    m_dwKeyCodesUsed = 0;
    m_dwNumKeys = 0;
}

//***************************************************************************
//
//  SIdxKeyTable::MapFromPage
//
//  CAUTION!!!
//  The placement of DWORDs and WORDs is arranged to avoid 64-bit
//  alignment faults.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::MapFromPage(LPVOID pSrc)
{
    if (pSrc == 0)
        return ERROR_INVALID_PARAMETER;

    // Header
    //
    // DWORD[0]  Signature
    // DWORD[1]  Page number
    // DWORD[2]  Next Page (always zero)
    // ==================================\

    LPDWORD pDWCast = (LPDWORD) pSrc;

    if (*pDWCast++ != CBTreeFile::PAGE_TYPE_ACTIVE)
    {
        return ERROR_BAD_FORMAT;
    }
    m_dwPageId = *pDWCast++;
    pDWCast++;  // Skip the 'next page' field

    // Key lookup table info
    //
    // DWORD[0]    Parent Page
    // DWORD[1]    Num Keys = n
    // DWORD[n]    User Data
    // DWORD[n+1]  Child Page Map
    // WORD[n]     Key encoding offsets array
    // ======================================

    m_dwParentPageId = *pDWCast++;
    m_dwNumKeys = *pDWCast++;

    // Decide the allocation sizes and build the arrays
    // ================================================

    if (m_dwNumKeys <= const_DefaultArray)
        m_dwKeyLookupTotalSize = const_DefaultArray;
    else
        m_dwKeyLookupTotalSize = m_dwNumKeys;

    m_pdwUserData = (DWORD*) _BtrMemAlloc(m_dwKeyLookupTotalSize * sizeof(DWORD));
    m_pdwChildPageMap = (DWORD*) _BtrMemAlloc((m_dwKeyLookupTotalSize+1) * sizeof(DWORD));
    m_pwKeyLookup = (WORD*) _BtrMemAlloc(m_dwKeyLookupTotalSize * sizeof(WORD));

    if (m_pdwUserData == 0 || m_pdwChildPageMap == 0 || m_pwKeyLookup == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Copy the page info into the arrays
    // ==================================

    memcpy(m_pdwUserData, pDWCast, sizeof(DWORD) * m_dwNumKeys);
    pDWCast += m_dwNumKeys;
    memcpy(m_pdwChildPageMap, pDWCast, sizeof(DWORD) * (m_dwNumKeys+1));
    pDWCast += m_dwNumKeys + 1;
    memcpy(m_pwKeyLookup, pDWCast, sizeof(WORD) * m_dwNumKeys);
    LPWORD pWCast = LPWORD(pDWCast);
    pWCast += m_dwNumKeys;

    // Key encoding table info
    //
    // WORD[0]  Num key codes = n
    // WORD[n]  Key codes
    // ===========================

    m_dwKeyCodesUsed = (DWORD) *pWCast++;

    if (m_dwKeyCodesUsed <= const_DefaultKeyCodeArray)
        m_dwKeyCodesTotalSize = const_DefaultKeyCodeArray;
    else
        m_dwKeyCodesTotalSize = m_dwKeyCodesUsed;

    m_pwKeyCodes = (WORD*) _BtrMemAlloc(m_dwKeyCodesTotalSize * sizeof(WORD));
    if (!m_pwKeyCodes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(m_pwKeyCodes, pWCast, sizeof(WORD) * m_dwKeyCodesUsed);
    pWCast += m_dwKeyCodesUsed;

    // String pool
    //
    // WORD[0] Num strings = n
    // WORD[n] Offsets
    //
    // WORD[0] String pool size = n
    // BYTE[n] String pool
    // =============================

    m_pStrPool = new SIdxStringPool;
    if (!m_pStrPool)
        return ERROR_NOT_ENOUGH_MEMORY;

    m_pStrPool->m_dwNumStrings = (DWORD) *pWCast++;
    if (m_pStrPool->m_dwNumStrings <= const_DefaultArray)
        m_pStrPool->m_dwOffsetsSize = const_DefaultArray;
    else
        m_pStrPool->m_dwOffsetsSize = m_pStrPool->m_dwNumStrings;

    m_pStrPool->m_pwOffsets = (WORD *) _BtrMemAlloc(sizeof(WORD)* m_pStrPool->m_dwOffsetsSize);
    if (m_pStrPool->m_pwOffsets == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(m_pStrPool->m_pwOffsets, pWCast, sizeof(WORD)*m_pStrPool->m_dwNumStrings);
    pWCast += m_pStrPool->m_dwNumStrings;

    // String pool setup
    // =================

    m_pStrPool->m_dwPoolUsed = *pWCast++;
    LPSTR pszCast = LPSTR(pWCast);

    if (m_pStrPool->m_dwPoolUsed <= SIdxStringPool::const_DefaultPoolSize)
        m_pStrPool->m_dwPoolTotalSize = SIdxStringPool::const_DefaultPoolSize;
    else
        m_pStrPool->m_dwPoolTotalSize = m_pStrPool->m_dwPoolUsed;

    m_pStrPool->m_pStringPool = (LPSTR) _BtrMemAlloc(m_pStrPool->m_dwPoolTotalSize);
    if (m_pStrPool->m_pStringPool == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(m_pStrPool->m_pStringPool, pszCast, m_pStrPool->m_dwPoolUsed);

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::MapToPage
//
//  Copies the info to a linear page.  Precondition: the page must
//  be large enough by validating using a prior test to GetRequiredPageMemory.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::MapToPage(LPVOID pDest)
{
    if (pDest == 0)
        return ERROR_INVALID_PARAMETER;

    // Header
    //
    // DWORD[0]  Signature
    // DWORD[1]  Page number
    // DWORD[2]  Next Page (always zero)
    // ==================================\

    LPDWORD pDWCast = (LPDWORD) pDest;
    *pDWCast++ = CBTreeFile::PAGE_TYPE_ACTIVE;
    *pDWCast++ = m_dwPageId;
    *pDWCast++ = 0;  // Unused 'next page' field

    // Key lookup table info
    //
    // DWORD[0]    Parent Page
    // DWORD[1]    Num Keys = n
    // DWORD[n]    User Data
    // DWORD[n+1]  Child Page Map
    // WORD[n]     Key encoding offsets array
    // ======================================

    *pDWCast++ = m_dwParentPageId;
    *pDWCast++ = m_dwNumKeys;

    // Decide the allocation sizes and build the arrays
    // ================================================

    memcpy(pDWCast, m_pdwUserData, sizeof(DWORD) * m_dwNumKeys);
    pDWCast += m_dwNumKeys;
    memcpy(pDWCast, m_pdwChildPageMap, sizeof(DWORD) * (m_dwNumKeys+1));
    pDWCast += m_dwNumKeys + 1;
    memcpy(pDWCast, m_pwKeyLookup, sizeof(WORD) * m_dwNumKeys);
    LPWORD pWCast = LPWORD(pDWCast);
    pWCast += m_dwNumKeys;

    // Key encoding table info
    //
    // WORD[0]  Num key codes = n
    // WORD[n]  Key codes
    // ===========================

    *pWCast++ = WORD(m_dwKeyCodesUsed);
    memcpy(pWCast, m_pwKeyCodes, sizeof(WORD) * m_dwKeyCodesUsed);
    pWCast += m_dwKeyCodesUsed;

    // String pool
    //
    // WORD[0] Num strings = n
    // WORD[n] Offsets
    //
    // WORD[0] String pool size = n
    // BYTE[n] String pool
    // =============================

    *pWCast++ = WORD(m_pStrPool->m_dwNumStrings);
    memcpy(pWCast, m_pStrPool->m_pwOffsets, sizeof(WORD)*m_pStrPool->m_dwNumStrings);
    pWCast += m_pStrPool->m_dwNumStrings;

    *pWCast++ = WORD(m_pStrPool->m_dwPoolUsed);
    LPSTR pszCast = LPSTR(pWCast);
    memcpy(pszCast, m_pStrPool->m_pStringPool, m_pStrPool->m_dwPoolUsed);

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::Create
//
//  Does a default create
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Create(
    DWORD dwPageId,
    OUT SIdxKeyTable **pNewInst
    )
{
    SIdxKeyTable *p = new SIdxKeyTable;
    if (!p)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Set up default string pool, arrays, etc.
    // ========================================

    p->m_dwPageId = dwPageId;
    p->m_dwNumKeys = 0;
    p->m_pwKeyLookup = (WORD*) _BtrMemAlloc(const_DefaultArray * sizeof(WORD));
    p->m_dwKeyLookupTotalSize = const_DefaultArray;
    p->m_pwKeyCodes = (WORD*) _BtrMemAlloc(const_DefaultArray * sizeof(WORD));
    p->m_dwKeyCodesTotalSize = const_DefaultArray;
    p->m_dwKeyCodesUsed = 0;

    p->m_pdwUserData = (DWORD*) _BtrMemAlloc(const_DefaultArray * sizeof(DWORD));
    p->m_pdwChildPageMap = (DWORD*) _BtrMemAlloc((const_DefaultArray+1) * sizeof(DWORD));

    // Set up string pool.
    // ===================
    p->m_pStrPool = new SIdxStringPool;
    if (p->m_pStrPool != NULL)
    {
	    p->m_pStrPool->m_pwOffsets = (WORD*) _BtrMemAlloc(const_DefaultArray * sizeof(WORD));
	    p->m_pStrPool->m_dwOffsetsSize = const_DefaultArray;

	    p->m_pStrPool->m_pStringPool = (LPSTR) _BtrMemAlloc(SIdxStringPool::const_DefaultPoolSize);
	    p->m_pStrPool->m_dwPoolTotalSize = SIdxStringPool::const_DefaultPoolSize;
    }

    // Check all pointers.  If any are null, error out.
    // ================================================

    if (
       p->m_pwKeyLookup == NULL ||
       p->m_pwKeyCodes == NULL  ||
       p->m_pdwUserData == NULL ||
       p->m_pdwChildPageMap == NULL ||
       p->m_pStrPool == NULL ||
       p->m_pStrPool->m_pwOffsets == NULL ||
       p->m_pStrPool->m_pStringPool == NULL
       )
    {
        delete p;
        *pNewInst = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Return good object to caller.
    // =============================

    p->AddRef();
    *pNewInst = p;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxStringPool::~SIdxStringPool
//
//***************************************************************************
//  ok
SIdxStringPool::~SIdxStringPool()
{
    if (m_pwOffsets)
        _BtrMemFree(m_pwOffsets);
    m_pwOffsets = 0;
    if (m_pStringPool)
        _BtrMemFree(m_pStringPool);           // Pointer to string pool
    m_pStringPool = 0;
}

//***************************************************************************
//
//  SIdxKeyTable::Create
//
//  Does a default create
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Create(
    IN  LPVOID pPage,
    OUT SIdxKeyTable **pNewInst
    )
{
    SIdxKeyTable *p = new SIdxKeyTable;
    if (!p)
        return ERROR_NOT_ENOUGH_MEMORY;
    DWORD dwRes = p->MapFromPage(pPage);
    if (dwRes)
    {
        *pNewInst = 0;
        delete p;
        return dwRes;
    }
    p->AddRef();
    *pNewInst = p;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::AddRef
//
//***************************************************************************
// ok
DWORD SIdxKeyTable::AddRef()
{
    InterlockedIncrement((LONG *) &m_dwRefCount);
    return m_dwRefCount;
}

//***************************************************************************
//
//  SIdxKeyTable::Release
//
//***************************************************************************
// ok
DWORD SIdxKeyTable::Release()
{
    DWORD dwNewCount = InterlockedDecrement((LONG *) &m_dwRefCount);
    if (0 != dwNewCount)
        return dwNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SIdxKeyTable::Cleanup
//
//  Does a consistency check of the key encoding table and cleans up the
//  string pool if any strings aren't being referenced.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Cleanup()
{
    // See if all string pool codes are used in key code table.
    // If not, remove the string pool code.
    // =======================================================

    DWORD dwLastId = m_pStrPool->GetLastId();
    BOOL *pCheck = (BOOL*) _BtrMemAlloc(sizeof(BOOL) * dwLastId);
    if (!pCheck)
        return ERROR_NOT_ENOUGH_MEMORY;

    while (1)
    {
        if (m_pStrPool->GetNumStrings() == 0 || m_dwKeyCodesUsed == 0 || m_dwNumKeys == 0)
        {
            ZapPage();
            break;
        }

        dwLastId = m_pStrPool->GetLastId();
        memset(pCheck, 0, sizeof(BOOL)*dwLastId);   // Mark all codes as 'unused'

        // Move through all key codes.  If we delete a key encoding, there
        // may be a code in the string pool not used by the encoding.
        // What we have to do is set the pCheck array to TRUE for each
        // code encountered.  If any have FALSE when we are done, we have
        // an unused code.

        WORD wCurrentSequence = 0;
        for (DWORD i = 0; i < m_dwKeyCodesUsed; i++)
        {
            if (wCurrentSequence == 0)  // Skip the length WORD
            {
                wCurrentSequence = m_pwKeyCodes[i];
                continue;
            }
            else                        // A string pool code
                pCheck[m_pwKeyCodes[i]] = TRUE;
            wCurrentSequence--;
        }

        // Now the pCheck array contains deep within its psyche
        // the knowledge of whether or not all string pool codes
        // were used TRUE for referenced ones, FALSE for those
        // not referenced. Let's look through it and see!

        DWORD dwUsed = 0, dwUnused = 0;

        for (i = 0; i < dwLastId; i++)
        {
            if (pCheck[i] == FALSE)
            {
                dwUnused++;
                // Yikes! A lonely, unused string code.  Let's be merciful
                // and zap it before it knows the difference.
                // =======================================================
                int nAdj = 0;
                m_pStrPool->DeleteStr(WORD(i), &nAdj);
                AdjustKeyCodes(WORD(i), nAdj);
                break;
            }
            else
                dwUsed++;
        }

        if (dwUnused == 0)
            break;
    }

    _BtrMemFree(pCheck);

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::AdjustKeyCodes
//
//***************************************************************************
//  ok
void SIdxKeyTable::AdjustKeyCodes(
    WORD wID,
    int nAdjustment
    )
{
    // Adjust all key codes starting with wID by the amount of the
    // adjustment, skipping length bytes.
    // =============================================================

    WORD wCurrentSequence = 0;
    for (DWORD i = 0; i < m_dwKeyCodesUsed; i++)
    {
        if (wCurrentSequence == 0)
        {
            wCurrentSequence = m_pwKeyCodes[i];
            continue;
        }
        else
        {
            if (m_pwKeyCodes[i] >= wID)
                m_pwKeyCodes[i] = m_pwKeyCodes[i] + nAdjustment;
        }
        wCurrentSequence--;
    }
}

//***************************************************************************
//
//  SIdxKeyTable::AddKey
//
//  Adds a string to the table at position <wID>.  Assumes FindString
//  was called first to get the correct location.
//
//  Precondition:  <pszStr> is valid, and <wID> is correct.
//
//  Return codes:
//
//  ERROR_OUT_OF_MEMORY
//  NO_ERROR
//  ERROR_INVALID_PARAMETER     // Too many slashes in key
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::AddKey(
    LPSTR pszStr,
    WORD wKeyID,
    DWORD dwUserData
    )
{
    DWORD dwRes, dwRet;
    LPVOID pTemp = 0;
    LPSTR pszTemp = 0;
    DWORD dwLen, i;
    DWORD dwTokenCount = 0;
    WORD *pwTokenIDs = 0;
    DWORD dwNumNewTokens = 0;
    LPSTR *pszStrings = 0;
    DWORD dwToBeMoved;
    DWORD dwStartingOffset;

    // Set up some temp working arrays.
    // ================================
    if (!pszStr)
        return ERROR_INVALID_PARAMETER;
    dwLen = strlen(pszStr);
    if (dwLen == 0)
        return ERROR_INVALID_PARAMETER;

    pszTemp = (LPSTR) _BtrMemAlloc(dwLen+1);
    if (!pszTemp)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Ensure there is enough room.
    // ============================

    if (m_dwKeyLookupTotalSize == m_dwNumKeys)
    {
        // Expand the array.

        DWORD dwNewSize = m_dwKeyLookupTotalSize * 2;
        pTemp = _BtrMemReAlloc(m_pwKeyLookup, dwNewSize * sizeof(WORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_dwKeyLookupTotalSize = dwNewSize;
        m_pwKeyLookup = PWORD(pTemp);

        // Expand user data.

        pTemp = _BtrMemReAlloc(m_pdwUserData, dwNewSize * sizeof(DWORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_pdwUserData = (DWORD *) pTemp;

        // Expand child page map.

        pTemp = _BtrMemReAlloc(m_pdwChildPageMap, (dwNewSize + 1) * sizeof(DWORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_pdwChildPageMap = (DWORD *) pTemp;
    }

    // Parse the string into backslash separated tokens.
    // =================================================

    dwRes = ParseIntoTokens(pszStr, &dwTokenCount, &pszStrings);
    if (dwRes)
    {
        dwRet = dwRes;
        goto Exit;
    }

    // Allocate an array to hold the IDs of the tokens in the string.
    // ==============================================================

    pwTokenIDs = (WORD *) _BtrMemAlloc(sizeof(WORD) * dwTokenCount);
    if (pwTokenIDs == 0)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Work through the tokens and add them to the pool & key encoding table.
    // =============================================================

    for (i = 0; i < dwTokenCount; i++)
    {
        LPSTR pszTok = pszStrings[i];

        // See if token exists, if not add it.
        // ===================================
        WORD wID = 0;
        dwRes = m_pStrPool->FindStr(pszTok, &wID, 0);

        if (dwRes == NO_ERROR)
        {
            // Found it
            pwTokenIDs[dwNumNewTokens++] = wID;
        }
        else if (dwRes == ERROR_NOT_FOUND)
        {
            int nAdjustment = 0;
            dwRes = m_pStrPool->AddStr(pszTok, wID, &nAdjustment);
            if (dwRes)
            {
                dwRet = dwRes;
                goto Exit;
            }
            // Adjust string IDs because of the addition.
            // All existing ones with the same ID or higher
            // must be adjusted upwards.
            if (nAdjustment)
            {
                AdjustKeyCodes(wID, nAdjustment);
                for (DWORD i2 = 0; i2 < dwNumNewTokens; i2++)
                {
                    if (pwTokenIDs[i2] >= wID)
                        pwTokenIDs[i2] = pwTokenIDs[i2] + nAdjustment;
                }
            }

            // Adjust current tokens to accomodate new
            pwTokenIDs[dwNumNewTokens++] = wID;
        }
        else
        {
            dwRet = dwRes;
            goto Exit;
        }
    }

    // Now we know the encodings.  Add them to the key encoding table.
    // First make sure that there is enough room in the table.
    // ===============================================================

    if (m_dwKeyCodesTotalSize - m_dwKeyCodesUsed < dwNumNewTokens + 1)
    {
        DWORD dwNewSize = m_dwKeyCodesTotalSize * 2 + dwNumNewTokens + 1;
        PWORD pTemp2 = (PWORD) _BtrMemReAlloc(m_pwKeyCodes, dwNewSize * sizeof(WORD));
        if (!pTemp2)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_pwKeyCodes = pTemp2;
        m_dwKeyCodesTotalSize = dwNewSize;
    }

    dwStartingOffset = m_dwKeyCodesUsed;

    m_pwKeyCodes[m_dwKeyCodesUsed++] = (WORD) dwNumNewTokens;  // First WORD is count of tokens

    for (i = 0; i < dwNumNewTokens; i++)                    // Encoded tokens
        m_pwKeyCodes[m_dwKeyCodesUsed++] = pwTokenIDs[i];

    // Now, add in the new key lookup by inserting it into the array.
    // ==============================================================

    dwToBeMoved = m_dwNumKeys - wKeyID;

    if (dwToBeMoved)
    {
        memmove(&m_pwKeyLookup[wKeyID+1], &m_pwKeyLookup[wKeyID], sizeof(WORD)*dwToBeMoved);
        memmove(&m_pdwUserData[wKeyID+1], &m_pdwUserData[wKeyID], sizeof(DWORD)*dwToBeMoved);
        memmove(&m_pdwChildPageMap[wKeyID+1], &m_pdwChildPageMap[wKeyID], (sizeof(DWORD))*(dwToBeMoved+1));
    }

    m_pwKeyLookup[wKeyID] = (WORD) dwStartingOffset;
    m_pdwUserData[wKeyID] = dwUserData;
    m_dwNumKeys++;

    dwRet = NO_ERROR;

    // Cleanup code.
    // =============

Exit:
    if (pszTemp)
        _BtrMemFree(pszTemp);
    FreeTokenArray(dwTokenCount, pszStrings);
    if (pwTokenIDs)
        _BtrMemFree(pwTokenIDs);

    return dwRet;
}

//***************************************************************************
//
//  SIdxKeyTable::RemoveKey
//
//  Precondition: <wID> is the valid target
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::RemoveKey(
    WORD wID
    )
{
    // Find the key code sequence and remove it.
    // =========================================

    WORD wKeyCodeStart = m_pwKeyLookup[wID];
    DWORD dwToBeMoved = m_dwNumKeys - DWORD(wID) - 1;
    if (dwToBeMoved)
    {
        memmove(&m_pwKeyLookup[wID], &m_pwKeyLookup[wID+1], sizeof(WORD)*dwToBeMoved);
        memmove(&m_pdwUserData[wID], &m_pdwUserData[wID+1], sizeof(DWORD)*dwToBeMoved);
        memmove(&m_pdwChildPageMap[wID], &m_pdwChildPageMap[wID+1], sizeof(DWORD)*(dwToBeMoved+1));
    }
    m_dwNumKeys--;

    // Zap the key encoding table to remove references to this key.
    // ============================================================

    WORD wCount = m_pwKeyCodes[wKeyCodeStart]+1;
    dwToBeMoved = m_dwKeyCodesUsed - (wKeyCodeStart + wCount);
    if (dwToBeMoved)
        memmove(&m_pwKeyCodes[wKeyCodeStart], &m_pwKeyCodes[wKeyCodeStart + wCount], sizeof(WORD)*dwToBeMoved);
    m_dwKeyCodesUsed -= wCount;

    // Adjust all zapped key codes referenced by key lookup table.
    // ===========================================================
    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (m_pwKeyLookup[i] >= wKeyCodeStart)
            m_pwKeyLookup[i] -= wCount;
    }

    // Now check the string pool & key encoding table for
    // unreferenced strings thanks to the above tricks
    // and clean up the mess left behind!!
    // ==================================================

    return Cleanup();
}


//***************************************************************************
//
//  Compares the literal string in <pszSearchKey> against the encoded
//  string at <nID>.  Returns the same value as strcmp().
//
//  This is done by decoding the compressed string, token by token, and
//  comparing each character to that in the search string.
//
//***************************************************************************
//  ok
int SIdxKeyTable::KeyStrCompare(
    LPSTR pszSearchKey,
    WORD wID
    )
{
    LPSTR pszTrace = pszSearchKey;
    WORD dwEncodingOffs = m_pwKeyLookup[wID];
    WORD wNumTokens = m_pwKeyCodes[dwEncodingOffs];
    WORD wStrId = m_pwKeyCodes[++dwEncodingOffs];
    LPSTR pszDecoded = m_pStrPool->GetStrById(wStrId);
    wNumTokens--;
    int nRes;

    while (1)
    {
        int nTraceChar = *pszTrace++;
        int nCodedChar = *pszDecoded++;
        if (nCodedChar == 0 && wNumTokens)
        {
            pszDecoded = m_pStrPool->GetStrById(m_pwKeyCodes[++dwEncodingOffs]);
            wNumTokens--;
            nCodedChar = '\\';
        }
        nRes = nTraceChar - nCodedChar;
        if (nRes || (nTraceChar == 0 && nCodedChar == 0))
            return nRes;
    }

    // Identical strings
    return 0;
}


//***************************************************************************
//
//  SIdxKeyTable::FindKey
//
//  Finds the key in the key table, if present.  If not, returns
//  ERROR_NOT_FOUND and <pID> set to the point where it would be if
//  later inserted.
//
//  Return values:
//      ERROR_NOT_FOUND
//      NO_ERROR
//
//***************************************************************************
// ready for test
DWORD SIdxKeyTable::FindKey(
    LPSTR pszSearchKey,
    WORD *pID
    )
{
    if (pszSearchKey == 0 || *pszSearchKey == 0 || pID == 0)
        return ERROR_INVALID_PARAMETER;

    // Binary search the key table.
    // ============================

    if (m_dwNumKeys == 0)
    {
        *pID = 0;
        return ERROR_NOT_FOUND;
    }

    int nPosition = 0;
    int l = 0, u = int(m_dwNumKeys) - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;
        int nRes;

        // m is the current key to consider 0...n-1

        nRes = KeyStrCompare(pszSearchKey, WORD(m));

        // Decide which way to cut the array in half.
        // ==========================================

        if (nRes < 0)
        {
            u = m - 1;
            nPosition = u + 1;
        }
        else if (nRes > 0)
        {
            l = m + 1;
            nPosition = l;
        }
        else
        {
            // If here, we found the darn thing.  Life is good.
            // Populate the key unit.
            // ================================================

            *pID = WORD(m);
            return NO_ERROR;
        }
    }


    // Not found, if here.  We record where the key should have been
    // and tell the user the unhappy news.
    // ==============================================================

    *pID = WORD(nPosition);  // The key would have been 'here'
    return ERROR_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
// untested
DWORD SIdxKeyTable::Dump(FILE *f, DWORD *pdwKeys)
{
    fprintf(f, "\t|---Begin Key Table Dump---\n");

    fprintf(f, "\t| m_dwPageId              = %d (0x%X)\n", m_dwPageId, m_dwPageId);
    fprintf(f, "\t| m_dwParentPageId        = %d\n", m_dwParentPageId);
    fprintf(f, "\t| m_dwNumKeys             = %d\n", m_dwNumKeys);
    fprintf(f, "\t| m_pwKeyLookup           = 0x%p\n", m_pwKeyLookup);
    fprintf(f, "\t| m_dwKeyLookupTotalSize  = %d\n", m_dwKeyLookupTotalSize);
    fprintf(f, "\t| m_pwKeyCodes            = 0x%p\n", m_pwKeyCodes);
    fprintf(f, "\t| m_dwKeyCodesTotalSize   = %d\n", m_dwKeyCodesTotalSize);
    fprintf(f, "\t| m_dwKeyCodesUsed        = %d\n", m_dwKeyCodesUsed);
    fprintf(f, "\t| Required Page Memory    = %d\n", GetRequiredPageMemory());

    fprintf(f, "\t| --Key Lookup Table\n");

    if (pdwKeys)
        *pdwKeys = m_dwNumKeys;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        fprintf(f, "\t|  *  Left Child Page ------------------------> %d\n", m_pdwChildPageMap[i]);
        fprintf(f, "\t| KeyID[%d] = offset %d\n", i, m_pwKeyLookup[i]);
        fprintf(f, "\t|   User Data=%d\n", m_pdwUserData[i]);

        WORD wKeyEncodingOffset = m_pwKeyLookup[i];
        WORD wEncodingUnits = m_pwKeyCodes[wKeyEncodingOffset];

        int nPass = 0;
        fprintf(f, "\t  | Key=");

        for (DWORD i2 = 0; i2 < DWORD(wEncodingUnits); i2++)
        {
            WORD wCode = m_pwKeyCodes[wKeyEncodingOffset + 1 + i2];
            if (nPass)
                fprintf(f, "\\");
            fprintf(f,   "%s", m_pStrPool->GetStrById(wCode));
            nPass++;
        }

        fprintf(f, "\n");
        fprintf(f, "\t|  Num encoding units = %d\n", wEncodingUnits);

        for (DWORD i2 = 0; i2 < DWORD(wEncodingUnits); i2++)
        {
            WORD wCode = m_pwKeyCodes[wKeyEncodingOffset + 1 + i2];
            fprintf(f,   "\t  | KeyCode = %d\n", wCode);
        }
    }

    fprintf(f, "\t|   * Rightmost child page -------------------> %d\n", m_pdwChildPageMap[i]);
    fprintf(f, "\t|---\n");

#ifdef EXTENDED_STRING_TABLE_DUMP
    fprintf(f, "\t|---Key Encoding Table\n");

    WORD wCurrentSequence = 0;
    for (i = 0; i < m_dwKeyCodesUsed; i++)
    {
        if (wCurrentSequence == 0)
        {
            wCurrentSequence = m_pwKeyCodes[i];
            fprintf(f, "\t| KeyCode[%d] = %d <count>\n", i, m_pwKeyCodes[i]);
            continue;
        }
        else
            fprintf(f, "\t| KeyCode[%d] = %d <%s>\n", i, m_pwKeyCodes[i],
                m_pStrPool->GetStrById(m_pwKeyCodes[i]));
        wCurrentSequence--;
    }

    fprintf(f, "\t|---End Key Encoding Table---\n");
    m_pStrPool->Dump(f);
#endif
    return 0;
}



//***************************************************************************
//
//  SIdxStringPool::Dump
//
//  Dumps the string pool
//
//***************************************************************************
// tested
DWORD SIdxStringPool::Dump(FILE *f)
{
/*
    try
    {
    fprintf(f, "\t\t|| ---String Pool Dump---\n");
    fprintf(f, "\t\t|| m_dwNumStrings    = %d\n", m_dwNumStrings);
    fprintf(f, "\t\t|| m_pwOffsets       = 0x%p\n", m_pwOffsets);
    fprintf(f, "\t\t|| m_dwOffsetsSize   = %d\n",  m_dwOffsetsSize);
    fprintf(f, "\t\t|| m_pStringPool     = 0x%p\n", m_pStringPool);
    fprintf(f, "\t\t|| m_dwPoolTotalSize = %d\n", m_dwPoolTotalSize);
    fprintf(f, "\t\t|| m_dwPoolUsed      = %d\n", m_dwPoolUsed);

    fprintf(f, "\t\t|| --Contents of offsets array--\n");

    for (DWORD ix = 0; ix < m_dwNumStrings; ix++)
    {
        fprintf(f, "\t\t|| String[%d] = offset %d  Value=<%s>\n",
            ix, m_pwOffsets[ix], m_pStringPool+m_pwOffsets[ix]);
    }

#ifdef EXTENDED_STRING_TABLE_DUMP
    fprintf(f, "\t\t|| --String table--\n");

    for (ix = 0; ix < m_dwPoolTotalSize; ix += 20)
    {
        fprintf(f, "\t\t || %4d ", ix);

        for (int nSubcount = 0; nSubcount < 20; nSubcount++)
        {
            if (nSubcount + ix >= m_dwPoolTotalSize)
                continue;

            char c = m_pStringPool[ix+nSubcount];
            fprintf(f, "%02x ", c);
        }

        for (int nSubcount = 0; nSubcount < 20; nSubcount++)
        {
            if (nSubcount + ix >= m_dwPoolTotalSize)
                continue;

            char c = m_pStringPool[ix+nSubcount];
            if (c < 32)
            {
                c = '.';
            }
            fprintf(f, "%c ", c);
        }

        fprintf(f, "\n");
    }
#endif

    fprintf(f, "\t\t|| ---End of String Pool Dump\n");
    }
    catch(...)
    {
        printf("Exception during dump\n");
    }
*/
    return 0;
}


//***************************************************************************
//
//  CBTree::Init
//
//***************************************************************************
//
DWORD CBTree::Init(
    CBTreeFile *pSrc
    )
{
    DWORD dwRes;

    if (pSrc == 0)
        return ERROR_INVALID_PARAMETER;

    // Read the logical root page, if any.  If the index is just
    // being created, create the root index page.

    m_pSrc = pSrc;
    m_pRoot = 0;

    DWORD dwRoot = m_pSrc->GetRootPage();
    if (dwRoot == 0)
    {
        LPDWORD pNewPage = 0;

        dwRes = m_pSrc->NewPage((LPVOID *) &pNewPage);
        if (dwRes)
            return dwRes;

        DWORD dwPageNum = pNewPage[CBTreeFile::OFFSET_PAGE_ID];
        _BtrMemFree(pNewPage);
        dwRes = SIdxKeyTable::Create(dwPageNum, &m_pRoot);
        if (dwRes)
            return dwRes;

        dwRes = m_pSrc->SetRootPage(dwPageNum);
		if (dwRes)
			return dwRes;
        dwRes = WriteIdxPage(m_pRoot);
		if (dwRes)
			return dwRes;
    }
    else
    {
        // Retrieve existing root
        LPVOID pPage = 0;
        dwRes = m_pSrc->GetPage(dwRoot, &pPage);
        if (dwRes)
            return dwRes;

        dwRes = SIdxKeyTable::Create(pPage, &m_pRoot);
        _BtrMemFree(pPage);
        if (dwRes)
            return dwRes;
    }

    return dwRes;
}

//***************************************************************************
//
//  CBTree::CBTree
//
//***************************************************************************
//
CBTree::CBTree()
{
    m_pSrc = 0;
    m_pRoot = 0;
    m_lGeneration = 0;
}

//***************************************************************************
//
//  CBTree::~CBTree
//
//***************************************************************************
//
CBTree::~CBTree()
{
    if (m_pSrc || m_pRoot)
    {
        Shutdown(WMIDB_SHUTDOWN_NET_STOP);
    }
}

//***************************************************************************
//
//  CBTree::Shutdown
//
//***************************************************************************
//
DWORD CBTree::Shutdown(DWORD dwShutDownFlags)
{
    if (m_pRoot)
    {
        m_pRoot->Release();
        m_pRoot = 0;
    }

    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CBTree::InsertKey
//
//  Inserts the key+data into the tree.  Most of the work is done
//  in InsertPhase2().
//
//***************************************************************************
//   ok

DWORD CBTree::InsertKey(
    IN LPSTR pszKey,
    DWORD dwValue
    )
{
    DWORD dwRes;
	if (m_pRoot == NULL)
	{
		dwRes = InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
    WORD wID;
    SIdxKeyTable *pIdx = 0;
    LONG  StackPtr = -1;
    DWORD *Stack = new DWORD[CBTreeIterator::const_MaxStack];
	if (Stack == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;
	std::auto_ptr <DWORD> _autodelete(Stack);

    if (pszKey == 0 || *pszKey == 0)
        return ERROR_INVALID_PARAMETER;

    dwRes = Search(pszKey, &pIdx, &wID, Stack, StackPtr);
    if (dwRes == 0)
    {
        // Ooops.  Aleady exists.  We can't insert it.
        // ===========================================
        pIdx->Release();
        return ERROR_ALREADY_EXISTS;
    }

    if (dwRes != ERROR_NOT_FOUND)
        return dwRes;

    // If here, we can indeed add it.
    // ==============================

    dwRes = InsertPhase2(pIdx, wID, pszKey, dwValue, Stack, StackPtr);
	ReleaseIfNotNULL(pIdx);

    return dwRes;
}

//***************************************************************************
//
//  CBTree::ComputeLoad
//
//***************************************************************************
//
DWORD CBTree::ComputeLoad(
    SIdxKeyTable *pKT
    )
{
    DWORD  dwMem = pKT->GetRequiredPageMemory();
    DWORD  dwLoad = dwMem * 100 / m_pSrc->GetPageSize();
    return dwLoad;
}

//***************************************************************************
//
//  CBTree::Search
//
//  The actual search occurs here.  Descends through the page mechanism.
//
//  Returns:
//  NO_ERROR    <pPage> is assigned, and <pwID> points to the key.
//
//  ERROR_NOT_FOUND <pPage> is assigned to where the insert should occur,
//                  at <pwID> in that page.
//
//  Other errors don't assign the OUT parameters.
//
//  Note: caller must release <pRetIdx> using Release() when it is returned
//  whether with an error code or not.
//
//***************************************************************************
//  ok
DWORD CBTree::Search(
    IN  LPSTR pszKey,
    OUT SIdxKeyTable **pRetIdx,
    OUT WORD *pwID,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    DWORD dwRes, dwChildPage, dwPage;

    if (pszKey == 0 || *pszKey == 0 || pwID == 0 || pRetIdx == 0)
        return ERROR_INVALID_PARAMETER;
    *pRetIdx = 0;

    SIdxKeyTable *pIdx = m_pRoot;
    pIdx->AddRef();
    Stack[++StackPtr] = 0;

    while (1)
    {
        dwRes = pIdx->FindKey(pszKey, pwID);
        if (dwRes == 0)
        {
            // Found it

            *pRetIdx = pIdx;
            return NO_ERROR;
        }
		else if (dwRes != ERROR_NOT_FOUND)
		{
			pIdx->Release();
			pIdx = 0;
			return dwRes;
		}

        // Otherwise, we have to try to descend to a child page.
        // =====================================================
        dwPage = pIdx->GetPageId();
        dwChildPage = pIdx->GetChildPage(*pwID);
        if (dwChildPage == 0)
            break;

        pIdx->Release();
        pIdx = 0;
        Stack[++StackPtr] = dwPage;

        dwRes = ReadIdxPage(dwChildPage, &pIdx);
        if (dwRes)
			return dwRes;
    }

    *pRetIdx = pIdx;

    return ERROR_NOT_FOUND;
}

//***************************************************************************
//
//  CBTree::InsertPhase2
//
//  On entry, assumes that we have identified the page into which
//  the insert must physically occur.   This does the split + migrate
//  logical to keep the tree in balance.
//
//  Algorithm:  Add key to page.  If it does not overflow, we are done.
//  If overflow occurs, allocate a new sibling page which will acquire
//  half the keys from the current page.   This sibling will be treated
//  as lexically smaller in all cases.  The median key is migrated
//  up to the parent with pointers to both the new sibing page and
//  the current page.
//  The parent may also overflow.  If so, the algorithm repeats.
//  If an overflow occurs and there is no parent node (we are at the root)
//  a new root node is allocated and the median key migrated into it.
//
//***************************************************************************
// ok
DWORD CBTree::InsertPhase2(
    SIdxKeyTable *pCurrent,
    WORD wID,
    LPSTR pszKey,
    DWORD dwValue,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    DWORD dwRes;

    // If non-NULL, used for a primary insert.
    // If NULL, skip this, under the assumption the
    // node is already up-to-date and merely requires
    // the up-recursive split & migrate treatment.
    // ==============================================

    if (pszKey)
    {
        dwRes = pCurrent->AddKey(pszKey, wID, dwValue);
        if (dwRes)
            return dwRes;    // Failed
    }

    pCurrent->AddRef();                       // Makes following loop consistent
    SIdxKeyTable *pSibling = 0;
    SIdxKeyTable *pParent = 0;

    // The class B-tree split+migration loop.
    // ======================================

    for (;;)
    {
        // Check the current node where we added the key.
        // If it isn't too big, we're done.
        // ==============================================

        dwRes = pCurrent->GetRequiredPageMemory();
        if (dwRes <= m_pSrc->GetPageSize())
        {
            dwRes = WriteIdxPage(pCurrent);
            break;
        }

        // If here, it ain't gonna fit.  We have to split the page.
        // Allocate a new page (Sibling) and get the parent page, which
        // will receive the median key.
        // ============================================================

        DWORD dwParent = Stack[StackPtr--];
        if (dwParent == 0)
        {
            // Allocate a new page to become the parent.
            LPDWORD pParentPg = 0;
            dwRes = m_pSrc->NewPage((LPVOID *) &pParentPg);
            if (dwRes)
                break;

            DWORD dwNewParent = pParentPg[CBTreeFile::OFFSET_PAGE_ID];
            _BtrMemFree(pParentPg);

            dwRes = SIdxKeyTable::Create(dwNewParent, &pParent);
            if (dwRes)
                break;
            dwRes = m_pSrc->SetRootPage(dwNewParent);
            if (dwRes)
                break;

            m_pRoot->Release();    // Replace old root
            m_pRoot = pParent;
            m_pRoot->AddRef();
        }
        else
        {
            if (dwParent == m_pRoot->GetPageId())
            {
                pParent = m_pRoot;
                pParent->AddRef();
            }
            else
            {
                dwRes = ReadIdxPage(dwParent, &pParent);
                if (dwRes)
                    break;
            }
        }

        // Allocate a new sibling in any case to hold half the keys
        // ========================================================

        LPDWORD pSibPg = 0;
        dwRes = m_pSrc->NewPage((LPVOID *) &pSibPg);
        if (dwRes)
            break;

        DWORD dwNewSib = pSibPg[CBTreeFile::OFFSET_PAGE_ID];
        _BtrMemFree(pSibPg);

        dwRes = SIdxKeyTable::Create(dwNewSib, &pSibling);
        if (dwRes)
            break;

        dwRes = pCurrent->Redist(pParent, pSibling);
        if (dwRes)
            break;

        dwRes = WriteIdxPage(pCurrent);
		if (dwRes)
			break;
        dwRes = WriteIdxPage(pSibling);
		if (dwRes)
			break;

        pCurrent->Release();
        pCurrent = 0;
        pSibling->Release();
        pSibling = 0;

        if (dwRes)
            break;

        pCurrent = pParent;
        pParent = 0;
    }

    ReleaseIfNotNULL(pParent);
    ReleaseIfNotNULL(pCurrent);
    ReleaseIfNotNULL(pSibling);

    return dwRes;
}


//***************************************************************************
//
//  CBTree::WriteIdxPage
//
//  Writes the object to the physical page it is assigned to.
//  If the page ID is zero, then it is considered invalid.  Further,
//  while is it correct to precheck the page size, this function does
//  validate with regard to sizes, etc.
//
//***************************************************************************
//
DWORD CBTree::WriteIdxPage(
    SIdxKeyTable *pIdx
    )
{
    DWORD dwRes;
    DWORD dwPageSize = m_pSrc->GetPageSize();
    DWORD dwMem = pIdx->GetRequiredPageMemory();
    if (dwMem > dwPageSize)
        return ERROR_INVALID_PARAMETER;

    LPVOID pMem = _BtrMemAlloc(dwPageSize);
    if (pMem == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    dwRes =  pIdx->MapToPage(pMem);
    if (dwRes)
    {
        _BtrMemFree(pMem);
        return dwRes;
    }

    dwRes = m_pSrc->PutPage(pMem, CBTreeFile::PAGE_TYPE_ACTIVE);
    _BtrMemFree(pMem);
	if (dwRes)
		return dwRes;

    InterlockedIncrement(&m_lGeneration);

    // Check for a root update.
    // ========================

    if (m_pRoot != pIdx && m_pRoot->GetPageId() == pIdx->GetPageId())
    {
        m_pRoot->Release();
        m_pRoot = pIdx;
        m_pRoot->AddRef();

        if (m_pSrc->GetRootPage() != m_pRoot->GetPageId())
           dwRes = m_pSrc->SetRootPage(m_pRoot->GetPageId());
    }

    return dwRes;
}

//***************************************************************************
//
//  CBTree::ReadIdxPage
//
//***************************************************************************
//
DWORD CBTree::ReadIdxPage(
    DWORD dwPage,
    SIdxKeyTable **pIdx
    )
{
    DWORD dwRes;
    LPVOID pPage = 0;
    SIdxKeyTable *p = 0;
    if (pIdx == 0)
        return ERROR_INVALID_PARAMETER;
    *pIdx = 0;

//    if (dwPage < MAX_PAGE_HISTORY)      // May remove if studies show no caching possible
//        ++History[dwPage];

    dwRes = m_pSrc->GetPage(dwPage, &pPage);
    if (dwRes)
        return dwRes;

    dwRes = SIdxKeyTable::Create(pPage, &p);
    if (dwRes)
    {
        _BtrMemFree(pPage);
        return dwRes;
    }

    _BtrMemFree(pPage);
    if (dwRes)
        return dwRes;

    *pIdx = p;
    return dwRes;
}

//***************************************************************************
//
//  CBTree::FindKey
//
//  Does a simple search of a key, returning the user data, if requested.
//
//  Typical Return values
//      NO_ERROR
//      ERROR_NOT_FOUND
//
//***************************************************************************
//  ok

DWORD CBTree::FindKey(
    IN LPSTR pszKey,
    DWORD *pdwData
    )
{
    DWORD dwRes;
	if (m_pRoot == NULL)
	{
		dwRes = InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
    WORD wID;
    SIdxKeyTable *pIdx = 0;
    LONG  StackPtr = -1;
    DWORD *Stack = new DWORD[CBTreeIterator::const_MaxStack];
	if (Stack == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;
	CVectorDeleteMe<DWORD> vdm(Stack);

    if (pszKey == 0 || *pszKey == 0)
        return ERROR_INVALID_PARAMETER;

    // Search high and low, hoping against hope...
    // ===========================================

    dwRes = Search(pszKey, &pIdx, &wID, Stack, StackPtr);
    if (dwRes == 0 && pdwData)
    {
        *pdwData = pIdx->GetUserData(wID);
    }

    // If here, we can indeed add it.
    // ==============================

    ReleaseIfNotNULL(pIdx);
    return dwRes;
}


//***************************************************************************
//
//  CBTree::DeleteKey
//
//***************************************************************************
//
DWORD CBTree::DeleteKey(
    IN LPSTR pszKey
    )
{
    DWORD dwRes;
	if (m_pRoot == NULL)
	{
		dwRes = InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
    LONG  StackPtr = -1;
    DWORD *Stack = new DWORD[CBTreeIterator::const_MaxStack];
	if (Stack == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;
	CVectorDeleteMe<DWORD> vdm(Stack);

    SIdxKeyTable *pIdx = 0;
    WORD wId;
    DWORD dwLoad;

    // Find it
    // =======
    dwRes = Search(pszKey, &pIdx, &wId, Stack, StackPtr);
    if (dwRes)
        return dwRes;

    // Delete key from from page
    // ==========================

    if (pIdx->IsLeaf())
    {
        // A leaf node.  Remove the key.
        // =============================
        dwRes = pIdx->RemoveKey(wId);
		if (dwRes)
			return dwRes;

        // Now, check the load and see if it has dropped below 30%.
        // Of course, if we are at the root node and it is a leaf,
        // we have to pretty much let it go as is...
        // ========================================================
        dwLoad = ComputeLoad(pIdx);
        if (dwLoad > const_MinimumLoad ||
            pIdx->GetPageId() == m_pRoot->GetPageId())
        {
            dwRes = WriteIdxPage(pIdx);
            pIdx->Release();
            return dwRes;
        }
    }
    else
    {
        // An internal node, so we have to find the successor.
        // Since this call may alter the shape of the tree quite
        // a bit (the successor may overflow the affected node),
        // we have to relocate the successor.
        // ====================================================
        LPSTR pszSuccessor = 0;
        BOOL bUnderflow = FALSE;
        dwRes = ReplaceBySuccessor(pIdx, wId, &pszSuccessor, &bUnderflow, Stack, StackPtr);
        if (dwRes)
            return dwRes;

        dwRes = InsertPhase2(pIdx, 0, 0, 0, Stack, StackPtr);
        if (dwRes)
            return dwRes;

        pIdx->Release();
        pIdx = 0;
        StackPtr = -1;

        if (bUnderflow == FALSE)
        {
            _BtrMemFree(pszSuccessor);
            return NO_ERROR;
        }

        // If here, the node we extracted the successor from was reduced
        // to poverty and underflowed.  We have to find it again and
        // execute the underflow repair loop.
        // =============================================================

        dwRes = Search(pszSuccessor, &pIdx, &wId, Stack, StackPtr);
        _BtrMemFree(pszSuccessor);
        if (dwRes)
            return dwRes;

        SIdxKeyTable *pSuccessor = 0;
        dwRes = FindSuccessorNode(pIdx, wId, &pSuccessor, 0, Stack, StackPtr);
        if (dwRes)
            return dwRes;

        pIdx->Release();
        pIdx = pSuccessor;
    }

    // UNDERFLOW REPAIR Loop.
    // At this point <pIdx> points to the deepest affected node.
    // We need to start working back up the tree and repairing
    // the damage.  Nodes which have reached zero in size are
    // quite a pain.  But they aren't half as bad as nodes which claim
    // they can recombine with a sibling but really can't.  So,
    // we either do nothing (the node has enough stuff to be useful),
    // collapse with a sibling node or borrow some keys from a sibling
    // to ensure all nodes meet the minimum load requirement.
    // ===============================================================

    SIdxKeyTable *pSibling = 0;
    SIdxKeyTable *pParent = 0;

    for (;;)
    {
        DWORD dwParentId = Stack[StackPtr--];
        DWORD dwThisId = pIdx->GetPageId();

        dwLoad = ComputeLoad(pIdx);
        if (dwLoad > const_MinimumLoad || dwParentId == 0)
        {
            dwRes = WriteIdxPage(pIdx);
            pIdx->Release();
			if (dwRes != 0)
				return dwRes;
            break;
        }

        // If here the node is getting small.  We must collapsed this
        // node with a sibling.

        // collapse this node and a sibling

        dwRes = ReadIdxPage(dwParentId, &pParent);
		if (dwRes != 0)
			return dwRes;

        // Locate a sibling and see if the sibling and the current node
        // can be collapsed with leftover space.
        // =============================================================

        DWORD dwLeftSibling = pParent->GetLeftSiblingOf(pIdx->GetPageId());
        DWORD dwRightSibling = pParent->GetRightSiblingOf(pIdx->GetPageId());
        DWORD dwSiblingId = 0;

        if (dwLeftSibling)
        {
            dwRes = ReadIdxPage(dwLeftSibling, &pSibling);
			if (dwRes != 0)
				return dwRes;
            dwSiblingId = pSibling->GetPageId();
        }
        else
        {
            dwRes = ReadIdxPage(dwRightSibling, &pSibling);
			if (dwRes != 0)
				return dwRes;
            dwSiblingId = pSibling->GetPageId();
        }

        // If here, the node is 'underloaded'.  Now we have to
        // get the parent and the sibling and collapsed them.
        // ===================================================

        SIdxKeyTable *pCopy = 0;
        dwRes = pIdx->Clone(&pCopy);
		if (dwRes != 0)
			return dwRes;

        dwRes = pIdx->Collapse(pParent, pSibling);
		if (dwRes != 0)
		{
			pCopy->Release();
			return dwRes;
		}

        // Now we have a different sort of problem, possibly.
        // If the collapsed node is too big, we have to try
        // a different strategy.
        // ===================================================

        if (pIdx->GetRequiredPageMemory() > m_pSrc->GetPageSize())
        {
            pIdx->Release();
            pParent->Release();
            pSibling->Release();
            pIdx = pParent = pSibling = 0;

            // Reread the pages.
            // =================
            pIdx = pCopy;
            dwRes = ReadIdxPage(dwParentId, &pParent);
			if (dwRes != 0)
				return dwRes;
            dwRes = ReadIdxPage(dwSiblingId, &pSibling);
			if (dwRes != 0)
				return dwRes;

            // Transfer a key or two from sibling via parent.
            // This doesn't change the tree shape, but the
            // parent may overflow.
            // ==============================================
            do
            {
                dwRes = pIdx->StealKeyFromSibling(pParent, pSibling);
				if (dwRes != 0)
					return dwRes;
                dwLoad = ComputeLoad(pIdx);
            }   while (dwLoad < const_MinimumLoad);

            dwRes = WriteIdxPage(pIdx);
            pIdx->Release();
			if (dwRes != 0)
				return dwRes;
            dwRes = WriteIdxPage(pSibling);
            pSibling->Release();
			if (dwRes != 0)
				return dwRes;
            dwRes = InsertPhase2(pParent, 0, 0, 0, Stack, StackPtr);
            pParent->Release();
			if (dwRes != 0)
				return dwRes;
            break;
        }
        else  // The collapse worked; we can free the sibling page
        {
            pCopy->Release();
            dwRes = m_pSrc->FreePage(pSibling->GetPageId());
			if (dwRes != 0)
				return dwRes;
            pSibling->Release();
        }

        // If here, the collapse worked.
        // =============================

        dwRes = WriteIdxPage(pIdx);
        if (dwRes)
        {
            pIdx->Release();
            break;
        }

        if (pParent->GetNumKeys() == 0)
        {
            // We have replaced the root. Note
            // that we transfer the ref count of pIdx to m_pRoot.
            DWORD dwOldRootId = m_pRoot->GetPageId();
            m_pRoot->Release();
            m_pRoot = pIdx;

            // Even though we wrote <pIdx> a few lines back,
            // a rewrite is required to update internal stuff
            // because this has become the new root.
            // ==============================================
            dwRes = m_pSrc->SetRootPage(m_pRoot->GetPageId());
			if (dwRes != 0)
				return dwRes;
            dwRes = WriteIdxPage(m_pRoot);
			if (dwRes != 0)
				return dwRes;
            dwRes = m_pSrc->FreePage(dwOldRootId);
			if (dwRes != 0)
				return dwRes;
            pParent->Release();
            break;
        }

        pIdx->Release();
        pIdx = pParent;
    }

    return dwRes;
}

//***************************************************************************
//
//  CBTree::ReplaceBySuccessor
//
//  Removes the wId key in the <pIdx> node, and replaces it with the
//  successor.
//
//  Precondition: <pIdx> is an internal (non-leaf) node.
//
//  Side-effects:  <pIdx> may be overflowed and require the InsertPhase2
//  treatment.  The node from which the successor is extracted is
//  written, but may have been reduced to zero keys.
//
//***************************************************************************
//
DWORD CBTree::ReplaceBySuccessor(
    IN SIdxKeyTable *pIdx,
    IN WORD wId,
    OUT LPSTR *pszSuccessorKey,
    OUT BOOL *pbUnderflowDetected,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    SIdxKeyTable *pTemp = 0;
    DWORD dwRes;
    DWORD dwPredecessorChild;

    dwRes = FindSuccessorNode(pIdx, wId, &pTemp, &dwPredecessorChild, Stack, StackPtr);
    if (dwRes || pTemp == 0)
        return dwRes;

    LPSTR pszKey = 0;
    dwRes = pTemp->GetKeyAt(0, &pszKey);
	if (dwRes)
	{
	    pTemp->Release();
		return dwRes;
	}
    DWORD dwUserData = pTemp->GetUserData(0);
    dwRes = pTemp->RemoveKey(0);
	if (dwRes)
	{
        _BtrMemFree(pszKey);
        pTemp->Release();

		return dwRes;
	}
    if (ComputeLoad(pTemp) < const_MinimumLoad)
        *pbUnderflowDetected = TRUE;
    dwRes = WriteIdxPage(pTemp);
    pTemp->Release();
	if (dwRes)
	{
	    _BtrMemFree(pszKey);
		return dwRes;
	}

    pIdx->RemoveKey(wId);
    dwRes = pIdx->AddKey(pszKey, wId, dwUserData);
	if (dwRes)
	{
		_BtrMemFree(pszKey);
		return dwRes;
	}
    pIdx->SetChildPage(wId, dwPredecessorChild);

    *pszSuccessorKey = pszKey;
    StackPtr--;
    return dwRes;
}

//***************************************************************************
//
//  CBTree::FindSuccessorNode
//
//  Read-only. Finds the node containing the successor to the specified key.
//
//***************************************************************************
//
DWORD CBTree::FindSuccessorNode(
    IN SIdxKeyTable *pIdx,
    IN WORD wId,
    OUT SIdxKeyTable **pSuccessor,
    OUT DWORD *pdwPredecessorChild,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    SIdxKeyTable *pTemp = 0;
    DWORD dwRes = 0;
    DWORD dwSuccessorChild, dwPredecessorChild;

    dwPredecessorChild = pIdx->GetChildPage(wId);
    dwSuccessorChild = pIdx->GetChildPage(wId+1);

    Stack[++StackPtr] = pIdx->GetPageId();

    // From this point on, take leftmost children until
    // we reach a leaf node.  The leftmost key in the
    // leftmost node is always the successor, thanks to the
    // astonishing properties of the BTree.  Nice and easy, huh?
    // =========================================================

    while (dwSuccessorChild)
    {
        Stack[++StackPtr] = dwSuccessorChild;
        if (pTemp)
            pTemp->Release();
        dwRes = ReadIdxPage(dwSuccessorChild, &pTemp);
		if (dwRes)
		{
			//Bail because we have an error!
			return dwRes;
		}
        dwSuccessorChild = pTemp->GetChildPage(0);
    }

    StackPtr--;     // Pop the element we are returning in <*pSuccessor>

    *pSuccessor = pTemp;
    if (pdwPredecessorChild)
        *pdwPredecessorChild = dwPredecessorChild;

    return dwRes;
}



//***************************************************************************
//
//   CBTree::BeginEnum
//
//***************************************************************************
//
DWORD CBTree::BeginEnum(
    LPSTR pszStartKey,
    OUT CBTreeIterator **pIterator
    )
{
	DWORD dwRes;
	if (m_pRoot == NULL)
	{
		dwRes = InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
    CBTreeIterator *pIt = new CBTreeIterator;
    if (pIt == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    dwRes = pIt->Init(this, pszStartKey);
    if (dwRes)
    {
        pIt->Release();
        return dwRes;
    }

    *pIterator = pIt;
    return NO_ERROR;
}


//***************************************************************************
//
//   CBTree::Dump
//
//***************************************************************************
//
void CBTree::Dump(FILE *f)
{
    m_pSrc->Dump(f);
}


//***************************************************************************
//
//***************************************************************************
//
DWORD CBTree::InvalidateCache()
{
	if (m_pRoot)
		m_pRoot->Release();

    DWORD dwRootPage = m_pSrc->GetRootPage();
    DWORD dwRes = ReadIdxPage(dwRootPage, &m_pRoot);
    return dwRes;
}

//***************************************************************************
//
//  CBTreeIterator::FlushCaches
//
//***************************************************************************
//
DWORD CBTree::FlushCaches()
{
	if (m_pRoot)
	{
		m_pRoot->Release();
		m_pRoot = NULL;
	}
	return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeIterator::Init
//
//***************************************************************************
//
DWORD CBTreeIterator::Init(
    IN CBTree *pTree,
    IN LPSTR pszStartKey
    )
{
	DWORD dwRes;
    if (pTree == 0)
        return ERROR_INVALID_PARAMETER;
    m_pTree = pTree;

	if (m_pTree->m_pRoot == NULL)
	{
		dwRes = m_pTree->InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}

    // Special case of enumerating everything.  Probably not useful
    // for WMI, but great for testing & debugging (I think).
    // ============================================================

    if (pszStartKey == 0)
    {
        Push(0, 0); // Sentinel value in stack

        SIdxKeyTable *pRoot = pTree->m_pRoot;
        pRoot->AddRef();
        Push(pRoot, 0);

        DWORD dwChildPage = Peek()->GetChildPage(0);

        while (dwChildPage)
        {
            SIdxKeyTable *pIdx = 0;
            dwRes = m_pTree->ReadIdxPage(dwChildPage, &pIdx);
            if (dwRes)
                return dwRes;
            if (StackFull())
            {
                pIdx->Release();
                return ERROR_INSUFFICIENT_BUFFER;
            }
            Push(pIdx, 0);
            dwChildPage = pIdx->GetChildPage(0);
        }
        return NO_ERROR;
    }

    // If here, a matching string was specified.
    // This is the typical case.
    // =========================================

    Push(0, 0); // Sentinel value in stack

    WORD wId = 0;
    DWORD dwChildPage;
    SIdxKeyTable *pIdx = pTree->m_pRoot;
    pIdx->AddRef();

    while (1)
    {
        dwRes = pIdx->FindKey(pszStartKey, &wId);
        if (dwRes == 0)
        {
            // Found it
            Push(pIdx, wId);
            return NO_ERROR;
        }
		else if (dwRes != ERROR_NOT_FOUND)
			return dwRes;

        // Otherwise, we have to try to descend to a child page.
        // =====================================================
        dwChildPage = pIdx->GetChildPage(wId);
        if (dwChildPage == 0)
            break;

        Push(pIdx, wId);
        pIdx = 0;
        dwRes = pTree->ReadIdxPage(dwChildPage, &pIdx);
        if (dwRes)
            return dwRes;
    }

    Push(pIdx, wId);

    while (Peek() && PeekId() == WORD(Peek()->GetNumKeys()))
        Pop();

    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeIterator::Next
//
//  On entry:
//  <wID> is the key to visit in the current node (top-of-stack).
//  The call sets up the successor before leaving.  If there is no successor,
//  the top of stack is left at NULL and ERROR_NO_MORE_ITEMS is returned.
//
//  Returns ERROR_NO_MORE_ITEMS when the iteration is complete.
//
//***************************************************************************
//
DWORD CBTreeIterator::Next(
    LPSTR *ppszStr,
    DWORD *pdwData
    )
{
    DWORD dwRes;

    if (ppszStr == 0)
        return ERROR_INVALID_PARAMETER;
    *ppszStr = 0;

    if (Peek() == 0)
        return ERROR_NO_MORE_ITEMS;

    // Get the item for the caller.
    // ============================

    dwRes = Peek()->GetKeyAt(PeekId(), ppszStr);
    if (dwRes)
        return dwRes;
    if (pdwData)
        *pdwData = Peek()->GetUserData(PeekId());
    IncStackId();

    // Now find the successor.
    // =======================

    DWORD dwChildPage = Peek()->GetChildPage(PeekId());

    while (dwChildPage)
    {
        SIdxKeyTable *pIdx = 0;
        dwRes = m_pTree->ReadIdxPage(dwChildPage, &pIdx);
        if (dwRes)
        {
            _BtrMemFree(*ppszStr);
            *ppszStr = NULL;
            return dwRes;
        }
        if (StackFull())
        {
            _BtrMemFree(*ppszStr);
            *ppszStr = NULL;
            pIdx->Release();
            return ERROR_INSUFFICIENT_BUFFER;
        }
        Push(pIdx, 0);
        dwChildPage = pIdx->GetChildPage(0);
    }

    // If here, we are at a leaf node.
    // ===============================

    while (Peek() && PeekId() == WORD(Peek()->GetNumKeys()))
        Pop();

    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeIterator::Release
//
//***************************************************************************
//
DWORD CBTreeIterator::Release()
{
    delete this;
    return 0;
}

//***************************************************************************
//
//  CBTreeIterator::~CBTreeIterator
//
//***************************************************************************
//
CBTreeIterator::~CBTreeIterator()
{
    // Cleanup any leftover stack
    while (m_lStackPointer > -1)
        Pop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\creposit.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <ql.h>
#include <time.h>
#include "a51rep.h"
#include <md5.h>
#include <objpath.h>
#include "lock.h"
#include <persistcfg.h>
#include "a51fib.h"
#include "RepositoryPackager.h"
#include "Win9xSecurity.h"
#include <scopeguard.h>
#include <malloc.h>
#include "Upgrade.h"

#define A51REP_CACHE_FLUSH_TIMEOUT 60000
#define A51REP_THREAD_IDLE_TIMEOUT 60000

//Checkpoint timeout is how long between getting a write notification it takes
//before we commit all transactions
#define A51_WRITE_CHECKPOINT 7500

//Number of pages from each of the paged files to be moved from the end to a 
//place earlier in the file
#define A51_WRITE_OPERATION_COMPACT 10

//

LONG g_RecoverFailureCnt[FailCntLast];


//
//
//////////////////////////////////////////////////////////////////////

CLock g_readWriteLock;
bool g_bShuttingDown = false;
CNamespaceHandle *g_pSystemClassNamespace = NULL;
DWORD g_dwOldRepositoryVersion = 0;
DWORD g_dwCurrentRepositoryVersion = 0;
DWORD g_dwSecTlsIndex = 0xFFFFFFFF ;

DWORD    CRepository::m_ShutDownFlags = 0;
HANDLE   CRepository::m_hShutdownEvent = 0;
HANDLE   CRepository::m_hFlusherThread = 0;
LONG     CRepository::m_ulReadCount = 0;
LONG     CRepository::m_ulWriteCount = 0;
HANDLE   CRepository::m_hWriteEvent = 0;
HANDLE   CRepository::m_hReadEvent = 0;
int      CRepository::m_threadState = CRepository::ThreadStateDead;
CStaticCritSec CRepository::m_cs;
LONG     CRepository::m_threadCount = 0;
LONG     CRepository::m_nFlushFailureCount = 0;

DWORD g_FileSD[] = {
0x80040001, 0x00000000, 0x00000000, 0x00000000,
0x00000014, 0x00340002, 0x00000002, 0x00140000, 
FILE_ALL_ACCESS, 0x00000101, 0x05000000, 0x00000012, 
0x00180000, FILE_ALL_ACCESS, 0x00000201, 0x05000000, 
0x00000020, 0x00000220 
};

SECURITY_ATTRIBUTES g_SA = {sizeof(SECURITY_ATTRIBUTES),g_FileSD,FALSE};

//*****************************************************************************

HRESULT CRepository::Initialize()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    InitializeRepositoryVersions();

    //
    // Initialize time index
    //
    if (SUCCEEDED(hRes))
    {
        FILETIME ft;
        GetSystemTimeAsFileTime(&ft);

        g_nCurrentTime = ft.dwLowDateTime + ((__int64)ft.dwHighDateTime << 32);
    }

    //
    // Get the repository directory
    // sets g_Glob.GetRootDir()
    //
    if (SUCCEEDED(hRes))
        hRes = GetRepositoryDirectory();

    //Do the upgrade of the repository if necessary
    if (SUCCEEDED(hRes))
        hRes = UpgradeRepositoryFormat();
    //
    // initialze all our global resources
    //
    if (SUCCEEDED(hRes))
        hRes = InitializeGlobalVariables();

    if (SUCCEEDED(hRes))
    {
        long lRes;
        if (ERROR_SUCCESS != (lRes = g_Glob.m_FileCache.Initialize(g_Glob.GetRootDir())))
        {
            ERRORTRACE((LOG_WBEMCORE, "CFileCache::Initialize returned %x\n",lRes));
            if (WBEM_E_FAILED == (hRes = A51TranslateErrorCode(lRes)))
                hRes = WBEM_E_INITIALIZATION_FAILURE;
        }
    }

    //
    // Initialize class cache.  It will read the registry itself to find out
    // its size limitations
    //

    if (SUCCEEDED(hRes))
    {
        hRes = g_Glob.Initialize();
        if(hRes != S_OK)
        {
            hRes = WBEM_E_INITIALIZATION_FAILURE;
        }
    }
    
    //If we need to create the system class namespace then go ahead and do that...
    if (SUCCEEDED(hRes))
    {
        g_pSystemClassNamespace = new CNamespaceHandle(m_pControl, this);
        if (g_pSystemClassNamespace == NULL)
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
        }
    }

    if (SUCCEEDED(hRes))
    {
        g_pSystemClassNamespace->AddRef();
        hRes = g_pSystemClassNamespace->Initialize(A51_SYSTEMCLASS_NS);
    }

    if (SUCCEEDED(hRes))
    {
        m_hWriteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hWriteEvent == NULL)
            hRes = WBEM_E_CRITICAL_ERROR;
    }
    if (SUCCEEDED(hRes))
    {
        m_hReadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hReadEvent == NULL)
            hRes = WBEM_E_CRITICAL_ERROR;
    }
    if (SUCCEEDED(hRes))
    {
        m_hShutdownEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hShutdownEvent == NULL)
            hRes = WBEM_E_CRITICAL_ERROR;
    }

    //We need to reset the shutting down flag as the flusher thread
    //will not start without it.  The problem is that the next 2 
    //operations (CreateSystemClasses and Import security do things
    //that will re-create the thread even though we don't do it above
    //
    if (SUCCEEDED(hRes))
    {
        g_bShuttingDown = false;
    }

    if (SUCCEEDED(hRes))
    {
        CAutoWriteLock lock(&g_readWriteLock);
        if (!lock.Lock())
            hRes = WBEM_E_FAILED;
        else            
            hRes = g_pSystemClassNamespace->CreateSystemClasses(m_aSystemClasses);
    }

    if (SUCCEEDED(hRes))
    {
        // import Win9x security data if necessary
        CWin9xSecurity win9xSecurity(m_pControl, this);
        if (win9xSecurity.Win9xBlobFileExists())
            hRes = win9xSecurity.ImportWin9xSecurity();
    }

    if (SUCCEEDED(hRes))
    {
        CLocalizationUpgrade upgrade(m_pControl, this);
        hRes = upgrade.DoUpgrade();
    }

    if (FAILED(hRes))
    {
        g_bShuttingDown = true;    //Reset to true as we cleared it earlier!
        g_Glob.m_FileCache.Uninitialize(0);

        g_Glob.m_ForestCache.Deinitialize();

        if (g_pSystemClassNamespace)
        {
            delete g_pSystemClassNamespace;
            g_pSystemClassNamespace = NULL;
        }

        if (m_hWriteEvent != NULL)
        {
            CloseHandle(m_hWriteEvent);
            m_hWriteEvent = NULL;
        }
        if (m_hReadEvent != NULL)
        {
            CloseHandle(m_hReadEvent);
            m_hReadEvent = NULL;
        }
        if (m_hShutdownEvent != NULL)
        {
            CloseHandle(m_hShutdownEvent);
            m_hShutdownEvent = NULL;
        }
        HANDLE hTmp = NULL;
        if (hTmp = InterlockedCompareExchangePointer(&m_hFlusherThread,0,m_hFlusherThread))
        {
            CloseHandle(hTmp);
        }        
    }

    return hRes;
}

HRESULT CRepository::InitializeRepositoryVersions()
{
    DWORD dwVal = 0;
    CPersistentConfig cfg;
    cfg.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal);
    if (dwVal == 0)
        dwVal = A51_REP_FS_VERSION;

    g_dwOldRepositoryVersion = dwVal;
    g_dwCurrentRepositoryVersion = A51_REP_FS_VERSION;

    return WBEM_S_NO_ERROR;
}

HRESULT CRepository::UpgradeRepositoryFormat()
{
    HRESULT hRes = WBEM_E_DATABASE_VER_MISMATCH;
    CPersistentConfig cfg;
    DWORD dwVal = 0;
    cfg.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal);
    
    if (dwVal == 0)
    {
        //
        // First time --- write the right version in
        //
        hRes = WBEM_S_NO_ERROR;

        cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, 
                                    A51_REP_FS_VERSION);
    }
    else if ((dwVal > 0) && (dwVal < 5))
    {
        ERRORTRACE((LOG_WBEMCORE, "Repository cannot upgrade this version of the repository.  Version found = <%ld>, version expected = <%ld>\n", dwVal, A51_REP_FS_VERSION ));
        hRes = WBEM_E_DATABASE_VER_MISMATCH;
    }
    else if (dwVal == 5)
    {
        ERRORTRACE((LOG_WBEMCORE, "Repository does not support upgrade from version 5. We are deleting the old version and re-initializing it. Version found = <%ld>, version expected = <%ld>\n", dwVal, A51_REP_FS_VERSION ));
        //Need to delete the old repostiory
        CFileName fn;
        if (fn == NULL)
            hRes = WBEM_E_OUT_OF_MEMORY;
        else
        {
            StringCchCopyW(fn, fn.Length(), g_Glob.GetRootDir());
            StringCchCatW(fn, fn.Length(), L"\\index.btr");
            DeleteFileW(fn);
            StringCchCopyW(fn, fn.Length(), g_Glob.GetRootDir());
            StringCchCatW(fn, fn.Length(), L"\\lowstage.dat");
            DeleteFileW(fn);
            StringCchCopyW(fn, fn.Length(), g_Glob.GetRootDir());
            StringCchCatW(fn, fn.Length(), L"\\objheap.fre");
            DeleteFileW(fn);
            StringCchCopyW(fn, fn.Length(), g_Glob.GetRootDir());
            StringCchCatW(fn, fn.Length(), L"\\objheap.hea");
            DeleteFileW(fn);
            
            cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, A51_REP_FS_VERSION);
            hRes = WBEM_S_NO_ERROR;
        }
    }
    else if (dwVal == 6)
    {
        //We need to run a Locale Upgrade on the repository... but we do nothing now!
        hRes = WBEM_S_NO_ERROR;
    }
    else if (dwVal == A51_REP_FS_VERSION)
        hRes = WBEM_S_NO_ERROR;

    if (hRes == WBEM_E_DATABASE_VER_MISMATCH)
    {
        //
        // Unsupported version
        //
    
        ERRORTRACE((LOG_WBEMCORE, "Repository cannot initialize "
            "due to the detection of an unknown repository version.  Version found = <%ld>, version expected = <%ld>\n", dwVal, A51_REP_FS_VERSION ));
        return WBEM_E_DATABASE_VER_MISMATCH;
    }
    return hRes;
}


HRESULT CRepository::GetRepositoryDirectory()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    CFileName wszTmp;
    if (wszTmp == NULL)
    {
        RegCloseKey(hKey);
        return WBEM_E_OUT_OF_MEMORY;
    }
    DWORD dwLen = wszTmp.Length() * sizeof(wchar_t);
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)(wchar_t*)wszTmp, &dwLen);
    RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

    CFileName wszRepDir;
    if (wszRepDir == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if (ExpandEnvironmentStringsW(wszTmp,wszRepDir,wszTmp.Length()) == 0)
        return WBEM_E_FAILED;


    lRes = EnsureDirectory(wszRepDir);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    //
    // Append standard postfix --- that is our root
    //
    StringCchCopyW(g_Glob.GetRootDir(), MAX_PATH, wszRepDir);
    StringCchCatW(g_Glob.GetRootDir(), MAX_PATH, L"\\FS");
    g_Glob.SetRootDirLen(wcslen(g_Glob.GetRootDir()));

    //
    // Ensure the directory is there
    //

    lRes = EnsureDirectory(g_Glob.GetRootDir());
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    SetFileAttributesW(g_Glob.GetRootDir(), FILE_ATTRIBUTE_NOT_CONTENT_INDEXED);

    return WBEM_S_NO_ERROR;
}

HRESULT CRepository::InitializeGlobalVariables()
{

    return WBEM_S_NO_ERROR;
}

HRESULT DoAutoDatabaseRestore()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    //We may need to do a database restore!
    CFileName wszBackupFile;
    if (wszBackupFile == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    int nLen = g_Glob.GetRootDirLen();

    StringCchCopyNW(wszBackupFile, wszBackupFile.Length(), g_Glob.GetRootDir(), nLen - 3);   // exclude "\FS" from path
    wszBackupFile[nLen - 3] = '\0';
    StringCchCatW(wszBackupFile, wszBackupFile.Length(), L"\\repdrvfs.rec");

    DWORD dwAttributes = GetFileAttributesW(wszBackupFile);
    if (dwAttributes != -1)
    {
        DWORD dwMask =    FILE_ATTRIBUTE_DEVICE |
                        FILE_ATTRIBUTE_DIRECTORY |
                        FILE_ATTRIBUTE_OFFLINE |
                        FILE_ATTRIBUTE_REPARSE_POINT |
                        FILE_ATTRIBUTE_SPARSE_FILE;

        if (!(dwAttributes & dwMask))
        {
            CRepositoryPackager packager;
            hRes = packager.UnpackageRepository(wszBackupFile);

            //We are going to ignore the error so if there was a problem we will just
            //load all the standard MOFs.
            //WHY OH WHY WAS THIS PUT HERE?  IT BREAKS BACKUP/RESTORE FUNCTIONALIUTY BECAUSE
            //WE GET NO ERROR CODES PROPAGATED BACK!
            //if (hRes != WBEM_E_OUT_OF_MEMORY)
            //    hRes = WBEM_S_NO_ERROR;
        }
    }

    return hRes;
}



HRESULT STDMETHODCALLTYPE CRepository::Logon(
      WMIDB_LOGON_TEMPLATE *pLogonParms,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
     IWmiDbSession **ppSession,
     IWmiDbHandle **ppRootNamespace
    )
{
    //
    // Get the SecFlag TLS index from the logon parameters. Store this away in global
    // g_dwSecTlsIndex
    // 
    if ( pLogonParms == NULL )
    {
        return WBEM_E_FAILED ;
    }
    else if ( g_dwSecTlsIndex == -1 )
    {
        g_dwSecTlsIndex = (DWORD)V_I4(&pLogonParms->pParm->Value) ;
    }
    
    //If not initialized, initialize all subsystems...
    if (!g_Glob.IsInit())
    {
        HRESULT hres = Initialize();
        if (FAILED(hres))
            return hres;
    }
    
    CSession* pSession = new CSession(m_pControl);
    if (pSession == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSession->AddRef();
    CReleaseMe rm1(pSession);

    CNamespaceHandle* pHandle = new CNamespaceHandle(m_pControl, this);
    if (pHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pHandle->AddRef();
    CTemplateReleaseMe<CNamespaceHandle> rm2(pHandle);

    HRESULT hres = pHandle->Initialize(L"");
    if(FAILED(hres))
        return hres;

    *ppRootNamespace = pHandle;
    pHandle->AddRef();
    *ppSession = pSession;
    pSession->AddRef();

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetLogonTemplate(
       LCID  lLocale,
       DWORD dwFlags,
      WMIDB_LOGON_TEMPLATE **ppLogonTemplate
    )
{
    WMIDB_LOGON_TEMPLATE* lt = (WMIDB_LOGON_TEMPLATE*)CoTaskMemAlloc(sizeof(WMIDB_LOGON_TEMPLATE));
    WMIDB_LOGON_PARAMETER* lp = (WMIDB_LOGON_PARAMETER*) CoTaskMemAlloc(sizeof(WMIDB_LOGON_PARAMETER));

    if ((lt == 0) || (lp == 0))
    {
        CoTaskMemFree(lt);
        CoTaskMemFree(lp);
        return WBEM_E_OUT_OF_MEMORY;
    }

    VARIANT v ;
    VariantInit ( &v ) ;
    lp->Value = v ;

    lt->dwArraySize = 1;
    lt->pParm = lp ;

    *ppLogonTemplate = lt;
    return S_OK;
}
    

HRESULT STDMETHODCALLTYPE CRepository::FreeLogonTemplate(
     WMIDB_LOGON_TEMPLATE **ppTemplate
    )
{
    WMIDB_LOGON_TEMPLATE* pTemp = *ppTemplate ;
    WMIDB_LOGON_PARAMETER* pParam = pTemp->pParm ;
    VariantClear ( &(pParam->Value) );

    CoTaskMemFree((*ppTemplate)->pParm);
    CoTaskMemFree(*ppTemplate);
    *ppTemplate = NULL;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CRepository::Shutdown(
     DWORD dwFlags
    )
{
    g_bShuttingDown = true;     
    m_ShutDownFlags = dwFlags;

    //Trigger the flusher thread to shutdown
    SetEvent(m_hShutdownEvent);
    SetEvent(m_hWriteEvent);
    
    if (m_hFlusherThread)
        WaitForSingleObject(m_hFlusherThread, INFINITE);
    
    bool bUnlock = (CLock::NoError == g_readWriteLock.WriteLock());

    //Mark thread as dead
    m_threadState = ThreadStateDead;

    if (WMIDB_SHUTDOWN_MACHINE_DOWN != dwFlags)
    {
        if (g_pSystemClassNamespace)
            g_pSystemClassNamespace->Release();
        g_pSystemClassNamespace = NULL;

        g_Glob.m_ForestCache.Deinitialize();
    } 

    g_Glob.m_FileCache.Flush(false);

    g_Glob.m_FileCache.Uninitialize(dwFlags);


    if (WMIDB_SHUTDOWN_MACHINE_DOWN != dwFlags)
    {        
        g_Glob.Deinitialize();
        if (bUnlock)
            g_readWriteLock.WriteUnlock();
    }

    if (m_hShutdownEvent != NULL)
    {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }
    if (m_hWriteEvent != NULL)
    {
        CloseHandle(m_hWriteEvent);
        m_hWriteEvent = NULL;
    }
    if (m_hReadEvent != NULL)
    {
        CloseHandle(m_hReadEvent);
        m_hReadEvent = NULL;
    }
    HANDLE hTmp = NULL;
    if (hTmp = InterlockedCompareExchangePointer(&m_hFlusherThread,0,m_hFlusherThread))
    {
        CloseHandle(hTmp);
    }
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CRepository::SetCallTimeout(
     DWORD dwMaxTimeout
    )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::SetCacheValue(
     DWORD dwMaxBytes
    )
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);
    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxAge;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Item Age (ms)", NULL, NULL, 
                (LPBYTE)&dwMaxAge, &dwLen);

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxAge = 10000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Item Age (ms)", 0, 
                REG_DWORD, (LPBYTE)&dwMaxAge, sizeof(DWORD));
    }
    g_Glob.m_ForestCache.SetMaxMemory(dwMaxBytes, dwMaxAge);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::FlushCache(
     DWORD dwFlags
    )

{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetStatistics(
      DWORD  dwParameter,
     DWORD *pdwValue
    )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetRepositoryVersions(DWORD *pdwOldVersion, 
                                                             DWORD *pdwCurrentVersion)
{
    *pdwOldVersion = g_dwOldRepositoryVersion;
    *pdwCurrentVersion = g_dwCurrentRepositoryVersion;
    return S_OK;
}

HRESULT CRepository::GetNamespaceHandle(LPCWSTR wszNamespaceName,
                                    RELEASE_ME CNamespaceHandle** ppHandle)
{
    HRESULT hres;

    //
    // No validation --- that would be too hard.  Just create a handle and
    // return
    //

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl, this);
    if (pNewHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pNewHandle->AddRef();
    CReleaseMe rm1(pNewHandle);

    hres = pNewHandle->Initialize(wszNamespaceName);
    if(FAILED(hres)) 
        return hres;

    *ppHandle = pNewHandle;
    pNewHandle->AddRef();
    return S_OK;
}

HRESULT CRepository::Backup(LPCWSTR wszBackupFile, long lFlags)
{
    TIMETRACEBACKUP;
    HRESULT hRes = WBEM_S_NO_ERROR;

    // params have already been verified by the calling method (CWbemBackupRestore::DoBackup),
    // but do it again just in case things change and this is no longer the case
    if (NULL == wszBackupFile || (lFlags != 0))
        return WBEM_E_INVALID_PARAMETER;

    if (FAILED(hRes = LockRepository()))
        return hRes;
    
    CRepositoryPackager packager;
    hRes = packager.PackageRepository(wszBackupFile);

    UnlockRepository();

    return hRes;
}
HRESULT CRepository::Restore(LPCWSTR wszBackupFile, long lFlags)
{
    return WBEM_E_NOT_SUPPORTED;
}


#define MaxTraceSizeBackup  (11)

struct BackUpTraces {
    DWORD ThreadId;    
    PVOID  Trace[MaxTraceSizeBackup];
} g_Backup[2];

LONG g_NumTimes;

HRESULT CRepository::LockRepository()
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
    //Lock the database so no one writes to it
    if (CLock::NoError != g_readWriteLock.WriteLock())
        return WBEM_E_FAILED;

    ScopeGuard lockGuard = MakeObjGuard(g_readWriteLock, &CLock::WriteUnlock);

    if (g_bShuttingDown)
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    InterlockedIncrement(&g_NumTimes);
    g_Backup[0].ThreadId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSizeBackup,g_Backup[0].Trace,&Hash);
    g_Backup[1].ThreadId = 0;    

    //We need to wait for the transaction manager write to flush...
    long lRes = g_Glob.m_FileCache.Flush(false);
    if (lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }

    if (CLock::NoError != g_readWriteLock.DowngradeLock())
        return WBEM_E_FAILED;

    lockGuard.Dismiss();
    return WBEM_S_NO_ERROR;
}

HRESULT CRepository::UnlockRepository()
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
    g_readWriteLock.ReadUnlock();

    InterlockedDecrement(&g_NumTimes);
    g_Backup[1].ThreadId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSizeBackup,g_Backup[1].Trace,&Hash);
    g_Backup[0].ThreadId = 0;    

    return WBEM_S_NO_ERROR;
}

DWORD WINAPI CRepository::_FlusherThread(void *)
{
//    ERRORTRACE((LOG_REPDRV, "Flusher thread stated, thread = %lu\n", GetCurrentThreadId()));
    InterlockedIncrement(&m_threadCount);

    HANDLE aHandles[2];
    aHandles[0] = m_hWriteEvent;
    aHandles[1] = m_hReadEvent;

    DWORD dwTimeout = INFINITE;
    LONG ulPreviousReadCount = m_ulReadCount;
    LONG ulPreviousWriteCount = m_ulWriteCount;
    bool bShutdownThread = false;

    while (!g_bShuttingDown && !bShutdownThread)
    {
        DWORD dwRet = WaitForMultipleObjects(2, aHandles, FALSE, dwTimeout);

        switch(dwRet)
        {
        case WAIT_OBJECT_0:    //Write event
        {
            dwRet = WaitForSingleObject(m_hShutdownEvent, A51_WRITE_CHECKPOINT);
            switch (dwRet)
            {
            case WAIT_OBJECT_0:
                break;    //Shutting down, we cannot grab the lock so let the
                        //initiator of shutdown do the flush for us
            case WAIT_TIMEOUT:
            {
                //We need to do a flush... either shutting down or idle
                CAutoWriteLock lock(&g_readWriteLock);
                if (lock.Lock())
                {
                       long lResInner;
                    if (NO_ERROR != (lResInner = g_Glob.m_FileCache.Flush(true)))
                    {
                        //Flush failed, so we need to retry in a little while!
                        SetEvent(m_hWriteEvent);
                        m_nFlushFailureCount++;
                    }
                    else
                        m_nFlushFailureCount = 0;
                }
                break;
            }
            case WAIT_FAILED:
                break;
            }

            //Transition to flush mode
            dwTimeout = A51REP_CACHE_FLUSH_TIMEOUT;
            ulPreviousReadCount = m_ulReadCount;
            m_threadState = ThreadStateFlush;
            break;
        }

        case WAIT_OBJECT_0+1:    //Read event
            //Reset the flush mode as read happened
            dwTimeout = A51REP_CACHE_FLUSH_TIMEOUT;
            ulPreviousReadCount = m_ulReadCount;
            m_threadState = ThreadStateFlush;
            break;

        case WAIT_TIMEOUT:    //Timeout, so flush caches
        {
            //Check for if we are in an idle shutdown state...
            m_cs.Enter();
            if (m_threadState == ThreadStateIdle)
            {
                m_threadState = ThreadStateDead;
                bShutdownThread = true;
                // since we are setting the status to "dead", decrement also the thread counter
                InterlockedDecrement(&m_threadCount);
            }
            m_cs.Leave();
            
            if (bShutdownThread)
                break;

            //Not thread shutdown, so we check for cache flush
            if (ulPreviousReadCount == m_ulReadCount)
            {
                //Mark the idle for the next phase so if another
                //request comes in while we are doing this we will
                //be brought out of the idle state...
                dwTimeout = A51REP_THREAD_IDLE_TIMEOUT;
                m_threadState = ThreadStateIdle;
                m_ulReadCount = 0;

                CAutoWriteLock lock(&g_readWriteLock);
                if (lock.Lock())
                {
                    //Compact the database again!
                       long lResInner;                    
                    if ( NO_ERROR != (lResInner= g_Glob.m_FileCache.Flush(true)))
                    {
                        //Flush failed, so we need to make sure it happens again
                        SetEvent(m_hWriteEvent);
                        break;
                    }

                    //Flush the caches
                    g_Glob.m_ForestCache.Clear();
                    g_Glob.m_FileCache.EmptyCaches();
                }
            }
            else
            {
                //We need to sleep for some more as some more reads happened
                ulPreviousReadCount = m_ulReadCount;
                dwTimeout = A51REP_CACHE_FLUSH_TIMEOUT;
            }
            break;
        }
        }
    }

    if (g_bShuttingDown && !bShutdownThread)
        InterlockedDecrement(&m_threadCount);

    return 0;
}

HRESULT CRepository::ReadOperationNotification()
{
//    ERRORTRACE((LOG_REPDRV, "Read Operation logged\n"));
    //Check to make sure the thread is active, if not we need to activate it!
    HRESULT hRes = WBEM_S_NO_ERROR;
    m_cs.Enter();
    if (m_threadState == ThreadStateDead)
    {
        m_threadState = ThreadStateOperationPending;
        HANDLE hTmp = NULL;
        if (hTmp = InterlockedCompareExchangePointer(&m_hFlusherThread,0,m_hFlusherThread))
        {
            CloseHandle(hTmp);
        }
        m_hFlusherThread = CreateThread(NULL, 0, _FlusherThread, 0, 0, NULL);
    }
    if (m_hFlusherThread != NULL)
        m_threadState = ThreadStateOperationPending;
    else
        hRes = WBEM_E_FAILED;
    m_cs.Leave();
    if ((m_hFlusherThread != NULL) &&(InterlockedIncrement(&m_ulReadCount) == 1))
        SetEvent(m_hReadEvent);
    return hRes;
}
HRESULT CRepository::WriteOperationNotification()
{
//    ERRORTRACE((LOG_REPDRV, "Write Operation logged\n"));
    //Check to make sure the thread is active, if not we need to activate it!
    HRESULT hRes = WBEM_S_NO_ERROR;
    m_cs.Enter();
    if (m_threadState == ThreadStateDead)
    {
        m_threadState = ThreadStateOperationPending;
        HANDLE hTmp = NULL;
        if (hTmp = InterlockedCompareExchangePointer(&m_hFlusherThread,0,m_hFlusherThread))
        {
            CloseHandle(hTmp);
        }        
        m_hFlusherThread = CreateThread(NULL, 0, _FlusherThread, 0, 0, NULL);
    }
    if (m_hFlusherThread != NULL)
        m_threadState = ThreadStateOperationPending;
    else
        hRes = WBEM_E_FAILED;
    m_cs.Leave();
    SetEvent(m_hWriteEvent);
    return hRes;
}


#ifdef DBG
class CErrorRecover
{
private:
    enum  { ErrorsMax = 1024};
    long Errors_[ErrorsMax];
    long Index_;
public:    
    CErrorRecover():Index_(-1){};
    void AddError(long lRes)
    {
        Errors_[InterlockedIncrement(&Index_)%ErrorsMax] = lRes;
    };
} g_ErrorRecover;
#endif



//
//
//
//
//////////////////////////////////////////////////////////////////////

CGlobals g_Glob;


HRESULT
CGlobals::Initialize()
{
    CInCritSec ics(&m_cs);
    
    if (m_bInit)
        return S_OK;

    HRESULT hRes;        

    hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL,
               CLSCTX_INPROC_SERVER, IID__IWmiCoreServices,
                (void**)&m_pCoreServices);
                
    if (SUCCEEDED(hRes))
    {
        hRes = m_ForestCache.Initialize();
        if (SUCCEEDED(hRes))
        {
            DWORD dwSize = sizeof(m_ComputerName)/sizeof(m_ComputerName[0]);
            ::GetComputerNameW(m_ComputerName, &dwSize);
            m_bInit = TRUE;
        }
        else
        {
            m_pCoreServices->Release();
            m_pCoreServices = NULL;
        }
    }
    
    return hRes;
}


HRESULT
CGlobals::Deinitialize()
{
    CInCritSec ics(&m_cs);
    
    if (!m_bInit)
        return S_OK;

    HRESULT hRes;

    m_pCoreServices->Release();
    m_pCoreServices = NULL;

    hRes = m_ForestCache.Deinitialize();

    m_bInit = FALSE;
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\btr.h ===
//***************************************************************************
//
//  (c) 2000 Microsoft Corp.  All Rights Reserved.
//
//  BTR.H
//
//  Repository B-tree classes
//
//  raymcc  15-Oct-00       First version
//
//***************************************************************************

#ifndef _BTR_H_
#define _BTR_H_

#define A51_INDEX_FILE_ID 2
class CPageFile;
class CPageSource;

LPVOID WINAPI _BtrMemAlloc(
    SIZE_T dwBytes  // number of bytes to allocate
    );

LPVOID WINAPI _BtrMemReAlloc(
    LPVOID pOriginal,
    DWORD dwNewBytes
    );

BOOL WINAPI _BtrMemFree(LPVOID pMem);

#define ReleaseIfNotNULL(p) if(p) p->Release()

class CBTreeFile
{
    DWORD  m_dwPageSize;

    DWORD  m_dwLogicalRoot;

    CPageFile* m_pFile;
	CPageSource *m_pTransactionManager;

    // Methods
    DWORD Setup();
    DWORD WriteAdminPage();

public:
    CBTreeFile();
   ~CBTreeFile();

    enum { const_DefaultPageSize = 0x2000, const_CurrentVersion = 0x101 };

    enum {
        PAGE_TYPE_IMPOSSIBLE = 0x0,       // Not supposed to happen
        PAGE_TYPE_ACTIVE = 0xACCC,        // Page is active with data
        PAGE_TYPE_DELETED = 0xBADD,       // A deleted page on free list
        PAGE_TYPE_ADMIN = 0xADDD,         // Page zero only

        // All pages
        OFFSET_PAGE_TYPE = 0,             // True for all pages
        OFFSET_PAGE_ID = 1,               // True for all pages
        OFFSET_NEXT_PAGE = 2,             // True for all pages (Page continuator)

        // Admin Page (page zero) only
        OFFSET_LOGICAL_ROOT = 3,          // Root of database
        };


    DWORD Init(
        DWORD dwPageSize,        // 8k default
        LPWSTR pszFilename, 
		CPageSource* pSource
        );

    DWORD Shutdown(DWORD dwShutDownFlags);

    DWORD GetPage(DWORD dwId, LPVOID *pPage);
    DWORD PutPage(LPVOID pPage, DWORD dwType);
    DWORD NewPage(LPVOID *pPage);
    DWORD FreePage(LPVOID pPage);
    DWORD FreePage(DWORD dwId);

    DWORD GetPageSize() { return m_dwPageSize; }

    DWORD SetRootPage(DWORD dwID);
    DWORD GetRootPage() { return m_dwLogicalRoot; }
    DWORD ReadAdminPage();

    void  Dump(FILE *);
};

struct SIdxStringPool
{
    DWORD  m_dwNumStrings;          // Number of strings in pool
    WORD  *m_pwOffsets;             // Offsets into pool of strings
    DWORD  m_dwOffsetsSize;         // Number of elements in above array

    LPSTR  m_pStringPool;           // Pointer to string pool
    DWORD  m_dwPoolTotalSize;       // Total size, used+unused
    DWORD  m_dwPoolUsed;            // Offset of first free position

public:
    enum { const_DefaultPoolSize = 0x2200 };

    SIdxStringPool() { memset(this, 0, sizeof(SIdxStringPool)); }
   ~SIdxStringPool();

    DWORD  AddStr(LPSTR pszStr, WORD wInsertPos, int *pnAdjuster);
    DWORD  DeleteStr(WORD wAssignedOffset, int *pnAdjuster);

    DWORD  GetLastId() { return m_dwNumStrings; }

    DWORD FindStr(
        IN  LPSTR pszSearchKey,
        OUT WORD *pwStringNumber,
        OUT WORD *pwPoolOffset
        );

    DWORD  GetNumStrings() { return m_dwNumStrings; }
    DWORD  GetRequiredPageMemory()
        {
        return m_dwPoolUsed + (m_dwNumStrings * sizeof(WORD)) +
        sizeof(m_dwNumStrings) + sizeof(m_dwPoolUsed);
        }

    DWORD  Dump(FILE *f);

    LPSTR  GetStrById(WORD id) { return m_pStringPool+m_pwOffsets[id]; }
    void   Empty() { m_dwNumStrings = 0; m_dwPoolUsed = 0; }
    DWORD  Clone(SIdxStringPool **);
};

class SIdxKeyTable
{
    DWORD m_dwRefCount;                // Ref count

    DWORD m_dwPageId;                  // Page number
    DWORD m_dwParentPageId;            // Parent page id  <For DEBUGGING only>
    DWORD m_dwNumKeys;                 // Num keys
    WORD *m_pwKeyLookup;               // Offset of key into key-encoding-table
    DWORD m_dwKeyLookupTotalSize;      // Elements in array
    DWORD *m_pdwUserData;              // User DWORD with each key
    DWORD *m_pdwChildPageMap;          // Child page pointers n=left ptr, n+1=right pointer

    WORD *m_pwKeyCodes;                // Key encoding table
    DWORD m_dwKeyCodesTotalSize;       // Total elements in array
    DWORD m_dwKeyCodesUsed;            // Elements used
    SIdxStringPool *m_pStrPool;        // The pool associated with this key table

    // Methods

    SIdxKeyTable();
   ~SIdxKeyTable();

public:
    enum { const_DefaultArray = 256,
           const_DefaultKeyCodeArray = 512
         };

    static DWORD Create(DWORD dwPageId, SIdxKeyTable **pNew);
    static DWORD Create(LPVOID pPage, SIdxKeyTable **pNew);

    DWORD AddRef();
    DWORD Release();

    DWORD AddKey(LPSTR pszStr, WORD ID, DWORD dwUserData);
    DWORD RemoveKey(WORD wID);
    DWORD FindKey(LPSTR pszStr, WORD *pID);
    DWORD GetUserData(WORD wID) { return m_pdwUserData[wID]; }

    void  SetChildPage(WORD wID, DWORD dwPage) { m_pdwChildPageMap[wID] = dwPage; }
    DWORD GetChildPage(WORD wID) { return m_pdwChildPageMap[wID]; }
    DWORD GetLastChildPage() { return m_pdwChildPageMap[m_dwNumKeys]; }
    DWORD GetLeftSiblingOf(DWORD dwId);
    DWORD GetRightSiblingOf(DWORD dwId);
    DWORD GetKeyAt(WORD wID, LPSTR *pszKey);    // Use _MemFree
    DWORD GetNumKeys() { return m_dwNumKeys; }
    void  SetStringPool(SIdxStringPool *pPool) { m_pStrPool = pPool; }
    void  FreeMem(LPVOID pMem);

    void AdjustKeyCodes(
        WORD wID,
        int nAdjustment
        );

    int KeyStrCompare(
        LPSTR pszSearchKey,
        WORD wID
        );

    DWORD Cleanup();

    DWORD NumKeys() { return m_dwNumKeys; }
    DWORD GetRequiredPageMemory();
    DWORD Dump(FILE *, DWORD *pdwKeys = 0);
    void  ZapPage();
    DWORD GetPageId() { return m_dwPageId; }

    // Sibling/Parent page helpers

    DWORD GetKeyOverhead(WORD wID); // Returns total bytes required by new key

    BOOL IsLeaf() { return m_pdwChildPageMap[0] == 0; }
    DWORD Redist(
        SIdxKeyTable *pParent,
        SIdxKeyTable *pNewSibling
        );

    DWORD Collapse(
        SIdxKeyTable *pParent,
        SIdxKeyTable *pDoomedSibling
        );

    DWORD StealKeyFromSibling(
        SIdxKeyTable *pParent,
        SIdxKeyTable *pSibling
        );

    DWORD MapFromPage(LPVOID pSrc);
    DWORD MapToPage(LPVOID pMem);

    DWORD Clone(OUT SIdxKeyTable **pCopy);
};

class CBTree;


class CBTreeIterator
{
    friend class CBTree;
    enum {
        const_MaxStack = 1024,
        const_PrefetchSize = 64
        };

    CBTree       *m_pTree;
    SIdxKeyTable *m_Stack[const_MaxStack];
    WORD          m_wStack[const_MaxStack];
    LONG          m_lStackPointer;

    LPSTR        *m_pPrefetchKeys[const_PrefetchSize];
    DWORD         m_dwPrefetchData[const_PrefetchSize];
    DWORD         m_dwPrefetchActive;

   ~CBTreeIterator();

    // Stack helpers
    SIdxKeyTable *Peek() { return m_Stack[m_lStackPointer]; }
    WORD PeekId() { return m_wStack[m_lStackPointer]; }
    void IncStackId() { m_wStack[m_lStackPointer]++; }

    void Pop() {  ReleaseIfNotNULL(m_Stack[m_lStackPointer]); m_lStackPointer--; }
    BOOL StackFull() { return m_lStackPointer == const_MaxStack - 1; }
    void Push(SIdxKeyTable *p, WORD wId) { m_Stack[++m_lStackPointer] = p; m_wStack[m_lStackPointer] = wId; }

    DWORD ZapStack();
    DWORD PurgeKey(LPSTR pszDoomedKey);
    DWORD RebuildStack(LPSTR pszStartKey);
    DWORD ExecPrefetch();

    static DWORD ZapAllStacks();
    static DWORD GlobalPurgeKey(LPSTR pszDoomedKey);

public:

    CBTreeIterator() { m_pTree = 0; m_lStackPointer = -1; }

    DWORD Init(CBTree *pRoot, LPSTR pszStartKey = 0);  // If last parm is null, iterate through all
    DWORD Next(LPSTR *ppszStr, DWORD *pdwData = 0);
    void  FreeString(LPSTR pszStr) { _BtrMemFree(pszStr); }
    DWORD Release();
};

class CBTree
{
    enum { const_DefaultArray = 256 };
    enum { const_MinimumLoad = 33 };

    CBTreeFile *m_pSrc;
    SIdxKeyTable *m_pRoot;
    friend class CBTreeIterator;

    LONG m_lGeneration;

    // private methods

    DWORD ReplaceBySuccessor(
        IN SIdxKeyTable *pIdx,
        IN WORD wId,
        OUT LPSTR *pszSuccessorKey,
        OUT BOOL *pbUnderflowDetected,
        DWORD Stack[],
        LONG &StackPtr
        );

    DWORD FindSuccessorNode(
        IN SIdxKeyTable *pIdx,
        IN WORD wId,
        OUT SIdxKeyTable **pSuccessor,
        OUT DWORD *pdwPredecessorChild,
        DWORD Stack[],
        LONG &StackPtr
        );

    DWORD ReadIdxPage(
        DWORD dwPage,
        SIdxKeyTable **pIdx
        );

    DWORD WriteIdxPage(
        SIdxKeyTable *pIdx
        );

    DWORD ComputeLoad(
        SIdxKeyTable *pKT
        );

    DWORD InsertPhase2(
        SIdxKeyTable *pCurrent,
        WORD wID,
        LPSTR pszKey,
        DWORD dwValue,
        DWORD Stack[],
        LONG &StackPtr
        );

    DWORD Search(
        IN  LPSTR pszKey,
        OUT SIdxKeyTable **pRetIdx,
        OUT WORD *pwID,
        DWORD Stack[],
        LONG &StackPtr
        );

public:
    CBTree();
   ~CBTree();

    DWORD Init(CBTreeFile *pSrc);
    DWORD Shutdown(DWORD dwShutDownFlags);

    DWORD InsertKey(
        IN LPSTR pszKey,
        DWORD dwValue
        );

    DWORD FindKey(
        IN LPSTR pszKey,
        DWORD *pdwData
        );

    DWORD DeleteKey(
        IN LPSTR pszKey
        );

    DWORD BeginEnum(
        LPSTR pszStartKey,
        OUT CBTreeIterator **pIterator
        );

    void Dump(FILE *fp);

    DWORD InvalidateCache();

	DWORD FlushCaches();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\filecach.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <wbemcomn.h>
#include <reposit.h>
#include "filecach.h"
#include "creposit.h"

long CFileCache::InnerInitialize(LPCWSTR wszBaseName)
{
    long lRes;

    StringCchCopyW(m_wszBaseName, MAX_PATH+1, wszBaseName);
    StringCchCatW(m_wszBaseName, MAX_PATH+1, L"\\");
    m_dwBaseNameLen = wcslen(m_wszBaseName);

    lRes = m_TransactionManager.Init();
    if(lRes != ERROR_SUCCESS)
        return lRes;

	lRes = m_TransactionManager.BeginTrans();
	if (lRes != ERROR_SUCCESS)
	{
		Clear(0);
		return lRes;
	}
    lRes = m_ObjectHeap.Initialize(&m_TransactionManager, 
                                   (WCHAR*)wszBaseName,
                                   m_dwBaseNameLen);
    if(lRes != ERROR_SUCCESS)
	{
		m_TransactionManager.RollbackTrans();
		Clear(0);
	}
	else
	{
		lRes = m_TransactionManager.CommitTrans();
		if (lRes != ERROR_SUCCESS)
		{
			m_TransactionManager.RollbackTrans();

			Clear(0);
		}
	}


    return lRes;
}

long CFileCache::RepositoryExists(LPCWSTR wszBaseName)
{
    CFileName wszStagingName;
	if (wszStagingName == NULL)
		return ERROR_OUTOFMEMORY;

    StringCchPrintfW(wszStagingName, wszStagingName.Length(), L"%s\\index.btr", wszBaseName);

    DWORD dwAttributes = GetFileAttributesW(wszStagingName);
    if (dwAttributes == -1)
        return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}

long CFileCache::Initialize(LPCWSTR wszBaseName)
{
	long lRes;

	if (m_bInit)
	    return ERROR_SUCCESS;

    lRes = RepositoryExists(wszBaseName);
	if (ERROR_FILE_NOT_FOUND == lRes)
	{
		//If we have a database restore to do, go ahead and do it...
		lRes = DoAutoDatabaseRestore();
	}
	
    //
    // Initialize file cache.  It will read the registry itself to find out
    // its size limitations
    //
	if (SUCCEEDED(lRes))
	{
		lRes = InnerInitialize(wszBaseName);
		if (ERROR_SUCCESS == lRes)
		{
		    m_bInit = TRUE;
		}
	}

	return lRes;
}

CFileCache::CFileCache()
: m_lRef(1), m_bInit(FALSE)
{
}

CFileCache::~CFileCache()
{
}

long CFileCache::Uninitialize(DWORD dwShutDownFlags)
{
    if (!m_bInit)
        return 0;

    Clear(dwShutDownFlags);

    m_bInit = FALSE;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\a51tools.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51_TOOLS__H_
#define __A51_TOOLS__H_

#include <sync.h>
#include <newnew.h>
#include <xmemory>

typedef LONGLONG TFileOffset;

#define MAX_HASH_LEN 32

void* TempAlloc(DWORD dwLen);
void TempFree(void* p, DWORD dwLen = 0);

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen);
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen = 0);

HRESULT A51TranslateErrorCode(long lRes);

#define TEMPFREE_ME

class CTempFreeMe
{
protected:
    void* m_p;
    DWORD m_dwLen;
public:
    CTempFreeMe(void* p, DWORD dwLen = 0) : m_p(p), m_dwLen(dwLen){}
    ~CTempFreeMe() {TempFree(m_p, m_dwLen);}
};


inline void wbem_wcsupr(WCHAR* pwcTo, const WCHAR* pwcFrom)
{
    while(*pwcFrom)
    {
        if(*pwcFrom >= 'a' && *pwcFrom <= 'z')
            *pwcTo = *pwcFrom + ('A'-'a');
        else if(*pwcFrom < 128)
            *pwcTo = *pwcFrom;
        else 
            *pwcTo = wbem_towupper(*pwcFrom);
        pwcTo++;
        pwcFrom++;
    }
    *pwcTo = 0;
}

class CFileName
{
private:
	wchar_t *m_wszFilename;

public:
	DWORD Length() { return MAX_PATH + 1; }
	CFileName() { m_wszFilename = (wchar_t*)TempAlloc(sizeof(wchar_t) * Length()); }
	~CFileName() { TempFree(m_wszFilename, sizeof(wchar_t) * Length()); }
	operator wchar_t *() { return m_wszFilename; }
};

long EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA = NULL);
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash);
extern __int64 g_nCurrentTime;

template<class T>
class CTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    char* _Charalloc(size_t n)
    {
        return (char*)TempAlloc(n);
    }

    void deallocate(void* p, size_t n)
    {
        TempFree(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
};

template<class T>
class CPrivateTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    CPrivateTempAllocator(CTempMemoryManager* pManager) 
        : m_pManager(pManager)
    {}
    
    char* _Charalloc(size_t n)
    {
        return (char*)m_pManager->Allocate(n);
    }

    void deallocate(void* p, size_t n)
    {
        m_pManager->Free(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
protected:
    CTempMemoryManager* m_pManager;
};
            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\filecach.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_FILECACHE_H_
#define __WMI_A51_FILECACHE_H_

#include <set>

extern bool g_bShuttingDown;


#include "pagemgr.h"
#include "a51tools.h"
#include "objheap.h"
#include "index.h"

class CFileCache
{
protected:
    long m_lRef;
    BOOL m_bInit;

    CPageSource m_TransactionManager;
    
    CObjectHeap m_ObjectHeap;
    
    DWORD m_dwBaseNameLen;
    WCHAR m_wszBaseName[MAX_PATH+1]; // be debugger friendly, live it last

public:

protected:

public:
    CFileCache();
    ~CFileCache();
private:    
    void Clear(DWORD dwShutDownFlags)
	{    
		m_ObjectHeap.Uninitialize(dwShutDownFlags);
		m_TransactionManager.Shutdown(dwShutDownFlags);
	}

public:    
	long Flush(bool bCompactPages)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_TransactionManager.Checkpoint(bCompactPages);
	}

    long Initialize(LPCWSTR wszBaseName);
    long Uninitialize(DWORD dwShutDownFlags);
    
private:    
    long InnerInitialize(LPCWSTR wszBaseName);    
    long RepositoryExists(LPCWSTR wszBaseName);
public:   
	//Write 1 or 2 indexes pointing to the object in the object store
	long WriteObject(LPCWSTR wszFileName1, LPCWSTR wszFileName2, DWORD dwLen, BYTE* pBuffer)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.WriteObject(wszFileName1, wszFileName2, dwLen, pBuffer);
	}

	//Writes a link and no object
	long WriteLink(LPCWSTR wszLinkName)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.WriteLink(wszLinkName);
	}
    
	//Retrieve a buffer based on the index
	HRESULT ReadObject(LPCWSTR wszFileName, DWORD* pdwLen, BYTE** ppBuffer, bool bMustBeThere = false)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ReadObject(wszFileName, pdwLen, ppBuffer);
	}

	//Deletion of an object deletes the link also
	long DeleteObject(LPCWSTR wszFileName)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.DeleteObject(wszFileName);
	}
	//Deletion of a link does not touch the object heap
	long DeleteLink(LPCWSTR wszLinkName)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.DeleteLink(wszLinkName);
	}

	//Deletes an entire node from the BTree and all associated objects from that store
	long DeleteNode(LPCWSTR wszNodeName)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.DeleteNode(wszNodeName);
	}

	long BeginTransaction()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_TransactionManager.BeginTrans();
	}
	long CommitTransaction()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_TransactionManager.CommitTrans();
	}
	long AbortTransaction()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		long lRes = m_TransactionManager.RollbackTrans();
		if(lRes != ERROR_SUCCESS) return lRes;
		m_ObjectHeap.InvalidateCache();
		return ERROR_SUCCESS;
	}

    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release() {long lRet = InterlockedDecrement(&m_lRef); if (!lRet) delete this;return lRet;}

	//Object enumeration methods that allow us to enumerate a set of objects and the
	//result is the heap object itself rather than just the path
	long ObjectEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ObjectEnumerationBegin(wszSearchPrefix, ppHandle);
	}

	long ObjectEnumerationEnd(void *pHandle)
	{
		if (!m_bInit)return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ObjectEnumerationEnd(pHandle);
	}
	long ObjectEnumerationNext(void *pHandle, CFileName &wszFileName, BYTE **ppBlob, DWORD *pdwSize)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ObjectEnumerationNext(pHandle, wszFileName, ppBlob, pdwSize);
	}
	long ObjectEnumerationFree(void *pHandle, BYTE *pBlob)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ObjectEnumerationFree(pHandle, pBlob);
	}

	//Index enumeration methods for iterating through the index
	long IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.IndexEnumerationBegin(wszSearchPrefix, ppHandle);
	}
	long IndexEnumerationEnd(void *pHandle)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.IndexEnumerationEnd(pHandle);
	}
	long IndexEnumerationNext(void *pHandle, CFileName &wszFileName, bool bCopyFullPath = false)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.IndexEnumerationNext(pHandle, wszFileName, bCopyFullPath);
	}
	long EmptyCaches()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		long lRes = m_TransactionManager.EmptyCaches();
		if (lRes == 0)
			lRes = m_ObjectHeap.FlushCaches();

		return lRes;
	}
	long ReadNextIndex(CFileName &wszSearch, CFileName &wszNextIndex)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ReadNextIndex(wszSearch, wszNextIndex);
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\hiecache.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <wbemcomn.h>
#include "hiecache.h"
#include <creposit.h>
#include <malloc.h>
#include <corex.h>

extern bool g_bShuttingDown;

long CHierarchyCache::s_nCaches = 0;

long CClassRecord::s_nRecords = 0;

//
//
//  CClassRecord::CClassRecord
//
////////////////////////////////////////////////////////////////////

CClassRecord::CClassRecord(LPCWSTR wszClassName, LPCWSTR wszHash)
    : m_wszClassName(NULL), m_pClassDef(NULL), m_pParent(NULL), 
        m_eIsKeyed(e_KeynessUnknown), m_bTreeComplete(false), 
        m_bChildrenComplete(false),
        m_lLastChildInvalidationIndex(-1), m_pMoreRecentlyUsed(NULL),
        m_pLessRecentlyUsed(NULL), m_lRef(0), m_nStatus(0), m_bSystemClass(false)
{
	size_t dwLen = wcslen(wszClassName)+1;
    m_wszClassName = new WCHAR[dwLen];
	if (m_wszClassName == NULL)
		throw CX_MemoryException();
    StringCchCopyW(m_wszClassName, dwLen, wszClassName);

    StringCchCopyW(m_wszHash, MAX_HASH_LEN+1, wszHash);

    m_dwLastUsed = GetTickCount();
	s_nRecords++;
}

CClassRecord::~CClassRecord()
{
    delete [] m_wszClassName;
    if(m_pClassDef)
	{
		if(m_pClassDef->Release() != 0)
		{
			s_nRecords++;
			s_nRecords--;
		}
    }
	s_nRecords--;
}

HRESULT CClassRecord::EnsureChild(CClassRecord* pChild)
{
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        if(m_apChildren[i] == pChild)
            return WBEM_S_FALSE;
    }
    
    if(m_apChildren.Add(pChild) < 0)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}

HRESULT CClassRecord::RemoveChild(CClassRecord* pChild)
{
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        if(m_apChildren[i] == pChild)
        {
            m_apChildren.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }
    
    return WBEM_E_NOT_FOUND;
}
        
//
//
//    CHierarchyCache::CHierarchyCache
//
/////////////////////////////////////////////////////////////////////
    
CHierarchyCache::CHierarchyCache(CForestCache* pForest)
    : m_pForest(pForest), m_lNextInvalidationIndex(0), m_lRef(0),
        m_hresError(S_OK)
{
	s_nCaches++;
}

CHierarchyCache::~CHierarchyCache()
{
    Clear();
	s_nCaches--;
}

void CHierarchyCache::Clear()
{
    CInCritSec ics(m_pForest->GetLock());
    
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        CClassRecord* pRecord = it->second;
        m_pForest->RemoveRecord(pRecord);
        it = m_map.erase(it);
        pRecord->Release();
    }
}

void CHierarchyCache::SetError(HRESULT hresError)
{
    m_hresError = hresError;
}

HRESULT CHierarchyCache::GetError()
{
    return m_hresError;
}
bool CHierarchyCache::MakeKey(LPCWSTR wszClassName, LPWSTR wszKey)
{
    // wbem_wcsupr(wszKey, wszClassName);
    return A51Hash(wszClassName, wszKey);
}

INTERNAL CClassRecord* CHierarchyCache::FindClass(LPCWSTR wszClassName)
{
    CInCritSec ics(m_pForest->GetLock());    

    LPWSTR wszKey = (WCHAR*)TempAlloc((MAX_HASH_LEN+2) * sizeof(WCHAR));
	if (wszKey == NULL)
		return NULL;
	CTempFreeMe tfm(wszKey, (MAX_HASH_LEN+2) * sizeof(WCHAR));
    if (!MakeKey(wszClassName, wszKey))
	return 0;

    return FindClassByKey(wszKey);
}

INTERNAL CClassRecord* CHierarchyCache::FindClassByKey(LPCWSTR wszKey)
{
    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
        return NULL;

    return it->second;
}

INTERNAL CClassRecord* CHierarchyCache::EnsureClass(LPCWSTR wszClassName)
{
    CInCritSec ics(m_pForest->GetLock());

    LPWSTR wszKey = (WCHAR*)TempAlloc((MAX_HASH_LEN+2) * sizeof(WCHAR));
	if (wszKey == NULL)
		return NULL;
	CTempFreeMe tfm(wszKey, (MAX_HASH_LEN+2) * sizeof(WCHAR));
    if (!MakeKey(wszClassName, wszKey))
		return 0;

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        //
        // Create a new record with the name
        //

		try
		{
			CClassRecord* pRecord = new CClassRecord(wszClassName, wszKey);
			if(pRecord == NULL)
				return NULL;

		    pRecord->AddRef(); // one for the map			
    		m_map[pRecord->m_wszHash] = pRecord;			

			return pRecord;
		}
		catch (CX_MemoryException)
		{
			return NULL;
		}
    }
    else
    {
        return it->second;
    }
}


HRESULT CHierarchyCache::AssertClass(_IWmiObject* pClass, LPCWSTR wszClassName,
                                    bool bClone, __int64 nTime, bool bSystemClass)
{
     CInCritSec ics(m_pForest->GetLock());
 
    HRESULT hres;

    m_pForest->MarkAsserted(this, wszClassName);

    //
    // If no record is given, find one
    //

    CClassRecord* pRecord = NULL;

    if(wszClassName == NULL)
    {
        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);

        hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_CLASS;

        pRecord = EnsureClass(V_BSTR(&v));
    }
    else
        pRecord = EnsureClass(wszClassName);

    if(pRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Figure out the parent
    //

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);

    if(SUCCEEDED(hres))
    {
        if(V_VT(&v) == VT_BSTR)
            pRecord->m_pParent = EnsureClass(V_BSTR(&v));
        else
            pRecord->m_pParent = EnsureClass(L"");

        if(pRecord->m_pParent)
            pRecord->m_pParent->EnsureChild(pRecord);
    }
    else
    {
        return hres;
    }
    
    //
    // Check if the class is keyed
    //

    unsigned __int64 i64Flags = 0;
    hres = pClass->QueryObjectFlags(0, WMIOBJECT_GETOBJECT_LOFLAG_KEYED,
                                    &i64Flags);
    if(FAILED(hres))
        return hres;

    if(i64Flags)
    {
        pRecord->m_eIsKeyed = e_Keyed;
    }
    else
    {
        pRecord->m_eIsKeyed = e_NotKeyed;
    }
     
    //
    // Expell whatever definition is there from the cache
    //

    m_pForest->RemoveRecord(pRecord);

    //  
    // Figure out how much space this object will take
    //

    DWORD dwSize;
    hres = pClass->GetObjectMemory(NULL, 0, &dwSize);
    if(hres != WBEM_E_BUFFER_TOO_SMALL)
    {
        if(SUCCEEDED(hres))
            return WBEM_E_CRITICAL_ERROR;
        else
            return hres;
    }

    //
    // Good.  Make room and add to cache
    //

    if(m_pForest->MakeRoom(dwSize))
    {
        if(bClone)
        {
            IWbemClassObject* pObj = NULL;
            hres = pClass->Clone(&pObj);
            if(FAILED(hres))
                return hres;

            if(pObj)
            {
                pObj->QueryInterface(IID__IWmiObject, 
                                        (void**)&pRecord->m_pClassDef);
                pObj->Release();
            }
        }
        else
        {   pRecord->m_pClassDef = pClass;
            pClass->AddRef();
        }

        if(nTime)
        {
            pRecord->m_bRead = true;
            pRecord->m_nClassDefCachedTime = nTime;
        }
        else
        {
            pRecord->m_bRead = false;
            pRecord->m_nClassDefCachedTime = g_nCurrentTime++;
        }

        pRecord->m_dwClassDefSize = dwSize;

		pRecord->m_bSystemClass = bSystemClass;
        
        //
        // It is most recently used, of course
        //

        m_pForest->Add(pRecord);
    }
    
    return WBEM_S_NO_ERROR;
    
}

HRESULT CHierarchyCache::InvalidateClass(LPCWSTR wszClassName)
{
     CInCritSec ics(m_pForest->GetLock());
 
    HRESULT hres;

    //
    // Find the record if not given
    //

    CClassRecord* pRecord = NULL;
    pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
    {
        // 
        // The record is not there --- there is nothing to invalidate.  This
        // is based on the assumption that if a class record is in the 
        // cache, then so are all its parents, which is true at the moment
        // because in order to construct a class we need to retrieve its
        // parents first.
        //

        return WBEM_S_FALSE;
    }

    pRecord->AddRef();
    CTemplateReleaseMe<CClassRecord> rm1(pRecord);

    LONGLONG lThisInvalidationIndex = m_lNextInvalidationIndex++;

    hres = InvalidateClassInternal(pRecord);

    //
    // Clear complete bits in all our parents, since this invalidation
    // means that no current enumeration of children can be trusted. At the same
    // time untie ourselves from the parent!
    //
    
    if(pRecord->m_pParent)
    {
        pRecord->m_pParent->m_bChildrenComplete = false;
        pRecord->m_pParent->m_bTreeComplete = false;
        pRecord->m_pParent->m_lLastChildInvalidationIndex = 
            lThisInvalidationIndex;
        pRecord->m_pParent->RemoveChild(pRecord);

        CClassRecord* pCurrent = pRecord->m_pParent->m_pParent;
        while(pCurrent)
        {
            pCurrent->m_bTreeComplete = false;
            pCurrent = pCurrent->m_pParent;
        }
    }

    return S_OK;
}


HRESULT CHierarchyCache::InvalidateClassInternal(CClassRecord* pRecord)
{
    //
    // Untie from the usage chain
    //

    //
    // Remove all its children from the cache
    //

    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        InvalidateClassInternal(pRecord->m_apChildren[i]);
    }

    pRecord->m_apChildren.RemoveAll();

    //
    // Count ourselves out of the total memory
    //

    m_pForest->RemoveRecord(pRecord);

    //
    // Remove ourselves from the cache
    //

    m_map.erase(pRecord->m_wszHash);
	pRecord->Release();

    return S_OK;
}

HRESULT CHierarchyCache::DoneWithChildren(LPCWSTR wszClassName, bool bRecursive,
                                LONGLONG lStartIndex, CClassRecord* pRecord)
{
     CInCritSec ics(m_pForest->GetLock());
 
    HRESULT hres;

    //
    // Find the record if not given
    //

    if(pRecord == NULL)
    {
        pRecord = FindClass(wszClassName);
        if(pRecord == NULL)
        {
            // Big time invalidation must have occurred
            return WBEM_S_FALSE;
        }
    }

    return DoneWithChildrenByRecord(pRecord, bRecursive, lStartIndex);
}

HRESULT CHierarchyCache::DoneWithChildrenByHash(LPCWSTR wszHash, 
                                bool bRecursive, LONGLONG lStartIndex)
{
     CInCritSec ics(m_pForest->GetLock());
 
    HRESULT hres;

    //
    // Find the record if not given
    //

    CClassRecord* pRecord = FindClassByKey(wszHash);
    if(pRecord == NULL)
    {
        // Big time invalidation must have occurred
        return WBEM_S_FALSE;
    }

    return DoneWithChildrenByRecord(pRecord, bRecursive, lStartIndex);
}

HRESULT CHierarchyCache::DoneWithChildrenByRecord(CClassRecord* pRecord,
                                bool bRecursive,  LONGLONG lStartIndex)
{
    //  
    // Check if any child invalidations occurred in this node since we started
    //

    if(lStartIndex < pRecord->m_lLastChildInvalidationIndex)
        return WBEM_S_FALSE;
    else
        pRecord->m_bChildrenComplete = true;
    
    if(bRecursive)
    {
        //
        // We have completed a recursive enumeration --- descend the 
        // hierarchy and mark as complete all the children that have not been
        // modified since the start
        //

        bool bAllValid = true;
        for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
        {
            CClassRecord* pChildRecord = pRecord->m_apChildren[i];
            HRESULT hres = DoneWithChildren(pChildRecord->m_wszClassName, true, 
                                    lStartIndex, pChildRecord);
    
            if(hres != S_OK)
                bAllValid = false;
        }
    
        if(bAllValid)
        {
            //
            // There were no invalidations anywhere in the tree, which makes
            // this record tree-complete
            //

            pRecord->m_bTreeComplete = true;
            return WBEM_S_NO_ERROR;
        }
        else
            return S_FALSE;
    }
    else
        return WBEM_S_NO_ERROR;
}


RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDef(LPCWSTR wszClassName,
                                                bool bClone, __int64* pnTime,
                                                bool* pbRead)
{
     CInCritSec ics(m_pForest->GetLock());
 
    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return NULL;

    if(pnTime)
        *pnTime = pRecord->m_nClassDefCachedTime;

    if(pbRead)
        *pbRead = pRecord->m_bRead;

    return GetClassDefFromRecord(pRecord, bClone);
}

RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDefByHash(LPCWSTR wszHash,
                                                bool bClone, __int64* pnTime,
                                                bool* pbRead, bool *pbSystemClass)
{
     CInCritSec ics(m_pForest->GetLock());
 
    CClassRecord* pRecord = FindClassByKey(wszHash);
    if(pRecord == NULL)
        return NULL;

    if(pbRead)
        *pbRead = pRecord->m_bRead;

    if(pnTime)
        *pnTime = pRecord->m_nClassDefCachedTime;
	
	if (pbSystemClass)
		*pbSystemClass = pRecord->m_bSystemClass;

    return GetClassDefFromRecord(pRecord, bClone);
}

// assumes: in m_cs
RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDefFromRecord(
                                                CClassRecord* pRecord,
                                                bool bClone)
{
    //
    // Accessing m_pClassDef, so we have to lock the forest
    //
     CInCritSec ics(m_pForest->GetLock());
    
    if(pRecord->m_pClassDef)
    {
        m_pForest->MakeMostRecentlyUsed(pRecord);

        if(bClone)
        {
            IWbemClassObject* pObj = NULL;
            if(FAILED(pRecord->m_pClassDef->Clone(&pObj)))
                return NULL;
            else
            {
                _IWmiObject* pRes = NULL;
                pObj->QueryInterface(IID__IWmiObject, (void**)&pRes);
                pObj->Release();
                return pRes;
            }
        }
        else
        {
            pRecord->m_pClassDef->AddRef();
            return pRecord->m_pClassDef;
        }
    }
    else
        return NULL;
}

HRESULT CHierarchyCache::EnumChildren(LPCWSTR wszClassName, bool bRecursive,
                            CWStringArray& awsChildren)
{
     CInCritSec ics(m_pForest->GetLock());
 
    //
    // Get the record
    //

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return WBEM_S_FALSE;

    //
    // Check if it is complete for this type of enumeration
    //

    if(!pRecord->m_bChildrenComplete)
        return WBEM_S_FALSE;

    if(bRecursive && !pRecord->m_bTreeComplete)
        return WBEM_S_FALSE;

    return EnumChildrenInternal(pRecord, bRecursive, awsChildren);
}

HRESULT CHierarchyCache::EnumChildrenInternal(CClassRecord* pRecord, 
                                        bool bRecursive,
                                        CWStringArray& awsChildren)
{
    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        CClassRecord* pChildRecord = pRecord->m_apChildren[i];
        if(awsChildren.Add(pChildRecord->m_wszClassName) < 0)
            return WBEM_E_OUT_OF_MEMORY;
        
        if(bRecursive)
        {
            HRESULT hres = EnumChildrenInternal(pChildRecord, bRecursive, 
                                                    awsChildren);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CHierarchyCache::EnumChildKeysByKey(LPCWSTR wszClassKey, 
                            CWStringArray& awsChildKeys)
{
     CInCritSec ics(m_pForest->GetLock());
 
    //
    // Get the record
    //

    CClassRecord* pRecord = FindClassByKey(wszClassKey);
    if(pRecord == NULL)
        return WBEM_S_FALSE;

    //
    // Check if it is complete for this type of enumeration
    //

    if(!pRecord->m_bChildrenComplete)
        return WBEM_S_FALSE;

    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        CClassRecord* pChildRecord = pRecord->m_apChildren[i];
        if(awsChildKeys.Add(pChildRecord->m_wszHash) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

 
HRESULT CHierarchyCache::GetKeyRoot(LPCWSTR wszClassName, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
     CInCritSec ics(m_pForest->GetLock());
 
    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return WBEM_E_NOT_FOUND;

    return GetKeyRootByRecord(pRecord, pwszKeyRoot);
}

// assumes: in cs
HRESULT CHierarchyCache::GetKeyRootByRecord(CClassRecord* pRecord,
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    *pwszKeyRoot = NULL;

    if(pRecord->m_eIsKeyed == e_NotKeyed)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // Go up until an unkeyed record is found.  Keep the previous in pPrev
    //

	CClassRecord* pPrev = pRecord;
    while(pRecord && pRecord->m_eIsKeyed == e_Keyed)
	{
		pPrev = pRecord;
        pRecord = pRecord->m_pParent;
	}

    if(pRecord && pRecord->m_eIsKeyed == e_NotKeyed)
    {
        //
        // Found unkeyed parent --- pPrev is the root
        //

        LPCWSTR wszKeyRoot = pPrev->m_wszClassName;
        DWORD dwLen = wcslen(wszKeyRoot)+1;
        *pwszKeyRoot = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
		if (*pwszKeyRoot == NULL)
			return WBEM_E_OUT_OF_MEMORY;
        StringCchCopyW(*pwszKeyRoot, dwLen, wszKeyRoot);
        return S_OK;
    }
    else
    {
        //
        // No unkeyed parents --- since "" is known to be unkeyed, we had have
        // hit a gap in the cache
        //

        return WBEM_E_NOT_FOUND;
    }
}

HRESULT CHierarchyCache::GetKeyRootByKey(LPCWSTR wszKey, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
     CInCritSec ics(m_pForest->GetLock());
 
    CClassRecord* pRecord = FindClassByKey(wszKey);
    if(pRecord == NULL)
        return WBEM_E_NOT_FOUND;

    return GetKeyRootByRecord(pRecord, pwszKeyRoot);
}

DELETE_ME LPWSTR CHierarchyCache::GetParent(LPCWSTR wszClassName)
{
     CInCritSec ics(m_pForest->GetLock());
 
    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return NULL;

    if(pRecord->m_pParent)
    {
        LPCWSTR wszParent = pRecord->m_pParent->m_wszClassName;
        size_t dwLen = wcslen(wszParent)+1;
        LPWSTR wszCopy = new WCHAR[dwLen];
		if (wszCopy == NULL)
			return NULL;
        StringCchCopyW(wszCopy, dwLen, wszParent);
        return wszCopy;
    }
    else
        return NULL;
}

//
//
//  CForestCache
//
//////////////////////////////////////////////////////////////////////

HRESULT CForestCache::Initialize()
{
     CInCritSec ics(&m_cs);
        
    if (m_bInit)
        return S_OK;

    //
    // Read the size limits from the registry
    //

    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);

    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxSize;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Size", NULL, NULL, 
                (LPBYTE)&dwMaxSize, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxSize = 5000000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Size", 0, REG_DWORD, 
                (LPBYTE)&dwMaxSize, sizeof(DWORD));
    }

    //
    // Read the maximum useful age of an item
    //

    dwLen = sizeof(DWORD);
    DWORD dwMaxAge;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Item Age (ms)", NULL, NULL, 
                (LPBYTE)&dwMaxAge, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxAge = 10000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Item Age (ms)", 0, 
                REG_DWORD, (LPBYTE)&dwMaxAge, sizeof(DWORD));
    }


    //
    // Apply
    //

    SetMaxMemory(dwMaxSize, dwMaxAge);

    //
    // Create a timer queue for flushing
    //

    //m_hTimerQueue = CreateTimerQueue();
    //m_hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    m_bInit = TRUE;

    return WBEM_S_NO_ERROR;
}


bool CForestCache::MakeRoom(DWORD dwSize)
{
     CInCritSec ics(&m_cs);
    
    if (!m_bInit)
        return false;    

    if(dwSize > m_dwMaxMemory)
        return false; // no hope!

    //  
    // Remove records until satisfied. Also, remove all records older than the
    // maximum age
    //

    DWORD dwNow = GetTickCount();

    while(m_pLeastRecentlyUsed && 
            (m_dwTotalMemory + dwSize > m_dwMaxMemory ||
             dwNow - m_pLeastRecentlyUsed->m_dwLastUsed > m_dwMaxAgeMs)
         )
    {
		RemoveRecord(m_pLeastRecentlyUsed);
    }

    return true;
}

bool CForestCache::Flush()
{
     CInCritSec ics(&m_cs);
     
    if (!m_bInit)
        return false;
    
    while(m_pLeastRecentlyUsed)
    {
		RemoveRecord(m_pLeastRecentlyUsed);
    }

    return true;
}

//
//
//  Test Only Function NOT IN REGULAR CODE
//
///////////////////////////////////////////////////////////////

#ifdef DBG

bool CForestCache::Test()
{
	if(m_pMostRecentlyUsed == NULL)
	{
		if(m_pLeastRecentlyUsed)
			DebugBreak();
		return true;
	}

	if(m_pMostRecentlyUsed->m_pMoreRecentlyUsed)
		DebugBreak();

	CClassRecord* pOne = m_pMostRecentlyUsed;
	CClassRecord* pTwo = m_pMostRecentlyUsed->m_pLessRecentlyUsed;

	while(pOne && pOne != pTwo)
	{
		if(pOne->m_pLessRecentlyUsed && pOne->m_pLessRecentlyUsed->m_pMoreRecentlyUsed != pOne)
			DebugBreak();
		if(pOne->m_pClassDef == NULL)
			DebugBreak();

		if(pOne->m_pLessRecentlyUsed == NULL && pOne != m_pLeastRecentlyUsed)
			DebugBreak();
		
		pOne = pOne->m_pLessRecentlyUsed;
		if(pTwo)
			pTwo = pTwo->m_pLessRecentlyUsed;
		if(pTwo)
			pTwo = pTwo->m_pLessRecentlyUsed;
	}
	if(pOne)
		DebugBreak();
	return true;
}

#endif        

void CForestCache::MakeMostRecentlyUsed(CClassRecord* pRecord)
{
     CInCritSec ics(&m_cs);

	//Test();
	Untie(pRecord);

	pRecord->m_pMoreRecentlyUsed = NULL;
	pRecord->m_pLessRecentlyUsed = m_pMostRecentlyUsed;
	if(m_pMostRecentlyUsed)
		m_pMostRecentlyUsed->m_pMoreRecentlyUsed = pRecord;

	m_pMostRecentlyUsed = pRecord;
	if(m_pLeastRecentlyUsed == NULL)
		m_pLeastRecentlyUsed = pRecord;


    pRecord->m_dwLastUsed = GetTickCount();
    pRecord->m_nStatus = 4;
	//Test();

    //
    // Schedule a timer to clean up, if not already there
    //

    if(m_hCurrentTimer == NULL)
    {
        CreateTimerQueueTimer(&m_hCurrentTimer, NULL,  
            (WAITORTIMERCALLBACK)&staticTimerCallback, this, m_dwMaxAgeMs,
            m_dwMaxAgeMs, WT_EXECUTEINTIMERTHREAD);
    }
}

void CForestCache::staticTimerCallback(void* pParam, BOOLEAN)
{
#ifdef DBG
    if (pParam != &g_Glob.m_ForestCache)
    {
        char pBuff[128];
        StringCchPrintfA(pBuff,128, "_RTLP_GENERIC_TIMER::Context == %p != %p\n",pParam,&g_Glob.m_ForestCache);
        OutputDebugStringA(pBuff);
        DebugBreak();
    }
#endif 
    g_Glob.m_ForestCache.TimerCallback();
}
    
void CForestCache::TimerCallback()
{    
     CInCritSec ics(&m_cs);
    
    // g_Glob.GetForestCache()->m_hCurrentTimer can be NULL at this point
    // if there is the CForestCache::Deinitialize function being executed
    // but we will delete the timer in that function instead of deleteing it below
    
    if (!m_bInit)
        return;

    //
    // Clean up what's stale
    //

    MakeRoom(0);

    //
    // See if we have any more reasons to live
    //

    if(m_pMostRecentlyUsed == NULL)
    {
        HANDLE hCurrentTimer;
   		if (hCurrentTimer = InterlockedCompareExchangePointer(&m_hCurrentTimer,0,m_hCurrentTimer))
        {
            DeleteTimerQueueTimer( NULL, hCurrentTimer, NULL);
        }
    }
}

void CForestCache::Add(CClassRecord* pRecord)
{
     CInCritSec ics(&m_cs);
    
    if (!m_bInit)
        return;

    MakeMostRecentlyUsed(pRecord);
    m_dwTotalMemory += pRecord->m_dwClassDefSize;
    pRecord->m_nStatus = 3;
}

void CForestCache::RemoveRecord(CClassRecord* pRecord)
{
     CInCritSec ics(&m_cs);
     
    if (!m_bInit)
        return;    

    if(pRecord->m_pClassDef == NULL)
		return;

	Untie(pRecord);

    m_dwTotalMemory -= pRecord->m_dwClassDefSize;

    pRecord->m_pClassDef->Release();
    pRecord->m_pClassDef = NULL;
    pRecord->m_nStatus = 2;
}

//
//
//  helper function, always in m_cs
//
///////////////////////////////////////////////////////

void CForestCache::Untie(CClassRecord* pRecord)
{
    CClassRecord* pPrev = pRecord->m_pLessRecentlyUsed;
    CClassRecord* pNext = pRecord->m_pMoreRecentlyUsed;
    if(pPrev)
        pPrev->m_pMoreRecentlyUsed = pNext;
    if(pNext)
        pNext->m_pLessRecentlyUsed = pPrev;

    if(m_pLeastRecentlyUsed == pRecord)
        m_pLeastRecentlyUsed = m_pLeastRecentlyUsed->m_pMoreRecentlyUsed;

    if(m_pMostRecentlyUsed == pRecord)
        m_pMostRecentlyUsed = m_pMostRecentlyUsed->m_pLessRecentlyUsed;

	pRecord->m_pMoreRecentlyUsed = pRecord->m_pLessRecentlyUsed = NULL;
}

void CForestCache::SetMaxMemory(DWORD dwMaxMemory, DWORD dwMaxAgeMs)
{
    m_dwMaxMemory = dwMaxMemory;
    m_dwMaxAgeMs = dwMaxAgeMs;
    
    // 
    // Make room for 0 bytes --- has the effect of clearing all the records
    // above the limit
    //

    MakeRoom(0);
}


CHierarchyCache* CForestCache::GetNamespaceCache(WString & wszNamespace)
{
     CInCritSec ics(&m_cs);
        
    if (!m_bInit)
        return  NULL;

    //
    // See if you can find one
    //

    TIterator it = m_map.find(wszNamespace);
    if(it != m_map.end())
    {
        it->second->AddRef();
        return it->second;
    }
    else
    {
        //
        // Not there --- create one
        //

        CHierarchyCache* pCache = new CHierarchyCache(this);
        if(pCache == NULL)
            return NULL;

        try 
        {
            pCache->AddRef();   // this refcount is for the cache
            m_map[wszNamespace] = pCache;
            pCache->AddRef();  // this refcount is for the customers
        }
        catch (CX_MemoryException)
        {
            delete pCache; // despite the AddRef
            pCache = NULL;
        }
        return pCache;
    }
}

void CForestCache::ReleaseNamespaceCache(WString & wszNamespace, 
                                            CHierarchyCache* pCache)
{
     CInCritSec ics(&m_cs);

    //
    // this is a cleanup function, we always want this to be called
    //
    //if (!m_bInit)
    //    return;    

    //
    // Find it in the map
    //
    TIterator it = m_map.find(wszNamespace);
        
    if (it !=  m_map.end() && (it->second == pCache))
    {
        //
	    // Last ref-count --- remove
	    //
        if( 1 == pCache->Release())
        {
	        m_map.erase(it);
	        pCache->Release(); // this is the last one
        }
    }
    else
    {
        pCache->Release();
    }
}

void CForestCache::BeginTransaction()
{
    m_bAssertedInTransaction = false;
}

bool CForestCache::MarkAsserted(CHierarchyCache* pCache, LPCWSTR wszClassName)
{
    m_bAssertedInTransaction = true;
    return true;
}

void CForestCache::CommitTransaction()
{
    m_bAssertedInTransaction = false;
}

void CForestCache::AbortTransaction()
{
    if(m_bAssertedInTransaction)
        Clear();

    m_bAssertedInTransaction = false;
}

void CForestCache::Clear()
{
     CInCritSec ics(&m_cs);
    
    if (!m_bInit)
        return;

    Flush();

    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        it->second->Clear();
        it++;
    }
}

HRESULT
CForestCache::Deinitialize()
{
    HANDLE hCurrentTimer;
    if (hCurrentTimer = InterlockedCompareExchangePointer(&m_hCurrentTimer,0,m_hCurrentTimer))
    {
        DeleteTimerQueueTimer( NULL, hCurrentTimer, NULL);
    }

     CInCritSec ics(&m_cs);    
    
    if (!m_bInit)
        return S_OK;
    
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        it->second->Clear();
        it->second->Release();
        it->second = NULL;        
        it++;
    };

    m_map.erase(m_map.begin(),m_map.end());

    m_bInit = FALSE;
    return S_OK;
}

CForestCache::~CForestCache()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\creposit.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __CREPOSIT__H_
#define __CREPOSIT__H_

#include <windows.h>
#include <wbemidl.h>
#include <unk.h>
#include <wbemcomn.h>
#include <sync.h>
#include <reposit.h>
#include <wmiutils.h>
#include <filecach.h>
#include <hiecache.h>
#include <corex.h>
#include "a51fib.h"
#include "lock.h"
#include <statsync.h>

extern CLock g_readWriteLock;
extern bool g_bShuttingDown;

/* ===================================================================================
 * A51_REP_FS_VERSION
 * 
 * 1 - Original A51 file-based repository
 * 2 - All Objects stored in single file (Whistler Beta 1)
 * 3 - BTree added
 * 4 - System Class optimisation - put all system classes in __SYSTEMCLASS namespace
 * 5 - Change to system classes in __SYSTEMCLASS namespace - need to propagate change
 *		to all namespaces as there may be instances of these classes.
 * 6 - XFiles: New page based heap. Transacted page manager sitting under new heap and
 *		BTree.  Instance indexing improved so instance queries are faster
 * 7 - Locale Upgrade run on repository
 * ===================================================================================
 */
#define A51_REP_FS_VERSION 7


/* =================================================================================
 *
 *	See sample_layout.txt for an example of the raw data!
 *	See sample_layout_translated.txt for a version with hashes converted to appropriate classes/keys/namespaces
 *
 *	<full repository path>	- Stripped out in the INDEX.CPP layer... c:\windows\system32\wbem\repository\fs
 *		\NS_<full_namespace>			- one for each namespace, hashed on full NS path
 *
 *			\CD_<class name>.x.y.z		- Class definition, hash on class name, object location appended
 *			\CR_<parent_class_name>\C_<class_name>	- parent/child class relationship
 *			\CR_<reference_class_name>\R_<class_name>	- class reference to another class
 *
 *			\KI_<key_root_class_name>\I_<key>.x.y.z	- Instance location for all instances sharing key tree
 *			\CI_<class_name>\IL_<key>.x.y.z			- Instance location associated with its own class
 *
 *			\KI_<referenced_key_root_class_name>\IR_<referenced_key>\R_<full_repository_path_of_referencing_KI\I_instance>.x.y.z		- instance reference
 *
 * 	SC_<hash>		- Not used!
 *
 *
 * Class definition object
 *	DWORD 		dwSuperclassLen					- no NULL terminator
 *	wchar_t 	wsSuperclassName[dwSuperclassLen]; - superclass name
 *	__int64 	i64Timestamp 					- timestamp of last update
 *	BYTE		baUnmergedClass[?]				- Unmerged class
 *
 *
 * Instance definition object
 *	wchar_t		wsClassHash[MAX_HASH_LEN]
 *	__int64		i64InstanceTimestamp
 *	__int64		i64ClassTimestamp
 *	BYTE		baUnmergedClass[?]
 *
 *
 * Instance Reference definition object -
 * NOTE!  If an instance has  multiple references to the same object, we will only return the last one as each one will get overwritten by
 * the last!  This is because final R_<HASH> is based on the referring objects full instance path.  It does not include the property in the hash!
 *	DWORD		dwNamespaceLen					- no NULL terminator
 *	wchar_t		wsNamespace	[dwNamespaceLen]	- namespace, root\default...
 *	DWORD		dwReferringClassLen				- Class name of instance referring to this instance
 *	wchar_t		wsReferringClass[dwReferringClassLen]	 - no NULL terminator
 *	DWORD		dwReferringPropertyLen			- property referring to us from the source object
 *	wchar_t		wsReferringProperty[dwReferringPropertyLen]	 - no NULL terminator
 *	DWORD		dwReferringFileNameLen			- file path of instance referring to this one, minus the full repository path 
 *	wchar_t		dwReferringFileName[dwReferringFileNameLen]	- (minus c:\windows..., but includes NS_....), not NULL terminated
 *
 * =================================================================================
 */
 
#define A51_CLASSDEF_FILE_PREFIX L"CD_"

#define A51_CLASSRELATION_DIR_PREFIX L"CR_"
#define A51_CHILDCLASS_FILE_PREFIX L"C_"

#define A51_KEYROOTINST_DIR_PREFIX L"KI_"
#define A51_INSTDEF_FILE_PREFIX L"I_"

#define A51_CLASSINST_DIR_PREFIX L"CI_"
#define A51_INSTLINK_FILE_PREFIX L"IL_"

#define A51_INSTREF_DIR_PREFIX L"IR_"
#define A51_REF_FILE_PREFIX L"R_"

#define A51_SCOPE_DIR_PREFIX L"SC_"

#define A51_SYSTEMCLASS_NS L"__SYSTEMCLASS"

class CGlobals;
extern CGlobals g_Glob;

class CNamespaceHandle;
extern CNamespaceHandle * g_pSystemClassNamespace;

//
// let's count here how many times we fail to recover from a failed transaction
//
/////////////////////////////////////////////////

enum eFailCnt {
    FailCntCommit,
   	FailCntInternalBegin,
   	FailCntInternalCommit,
   	FailCntCreateSystem,
   	FailCntCompactPages,
    FailCntLast
};

extern LONG g_RecoverFailureCnt[];

class CForestCache;
class CGlobals 
{
private:
    BOOL m_bInit;
    CStaticCritSec m_cs;

public:
    _IWmiCoreServices* m_pCoreServices;

    CForestCache m_ForestCache;

    CFileCache m_FileCache;

private:
    long    m_lRootDirLen;
    WCHAR   m_wszRootDir[MAX_PATH];    // keep this last: be debugger friendly
    WCHAR   m_ComputerName[MAX_COMPUTERNAME_LENGTH+1];

public:
    CGlobals():m_bInit(FALSE){};
    ~CGlobals(){};
    HRESULT Initialize();
    HRESULT Deinitialize();
	_IWmiCoreServices * GetCoreSvcs(){if (m_pCoreServices) m_pCoreServices->AddRef();return m_pCoreServices;}
//	CForestCache * GetForestCache() { return &m_ForestCache; }
//	CFileCache   * GetFileCache() { return &m_FileCache; }
    WCHAR * GetRootDir() {return (WCHAR *)m_wszRootDir;}
    WCHAR * GetComputerName(){ return (WCHAR *)m_ComputerName; };
    long    GetRootDirLen() {return  m_lRootDirLen;};   
    void    SetRootDirLen(long Len) { m_lRootDirLen = Len;};
    BOOL    IsInit(){ return m_bInit; };
};


HRESULT DoAutoDatabaseRestore();


class CNamespaceHandle;
class CRepository : public CUnkBase<IWmiDbController, &IID_IWmiDbController>
{
private:
	CFlexArray m_aSystemClasses;	//Used for part of the upgrade process.

	static DWORD m_ShutDownFlags;
	static HANDLE m_hShutdownEvent;
	static HANDLE m_hFlusherThread;
	static LONG   m_ulReadCount;
	static LONG   m_ulWriteCount;
	static HANDLE m_hWriteEvent;
	static HANDLE m_hReadEvent;
	static int    m_threadState;
	static CStaticCritSec m_cs;
	static LONG  m_threadCount;
	static LONG	 m_nFlushFailureCount;

	enum { ThreadStateDead, ThreadStateIdle, ThreadStateFlush, ThreadStateOperationPending};

protected:
    HRESULT Initialize();
	HRESULT UpgradeRepositoryFormat();
	HRESULT GetRepositoryDirectory();
	HRESULT InitializeGlobalVariables();
	HRESULT InitializeRepositoryVersions();
	static DWORD WINAPI _FlusherThread(void *);

public:

    HRESULT STDMETHODCALLTYPE Logon(
          WMIDB_LOGON_TEMPLATE *pLogonParms,
          DWORD dwFlags,
          DWORD dwRequestedHandleType,
         IWmiDbSession **ppSession,
         IWmiDbHandle **ppRootNamespace
        );

    HRESULT STDMETHODCALLTYPE GetLogonTemplate(
           LCID  lLocale,
           DWORD dwFlags,
          WMIDB_LOGON_TEMPLATE **ppLogonTemplate
        );

    HRESULT STDMETHODCALLTYPE FreeLogonTemplate(
         WMIDB_LOGON_TEMPLATE **ppTemplate
        );

    HRESULT STDMETHODCALLTYPE Shutdown(
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE SetCallTimeout(
         DWORD dwMaxTimeout
        );

    HRESULT STDMETHODCALLTYPE SetCacheValue(
         DWORD dwMaxBytes
        );

    HRESULT STDMETHODCALLTYPE FlushCache(
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE GetStatistics(
          DWORD  dwParameter,
         DWORD *pdwValue
        );

    HRESULT STDMETHODCALLTYPE Backup(
		LPCWSTR wszBackupFile,
		long lFlags
        );
    
    HRESULT STDMETHODCALLTYPE Restore(
		LPCWSTR wszBackupFile,
		long lFlags
        );

    HRESULT STDMETHODCALLTYPE LockRepository();

    HRESULT STDMETHODCALLTYPE UnlockRepository();

	HRESULT STDMETHODCALLTYPE GetRepositoryVersions(DWORD *pdwOldVersion, DWORD *pdwCurrentVersion);

	static HRESULT ReadOperationNotification();
	static HRESULT WriteOperationNotification();
   
public:
    CRepository(CLifeControl* pControl) : TUnkBase(pControl)
    {
        
    }
    ~CRepository()
    {
    }

    HRESULT GetNamespaceHandle(LPCWSTR wszNamespaceName, 
                                CNamespaceHandle** ppHandle);
};


#endif /*__CREPOSIT__H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\index.cpp ===
//***************************************************************************
//
//  (c) 2000-2001 by Microsoft Corp.  All Rights Reserved.
//
//  INDEX.CPP
//
//  24-Oct-00   raymcc      Integration layer to disk-based B-Tree
//
//***************************************************************************

#include "precomp.h"
#include <wbemcomn.h>
#include <reposit.h>
#include "a51tools.h"
#include "index.h"
#include <statsync.h>
#include "btr.h"

extern DWORD g_dwSecTlsIndex;

//***************************************************************************
//
//***************************************************************************
//
//#define DEBUG

static CLockableFlexArray<CStaticCritSec> g_aIterators;

class CIteratorBatch
{
    CFlexArray m_aStrings;
    BOOL  m_bDone;
    DWORD m_dwCursor;

public:
    CIteratorBatch();
   ~CIteratorBatch();
    BOOL Purge(LPSTR pszTarget);
    BOOL Add(LPSTR pszSrc);    // Acquires memory
    void SetDone() { m_bDone = TRUE; }
    BOOL Next(LPSTR *pString);
    static DWORD PurgeAll(LPSTR pszDoomed);
};

//***************************************************************************
//
//  CIteratorBatch::PurgeAll
//
//
//  Purges all iterators of a particular string.  This happens when
//  a DeleteKey succeeds while there are outstanding enumerators; we want
//  to remove the key from all enumerators so that deleted objects
//  are not reported.
//
//  This is required because the enumerators do "prefetch" and may
//  have been invoked considerably in advance of the delete
//
//  Assumes prior concurrency control.
//
//***************************************************************************
// ok
DWORD CIteratorBatch::PurgeAll(LPSTR pszDoomed)
{
    DWORD dwTotal = 0;
	g_aIterators.Lock();
    for (int i = 0; i < g_aIterators.Size(); i++)
    {
        CIteratorBatch *p = (CIteratorBatch *) g_aIterators[i];
        BOOL bRes = p->Purge(pszDoomed);
        if (bRes)
            dwTotal++;
    }
	g_aIterators.Unlock();
    return dwTotal;
}

//***************************************************************************
//
//  CIteratorBatch::CIteratorBatch
//
//***************************************************************************
// ok
CIteratorBatch::CIteratorBatch()
{
    m_bDone = FALSE;
    m_dwCursor = 0;
}

//***************************************************************************
//
//  CIteratorBatch::Add
//
//  Adds a string to the enumerator.
//
//***************************************************************************
//
BOOL CIteratorBatch::Add(LPSTR pszSrc)
{
	if (m_aStrings.Size() == 0)
	{
		g_aIterators.Lock();
	    int i = g_aIterators.Add(this);
		g_aIterators.Unlock();
		if (i)
			return FALSE;
	}
    int nRes = m_aStrings.Add(pszSrc);
    if (nRes)
        return FALSE;
    return TRUE;
}


//***************************************************************************
//
//  CIteratorBatch::~CIteratorBatch
//
//  Removes all remaining strings and deallocates them and removes
//  this iterator from the global list.
//
//  Assumes prior concurrency control.
//
//***************************************************************************
//
CIteratorBatch::~CIteratorBatch()
{
    for (int i = 0; i < m_aStrings.Size(); i++)
    {
        _BtrMemFree(m_aStrings[i]);
    }

	g_aIterators.Lock();
    for (i = 0; i < g_aIterators.Size(); i++)
    {
        if (g_aIterators[i] == this)
        {
            g_aIterators.RemoveAt(i);
            break;
        }
    }
	g_aIterators.Unlock();
}

//***************************************************************************
//
//  CIteratorBatch::Purge
//
//  Removes a specific string from the enumerator.  Happens when a concurrent
//  delete succeeds; we have to remove the deleted key from the enumeration
//  for result set coherence.
//
//  Assumes prior concurrency control.
//
//  Returns FALSE if the string was not removed, TRUE if it was.  The
//  return value is mostly a debugging aid.
//
//***************************************************************************
// ok
BOOL CIteratorBatch::Purge(
    LPSTR pszTarget
    )
{
    int nSize = m_aStrings.Size();

    if (nSize == 0)
        return FALSE;

    // First, check the first/last strings against
    // the first character of the target.  We can
    // avoid a lot of strcmp calls if the target
    // is lexcially outside the range of the contents of
    // the enumerator.
    // ==================================================

    LPSTR pszFirst = (LPSTR) m_aStrings[0];
    LPSTR pszLast = (LPSTR) m_aStrings[nSize-1];
    if (*pszTarget > *pszLast)
        return FALSE;
    if (*pszTarget < *pszFirst)
        return FALSE;

    // If here, there is a chance that we have the
    // string in the enumerator. Since all keys are
    // retrieved in lexical order, a simple binary
    // search is all we need.
    // =============================================

    int nPosition = 0;
    int l = 0, u = nSize - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        // m is the current key to consider 0...n-1

        LPSTR pszCandidate = (LPSTR) m_aStrings[m];
        int nRes = strcmp(pszTarget, pszCandidate);

        // Decide which way to cut the array in half.
        // ==========================================

        if (nRes < 0)
        {
            u = m - 1;
            nPosition = u + 1;
        }
        else if (nRes > 0)
        {
            l = m + 1;
            nPosition = l;
        }
        else
        {
            // If here, we found the darn thing.  Life is good.
            // Zap it and return!
            // ================================================

            _BtrMemFree(pszCandidate);
            m_aStrings.RemoveAt(m);
            return TRUE;
        }
    }

    return FALSE;
}



//***************************************************************************
//
//  CIteratorBatch::Next
//
//  Returns the next string from the enumeration prefetch.
//
//***************************************************************************
//
BOOL CIteratorBatch::Next(LPSTR *pMem)
{
    if (m_aStrings.Size())
    {
        *pMem = (LPSTR) m_aStrings[0];
        m_aStrings.RemoveAt(0);
        return TRUE;
    }
    return FALSE;
}



//***************************************************************************
//
//  CBtrIndex::CBtrIndex
//
//***************************************************************************
//
CBtrIndex::CBtrIndex()
{
    m_dwPrefixLength = 0;
}


//***************************************************************************
//
//  CBtrIndex::~CBtrIndex
//
//***************************************************************************
//
CBtrIndex::~CBtrIndex()
{
}

long CBtrIndex::Shutdown(DWORD dwShutDownFlags)
{
    long lRes;

    lRes = bt.Shutdown(dwShutDownFlags);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = ps.Shutdown(dwShutDownFlags);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CBtrIndex::Initialize
//
//***************************************************************************
//
long CBtrIndex::Initialize(DWORD dwPrefixLength, 
						   LPCWSTR wszRepositoryDir, 
						   CPageSource* pSource)
{
    // Initialize the files in question and map BTree into it.
    // =======================================================

    CFileName buf;
    if (buf == NULL)
    	return ERROR_OUTOFMEMORY;
    StringCchCopyW(buf, buf.Length(),wszRepositoryDir);
    StringCchCatW(buf, buf.Length(), L"\\index.btr");

    DWORD dwRes = ps.Init(8192, buf, pSource);
    dwRes |= bt.Init(&ps);

    m_dwPrefixLength = dwPrefixLength;

    return long(dwRes);
}


//***************************************************************************
//
//   CBtrIndex::Create
//
//***************************************************************************
//
long CBtrIndex::Create(LPCWSTR wszFileName)
{
    DWORD dwRes;

    if (wszFileName == 0)
        return ERROR_INVALID_PARAMETER;

    wszFileName += m_dwPrefixLength;

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszFileName) + 1];
    if (pAnsi == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    LPCWSTR pSrc = wszFileName;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    try
    {
        dwRes = bt.InsertKey(pAnsi, 0);
    }
    catch (CX_MemoryException &)
    {
        dwRes = ERROR_OUTOFMEMORY;
    }

    delete [] pAnsi;

    if (dwRes == ERROR_ALREADY_EXISTS)
        dwRes = NO_ERROR;

    return long(dwRes);
}

//***************************************************************************
//
//  CBtrIndex::Delete
//
//  Deletes a key from the index
//
//***************************************************************************
//
long CBtrIndex::Delete(LPCWSTR wszFileName)
{
    DWORD dwRes = 0;

    wszFileName += m_dwPrefixLength;

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszFileName) + 1];
    if (pAnsi == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    LPCWSTR pSrc = wszFileName;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    try
    {
        dwRes = bt.DeleteKey(pAnsi);
        if (dwRes == 0)
            CIteratorBatch::PurgeAll(pAnsi);
    }
    catch (CX_MemoryException &)
    {
        dwRes = ERROR_OUTOFMEMORY;
    }

    delete pAnsi;

    return long(dwRes);
}

//***************************************************************************
//
//  CBtrIndex::CopyStringToWIN32_FIND_DATA
//
//  Does an ANSI to UNICODE convert for the key string.
//
//***************************************************************************
//
BOOL CBtrIndex::CopyStringToWIN32_FIND_DATA(
    LPSTR pszKey,
    LPWSTR pszDest,
    bool bCopyFullPath 
    )
{
    LPSTR pszSuffix;

    if ( bCopyFullPath)
    {
        pszSuffix = pszKey;
    }
    else
    {
        pszSuffix = pszKey + strlen(pszKey) - 1;
        while (pszSuffix[-1] != '\\' && pszSuffix > pszKey)
        {
            pszSuffix--;
        }
    }

    // If here, a clean match.
    // =======================

    while (*pszSuffix)
        *pszDest++ = (wchar_t) *pszSuffix++;
    *pszDest = 0;

    return TRUE;
}


//***************************************************************************
//
//  CBtrIndex::FindFirst
//
//  Starts an enumeration
//
//***************************************************************************
//
long CBtrIndex::FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{

    BOOL bExclude = FALSE;
    if (TlsGetValue(g_dwSecTlsIndex))
    {
		WCHAR pCompare[] = L"KI_644C0907A53790A09D448C09530D58E6\\I_18BA379108CD7CCC2FA0FD754AD45A25";
		DWORD dwLenCompare = sizeof(pCompare)/sizeof(WCHAR) - 1;
		WCHAR * pEndCompare = pCompare + (dwLenCompare -1);

		DWORD dwLen  = wcslen(wszPrefix);
		WCHAR * pEnd = (WCHAR *)wszPrefix+ (dwLen-1);

		do
		{
		    if (*pEndCompare != *pEnd)
		    	break;
		    else
		    {
		        pEndCompare--;
		        pEnd--;
		    }
		} while ((pCompare-1) != pEndCompare);
		if ((pCompare-1) == pEndCompare)
		{
		   //OutputDebugStringA("Findfirst for __thisnamespace=@ called\n");
		   bExclude = TRUE;
		}
    }


    DWORD dwRes;
    wszPrefix += m_dwPrefixLength;

    if(ppHandle)
        *ppHandle = INVALID_HANDLE_VALUE;

    pfd->cFileName[0] = 0;
    pfd->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszPrefix) + 1];
    if (pAnsi == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CVectorDeleteMe<char> vdm(pAnsi);

    LPCWSTR pSrc = wszPrefix;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    // Critical-section blocked.
    // =========================

    CBTreeIterator *pIt = new CBTreeIterator;
    if (!pIt)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    try
    {
        dwRes = pIt->Init(&bt, pAnsi);
    }
    catch (CX_MemoryException &)
    {
        dwRes = ERROR_OUTOFMEMORY;
    }

    if (dwRes)
    {
        pIt->Release();
        return dwRes;
    }

    // Create CIteratorBatch.
    // ======================

    CIteratorBatch *pBatch = new CIteratorBatch;

    if (pBatch == 0)
    {
        pIt->Release();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Iterate and fill batcher.
    // =========================

    LPSTR pszKey = 0;
    int nMatchLen = strlen(pAnsi);
	long lRes = 0;
    for (;;)
    {
        lRes = pIt->Next(&pszKey);
		
		if (lRes == ERROR_NO_MORE_ITEMS)
		{
			//We hit the end of the BTree result set, so we need to ignore this error
			lRes = 0;
			break;
		}
		//If we hit an error we quit the loop        
        if (lRes)
            break;

        // See if prefix matches.

        if (strncmp(pAnsi, pszKey, nMatchLen) != 0 || bExclude)
        {
            pIt->FreeString(pszKey);
            pBatch->SetDone();
            break;
        }
        if (!pBatch->Add(pszKey))
        {
        	lRes = ERROR_OUTOFMEMORY;
        	break;
        }

		if (ppHandle == NULL)
			break;	//Only asked for 1 item!  No need to try the next
    }

    pIt->Release();

	if (lRes == NO_ERROR)
	    lRes = FindNext(pBatch, pfd);

    if (lRes == ERROR_NO_MORE_FILES)
        lRes = ERROR_FILE_NOT_FOUND;

    if (lRes == NO_ERROR)
    {
        if(ppHandle)
        {
            *ppHandle = (LPVOID *) pBatch;
        }
        else
        {
            //
            // Only asked for one --- close handle
            //

            delete pBatch;
        }
    }
    else
    {
        delete pBatch;
    }

    return lRes;
}

//***************************************************************************
//
//  CBtrIndex::FindNext
//
//  Continues an enumeration.  Reads from the prefetch buffer.
//
//***************************************************************************
//
long CBtrIndex::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    LPSTR pszString = 0;
    BOOL bRes;

    if (pHandle == 0 || pfd == 0 || pHandle == INVALID_HANDLE_VALUE)
        return ERROR_INVALID_PARAMETER;

    CIteratorBatch *pBatch = (CIteratorBatch *) pHandle;
    bRes = pBatch->Next(&pszString);

    if (bRes == FALSE)
        return ERROR_NO_MORE_FILES;

    CopyStringToWIN32_FIND_DATA(pszString, pfd->cFileName);
    pfd->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

    if (pszString)
       _BtrMemFree(pszString);

    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CBtrIndex::FindClose
//
//  Closes an enumeration by deleting the 'hidden' pointer.
//
//***************************************************************************
//  ok
long CBtrIndex::FindClose(void* pHandle)
{
    if (pHandle == 0 || pHandle == INVALID_HANDLE_VALUE)
        return NO_ERROR;

    delete (CIteratorBatch *) pHandle;

    return ERROR_SUCCESS;
}

long CBtrIndex::InvalidateCache()
{

    //
    // Re-read the admin page from disk.  NOTE: this will need changing if more
    // caching is added!
    //

    DWORD dwRes = ps.ReadAdminPage();
    if (dwRes == NO_ERROR)
        dwRes = bt.InvalidateCache();

    return long(dwRes);
}

long CBtrIndex::FlushCaches()
{
	return bt.FlushCaches();
}


long CBtrIndex::IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
{
    BOOL bExclude = FALSE;
    if (TlsGetValue(g_dwSecTlsIndex))
    {    	
		WCHAR pCompare[] = L"CI_644C0907A53790A09D448C09530D58E6";
		DWORD dwLenCompare = sizeof(pCompare)/sizeof(WCHAR) - 1;
		WCHAR * pEndCompare = pCompare + (dwLenCompare -1);

		DWORD dwLen  = wcslen(wszSearchPrefix);
		WCHAR * pEnd = (WCHAR *)wszSearchPrefix+ (dwLen-1);
		while (*pEnd != L'\\') pEnd--;
		pEnd--;

		do
		{
		    if (*pEndCompare != *pEnd)
		    	break;
		    else
		    {
		        pEndCompare--;
		        pEnd--;
		    }
		} while ((pCompare-1) != pEndCompare);
		
		if ((pCompare-1) == pEndCompare)
		{
		   //OutputDebugStringA("IndexEnumerationBegin for __thisnamespace called\n");
		   bExclude = TRUE;
		}
    	
    }

    DWORD dwRes = ERROR_SUCCESS;
    wszSearchPrefix += m_dwPrefixLength;

    if(ppHandle)
        *ppHandle = INVALID_HANDLE_VALUE;

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszSearchPrefix) + 1];
    if (pAnsi == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CVectorDeleteMe<char> vdm(pAnsi);

    LPCWSTR pSrc = wszSearchPrefix;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    CBTreeIterator *pIt = new CBTreeIterator;
    if (!pIt)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    try
    {
        dwRes = pIt->Init(&bt, pAnsi);
    }
    catch (CX_MemoryException &)
    {
        dwRes = ERROR_OUTOFMEMORY;
    }

    if (dwRes)
    {
        pIt->Release();
        return dwRes;
    }

    // Create CIteratorBatch.
    // ======================

    CIteratorBatch *pBatch = new CIteratorBatch;

    if (pBatch == 0)
    {
        pIt->Release();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Iterate and fill batcher.
    // =========================

    LPSTR pszKey = 0;
    int nMatchLen = strlen(pAnsi);

    for (int nCount = 0;;nCount++)
    {
        dwRes = pIt->Next(&pszKey);
        
		if (dwRes == ERROR_NO_MORE_ITEMS)
		{
			//We hit the end of the BTree result set, so we need to ignore this error
			dwRes = 0;
			break;
		}

		//If we hit an error we quit the loop
        if (dwRes)
            break;

        // See if prefix matches.

        if (strncmp(pAnsi, pszKey, nMatchLen) != 0 || bExclude)
        {
            pIt->FreeString(pszKey);
            pBatch->SetDone();
            break;
        }
        if (!pBatch->Add(pszKey))
        {
        	dwRes = ERROR_OUTOFMEMORY;
        	break;
        }
    }

    pIt->Release();

	if ((nCount == 0) && (dwRes == ERROR_SUCCESS))
		dwRes = ERROR_FILE_NOT_FOUND;

	if (dwRes == ERROR_SUCCESS)
	{
		if(ppHandle)
		{
			*ppHandle = (LPVOID *) pBatch;
		}
		else
			delete pBatch;
	}
	else
		delete pBatch;


    return dwRes;
}

long CBtrIndex::IndexEnumerationEnd(void *pHandle)
{
	if (pHandle != INVALID_HANDLE_VALUE)
		delete (CIteratorBatch *) pHandle;

    return ERROR_SUCCESS;
}

long CBtrIndex::IndexEnumerationNext(void *pHandle, CFileName &wszFileName, bool bCopyFullPath)
{
    LPSTR pszString = 0;
    BOOL bRes;

    if (pHandle == 0 || pHandle == INVALID_HANDLE_VALUE)
        return ERROR_INVALID_PARAMETER;

    CIteratorBatch *pBatch = (CIteratorBatch *) pHandle;
    bRes = pBatch->Next(&pszString);

    if (bRes == FALSE)
        return ERROR_NO_MORE_FILES;

    CopyStringToWIN32_FIND_DATA(pszString, wszFileName, bCopyFullPath);

    if (pszString)
       _BtrMemFree(pszString);

    return ERROR_SUCCESS;
}

//======================================================
//
//  CBtrIndex::ReadNextIndex
//
//  Description:
//  
//  Parameters:
//
//  Returns:
//      ERROR_SUCCESS                    Success
//      ERROR_NO_MORE_ITEMS         No more items
//      other errors as necessary
//======================================================
long CBtrIndex::ReadNextIndex(const wchar_t *wszSearch, CFileName &wszNextIndex)
{
    DWORD dwRes = ERROR_SUCCESS;
//Current usage doesn't need the prefix.  If someone does in the future
//you're going to have to add a flag to make this work!
//    wszSearch += m_dwPrefixLength;

    // Convert to ANSI
    char *pAnsi = new char[wcslen(wszSearch) + 1];
    if (pAnsi == 0)
        return ERROR_OUTOFMEMORY;
    CVectorDeleteMe<char> vdm(pAnsi);

    const wchar_t *pSrc = wszSearch;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    CBTreeIterator *pIt = new CBTreeIterator;
    if (!pIt)
        return ERROR_OUTOFMEMORY;
    CTemplateReleaseMe<CBTreeIterator> rm(pIt);

    try
    {
        dwRes = pIt->Init(&bt, pAnsi);
    }
    catch (CX_MemoryException &)
    {
        dwRes = ERROR_OUTOFMEMORY;
    }

    if (dwRes)
        return dwRes;

    char *pszKey = 0;

    dwRes = pIt->Next(&pszKey);
    
    if (dwRes == 0)
    {
        //Copy result to out parameter
        wchar_t *pDest = wszNextIndex;
        char *pSrc= pszKey;
        while (*pSrc)
            *pDest++ = (wchar_t) *pSrc++;
        *pDest = 0;

        //delete the string
        pIt->FreeString(pszKey);
    }

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\hiecache.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51__HIECACHE__H_
#define __WMI_A51__HIECACHE__H_

//
// NOTE: it is critical that things be marked in the cache while the repository
// lock is held!  Otherwise, invalidation/completion logic will break
//

#include <wbemint.h>
#include <map>
#include <sync.h>
#include <wstlallc.h>
#include <statsync.h>
#include "a51tools.h"


class wcscless : public binary_function<LPCWSTR, LPCWSTR, bool> 
{
public:
    bool operator()(const LPCWSTR& wcs1, const LPCWSTR& wcs2) const
        {return wcscmp(wcs1, wcs2) < 0;}
};

typedef enum {e_KeynessUnknown, e_Keyed, e_NotKeyed} EKeyNess;

class CClassRecord
{
protected:
    static long s_nRecords;

    long m_lRef;

    CClassRecord* m_pMoreRecentlyUsed;
    CClassRecord* m_pLessRecentlyUsed;
    
    LPWSTR m_wszClassName;
    WCHAR m_wszHash[MAX_HASH_LEN+1];

    _IWmiObject* m_pClassDef;
    DWORD m_dwClassDefSize;
    
    CClassRecord* m_pParent;
    EKeyNess m_eIsKeyed;
    CPointerArray<CClassRecord> m_apChildren;

    bool m_bTreeComplete;
    bool m_bChildrenComplete;
    LONGLONG m_lLastChildInvalidationIndex;

    DWORD m_dwLastUsed;
    int m_nStatus;
    __int64 m_nClassDefCachedTime;
    bool m_bRead;
	bool m_bSystemClass;

public:
    CClassRecord(LPCWSTR wszClassName, LPCWSTR wszHash);
    virtual ~CClassRecord();

    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {if(InterlockedDecrement(&m_lRef) == 0) delete this;}

    HRESULT EnsureChild(CClassRecord* pChild);
    HRESULT RemoveChild(CClassRecord* pChild);

    friend class CHierarchyCache;
    friend class CForestCache;
};

class CForestCache;
class CHierarchyCache
{
protected:

    static long s_nCaches;

    long m_lRef;
    typedef std::map<LPCWSTR, CClassRecord*, wcscless, wbem_allocator<CClassRecord*> > TMap;
    typedef TMap::iterator TIterator;

    CForestCache* m_pForest;
    TMap m_map;
    LONGLONG m_lNextInvalidationIndex;
    HRESULT m_hresError;

public:
    CHierarchyCache(CForestCache* pForest);
    virtual ~CHierarchyCache();
    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release() { long lRet = InterlockedDecrement(&m_lRef); if (0 == lRet) delete this; return lRet; }

    HRESULT AssertClass(_IWmiObject* pClass, LPCWSTR wszClassName, 
                       bool bClone, __int64 nTime, bool bSystemClass);
    HRESULT InvalidateClass(LPCWSTR wszClassName);

    HRESULT DoneWithChildren(LPCWSTR wszClassName, bool bRecursive, 
                            LONGLONG lStartingIndex, 
                            CClassRecord* pRecord = NULL);
    HRESULT DoneWithChildrenByHash(LPCWSTR wszHash, bool bRecursive,
                                LONGLONG lStartIndex);
    LONGLONG GetLastInvalidationIndex() {return m_lNextInvalidationIndex-1;}

    void SetError(HRESULT hresError);
    HRESULT GetError();

    void Clear();

public:
    RELEASE_ME _IWmiObject* GetClassDef(LPCWSTR wszClassName, 
                                        bool bClone, __int64* pnTime = NULL,
                                        bool* pbRead = NULL);
    HRESULT EnumChildren(LPCWSTR wszClassName, bool bRecursive,
                            CWStringArray& awsChildren);
    HRESULT EnumChildKeysByKey(LPCWSTR wszClassKey, 
                            CWStringArray& awsChildKeys);
    HRESULT GetKeyRootByKey(LPCWSTR wszKey, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    HRESULT GetKeyRoot(LPCWSTR wszClassName, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    HRESULT GetKeyRootByRecord(CClassRecord* pRecord,
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    DELETE_ME LPWSTR GetParent(LPCWSTR wszClassName);
    RELEASE_ME _IWmiObject* GetClassDefByHash(LPCWSTR wszHash, bool bClone,
                                              __int64* pnTime = NULL,
                                              bool* pbRead = NULL,
											  bool *pbSystemClass = NULL);

protected:
    INTERNAL CClassRecord* FindClass(LPCWSTR wszClassName);
    INTERNAL CClassRecord* FindClassByKey(LPCWSTR wszKey);
    RELEASE_ME _IWmiObject* GetClassDefFromRecord(CClassRecord* pRecord,
                                                bool bClone);
    INTERNAL CClassRecord* EnsureClass(LPCWSTR wszClassName);
    HRESULT EnumChildrenInternal(CClassRecord* pRecord, 
                                        bool bRecursive,
                                        CWStringArray& awsChildren);

    HRESULT InvalidateClassInternal(CClassRecord* pRecord);
    HRESULT DoneWithChildrenByRecord(CClassRecord* pRecord,
                                bool bRecursive,  LONGLONG lStartIndex);
    static bool MakeKey(LPCWSTR wszClassName, LPWSTR wszKey);
};

class CForestCache
{
protected:
    CStaticCritSec m_cs;

    CClassRecord* m_pMostRecentlyUsed;
    CClassRecord* m_pLeastRecentlyUsed;
    DWORD m_dwMaxMemory;
    DWORD m_dwMaxAgeMs;
    DWORD m_dwTotalMemory;

    HANDLE m_hCurrentTimer;
    long m_lRef;
    BOOL m_bInit;

    typedef std::map<WString, CHierarchyCache*, WSiless, wbem_allocator<CHierarchyCache*> > TMap;
    typedef TMap::iterator TIterator;

    TMap m_map;
    bool m_bAssertedInTransaction;

public:
    CForestCache() : m_dwMaxMemory(0xFFFFFFFF), m_dwTotalMemory(0),
        m_pMostRecentlyUsed(NULL), m_pLeastRecentlyUsed(NULL),
        m_dwMaxAgeMs(0), m_hCurrentTimer(NULL),
        m_lRef(1), m_bInit(FALSE), m_bAssertedInTransaction(false)        
    {
    }

    ~CForestCache();
    HRESULT Initialize();
    HRESULT Deinitialize();    

    void SetMaxMemory(DWORD dwMaxMemory, DWORD dwMaxAgeMs);
    bool MakeRoom(DWORD dwSize);
    bool Flush();
    void MakeMostRecentlyUsed(CClassRecord* pRecord);
    void Add(CClassRecord* pRecord);
    void RemoveRecord(CClassRecord* pRecord);
    void BeginTransaction();
    bool MarkAsserted(CHierarchyCache* pCache, LPCWSTR wszClassName);
    void CommitTransaction();
    void AbortTransaction();

public:
    CHierarchyCache* GetNamespaceCache(WString & wszNamespace);
    void ReleaseNamespaceCache(WString & wszNamespace, CHierarchyCache* pCache);
    long AddRef() {  return InterlockedIncrement(&m_lRef);}
    long Release() { long lRet = InterlockedDecrement(&m_lRef);  if (!lRet) delete this; return lRet;}

    void Clear();
protected:	
    CRITICAL_SECTION * GetLock() {return &m_cs;}
	bool Test();	
	void Untie(CClassRecord* pRecord);
    void TimerCallback();
    static void staticTimerCallback(VOID* pParam, BOOLEAN);
    friend class CHierarchyCache;
};
    
    
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\lock.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.CPP

Abstract:

    Implements the generic class for obtaining read and write locks to some 
    resource. 

    See lock.h for all documentation.

    Classes defined:

    CLock

History:

    a-levn  5-Sept-96       Created.
    3/10/97     a-levn      Fully documented

--*/

#include "precomp.h"
#include <stdio.h>
#include "lock.h"

// debugging.
#define PRINTF


#ifdef DBG
OperationStat gTimeTraceReadLock;
OperationStat gTimeTraceWriteLock;
OperationStat gTimeTraceBackupLock;
CStaticCritSec  OperationStat::lock_;
#endif

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

CLock::CLock() : m_nReading(0), m_nWriting(0), m_nWaitingToRead(0),
            m_nWaitingToWrite(0),
            m_csEntering(THROW_LOCK,0x80000000 | 500L),
            m_csAll(THROW_LOCK,0x80000000 | 500L)
            
{
    m_dwArrayIndex = 0;
    for (DWORD i=0;i<MaxRegistredReaders;i++)
    {
        m_adwReaders[i].ThreadId = 0;
    }
    // Create unnamed events for reading and writing
    // =============================================

    m_hCanRead = CreateEvent(NULL, TRUE, TRUE, NULL);
    m_hCanWrite = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (NULL == m_hCanRead || NULL == m_hCanWrite)
    {
    	CStaticCritSec::SetFailure();
    }
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
CLock::~CLock()
{
    if (m_hCanWrite) CloseHandle(m_hCanWrite);
    if (m_hCanRead) CloseHandle(m_hCanRead);
}


//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
int CLock::ReadLock(DWORD dwTimeout)
{
    PRINTF("%d wants to read\n", GetCurrentThreadId());


    // Get in line for getting any kind of lock (those unlocking don't go into
    // this line)
    // =======================================================================
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    
    LockGuard<CriticalSection> lgEnter(m_csEntering);
    if (!lgEnter.locked())
    {
#ifdef DBG
        DebugBreak();
#endif
    	return TimedOut;
    }

    // We are the only ones allowed to get any kind of lock now. Wait for the
    // event indicating that reading is enabled to become signaled
    // ======================================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());
    if(m_nWriting != 0)
    {
        int nRes = WaitFor(m_hCanRead, dwTimeout);
        if(nRes != NoError)
        {
            return nRes;
        }
    }

    // Enter inner critical section (unlockers use it too), increment the
    // number of readers and disable writing.
    // ==================================================================

    PRINTF("%d got event\n", GetCurrentThreadId());

    LockGuard<CriticalSection> lgAll(m_csAll);
    if (!lgAll.locked())
    {    
	    if(m_nReading == 0)
	    {
	        // this is for the read lock acquired on one thread and release on one other        
	        m_dwArrayIndex = 0;
	        
	        if(!SetEvent(m_hCanWrite))
	        {
#ifdef DBG
                DebugBreak();	        
#endif
	            return Failed;
	        }
	    }
#ifdef DBG
        DebugBreak();
#endif
        return TimedOut;
    }
    	
    m_nReading++;

    //DBG_PRINTFA((pBuff,"+ (%08x) %d\n",GetCurrentThreadId(),m_nReading));

    if (m_dwArrayIndex < MaxRegistredReaders)
    {
        m_adwReaders[m_dwArrayIndex].ThreadId = dwThreadId;
        ULONG Hash;
        //RtlCaptureStackBackTrace(1,MaxTraceSize,m_adwReaders[m_dwArrayIndex].Trace,&Hash);
        m_dwArrayIndex++;
    }

    
    PRINTF("Reset write\n");
    ResetEvent(m_hCanWrite);
    PRINTF("Done\n");

	if (m_nWriting)
	{
		
#ifdef DBG
                OutputDebugString(L"WinMgmt: Read lock aquired while write lock is aquired!\n");
		DebugBreak();
#endif
	}

    // Get out of all critical sections and return
    // ===========================================

    PRINTF("%d begins to read\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::ReadUnlock()
{
    PRINTF("%d wants to unlock reading\n", GetCurrentThreadId());

    // Enter internal ciritcal section and decrement the number of readers
    // ===================================================================

    LockGuard<CriticalSection> gl(m_csAll);

    while (!gl.locked())
    {
    	Sleep(20);
    	gl.acquire();
    };

    m_nReading--;

    //DBG_PRINTFA((pBuff,"- (%08x) %d\n",GetCurrentThreadId(),m_nReading));

    if(m_nReading < 0)
	{
#ifdef DBG
		OutputDebugString(L"WinMgmt: Repository detected more read unlocks than locks\n");
		DebugBreak();
#endif
		return Failed;
	}

    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < MaxRegistredReaders; i++)
    {
        if(m_adwReaders[i].ThreadId == dwThreadId)
        {
            m_adwReaders[i].ThreadId = 0;
            break;
        }
    }

    // If all readers are gone, allow writers in
    // =========================================

    if(m_nReading == 0)
    {
        // this is for the read lock acquired on one thread and release on one other                
        m_dwArrayIndex = 0;
        
        PRINTF("%d is the last reader\n", GetCurrentThreadId());
        PRINTF("Set write\n");
        if(!SetEvent(m_hCanWrite))
        {
#ifdef DBG
            DebugBreak();
#endif
            return Failed;
        }
        PRINTF("Done\n");
    }
    else PRINTF("%d sees %d still reading\n", GetCurrentThreadId(), m_nReading);

    // Get out and return
    // ==================

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteLock(DWORD dwTimeout)
{
    PRINTF("%d wants to write\n", GetCurrentThreadId());

    // Get in line for getting any kind of lock. Those unlocking don't use this
    // critical section.
    // ========================================================================

    LockGuard<CriticalSection> lgEnter(m_csEntering);
    if (!lgEnter.locked())
    {
#ifdef DBG
        DebugBreak();
#endif
    	return TimedOut;
    }

    // We are the only ones allowed to get any kind of lock now
    // ========================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());

    // Wait for the event allowing writing to become signaled
    // ======================================================

    int nRes = WaitFor(m_hCanWrite, dwTimeout);
    PRINTF("%d got event\n", GetCurrentThreadId());
    if(nRes != NoError)
    {            
#ifdef DBG
        DebugBreak();
#endif
        return nRes;
    }

    // Enter internal critical section (unlockers use it too), increment the
    // number of writers (from 0 to 1) and disable both reading and writing
    // from now on.
    // ======================================================================

    LockGuard<CriticalSection> lgAll(m_csAll);
    if (!lgAll.locked())
    {
        if(!SetEvent(m_hCanWrite))
        {
#ifdef DBG
        	DebugBreak();
#endif
        };
#ifdef DBG
        DebugBreak();
#endif
        return TimedOut;
    }

    m_WriterId = GetCurrentThreadId();
    m_nWriting++;

    //DBG_PRINTFA((pBuff,"+ (%08x) %d W %d\n",GetCurrentThreadId(),m_nReading,m_nWriting));
    
    PRINTF("Reset both\n");
    ResetEvent(m_hCanWrite);
    ResetEvent(m_hCanRead);
    PRINTF("Done\n");

	if (m_nReading)
	{
#ifdef DBG
	    OutputDebugString(L"WinMgmt: Write lock aquired while read lock is aquired!\n");
	    DebugBreak();
#endif
	}

    // Get out and return
    // ==================
    PRINTF("%d begins to write\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteUnlock()
{
    PRINTF("%d wants to release writing\n", GetCurrentThreadId());

    // Enter lock determination critical section
    // =========================================

    LockGuard<CriticalSection> gl(m_csAll);

    while (!gl.locked())
    {
    	Sleep(20);
    	gl.acquire();
    };
    
    m_nWriting--;

    //DBG_PRINTFA((pBuff,"- (%08x) %d W %d\n",GetCurrentThreadId(),m_nReading,m_nWriting));
    
    m_WriterId = 0;
    if(m_nWriting < 0) 
	{
#ifdef DBG
		OutputDebugString(L"WinMgmt: Repository detected too many write unlocks\n");
		DebugBreak();
#endif
		return Failed;
	}

    // Allow readers and writers in
    // ============================

    PRINTF("%d released writing\n", GetCurrentThreadId());

    PRINTF("Set both\n");
    if(!SetEvent(m_hCanRead))
    {
#ifdef DBG
		DebugBreak();    
#endif
        return Failed;
    }
    else if(!SetEvent(m_hCanWrite))
    {
#ifdef DBG
		DebugBreak();    
#endif
        return Failed;
    }
    else
    {
        PRINTF("Done\n");
        return NoError;
    }
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WaitFor(HANDLE hEvent, DWORD dwTimeout)
{
    DWORD dwRes;
    dwRes = WaitForSingleObject(hEvent, dwTimeout);

    // Analyze the error code and convert to ours
    // ==========================================

    if(dwRes == WAIT_OBJECT_0) return NoError;
    else if(dwRes == WAIT_TIMEOUT) return TimedOut;
    else return Failed;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::DowngradeLock()
{
    // Enter lock determination critical section
    // =========================================
    LockGuard<CriticalSection> gl(m_csAll);

    while (!gl.locked())
    {
    	Sleep(20);
    	gl.acquire();
    };

    m_nWriting--;
    m_WriterId = 0;    

    if(!SetEvent(m_hCanRead))
    {
        DebugBreak();
        return Failed;
    }

    m_nReading++;
    if (1 != m_nReading)
    {
#ifdef DBG
    	DebugBreak();
#endif
    }

    //DBG_PRINTFA((pBuff,"+ (%08x) %d\n",GetCurrentThreadId(),m_nReading));    
    
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    if (m_dwArrayIndex < MaxRegistredReaders)
    {
        m_adwReaders[m_dwArrayIndex].ThreadId = dwThreadId;
        ULONG Hash;
        //RtlCaptureStackBackTrace(1,MaxTraceSize,m_adwReaders[m_dwArrayIndex].Trace,&Hash);
        m_dwArrayIndex++;
    }
   
    return NoError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\index.h ===
#ifndef __A51_INDEX__H_
#define __A51_INDEX__H_

#include "btr.h"


class CBtrIndex
{
    DWORD m_dwPrefixLength;
    CBTree bt;
    CBTreeFile ps;

    BOOL CopyStringToWIN32_FIND_DATA(
        LPSTR pszSource,
        LPWSTR wszDest,
        bool bCopyFullPath = false
        );

public:
    CBtrIndex();
   ~CBtrIndex();

    long Shutdown(DWORD dwShutDownFlags);

    long Initialize(DWORD dwPrefixLength, LPCWSTR wszRepositoryDir, 
                    CPageSource* pSource );
    long Create(LPCWSTR wszFileName);
    long Delete(LPCWSTR wszFileName);
    long FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd, void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    long FindClose(void* pHandle);

    long IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle);
    long IndexEnumerationEnd(void *pHandle);
    long IndexEnumerationNext(void *pHandle, CFileName &wszFileName, bool bCopyFullPath = false);

    long ReadNextIndex(const wchar_t *wszSearch, CFileName &wszNextIndex);


    long InvalidateCache();

    long FlushCaches();

    CBTree& GetTree() {return bt;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\main.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <commain.h>
#include <clsfac.h>
#include <creposit.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

DEFINE_GUID(CLSID_A51Repository, 
0x7998dc37, 0xd3fe, 0x487c, 0xa6, 0x0a, 0x77, 0x01, 0xfc, 0xc7, 0x0c, 0xc6);

class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_A51Repository, 
            new CSimpleClassFactory<CRepository>(GetLifeControl()), 
            L"A51 Repository", TRUE);

        return S_OK;
    }

    HRESULT InitializeCom()
    {
        return CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\objheap.cpp ===
//***************************************************************************
//
//  (c) 2001 by Microsoft Corp.  All Rights Reserved.
//
//***************************************************************************

#include "precomp.h"
#include <wbemcomn.h>
#include "a51tools.h"
#include "objheap.h"
#include "index.h"
#include "creposit.h"

//*******************************************************************
//*******************************************************************
long CObjectHeap::Initialize(CPageSource  * pAbstractSource, 
                             WCHAR * wszBaseName,
                             DWORD dwBaseNameLen)
{
    if (m_bInit)
        return ERROR_SUCCESS;
        
    long lRes;
    
    lRes = m_Heap.Initialize(pAbstractSource);

    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = m_Index.Initialize(dwBaseNameLen, wszBaseName, pAbstractSource);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    m_bInit = TRUE;

    return lRes;
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::Uninitialize(DWORD dwShutDownFlags)
{
    if (!m_bInit)
        return ERROR_SUCCESS;
        
    m_Index.Shutdown(dwShutDownFlags);

    m_Heap.Shutdown(dwShutDownFlags);

    m_bInit = FALSE;

    return ERROR_SUCCESS;
}

//*******************************************************************
//*******************************************************************
void CObjectHeap::InvalidateCache()
{
    m_Index.InvalidateCache();
    m_Heap.InvalidateCache();
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::GetIndexFileName(LPCWSTR wszFilePath, CFileName& wszIndexFileName)
{
    WIN32_FIND_DATAW wfd;

    long lRes = m_Index.FindFirst(wszFilePath, &wfd, NULL);
    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    StringCchCopyW(wszIndexFileName, wszIndexFileName.Length(), wfd.cFileName);
    return ERROR_SUCCESS;
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::GetFileInfo(LPCWSTR wszFilePath, TPage *pnPage, TOffset* pnOffset,
                            DWORD* pdwLength)
{
    CFileName wszIndexFileName;
    if(wszIndexFileName == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = GetIndexFileName(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ParseInfoFromIndexFile(wszIndexFileName, pnPage, pnOffset, pdwLength);
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::ParseInfoFromIndexFile(LPCWSTR wszIndexFileName, 
                                        TPage *pnPage,
                                        TOffset* pnOffset, 
                                        DWORD* pdwLength)
{
    WCHAR* pDot = wcschr(wszIndexFileName, L'.');
    if(pDot == NULL)
        return ERROR_INVALID_PARAMETER;

    WCHAR* pwc = pDot+1;
    *pnPage = 0;
    while(*pwc && *pwc != L'.')
    {
        *pnPage = (*pnPage * 10) + (*pwc - '0');
        pwc++;
    }

    if(*pwc != L'.')
        return ERROR_INVALID_PARAMETER;

    pwc++;

    *pnOffset = 0;
    while(*pwc && *pwc != L'.')
    {
        *pnOffset = (*pnOffset * 10) + (*pwc - '0');
        pwc++;
    }

    if(*pwc != L'.')
        return ERROR_INVALID_PARAMETER;

    pwc++;

    *pdwLength = 0;
    while(*pwc && *pwc != L'.')
    {
        *pdwLength = (*pdwLength * 10) + (*pwc - '0');
        pwc++;
    }

    return ERROR_SUCCESS;
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::CreateIndexFile(LPCWSTR wszFilePath, 
                                  TPage nPage, 
                                  TOffset nOffset,
                                  DWORD dwLength)
{
    //
    // Simply append the numbers to the file path
    //

    CFileName wszIndexFilePath;
    if(wszIndexFilePath == NULL)
        return ERROR_OUTOFMEMORY;

    StringCchPrintfW(wszIndexFilePath, wszIndexFilePath.Length(), L"%s.%u.%u.%u",
        wszFilePath, nPage, nOffset, dwLength);

    return CreateZeroLengthFile(wszIndexFilePath);
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::DeleteIndexFile(LPCWSTR wszFilePath, LPCWSTR wszIndexFileName)
{
    //
    // Construct the full path to the index file by concatenating the directory 
    // of the original file with the name
    //

    CFileName wszIndexFilePath;
    if(wszIndexFilePath == NULL)
        return ERROR_OUTOFMEMORY;

    WCHAR* pwcLastSlash = wcsrchr(wszFilePath, L'\\');
    if(pwcLastSlash == NULL)
        return ERROR_INVALID_PARAMETER;

    int nPrefixLen = (pwcLastSlash - wszFilePath + 1);
    memcpy(wszIndexFilePath, wszFilePath, nPrefixLen * sizeof(WCHAR));

    StringCchCopyW(wszIndexFilePath + nPrefixLen, wszIndexFilePath.Length() - nPrefixLen, wszIndexFileName);
    return DeleteZeroLengthFile(wszIndexFilePath);
}

    

//*******************************************************************
//*******************************************************************
long CObjectHeap::CreateZeroLengthFile(LPCWSTR wszFilePath)
{
    return m_Index.Create(wszFilePath);
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::DeleteZeroLengthFile(LPCWSTR wszFilePath)
{
    return m_Index.Delete(wszFilePath);
}
    
//*******************************************************************
//*******************************************************************
long CObjectHeap::WriteAllocation(DWORD dwDataLength, BYTE* pData, TPage *pnPage, TOffset *pnOffset)
{
    return m_Heap.WriteNewBuffer(dwDataLength, pData, pnPage, pnOffset);
}
//*******************************************************************
//*******************************************************************
long CObjectHeap::WriteExistingAllocation(TPage nOldPage, TOffset nOldOffset, DWORD dwDataLength, BYTE *pBuffer, DWORD *pnNewPage, DWORD *pnNewOffset)
{
    return m_Heap.WriteExistingBuffer(dwDataLength, pBuffer, nOldPage, nOldOffset, pnNewPage, pnNewOffset);
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::ReadAllocation(TPage nPage, TOffset nOffset, DWORD dwDataLength, BYTE* pBuffer)
{
    //
    // Prepare a buffer with the complete allocation
    //

    BYTE* pAllocation;
    DWORD dwReadLength;

    long lRes = m_Heap.ReadBuffer(nPage, nOffset, &pAllocation, &dwReadLength);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if (dwReadLength != dwDataLength)
    {
        _ASSERT(0, L"WinMgmt: Buffer length is not the expected length!\n");
    }

    memcpy(pBuffer, pAllocation, dwDataLength);

    delete [] pAllocation;

    return ERROR_SUCCESS;
}
    

//*******************************************************************
//*******************************************************************
long CObjectHeap::WriteObject(LPCWSTR wszFilePath1, LPCWSTR wszFilePath2, DWORD dwBufferLen, BYTE* pBuffer)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;

    long lRes;

    if(dwBufferLen == 0)
    {
        //
        // We do not use the heap for 0-length files, we create them directly
        //

        return CreateZeroLengthFile(wszFilePath1);
    }

    //
    // Now, check if this file already exists
    //

    CFileName wszIndexFileName1;
    if(wszIndexFileName1 == NULL)
        return ERROR_OUTOFMEMORY;

    lRes = GetIndexFileName(wszFilePath1, wszIndexFileName1);
    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_SUCCESS)
        return lRes;

    if(lRes == ERROR_SUCCESS)
    {
        //
        // Already there. 
        //

        TPage nOldPage;
        TOffset nOldOffset;
        DWORD dwOldLength;
        TPage nNewPage;
        TOffset nNewOffset;

        lRes = ParseInfoFromIndexFile(wszIndexFileName1, &nOldPage, &nOldOffset, &dwOldLength);
        if(lRes != ERROR_SUCCESS)
            return lRes;


        //
        // Enough space in place --- just write the data and update the
        // length
        //

        lRes = WriteExistingAllocation(nOldPage, nOldOffset, dwBufferLen, pBuffer, &nNewPage, &nNewOffset);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        if((dwOldLength != dwBufferLen) || (nOldPage != nNewPage) || (nOldOffset != nNewOffset))
        {

            //
            // One of the bits of the path has changed so we need to re-create the index
            //

            lRes = DeleteIndexFile(wszFilePath1, wszIndexFileName1);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            lRes = CreateIndexFile(wszFilePath1, nNewPage, nNewOffset, dwBufferLen);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            if (wszFilePath2)
            {
                CFileName wszIndexFileName2;
                if(wszIndexFileName2 == NULL)
                    return ERROR_OUTOFMEMORY;
                lRes = GetIndexFileName(wszFilePath2, wszIndexFileName2);
                if(lRes != ERROR_SUCCESS)
                    return lRes;

                lRes = DeleteIndexFile(wszFilePath2, wszIndexFileName2);
                if(lRes != ERROR_SUCCESS)
                    return lRes;

                lRes = CreateIndexFile(wszFilePath2, nNewPage, nNewOffset, dwBufferLen);
                if(lRes != ERROR_SUCCESS)
                    return lRes;
            }
        }

        return ERROR_SUCCESS;
    }

    //
    // it wasn't there
    //

    TPage nPage;
    TOffset nOffset;

    lRes = WriteAllocation(dwBufferLen, pBuffer, &nPage, &nOffset);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = CreateIndexFile(wszFilePath1, nPage, nOffset, dwBufferLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if (wszFilePath2)
        lRes = CreateIndexFile(wszFilePath2, nPage, nOffset, dwBufferLen);
    
    return lRes;
}

//***********************************************************************
//***********************************************************************
long CObjectHeap::WriteLink(LPCWSTR wszLinkPath)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;

    return CreateZeroLengthFile(wszLinkPath);
}
//*******************************************************************
//*******************************************************************
long CObjectHeap::ReadObject(LPCWSTR wszFilePath, DWORD* pdwLength, BYTE** ppBuffer)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;    

    long lRes;

    //
    // Find the file
    //

    TPage nPage;
    TOffset nOffset;
    lRes = GetFileInfo(wszFilePath, &nPage, &nOffset, pdwLength);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Read the allocation
    //

    *ppBuffer = (BYTE*)TempAlloc(*pdwLength);
    if(*ppBuffer == NULL)
        return ERROR_OUTOFMEMORY;

    lRes = ReadAllocation(nPage, nOffset, *pdwLength, *ppBuffer);
    if(lRes != ERROR_SUCCESS)
    {
        TempFree(*ppBuffer);
        return lRes;
    }

    return ERROR_SUCCESS;
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::DeleteLink(LPCWSTR wszFilePath)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;    

    //
    // Find the index file
    //

    CFileName wszIndexFileName;
    if(wszIndexFileName == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = GetIndexFileName(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    //If we have any index information at the end of the path we need to add that to
    //the main path and delete that.  The delete requires an accurate path.
    CFileName wszActualFileName;
    if(wszActualFileName == NULL)
        return ERROR_OUTOFMEMORY;

    StringCchCopyW(wszActualFileName, wszActualFileName.Length(), wszFilePath);
    wchar_t *wszDot = wcschr(wszIndexFileName, L'.');
    if (wszDot != NULL)
        StringCchCatW(wszActualFileName, wszActualFileName.Length(), wszDot);

    return DeleteZeroLengthFile(wszActualFileName);
}
//*******************************************************************
//*******************************************************************
long CObjectHeap::DeleteObject(LPCWSTR wszFilePath)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;    

    //
    // Find the index file
    //

    CFileName wszIndexFileName;
    if(wszIndexFileName == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = GetIndexFileName(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Delete the allocation
    //

    TPage nPage;
    TOffset nOffset;
    DWORD dwLength;
    lRes = ParseInfoFromIndexFile(wszIndexFileName, &nPage, &nOffset, &dwLength);
    if(lRes == ERROR_INVALID_PARAMETER)
    {
        _ASSERT(0, L"WinMgmt: Deleting an object that does not have details of where object is!\n");
        return ERROR_INVALID_OPERATION;
    }
    
    lRes = m_Heap.DeleteBuffer(nPage, nOffset);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    
    //
    // Delete the index itself
    //

    lRes = DeleteIndexFile(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ERROR_SUCCESS;
}

long CObjectHeap::DeleteNode(LPCWSTR wszNodeName)
{
    long lRes = 0;
    void *handle;
    CFileName wszFileName;
    if (wszFileName == 0)
        return ERROR_OUTOFMEMORY;
    CFileName wszFullFileName;
    if (wszFullFileName == 0)
        return ERROR_OUTOFMEMORY;
    
    lRes = IndexEnumerationBegin(wszNodeName, &handle);
    if (lRes == ERROR_NO_MORE_FILES)
        lRes = 0;
    if (lRes)
        return lRes;

    while ((lRes = IndexEnumerationNext(handle, wszFileName, true)) == ERROR_SUCCESS)
    {
        StringCchCopyW(wszFullFileName, MAX_PATH, g_Glob.GetRootDir());
        StringCchCatW(wszFullFileName, MAX_PATH, L"\\");
        StringCchCatW(wszFullFileName, MAX_PATH, wszFileName);

        lRes = DeleteZeroLengthFile(wszFullFileName);
        if (lRes)
        {
            break;
        }

        TPage nPage;
        TOffset nOffset;
        DWORD dwLength;
        lRes = ParseInfoFromIndexFile(wszFullFileName+g_Glob.GetRootDirLen(), &nPage, &nOffset, &dwLength);
        if(lRes != ERROR_INVALID_PARAMETER)
        {
            if (!KeyRootInstancePath(wszFullFileName+g_Glob.GetRootDirLen()+1))
            {
                lRes = m_Heap.DeleteBuffer(nPage, nOffset);
                if(lRes != ERROR_SUCCESS)
                {
                    break;
                }
            }
        }

    }

    IndexEnumerationEnd(handle);
    if (lRes == ERROR_NO_MORE_FILES)
        lRes = 0;
    return lRes;
}

bool CObjectHeap::KeyRootInstancePath(const wchar_t *wszPath)
{
    WCHAR* pDot = wcschr(wszPath, L'\\');
    if(pDot == NULL)
        return false;

    pDot++;

    pDot = wcschr(pDot, L'\\');
    if(pDot == NULL)
        return false;

    pDot++;

    if ((*pDot == L'I') && (*(pDot+1) == L'_'))
        return true;
    else
        return false;
}
long CObjectHeap::ObjectEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
{
    return IndexEnumerationBegin(wszSearchPrefix, ppHandle);
}

long CObjectHeap::ObjectEnumerationEnd(void *pHandle)
{
    return IndexEnumerationEnd(pHandle);
}

long CObjectHeap::ObjectEnumerationNext(void *pHandle, CFileName &wszFileName, BYTE **ppBlob, DWORD *pdwSize)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;  
    
    long lRes = m_Index.IndexEnumerationNext(pHandle, wszFileName);

    if (lRes == ERROR_SUCCESS)
    {
        //We need to retrieve the object from the heap!
        TPage nPage;
        TOffset nOffset;
        DWORD dwLength;
        lRes = ParseInfoFromIndexFile(wszFileName, &nPage, &nOffset, &dwLength);
        if(lRes == ERROR_INVALID_PARAMETER)
            lRes = ERROR_SUCCESS;    //This is a plain enumeration, no blobs associated with it
        else
        {
            //Remove extra stuff from end of string...
            for (int nCount = 0, nIndex = wcslen(wszFileName); nCount != 3; nIndex --)
            {
                if (wszFileName[nIndex-1] == L'.')
                {
                    if (++nCount == 3)
                        wszFileName[nIndex-1] = L'\0';
                }

            }
            DWORD dwSize = 0;
            lRes = m_Heap.ReadBuffer(nPage, nOffset, ppBlob, &dwSize);
            if ((lRes == ERROR_SUCCESS) && (dwSize != dwLength))
            {
                _ASSERT(0, L"WinMgmt: Buffer size is not the expected length!\n");
            }
            *pdwSize = dwLength;
        }
    }
    return lRes;
}

long CObjectHeap::ObjectEnumerationFree(void *pHandle, BYTE *pBlob)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION; 

    delete [] pBlob;
    
    return ERROR_SUCCESS;
}

long CObjectHeap::IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;
    return m_Index.IndexEnumerationBegin(wszSearchPrefix, ppHandle);
}
long CObjectHeap::IndexEnumerationEnd(void *pHandle)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;    
    return m_Index.IndexEnumerationEnd(pHandle);
}
long CObjectHeap::IndexEnumerationNext(void *pHandle, CFileName &wszFileName, bool bCopyFullPath)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;  
    
    long lRes = m_Index.IndexEnumerationNext(pHandle, wszFileName, bCopyFullPath);

    if ((lRes == ERROR_SUCCESS) && !bCopyFullPath)
    {
        wchar_t *pDot = wcschr(wszFileName, L'.');
        if (pDot)
            *pDot = L'\0';
    }

    return lRes;
}

long CObjectHeap::FlushCaches()
{
    long lRes = m_Index.FlushCaches();
    if (lRes == 0)
        lRes = m_Heap.FlushCaches();
    return lRes;
}

long CObjectHeap::ReadNextIndex(CFileName &wszSearch, CFileName &wszNextIndex)
{
    if (!m_bInit)
        return ERROR_INVALID_OPERATION;  

    return m_Index.ReadNextIndex(wszSearch, wszNextIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\objheap.h ===
//***************************************************************************
//
//  (c) 2001 by Microsoft Corp.  All Rights Reserved.
//
//***************************************************************************

#ifndef __A51_OBJHEAP__H_
#define __A51_OBJHEAP__H_

#include "index.h"
#include "VarObjHeap.h"

typedef DWORD TOffset;
typedef DWORD TPage;

class CObjectHeap
{
protected:
    BOOL      m_bInit;
    
    CVarObjHeap m_Heap;
    CBtrIndex m_Index;

	bool KeyRootInstancePath(const wchar_t *wszPath);


public:
    CObjectHeap() :m_bInit(FALSE)
    {}
    virtual ~CObjectHeap(){}

    long Initialize(CPageSource  * pAbstractSource, 
                    WCHAR * wszBaseName,
                    DWORD dwBaseNameLen);
                    
    long Uninitialize(DWORD dwShutDownFlags);

	//Transaction aborts require caches to be flushed and re-read
    void InvalidateCache();

	long FlushCaches();

	//File read/write methods
    long WriteObject(LPCWSTR wszFilePath1, LPCWSTR wszFilePath2, DWORD dwBufferLen, BYTE* pBuffer);
    long WriteLink(LPCWSTR wszLinkPath);
    long DeleteObject(LPCWSTR wszFilePath);
    long DeleteLink(LPCWSTR wszLinkPath);
    long DeleteNode(LPCWSTR wszNodeName);

    long ReadObject(LPCWSTR wszFilePath, DWORD* pdwBufferLen, BYTE** ppBuffer);
    long ReadNextIndex(CFileName &wszSearch, CFileName &wszNextIndex);

    // for the dump utility
    CBtrIndex * GetIndex(){ return &m_Index; };
    CVarObjHeap * GetFileHeap(){ return &m_Heap; };
    
	long ObjectEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle);
	long ObjectEnumerationEnd(void *pHandle);
	long ObjectEnumerationNext(void *pHandle, CFileName &wszFileName, BYTE **ppBlob, DWORD *pdwSize);
	long ObjectEnumerationFree(void *pHandle, BYTE *pBlob);

	long IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle);
	long IndexEnumerationEnd(void *pHandle);
	long IndexEnumerationNext(void *pHandle, CFileName &wszFileName, bool bCopyFullPath = false);

protected:
    long GetIndexFileName(LPCWSTR wszFilePath, CFileName& wszIndexFileName);
    long GetFileInfo(LPCWSTR wszFilePath, TPage *pnPage, TOffset* pnOffset, DWORD* pdwLength);
    long ParseInfoFromIndexFile(LPCWSTR wszIndexFileName, TPage *pnPage, TOffset* pnOffset, DWORD* pdwLength);
    long CreateIndexFile(LPCWSTR wszFilePath, TPage nPage, TOffset nOffset, DWORD dwLength);
    long DeleteIndexFile(LPCWSTR wszFilePath, LPCWSTR wszIndexFileName);
    long CreateZeroLengthFile(LPCWSTR wszFilePath);
    long DeleteZeroLengthFile(LPCWSTR wszFilePath);
    long WriteAllocation(DWORD dwDataLength, BYTE* pData, TPage *pnPage, TOffset *pnOffset);
    long WriteExistingAllocation(TPage nOldPage, TOffset nOldOffset, DWORD dwBufferLen, BYTE *pBuffer, DWORD *pnNewPage, DWORD *pnNewOffset);
    long ReadAllocation(TPage nPage, TOffset nOffset, DWORD dwDataLength, BYTE* pBuffer);
};

    

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "corepol.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS
#include <windows.h>
#include <ole2.h>
#include <wincrypt.h>
#include <comdef.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\pagemgr.h ===
//***************************************************************************
//
//  (c) 2001 by Microsoft Corp.  All Rights Reserved.
//
//  PAGEMGR.H
//
//  Declarations for CPageFile, CPageSource for WMI repository for
//  Windows XP.
//
//  21-Feb-01       raymcc
//
//***************************************************************************

#ifndef _PAGEMGR_H_
#define _PAGEMGR_H_

#define WMIREP_PAGE_SIZE (8192)

#define WMIREP_INVALID_PAGE   0xFFFFFFFF
#define WMIREP_RESERVED_PAGE  0xFFFFFFFE

#define WMIREP_OBJECT_DATA L"OBJECTS.DATA"
#define WMIREP_BTREE_DATA L"INDEX.BTR"

#define WMIREP_MAP_1 L"MAPPING1.MAP"
#define WMIREP_MAP_2 L"MAPPING2.MAP"
#define WMIREP_MAP_VER L"MAPPING.VER"

//Old files for upgrade purpose only
#define WMIREP_OBJECT_MAP  L"OBJECTS.MAP"
#define WMIREP_OBJECT_MAP_NEW  L"OBJECTS.MAP.NEW"
#define WMIREP_BTREE_MAP  L"INDEX.MAP"
#define WMIREP_BTREE_MAP_NEW  L"INDEX.MAP.NEW"
#define WMIREP_ROLL_FORWARD L"ROLL_FORWARD"

#include <vector>
#include <wstlallc.h>
#include <wstring.h>
#include <sync.h>

typedef LONG NTSTATUS;

struct SCachePage
{
    BOOL   m_bDirty;
    DWORD  m_dwPhysId;
    LPBYTE m_pPage;

    SCachePage() { m_bDirty = 0; m_dwPhysId = 0; m_pPage = 0; }
   ~SCachePage() { if (m_pPage) delete [] m_pPage; }
};

class AutoClose
{
    HANDLE m_hHandle;
public:
    AutoClose(HANDLE h) { m_hHandle = h; }
   ~AutoClose() { CloseHandle(m_hHandle); }
};

class CPageCache
{
private:
	const wchar_t *m_wszStoreName;

    DWORD   m_dwPageSize;
    DWORD   m_dwCacheSize;

    DWORD   m_dwCachePromoteThreshold;
    DWORD   m_dwCacheSpillRatio;

    DWORD   m_dwLastFlushTime;
    DWORD   m_dwWritesSinceFlush;
    DWORD   m_dwLastCacheAccess;
    DWORD   m_dwReadHits;
    DWORD   m_dwReadMisses;
    DWORD   m_dwWriteHits;
    DWORD   m_dwWriteMisses;

    HANDLE  m_hFile;

    // Page r/w cache
    std::vector <SCachePage *, wbem_allocator<SCachePage *> > m_aCache;
public:
    DWORD ReadPhysPage(                         // Does a real disk access
        IN  DWORD   dwPage,                     // Always physical ID
        OUT LPBYTE *pPageMem                    // Returns read-only pointer (copy of ptr in SCachePage struct)
        );

    DWORD WritePhysPage(                        // Does a real disk access
        DWORD dwPageId,                         // Always physical ID
        LPBYTE pPageMem                         // Read-only; doesn't acquire pointer
        );

    DWORD Spill();
    DWORD Empty();

    // Private methods
public:
    CPageCache(const wchar_t *wszStoreName);
   ~CPageCache();

    DWORD Init(
        LPCWSTR pszFilename,                    // File
        DWORD dwPageSize,                       // In bytes
        DWORD dwCacheSize = 64,                 // Pages in cache
        DWORD dwCachePromoteThreshold = 16,     // When to ignore promote-to-front
        DWORD dwCacheSpillRatio = 4             // How many additional pages to write on cache write-through
        );

    DWORD DeInit();

    // Cache operations

    DWORD Write(                    // Only usable from within a transaction
        DWORD dwPhysId,
        LPBYTE pPageMem             // Acquires memory (operator new required)
        );

    DWORD Read(
        IN DWORD dwPhysId,
        OUT LPBYTE *pMem            // Use operator delete
        );

    DWORD Flush();

    DWORD GetFileSize(LARGE_INTEGER *pFileSize);

    DWORD EmptyCache() { DWORD dwRet = Flush();  if (dwRet == ERROR_SUCCESS) Empty(); return dwRet; }
    void  Dump(FILE *f);

    DWORD GetReadHits() { return m_dwReadHits; }
    DWORD GetReadMisses() { return m_dwReadMisses; }
    DWORD GetWriteHits()  { return m_dwWriteHits; }
    DWORD GetWriteMisses() { return m_dwWriteMisses; }
    SIZE_T GetCacheSize(){ return m_aCache.size(); };
};

class CPageFile
{
private:
    friend class CPageSource;

	const wchar_t *m_wszStoreName;
	
    LONG              m_lRef;
    DWORD             m_dwPageSize;
    DWORD             m_dwCacheSpillRatio;

    CRITICAL_SECTION  m_cs;
    bool m_bCsInit;

    CPageCache        m_Cache;
    BOOL              m_bInTransaction;
    DWORD             m_dwLastCheckpoint;
    DWORD             m_dwTransVersion;

    // Generation A Mapping
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPageMapA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPhysFreeListA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aLogicalFreeListA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aReplacedPagesA;
    DWORD m_dwPhysPagesA;

    // Generation B Mapping
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPageMapB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPhysFreeListB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aLogicalFreeListB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aReplacedPagesB;
    DWORD m_dwPhysPagesB;

    std::vector <DWORD, wbem_allocator<DWORD> > m_aDeferredFreeList;

public: // temp for testing
    // Internal methods
    DWORD Trans_Begin();
    DWORD Trans_Rollback();
    DWORD Trans_Commit();

    DWORD Trans_Checkpoint(HANDLE hFile);

    DWORD InitFreeList();
    DWORD ResyncMaps();
    DWORD ReadMap(HANDLE hFile);
    DWORD WriteMap(HANDLE hFile);

    DWORD ValidateMapFile();

    DWORD AllocPhysPage(DWORD *pdwId);

    DWORD ReclaimLogicalPages(
        DWORD dwCount,
        DWORD *pdwId
        );

    DWORD GetTransVersion() { return m_dwTransVersion; }
    void IncrementTransVersion(){ m_dwTransVersion++; }
    void DumpFreeListInfo();

public:

	CPageFile(const wchar_t *wszStoreName);

   ~CPageFile();

   //First-time initializatoin of structure
    DWORD Init(
    	WString &sMainFile,
        DWORD  dwRepPageSize,
        DWORD  dwCacheSize,
        DWORD  dwCacheSpillRatio
        );

	//Clear all caches and structures out
   DWORD DeInit();


    static DWORD RollForwardV1Maps(WString& sDirectory);
    
    ULONG AddRef();
    ULONG Release();

    DWORD GetPage(
        DWORD dwId,                     // page zero is admin page; doesn't require NewPage() call
        DWORD dwFlags,
        LPVOID pPage
        );

    DWORD PutPage(
        DWORD dwId,
        DWORD dwFlags,
        LPVOID pPage
        );

    DWORD NewPage(
        DWORD dwFlags,
        DWORD dwCount,
        DWORD *pdwFirstId
        );

    DWORD FreePage(
        DWORD dwFlags,
        DWORD dwId
        );

    DWORD GetPageSize() { return m_dwPageSize; }
    DWORD GetNumPages() { return m_aPageMapB.size(); }
    DWORD GetPhysPage(DWORD dwLogical) { return m_aPageMapB[dwLogical]; }

	DWORD EmptyCache() 
	{ 
		return m_Cache.EmptyCache(); 
	}

#ifdef WMI_PRIVATE_DBG
	DWORD CPageFile::DumpFileInformation(HANDLE hFile);
#endif

    void  Dump(FILE *f);

	DWORD CompactPages(DWORD dwNumPages);
};

class CPageSource
{
private:
	DWORD m_dwStatus;
    DWORD m_dwPageSize;

	DWORD m_dwCacheSize;
	DWORD m_dwCacheSpillRatio;

    DWORD m_dwLastCheckpoint;
    
    WString m_sDirectory;
    
    CPageFile m_BTreePF;
    CPageFile m_ObjPF;

    WString m_FileMainData;
    WString m_FileMainBtr;
    WString m_FileMap1;
    WString m_FileMap2;
    WString m_FileMapVer;

    HANDLE m_hFileMap1;
    HANDLE m_hFileMap2;
    HANDLE m_hFileMapVer;

    DWORD m_dwFileMapVer;
    DWORD Startup();

    DWORD OpenMapFiles();
    DWORD CloseMapFiles();

    DWORD V1ReposititoryExists(bool *pbV1RepositoryExists);
    DWORD V2ReposititoryExists(bool *pbV2RepositoryExists);
    DWORD UpgradeV1Maps();

	DWORD DeleteRepository();

public:
    CPageSource();
   ~CPageSource();

    DWORD Init( );

    DWORD Shutdown(DWORD dwFlags);

    DWORD GetBTreePageFile(OUT CPageFile **pPF);    // Use Release() when done
    DWORD GetObjectHeapPageFile(OUT CPageFile **pPF);  // Use Release() when done

    // Transactions

    DWORD BeginTrans();
    DWORD CommitTrans();
    DWORD RollbackTrans();

    // Checkpoint

    DWORD Checkpoint(bool bCompactPages);

	// Cache discard

	DWORD EmptyCaches();

    void Dump(FILE *f);

	//Compacts the last n physical pages of the files to the start of the file.
	//It does this for the BTree and ObjHeap.
	HRESULT CompactPages(DWORD dwNumPages);

	static BOOL FileExists(LPCWSTR pFile, NTSTATUS& lastStatus);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\lock.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.H

Abstract:

	Generic class for obtaining read and write locks to some resource. 

	See lock.h for all documentation.

	Classes defined:

	CLock

History:

	a-levn  5-Sept-96       Created.
	3/10/97     a-levn      Fully documented

--*/

#ifndef __GATEWAY__LOCK__H_
#define __GATEWAY__LOCK__H_

#include <corepol.h>
#include <lockst.h>
#include <statsync.h>

#ifdef DBG

class OperationStat
{
	
	enum { HistoryLength = 122 };
	DWORD signature;
	DWORD historycData_[HistoryLength];
	DWORD historyIndex_;
	DWORD opCount_;
	DWORD avgTime_;
	DWORD maxTime_;
	LONG zeroTime_;

	
public:
	static CStaticCritSec lock_;
	OperationStat() : 
	historyIndex_(0), opCount_(0), avgTime_(0), maxTime_(0),signature((DWORD)'nCpO')
	{
		memset(historycData_, 0, sizeof(historycData_));
	};
	void addTime(DWORD duration)
		{
		
 		if (duration==0) 
		{
			InterlockedIncrement(&zeroTime_);
 			return;
		}
		if (CStaticCritSec::anyFailure()) return ;
		
		EnterCriticalSection(&lock_);
		historycData_[historyIndex_++]=duration;
		historyIndex_%=HistoryLength;

		if (++opCount_ == 0)	++opCount_;
			
		double avg = (double)avgTime_  +  ((double)duration-avgTime_  )/opCount_;
		avgTime_ = (DWORD)avg;
		if (duration > maxTime_)
			{
			maxTime_ = duration;
			};
		LeaveCriticalSection(&lock_);
		};
};

extern OperationStat gTimeTraceReadLock;
extern OperationStat gTimeTraceWriteLock;
extern OperationStat gTimeTraceBackupLock;

class TimeTrace
{
	DWORD start_;
public:
	TimeTrace( ): 
		start_(GetTickCount())
		{ 	}
	~TimeTrace()
		{
		gTimeTraceBackupLock.addTime(GetTickCount()-start_);
		}
	
};

	#define TIMETRACEBACKUP TimeTrace timeTrace;
#else
	#define TIMETRACEBACKUP
#endif

//*****************************************************************************
//
//	class CLock
//
//	Generic class for obtaining read and write locks to some resource. 
//	Simultaneous reads are allowed, but no concurrent writes or concurrent 
//	read and write accesses are.
//
//	NOTE: this class is for in-process sinchronization only!
//
//	Usage: create an instance of this class and share it among the accessing
//	threads.  Threads must call member functions of the same instance to 
//	obtain and release locks.
//
//*****************************************************************************
//
//	ReadLock
//
//	Use this function to request read access to the resource. Access will be
//	granted once no threads are writing on the resource. You must call 
//	ReadUnlock once you are done reading.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	ReadUnlock
//
//	Use this function to release a read lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	ReadUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//	WriteLock
//
//	Use this function to request write access to the resource. Access will be
//	granted once no threads are reading or writing on the resource. You must 
//	call WriteUnlock once you are done writing.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	WriteUnlock
//
//	Use this function to release a write lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	WriteUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//  DowngradeLock
//
//  Use this function to "convert" a Write lock into a Read lock. That is, if
//  you are currently holding a write lock and call DowngradeLock, you will 
//  be holding a read lock with the guarantee that no one wrote anything between
//  the unlock and the lock
//
//  Returns:
//
//      NoError     On Success
//      Failed      On system error or unmatched call
//
//******************************************************************************
class CLock
{
public:
	enum { NoError = 0, TimedOut, Failed };

	int ReadLock(DWORD dwTimeout = INFINITE);
	int ReadUnlock();
	int WriteLock(DWORD dwTimeout = INFINITE);
	int WriteUnlock();

	int DowngradeLock();

	CLock();
	~CLock();

protected:
	int WaitFor(HANDLE hEvent, DWORD dwTimeout);

protected:
	int m_nWriting;
	int m_nReading;
	int m_nWaitingToWrite;
	int m_nWaitingToRead;

	CriticalSection m_csEntering;
	CriticalSection m_csAll;
	HANDLE m_hCanWrite;
	HANDLE m_hCanRead;
	DWORD m_WriterId;
	//CFlexArray m_adwReaders;
	enum { MaxRegistredReaders = 16,
	       MaxTraceSize = 7};
	DWORD m_dwArrayIndex;
	struct {
		DWORD ThreadId;
		//PVOID  Trace[MaxTraceSize];
	} m_adwReaders[MaxRegistredReaders];
};

#ifdef DBG
class CAutoReadLock
{
	DWORD start;	
public:
	CAutoReadLock(CLock *lock) : m_lock(lock), m_bLocked(FALSE) {  }
	~CAutoReadLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->ReadUnlock(); m_bLocked = FALSE; gTimeTraceReadLock.addTime(GetTickCount()-start);} }
	bool Lock()   {if (!m_bLocked) { start = GetTickCount(); return m_bLocked = (CLock::NoError == m_lock->ReadLock())  ; } else {return false;}; }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
class CAutoWriteLock
{
	DWORD start;
public:
	CAutoWriteLock(CLock *lock) : m_lock(lock), m_bLocked(FALSE) { }
	~CAutoWriteLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->WriteUnlock(); m_bLocked = FALSE; gTimeTraceWriteLock.addTime(GetTickCount()-start);} }
	bool Lock()   {if (!m_bLocked) { start = GetTickCount(); return m_bLocked = (CLock::NoError == m_lock->WriteLock()); } else { return false; }; }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};

#else
class CAutoReadLock
{
	
public:
	CAutoReadLock(CLock *lock) : m_lock(lock), m_bLocked(FALSE) {  }
	~CAutoReadLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->ReadUnlock(); m_bLocked = FALSE; } }
	bool Lock()   {if (!m_bLocked) { return m_bLocked = (CLock::NoError == m_lock->ReadLock())  ; } else {return false;}; }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
class CAutoWriteLock
{
public:
	CAutoWriteLock(CLock *lock) : m_lock(lock), m_bLocked(FALSE) { }
	~CAutoWriteLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->WriteUnlock(); m_bLocked = FALSE; } }
	bool Lock()   {if (!m_bLocked) { return m_bLocked = (CLock::NoError == m_lock->WriteLock()); } else { return false; }; }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\pagemgr.cpp ===
//***************************************************************************
//
//  (c) 2001 by Microsoft Corp.  All Rights Reserved.
//
//  PAGEMGR.CPP
//
//  Declarations for CPageFile, CPageSource for WMI repository for
//  Windows XP.  This is a fully transacted high-speed page manager.
//
//  21-Feb-01       raymcc      first draft of interfaces
//  28-Feb-01       raymcc      first complete working model
//  18-Apr-01       raymcc      Final fixes for rollback; page reuse
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <helper.h>
#include <pagemgr.h>
#include <sync.h>
#include <wbemcomn.h>
#include <creposit.h>
#include <cwbemtime.h>
#include <evtlog.h>
#include <winmgmtr.h>
#include <autoptr.h>
//
//
/////////////////////////////////////////////////////

extern SECURITY_ATTRIBUTES g_SA;

#ifdef DBG
void ASSERT_DEBUG_BREAK(bool x) 	{if (!x) __try { DebugBreak(); } __except(EXCEPTION_EXECUTE_HANDLER){};}
#else
void ASSERT_DEBUG_BREAK(bool x){};
#endif

#define GETTIME( a )

//
//
/////////////////////////////////////////////////////

#define MAP_LEADING_SIGNATURE   0xABCD
#define MAP_TRAILING_SIGNATURE  0xDCBA

#define CURRENT_TRANSACTION        0x80000000
#define PREVIOUS_TRANSACTION       0x40000000

#define ALL_REPLACED_FLAGS       (CURRENT_TRANSACTION | PREVIOUS_TRANSACTION)

#define MERE_PAGE_ID(x)              (x & 0x3FFFFFFF)

//Max pages = MAX_DWORD/8K.  This is because we work in 8K pages, and the maximum size of a file is a DWORD because of
//the SetFilePosition we use, and don't use the TOP DWORD!
#define MAX_NUM_PAGES		0x7FFFF

void StripHiBits(std::vector <DWORD, wbem_allocator<DWORD> > &Array);
void MoveCurrentToPrevious(std::vector <DWORD, wbem_allocator<DWORD> > &Array);


/*
Map & cache orientation

(a) There are two types of page ids, logical and physical.  The logical
    ID is what is used by the external user, such as the B-tree or
    object heap.  The physical ID is the 0-origin page number into the
    file itself.  For each logical id, there is a corresponding physical
    id.  The decoupling is to allow transacted writes without multiple
    physical writes during commit/rollback, but to 'simulate' transactions
    by interchanging physical-to-logical ID mapping instead. The
    physical offset into the file is the ID * the page size.

(b) Logical ID is implied, and is the offset into the PhysicalID array
(c) Cache operation is by physical id only
(d) The physical IDs of the pages contain other transaction information.
    The MS 2 bits are transaction-related and only the lower 30 bits is the
    physical page id, and so must be masked out when computing offsets.
    The bits are manipulated during commit/rollback, etc.

(d) 0xFFFFFFFE is a reserved page, meaning a page that was allocated
    by NewPage, but has not yet been written for the first time using PutPage.
    This is merely validation technique to ensure pages are written only
    after they were requested.

(e) Cache is agnostic to the transaction methodology.  It is
    simply a physical page cache and has no knowledge of anything
    else. It is promote-to-front on all accesses.  For optimization
    purposes, there is no real movement if the promotion would
    move the page from a near-to-front to absolute-front location.
    This is the 'PromoteToFrontThreshold' in the Init function.
    Note that the cache ordering is by access and not sorted
    in any other way.  Lookups require a linear scan.
    It is possible that during writes new physical pages
    are added to the cache which are 'new extent' pages.  These
    are harmless.

    Map  PhysId             Cache
    [0]  5        /->       2   ->  bytes
    [1]  6       /          3   ->  bytes
    [2]  -1     /           4   ->  bytes
    [3]  3     /            5   ->  bytes
    [4]  2  <-/
    [5]  4


(f) Transaction & checkpoint algorithms

    First, the general process is this:

      1.  Begin transaction:
          (a) Generation A mapping and Generation B mapping member
            variables are identical. Each contains a page map
      2.  Operations within the transaction occur on Generation B
          mapping.  Cache spills are allowed to disk, as they are harmless.
      3.  At rollback, Generation B mapping is copied from Generation A.
      4.  At commit, Generation A is copied from Generation B.
      5.  At checkpoint, Generation A/B are identical and written to disk

    Cache spills & usage are irrelevant to intermediate transactions.

    There are special cases in terms of how pages are reused.  First,
    as pages are freed within a transaction, we cannot just blindly add them
    to the free list, since they might be part of the previous checkpoint
    page set.  This would allow them to be accidentally reused and then
    a checkpoint rollback could never succeed (the original page
    having been destroyed).

    As pages committed during the previous checkpoint are updated, they
    are written to new physical pages under the same logical id.  The old
    physical pages are added to the "Replaced Pages" array.  This allows
    them to be identified as new free list pages once the checkpoint
    occurs.   So, during the checkpoint, replaced pages are merged
    into the current free list.  Until that time, they are 'off limits',
    since we need them for a checkpoint rollback in an emergency.

    Within a transaction, as pages are acquired, they are acquired
    from the physical free list, or if there is no free list, new
    pages are requested.  It can happen that during the next transaction (still
    within the checkpoint), those pages need updating, whether for rewrite
    or delete.  Now, because we may have to roll back, we cannot simply
    add those replaced pages directly to the free list (allowing them
    to be reused by some other operation). Instead, they
    have to be part of a 'deferred free list'. Once the current
    transaction is committed, they can safely be part of the
    regular free list.

    The algorithm is this:

    (a) The physical Page ID is the lower 30 bits of the entry. The two high
        bits have a special meaning.

    (b) Writes result either in an update or a new allocation [whether
        from an extent or a reuse of the free list].  Any such page is marked
        with the CURRENT_TRANSACTION bit (the ms bit) which is merged into
        the phyiscal id. If this page is encountered again, we know it
        was allocated during the current transaction.

    (c) For UPDATES
            1. If the page ID is equal to 0xFFFFFFFE, then we need to
               allocate a new page, which is marked with CURRENT_TRANSACTION.
            2. If the physical page ID written has both high bits clear,
               it is a page being updated which was inherited from the previous
               checkpoint page set. We allocate and write to a new physical
               page, marking this new page with CURRENT_TRANSACTION.
               We add the old physical page ID directly to the m_xReplacedPages
               array. It is off-limits until the next checkpoint, at which
               point it is merged into the free list.
            3. If the physical page id already has CURRENT_TRANSACTION, we
               simply update the page in place.
            4. If the page has the PREVIOUS_TRANSACTION bit set, we allocate
               a new page so a rollback will protect it, and add this page
               to the DeferredFreeList array.  During a commit, these
               pages are merged into the FreeList.  During a rollback,
               we simply throw this array away.

    (d) For DELETE
           1. If the page has both hi bits clear, we add it to the ReplacedPages
              array.
           2. If the page has the CURRENT_TRANSACTION bit set, we add it to the free list.
              This page was never part of any previous operation and can be reused
              right away.
           3. If the page has the PREVIOUS_TRANSACTION bit set, it is added to the
              DeferredFreeList.

    (e) For COMMIT
           1.  All pages with the CURRENT_TRANSACTION bit set are changed to clear that
               bit and set the PREVIOUS_TRANSACTION bit instead.
           2.  All pages with the PREVIOUS_TRANSACTION bit are left intact.
           3.  All pages in the DeferredFreeList are added to the FreeList.

    (f) For ROLLBACK
           1.  All pages with the CURRENT_TRANSACTION bit are moved back into the
               free list (the bits are cleared).
           2.  All pages with the PREVIOUS_TRANSACTION bit are left intact.

    (g) For Checkpoint
           1.  All DeferredFreeList entries are added to FreeList.
           2.  All ReplacedPages are added to FreeList.
           3.  All ms bits are cleared for physical IDs.

     Proof:

        T1 = page set touched for transaction 1, T2=page set touched for transaction 2, etc.

        After T1-START, all new pages are marked CURRENT.  If all are updated n times,
        no new pages are required, since rollback brings us back to zero pages
        anyway.

        At T1-COMMIT, all CURRENT pages are marked PREVIOUS. This is the T1a
        page set.

        After T2-BEGIN, all new pages are marked CURRENT. Again, updating
        all T2 pages infinitely never extends the file beyond the size
        of T1a+T2 page sets. Further deleting and reusing T2 pages
        never affects T1a pages, proving that deleting a CURRENT page
        merits direct addition to the free list.

        Updating n pages from T1 requires n new pages.  As we update
        all the T1 pages, we need a total file size of T2+T1*2.  As
        we encounter T1a pages marked as PREVIOUS, we allocate CURRENT
        pages for T1b and then reuse those indefinitely.  Whether we update
        all T1a or delete all T1a, we must still protect the original T1a
        page set in case of rollback.  Therefore all touched pages of T1a
        are posted the deferred free list as they become replaced by T1b
        equivalents.

        At rollback, we simply throw away the deferred free list,
        and T1a is intact, since those physical pages were never touched.

        At commit, all T1a pages are now in T1b, and al T1a
        pages are now reusable, and of course were in fact added
        to the deferred free list, which is merged with the
        general free list at commit time.  T1b and T2 pages are now
        protected and marked PREVIOUS.

        On the transitive nature of PREVIOUS:

        Assume zero T1 pages are touched at T2-BEGIN, and there
        are only T2 updates, commit and then T3 is begun.  At
        this point, both T1/T2 sets are marked as PREVIOUS
        and not distinguished. T3 new allocations follow the
        same rules.  Obviously if all T1 pages are deleted, we
        still cannot afford to reuse them, since a rollback
        would need to see T1 pages intact.   Therefore at
        each commit, there is an effective identity shift where
            T1 = T2 UNION T1
            T3 becomes T2
        And we are in the 2-transaction problem space again.

        Unmarking pages completely makes them equal to the
        previous checkpoint page set.  They can be completely
        replaced with new physical pages, but never reused until
        the next checkpoint, which wastes space.

    */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//  CPageCache


//***************************************************************************
//
//  CPageCache::CPageCache
//
//***************************************************************************
//  rev2
CPageCache::CPageCache(const wchar_t *wszStoreName)
: m_wszStoreName(wszStoreName)
{
    m_hFile = INVALID_HANDLE_VALUE;

    m_dwPageSize = 0;
    m_dwCacheSize = 0;

    m_dwCachePromoteThreshold = 0;
    m_dwCacheSpillRatio = 0;

    m_dwLastFlushTime = GetCurrentTime();
    m_dwWritesSinceFlush = 0;
    m_dwLastCacheAccess = 0;

    m_dwReadHits = 0;
    m_dwReadMisses = 0;
    m_dwWriteHits = 0;
    m_dwWriteMisses = 0;
}

//***************************************************************************
//
//  CPageCache::Init
//
//  Initializes the cache.  Called once during startup.  If the file
//  can't be opened, the cache becomes invalid right at the start.
//
//***************************************************************************
// rev2
DWORD CPageCache::Init(
    LPCWSTR pszFilename,               // File
    DWORD dwPageSize,                  // In bytes
    DWORD dwCacheSize,                 // Pages in cache
    DWORD dwCachePromoteThreshold,     // When to ignore promote-to-front
    DWORD dwCacheSpillRatio            // How many additional pages to write on cache write-through
    )
{
    m_dwPageSize = dwPageSize;
    m_dwCacheSize = dwCacheSize;
    m_dwCachePromoteThreshold = dwCachePromoteThreshold;
    m_dwCacheSpillRatio = dwCacheSpillRatio;

    m_hFile = CreateFileW(pszFilename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, &g_SA,
            OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageCache::~CPageCache
//
//  Empties cache during destruct; called once at shutdown.
//
//***************************************************************************
//  rev2
CPageCache::~CPageCache()
{
	DeInit();
}

DWORD CPageCache::DeInit()
{

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
    Empty();

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageCache::Write()
//
//  Writes a page to the cache and promotes it to the front.  If the
//  page is already present, it is simply marked as dirty and promoted
//  to the front (if it is outside the promote-to-front threshold).
//  If cache is full and this causes overflow, it is handled by the
//  Cache_Spill() at the end.  Physical writes occur in Spill() only if
//  there is cache overflow.
//
//  Errors: Return codes only, sets permanent error status of object
//          once error has occurred.
//
//  On failure, the caller must invoked Cache::Reinit() before using
//  it any further.  On error DISK_FULL, there is not much of a point
//  in a Reinit() even though it is safe.
//
//***************************************************************************
// rev2
DWORD CPageCache::Write(
    DWORD dwPhysId,
    LPBYTE pPageMem
    )
{
    m_dwWritesSinceFlush++;
    m_dwLastCacheAccess = GetCurrentTime();

    // Search current cache.
    // =====================

    DWORD dwSize = m_aCache.size();

    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        if (pTest->m_dwPhysId == dwPhysId)
        {
            delete [] pTest->m_pPage;
            pTest->m_pPage = pPageMem;
            pTest->m_bDirty = TRUE;

            // Promote to front?
            // =================
            if (dwIx > m_dwCachePromoteThreshold)
            {
                try
                {
                    m_aCache.erase(m_aCache.begin()+dwIx);
                    m_aCache.insert(m_aCache.begin(), pTest);
                }
                catch (CX_MemoryException &)
                {
                    pTest->m_pPage = 0;
                    return ERROR_OUTOFMEMORY;
                }
            }
            m_dwWriteHits++;
            return NO_ERROR;
        }
    }

    // If here, no cache hit, so we create a new entry.
    // ================================================

    wmilib::auto_ptr<SCachePage> pCP( new SCachePage);
    if (NULL == pCP.get())
    	return ERROR_OUTOFMEMORY;


    pCP->m_dwPhysId = dwPhysId;
    pCP->m_pPage = 0;
    pCP->m_bDirty = TRUE;

    try
    {
        m_aCache.insert(m_aCache.begin(), pCP.get());
    }
    catch(CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    pCP->m_pPage = pPageMem;

    DWORD dwRes = Spill();
    if (ERROR_SUCCESS != dwRes)
    {
        pCP->m_pPage = 0;
        m_aCache.erase(m_aCache.begin());
        return dwRes;
    }

    m_dwWriteMisses++;
    pCP.release();
    return NO_ERROR;
}


//***************************************************************************
//
//  CPageCache::Read
//
//  Reads the requested page from the cache.  If the page isn't found
//  it is loaded from the disk file.  The cache size cannot change, but
//  the referenced page is promoted to the front if it is outside of
//  the no-promote-threshold.
//
//  A pointer directly into the cache mem is returned in <pMem>, so
//  the contents should be copied as soon as possible.
//
//  Errors: If the read fails due to ERROR_OUTOFMEMORY, then the
//  cache is permanently in an error state until Cache->Reinit()
//  is called.
//
//***************************************************************************
// rev2
DWORD CPageCache::Read(
    IN DWORD dwPhysId,
    OUT LPBYTE *pMem            // Read-only!
    )
{
    if (pMem == 0)
        return ERROR_INVALID_PARAMETER;

    m_dwLastCacheAccess = GetCurrentTime();

    // Search current cache.
    // =====================

    DWORD dwSize = m_aCache.size();

    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        if (pTest->m_dwPhysId == dwPhysId)
        {
            // Promote to front?

            if (dwIx > m_dwCachePromoteThreshold)
            {
                try
                {
                    m_aCache.erase(m_aCache.begin()+dwIx);
                    m_aCache.insert(m_aCache.begin(), pTest);
                }
                catch (CX_MemoryException &)
                {
                    return ERROR_OUTOFMEMORY;
                }
            }
            *pMem = pTest->m_pPage;
            m_dwReadHits++;
            return NO_ERROR;
        }
    }

    // If here, not found, so we have to read in from disk
    // and do a spill test.
    // ====================================================

    wmilib::auto_ptr<SCachePage> pCP(new SCachePage);
    if (NULL == pCP.get())
    	return ERROR_OUTOFMEMORY;

    pCP->m_dwPhysId = dwPhysId;
    pCP->m_bDirty = FALSE;
    pCP->m_pPage = 0;

    m_dwReadMisses++;

	DWORD dwRes = ReadPhysPage(dwPhysId, &pCP->m_pPage);
    if (ERROR_SUCCESS != dwRes)
        return  dwRes;

    try
    {
        m_aCache.insert(m_aCache.begin(), pCP.get());
    }
    catch(CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

	dwRes = Spill();
	if (ERROR_SUCCESS != dwRes)
	{
	   m_aCache.erase(m_aCache.begin());
	   return dwRes;
	}

    *pMem = pCP->m_pPage;   
    pCP.release(); // cache took ownership
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageCache::Spill
//
//  Checks for cache overflow and implements the spill-to-disk
//  algorithm.
//
//  Precondition: The cache is either within bounds or 1 page too large.
//
//  If the physical id of the pages written exceeds the physical extent
//  of the file, WritePhysPage will properly extend the file to handle it.
//
//  Note that if no write occurs during the spill, additional pages are
//  not spilled or written.
//
//***************************************************************************
//  rev2
DWORD CPageCache::Spill()
{
    BOOL bWritten = FALSE;
    DWORD dwRes = 0;
    DWORD dwSize = m_aCache.size();

    // See if the cache has exceeded its limit.
    // ========================================

    if (dwSize <= m_dwCacheSize)
        return NO_ERROR;

    // If here, the cache is too large by 1 element (precondition).
    // We remove the last page after checking to see if it is
    // dirty and needs writing.
    // ============================================================

    SCachePage *pDoomed = *(m_aCache.end()-1);
    if (pDoomed->m_bDirty)
    {
        dwRes = WritePhysPage(pDoomed->m_dwPhysId, pDoomed->m_pPage);
        if (dwRes != NO_ERROR)
        {
            return dwRes;
        }
        bWritten = TRUE;
    }
    delete pDoomed;

    try
    {
        m_aCache.erase(m_aCache.end()-1);
    }
    catch(CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    if (!bWritten)
        return NO_ERROR;

    // If here, we had a write.
    // Next, work through the cache from the end and write out
    // a few more pages, based on the spill ratio. We don't
    // remove these from the cache, we simply write them and
    // clear the dirty bit.
    // ========================================================

    DWORD dwWriteCount = 0;

    try
    {
        std::vector <SCachePage *>::reverse_iterator rit;
        rit = m_aCache.rbegin();

        while (rit != m_aCache.rend() && dwWriteCount < m_dwCacheSpillRatio)
        {
            SCachePage *pTest = *rit;
            if (pTest->m_bDirty)
            {
                dwRes = WritePhysPage(pTest->m_dwPhysId, pTest->m_pPage);
                if (dwRes)
                    return dwRes;
                pTest->m_bDirty = FALSE;
                dwWriteCount++;
            }
            rit++;
        }
    }
    catch(CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  CPageCache::WritePhysPage
//
//  Writes a physical page.
//
//***************************************************************************
// rev2
DWORD CPageCache::WritePhysPage(
    IN DWORD dwPageId,
    IN LPBYTE pPageMem
    )
{
    GETTIME(Counter::OpTypeWrite);

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD dwWritten;
    LARGE_INTEGER Li;
    Li.QuadPart = m_dwPageSize * dwPageId;
	
    Status = NtWriteFile(m_hFile,
					    NULL,
					    NULL,
					    NULL,
					    &IoStatusBlock,
					    (PVOID)pPageMem,
					    m_dwPageSize,
					    &Li,
					    NULL);

	if ( Status == STATUS_PENDING) 
	{
	    // Operation must complete before return & IoStatusBlock destroyed
	    Status = NtWaitForSingleObject( m_hFile, FALSE, NULL );
	    if ( NT_SUCCESS(Status)) 
	    {
	        Status = IoStatusBlock.Status;
	    }
	}

	if ( !NT_SUCCESS(Status)) 
	{
		return RtlNtStatusToDosError( Status );        
	}

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageCache::Empty
//
//  Does no checking to see if a flush should have occurred.
//
//***************************************************************************
// rev2
DWORD CPageCache::Empty()
{
    DWORD dwSize = m_aCache.size();
    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        delete pTest;
    }
    m_aCache.clear();
    return NO_ERROR;
}


//***************************************************************************
//
//  CPageCache::Flush
//
//***************************************************************************
// rev2
DWORD CPageCache::Flush()
{
    // Short-circuit.  If no writes have occurred, just reset
    // and return.
    // =======================================================

    if (m_dwWritesSinceFlush == 0)
    {
        m_dwLastFlushTime = GetCurrentTime();
        m_dwWritesSinceFlush = 0;
        return NO_ERROR;
    }

    // Logical cache flush.
    // ====================

    DWORD dwRes = 0;
    DWORD dwSize = m_aCache.size();
    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        if (pTest->m_bDirty)
        {
            dwRes = WritePhysPage(pTest->m_dwPhysId, pTest->m_pPage);
            if (dwRes)
                return dwRes;
            pTest->m_bDirty = FALSE;
        }
    }

    // Do the disk flush.
    // ==================
    {
        GETTIME(Counter::OpTypeFlush);
        if (!FlushFileBuffers(m_hFile))
        	return GetLastError();
    }
    m_dwLastFlushTime = GetCurrentTime();
    m_dwWritesSinceFlush = 0;

    return NO_ERROR;
}


//***************************************************************************
//
//  CPageCache::ReadPhysPage
//
//  Reads a physical page from the file.
//
//***************************************************************************
// rev2
DWORD CPageCache::ReadPhysPage(
    IN  DWORD   dwPage,
    OUT LPBYTE *pPageMem
    )
{
    DWORD dwRes;
    *pPageMem = 0;

    if (pPageMem == 0)
        return ERROR_INVALID_PARAMETER;

    // Allocate some memory
    // ====================

    LPBYTE pMem = new BYTE[m_dwPageSize];
    if (!pMem)
    {
        return ERROR_OUTOFMEMORY;
    }

    // Where is this page hiding?
    // ==========================

	LARGE_INTEGER pos;
	pos.QuadPart = dwPage * m_dwPageSize;
    dwRes = SetFilePointerEx(m_hFile, pos, NULL, FILE_BEGIN);
    if (dwRes == 0)
    {
        delete [] pMem;
        return GetLastError();
    }

    // Try to read it.
    // ===============

    DWORD dwRead = 0;
    BOOL bRes = ReadFile(m_hFile, pMem, m_dwPageSize, &dwRead, 0);
    if (!bRes || dwRead != m_dwPageSize)
    {
        delete [] pMem;
        // If we can't read it, we probably did a seek past eof,
        // meaning the requested page was invalid.
        // =====================================================

        return ERROR_INVALID_PARAMETER;
    }

    *pPageMem = pMem;
    return NO_ERROR;
}

DWORD CPageCache::GetFileSize(LARGE_INTEGER *pFileSize)
{
	if (!GetFileSizeEx(m_hFile, pFileSize))
		return GetLastError();
	return ERROR_SUCCESS;
}
//***************************************************************************
//
//  CPageCache::Dump
//
//  Dumps cache info to the specified stream.
//
//***************************************************************************
// rev2
void CPageCache::Dump(FILE *f)
{
    DWORD dwSize = m_aCache.size();

    fprintf(f, "---Begin Cache Dump---\n");
    fprintf(f, "Time since last flush = %d\n", GetCurrentTime() - m_dwLastFlushTime);
    fprintf(f, "Writes since last flush = %d\n", m_dwWritesSinceFlush);
    fprintf(f, "Read hits = %d\n", m_dwReadHits);
    fprintf(f, "Read misses = %d\n", m_dwReadMisses);
    fprintf(f, "Write hits = %d\n", m_dwWriteHits);
    fprintf(f, "Write misses = %d\n", m_dwWriteMisses);
    fprintf(f, "Size = %d\n", dwSize);

    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        fprintf(f, "Cache[%d] ID=%d dirty=%d pMem=0x%p <%s>\n",
            dwIx, pTest->m_dwPhysId, pTest->m_bDirty, pTest->m_pPage, pTest->m_pPage);
    }

    fprintf(f, "---End Cache Dump---\n");
}




/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//  CPageFile

//***************************************************************************
//
//  CPageFile::AddRef
//
//***************************************************************************
// rev2
ULONG CPageFile::AddRef()
{
    return (ULONG) InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CPageFile::ResyncMaps
//
//  Reninitializes B maps from A maps.
//
//***************************************************************************
// rev2
DWORD CPageFile::ResyncMaps()
{
    try
    {
	    m_aPageMapB.reserve(max(m_aPageMapB.size(), m_aPageMapA.size()));
        m_aPhysFreeListB.reserve(max(m_aPhysFreeListB.size(), m_aPhysFreeListA.size()));
        m_aLogicalFreeListB.reserve(max(m_aLogicalFreeListB.size(), m_aLogicalFreeListA.size()));
        m_aReplacedPagesB.reserve(max(m_aReplacedPagesB.size(), m_aReplacedPagesA.size()));

	    m_aPageMapB = m_aPageMapA;
        m_aPhysFreeListB = m_aPhysFreeListA;
        m_aLogicalFreeListB = m_aLogicalFreeListA;
        m_aReplacedPagesB = m_aReplacedPagesA;
      
        m_dwPhysPagesB = m_dwPhysPagesA;
        m_aDeferredFreeList.clear();
    }
    catch (CX_MemoryException &)
    {
    	_ASSERT(0, L"WinMgmt: ResyncMaps failed because of out of memory - precondition not satisfied!\n")
        return ERROR_OUTOFMEMORY;
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::ReadMap
//
//  Reads the map file into memory.  Format:
//
//      DWORD dwLeadingSignature
//      DWORD dwTransactionGeneration
//      DWORD dwNumMappedPages
//      DWORD PhysicalPages[]
//      DWORD dwNumFreePages
//      DWORD FreePages[]
//      DWORD dwTrailingSignature
//
//  The only time the MAP file will not be present is on creation of
//  a new map file.
//
//  This function is retry-compatible.
//
//***************************************************************************
// rev2
DWORD CPageFile::ReadMap(HANDLE hFile)
{
    BOOL bRes;
    
    // If here, read it.
    // =================

    DWORD dwSignature = 0;
    DWORD dwRead = 0;

    bRes = ReadFile(hFile, &dwSignature, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD) || dwSignature != MAP_LEADING_SIGNATURE)
    {
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    // Read transaction version.
    // =========================

    bRes = ReadFile(hFile, &m_dwTransVersion, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    // Read in physical page count.
    // ============================
    bRes = ReadFile(hFile, &m_dwPhysPagesA, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    // Read in the page map length and page map.
    // =========================================

    DWORD dwNumPages = 0;
    bRes = ReadFile(hFile, &dwNumPages, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    try
    {
        m_aPageMapA.resize(dwNumPages);
    }
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    bRes = ReadFile(hFile, &m_aPageMapA[0], sizeof(DWORD)*dwNumPages, &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD)*dwNumPages)
    {
    	m_aPageMapA.empty();
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    // Now, read in the physical free list.
    // ====================================

    DWORD dwFreeListSize = 0;
    bRes = ReadFile(hFile, &dwFreeListSize, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
    	m_aPageMapA.empty();
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    try
    {
        m_aPhysFreeListA.resize(dwFreeListSize);
    }
    catch (CX_MemoryException &)
    {
    	m_aPageMapA.empty();
        return ERROR_OUTOFMEMORY;
    }

    bRes = ReadFile(hFile, &m_aPhysFreeListA[0], sizeof(DWORD)*dwFreeListSize, &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD)*dwFreeListSize)
    {
    	m_aPageMapA.empty();
    	m_aPhysFreeListA.empty();

        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    // Read trailing signature.
    // ========================

    bRes = ReadFile(hFile, &dwSignature, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD) || dwSignature != MAP_TRAILING_SIGNATURE)
    {
    	m_aPageMapA.empty();
    	m_aPhysFreeListA.empty();
        return ERROR_INTERNAL_DB_CORRUPTION;
    }

    //Validate the MAP file length against the size of the data file.
	DWORD dwRes = ValidateMapFile();

    // Initialize the logical free list from the page map.
    // ===================================================

	if (dwRes == ERROR_SUCCESS)
	    dwRes = InitFreeList();

    if (dwRes == ERROR_SUCCESS)
    	dwRes = ResyncMaps();

    if (dwRes != ERROR_SUCCESS)
    {
    	//Clear everything up!
    	m_dwPhysPagesA = 0;
    	m_aPageMapA.empty();
    	m_aPhysFreeListA.empty();
    	m_aLogicalFreeListA.empty();
    	m_dwPhysPagesB = 0;
    	m_aPageMapB.empty();
    	m_aPhysFreeListB.empty();
    	m_aLogicalFreeListB.empty();
    }

    return dwRes;
}

//***************************************************************************
//
//  CPageFile::ValidateMapFile
//
//	Find the highest physical page ID and try and read it!  If it fails then something is not
//	right!
//***************************************************************************
DWORD CPageFile::ValidateMapFile()
{
	DWORD dwRet = ERROR_SUCCESS;
	DWORD dwPhysicalPageId = 0;
	DWORD dwLogicalPageId = 0;
	for (DWORD i = 0; i != m_aPageMapA.size(); i++)
	{
		if ((m_aPageMapA[i] != WMIREP_INVALID_PAGE) && (dwPhysicalPageId < m_aPageMapA[i]))
		{
			dwPhysicalPageId = m_aPageMapA[i];
			dwLogicalPageId = i;
		}
	}

	if (dwPhysicalPageId != 0)
	{
		LPBYTE pPageMem = 0;
		dwRet = m_Cache.ReadPhysPage(dwPhysicalPageId, &pPageMem);
		delete [] pPageMem;

		if ((dwRet != ERROR_SUCCESS) && (dwRet != ERROR_OUTOFMEMORY))
		{
			ERRORTRACE((LOG_REPDRV, "Repository corruption detected. %S data file was not large enough to retrieve page <0x%X>.  <0x%X>!\n", m_wszStoreName, dwPhysicalPageId, dwRet));
#ifdef DBG			
			OutputDebugStringW(L"WinMgmt: Repository corruption detected: ");
			OutputDebugStringW(m_wszStoreName);
			OutputDebugStringW(L"\n");
#endif			
#ifdef WMI_PRIVATE_DBG
			DebugBreak();
#endif
			dwRet = ERROR_INTERNAL_DB_CORRUPTION;
		}
		else if (dwRet == ERROR_SUCCESS)
		{
#ifdef WMI_PRIVATE_DBG
			wchar_t wszDebug[120];
			StringCchPrintfW(wszDebug, 120, L"ReadMap(%s), Highest physical Page ID <0x%X> for logical page ID <0x%X>\n", m_wszStoreName, dwPhysicalPageId, dwLogicalPageId);
			ERRORTRACE((LOG_REPDRV, "%S", wszDebug));
			OutputDebugStringW(wszDebug);
#endif
		}
	}

	return dwRet;
}

//***************************************************************************
//
//  CPageFile::WriteMap
//
//  Writes the generation A mapping (assuming that we write immediately
//  during a checkpoint when A and B generations are the same and that
//  the replacement lists have been appended to the free lists, etc., etc.
//  This write occurs to a temp file.  The renaming occurs externally.
//
//  This function is retry compatible.
//
//***************************************************************************
// rev2
DWORD CPageFile::WriteMap(HANDLE hFile)
{
    BOOL bRes;

    DWORD dwTotal = sizeof(DWORD)*(1 + 1 + 1 + 1 + m_aPageMapA.size() + 1 + m_aPhysFreeListA.size() +1);

    ASSERT_DEBUG_BREAK((m_aPageMapA.size() + m_aPhysFreeListA.size())!=0);
  
    BYTE * pMem = new BYTE[dwTotal];
    if (NULL == pMem) 
    	return ERROR_OUTOFMEMORY;
    CVectorDeleteMe<BYTE> vdm(pMem);

    DWORD * pCurrent = (DWORD *)pMem;

    DWORD dwSignature = MAP_LEADING_SIGNATURE;
    *pCurrent = dwSignature; 
    pCurrent++;

    *pCurrent = m_dwTransVersion; 
    pCurrent++;

    *pCurrent = m_dwPhysPagesA; 
    pCurrent++;

    DWORD dwNumPages = m_aPageMapA.size();    
    *pCurrent = dwNumPages; 
    pCurrent++;

    memcpy(pCurrent,&m_aPageMapA[0],sizeof(DWORD)*dwNumPages);
    pCurrent+=dwNumPages;    

    DWORD dwFreeListSize = m_aPhysFreeListA.size();
    *pCurrent = dwFreeListSize; 
    pCurrent++;        

    memcpy(pCurrent,&m_aPhysFreeListA[0], sizeof(DWORD)*dwFreeListSize);
    pCurrent+=dwFreeListSize;
    
    dwSignature = MAP_TRAILING_SIGNATURE;
    *pCurrent = dwSignature; 
    
    DWORD dwWritten = 0;
    {
        GETTIME(Counter::OpTypeWrite);
        bRes = WriteFile(hFile, pMem,dwTotal, &dwWritten, 0);
    }
    if (!bRes || dwWritten != dwTotal)
    {
        return GetLastError();
    }

#ifdef WMI_PRIVATE_DBG
	DumpFileInformation(hFile);
#endif
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::Trans_Commit
//
//  Rolls the transaction forward (in-memory).  A checkpoint may
//  occur afterwards (decided outside this function)
//
//  The r/w cache contents are not affected except that they may contain
//  garbage pages no longer relevant.
//
//***************************************************************************
// rev2
DWORD CPageFile::Trans_Commit()
{
    if (!m_bInTransaction)
        return ERROR_INVALID_OPERATION;

    try
    {
		m_aPageMapA.reserve(m_aPageMapB.size());
		m_aLogicalFreeListA.reserve(m_aLogicalFreeListB.size());
		m_aReplacedPagesA.reserve(m_aReplacedPagesB.size());
		
		m_aPhysFreeListA.reserve(m_aPhysFreeListB.size()+m_aDeferredFreeList.size());
		m_aPhysFreeListB.reserve(m_aPhysFreeListB.size()+m_aDeferredFreeList.size());
		
		MoveCurrentToPrevious(m_aPageMapB);

        while (m_aDeferredFreeList.size())
        {
            m_aPhysFreeListB.push_back(m_aDeferredFreeList.back());
            m_aDeferredFreeList.pop_back();
        }

	    m_aPageMapA = m_aPageMapB;
        m_aPhysFreeListA = m_aPhysFreeListB;
        m_aLogicalFreeListA = m_aLogicalFreeListB;
        m_aReplacedPagesA = m_aReplacedPagesB;

        m_dwPhysPagesA = m_dwPhysPagesB;
    }
    catch (CX_MemoryException &)
    {
    	_ASSERT(0, L"WinMgmt: Commit failed because of out of memory - precondition not satisfied!\n")
        return ERROR_OUTOFMEMORY;
    }

    m_bInTransaction = FALSE;

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::Trans_Rollback
//
//  Rolls back a transaction within the current checkpoint window.
//  If the cache is hosed, try to recover it.
//
//***************************************************************************
// rev2
DWORD CPageFile::Trans_Rollback()
{
    if (!m_bInTransaction)
        return ERROR_INVALID_OPERATION;
    m_bInTransaction = FALSE;
    return ResyncMaps();
}


//***************************************************************************
//
//  CPageFile::Trans_Checkpoint
//
//***************************************************************************
//  rev2
DWORD CPageFile::Trans_Checkpoint(HANDLE hFile )
{
    DWORD dwRes;

    std::vector <DWORD, wbem_allocator<DWORD> > & ref = m_aPageMapA;

    if (m_bInTransaction)
        return ERROR_INVALID_OPERATION;

    // Flush cache.  If cache is not in a valid state, it
    // will return the error/state immediately.
    // ===================================================

    dwRes = m_Cache.Flush();
    if (dwRes)
        return dwRes;

    //Make sure memory is pre-allocated before changing anything
    try
    {
		m_aPhysFreeListA.reserve(m_aPhysFreeListA.size()+m_aReplacedPagesA.size());
    }
    catch (CX_MemoryException &)
    {

    	return ERROR_OUTOFMEMORY;
    }

    // Strip the hi bits from the page maps.
    // =====================================

    StripHiBits(ref);

    // The replaced pages become added to the free list.
    // =================================================

	int revertCount = m_aReplacedPagesA.size();
    try	// Operation one
    {
        while (m_aReplacedPagesA.size())
   