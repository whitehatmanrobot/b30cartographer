 IActiveIMMApp * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMApp * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMApp * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMApp_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMApp_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMApp_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMApp_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC *phPrev);


void __RPC_STUB IActiveIMMApp_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_CreateContext_Proxy( 
    IActiveIMMApp * This,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DestroyContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMApp_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pfdwConversion,
    /* [out] */ DWORD *pfdwSentence);


void __RPC_STUB IActiveIMMApp_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDefaultIMEWnd_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND *phDefWnd);


void __RPC_STUB IActiveIMMApp_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetProperty_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD *pdwProperty);


void __RPC_STUB IActiveIMMApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetVirtualKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT *puVirtualKey);


void __RPC_STUB IActiveIMMApp_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMApp_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_NotifyIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMApp_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ReleaseContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMApp_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMApp_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SimulateHotKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMApp_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Activate_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ BOOL fRestoreLayout);


void __RPC_STUB IActiveIMMApp_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Deactivate_Proxy( 
    IActiveIMMApp * This);


void __RPC_STUB IActiveIMMApp_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_OnDefWindowProc_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_OnDefWindowProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_FilterClientWindows_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ ATOM *aaClassList,
    /* [in] */ UINT uSize);


void __RPC_STUB IActiveIMMApp_FilterClientWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCodePageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIMMApp_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetLangId_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIMMApp_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContextEx_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMApp_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DisableIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMApp_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumInputContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IActiveIMMApp_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMIME_INTERFACE_DEFINED__
#define __IActiveIMMIME_INTERFACE_DEFINED__

/* interface IActiveIMMIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03411-F96B-11d0-A475-00AA006BCC59")
    IActiveIMMIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateMessage( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMC( 
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT **ppIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMC( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCLockCount( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateIMCC( 
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReSizeIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCSize( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCLockCount( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT *puModifiers,
            /* [out] */ UINT *puVKey,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftKeyboard( 
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND *phSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeybdEvent( 
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCA( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCW( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSleeping( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMIME * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMIME * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMIME * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMIME * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateMessage )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT **ppIMC);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCLockCount )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *ReSizeIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCSize )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCLockCount )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT *puModifiers,
            /* [out] */ UINT *puVKey,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND *phSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroySoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *ShowSoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *KeybdEvent )( 
            IActiveIMMIME * This,
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo);
        
        HRESULT ( STDMETHODCALLTYPE *LockModal )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockModal )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCA )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCW )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *IsSleeping )( 
            IActiveIMMIME * This);
        
        END_INTERFACE
    } IActiveIMMIMEVtbl;

    interface IActiveIMMIME
    {
        CONST_VTBL struct IActiveIMMIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMIME_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMIME_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMIME_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMIME_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMIME_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMIME_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMIME_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMIME_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMIME_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMIME_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMIME_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMIME_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMIME_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMIME_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMIME_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMIME_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMIME_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMIME_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_GenerateMessage(This,hIMC)	\
    (This)->lpVtbl -> GenerateMessage(This,hIMC)

#define IActiveIMMIME_LockIMC(This,hIMC,ppIMC)	\
    (This)->lpVtbl -> LockIMC(This,hIMC,ppIMC)

#define IActiveIMMIME_UnlockIMC(This,hIMC)	\
    (This)->lpVtbl -> UnlockIMC(This,hIMC)

#define IActiveIMMIME_GetIMCLockCount(This,hIMC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCLockCount(This,hIMC,pdwLockCount)

#define IActiveIMMIME_CreateIMCC(This,dwSize,phIMCC)	\
    (This)->lpVtbl -> CreateIMCC(This,dwSize,phIMCC)

#define IActiveIMMIME_DestroyIMCC(This,hIMCC)	\
    (This)->lpVtbl -> DestroyIMCC(This,hIMCC)

#define IActiveIMMIME_LockIMCC(This,hIMCC,ppv)	\
    (This)->lpVtbl -> LockIMCC(This,hIMCC,ppv)

#define IActiveIMMIME_UnlockIMCC(This,hIMCC)	\
    (This)->lpVtbl -> UnlockIMCC(This,hIMCC)

#define IActiveIMMIME_ReSizeIMCC(This,hIMCC,dwSize,phIMCC)	\
    (This)->lpVtbl -> ReSizeIMCC(This,hIMCC,dwSize,phIMCC)

#define IActiveIMMIME_GetIMCCSize(This,hIMCC,pdwSize)	\
    (This)->lpVtbl -> GetIMCCSize(This,hIMCC,pdwSize)

#define IActiveIMMIME_GetIMCCLockCount(This,hIMCC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCCLockCount(This,hIMCC,pdwLockCount)

#define IActiveIMMIME_GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)	\
    (This)->lpVtbl -> GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)

#define IActiveIMMIME_SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)	\
    (This)->lpVtbl -> SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)

#define IActiveIMMIME_CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)	\
    (This)->lpVtbl -> CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)

#define IActiveIMMIME_DestroySoftKeyboard(This,hSoftKbdWnd)	\
    (This)->lpVtbl -> DestroySoftKeyboard(This,hSoftKbdWnd)

#define IActiveIMMIME_ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)	\
    (This)->lpVtbl -> ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)

#define IActiveIMMIME_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMIME_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMIME_KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)	\
    (This)->lpVtbl -> KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)

#define IActiveIMMIME_LockModal(This)	\
    (This)->lpVtbl -> LockModal(This)

#define IActiveIMMIME_UnlockModal(This)	\
    (This)->lpVtbl -> UnlockModal(This)

#define IActiveIMMIME_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMIME_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMIME_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMIME_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMIME_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#define IActiveIMMIME_RequestMessageA(This,hIMC,wParam,lParam,plResult)	\
    (This)->lpVtbl -> RequestMessageA(This,hIMC,wParam,lParam,plResult)

#define IActiveIMMIME_RequestMessageW(This,hIMC,wParam,lParam,plResult)	\
    (This)->lpVtbl -> RequestMessageW(This,hIMC,wParam,lParam,plResult)

#define IActiveIMMIME_SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)

#define IActiveIMMIME_SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)

#define IActiveIMMIME_IsSleeping(This)	\
    (This)->lpVtbl -> IsSleeping(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC *phPrev);


void __RPC_STUB IActiveIMMIME_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateContext_Proxy( 
    IActiveIMMIME * This,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMIME_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMIME_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA **pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMIME_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMIME_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMIME_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pfdwConversion,
    /* [out] */ DWORD *pfdwSentence);


void __RPC_STUB IActiveIMMIME_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDefaultIMEWnd_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND *phDefWnd);


void __RPC_STUB IActiveIMMIME_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetOpenStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetProperty_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD *pdwProperty);


void __RPC_STUB IActiveIMMIME_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetStatusWindowPos_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT *pptPos);


void __RPC_STUB IActiveIMMIME_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetVirtualKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT *puVirtualKey);


void __RPC_STUB IActiveIMMIME_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsIME_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_NotifyIME_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMIME_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReleaseContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCandidateWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMIME_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMIME_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetConversionStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMIME_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetOpenStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMIME_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetStatusWindowPos_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT *pptPos);


void __RPC_STUB IActiveIMMIME_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SimulateHotKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMIME_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GenerateMessage_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GenerateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ INPUTCONTEXT **ppIMC);


void __RPC_STUB IActiveIMMIME_LockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_UnlockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCLockCount_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC *phIMCC);


void __RPC_STUB IActiveIMMIME_CreateIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_DestroyIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ void **ppv);


void __RPC_STUB IActiveIMMIME_LockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_UnlockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReSizeIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC *phIMCC);


void __RPC_STUB IActiveIMMIME_ReSizeIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCSize_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD *pdwSize);


void __RPC_STUB IActiveIMMIME_GetIMCCSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCLockCount_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetHotKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [out] */ UINT *puModifiers,
    /* [out] */ UINT *puVKey,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMIME_GetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetHotKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [in] */ UINT uModifiers,
    /* [in] */ UINT uVKey,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_SetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateSoftKeyboard_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ UINT uType,
    /* [in] */ HWND hOwner,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [out] */ HWND *phSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_CreateSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroySoftKeyboard_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_DestroySoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ShowSoftKeyboard_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hSoftKbdWnd,
    /* [in] */ int nCmdShow);


void __RPC_STUB IActiveIMMIME_ShowSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCodePageA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIMMIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetLangId_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIMMIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_KeybdEvent_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ LANGID lgidIME,
    /* [in] */ BYTE bVk,
    /* [in] */ BYTE bScan,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwExtraInfo);


void __RPC_STUB IActiveIMMIME_KeybdEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockModal_Proxy( 
    IActiveIMMIME * This);


void __RPC_STUB IActiveIMMIME_LockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockModal_Proxy( 
    IActiveIMMIME * This);


void __RPC_STUB IActiveIMMIME_UnlockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContextEx_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMIME_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DisableIME_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMIME_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetImeMenuItemsA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetImeMenuItemsW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumInputContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IActiveIMMIME_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RequestMessageA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_RequestMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RequestMessageW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_RequestMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SendIMCA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_SendIMCA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SendIMCW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_SendIMCW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsSleeping_Proxy( 
    IActiveIMMIME * This);


void __RPC_STUB IActiveIMMIME_IsSleeping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME_INTERFACE_DEFINED__
#define __IActiveIME_INTERFACE_DEFINED__

/* interface IActiveIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6FE20962-D077-11d0-8FE7-00AA006BCC59")
    IActiveIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inquire( 
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD *pdwPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversionList( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pDest,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pRegisterWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ UINT uReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void *pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveContext( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessKey( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE *pbKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionString( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void *pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToAsciiEx( 
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwTransBuf,
            /* [out] */ UINT *puSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyle( 
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [out] */ LANGID *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIME * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            IActiveIME * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pDest,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IActiveIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IActiveIME * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void *pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            IActiveIME * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwTransBuf,
            /* [out] */ UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            IActiveIME * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            IActiveIME * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            IActiveIME * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            IActiveIME * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIME * This,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIME * This,
            /* [out] */ LANGID *plid);
        
        END_INTERFACE
    } IActiveIMEVtbl;

    interface IActiveIME
    {
        CONST_VTBL struct IActiveIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)

#define IActiveIME_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME_Inquire_Proxy( 
    IActiveIME * This,
    /* [in] */ DWORD dwSystemInfoFlags,
    /* [out] */ IMEINFO *pIMEInfo,
    /* [out] */ LPWSTR szWndClass,
    /* [out] */ DWORD *pdwPrivate);


void __RPC_STUB IActiveIME_Inquire_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ConversionList_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR szSource,
    /* [in] */ UINT uFlag,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pDest,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIME_ConversionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Configure_Proxy( 
    IActiveIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pRegisterWord);


void __RPC_STUB IActiveIME_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Destroy_Proxy( 
    IActiveIME * This,
    /* [in] */ UINT uReserved);


void __RPC_STUB IActiveIME_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Escape_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ void *pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIME_Escape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetActiveContext_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fFlag);


void __RPC_STUB IActiveIME_SetActiveContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ProcessKey_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uVirKey,
    /* [in] */ DWORD lParam,
    /* [in] */ BYTE *pbKeyState);


void __RPC_STUB IActiveIME_ProcessKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Notify_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIME_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Select_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fSelect);


void __RPC_STUB IActiveIME_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetCompositionString_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ void *pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ void *pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIME_SetCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ToAsciiEx_Proxy( 
    IActiveIME * This,
    /* [in] */ UINT uVirKey,
    /* [in] */ UINT uScanCode,
    /* [in] */ BYTE *pbKeyState,
    /* [in] */ UINT fuState,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwTransBuf,
    /* [out] */ UINT *puSize);


void __RPC_STUB IActiveIME_ToAsciiEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_RegisterWord_Proxy( 
    IActiveIME * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_RegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_UnregisterWord_Proxy( 
    IActiveIME * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_UnregisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetRegisterWordStyle_Proxy( 
    IActiveIME * This,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puBufSize);


void __RPC_STUB IActiveIME_GetRegisterWordStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_EnumRegisterWord_Proxy( 
    IActiveIME * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **ppEnum);


void __RPC_STUB IActiveIME_EnumRegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetCodePageA_Proxy( 
    IActiveIME * This,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetLangId_Proxy( 
    IActiveIME * This,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME2_INTERFACE_DEFINED__
#define __IActiveIME2_INTERFACE_DEFINED__

/* interface IActiveIME2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e1c4bf0e-2d53-11d2-93e1-0060b067b86e")
    IActiveIME2 : public IActiveIME
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Sleep( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unsleep( 
            /* [in] */ BOOL fDead) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIME2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIME2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIME2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            IActiveIME2 * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pDest,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IActiveIME2 * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IActiveIME2 * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void *pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            IActiveIME2 * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwTransBuf,
            /* [out] */ UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            IActiveIME2 * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            IActiveIME2 * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            IActiveIME2 * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            IActiveIME2 * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIME2 * This,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIME2 * This,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *Sleep )( 
            IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unsleep )( 
            IActiveIME2 * This,
            /* [in] */ BOOL fDead);
        
        END_INTERFACE
    } IActiveIME2Vtbl;

    interface IActiveIME2
    {
        CONST_VTBL struct IActiveIME2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME2_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME2_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)

#define IActiveIME2_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME2_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME2_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME2_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME2_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME2_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME2_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME2_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME2_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME2_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME2_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME2_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME2_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME2_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME2_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)


#define IActiveIME2_Sleep(This)	\
    (This)->lpVtbl -> Sleep(This)

#define IActiveIME2_Unsleep(This,fDead)	\
    (This)->lpVtbl -> Unsleep(This,fDead)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME2_Sleep_Proxy( 
    IActiveIME2 * This);


void __RPC_STUB IActiveIME2_Sleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME2_Unsleep_Proxy( 
    IActiveIME2 * This,
    /* [in] */ BOOL fDead);


void __RPC_STUB IActiveIME2_Unsleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CActiveIMM;

#ifdef __cplusplus

class DECLSPEC_UUID("4955DD33-B159-11d0-8FCF-00AA006BCC59")
CActiveIMM;
#endif
#endif /* __ActiveIMM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re32wrap\wrapinit.cpp ===
#include "wrapper.h"

HINSTANCE hinstRE32 = 0;
static const char szClassRE10A[] = RICHEDIT_CLASS10A;

class   CTxtEdit;

extern "C"
{

__declspec(dllimport) LRESULT CALLBACK RichEdit10ANSIWndProc(HWND, UINT, WPARAM, LPARAM);

BOOL WINAPI DllMain(HMODULE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    if(dwReason == DLL_PROCESS_DETACH)
    {
        UnregisterClassA(szClassRE10A, hinstRE32);
    }
    else if(dwReason == DLL_PROCESS_ATTACH) // We have just loaded
    {
        WNDCLASSA wca;

        hinstRE32 = hmod;

        wca.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC;
        wca.lpfnWndProc = RichEdit10ANSIWndProc;
        wca.cbClsExtra = 0;
        wca.cbWndExtra = sizeof(CTxtEdit FAR *);
        wca.hInstance = hinstRE32;
        wca.hIcon = 0;
        wca.hCursor = 0;
        wca.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
        wca.lpszMenuName = NULL;
        wca.lpszClassName = szClassRE10A;

        //
        //  Register the RICHEDIT 10 class.
        //

        if( !RegisterClassA(&wca) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\aimm_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Tue Jan 13 08:56:29 1998
 */
/* Compiler settings for aimm.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_ActiveIMM = {0x4955DD30,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IEnumRegisterWordA = {0x08C03412,0xF96B,0x11d0,{0xA4,0x75,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IEnumRegisterWordW = {0x4955DD31,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IAIMMRegistrar = {0xc7afa428,0x5007,0x11d1,{0xaa,0x94,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMMessagePumpOwner = {0xb5cf2cfa,0x8aeb,0x11d1,{0x93,0x64,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMApp = {0x08c0e040,0x62d1,0x11d1,{0x93,0x26,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMIME = {0x08C03411,0xF96B,0x11d0,{0xA4,0x75,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IActiveIME = {0x6FE20962,0xD077,0x11d0,{0x8F,0xE7,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const CLSID CLSID_CActiveIMM = {0x4955DD33,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};

/* c1ee01f2-b3b6-4a6a-9ddd-e988c088ec82 */
const CLSID CLSID_CActiveIMM12 = { 
    0xc1ee01f2,
    0xb3b6,
    0x4a6a,
    {0x9d, 0xdd, 0xe9, 0x88, 0xc0, 0x88, 0xec, 0x82}
  };

/* D7A6F58A-D478-44ab-86C9-591C23A26534 */
const IID IID_IActiveIMMAppEx = {
	0xD7A6F58A,
	0xD478,
	0x44ab,
	{0x86, 0xC9, 0x59, 0x1C, 0x23, 0xA2, 0x65, 0x34}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\array.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	ARRAY.C	-- Generic Array Implementation |
 *	
 *	Original Author: <nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95  alexgo  Cleanup and Commented
 *				 KeithCu Changed to auto/grow and shrink exponentially
 *
 *	Copyright (c) 1995-1999, Microsoft Corporation. All rights reserved.
 */


#include "_common.h"
#include "_array.h"

ASSERTDATA

const int celGrow = 4;

//
//	Invariant support
//
#define	DEBUG_CLASSNAME	CArrayBase
#include "_invar.h"

// ===================================  CArrayBase  ================================================

#ifdef DEBUG
/*
 *	CArrayBase::Invariant()
 *
 *	@mfunc	Tests the array state to make sure it is valid.  DEBUG only
 *
 *	@rdesc	TRUE if the tests succeed, FALSE otherwise
 */
BOOL CArrayBase::Invariant() const
{
	Assert(_cbElem > 0);

	if(!_prgel)
	{
		Assert(_cel == 0);
		Assert(_celMax == 0);

		// We go ahead and return a value here so that
		// this function can be executed in the "watch"
		// window of various debuggers
		if(_cel || _celMax)
			return FALSE;
	}
	else
	{
		Assert(_celMax > 0 );
		Assert(_cel <= _celMax);

		if(_celMax == 0 || _cel > _celMax)
			return FALSE;
	}

	return TRUE;
}

/* 
 *	CArrayBase::Elem(iel)
 *
 *	@mfunc	Returns a pointer to the element indexed by <p iel>
 *
 *	@rdesc	A pointer to the element indexed by <p iel>.  This pointer may
 *	be cast to a pointer of the appropriate element type.
 */
void* CArrayBase::Elem(
	LONG iel) const	//@parm Index to use
{
	_TEST_INVARIANT_

	AssertSz(iel == 0 || (iel > 0 && iel < _cel),
		"CArrayBase::Elem() - Index out of range");

	return _prgel + iel * _cbElem;
}								 
#endif

/*
 *	CArrayBase::TransferTo
 *
 *	@mfunc Shallow copy array to passed-in array, and
 *	initialize *this.
 */
void CArrayBase::TransferTo(CArrayBase &ar)
{
	Assert(ar._cbElem == _cbElem);
	ar._cel = _cel;
	ar._celMax = _celMax;
	ar._prgel = _prgel;

	_prgel = NULL; 
	_cel = 0; 
	_celMax = 0; 
}

/*
 *	CArrayBase::CArrayBase
 *
 *	@mfunc Constructor
 */
CArrayBase::CArrayBase(
	LONG cbElem)		//@parm	Size of an individual array element
{	
	_prgel = NULL; 
	_cel = 0; 
	_celMax = 0; 
	_cbElem = cbElem;
}

/*
 *	CArrayBase::ArAdd
 *
 *	@mfunc	Adds <p celAdd> elements to the end of the array.
 *
 *	@rdesc	A pointer to the start of the new elements added.  If non-NULL, 
 *	<p pielIns> will be set to the index at which elements were added.
 *
 *  We grow in steps of celGrow when small and exponentially when large.
 */
void* CArrayBase::ArAdd(
	LONG celAdd,	//@parm Count of elements to add
	LONG *pielIns)	//@parm Out parm for index of first element added
{
	_TEST_INVARIANT_
	char *pel;

	if(!_prgel || _cel + celAdd > _celMax)					// need to grow 
	{
		LONG celNew;

		if (!_prgel)
		{
			_cel = 0;
			_celMax = 0;
		}
		
		celNew = max(celAdd, celGrow) + _cel / 16;

		pel = (char*)PvReAlloc(_prgel, (_celMax + celNew) * _cbElem);
		if(!pel)
			return NULL;
		_prgel = pel;
		_celMax += celNew;
	}
	pel = _prgel + _cel * _cbElem;
	ZeroMemory(pel, celAdd * _cbElem);

	if(pielIns)
		*pielIns = _cel;

	_cel += celAdd;
	return pel;
}

/*
 *	CArrayBase::ArInsert (iel, celIns)
 *
 *	@mfunc Inserts <p celIns> new elements at index <p iel>
 *
 *	@rdesc A pointer to the newly inserted elements.  Will be NULL on
 *	failure.
 */
void* CArrayBase::ArInsert(
	LONG iel,		//@parm	Index at which to insert
	LONG celIns)	//@parm Count of elements to insert
{
	char *pel;

	_TEST_INVARIANT_

	AssertSz(iel <= _cel, "CArrayBase::Insert() - Insert out of range");

	if(iel >= _cel)
		return ArAdd(celIns, NULL);

	if(_cel + celIns > _celMax)				// need to grow 
	{
		AssertSz(_prgel, "CArrayBase::Insert() - Growing a non existent array !");

		LONG celNew = max(celIns, celGrow) + _cel / 16;
		pel = (char*)PvReAlloc(_prgel, (_celMax + celNew) * _cbElem);
		if(!pel)
		{
			TRACEERRORSZ("CArrayBase::Insert() - Couldn't realloc line array");
			return NULL;
		}
		_prgel = pel;
		_celMax += celNew;
	}
	pel = _prgel + iel * _cbElem;
	if(iel < _cel)				// Nove Elems up to make room for new ones
		MoveMemory(pel + celIns*_cbElem, pel, (_cel - iel)*_cbElem);

	_cel += celIns;
	return pel;
}

/*
 *	CArrayBase::Remove
 *
 *	@mfunc	Removes the <p celFree> elements from the array starting at index
 *	<p ielFirst>.  If <p celFree> is negative, then all elements after
 *	<p ielFirst> are removed.
 *
 *	@rdesc nothing
 */
void CArrayBase::Remove(
	LONG ielFirst, 		//@parm Index at which elements should be removed
	LONG celFree) 		//@parm	Count of elements to remove. 
{
	char *pel;

	_TEST_INVARIANT_

	if(celFree < 0)
		celFree = _cel - ielFirst;

	AssertSz(ielFirst + celFree <= _cel, "CArrayBase::Free() - Freeing out of range");

	if(_cel > ielFirst + celFree)
	{
		pel = _prgel + ielFirst * _cbElem;
		MoveMemory(pel, pel + celFree * _cbElem,
			(_cel - ielFirst - celFree) * _cbElem);
	}

	_cel -= celFree;

	if(_cel < _celMax - celGrow - _cel / 16)
	{
		// Shrink array
		LONG	celCount = max(_cel, celGrow);
		char*	prgelLocal = (char*)PvReAlloc(_prgel, celCount * _cbElem);

		if (prgelLocal)
		{
			_celMax	= celCount;
			_prgel	= prgelLocal;
		}
	}
}

/*
 *	CArrayBase::Clear
 *
 *	@mfunc	Clears the entire array, potentially deleting all of the memory
 *	as well.
 *
 *	@rdesc	nothing
 */
void CArrayBase::Clear(
	ArrayFlag flag)	//@parm Indicates what should be done with the memory
					//in the array.  One of AF_DELETEMEM or AF_KEEPMEM
{
	_TEST_INVARIANT_

	_cel = 0;
	if( flag != AF_DELETEMEM && _prgel)
	{
		LONG	celCount = min(celGrow, _celMax);
		char	*prgelLocal = (char*) PvReAlloc(_prgel, celCount * _cbElem);

		if (prgelLocal)
		{
			_celMax	= celCount;
			_prgel	= prgelLocal;
			return;
		}
	}

	FreePv(_prgel);
	_prgel = NULL;
	_celMax = 0;
}

/*
 *	CArrayBase::Replace
 *
 *	@mfunc	Replaces the <p celRepl> elements at index <p ielRepl> with the
 *	contents of the array specified by <p par>.  If <p celRepl> is negative,
 *	then the entire contents of <p this> array starting at <p ielRepl> should
 *	be replaced.
 *
 *	@rdesc	Returns TRUE on success, FALSE otherwise.
 */
BOOL CArrayBase::Replace(
	LONG ielRepl, 		//@parm index at which replacement should occur
	LONG celRepl, 		//@parm number of elements to replace (may be
						//		negative, indicating that all
	CArrayBase *par)	//@parm array to use as the replacement source
{
	_TEST_INVARIANT_

	LONG celMove = 0;
	LONG celIns = par->Count();
	
	if (celRepl < 0)
		celRepl = _cel - ielRepl;

	AssertSz(ielRepl + celRepl <= _cel, "CArrayBase::ArReplace() - Replacing out of range");
	
	celMove = min(celRepl, celIns);

	if (celMove > 0) 
	{
		MoveMemory(Elem(ielRepl), par->Elem(0), celMove * _cbElem);
		celIns -= celMove;
		celRepl -= celMove;
		ielRepl += celMove;
	}

	Assert(celIns >= 0);
	Assert(celRepl >= 0);
	Assert(celIns + celMove == par->Count());

	if(celIns > 0)
	{
		Assert(celRepl == 0);
		void *pelIns = ArInsert (ielRepl, celIns);
		if (!pelIns)
			return FALSE;
		MoveMemory(pelIns, par->Elem(celMove), celIns * _cbElem);
	}
	else if(celRepl > 0)
		Remove (ielRepl, celRepl);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\antievt.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	ANTIEVT.C |
 *
 *	Purpose:
 *		implemenation of common antievents and a caching mechanism
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_m_undo.h"
#include "_edit.h"
#include "_antievt.h"
#include "_range.h"
#include "_select.h"
#include "_format.h"
#include "_coleobj.h"
#include "_objmgr.h"
#ifdef DEBUG
#include "_uspi.h"
#endif

ASSERTDATA


//
// CAntiEventDispenser global instance
//
CAntiEventDispenser gAEDispenser;


//
//	CBaseAE PUBLIC methods
//

/*
 *	CBaseAE::Destroy ()
 *
 *	@mfunc
 *		sends the Destroy notification to the next antievent in the list
 */

void CBaseAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::Destroy");
}

/*
 *	CBaseAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		sends the Undo notification to the next antievent in the list
 *
 *	@rdesc	HRESULT
 */
HRESULT CBaseAE::Undo(
	CTxtEdit *	  ped,		//@parm	Edit context for this undo operation
	IUndoBuilder *publdr)	//@parm Undo context.
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::Undo");
	return NOERROR;
}

/*
 *	CBaseAE::OnCommit (ped)
 *
 *	@mfunc	called after the antievent is added to the undo stack
 *
 *	@rdesc	void
 */
void CBaseAE::OnCommit(
	CTxtEdit *ped)			//@parm Edit context
{
}

/*
 *	CBaseAE::MergeData (dwDataType, pdata)
 *
 *	@mfunc	simply forwards the merge data request to the next antievent
 *			(if one exists)
 *
 *	@rdesc	HRESULT.  If S_FALSE, indicates that nothing could be done
 *			with the merge data.
 */
HRESULT	CBaseAE::MergeData(
	DWORD dwDataType, 		//@parm Type of data in <p pdata>
	void *pdata)			//@parm Merge data
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::MergeData");

	return S_FALSE;
}

/*
 *	CBaseAE::SetNext(pNext)
 *
 *	@mfunc
 *		informs this antievent of the antievent which should follow it
 */
void CBaseAE::SetNext(
	IAntiEvent *pNext)		//@parm	the AntiEvent to link to
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::SetNext");

	_pnext  = pNext;
}

/*
 *	CBaseAE::GetNext()
 *
 *	@mfunc
 *		retrieves the next element (if any)
 *
 *	@rdesc	a pointer to the next AntiEvent
 */
IAntiEvent *CBaseAE::GetNext()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::GetNext");

	return _pnext;
}

//
// CBaseAE PROTECTED methods
//

/*
 *	CBaseAE::CBaseAE()
 *
 *	@mfunc	Constructor
 */
CBaseAE::CBaseAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::CBaseAE");

	_pnext = NULL;
}

/* 
 *	CReplaceRangeAE::Destroy ()
 *
 *	@mfunc
 *		deletes this instance
 */
void CReplaceRangeAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::Destroy");

	if(_paeCF)
	{
		_paeCF->Destroy();
		_paeCF = NULL;
	}
	if(_paePF)
	{
		_paePF->Destroy();
		_paePF = NULL;
	}

	CBaseAE::Destroy();
	delete this;
}
	
/*
 *	CReplaceRangeAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		undoes a CTxtPtr::ReplaceRange operation
 *
 *	@rdesc
 *		HRESULT
 *
 *	@comm	
 *	Algorithm:
 *
 *		A replace range works as follows:  delete n characters and in their
 *		place, put m characters.
 *
 *		To undo this, we delete m characters and restore the n that were
 *		originally deleted.  Note that we restore the n characters with
 *		default formatting.  If there was any other formatting to those
 *		characters, a separate antievent (CReplaceFormattingAE) will
 *		apply the correct formatting.
 */
HRESULT CReplaceRangeAE::Undo(
	CTxtEdit *	  ped,		//@parm	Context for this undo operation
	IUndoBuilder *publdr)	//@parm Undo context	
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::Undo");

	CRchTxtPtr rtp(ped, _cpMin);
	LONG	   cchMove = 0;

	rtp.ReplaceRange(_cpMax - _cpMin, _cchDel, _pchDel,
					 publdr, -1, &cchMove,
					 RR_ITMZ_NONE | RR_NO_TRD_CHECK);	// RAID 6554

	// Passing NULL for the publdr is *extremely* important
	// below.  The rich text pointer ReplaceRange call will
	// already generate the appropriate antievents for any 
	// deleted formatting, so we do not need to repeat that here.
	if(_paeCF)
		_paeCF->Undo(ped, NULL);

	if(_paePF)
		_paePF->Undo(ped, NULL);

	if (ped->IsComplexScript())
	{
		// For complex script doc, we need itemization at the end of the range undo.
		// Since the formattings were rolled back, the rtp's runptrs are no longer
		// reliable.
		if (_paeCF && rtp._rpCF.IsValid())
			rtp._rpCF.BindToCp(_cpMin + _cchDel);

		if (_paePF && rtp._rpPF.IsValid())
			rtp._rpPF.BindToCp(_cpMin + _cchDel);

		rtp.ItemizeReplaceRange(_cchDel, cchMove, NULL, FALSE);
	}
	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceRangeAE::MergeData (dwDataType, pdata)	
 *
 *	@mfunc	gives the caller a chance to extend the current antievent
 *			if we're in merge typing mode
 *
 *	@rdesc
 *		HRESULT
 *
 *	@comm	if the requested data can be trivially merged into this
 *			antievent, then do so; otherwise, return S_FALSE.
 *
 *			There are two cases of interest:  <nl>
 *				1. typing another character
 *				2. backspacing over a character in this merge
 *				   typing session.
 */
HRESULT CReplaceRangeAE::MergeData(
	DWORD dwDataType, 		//@parm	Type of <p pdata>
	void *pdata)			//@parm Merge data
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::MergeData");

	if(dwDataType == MD_SIMPLE_REPLACERANGE)
	{
		SimpleReplaceRange *psr = (SimpleReplaceRange *)pdata;

		// Test for first case: just typing another character
		if(psr->cpMin == _cpMax && psr->cchDel == 0)
		{
			_cpMax = psr->cpMax;
			return NOERROR;
		}
		// Second case: deleting text stored in this antievent
		if (psr->cpMax == psr->cpMin &&
			psr->cpMin + psr->cchDel == _cpMax &&
			psr->cpMin >= _cpMin)
		{
			_cpMax = psr->cpMax;
			return NOERROR;
		}
	}
	return S_FALSE;
}	

/* 
 *	CReplaceRangeAE::CReplaceRangeAE (cpMin, cpMax, cchDel, pchDel, paeCF, paePF)
 *
 *	@mfunc	Constructor for a text replace range antievent
 */
CReplaceRangeAE::CReplaceRangeAE(
	LONG cpMin, 		//@parm cp starting the *final* range
	LONG cpMax, 		//@parm cp ending the *final* range
	LONG cchDel, 		//@parm # of chars deleted during ReplaceRange
	WCHAR *pchDel, 		//@parm Deleted characters. Ownership xfers to this object
	IAntiEvent *paeCF,	//@parm Antievent for any character formatting replacement
	IAntiEvent *paePF)	//@parm Antievent for any paragraph formatting replacement
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::CReplaceRangeAE");

	_cpMin 	= cpMin;
	_cpMax 	= cpMax;
	_cchDel = cchDel;
	_pchDel	= pchDel;
	_paeCF  = paeCF;
	_paePF  = paePF;
}

/*
 *	CReplaceRangeAE::~CReplaceRangeAE ()
 *
 *	@mfunc	Destructor
 */
CReplaceRangeAE::~CReplaceRangeAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::~CReplaceRangeAE");
		
	if(_pchDel)
		delete _pchDel;
}

/*
 *	CReplaceFormattingAE
 *
 *	@mfunc	Destroys this instance
 */
void CReplaceFormattingAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::Destroy");

	CBaseAE::Destroy();
	delete this;
}

/*
 *	CReplaceFormattingAE::Undo (ped, publdr)
 *
 *	@mfunc		Undoes a formatting operation
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote	This antievent assumes that the text to which formatting
 *				should be applied exists!!
 */			
HRESULT CReplaceFormattingAE::Undo(
	CTxtEdit *	  ped,		//@parm CTxtEdit closure
	IUndoBuilder *publdr)	//@parm Undo builder context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::Undo");

	LONG			cchEaten;
	LONG			cchTotal = 0;
	LONG			delta;
	LONG			iRunMerge;
	IAntiEvent *	pae;
	IFormatCache *	pf = _fPara
					   ? (IFormatCache *)GetParaFormatCache()
					   : (IFormatCache *)GetCharFormatCache();
	CNotifyMgr *	pnm = ped->GetNotifyMgr();
	CFormatRuns **	ppfmtruns;
	CTxtStory *		pStory = ped->GetTxtStory();
	const CParaFormat * pDefPF = _fPara ? pStory->GetParaFormat(-1) : NULL;
	BYTE			bDefPFLevel = pDefPF && pDefPF->IsRtl() ? 1 : 0;

	// First set things up correctly for whether we are paragraph
	// or character formatting
	CFormatRunPtr rp(_fPara ? pStory->GetPFRuns() :pStory->GetCFRuns());

	// Count up count of characters affected
	for(LONG i = 0 ; i < _cRuns; i++)
		cchTotal += _prgRuns[i]._cch;

	// We are going to be adding in some runs, so be sure the format
	// run array is allocated!
	if(!rp.IsValid())
	{
		ppfmtruns = _fPara ? &(pStory->_pPFRuns) : &(pStory->_pCFRuns);

		if(!rp.InitRuns(0, ped->GetTextLength(), ppfmtruns))
			return E_OUTOFMEMORY;

		// tell folks we allocated a new run
		if(pnm)
			pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, CP_INFINITE, CP_INFINITE);
	} 
	// Now do a pre-notification of the change we are about to make
	// This lets objects like a delayed render data object grab
	// any data *before* we change it.


	// Do a little more checking
#ifdef DEBUG
	LONG	cchText = ped->GetTextLength();
	LONG	cp =
#endif
	rp.BindToCp(_cp);

	AssertSz(_cp == cp && rp.CalcTextLength() == cchText && _cp <= cchText,
		"CReplaceFormattingAE::Undo: invalid cp");

	if(pnm)
		pnm->NotifyPreReplaceRange(NULL, CP_INFINITE, 0, 0, _cp, _cp + cchTotal);

	// We want to merge runs with where we start plus one behind
	iRunMerge = rp._iRun;
	if(iRunMerge > 0)
		iRunMerge--;

	// If we need to be able to undo this operation, go through and
	// save existing run information
	if(publdr)
	{
		LONG	cchBackup = 0, cchMove = 0;
		if (ped->IsBiDi())
		{
			// For redo'ing purpose, we expand the range to keep in the antievent
			// to make sure that BiDi levels are recorded adequately.
			CRchTxtPtr	rtp(ped, _cp);
			cchBackup = rtp.ExpandRangeFormatting(cchTotal, 0, cchMove);
			Assert(cchBackup <= 0);
			rp.Move(cchBackup);
		}
		pae = gAEDispenser.CreateReplaceFormattingAE(ped, _cp + cchBackup, rp,
					cchTotal - cchBackup + cchMove, pf, _fPara);
		rp.Move(-cchBackup);

		if(pae)
			publdr->AddAntiEvent(pae);
	}	

	// Now go through and apply the saved formatting.
	for(i = 0; i < _cRuns; i++)
	{
		cchEaten = 0;

        // Use a do-while, because we may have a zero-length
        // format run.  We know we need to do "something" at
        // least once, because otherwise, we would not have
        // bothered creating a run!
		do 
		{
			if (_fPara && _prgRuns[i]._iFormat == -1)
				// (#6768) The -1 format may have changed before undoing.
				_prgRuns[i]._level._value = bDefPFLevel;

			delta = rp.SetFormat(_prgRuns[i]._iFormat, 
							_prgRuns[i]._cch - cchEaten, pf, &_prgRuns[i]._level);
			if(delta == -1)
			{
				ped->GetCallMgr()->SetOutOfMemory();
				break;
			}
			cchEaten += delta;
		} while(cchEaten < _prgRuns[i]._cch);
	}

	// Merge formatting runs in case there are duplicate formatting
	// runs side by side
    rp.NextRun();
	rp.MergeRuns(iRunMerge, pf);

	// Make sure the runs are still OK  
	AssertNr(rp.CalcTextLength() == cchText);

	if(pnm)
		pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, _cp, _cp + cchTotal);

	ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceFormattingAE::CReplaceFormattingAE(ped, cp, &rpIn, cch, pf, fPara)
 *
 *	@mfunc	Constructor.  During construction, we will loop through and
 *			find all of the formats for the given text range
 */
CReplaceFormattingAE::CReplaceFormattingAE(
	CTxtEdit *	   ped,		//@parm CTxtEdit
	LONG		   cp,		//@parm cp at start of replace
	CFormatRunPtr &rpIn, 	//@parm	Run pointer to start with
	LONG		   cch,		//@parm cch to find formatting info on
	IFormatCache * pf,		//@parm Format cache (to AddRef/Release formats) 
	BOOL		   fPara)	//@parm If TRUE, formatting is for paras
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::CReplaceFormattingAE");

    LONG		  cchLeft;
	LONG		  cchTemp = cch;
	CFormatRunPtr rp(rpIn);			// We use 2 format run pointers to avoid
	CFormatRunPtr rpTemp(rpIn);		// backing up after counting the number of
									// format runs
	Assert(pf);

	_cp = cp;
	AssertSz(_cp == (cp = rpIn.CalculateCp()),
		"CReplaceFormattingAE::CReplaceFormattingAE: illegal cp");

	_fPara = fPara;

	// Count the number of formats needed.  Recall that even if no characters
    // are to be deleted, we may still be "deleting" a zero length format run.
	_cRuns = 0;
    do
	{
		_cRuns++;
        cchLeft = rp.GetCchLeft();
		cchTemp -= min(cchLeft, cchTemp);
	} while(rp.NextRun() && cchTemp > 0);

	_prgRuns = new CFormatRun[_cRuns];
	if(!_prgRuns)
	{
		_cRuns = 0;
		return;
	}

	for(LONG i = 0; i < _cRuns; i++)
	{
		_prgRuns[i]._cch = min(cch, rpTemp.GetCchLeft());
		CFormatRun *pRun = rpTemp.GetRun(0);

		_prgRuns[i]._iFormat = pRun->_iFormat;
		_prgRuns[i]._level	 = pRun->_level;

		pf->AddRef(_prgRuns[i]._iFormat);
		rpTemp.NextRun();
		cch -= _prgRuns[i]._cch;
	}
	Assert(cch == 0);
}

/*
 * 	CReplaceFormattingAE::~CReplaceFormattingAE	()
 *
 *	@mfunc	Destructor
 */
CReplaceFormattingAE::~CReplaceFormattingAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::~CReplaceFormattingAE");

	IFormatCache *	pf = _fPara
					   ? (IFormatCache *)GetParaFormatCache()
					   : (IFormatCache *)GetCharFormatCache();
	if(_prgRuns)
	{
		if(pf)
		{
			for(LONG i = 0; i < _cRuns; i++)
				pf->Release(_prgRuns[i]._iFormat);
		}
		delete _prgRuns;
	}
}

//
//	CReplaceObjectAE PUBLIC methods
//

/*
 *	CReplaceObjectAE::Destroy()
 *
 *	@mfunc	Destroy's this object
 */
void CReplaceObjectAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Destroy");

	COleObject *pobj = _pobj;
	_pobj = NULL;

	// We only need to zombie the object if it wasn't put back into
	// the document.
	if(!_fUndoInvoked)
		pobj->MakeZombie();

	pobj->Release();
	CBaseAE::Destroy();
	delete this;
}

/*
 *	CReplaceObjectAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		Undo'es the delete operation and restores the object
 *		to its original state
 *
 *	@rdesc	HRESULT
 */
HRESULT CReplaceObjectAE::Undo(
	CTxtEdit *	  ped,		//@parm	Edit context
	IUndoBuilder *publdr)	//@parm Undo/redo context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Undo");

	CObjectMgr *pobjmgr = ped->GetObjectMgr();
	if(_pobj && pobjmgr)
	{
		_fUndoInvoked = TRUE;
		_pobj->Restore();
		pobjmgr->RestoreObject(_pobj);
	}
	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceObjectAE::OnCommit(ped)
 *
 *	@mfunc	called when the antievent chain is committed to the
 *			undo stack.  This gives us a chance to make 'dangerous'
 *			calls that could cause us to be re-entered.
 */
void CReplaceObjectAE::OnCommit(
	CTxtEdit *ped)			//@parm Edit context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::OnCommit");
	_pobj->Close(OLECLOSE_SAVEIFDIRTY);
}

//
//	CReplaceObjectAE PRIVATE methods
//

/*
 *	CReplaceObjectAE::CReplaceObjectAE (pobj)
 *
 *	@mfunc	constructor
 */
CReplaceObjectAE::CReplaceObjectAE(
	COleObject *pobj)		//@parm Object that was deleted
{
	_fUndoInvoked = FALSE;
	_pobj = pobj;
	_pobj->AddRef();
}

/*
 *	CReplaceObjectAE::~CReplaceObjectAE
 *
 *	@mfunc	destructor
 */
CReplaceObjectAE::~CReplaceObjectAE()
{
	Assert(_pobj == NULL);
}

//
//	CResizeObjectAE PUBLIC methods
//

/*
*	CResizeObjectAE::Destroy ()
 *
 *	@mfunc	Destroy's this object
 */
void CResizeObjectAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CResizeObjectAE::Destroy");

	_pobj = NULL;
	CBaseAE::Destroy();

	delete this;
}

/*
 *	CResizeObjectAE::Undo(ped, publdr)
 *
 *	@mfunc	Undo'es the resize operation and restores the object
 *			to it's original size/position
 *
 *	@rdesc	HRESULT
 */
HRESULT CResizeObjectAE::Undo(
	CTxtEdit *	  ped,		//@parm	Edit context
	IUndoBuilder *publdr)	//@parm Undo/redo context
{
	CObjectMgr *pobjmgr;

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Undo");

	pobjmgr = ped->GetObjectMgr();

	if(_pobj && pobjmgr)
	{
		_fUndoInvoked = TRUE;
		_pobj->Resize(_size, FALSE);
	}

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CResizeObjectAE::OnCommit(ped)
 *
 *	@mfunc	called when the antievent chain is committed to the
 *			undo stack.  This gives us a chance to make 'dangerous'
 *			calls that could cause us to be re-entered.
 */
void CResizeObjectAE::OnCommit(
	CTxtEdit *ped)			//@parm Edit context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::OnCommit");
}

//
//	CResizeObjectAE PRIVATE methods
//

/*
 *	CResizeObjectAE::CResizeObjectAE (pobj, size)
 *
 *	@mfunc	constructor
 */
CResizeObjectAE::CResizeObjectAE(
	COleObject *pobj,		//@parm Object that was resized
	SIZEUV		size)		//@parm Old size
{
	_fUndoInvoked = FALSE;
	_pobj = pobj;
	_size = size;
}

/*
 *	CResizeObjectAE::~CResizeObjectAE
 *
 *	@mfunc	destructor
 */
CResizeObjectAE::~CResizeObjectAE()
{
	Assert(_pobj == NULL);
}

//
//  CSelectionAE PUBLIC methods
//

/*
 *  CSelectionAE::Destroy ()
 *
 *  @mfunc  gets rid of this instance
 */
void CSelectionAE::Destroy()
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::Destroy");

    CBaseAE::Destroy();
    delete this;
}

/*
 *  CSelectionAE::Undo (ped, publdr)
 *
 *  @mfunc  Restore selection to its former position
 *
 *  @rdesc  NOERROR
 */
HRESULT CSelectionAE::Undo(
    CTxtEdit *	  ped,		//@parm Edit context
    IUndoBuilder *publdr)   //@parm Undo context
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::Destroy");

    CTxtSelection *psel = ped->GetSel();

    if(psel)
        psel->SetDelayedSelectionRange(_cp, _cch);

	if(publdr)
	{
		IAntiEvent *pae;
		pae = gAEDispenser.CreateSelectionAE(ped, _cpNext, _cchNext, 
					_cp, _cch);
		if(pae)
			publdr->AddAntiEvent(pae);
	}
	return CBaseAE::Undo(ped, publdr);
}

/*
 *  CSelectionAE::MergeData(dwDataType, pdata)
 *
 *  @mfunc  merges new selection data
 *
 *  @rdesc  S_FALSE, NOERROR
 *
 *	@comm	The mergine algorithm is fairly tricky.  There are basically two
 *			cases of interest:  group typing and drag-move.
 *
 *			In the group typing case, the "start" of the typing becomes a
 *			fixed reference from which characters are added or removed (i.e.
 *			you type or hit the backspace key).  "Undo" should return you to
 *			that reference point; redo, on the other hand, should return the
 *			selection to the last insertion point.  Thus, we only update
 *			_xxNext for the SELAE_MERGE action.
 *
 *			Drag-Move is somewhat different; in this case, there are really
 *			two actions--the "paste" on the drop, and the subsequent "cut"
 *			operation.  Thus, we need to be able to update the selection
 *			antievent during the cut (since this only happens on move; not
 *			copies).  This is accomplished with teh FORCEREPLACE flag
 *			and by setting fields to -1 to be ignored.
 *
 */
HRESULT CSelectionAE::MergeData(
    DWORD dwDataType,       //@parm Type of data in <p pdata>
    void *pdata)            //@parm Merge data
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::MergeData");

    SelRange *psrg = (SelRange *)pdata;

    if(dwDataType == MD_SELECTIONRANGE)
    {
		if(psrg->flags == SELAE_MERGE)
		{
			Assert(psrg->cpNext != -1);
			_cpNext = psrg->cpNext;
			_cchNext = psrg->cchNext;
		}
		else
		{
			// -1 is used a no-op, so we should ignore it
			if(psrg->cp != -1)
			{
				_cp = psrg->cp;
				_cch = psrg->cch;
			}
			if(psrg->cpNext != -1)
			{
				_cpNext = psrg->cpNext;
				_cchNext = psrg->cchNext;
			}
		}
        return NOERROR;
    }
    return S_FALSE;
}

//
//  CSelectionAE PRIVATE methods
//

/*
 *  CSelectionAE::CSelectionAE (cp, cch, cpNext, cchNext)
 *
 *  @mfunc  Constructor
 */
CSelectionAE::CSelectionAE(
    LONG    cp,			//@parm Active end cp
    LONG    cch,        //@parm Signed extension
	LONG	cpNext,		//@parm cp to use for the AE of this AE
	LONG	cchNext)	//@parm cch for the AE of this AE
{
    _cp			= cp;
    _cch		= cch;
    _cpNext		= cpNext;
	_cchNext	= cchNext;
}

/*
 *  CSelectionAE::~CSelectionAE()
 *
 *  @mfunc  desctructor
 */
CSelectionAE::~CSelectionAE()
{
    ;
}

/*
 *	CAntiEventDispenser::CreateReplaceRangeAE(ped, cpMin, cpMax, cchDel,
 *											  pchDel, paeCF, paePF)
 *	@mfunc
 *		creates an antievent for a replace range operation 
 *
 *	@rdesc
 *		IAntiEvent *
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceRangeAE(
	CTxtEdit *	ped,	//@parm edit context
	LONG		cpMin, 	//@parm cp starting the *final* range
	LONG		cpMax, 	//@parm cp ending the *final* range
	LONG		cchDel, //@parm # of chars deleted during ReplaceRange
	WCHAR *		pchDel,	//@parm Deleted chars. Ownership transfers to this object
	IAntiEvent *paeCF,	//@parm Antievent for any char formatting replacement
	IAntiEvent *paePF)	//@parm Antievent for any para formatting replacement	
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CAntiEventDispenser::CreateReplaceRangeAE");

	// FUTURE (alexgo): improve the efficiency of this routine!!
	IAntiEvent *pae = (IAntiEvent *)(new CReplaceRangeAE(cpMin, cpMax,
									cchDel, pchDel, paeCF, paePF));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *	CAntiEventDispenser::CreateReplaceFormattingAE(ped, cp, &rp, cch, pf, fPara)
 *
 *	@mfunc
 *		Creates an antievent for replacing formatting
 *
 *	@rdesc
 *		IAntiEvent *
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceFormattingAE(
	CTxtEdit *		ped,	//@parm Edit context
	LONG			cp,		//@parm Position at start of replace
	CFormatRunPtr &	rp,		//@parm	Run pointer to start with
	LONG			cch,	//@parm Count of characters to find formatting info on
	IFormatCache *	pf,		//@parm Format cache (to AddRef/Release formats) 
	BOOL			fPara)	//@parm If TRUE, formatting is paragraphs
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CAntiEventDispenser::CreateReplaceFormattingAE");

	// FUTURE (alexgo): improve the efficiency of this routine!!!
	IAntiEvent *pae = (IAntiEvent *)(new CReplaceFormattingAE(ped, cp, rp, cch, pf, fPara));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *	CAntiEventDispenser::CreateReplaceObjectAE (ped, pobj)
 *
 *	@mfunc	Creates an antievent for replacing an object
 *
 *	@rdesc
 *		IAntiEvent * created
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceObjectAE(
	CTxtEdit *	ped,	//@parm Edit context.
	COleObject *pobj)	//@parm Object that was deleted
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, 
		"CAntiEventDispenser::CreateReplaceObjectAE");

	// Always allocating is probably a reasonable strategy for objects;
	// they are not expected to be the bread & butter case.
	IAntiEvent *pae = (IAntiEvent *)(new CReplaceObjectAE(pobj));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *	CAntiEventDispenser::CreateResizeObjectAE (ped, pobj, size)
 *
 *	@mfunc	Creates an antievent for resizing an object
 *
 *	@rdesc	the created antievent
 */
IAntiEvent * CAntiEventDispenser::CreateResizeObjectAE(
	CTxtEdit *	ped,	//@parm Edit context.
	COleObject *pobj,	//@parm Object that was resized
	SIZEUV		size)	//@parm Old object position rectangle
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, 
		"CAntiEventDispenser::CreateResizeeObjectAE");

	// Always allocating is probably a reasonable strategy for objects;
	// they are not expected to be the bread & butter case.
	IAntiEvent *pae = (IAntiEvent *)(new CResizeObjectAE(pobj, size));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *  CAntiEventDispenser::CreateSelectionAE (ped, cp, cch, cpNext, cchNext)
 *
 *  @mfunc  Creates an antievent for restoring a non-degenerate selection
 *
 *  @rdesc  created antievent
 */
IAntiEvent * CAntiEventDispenser::CreateSelectionAE(
	CTxtEdit *ped,		//@parm Edit context
    LONG    cp,			//@parm Active end of selection
    LONG    cch,        //@parm Signed extension
	LONG	cpNext,		//@parm cp to use for AE of this AE
	LONG	cchNext)	//@parm cch to use for AE 
{
	// FUTURE (alexgo): improve the efficiency of this routine
	IAntiEvent *pae = (IAntiEvent *)(new CSelectionAE(cp, cch, cpNext, cchNext));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\clasifyc.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module clasifyc.cpp -- Kinsoku classify characters |
 *	
 *		Used in word breaking procs, particularly important
 *		for properly wrapping a line.
 *	
 *	Authors: <nl>
 *		Jon Matousek
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */								 

//FUTURE (keithcu) Some of this data we could get from GetStringTypeEx which
//would make us smaller.

#include "_common.h"
#include "_clasfyc.h"
#include "_array.h"

ASSERTDATA

// Data for Kinsoku character classifications.
// NOTE: All values are for UNICODE characters.

// "dumb" quotes and other characters with no left/right orientation.
// This is a hack-around the Kinsoku rules, these are treated
// like an opening paren, when leading and kind of like a closing
// paren when follow--but will only break on white space in former case.
#define	brkclsQuote	0
#define C3_FullWidth	(C3_KATAKANA | C3_HIRAGANA | C3_IDEOGRAPH | C3_FULLWIDTH)

const WCHAR set0[] = {
	0x0022,	// QUOTATION MARK
	0x0027, // APOSTROPHE
	0x2019, // RIGHT SINGLE QUOTATION MARK
	0x301F,	// LOW DOUBLE PRIME QUOTATION MARK
	0xFF02,	// FULLWIDTH QUOTATION MARK
	0xFF07,	// FULLWIDTH APOSTROPHE
	0
};

// Opening-parenthesis character
#define	brkclsOpen	1

const WCHAR set1[] = {
	0x0028, // LEFT PARENTHESIS
	0x003C,	// LEFT ANGLE BRACKET
	0x005B, // LEFT SQUARE BRACKET
	0x007B, // LEFT CURLY BRACKET
	0x00AB, // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
	0x2018, // LEFT SINGLE QUOTATION MARK
	0x201C, // LEFT DOUBLE QUOTATION MARK
	0x2039, // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
	0x2045, // LEFT SQUARE BRACKET WITH QUILL
	0x207D, // SUPERSCRIPT LEFT PARENTHESIS
	0x208D, // SUBSCRIPT LEFT PARENTHESIS
	0x3008, // LEFT ANGLE BRACKET
	0x300A, // LEFT DOUBLE ANGLE BRACKET
	0x300C, // LEFT CORNER BRACKET
	0x300E, // LEFT WHITE CORNER BRACKET
	0x3010, // LEFT BLACK LENTICULAR BRACKET
	0x3014, // LEFT TORTOISE SHELL BRACKET
	0x3016, // LEFT WHITE LENTICULAR BRACKET
	0x3018, // LEFT WHITE TORTOISE SHELL BRACKET
	0x301A, // LEFT WHITE SQUARE BRACKET
	0x301D, // REVERSED DOUBLE PRIME QUOTATION MARK
	0xFD3E, // ORNATE LEFT PARENTHESIS
	0xFE59, // SMALL LEFT PARENTHESIS
	0xFE5B, // SMALL LEFT CURLY BRACKET
	0xFE5D, // SMALL LEFT TORTOISE SHELL BRACKET
	0xFF08, // FULLWIDTH LEFT PARENTHESIS
	0xFF3B, // FULLWIDTH LEFT SQUARE BRACKET
	0xFF5B, // FULLWIDTH LEFT CURLY BRACKET
	0xFF62, // HALFWIDTH LEFT CORNER BRACKET
	0xFFE9, // HALFWIDTH LEFTWARDS ARROW
	0
};


// Closing-parenthesis character
#define	brkclsClose	2

//FUTURE (keithcu) A dash next to a dash should be a break opportunity.

const WCHAR set2[] = {
	// 0x002C, // COMMA	moved to set 6 to conjoin numerals.
	0x002D,	// HYPHEN
	0x2013,	// EN-DASH
	0x2014,	// EM-DASH
	0x00AD,	// OPTIONAL HYPHEN
	0x055D, // ARMENIAN COMMA
	0x060C, // ARABIC COMMA
	0x3001, // IDEOGRAPHIC COMMA
	0xFE50, // SMALL COMMA
	0xFE51, // SMALL IDEOGRAPHIC COMMA
	0xFF0C, // FULLWIDTH COMMA
	0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA

	0x0029, // RIGHT PARENTHESIS
	0x003E,	// RIGHT ANGLE BRACKET
	0x005D, // RIGHT SQUARE BRACKET
	0x007D, // RIGHT CURLY BRACKET
	0x00BB, // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
	//0x2019, // RIGHT SINGLE QUOTATION MARK moved to set 0
	0x201D, // RIGHT DOUBLE QUOTATION MARK
	0x203A, // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
	0x2046, // RIGHT SQUARE BRACKET WITH QUILL
	0x207E, // SUPERSCRIPT RIGHT PARENTHESIS
	0x208E, // SUBSCRIPT RIGHT PARENTHESIS
	0x3009, // RIGHT ANGLE BRACKET
	0x300B, // RIGHT DOUBLE ANGLE BRACKET
	0x300D, // RIGHT CORNER BRACKET
	0x300F, // RIGHT WHITE CORNER BRACKET
	0x3011, // RIGHT BLACK LENTICULAR BRACKET
	0x3015, // RIGHT TORTOISE SHELL BRACKET
	0x3017, // RIGHT WHITE LENTICULAR BRACKET
	0x3019, // RIGHT WHITE TORTOISE SHELL BRACKET
	0x301B, // RIGHT WHITE SQUARE BRACKET
	0x301E, // DOUBLE PRIME QUOTATION MARK
	0xFD3F, // ORNATE RIGHT PARENTHESIS
	0xFE5A, // SMALL RIGHT PARENTHESIS
	0xFE5C, // SMALL RIGHT CURLY BRACKET
	0xFE5E, // SMALL RIGHT TORTOISE SHELL BRACKET
	0xFF09, // FULLWIDTH RIGHT PARENTHESIS
	0xFF3D, // FULLWIDTH RIGHT SQUARE BRACKET
	0xFF5D, // FULLWIDTH RIGHT CURLY BRACKET
	0xFF63, // HALFWIDTH RIGHT CORNER BRACKET
	0xFFEB, // HALFWIDTH RIGHTWARDS ARROW
	0
};

// 'Non-breaking' em-character at line-starting point
#define	brkclsGlueA	3

const WCHAR set3[] = {
	0x3005, // IDEOGRAPHIC ITERATION MARK
	0x309D, // HIRAGANA ITERATION MARK
	0x309E, // HIRAGANA VOICED ITERATION MARK
	0x30FC, // KATAKANA-HIRAGANA PROLONGED SOUND MARK
	0x30FD, // KATAKANA ITERATION MARK
	0x30FE, // KATAKANA VOICED ITERATION MARK
	0x3041, // HIRAGANA LETTER SMALL A
	0x3043, // HIRAGANA LETTER SMALL I
	0x3045, // HIRAGANA LETTER SMALL U
	0x3047, // HIRAGANA LETTER SMALL E
	0x3049, // HIRAGANA LETTER SMALL O
	0x3063, // HIRAGANA LETTER SMALL TU
	0x3083, // HIRAGANA LETTER SMALL YA
	0x3085, // HIRAGANA LETTER SMALL YU
	0x3087, // HIRAGANA LETTER SMALL YO
	0x308E, // HIRAGANA LETTER SMALL WA
	0x309B,	// KATAKANA-HIRAGANA VOICED SOUND MARK
	0x309C,	// KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
	0x30A1, // KATAKANA LETTER SMALL A
	0x30A3, // KATAKANA LETTER SMALL I
	0x30A5, // KATAKANA LETTER SMALL U
	0x30A7, // KATAKANA LETTER SMALL E
	0x30A9, // KATAKANA LETTER SMALL O
	0x30C3, // KATAKANA LETTER SMALL TU
	0x30E3, // KATAKANA LETTER SMALL YA
	0x30E5, // KATAKANA LETTER SMALL YU
	0x30E7, // KATAKANA LETTER SMALL YO
	0x30EE, // KATAKANA LETTER SMALL WA
	0x30F5, // KATAKANA LETTER SMALL KA
	0x30F6, // KATAKANA LETTER SMALL KE
	0xFF67, // HALFWIDTH KATAKANA LETTER SMALL A
	0xFF68, // HALFWIDTH KATAKANA LETTER SMALL I
	0xFF69, // HALFWIDTH KATAKANA LETTER SMALL U
	0xFF6A, // HALFWIDTH KATAKANA LETTER SMALL E
	0xFF6B, // HALFWIDTH KATAKANA LETTER SMALL O
	0xFF6C, // HALFWIDTH KATAKANA LETTER SMALL YA
	0xFF6D, // HALFWIDTH KATAKANA LETTER SMALL YU
	0xFF6E, // HALFWIDTH KATAKANA LETTER SMALL YO
	0xFF6F, // HALFWIDTH KATAKANA LETTER SMALL TU
	0xFF70, // HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK
	0xFF9E,	// HALFWIDTH KATAKANA VOICED SOUND MARK
	0xFF9F,	// HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
	0
};

// Expression mark
#define	brkclsExclaInterr	4

const WCHAR set4[] = {
	0x0021, // EXCLAMATION MARK
	0x003F, // QUESTION MARK
	0x00A1, // INVERTED EXCLAMATION MARK
	0x00BF, // INVERTED QUESTION MARK
	0x01C3, // LATIN LETTER RETROFLEX CLICK
	0x037E, // GREEK QUESTION MARK
	0x055C, // ARMENIAN EXCLAMATION MARK
	0x055E, // ARMENIAN QUESTION MARK
	0x055F, // ARMENIAN ABBREVIATION MARK
	0x061F, // ARABIC QUESTION MARK
	0x203C, // DOUBLE EXCLAMATION MARK
	0x203D, // INTERROBANG
	0x2762, // HEAVY EXCLAMATION MARK ORNAMENT
	0x2763, // HEAVY HEART EXCLAMATION MARK ORNAMENT
	0xFE56, // SMALL QUESTION MARK
	0xFE57, // SMALL EXCLAMATION MARK
	0xFF01, // FULLWIDTH EXCLAMATION MARK
	0xFF1F, // FULLWIDTH QUESTION MARK
	0
};

// Centered punctuation mark

const WCHAR set5[] = {		        
//	0x003A,	// COLON		moved to set 6 to conjoin numerals.
//	0x003B, // SEMICOLON	moved to set 6 to conjoin numerals
	0x00B7, // MIDDLE DOT
	0x30FB, // KATAKANA MIDDLE DOT
	0xFF65, // HALFWIDTH KATAKANA MIDDLE DOT
	0x061B, // ARABIC SEMICOLON
	0xFE54, // SMALL SEMICOLON
	0xFE55, // SMALL COLON
	0xFF1A, // FULLWIDTH COLON
	0xFF1B, // FULLWIDTH SEMICOLON
	0
};

// Punctuation mark		// diverged from the Kinsoku tables to enhance 
#define	brkclsSlash	6

const WCHAR set6[] = {	// How colon, comma, and full stop are treated around 
	0x002C, // COMMA	//  numerals and set 15 (roman text).
	0x002f,	// SLASH	// But don't break up URLs (see IsURLDelimiter())!
	0x003A, // COLON
	0x003B, // SEMICOLON

	0x002E, // FULL STOP (PERIOD)
	0x0589, // ARMENIAN FULL STOP
	0x06D4, // ARABIC FULL STOP
	0x3002, // IDEOGRAPHIC FULL STOP
	0xFE52, // SMALL FULL STOP
	0xFF0E, // FULLWIDTH FULL STOP
	0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP
	0
};

// Inseparable character
#define	brkclsInseparable	7

const WCHAR set7[] = {
	0		// FUTURE (alexgo): maybe handle these.
};

// Pre-numeral abbreviation
#define	brkclsPrefix	8

const WCHAR set8[] = {
	0x0024, // DOLLAR SIGN
	0x00A3, // POUND SIGN
	0x00A4, // CURRENCY SIGN
	0x00A5, // YEN SIGN
	0x005C, // REVERSE SOLIDUS (looks like Yen in FE fonts.)
	0x0E3F, // THAI CURRENCY SYMBOL BAHT
	0x20AC, // EURO-CURRENCY SIGN
	0x20A1, // COLON SIGN
	0x20A2, // CRUZEIRO SIGN
	0x20A3, // FRENCH FRANC SIGN
	0x20A4, // LIRA SIGN
	0x20A5, // MILL SIGN
	0x20A6, // NAIRA SIGN
	0x20A7, // PESETA SIGN
	0x20A8, // RUPEE SIGN
	0x20A9, // WON SIGN
	0x20AA, // NEW SHEQEL SIGN

	0xFF04, // FULLWIDTH DOLLAR SIGN
	0xFFE5,	// FULLWIDTH YEN SIGN
	0xFFE6,	// FULLWIDTH WON SIGN

	0xFFE1,	// FULLWIDTH POUND SIGN
	0
};

// Post-numeral abbreviation
#define	brkclsPostfix	9

const WCHAR set9[] = {
	0x00A2, // CENT SIGN
	0x00B0, // DEGREE SIGN
	0x2103, // DEGREE CELSIUS
	0x2109, // DEGREE FAHRENHEIT
	0x212A, // KELVIN SIGN
	0x0025, // PERCENT SIGN
	0x066A, // ARABIC PERCENT SIGN
	0xFE6A, // SMALL PERCENT SIGN
	0xFF05, // FULLWIDTH PERCENT SIGN
	0x2030, // PER MILLE SIGN
	0x2031, // PER TEN THOUSAND SIGN
	0x2032, // PRIME
	0x2033, // DOUBLE PRIME
	0x2034, // TRIPLE PRIME
	0x2035, // REVERSED PRIME
	0x2036, // REVERSED DOUBLE PRIME
	0x2037,	// REVERSED TRIPLE PRIME

	0xFF05,	// FULLWIDTH PERCENT SIGN
	0xFFE0,	// FULLWIDTH CENT SIGN
	0
};

// Japanese space (blank) character
#define	brkclsNoStartIdeo	10

const WCHAR set10[] = {
	0x3000,  // IDEOGRAPHIC SPACE
	0
};

// Japanese characters other than above
#define	brkclsIdeographic	11

const WCHAR set11[] = {
	0		//we use GetStringTypeEx
};

// Characters included in numeral-sequence
#define	brkclsNumeral	12

const WCHAR set12[] = {
	0x0030, // DIGIT ZERO
	0x0031, // DIGIT ONE
	0x0032, // DIGIT TWO
	0x0033, // DIGIT THREE
	0x0034, // DIGIT FOUR
	0x0035, // DIGIT FIVE
	0x0036, // DIGIT SIX
	0x0037, // DIGIT SEVEN
	0x0038, // DIGIT EIGHT
	0x0039, // DIGIT NINE
	0x0660, // ARABIC-INDIC DIGIT ZERO
	0x0661, // ARABIC-INDIC DIGIT ONE
	0x0662, // ARABIC-INDIC DIGIT TWO
	0x0663, // ARABIC-INDIC DIGIT THREE
	0x0664, // ARABIC-INDIC DIGIT FOUR
	0x0665, // ARABIC-INDIC DIGIT FIVE
	0x0666, // ARABIC-INDIC DIGIT SIX
	0x0667, // ARABIC-INDIC DIGIT SEVEN
	0x0668, // ARABIC-INDIC DIGIT EIGHT
	0x0669, // ARABIC-INDIC DIGIT NINE
	0x06F0, // EXTENDED ARABIC-INDIC DIGIT ZERO
	0x06F1, // EXTENDED ARABIC-INDIC DIGIT ONE
	0x06F2, // EXTENDED ARABIC-INDIC DIGIT TWO
	0x06F3, // EXTENDED ARABIC-INDIC DIGIT THREE
	0x06F4, // EXTENDED ARABIC-INDIC DIGIT FOUR
	0x06F5, // EXTENDED ARABIC-INDIC DIGIT FIVE
	0x06F6, // EXTENDED ARABIC-INDIC DIGIT SIX
	0x06F7, // EXTENDED ARABIC-INDIC DIGIT SEVEN
	0x06F8, // EXTENDED ARABIC-INDIC DIGIT EIGHT
	0x06F9, // EXTENDED ARABIC-INDIC DIGIT NINE
	0x0966, // DEVANAGARI DIGIT ZERO
	0x0967, // DEVANAGARI DIGIT ONE
	0x0968, // DEVANAGARI DIGIT TWO
	0x0969, // DEVANAGARI DIGIT THREE
	0x096A, // DEVANAGARI DIGIT FOUR
	0x096B, // DEVANAGARI DIGIT FIVE
	0x096C, // DEVANAGARI DIGIT SIX
	0x096D, // DEVANAGARI DIGIT SEVEN
	0x096E, // DEVANAGARI DIGIT EIGHT
	0x096F, // DEVANAGARI DIGIT NINE
	0x09E6, // BENGALI DIGIT ZERO
	0x09E7, // BENGALI DIGIT ONE
	0x09E8, // BENGALI DIGIT TWO
	0x09E9, // BENGALI DIGIT THREE
	0x09EA, // BENGALI DIGIT FOUR
	0x09EB, // BENGALI DIGIT FIVE
	0x09EC, // BENGALI DIGIT SIX
	0x09ED, // BENGALI DIGIT SEVEN
	0x09EE, // BENGALI DIGIT EIGHT
	0x09EF, // BENGALI DIGIT NINE
	0x0A66, // GURMUKHI DIGIT ZERO
	0x0A67, // GURMUKHI DIGIT ONE
	0x0A68, // GURMUKHI DIGIT TWO
	0x0A69, // GURMUKHI DIGIT THREE
	0x0A6A, // GURMUKHI DIGIT FOUR
	0x0A6B, // GURMUKHI DIGIT FIVE
	0x0A6C, // GURMUKHI DIGIT SIX
	0x0A6D, // GURMUKHI DIGIT SEVEN
	0x0A6E, // GURMUKHI DIGIT EIGHT
	0x0A6F, // GURMUKHI DIGIT NINE
	0x0AE6, // GUJARATI DIGIT ZERO
	0x0AE7, // GUJARATI DIGIT ONE
	0x0AE8, // GUJARATI DIGIT TWO
	0x0AE9, // GUJARATI DIGIT THREE
	0x0AEA, // GUJARATI DIGIT FOUR
	0x0AEB, // GUJARATI DIGIT FIVE
	0x0AEC, // GUJARATI DIGIT SIX
	0x0AED, // GUJARATI DIGIT SEVEN
	0x0AEE, // GUJARATI DIGIT EIGHT
	0x0AEF, // GUJARATI DIGIT NINE
	0x0B66, // ORIYA DIGIT ZERO
	0x0B67, // ORIYA DIGIT ONE
	0x0B68, // ORIYA DIGIT TWO
	0x0B69, // ORIYA DIGIT THREE
	0x0B6A, // ORIYA DIGIT FOUR
	0x0B6B, // ORIYA DIGIT FIVE
	0x0B6C, // ORIYA DIGIT SIX
	0x0B6D, // ORIYA DIGIT SEVEN
	0x0B6E, // ORIYA DIGIT EIGHT
	0x0B6F, // ORIYA DIGIT NINE
	0x0BE7, // TAMIL DIGIT ONE
	0x0BE8, // TAMIL DIGIT TWO
	0x0BE9, // TAMIL DIGIT THREE
	0x0BEA, // TAMIL DIGIT FOUR
	0x0BEB, // TAMIL DIGIT FIVE
	0x0BEC, // TAMIL DIGIT SIX
	0x0BED, // TAMIL DIGIT SEVEN
	0x0BEE, // TAMIL DIGIT EIGHT
	0x0BEF, // TAMIL DIGIT NINE
	0x0BF0, // TAMIL NUMBER TEN
	0x0BF1, // TAMIL NUMBER ONE HUNDRED
	0x0BF2, // TAMIL NUMBER ONE THOUSAND
	0x0C66, // TELUGU DIGIT ZERO
	0x0C67, // TELUGU DIGIT ONE
	0x0C68, // TELUGU DIGIT TWO
	0x0C69, // TELUGU DIGIT THREE
	0x0C6A, // TELUGU DIGIT FOUR
	0x0C6B, // TELUGU DIGIT FIVE
	0x0C6C, // TELUGU DIGIT SIX
	0x0C6D, // TELUGU DIGIT SEVEN
	0x0C6E, // TELUGU DIGIT EIGHT
	0x0C6F, // TELUGU DIGIT NINE
	0x0CE6, // KANNADA DIGIT ZERO
	0x0CE7, // KANNADA DIGIT ONE
	0x0CE8, // KANNADA DIGIT TWO
	0x0CE9, // KANNADA DIGIT THREE
	0x0CEA, // KANNADA DIGIT FOUR
	0x0CEB, // KANNADA DIGIT FIVE
	0x0CEC, // KANNADA DIGIT SIX
	0x0CED, // KANNADA DIGIT SEVEN
	0x0CEE, // KANNADA DIGIT EIGHT
	0x0CEF, // KANNADA DIGIT NINE
	0x0D66, // MALAYALAM DIGIT ZERO
	0x0D67, // MALAYALAM DIGIT ONE
	0x0D68, // MALAYALAM DIGIT TWO
	0x0D69, // MALAYALAM DIGIT THREE
	0x0D6A, // MALAYALAM DIGIT FOUR
	0x0D6B, // MALAYALAM DIGIT FIVE
	0x0D6C, // MALAYALAM DIGIT SIX
	0x0D6D, // MALAYALAM DIGIT SEVEN
	0x0D6E, // MALAYALAM DIGIT EIGHT
	0x0D6F, // MALAYALAM DIGIT NINE
	0x0E50, // THAI DIGIT ZERO
	0x0E51, // THAI DIGIT ONE
	0x0E52, // THAI DIGIT TWO
	0x0E53, // THAI DIGIT THREE
	0x0E54, // THAI DIGIT FOUR
	0x0E55, // THAI DIGIT FIVE
	0x0E56, // THAI DIGIT SIX
	0x0E57, // THAI DIGIT SEVEN
	0x0E58, // THAI DIGIT EIGHT
	0x0E59, // THAI DIGIT NINE
	0x0ED0, // LAO DIGIT ZERO
	0x0ED1, // LAO DIGIT ONE
	0x0ED2, // LAO DIGIT TWO
	0x0ED3, // LAO DIGIT THREE
	0x0ED4, // LAO DIGIT FOUR
	0x0ED5, // LAO DIGIT FIVE
	0x0ED6, // LAO DIGIT SIX
	0x0ED7, // LAO DIGIT SEVEN
	0x0ED8, // LAO DIGIT EIGHT
	0x0ED9, // LAO DIGIT NINE
	0xFF10, // FULLWIDTH DIGIT ZERO
	0xFF11, // FULLWIDTH DIGIT ONE
	0xFF12, // FULLWIDTH DIGIT TWO
	0xFF13, // FULLWIDTH DIGIT THREE
	0xFF14, // FULLWIDTH DIGIT FOUR
	0xFF15, // FULLWIDTH DIGIT FIVE
	0xFF16, // FULLWIDTH DIGIT SIX
	0xFF17, // FULLWIDTH DIGIT SEVEN
	0xFF18, // FULLWIDTH DIGIT EIGHT
	0xFF19, // FULLWIDTH DIGIT NINE

	0x3007, // IDEOGRAPHIC NUMBER ZERO
	0x3021, // HANGZHOU NUMERAL ONE
	0x3022, // HANGZHOU NUMERAL TWO
	0x3023, // HANGZHOU NUMERAL THREE
	0x3024, // HANGZHOU NUMERAL FOUR
	0x3025, // HANGZHOU NUMERAL FIVE
	0x3026, // HANGZHOU NUMERAL SIX
	0x3027, // HANGZHOU NUMERAL SEVEN
	0x3028, // HANGZHOU NUMERAL EIGHT
	0x3029, // HANGZHOU NUMERAL NINE
	0
};

// Characters included in unit symbol group
const WCHAR set13[] = {
	0		//we use GetStringTypeEx
};

//Roman inter-word space
#define	brkclsSpaceN	14

const WCHAR set14[] = {
	0x0009,	// TAB
	0x0020, // SPACE
	0x2002, // EN SPACE
	0x2003, // EM SPACE
	0x2004, // THREE-PER-EM SPACE
	0x2005, // FOUR-PER-EM SPACE
	0x2006, // SIX-PER-EM SPACE
	0x2007, // FIGURE SPACE
	0x2008, // PUNCTUATION SPACE
	0x2009, // THIN SPACE
	0x200A, // HAIR SPACE
	0x200B,  // ZERO WIDTH SPACE
	WCH_EMBEDDING, // OBJECT EMBEDDING (0xFFFC)
	0
};

// Roman characters
#define	brkclsAlpha	15

const WCHAR set15[] = {
	0		//we use GetStringTypeEx
};

// So we can easily loop over all Kinsoku categories.
const WCHAR *charCategories[] = {
	set0,
	set1,
	set2,
	set3,
	set4,
	set5,
	set6,
	set7,
	set8,
	set9,
	set10,
	set11,
	set12,
	set13,
	set14,
	set15
};

static const INT classifyChunkSize = 64;
static const INT indexSize = 65536 / classifyChunkSize;
static const INT classifyBitMapSize = indexSize / 8;
static const INT bitmapShift = 6; // 16 - log(indexSize)/log(2)

typedef struct {
	CHAR classifications[classifyChunkSize];		// must be unsigned bytes!
} ClassifyChunk;

static ClassifyChunk *classifyData;					// Chunk array, sparse chrs
static BYTE *classifyIndex;							// Indexes into chunk array


/*
 *	BOOL InitKinsokuClassify()
 *
 *	@func
 *		Map the static character tables into a compact array for
 *		quick lookup of the characters Kinsoku classification.
 *
 *	@comm
 *		Kinsoku classification is necessary for word breaking and
 *		may be neccessary for proportional line layout, Kinsoku style.
 *
 *	@devnote
 *		We break the entire Unicode range in to chunks of characters.
 *		Not all of the chunks will have data in them. We do not
 *		maintain information on empty chunks, therefore we create
 *		a compact, contiguous array of chunks for only the chunks
 *		that do contain information. We prepend 1 empty chunk to the
 *		beginning of this array, where all of the empty chunks map to,
 *		this prevents a contiontional test on NULL data. The lookup
 *		will return 0 for any character not in the tables, so the client
 *		will then need to process the character further in such cases.
 *
 *	@rdesc
 *		return TRUE if we successfully created the lookup table.
 */
BOOL InitKinsokuClassify()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "InitKinsokuClassify");

	WORD	bitMapKey;								// For calcing total chunks
	BYTE	bitData;								// For calcing total chunks
	WCHAR	ch;
	LPCWSTR pWChar;								// Looping over char sets.
	INT		i, j, count;							// Loop support.
	BYTE	classifyBitMap[classifyBitMapSize],		// Temp bitmap.
			*pIndex;								// Index into chunk array.

	// See how many chunks we'll need. We loop over all of the special
	//  characters
	AssertSz(cKinsokuCategories == ARRAY_SIZE(charCategories),
		"InitKinsokuClassify: incorrect Kinsoku-category count");

	ZeroMemory(classifyBitMap, sizeof(classifyBitMap));
	for (i = 0; i < cKinsokuCategories; i++ )
	{
		pWChar = charCategories[i];
		while ( ch = *pWChar++ )
		{
			bitMapKey = ch >> bitmapShift;
			classifyBitMap[bitMapKey >> 3] |= 1 << (bitMapKey & 7);
		}
	}

	// Now that we know how many chunks we'll need, allocate the memory.
	count = 1 + CountMatchingBits((DWORD *)classifyBitMap, (DWORD *)classifyBitMap, sizeof(classifyBitMap)/sizeof(DWORD));
	classifyData = (ClassifyChunk *) PvAlloc( sizeof(ClassifyChunk) * count, GMEM_ZEROINIT);
	classifyIndex = (BYTE *) PvAlloc( sizeof(BYTE) * indexSize, GMEM_ZEROINIT);

	// We failed if we did not get the memory.
	if ( !classifyData || !classifyIndex )
		return FALSE;								// FAILED.

	// Set Default missing value.
	FillMemory( classifyData, -1, sizeof(ClassifyChunk) * count );  

	// Init the pointers to the chunks, which are really just indexes into
	//  a contiguous block of memory -- an one-based array of chunks.
	pIndex = classifyIndex;
	count = 1;										// 1 based array.
	for (i = 0; i < sizeof(classifyBitMap); i++ )	// Loop over all bytes.
	{												// Get the bitmap data.
		bitData = classifyBitMap[i];				// For each bit in the byte
		for (j = 0; j < 8; j++, bitData >>= 1, pIndex++)
		{
			if(bitData & 1)			
				*pIndex = count++;					// We used a chunk.
		}
	}
	
	// Store the classifications of each character.
	// Note: classifications are 1 based, a zero value
	//  means the category was not set.
	for (i = 0; i < cKinsokuCategories; i++ )
	{
		pWChar = charCategories[i];					// Loop over all chars in
		while ( ch = *pWChar++ )					//  category.
		{
			bitMapKey = ch >> bitmapShift;
			Assert( classifyIndex[bitMapKey] > 0 );
			Assert( classifyIndex[bitMapKey] < count );

			classifyData[classifyIndex[bitMapKey]].
				classifications[ ch & ( classifyChunkSize-1 )] = (char)i;
		}
	}
	return TRUE;									// Successfully created.
}

void UninitKinsokuClassify()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "UninitKinsokuClassify");

	FreePv(classifyData);
	FreePv(classifyIndex);
}

/*
 *	KinsokuClassify(ch)
 *
 *	@func
 *		Kinsoku classify the character iff it was a given from
 *		one of the classification tables.
 *
 *	@comm
 *		Hi order bits of ch are used to get an index value used to index
 *		into an array of chunks. Each chunk contains the classifications
 *		for that character as well as some number of characters adjacent
 *		to that character. The low order bits are used to index into
 *		the chunk of adjacent characters.
 *
 *	@devnote
 *		Because of the way we constructed the array, all that we need to
 *		do is look up the data; no conditionals necessary.
 *
 *		The routine is inline to avoid the call overhead. It is static
 *		because it only returns characters from the tables; i.e., this 
 *		routine does NOT classify all Unicode characters.
 *
 *	@rdesc
 *		Returns the classification.
 */
static __forceinline INT
KinsokuClassify(
	WCHAR ch )	// @parm char to classify.
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "KinsokuClassify");

	return classifyData[ classifyIndex[ ch >> bitmapShift ] ].
			classifications[ ch & ( classifyChunkSize-1 )];
}


#define IsSameNonFEClass(_c1, _c2)	(!(((_c1) ^ (_c2)) & WBF_CLASS))
#define IdeoKanaTypes (C3_HALFWIDTH | C3_FULLWIDTH | C3_KATAKANA | C3_HIRAGANA)
#define IdeoTypes	  (IdeoKanaTypes | C3_IDEOGRAPH)
#define IsIdeographic(_c1) ( 0 != (_c1 & (C3_KATAKANA | C3_HIRAGANA | C3_IDEOGRAPH)) )

/*
 *	IsSameClass(currType1, startType1, currType3, startType3 )
 *
 *	@func	Used to determine word breaks.
 *
 *	@comm	Ideographic chars are all considered to be unique, so that only
 *			one at a time is selected
 */
BOOL IsSameClass(WORD currType1, WORD startType1,
				 WORD currType3, WORD startType3 )
{
	BOOL	fIdeographic = IsIdeographic(currType3);

	// Do classifications for startType3 being ideographic
	if(IsIdeographic(startType3))
	{
		int checkTypes = (currType3 & IdeoTypes) ^ (startType3 & IdeoTypes);

		// We only get picky with non-ideographic Kana chars
		//  C3_HALFWIDTH | C3_FULLWIDTH | C3_KATAKANA | C3_HIRAGANA.
		return fIdeographic && (startType3 & IdeoKanaTypes) &&
			   (!checkTypes || checkTypes == C3_FULLWIDTH || checkTypes == C3_HIRAGANA || 
			   checkTypes == (C3_FULLWIDTH | C3_HIRAGANA));
	}	

	// Do classifications for nonideographic startType3
	return !fIdeographic && IsSameNonFEClass(currType1, startType1);
}

WORD ClassifyChar(
	WCHAR	ch,
	LCID	lcid)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "ClassifyChar");
	WORD wRes, cType3;
	int kinsokuclass;

	BatchClassify(&ch, 1, lcid, &cType3, &kinsokuclass, &wRes);
	return wRes;
}


//
//This is a cache of the wres information for ansi.
//
const byte rgwresAnsi[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, //0x00
0x00, 0x13, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, //0x08
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x10
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x18
0x32, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0x20
0x01, 0x01, 0x01, 0x01, 0x01, 0x41, 0x01, 0x01, //0x28
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x30
0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0x38
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x40
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x48
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x50
0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, //0x58
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x60
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x68
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x70
0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, //0x78
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x80
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x88
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x90
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x98
0x12, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0xA0
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0xA8
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0xB0
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0xB8
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xC0
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xC8
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, //0xD0
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xD8
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xE0
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xE8
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xF0
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};//0xF8

/*
 *	BatchClassify (pch, cch, lcid, pcType3, kinsokuClassifications, pwRes)
 *
 *	@func
 *		Kinsoku classify and ClassifyChar() each character of the given string.
 *
 *	@comm
 *		The Kinsoku classifications are passed to the CanBreak() routine. We
 *		do process in batch to save on overhead.
 *
 *		If the character is not in the Kinsoku classification tables then
 *		GetStringTypeEx is used to classify any remaining character.
 *
 *		*Note* Using CT_CTYPE1 values alone is unreliable since CT_CTYPE1
 *		defines C1_PUNCT for all diacritic characters. According to KDChang,
 *		this is by design for POSIX compatibility and it couldn't be changed
 *		easily since Win9x shares the same NLS data with NT. (wchao)
 *		Therefore we use CT_CTYPE3 data to distinguish diacritics, except on
 *		Win9x, for which we use a range check, since GetStringTypeExW isn't
 *		supported).
 *
 *	@rdesc
 *		Result in out param kinsokuClassifications.
 *		pcType3 result from GetStringTypeEx for CT_CTYPE3
 */
void BatchClassify (
	const WCHAR *pch,	//@parm char string
	INT	  cch,			//@parm Count of chars in string
	LCID  lcid,			//@parm lcid to use for GetStringTypeExA()
	WORD *pcType3,		//@parm Result of GetStringTypeEx for CT_CTYPE3
	INT * kinsokuClassifications,	// @parm Result of the classifications
	WORD *pwRes)		//@parm ClassifyChar() result
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "BatchClassify");

	WCHAR	ch;
	WORD	wRes;

	Assert( cch < MAX_CLASSIFY_CHARS );
	Assert( pch );
	Assert( kinsokuClassifications );

	W32->GetStringTypes(lcid, pch, cch, pwRes, pcType3);

	while ( cch-- )									// For all ch...
	{
		wRes = *pwRes;
		ch = *pch++;
		
		if (ch <= 255)
			wRes = rgwresAnsi[ch];
		else if(IsKorean(ch))								
			wRes = WBF_KOREAN;						// Special Korean class
		else if (IsThai(ch))
			wRes = 0;						// Thai class
		else if (ch == WCH_EMBEDDING)				// Objects
			wRes = 2 | WBF_BREAKAFTER;
		else if(wRes & C1_SPACE)
		{
			if (wRes & C1_BLANK)
				wRes = 2 | WBF_ISWHITE | WBF_BREAKLINE;
			else
				wRes = 4 | WBF_ISWHITE | WBF_BREAKLINE;
		}
		else if((wRes & C1_PUNCT) && !IsDiacriticOrKashida(ch, *pcType3))
			wRes = 1;
		else 
			wRes = 0;

		*pwRes++ = wRes;

		*kinsokuClassifications++ = GetKinsokuClass(ch, *pcType3, lcid);
		pcType3++;
	}
}


/*
 *	GetKinsokuClass (ch, cType3, lcid)
 *
 *	@func
 *		Kinsoku classify ch
 *
 *	@comm
 *		The Kinsoku classifications are passed to the CanBreak() routine. This
 *		single-character routine is for use with LineServices
 *
 *		If the character is not in the Kinsoku classification tables then
 *		GetStringTypeEx is used to classify any remaining character.
 *
 *	@rdesc
 *		Kinsoku classification for ch
 */
INT GetKinsokuClass (
	WCHAR	ch,		//@parm char 
	WORD	cType3,	//@parm cType3 info
	LCID	lcid)	//@parm lcid
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "GetKinsokuClass");

	// surrogate classification
	if (IN_RANGE(0xD800, ch, 0xDFFF))
		return IN_RANGE(0xDC00, ch, 0xDFFF) ? brkclsClose : brkclsOpen;

	INT iCategory = KinsokuClassify(ch);
	if(iCategory >= 0)
		return iCategory;

	if (cType3 == 0xFFFF)
		W32->GetStringTypeEx(lcid, CT_CTYPE3, &ch, 1, &cType3);

	if(cType3 & C3_SYMBOL)
		return 13;							// Symbol chars

	if(IsKorean(ch) || cType3 & C3_FullWidth)
		return 11;							// Ideographic chars

	return 15;								// All other chars.
}

/*
 *	CanBreak(class1, class2)
 *
 *	@func
 *		Look into the truth table to see if two consecutive charcters
 *		can have a line break between them.
 *
 *	@comm
 *		This determines whether two successive characters can break a line.
 *		The matrix is taken from JIS X4051 and is based on categorizing
 *		characters into 15 classifications.
 *
 *	@devnote
 *		The table is 1 based.
 *
 *	@rdesc
 *		Returns TRUE if the characters can be broken across a line.
 */
BOOL CanBreak(
	INT class1,		//@parm	Kinsoku classification of character #1
	INT class2 )	//@parm	Kinsoku classification of following character.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CanBreak");

	static const WORD br[16] = {//   fedc ba98 7654 3210
		0x0000,					// 0 0000 0000 0000 0000
		0x0000,					// 1 0000 0000 0000 0000
		0xfd82,					// 2 1111 1101 1000 0010
		0xfd82,					// 3 1111 1101 1000 0010
		0xfd82,					// 4 1111 1101 1000 0010
		0xfd82,					// 5 1111 1101 1000 0010
		0x6d82,					// 6 0110 1101 1000 0010
		0xfd02,					// 7 1111 1101 0000 0010
		0x0000,					// 8 0000 0000 0000 0000
		0xfd82,					// 9 1111 1101 1000 0010
		0xfd83,					// a 1111 1101 1000 0011
		0xfd82,					// b 1111 1101 1000 0010
		0x6d82,					// c 0110 1101 1000 0010
		0x5d82,					// d 0101 1101 1000 0010
		0xfd83,					// e 1111 1101 1000 0011
		0x4d82,					// f 0100 1101 1000 0010
	};
	return (br[class1] >> class2) & 1;
}

/*
 *	IsURLDelimiter(ch)
 *
 *	@func
 *		Punctuation characters are those of sets 0, 1, 2, 4, 5, and 6,
 *		and < or > which we consider to be brackets, not "less" or
 *      "greater" signs. On the other hand; "/" (in set 6) should not be
 *		a delimiter, but rather a part of the URL.
 *
 *	@comm This function is used in URL detection
 *
 *	@rdesc
 *		Returns TRUE if the character is a punctuation mark.
 */
BOOL IsURLDelimiter(
	WCHAR ch)
{
	if (IsKorean(ch))
		return TRUE;

	INT iset = KinsokuClassify(ch);

	return IN_RANGE(0, iset, 2) || (IN_RANGE(4, iset, 6) && ch != '/')
		   || ch == '<' || ch == '>';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\cbhost.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LBHOST.CPP -- Text Host for CreateWindow() Rich Edit 
 *		Combo Box Control | 
 *		Implements CCmbBxWinHost message
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/30/97 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

#ifndef NOLISTCOMBOBOXES

#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"
#include "_cbhost.h"

ASSERTDATA

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);

// For effeciency and to avoid Winnt thunking layer we will call
// the listbox winproc directly
extern "C" LRESULT CALLBACK RichListBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam);

//////////////////////////// System Window Procs ////////////////////////////
/*
 *	RichComboBoxWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services. 
 *	@rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
extern "C" LRESULT CALLBACK RichComboBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichComboBoxWndProc");

	LRESULT	lres = 1;	//signify we didn't handle the message
	HRESULT hr = S_FALSE;
	CCmbBxWinHost *phost = (CCmbBxWinHost *) GetWindowLongPtr(hwnd, ibPed);

#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CCmbBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam);

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WINCE)
		if (!phost)
		{
			(void) CCmbBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam);
			phost = (CCmbBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
		}
		break;

	case WM_DESTROY:
		if(phost)
			CCmbBxWinHost::OnNCDestroy(phost);
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// in certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	switch(msg)
	{
	case WM_MOUSEMOVE:
		if (!phost->OnMouseMove(wparam, lparam))
			break;
		goto serv;

	case WM_MOUSELEAVE:
		lres = phost->OnMouseLeave(wparam, lparam);
		break;

	case WM_LBUTTONUP:
		if (!phost->OnLButtonUp(wparam, lparam))
			break;
		goto serv;

	case WM_MOUSEWHEEL:
		if (!phost->OnMouseWheel(wparam, lparam))
			break;
		goto defproc;

	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
		if (!phost->OnLButtonDown(wparam, lparam))
			goto Exit;
		goto serv;

	case WM_COMMAND:
		if (!phost->OnCommand(wparam, lparam))
			break;
		goto serv;		

	case WM_CREATE:
		lres = phost->OnCreate((CREATESTRUCT*)lparam);
		break;
	
	case WM_KEYDOWN:
		if (!phost->OnKeyDown((WORD) wparam, (DWORD) lparam))
			break;								
		goto serv;						//  give it to text services		   

	case WM_SETTEXT:
		if (phost->_cbType != CCmbBxWinHost::kDropDown)
		{
			lres = CB_ERR;
			break;
		}
		phost->_fIgnoreChange = 1;
		phost->_nCursor = -2;			// Reset last selected item
		goto serv;
		
	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;
		
	case WM_CHAR:

		if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				// UNDONE:
				// Need to see what we should do in WM_IME_CHAR
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
	
		if(!phost->OnChar((WORD) wparam, (DWORD) lparam))
			// processed code: break out
			break;							
		goto serv;							//  else give it to text services

	case WM_DRAWITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_DRAWLIST, wparam, lparam);
		if (lres)
			break;
		goto defproc;

	case WM_DELETEITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_DELETE, wparam, lparam);
		if (lres)
			break;
		goto defproc;		

	case WM_ENABLE:
		if (phost->OnEnable(wparam, lparam))
		{
			if(!wparam ^ phost->_fDisabled)
			{
				// Stated of window changed so invalidate it so it will
				// get redrawn.
				InvalidateRect(phost->_hwnd, NULL, TRUE);
				phost->SetScrollBarsForWmEnable(wparam);

				// Need to enable the listbox window
				::EnableWindow(phost->_hwndList, wparam);
			}
			phost->_fDisabled = !wparam;				// Set disabled flag
			lres = 0;							// Return value for message
		}
											// Fall thru to WM_SYSCOLORCHANGE?
	case WM_SYSCOLORCHANGE:
		//forward message to listbox first then pass to textservice
		SendMessage(phost->_hwndList, msg, wparam, lparam);
		phost->OnSysColorChange();
		goto serv;							// Notify text services that
											//  system colors have changed
	case WM_GETDLGCODE:
		//forward message to listbox first then pass to textservice
		SendMessage(phost->_hwndList, msg, wparam, lparam);
		lres = phost->OnGetDlgCode(wparam, lparam);
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;
		
	case WM_SIZE:
		lres = phost->OnSize(wparam, lparam);
		break;

	case WM_SETCURSOR:
		//	Only set cursor when over us rather than a child; this
		//	helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
				lres = phost->OnSetCursor(wparam, lparam);
		}
		break;

	case WM_SHOWWINDOW:
		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case WM_NCPAINT:
		RECT	rcClient;

		GetClientRect(hwnd, &rcClient);
		lres = 0;
		if (rcClient.bottom - rcClient.top <= phost->_cyCombo && !phost->DrawCustomFrame(wparam, NULL))
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_PAINT:
		lres = phost->OnPaint(wparam, lparam);
		break;

	case WM_KILLFOCUS:
		lres = phost->OnKillFocus(wparam, lparam);
		if (!lres)
			goto serv;
		goto defproc;

	case LBCB_TRACKING:
		// release any mousedown stuff
		phost->OnLButtonUp(0, 0);
		phost->_fFocus = 1;
		phost->_fLBCBMessage = 1;
		// Fall through case!!!
		
	case WM_SETFOCUS:
		lres = phost->OnSetFocus(wparam, lparam);		
		if (lres)
			goto defproc;
		goto serv;

	case WM_SYSKEYDOWN:
		if (phost->OnSyskeyDown((WORD)wparam, (DWORD)lparam))
			goto serv;
		break;

	case WM_CAPTURECHANGED:
		if (!phost->OnCaptureChanged(wparam, lparam))
			goto serv;
		break;

	case WM_MEASUREITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_MEASUREITEM, wparam, lparam);
		goto Exit;

	//bug fix #4076
	case CB_GETDROPPEDSTATE:
		lres = phost->_fListVisible;
		goto Exit;

	// combo box messages
	case CB_GETEXTENDEDUI:
		lres = phost->CbGetExtendedUI();
		break;

	case CB_SETEXTENDEDUI:
		lres = phost->CbSetExtendedUI(wparam);
		break;
	
    case CB_SETITEMHEIGHT:
		lres = phost->CbSetItemHeight(wparam, lparam);
		break;

	case CB_GETITEMHEIGHT:
		lres = phost->CbGetItemHeight(wparam, lparam);
		break;

    case CB_SETDROPPEDWIDTH:
		phost->CbSetDropWidth(wparam);
		// fall thru

    case CB_GETDROPPEDWIDTH:
		lres = phost->CbGetDropWidth();
		break;

// Listbox specific messages
    case CB_DELETESTRING:
    	msg = LB_DELETESTRING;
    	goto deflstproc;

    case CB_SETTOPINDEX:
    	msg = LB_SETTOPINDEX;
    	goto deflstproc;

    case CB_GETTOPINDEX:
    	msg = LB_GETTOPINDEX;
    	goto deflstproc;
 
    case CB_GETCOUNT:
    	msg = LB_GETCOUNT;
    	goto deflstproc;
    	
    case CB_GETCURSEL:
    	msg = LB_GETCURSEL;
    	goto deflstproc;
    	
    case CB_GETLBTEXT:
    	msg = LB_GETTEXT;
    	goto deflstproc;
    	
    case CB_GETLBTEXTLEN:
    	msg = LB_GETTEXTLEN;
    	goto deflstproc;
    	
    case CB_INSERTSTRING:
    	msg = LB_INSERTSTRING;
    	goto deflstproc;
    	
    case CB_RESETCONTENT:
    	msg = LB_RESETCONTENT;
    	goto deflstproc;

    case CB_FINDSTRING:
    	msg = LB_FINDSTRING;
    	goto deflstproc;

    case CB_FINDSTRINGEXACT:
    	msg = LB_FINDSTRINGEXACT;
    	goto deflstproc;

    case CB_SELECTSTRING:
    	//bug fix
    	// The system control does 2 things here.  1) selects the requested item
    	// 2) sets the newly selected item to the top of the list
    	lres = CB_ERR;
    	if (phost->_hwndList)
    	{
    		lres = RichListBoxWndProc(phost->_hwndList, LB_SELECTSTRING, wparam, lparam);
    		phost->UpdateEditBox();
    	}
    	break;    	

    case CB_GETITEMDATA:
    	msg = LB_GETITEMDATA;
    	goto deflstproc;

    case CB_SETITEMDATA:
    	msg = LB_SETITEMDATA;
    	goto deflstproc;

    case CB_SETCURSEL:
    	//bug fix
    	// The system control does 2 things here.  1) selects the requested item
    	// 2) sets the newly selected item to the top of the list
    	if (phost->_hwndList)
    	{
    		lres = RichListBoxWndProc(phost->_hwndList, LB_SETCURSEL, wparam, lparam);
    		if (lres != -1)
    			RichListBoxWndProc(phost->_hwndList, LB_SETTOPINDEX, wparam, 0);
    		phost->UpdateEditBox();
    	}
    	break;

	case CB_ADDSTRING:
		msg = LB_ADDSTRING;
		goto deflstproc;

    case CB_GETHORIZONTALEXTENT:
		msg = LB_GETHORIZONTALEXTENT;
		goto deflstproc;

    case CB_SETHORIZONTALEXTENT:
		msg = LB_SETHORIZONTALEXTENT;
		goto deflstproc;

// edit box specific messages
    case CB_GETEDITSEL:
		msg = EM_GETSEL;
		goto serv;

    case CB_LIMITTEXT:
		msg = EM_SETLIMITTEXT;
		goto serv;    	
    
    case CB_SETEDITSEL:
    	if (phost->_cbType == CCmbBxWinHost::kDropDownList)
    	{
    	    lres = CB_ERR;
    		break;
    	}
    	msg = EM_SETSEL;
		// When we are in a dialog box that is empty, EM_SETSEL will not select
		// the final always existing EOP if the control is rich.
		if (phost->_fUseSpecialSetSel &&
			((CTxtEdit *)phost->_pserv)->GetAdjustedTextLength() == 0 &&
			wparam != -1)
		{
			lparam = 0;
			wparam = 0;
		}
		else
		{			
			//parameters are different between CB and EM messages
			wparam = (WPARAM)(signed short)LOWORD(lparam);
			lparam = (LPARAM)(signed short)HIWORD(lparam);
		}
		goto serv;

	
	case EM_SETMARGINS:  //PPT uses this message for the combo box. bug fix #4072
		// We need to keep track of the margins size because we have a minimum inset
		// value bug fix #4659
		if (wparam & EC_LEFTMARGIN)
			phost->_dxLOffset = LOWORD(lparam);
		if (wparam & EC_RIGHTMARGIN)
			phost->_dxROffset = HIWORD(lparam);
		phost->OnSetMargins(wparam, LOWORD(lparam) + phost->_dxLInset, 
			HIWORD(lparam) + phost->_dxRInset);
		break;
		
	case EM_GETOPTIONS:
		lres = phost->OnGetOptions();
		break;
		
	case EM_SETOPTIONS:
		phost->OnSetOptions((WORD) wparam, (DWORD) lparam);
		lres = (phost->_dwStyle & ECO_STYLES);
		if(phost->_fEnableAutoWordSel)
			lres |= ECO_AUTOWORDSELECTION;
		break;

	case EM_HIDESELECTION:
		if(lparam)
		{
			DWORD dwPropertyBits = 0;

			phost->_dwStyle |= ES_NOHIDESEL;
			if(wparam)
			{
				phost->_dwStyle &= ~ES_NOHIDESEL;
				dwPropertyBits = TXTBIT_HIDESELECTION;
			}

			// Notify text services of change in status.
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_HIDESELECTION, 
				dwPropertyBits);
		}
		goto serv;

	case EM_GETPASSWORDCHAR:
#ifndef NOACCESSIBILITY    
		lres = 0;
		break;
#endif

	// We should ignore any EM_ messages which we don't handle ourselves
	case EM_SETPALETTE:
	case EM_GETRECT:
	case EM_SETBKGNDCOLOR:
	case EM_SETPASSWORDCHAR:
	case EM_SETREADONLY:
	case EM_SETRECTNP:							
	case EM_SETRECT:	
//	case CB_INITSTORAGE:        
    case CB_SETLOCALE:
    case CB_GETLOCALE:
		AssertSz(FALSE, "Message not supported");
		//FALL THROUGH!!!

	case WM_STYLECHANGED:
		break;

	case CB_GETDROPPEDCONTROLRECT:
		lres = 0;
		if (lparam)
		{
			RECT rcList;
			lres = 1;
			phost->GetListBoxRect(rcList);
			memcpy((void *)lparam, &rcList, sizeof(RECT));
		}
		break;

	case EM_SETTEXTEX:
		phost->OnSetTextEx(wparam, lparam);
		break;

	case EM_SETEDITSTYLE:
		lres = phost->OnSetEditStyle(wparam, lparam);
		break;

    case CB_SHOWDROPDOWN:
		if (wparam && !phost->_fListVisible)
		{
			phost->ShowListBox(TRUE);
			phost->TxSetCapture(TRUE);
			phost->_fCapture = TRUE;
		}
		else if (!wparam && phost->_fListVisible)
		{
			phost->HideListBox(TRUE, FALSE);
		}
        break;

#ifndef NOACCESSIBILITY        
	case WM_GETOBJECT:	
		IUnknown* punk;
		phost->QueryInterface(IID_IUnknown, (void**)&punk);
		Assert(punk);
		lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
		AssertSz(!FAILED((HRESULT)lres), "WM_GETOBJECT message FAILED\n");
		punk->Release();
		break;
#endif		
		
	default:
		//CTxtWinHost message handler
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);

defproc:
		if(hr == S_FALSE)
		{			
			// Message was not processed by text services so send it
			// to the default window proc.
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}

		// Need to do some things after we send the message to ITextService
		switch (msg)
		{
		case EM_SETSEL:
			phost->_pserv->TxSendMessage(EM_HIDESELECTION, 0, 0, NULL);
			lres = 1;
			break;

		case EM_SETLIMITTEXT:
			lres = 1;								// Need to return 1 per SDK documentation
			break;

		case WM_SETTINGCHANGE:
			phost->CbCalcControlRects(NULL, FALSE);	// Need to resize control after setting change
			break;

		case WM_SETTEXT:
			phost->_fIgnoreChange = 0;
			break;

		case WM_SETFONT:
		{
			// Special border processing. The inset changes based on the size of the
			// defautl character set. So if we got a message that changes the default
			// character set, we need to update the inset.
			// Update our font height member variable with the new fonts height
			// Get the inset information
			HDC hdc = GetDC(hwnd);
			LONG xAveCharWidth = 0;
			LONG yCharHeight = GetECDefaultHeightAndWidth(phost->_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);
			ReleaseDC(hwnd, hdc);

			if (yCharHeight)
				phost->_dyFont = yCharHeight;

			// force a recalculation of the edit control
			phost->_dyEdit = 0;
			phost->CbCalcControlRects(&phost->_rcWindow, TRUE);

			// force a resize of the control
			phost->_fListVisible = 1;
			phost->HideListBox(FALSE, FALSE);
		}
			goto deflstproc;
			
		case EM_FORMATRANGE:
		case EM_SETPARAFORMAT:
		case EM_SETCHARFORMAT:
		case EM_SETLANGOPTIONS:
		case EM_SETBIDIOPTIONS:
		case EM_SETTYPOGRAPHYOPTIONS:
			goto deflstproc;			
		}
		break;

deflstproc:
		//CLstBxWinHost message handler
		Assert(phost->_hwndList);
		if (phost->_hwndList)
		{
			lres = SendMessage(phost->_hwndList, msg, wparam, lparam);
			
			switch (msg)
			{
			case LB_RESETCONTENT:
				//need to remove the content from the edit box
				phost->_fIgnoreChange = 1;
				phost->_pserv->TxSendMessage(WM_SETTEXT, wparam, NULL, &lres);
				phost->_fIgnoreChange = 0;
				// Fall thru to update the listbox

			case LB_SETCURSEL:
				// need to update the edit control
				phost->UpdateEditBox();
				break;	
			}
		}
		break;				
	}	

Exit:
	phost->Release();
	return lres;
}


//////////////// CCmbBxWinHost Creation/Initialization/Destruction ///////////////////////
#ifndef NOACCESSIBILITY
/*
 *	CCmbBxWinHost::QueryInterface(REFIID riid, void **ppv)
 *
 *	@mfunc
 *		
 */
HRESULT CCmbBxWinHost::QueryInterface(
	REFIID riid, 
	void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");
  
  	if(riid == IID_IAccessible)
		*ppv = (IAccessible*)this;
    else if (riid == IID_IDispatch)
		*ppv = (IDispatch*)(IAccessible*)this;
    else if (IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown*)(IAccessible*)this;
    else
        return CTxtWinHost::QueryInterface(riid, ppv);

	AddRef();		
	return NOERROR;
}
#endif

/*
 *	CCmbBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
LRESULT CCmbBxWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnNCCreate");


	CCmbBxWinHost *phost = new CCmbBxWinHost();

	if (!phost)
	{
		// Allocation failure.
		return 0;
	}

	if(!phost->Init(hwnd, pcs))					// Stores phost in associated
	{											//  window data
		phost->Shutdown();
		delete phost;
		return 0;
	}
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLongPtr())
 */
void CCmbBxWinHost::OnNCDestroy(
	CCmbBxWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnNCDestroy");

	// NOTE:
	//	We have to be careful when we destroy the window because there can be cases
	// when we have a valid hwnd but no host for the hwnd so we have to check for
	// both cases

	phost->_fShutDown = 1;
	if (phost->_plbHost)
	{
		phost->_plbHost->_fShutDown = 1;
		phost->_plbHost->Release();
	}
		
	// Destroy list box here so we will get the WM_DELETEITEM before the
	// combo box gets destroyed
	if (phost->_hwndList)
		DestroyWindow(phost->_hwndList);

	phost->Shutdown();
	phost->Release();
	
}

/*
 *	CCmbBxWinHost::CCmbBxWinHost()
 *
 *	@mfunc
 *		constructor
 */
CCmbBxWinHost::CCmbBxWinHost(): CTxtWinHost(), _plbHost(NULL), _hwndList(NULL), _hcurOld(NULL)
{
	//_dxLInset = _dxRInset = 0;
	//_fIgnoreUpdate = 0;
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CTxtWinHost");
}

/*
 *	CCmbBxWinHost::~CCmbBxWinHost()
 *
 *	@mfunc
 *		destructor
 */
CCmbBxWinHost::~CCmbBxWinHost()
{
}

/*
 *	CCmbBxWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CCmbBxWinHost
 */
BOOL CCmbBxWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs)	//@parm Corresponding CREATESTRUCT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::Init");

	if(!pcs->lpszClass)
		return -1;

	//_fRightAlign = 0;
	//_fListVisible = 0;
	//_fOwnerDraw = 0;
	//_fOwnerDrawVar = 0;
	//_fFocus = 0;
	//_fMousedown = 0;
	//_cyList = 0;
	//_cxList = 0;
	//_fDisabled = 0;
	//_fNoIntegralHeight = 0;
	_idCtrl = (UINT)(DWORD_PTR) pcs->hMenu;
	//_fKeyMaskSet = 0;
	//_fMouseMaskSet = 0;
	//_fScrollMaskSet = 0;
	_nCursor = -2;
	//_fExtendedUI = 0;
	//_fLBCBMessage = 0;
	//_dxROffset = _dxLOffset = 0;

	// Set pointer back to CCmbBxWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);

	_hwnd = hwnd;

	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		// We need to change our Extended because we don't support most of them
		DWORD dwExStyle = _dwExStyle & (WS_EX_LEFTSCROLLBAR | WS_EX_TOPMOST | WS_EX_RIGHT |
							WS_EX_RTLREADING | WS_EX_CLIENTEDGE); 
		//	NOTE:
		//	  The order in which we check the style flags immulate
		//	WinNT's order.  So please verify with NT order before
		//	reaaranging order.
		if (_dwStyle & CBS_DROPDOWN)
		{
			_cbType = kDropDown;
			if (_dwStyle & CBS_SIMPLE)
				_cbType = kDropDownList;
		}
		else
		{
			AssertSz(FALSE, "CBS_SIMPLE not supported");
		}

		if (_dwStyle & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))
		{
			_fOwnerDraw = 1;
			_fOwnerDrawVar = !!(_dwStyle & CBS_OWNERDRAWVARIABLE);
		}
			
		if (_dwStyle & WS_DISABLED)
			_fDisabled = 1;

		if (_dwStyle & CBS_NOINTEGRALHEIGHT)
			_fNoIntegralHeight = 1;

		// the combobox doesn't support ES_RIGHT because its value is the 
		// same as CBS_DROPDOWN!!
		if (_dwExStyle & WS_EX_RIGHT)
		{
			_fRightAlign = 1;
			_dwStyle |= ES_RIGHT;
		}

		// implicitly set the ES_AUTOHSCROLL style bit
		_dwStyle |= ES_AUTOHSCROLL;				
		// _dwStyle &= ~ES_AUTOVSCROLL;

		// If we have any kind of border it will always be a 3d border
		if (_dwStyle & WS_BORDER || _dwExStyle & WS_EX_CLIENTEDGE)
		{
			_fBorder = 1;
			_dwStyle &= ~WS_BORDER;
			_dwExStyle |= WS_EX_CLIENTEDGE;
			dwExStyle |= WS_EX_CLIENTEDGE;
		}

		// handle default disabled
		if(_dwStyle & WS_DISABLED)
			_fDisabled = TRUE;

		DWORD dwStyle = _dwStyle;

		// Remove the scroll style for the edit window
		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);

        // Set the window styles
        SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
        SetWindowLong(_hwnd, GWL_EXSTYLE, dwExStyle);
	}

	DWORD dwStyleSaved = _dwStyle;

	// get rid of all ES styles except ES_AUTOHSCROLL and ES_RIGHT
	_dwStyle &= (~(0x0FFFFL) | ES_AUTOHSCROLL | ES_RIGHT);

	// Create Text Services component
	if(FAILED(CreateTextServices()))
		return FALSE;

	_dwStyle = dwStyleSaved;
	_xInset = 1;
	_yInset = 1;

	PARAFORMAT PF2;	
	PF2.dwMask = 0;
	if(_dwExStyle & WS_EX_RIGHT)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = (WORD)(PFA_RIGHT);	// right or center-aligned
	}

	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}
	
	PARAFORMAT PF;							// If left or right alignment,
	if(_fRightAlign)				//  tell text services
	{
		PF.cbSize = sizeof(PARAFORMAT);
		PF.dwMask = PFM_ALIGNMENT;
		PF.wAlignment = (WORD)PFA_RIGHT;
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF, NULL);
	}

	//bug fix #4644 we want the EN_CHANGE and EN_UPDATE notifications
	_pserv->TxSendMessage(EM_SETEVENTMASK, 0, ENM_UPDATE | ENM_CHANGE, NULL);

	// Tell textservices to turn-on auto font sizing
	_pserv->TxSendMessage(EM_SETLANGOPTIONS, 0, 
			IMF_AUTOKEYBOARD | IMF_AUTOFONT | IMF_AUTOFONTSIZEADJUST | IMF_UIFONTS |
			IMF_IMEALWAYSSENDNOTIFY, NULL);

	return TRUE;
}


/*
 *	CCmbBxWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CCmbBxWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;

	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;	

	// Get the font height to base the control heights from
	// Initially the font height is the item height	
	HDC hdc = GetDC(_hwnd);	
	LONG xAveCharWidth = 0;
	_dyFont = GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
		W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);
	Assert(_dyFont != 0); // _yInset should be zero since listbox's doesn't have yinsets

	ReleaseDC(_hwnd, hdc);
	
	
	// init variables
	_idCtrl = (UINT)(DWORD_PTR)pcs->hMenu;

	// Need to calculate the rects of EVERYTHING!!
	// Force a request of itemHeight
	_rcButton.left = 0;
	_dyEdit = 0;
	_cyList = -1;
	CbCalcControlRects(&rcClient, TRUE);

	// Now lets handle the listbox stuff!
	// create and tranlate styles for combo box to listbox
	DWORD lStyle = WS_BORDER | WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_COMBOBOX | WS_CLIPSIBLINGS;
	if (_dwStyle & CBS_HASSTRINGS)
		lStyle |= LBS_HASSTRINGS;

	if (_dwStyle & CBS_SORT)
		lStyle |= LBS_SORT;

	if (_dwStyle & CBS_DISABLENOSCROLL)
		lStyle |= LBS_DISABLENOSCROLL;

	if (_dwStyle & CBS_NOINTEGRALHEIGHT)
		lStyle |= LBS_NOINTEGRALHEIGHT;

	if (_dwStyle & CBS_OWNERDRAWFIXED)
		lStyle |= LBS_OWNERDRAWFIXED;
	else if (_dwStyle & CBS_OWNERDRAWVARIABLE)
		lStyle |= LBS_OWNERDRAWVARIABLE;


	// copy over some window styles
	lStyle |= (_dwStyle & WS_DISABLED);
	lStyle |= (_dwStyle & (WS_VSCROLL | WS_HSCROLL));

	// no longer need scrollbar or else the editbox will look bad
	_dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);

	DWORD lExStyle = _dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

	//NOTE. It doesn't matter if the listbox is made with the correct size since
	// it's going to get resized anyways
	if (!W32->OnWin9x())
	{
		//WinNT
		_hwndList = ::CreateWindowExW(lExStyle | WS_EX_TOOLWINDOW, L"REListBox20W", 
					NULL, lStyle, _rcList.left, _rcList.top, _rcList.right - _rcList.left,
					_rcList.bottom - _rcList.top, _hwnd, (HMENU)CB_LISTBOXID, NULL, this);
	}
	else
	{
		// Win '95, '98 system
		_hwndList = ::CreateWindowExA(lExStyle | WS_EX_TOOLWINDOW, "REListBox20W", 
					NULL, lStyle, _rcList.left, _rcList.top, _rcList.right - _rcList.left,
					_rcList.bottom - _rcList.top, _hwnd, (HMENU)CB_LISTBOXID, NULL, this);
	}

	Assert(_hwndList);
	_plbHost = (CLstBxWinHost *) GetWindowLongPtr(_hwndList, ibPed);
	Assert(_plbHost);
	if (!_plbHost)
		return -1;
		
	// increment reference counter!
	_plbHost->AddRef();

	if (_cbType != kSimple)
		ShowWindow(_hwndList, SW_HIDE);
	SetParent(_hwndList, NULL);

	_fIgnoreChange = 1;
	if (_cbType == kDropDownList)
	{			
		AssertSz(!((CTxtEdit*)_pserv)->_fReadOnly, "edit is readonly");
		
		// Tell textservices to select the entire background
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EXTENDBACKCOLOR, SES_EXTENDBACKCOLOR, NULL);	

		// format the paragraph to immulate the system control
		PARAFORMAT2 pf;
		pf.cbSize = sizeof(PARAFORMAT2);
		pf.dwMask = PFM_STARTINDENT;
		pf.dxStartIndent = (1440.0 / W32->GetXPerInchScreenDC());
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf, NULL);
		_usIMEMode = ES_NOIME;
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	

	}
	else
	{
		// make the richedit control behave like the edit control		
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EMULATESYSEDIT, SES_EMULATESYSEDIT, NULL);
	}

	// Need to resize the list box
	if (_cbType != kSimple)
		SetDropSize(&_rcList);

	_fIgnoreChange = 0;
	return 0;
}


/////////////////////////// CCmbBxWinHost Helper functions /////////////////////////////////
/*
 *	CCmbBxWinHost::GetTextLength ()
 *
 *	@mfunc
 *		returns the text length of the edit control using CR and NOT CRLF
 *
 *	@rdesc
 *		LRESULT = text length
 */
LRESULT CCmbBxWinHost::GetTextLength()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::GetTextLength");

	LRESULT lr = 0;
	GETTEXTLENGTHEX gtl;
	gtl.flags = GTL_NUMCHARS | GTL_PRECISE;
	gtl.codepage = 1200;

#ifdef DEBUG
	HRESULT hr = _pserv->TxSendMessage(EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0, &lr);
	Assert(hr == NOERROR);
#else
	_pserv->TxSendMessage(EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0, &lr);
#endif
	return lr;
}

/*
 *	CCmbBxWinHost::GetEditText (LPTSTR, int)
 *
 *	@mfunc
 *		returns the text length in the edit control in UNICODE
 *
 *	@rdesc
 *		LRESULT = text length copied to passed in buffer
 */
LRESULT CCmbBxWinHost::GetEditText (
	LPTSTR szStr, 
	int nSize)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::GetEditText");

	LRESULT lr = 0;
	GETTEXTEX gt;
	gt.cb = nSize * sizeof(WCHAR);
	gt.flags = 0;
	gt.codepage = 1200;
	gt.lpDefaultChar = NULL;
	gt.lpUsedDefChar = NULL;

#ifdef DEBUG
	HRESULT hr = _pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)szStr, &lr);
	Assert(hr == NOERROR);
#else
	_pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)szStr, &lr);
#endif
	return lr;
}
 
 
/*
 *	CCmbBxWinHost::SetDropSize(RECT* prc)
 *
 *	@mfunc
 *		Compute the drop down window's width and max height
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::SetDropSize(
	RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SetDropSize");

	_fListVisible = TRUE;
	HideListBox(FALSE, FALSE);
	POINT pt1 = {prc->left, prc->top};
	POINT pt2 = {prc->right, prc->bottom};

	::ClientToScreen(_hwnd, &pt1);
	::ClientToScreen(_hwnd, &pt2);

	int   iWidth = pt2.x - pt1.x;

	if (_cxList > iWidth)
		iWidth = _cxList;

	MoveWindow(_hwndList, pt1.x, pt1.y, iWidth,
			pt2.y - pt1.y, FALSE);

}

/*
 *	CCmbBxWinHost::SetSizeEdit(int nLeft, int nTop, int nRight, int nBottom)
 *
 *	@mfunc
 *		sets the edit controls size
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::SetSizeEdit(
	int nLeft,
	int nTop,
	int nRight,
	int nBottom)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SizeEdit");

	// Generate default view rect from client rect
	if(_fBorder)
	{
		// Factors in space for borders
  		_rcViewInset.top	= W32->DeviceToHimetric(nTop, W32->GetYPerInchScreenDC());
   		_rcViewInset.bottom	= W32->DeviceToHimetric(nBottom, W32->GetYPerInchScreenDC());
   		_rcViewInset.left	= W32->DeviceToHimetric(nLeft, W32->GetXPerInchScreenDC());
   		_rcViewInset.right	= W32->DeviceToHimetric(nRight, W32->GetXPerInchScreenDC());
	}
	else
	{
		// Default the top and bottom inset to 0 and the left and right
		// to the size of the border.
		_rcViewInset.top = 0;
		_rcViewInset.bottom = 0;
		_rcViewInset.left = W32->DeviceToHimetric(nLeft, W32->GetXPerInchScreenDC());
		_rcViewInset.right = W32->DeviceToHimetric(nRight, W32->GetXPerInchScreenDC());
	}
}

/*
 *	CCmbBxWinHost::CbCalcControlRects(RECT* prc, BOOL bCalcChange)
 *
 *	@mfunc
 *		Calculates the RECT for all the controls.  The rect should
 *	include the non-client area's also
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
BOOL CCmbBxWinHost::CbCalcControlRects(
	RECT* prc, 
	BOOL bCalcChange)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbCalcControlRects");

	// copy over the window rect
	if (prc)
		_rcWindow = *prc;

	// Item specific things
	const int smY = GetSystemMetrics(SM_CYEDGE);
	const int smX = GetSystemMetrics(SM_CXEDGE);

	BOOL fCustomLook = ((CTxtEdit *) _pserv)->_fCustomLook;
	BOOL fAdjustBorder = _fBorder && !fCustomLook;

	_cxCombo = _rcWindow.right - _rcWindow.left;

	if (!_dyEdit)
		_dyEdit = _dyFont + 2 + ((fAdjustBorder) ? (2 * _yInset) : 0);
	
	if (_fOwnerDraw)
	{		
		if (bCalcChange)
		{
            // No height has been defined yet for the static text window.  Send
            // a measure item message to the parent
			MEASUREITEMSTRUCT mis;
            mis.CtlType = ODT_COMBOBOX;
            mis.CtlID = _idCtrl;
            mis.itemID = (UINT)-1;
            mis.itemHeight = _dyEdit;
            mis.itemData = 0;

            SendMessage(_hwndParent, WM_MEASUREITEM, _idCtrl, (LPARAM)&mis);
			_dyEdit = mis.itemHeight;
        }
	}
	else
	{
		// NOTE:
		//	Richedit prevents us from trying to set the itemHeight less than the 
		// font height so we need to take account of this by preventing user from
		// setting height less than font height
		int nyEdit = _dyFont + (fAdjustBorder ? 2 * _yInset : 0);
		if (_dyEdit > nyEdit)
		{
			//In order for the highlighting to work properly we need to empty
			//the richedit control
			LRESULT nLen;
			_pserv->TxSendMessage(WM_GETTEXTLENGTH, 0, 0, &nLen);

			WCHAR* pwch = NULL;
			if (nLen && _cbType == kDropDownList)
			{
				pwch = new WCHAR[nLen + 1 /*NULL*/];
				AssertSz(pwch, "Unable to allocate memory for string");

				if (pwch)
				{				
					// Get the text from richedit and emtpy it
					_fIgnoreChange = 1;
					_fDontWinNotify = 1;
					_pserv->TxSendMessage(WM_GETTEXT, nLen + 1, (LPARAM)pwch, NULL);
					_fDontWinNotify = 1;
					_pserv->TxSendMessage(WM_SETTEXT, 0, NULL, NULL);
					_fIgnoreChange = 0;
				}
				else
				{
					// something bad happened so send a message
					// to client
					TxNotify(EN_ERRSPACE, NULL);	
				}
			}
			else if (_cbType == kDropDown && nLen == 0)
			{
				// we need to insert a dummy character into the richedit
				// control so it won't try to highlight space after
				// the paragraph
				_fIgnoreChange = 1;
				_fDontWinNotify = 1;
				_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)L" ", NULL);
				_fIgnoreChange = 0;
			}

		 	// Calculate the difference in size
		 	nyEdit = _dyEdit - nyEdit;
			int		nyAbove = 0;

			PARAFORMAT2 pf;
			pf.cbSize = sizeof(PARAFORMAT2);
			pf.dwMask = PFM_SPACEAFTER;

			if (fCustomLook)
			{
				// Try to center the text vertically using Space Before

				nyEdit += 2;			// adjust for the custom frame
				nyAbove = nyEdit / 2;

				pf.dwMask = PFM_SPACEAFTER | PFM_SPACEBEFORE;
				pf.dySpaceBefore = (int)(((double)nyAbove * 1440.0) / (double)W32->GetYPerInchScreenDC());
				nyEdit -= nyAbove;
			}

			pf.dySpaceAfter = (int)(((double)nyEdit * 1440.0) / (double)W32->GetYPerInchScreenDC());
			_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf, NULL);

			//Reset the text which was there before in the richedit control
			if (pwch || (_cbType == kDropDown && nLen == 0))
			{
				_fIgnoreChange = 1;
				_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)(pwch ? pwch : NULL), NULL);
				_fIgnoreChange = 0;
				if (pwch)
					delete pwch;
			}
		}
		else
			_dyEdit = nyEdit;	// stabalize ourselves
	}

	// For Bordered Combobox we take account of the clientedge for the top
	// and bottom. And since we want to draw the focus rect within the yellow
	// area we need to subtract 1.
	_cyCombo = min(_dyEdit + ((_fBorder) ? 2 * smY : 0), 
				_rcWindow.bottom - _rcWindow.top); 
	
	// recompute the max height of the dropdown listbox -- full window
    // size MINUS edit/static height
	int iHeight = (_rcWindow.bottom - _rcWindow.top) - _cyCombo;

	if (_cyList == -1 || iHeight > _dyEdit)
		_cyList = iHeight;

	// calculate the rect for the buttons
	if (_cbType != kSimple)
	{
		_rcButton.top = 0;
		_rcButton.bottom = _cyCombo;
		if (!fCustomLook)
			_rcButton.bottom = min(_dyEdit, _rcWindow.bottom - _rcWindow.top);

		if (_fRightAlign)
		{
			_rcButton.left = 0;
			_rcButton.right = _rcButton.left + W32->GetCxVScroll();
		}
		else
		{
			_rcButton.right = _cxCombo - (fAdjustBorder ? (2 * smX): 0);
			_rcButton.left = _rcButton.right - W32->GetCxVScroll();
		}
	}


	// calculate the edit control rect	
	int nTop = _yInset;
	int nBottom = 0;
	_dxLInset = _xInset;
	_dxRInset = _xInset;	
	if (_cbType != kSimple)
	{
		if (_fRightAlign)
			_dxLInset = (_rcButton.right - _rcButton.left) + fCustomLook ? 0 : smX;
		else
			_dxRInset = (_rcButton.right - _rcButton.left) + fCustomLook ? 0 : smX;
	}
	SetSizeEdit(_dxLInset + _dxLOffset, nTop, _dxRInset + _dxROffset, nBottom);

	// calculate the rect for the list box window
	_rcList.left = fAdjustBorder ? - smX : 0;
	_rcList.top = _cyCombo - (fAdjustBorder ? smY : 0);
	_rcList.right = fAdjustBorder ? max(_cxCombo - smX, 0) : _rcWindow.right;
	_rcList.bottom = _cyCombo + _cyList;	

	return TRUE;
}


/*
 *	CCmbBxWinHost::DrawButton(HDC, BOOL)
 *
 *	@mfunc
 *		Draws the combo box button given an hdc
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::DrawButton(
	HDC hdc, 
	BOOL bDown)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawButton");
	// Check if we have to draw the drop down button
    if (_cbType != kSimple) 
	{
		BOOL bRelease = !hdc;
		if (!hdc)
			hdc = TxGetDC();

		if (((CTxtEdit *) _pserv)->_fCustomLook)
		{
			// Draw buttomn using new look
			COLORREF crBorder = W32->GetCtlBorderColor(_fListVisible, _fMouseover);
			COLORREF crBackground = W32->GetCtlBkgColor(_fListVisible, _fMouseover);
			COLORREF crArrow = W32->GetCtlTxtColor(_fListVisible, _fMouseover, _fDisabled);;
		
			W32->DrawBorderedRectangle(hdc, &_rcButton, crBorder, crBackground);			
			W32->DrawArrow(hdc, &_rcButton, crArrow);
		}
		else
		{
			DrawFrameControl(hdc, &_rcButton, DFC_SCROLL, DFCS_SCROLLCOMBOBOX |
				(bDown ? DFCS_PUSHED | DFCS_FLAT: 0) | (!_fBorder ? DFCS_FLAT : 0) |
				(!_fDisabled ? 0 : DFCS_INACTIVE));
		}

		if (bRelease)
			TxReleaseDC(hdc);
    }
}

/* 
 *	CCmbBxWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  In the case of the combobox we will
 *		notify parent of only two edit notifications; EN_CHANGE 
 *		and EN_UPDATE.  The others will be from the listbox
 *		or be generated because of focus changing
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		<CBN_DBLCLK> user double-clicks an item in the list box
 *
 *		<CBN_ERRSPACE> The list box cannot allocate enough memory to 
 *		fulfill a request
 *
 *		<CBN_KILLFOCUS> The list box loses the keyboard focus
 *
 *		<CBN_SELENDCANCEL> notification message is sent when the user 
 *		selects an item, but then selects another control or closes the 
 *		dialog box
 *
 *		<CBN_SELCHANGE> notification message is sent when the user changes 
 *		the current selection in the list box of a combo box
 *
 *		<CBN_SETFOCUS> The list box receives the keyboard focus
 *
 *		<CBN_CLOSEUP> This message is sent when the listbox has been closed
 *
 *		<CBN_SELENDOK> notification message is sent when the user selects a 
 *		list item, or selects an item and then closes the list
 *
 *		<CBN_EDITCHANGE> notification message is sent after the user 
 *		has taken an action that may have altered the text in the edit 
 *		control portion of a combo box
 *
 *		<CBN_EDITUPDATE> notification message is sent when the edit control 
 *		portion of a combo box is about to display altered text
 *
 *		<CBN_DROPDOWN> This message is sent when the listbox has been made visible
 */
HRESULT CCmbBxWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxNotify");
	HRESULT hr = S_FALSE;
	BOOL	fSendNotify = FALSE;

	if (EN_SAVECLIPBOARD == iNotify)	// Special RE notify
		return S_OK;					//	return S_OK to put data on clipboard

	if (_hwndParent)
	{
		// First, handle WM_NOTIFY style notifications
		//WPARAM LOWORD(_idCtrl) ; LPARAM - HWND(COMBO)
		switch(iNotify)
		{
		case EN_CHANGE:

#ifndef NOACCESSIBILITY
			if (!_fDontWinNotify)
				fSendNotify = TRUE;

			_fDontWinNotify = 0;
#endif
			//update the listbox bug fix #5206
			if (_fIgnoreChange)
			{
				if (!fSendNotify)
					return hr;

				goto WIN_EVENT;
			}

			if (_fListVisible && _cbType == kDropDown)
				UpdateListBox(FALSE);
			else if (_cbType == kDropDownList)
			    // don't send notification if dropdownlist
			    return S_FALSE;
			    
			iNotify = CBN_EDITUPDATE;
			_fSendEditChange = 1;

			goto SEND_MSG;
			
		case EN_UPDATE:
			//bug fix - we're sending too much CBN_UPDATE notifications
			if (_fIgnoreUpdate)
				return hr;
			if (_cbType == kDropDownList)
			    return S_FALSE;
			    
			iNotify = CBN_EDITCHANGE;
			goto SEND_MSG;
			
		case EN_ERRSPACE:
			iNotify = (unsigned)CBN_ERRSPACE;
			goto SEND_MSG;

		case CBN_SELCHANGE: 
		case CBN_SELENDCANCEL:		
		case CBN_CLOSEUP:
		case CBN_DBLCLK:	
		case CBN_DROPDOWN:  
		case CBN_KILLFOCUS:  
		case CBN_SELENDOK:
		case CBN_SETFOCUS:
	
SEND_MSG:
		hr = SendMessage(_hwndParent, WM_COMMAND, 
						GET_WM_COMMAND_MPS(_idCtrl, _hwnd, iNotify));


WIN_EVENT:
#ifndef NOACCESSIBILITY
		if (fSendNotify)
			W32->NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, _hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
#endif
		}		
	}
	return hr;
}

/*
 *	CCmbBxWinHost::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *									lprcUpdate, fuScroll)
 *	@mfunc
 *		Request Text Host to scroll the content of the specified client area.
 *
 *	@devnote
 *		Need to exclude the drop-dwon button from the Clip rect or else ScrollWindowEx
 *		will scroll the button image as well.
 *
 */
void CCmbBxWinHost::TxScrollWindowEx (
	INT		dx, 			//@parm	Amount of horizontal scrolling
	INT		dy, 			//@parm	Amount of vertical scrolling
	LPCRECT lprcScroll, 	//@parm	Scroll rectangle
	LPCRECT lprcClip,		//@parm	Clip rectangle
	HRGN	hrgnUpdate, 	//@parm	Handle of update region
	LPRECT	lprcUpdate,		//@parm	Update rectangle
	UINT	fuScroll)		//@parm	Scrolling flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxScrollWindowEx");

	Assert(_hwnd);
	RECT	rcClip = *lprcClip;

	if (_cbType != kSimple && lprcClip && dx)
	{
		// Exclude the dropdown button rect from the clipping rect
		if (_fRightAlign)
			rcClip.left = max(lprcClip->left, _rcButton.right);
		else
			rcClip.right = min(lprcClip->right, _rcButton.left);
	}
	::ScrollWindowEx(_hwnd, dx, dy, lprcScroll, &rcClip, hrgnUpdate, lprcUpdate, fuScroll);
}

/* 
 *	CCmbBxWinHost::TxInvalidateRect (prc, fMode)
 *
 *	@mfunc
 *		Adds a rectangle to the Text Host window's update region
 *
 *	@comm
 *		We want to make sure the invalidate rect include the focus rect.
 *
 */
void CCmbBxWinHost::TxInvalidateRect(
	LPCRECT	prc, 		//@parm	Address of rectangle coordinates
	BOOL	fMode)		//@parm	Erase background flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxInvalidateRect");

	Assert(_hwnd);

	if(!_fVisible)
	{
		// There doesn't seem to be a deterministic way to determine whether
		// our window is visible or not via message notifications. Therefore,
		// we check this each time in case it might have changed.
		_fVisible = IsWindowVisible(_hwnd);

		if(_fVisible)
			OnTxVisibleChange(TRUE);
	}

	// Don't bother with invalidating rect if we aren't visible
	if(_fVisible)
	{
		RECT rcLocal;
		if (prc && _cbType == kDropDownList)
		{
			RECT rcClient;
			GetClientRect(_hwnd, &rcClient);

			rcClient.top += _yInset;
			rcClient.bottom -= _yInset;

			if (prc->bottom < rcClient.bottom || prc->top > rcClient.top)
			{
				// Make sure we also invalidate the focus rect as well
				rcLocal = *prc;
				if (prc->bottom < rcClient.bottom)
					rcLocal.bottom = rcClient.bottom;

				if (prc->top > rcClient.top)
					rcLocal.top = rcClient.top;

				prc = &rcLocal;
			}
		}
		::InvalidateRect(_hwnd, prc, FALSE);
	}
}

/* 
 *	CCmbBxWinHost::TxGetClientRect (prc)
 *
 *	@mfunc
 *		Retrieve client coordinates of CCmbBxWinHost's client area.
 *
 *	@rdesc
 *		HRESULT = (success) ? S_OK : E_FAIL
 */
HRESULT CCmbBxWinHost::TxGetClientRect(
	LPRECT prc)		//@parm	Where to put client coordinates
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxGetClientRect");

	HRESULT hr;

	Assert(_hwnd && prc);
	hr = ::GetClientRect(_hwnd, prc) ? S_OK : E_FAIL;

	if (hr == S_OK && _cbType != kSimple)
	{
		if (_fRightAlign)
			prc->left = _rcButton.right + _xInset;
		else
			prc->right = _rcButton.left - (((CTxtEdit *)_pserv)->_fCustomLook ? 0 : _xInset);
	}

	return hr;
}

/*
 *	CCmbBxWinHost::DrawEditFocus(HDC)
 *
 *	@mfunc
 *		Either draws or notifies owner to draw the focus rect
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::DrawEditFocus(
	HDC hdc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawEditFocus");

	BOOL bRelease = FALSE;
	if (!hdc)
	{
		hdc = TxGetDC();
		bRelease = TRUE;
	}

	RECT rc;
	GetClientRect(_hwnd, &rc);

	if (!_fOwnerDraw)
	{
		HiliteEdit(_fFocus);

		if (_cbType == kDropDownList)
		{
			// shrink the focus rect by the inset
			rc.top += _yInset;
			rc.bottom -= _yInset;			
			
			if (_fRightAlign)
				rc.left = _rcButton.right;
			else
				rc.right = _rcButton.left;

			rc.left += _xInset;

			if (!((CTxtEdit *) _pserv)->_fCustomLook)
				rc.right -= _xInset;

			DrawFocusRect(hdc, &rc);
		}
	}

	if (bRelease)
		TxReleaseDC(hdc);
	
}

/*
 *	CCmbBxWinHost::SetSelectionInfo(BOOL bOk, int nIdx)
 *
 *	@mfunc
 *		Completes the text in the edit box with the closest match from the
 * listbox.  If a prefix match can't be found, the edit control text isn't
 * updated. Assume a DROPDOWN style combo box.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::SetSelectionInfo(
	BOOL bOk, 
	int nIdx)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SetSelectionInfo");

	_nCursor = nIdx;
	_bSelOk = bOk;	
}

/*
 *	CCmbBxWinHost::AutoUpdateEdit(int i)
 *
 *	@mfunc
 *		Completes the text in the edit box with the closest match from the
 * listbox.  If a prefix match can't be found, the edit control text isn't
 * updated. Assume a DROPDOWN style combo box.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::AutoUpdateEdit(
	int nItem)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::AutoUpdateEdit");

    // We update the edit part of the combo box with the current selection of
    // the list box
	int cch;
	WCHAR* pszText;
	LRESULT lr;

	// find the best matching string in the list box
	if (nItem == -1 || nItem == -2)
	{
		cch = GetTextLength();

		// no text to search so just get out
	    if (!cch)
	    	return;

	    cch++; // account for null character
	    pszText = new WCHAR[cch];
	    AssertSz(pszText, "string allocation failed");
	    if (!pszText) 
	    {
			TxNotify((unsigned)CBN_ERRSPACE, NULL);
			return;
		}

		// get string from edit control and try to find a exact match else a match
		// in the list box
		GetEditText(pszText, cch);
		
	    nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszText);

	    if (nItem == -1)
	    	nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRING, (WPARAM)-1, (LPARAM)pszText);
		delete [] pszText;

		// no match found so just get out
	    if (nItem == -1)         	
	    	return;
    }

	cch = RichListBoxWndProc(_hwndList, LB_GETTEXTLEN, nItem, 0);

	if (cch <= 0)
		return;
		
    cch++; // account for null character
    pszText = new WCHAR[cch];
	AssertSz(pszText, "Unable to allocate string");
	if (!pszText)
	{
		TxNotify((unsigned)CBN_ERRSPACE, NULL);
		return;
	}

	RichListBoxWndProc(_hwndList, LB_GETTEXT, nItem, (LPARAM)pszText);
	_fIgnoreChange = 1;
	_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)pszText, &lr);
	_fIgnoreChange = 0;

   	HiliteEdit(TRUE);

    delete [] pszText;
}

/*
 *	CCmbBxWinHost::HiliteEdit(BOOL)
 *
 *	@mfunc
 *		Sets the hilite background or selects the entire text for the
 *	edit control
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::HiliteEdit(
	BOOL bSelect)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::HiliteEdit");

	//bug fix 4073
	Assert(!_fOwnerDraw || _cbType == kDropDown);

	if (_cbType != kDropDownList)
	{
		//if bSelect is true else put cursor at beginning of text
		_pserv->TxSendMessage(EM_SETSEL, 0, (LPARAM)((bSelect) ? -1 : 0), NULL);
	}
	else
	{
		//Get the range of the paragraph
		ITextRange* pRange;		
		if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, &pRange))
		{
			AssertSz(FALSE, "unable to get range");
			return;
		}
		Assert(pRange);

		DWORD crFore = (unsigned)tomAutoColor;
		DWORD crBack = (unsigned)tomAutoColor;
		if (bSelect)
		{
			crFore = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
			crBack = ::GetSysColor(COLOR_HIGHLIGHT);
		}

		// Get the entire paragraph
		ITextFont* pFont = NULL;	

		// Select entire text
		CHECKNOERROR(pRange->SetIndex(tomParagraph, 1, 1));
		
		// Set the background and forground color
		CHECKNOERROR(pRange->GetFont(&pFont));
		
		Assert(pFont);
		CHECKNOERROR(pFont->SetBackColor(crBack));
		CHECKNOERROR(pFont->SetForeColor(crFore));

CleanExit:
		// Release pointers
		if (pFont)
			pFont->Release();
		pRange->Release();
	}
}


/*
 *	CCmbBxWinHost::UpdateEditBox()
 *
 *	@mfunc
 *		Updates the editcontrol window so that it contains the text
 * given by the current selection in the listbox.  If the listbox has no
 * selection (ie. -1), then we erase all the text in the editcontrol.
 *
 * hdc is from WM_PAINT messages Begin/End Paint hdc. If null, we should
 * get our own dc.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::UpdateEditBox()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::UpdateEditBox");

    Assert(_hwndList);
    Assert(_plbHost);

    // Update the edit box
    if (_cbType == kDropDownList && _fOwnerDraw)
    {
	   	CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	   	return;
	}
    else 
    {
		WCHAR* pszText = NULL;
	   	int nItem = (signed)_plbHost->GetCursor();   	
	    if (nItem != -1)
		{
			int cch = RichListBoxWndProc(_hwndList, LB_GETTEXTLEN, (LPARAM)nItem, 0);
		    pszText = new WCHAR[cch + 1];
			AssertSz(pszText, "allocation failed");

			// just get out if memory allocation failed
			if (!pszText)
			{
				TxNotify((unsigned)CBN_ERRSPACE, NULL);
				return;
			}
			RichListBoxWndProc(_hwndList, LB_GETTEXT, (WPARAM)nItem, (LPARAM)pszText);		
		}
	
    	// if the cursor is on a valid item then update edit with the item text
    	// else we just display a blank text
    	WCHAR szEmpty[] = L"";
    	_fIgnoreChange = 1;
    	_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)((pszText) ? pszText : szEmpty), NULL);
   		DrawEditFocus(NULL);
    	if (pszText)
    		delete pszText;
		_fIgnoreChange = 0;
    }
}

/*
 *	CCmbBxWinHost::UpdateListBox(BOOL)
 *
 *	@mfunc
 *		Updates the list box by searching and moving to the top the text in
 *	edit control.  And possibly pre-selecting the item if bSetSel is set
 *
 *	@rdesc
 *		int = found ? index of item : -1
 */
int CCmbBxWinHost::UpdateListBox(
	BOOL bSetSel)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::UpdateListBox");

    int nItem = -1;
    int nSel = -1;
	WCHAR* pszText;
	int cch;

	// Get text from edit box
    cch = GetTextLength();
    if (cch) 
    {
    	// add one for null string
        cch++;
        pszText = new WCHAR[cch];
        if (pszText != NULL) 
        {  
        	if (GetEditText(pszText, cch))
        	{
        		//Bypass Winnt thunking layer by calling the function directly
        		nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRING, (WPARAM)-1L, (LPARAM)pszText);
        	}
        	delete [] pszText;        	
        }
        else
        {
			TxNotify((unsigned)CBN_ERRSPACE, NULL);
			return 0;
		}
    }

    if (bSetSel)
        nSel = nItem;

	// update the list box
    RichListBoxWndProc(_hwndList, LB_SETCURSEL, (LPARAM)nSel, 0);
	RichListBoxWndProc(_hwndList, LB_SETTOPINDEX, (LPARAM)max(nItem, 0), 0);	
    return nItem;
}


/*
 *	CCmbBxWinHost::HideListBox(BOOL, BOOL)
 *
 *	@mfunc
 *		Hides the list box
 *
 *	@rdesc
 *		void
 */
BOOL CCmbBxWinHost::HideListBox(
	BOOL bNotify, 
	BOOL fSelOk)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::HideListBox");

	//send CBN_SELENDOK to all types of comboboxes but only
    // allow CBN_SELENDCANCEL to be sent for droppable comboboxes
	if (bNotify)
	{
		if (fSelOk)
		{
			TxNotify(CBN_SELENDOK, NULL);
		}
		else if (_cbType != kSimple)
		{
			TxNotify(CBN_SELENDCANCEL, NULL);
		}
	}
	
    // return, we don't hide simple combo boxes.
	if (!_fListVisible || _cbType == kSimple) 
    	return TRUE;

    // Tell the listbox to end tracking
    Assert(_plbHost);
	_plbHost->OnCBTracking(LBCBM_END, 0);     	
    
    // Hide the listbox window
    _fListVisible = 0;
	_fMouseover = 0;
    ShowWindow(_hwndList, SW_HIDE);
	if (_fCapture)
	{
		_fCapture = FALSE;
		TxSetCapture(FALSE);
	}

	_fResizing = 1;
    // Invalidate the item area now since SWP() might update stuff.
    // Since the combo is CS_VREDRAW/CS_HREDRAW, a size change will
    // redraw the whole thing, including the item rect.  But if it
    // isn't changing size, we still want to redraw the item anyway
    // to show focus/selection
    if (_cbType == kDropDownList)
	{
		if (!_fOwnerDraw)
			HiliteEdit(_fFocus);
        InvalidateRect(_hwnd, NULL, TRUE);
	}

	//bug fix
	// The button may look depressed so we must redraw the button
	if (_fMousedown)
	{
		_fMousedown = FALSE;
		InvalidateRect(_hwnd, &_rcButton, FALSE);
	}

    SetWindowPos(_hwnd, HWND_TOP, 0, 0, _cxCombo, _cyCombo, 
    	SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

	_fResizing = 0;

	if (_cbType == kDropDown)
		AutoUpdateEdit(_nCursor);
	_nCursor = -2;

    // In case size didn't change
    UpdateWindow(_hwnd);

    if (bNotify) 
    {
        //Notify parent we will be popping up the combo box.
        TxNotify(CBN_CLOSEUP, NULL);
    }

	// reset back to old cursor if mouse cursor was set
	if (_hcurOld)
	{
		TxSetCursor2(_hcurOld, NULL);
		_hcurOld = NULL;
	}
    return(TRUE);
}

/*
 *	CCmbBxWinHost::GetListBoxRect(RECT &rcList)
 *
 *	@mfunc
 *		Get the rect for the list box
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::GetListBoxRect(
	RECT &rcList)
{
	POINT pt1;
	int iWidth = _rcList.right - _rcList.left;

	if (iWidth < _cxList)
		iWidth = _cxList;

    pt1.x = _rcList.left;
    pt1.y = _rcList.top;

	TxClientToScreen(&pt1);
	rcList.left = pt1.x;
	rcList.top = pt1.y;
	rcList.right = rcList.left + iWidth;
	rcList.bottom = rcList.top + _cyList;

	int iWindowHeight = max((_rcWindow.bottom - _rcWindow.top) - _cyCombo, 0);
    int iHeight = max(_cyList, iWindowHeight);

	if (!_fOwnerDrawVar)
	{
		// List area
		int cyItem = _plbHost->GetItemHeight();
		AssertSz(cyItem, "LB_GETITEMHEIGHT is returning 0");

		if (cyItem == 0)
    		cyItem = _plbHost->GetFontHeight();

		// Windows NT comment:
		//  we shoulda' just been able to use cyDrop here, but thanks to VB's need
		//  to do things their OWN SPECIAL WAY, we have to keep monitoring the size
		//  of the listbox 'cause VB changes it directly (jeffbog 03/21/94)

		DWORD dwMult = (DWORD)RichListBoxWndProc(_hwndList, LB_GETCOUNT, 0, 0);
		INT	cyEdge = GetSystemMetrics(SM_CYEDGE);

		if (dwMult) 
		{
			dwMult = (DWORD)(LOWORD(dwMult) * cyItem);
			dwMult += cyEdge;

			if (dwMult < 0x7FFF)
				iHeight = min(LOWORD(dwMult), iHeight);
		}

		if (!_fNoIntegralHeight)
			iHeight = ((iHeight - cyEdge) / cyItem) * cyItem + cyEdge;
	}

    //UNDONE: Multi-monitor
    //	We need to change the following code if we are to support multi-monitor
    int yTop;
    int nScreenHeight = GetSystemMetrics(SM_CYFULLSCREEN);    
    if (rcList.top + iHeight <= nScreenHeight) 
    {
        yTop = rcList.top;
        if (!_fBorder)
            yTop -= W32->GetCyBorder();
    } 
    else 
    {
        yTop = max(rcList.top - iHeight - _cyCombo + 
			((_fBorder) ? W32->GetCyBorder() : 0), 0);
    }

	rcList.top = yTop;
	rcList.bottom = rcList.top + iHeight;
}

/*
 *	CCmbBxWinHost::ShowListBox(BOOL)
 *
 *	@mfunc
 *		Displays the list box
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::ShowListBox(
	BOOL fTrack)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::ShowListBox");
	
	Assert(_cbType != kSimple);
	Assert(_hwndList);

	// Notify parent window we are about to drop down the list box
	TxNotify(CBN_DROPDOWN, NULL);

	// force a redraw of the button so it looks depressed
	InvalidateRect(_hwnd, &_rcButton, TRUE);

	_fListVisible = TRUE;
	_fIgnoreChange = 0;

	_bSelOk = 0;
	if (_cbType == kDropDown)
	{
		UpdateListBox(!_fMousedown);
		if (!_fMousedown)
			AutoUpdateEdit(-1);
		_nCursor = _plbHost->GetCursor();

	}
	else
	{
        // Scroll the currently selected item to the top of the listbox.        
		int idx = (signed)_plbHost->GetCursor();
		_nCursor = idx;
		if (idx == -1)
			idx = 0;

		// set the top index if there is something in the list box
		if (_plbHost->GetCount() > 0)
			RichListBoxWndProc(_hwndList, LB_SETTOPINDEX, idx, 0);	

		// We are to lose focus in this case
		_fFocus = 0;
		if (!_fOwnerDraw)
			HiliteEdit(FALSE);
		
	    // We need to invalidate the edit rect so that the focus frame/invert
        // will be turned off when the listbox is visible.  Tandy wants this for
        // his typical reasons...        
        InvalidateRect(_hwnd, NULL, TRUE);        
    }

    // Figure out where to position the dropdown listbox.
    // We want the dropdown to pop below or above the combo
    // Get screen coords
	RECT	rcList;

	GetListBoxRect(rcList);
    SetWindowPos(_hwndList, HWND_TOPMOST, rcList.left,
        rcList.top, rcList.right - rcList.left, rcList.bottom - rcList.top, 0);

	Assert(_plbHost);
    _plbHost->SetScrollInfo(SB_VERT, FALSE);

	
	if (_cbType == kDropDownList)
		_fFocus = 0;

	// UNDONE:
	// Are we going to support window animation?	
    ShowWindow(_hwndList, SW_SHOW);
	
	// We send a message to the listbox to prepare for tracking
	if (fTrack)
	{		
		Assert(_plbHost);
		// initialize type searching
		_plbHost->InitSearch();
		_plbHost->OnCBTracking(LBCBM_PREPARE, LBCBM_PREPARE_SAVECURSOR | 
						((_cbType == kDropDownList) ? LBCBM_PREPARE_SETFOCUS : 0));
	}
	
	// Since we are about to display the list box change mouse cursor to arrow
	if (!_hcurOld)
		_hcurOld = TxSetCursor2(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
}

////////////////////////// Combo box Message Handlers ////////////////////////////////

/*
 *	CCmbBxWinHost::CbSetItemHeight(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Sets the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? 1 : CB_ERR
 */
LRESULT CCmbBxWinHost::CbSetItemHeight(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetItemHeight");

	int nHeight = lparam;
	//bug fix #4556
	if (nHeight == 0 || nHeight > 255)
		return CB_ERR;

	// We need to update the height internally
	if (wparam == (unsigned)-1)
	{
		RECT rc;
		GetClientRect(_hwnd, &rc);
		_dyEdit = nHeight;
		OnSize(0, MAKELONG(rc.right - rc.left, rc.bottom - rc.top));
	}
	else
		RichListBoxWndProc(_hwndList, LB_SETITEMHEIGHT, wparam, MAKELPARAM(nHeight, 0));

	return 1;
}

/*
 *	CCmbBxWinHost::CbGetDropWidth()
 *
 *	@mfunc
 *		Retrieves the drop width of the list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? 1 : CB_ERR
 */
LRESULT CCmbBxWinHost::CbGetDropWidth()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbGetDropWidth");

	int iWidth = _rcList.right - _rcList.left;

	return _cxList > iWidth ? _cxList : iWidth;
}

/*
 *	CCmbBxWinHost::CbSetDropWidth(WPARAM)
 *
 *	@mfunc
 *		sets the drop width of the list box.
 *
 */
void CCmbBxWinHost::CbSetDropWidth(
	WPARAM wparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetDropWidth");

	if ((int)wparam != _cxList)
	{
		_cxList = wparam;

		if (_cbType != kSimple)
			SetDropSize(&_rcList);	// Need to resize the list box
	}

}

/*
 *	CCmbBxWinHost::CbGetItemHeight(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Retrieves the item height of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = item height of the edit or list box
 */
LRESULT CCmbBxWinHost::CbGetItemHeight(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbGetItemHeight");

	return (wparam == (unsigned)-1) ? _dyEdit :
		RichListBoxWndProc(_hwndList, LB_GETITEMHEIGHT, _fOwnerDrawVar ? wparam : 0, 0);
}


/*
 *	CCmbBxWinHost::CbSetExtendedUI(BOOL)
 *
 *	@mfunc
 *		Retrieves the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? CB_OKAY : CB_ERR
 */
LRESULT CCmbBxWinHost::CbSetExtendedUI(
	BOOL bExtendedUI)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetExtendedUI");

	// We need to update the height internally
	_fExtendedUI = bExtendedUI ? 1 : 0;
	return CB_OKAY;
}


/*
 *	CCmbBxWinHost::CbMessageItemHandler(int, WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles any and all WM_DRAWITEM, WM_DELETEITEM, and WM_MEASUREITEM messages
 *
 *
 *	@rdesc
 *		LRESULT = whatever the parent window returns
 */
LRESULT CCmbBxWinHost::CbMessageItemHandler(
	HDC hdc, 
	int ff, 
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbMessageItemHandler");

	// modify the structure info a bit and pass it to the parent window
    DRAWITEMSTRUCT dis;   
    BOOL bRelease = FALSE;
    UINT msg = WM_DRAWITEM;
	switch (ff)
	{
	case ITEM_MSG_DRAWLIST:
		((LPDRAWITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
	    ((LPDRAWITEMSTRUCT)lparam)->CtlID = _idCtrl;
	    ((LPDRAWITEMSTRUCT)lparam)->hwndItem = _hwnd;	    
	    break;

	case ITEM_MSG_DELETE:
		((LPDELETEITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
	    ((LPDELETEITEMSTRUCT)lparam)->CtlID = _idCtrl;
	    ((LPDELETEITEMSTRUCT)lparam)->hwndItem = _hwnd;
	    msg = WM_DELETEITEM;
	    break;

	case ITEM_MSG_MEASUREITEM:
		((LPMEASUREITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
		((LPMEASUREITEMSTRUCT)lparam)->CtlID = _idCtrl;
		msg = WM_MEASUREITEM;
		break;

	case ITEM_MSG_DRAWCOMBO:
		if (!hdc)
	    {
	    	bRelease = TRUE;
	    	hdc = TxGetDC();
	    }
	    //Fill the DRAWITEMSTRUCT with the unchanging constants
	    dis.CtlType = ODT_COMBOBOX;
	    dis.CtlID = _idCtrl;    

	    // Use -1 if an invalid item number is being used.  This is so that the app
	    // can detect if it should draw the caret (which indicates the lb has the
	    // focus) in an empty listbox
	    dis.itemID = _plbHost->GetCursor();
	    dis.itemAction = ODA_DRAWENTIRE;
	    dis.hwndItem = _hwnd;	    
	    dis.hDC = hdc;
		dis.itemData = (_plbHost->GetCount()) ? (((signed)dis.itemID >= 0) ? _plbHost->GetData(dis.itemID) : 0) : 0;
	    dis.itemState = (UINT)((_fFocus && !_fListVisible ? ODS_SELECTED | ODS_FOCUS : 0) |
                    ((_fDisabled) ? ODS_DISABLED : 0) | ODS_COMBOBOXEDIT);
		           
		// Calculate the drawing rect
        TxGetClientRect(&dis.rcItem);
        if (_cbType != kSimple)
        {
        	if (_fRightAlign)
        		dis.rcItem.left = _rcButton.right;
        	else
        		dis.rcItem.right = _rcButton.left;
        }

        // immulate the system by making the HDC invert text if we have focus
		SetBkMode(hdc, OPAQUE);
		DWORD	crBack = GetSysColor(_fDisabled ? COLOR_BTNFACE : COLOR_WINDOW);
		HBRUSH	hbrBack = CreateSolidBrush(crBack);
		HBRUSH	hOldBrush = NULL;
		if (hbrBack)
			hOldBrush = (HBRUSH)::SelectObject(hdc, hbrBack);

		PatBlt(hdc, dis.rcItem.left, dis.rcItem.top, dis.rcItem.right - dis.rcItem.left,
                dis.rcItem.bottom - dis.rcItem.top, PATCOPY);

		if (hOldBrush)
			hOldBrush = (HBRUSH)::SelectObject(hdc, hOldBrush);
		::DeleteObject(hbrBack);

		if (_fFocus && !_fListVisible) 
		{
            SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }

		DrawCustomFrame(0, hdc);      

        // Don't let ownerdraw dudes draw outside of the combo client
        // bounds.
		InflateRect(&dis.rcItem, -1, -1);

		// For new look case, we are off by 1 between this rect and the dropdown rect
		// after the InflateRect
		if (_cbType != kSimple && ((CTxtEdit *) _pserv)->_fCustomLook)
		{
			if (_fRightAlign)
				dis.rcItem.left -= 1;
			else
				dis.rcItem.right += 1;
		}

        IntersectClipRect(hdc, dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, 
        				dis.rcItem.bottom);
	    lparam = (LPARAM)&dis;		
	}

	LRESULT lres = SendMessage(_hwndParent, msg, _idCtrl, lparam);
	if (bRelease)
		TxReleaseDC(hdc);

	return lres;
}

/////////////////////////// Windows Message Handlers /////////////////////////////////
/* 
 *	CCmbBxWinHost::OnCommand(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles notification from listbox and reflects it to the parent of
 *		the combo box
 *
 *	@comm
 *		LRESULT = Handled ? 0 : 1
 *
 *
 */
HRESULT CCmbBxWinHost::OnCommand(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::OnCommand");
	
	// Filter-out all the messages except Listbox notification messages
	Assert(_hwndParent);
	switch (HIWORD(wparam))
	{	
	case LBN_DBLCLK:
    	TxNotify(CBN_DBLCLK, NULL);
        break;

    case LBN_ERRSPACE:
        TxNotify((unsigned)CBN_ERRSPACE, NULL);
        break;

    case LBN_SELCHANGE:
    case LBN_SELCANCEL:
    	if (!_fListVisible)
			HideListBox(TRUE, TRUE);
    	TxNotify(CBN_SELCHANGE, NULL);
        UpdateEditBox();
        break;

    default:
    	// not handled so pass down the line
        return 1;
	}
	return 0;
}

/*
 *	CCmbBxWinHost::OnEnable(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_ENABLE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnEnable(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnEnable");

	if (_fMousedown) 
	{
        _fMousedown = FALSE;
        DrawButton(NULL, FALSE);

        //
        // Pop combo listbox back up, canceling.
        //
        if (_fListVisible)
            HideListBox(TRUE, FALSE);
    }
    return 1;
}


/*
 *	CCmbBxWinHost::OnChar(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_CHAR message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnChar(
	WORD wparam, 
	DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnChar");

	// Check if we should eat the message or not
	if (_cbType == kDropDownList)
	{
		//bug fix #5318 - ignore delete, insert and clear
		if (((WCHAR)wparam) == VK_DELETE || ((WCHAR)wparam) == VK_INSERT ||
			((WCHAR)wparam) == VK_CLEAR)
			return 0;
			
		// Sending WM_CHAR is BAD!!! call the message handler directly
		// send the character string message to the listbox if visible
		_plbHost->OnChar(LOWORD(wparam), lparam);

		//	If Hi-Ansi need to send a wm_syskeyup message to ITextServices to 
		// stabalize the state
		if (0x80 <= wparam && wparam <= 0xFF && !HIWORD(GetKeyState(VK_MENU)))
		{
			LRESULT lres;
			_pserv->TxSendMessage(WM_SYSKEYUP, VK_MENU, 0xC0000000, &lres);
		}		
		return 0;
	}

	
	if (_cbType == kDropDown)
	{
		if (_fListVisible)
		{
			if (!_fCapture)
			{
				// Tell listbox to reset capturing by ending then starting it up
				_plbHost->OnCBTracking(LBCBM_END, 0);
				_plbHost->OnCBTracking(LBCBM_PREPARE, 0);			
			}

			// Send the message to the edit control iff it's not a tab
			if (((WCHAR)wparam) != VK_TAB)
				_pserv->TxSendMessage(WM_CHAR, wparam, lparam, NULL);

			if (!_fCapture)
			{
				// capture the cursor
				TxSetCapture(TRUE);
				_fCapture = 1;				
			}
		}
		else
		{
			// set the cursel to -1 if it already isn't
			if ((wparam != VK_RETURN) && (_plbHost->GetCursor() != -1))
				RichListBoxWndProc(_hwndList, LB_SETCURSEL, (WPARAM)-1, 0);

			// Send the message to the edit control iff it's not CTRL+i or CTRL+h
			if (((WCHAR)wparam) != VK_TAB)
				_pserv->TxSendMessage(WM_CHAR, wparam, lparam, NULL);
		}		
		return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnKeyDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_KEYDOWN message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnKeyDown(
	WORD wparam, 
	DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnKeyDown");

	BOOL	fUpdateCursor = FALSE;

	if (_fListVisible && (wparam == VK_RETURN || wparam == VK_ESCAPE))
	{
		if (wparam == VK_RETURN)
			_nCursor = _plbHost->GetCursor();

		// if we don't have focus then set the focus first
		if (!_fFocus)
			TxSetFocus();
		_fFocus = 1;

		HideListBox(TRUE, wparam == VK_RETURN);
		return 0;
	}
	
	// if we are in extended mode and F4 is hit
	// we just ignore it
	if (_fExtendedUI && wparam == VK_F4)
		return 0;
	
	Assert(_plbHost);
	int fExtUI = _fExtendedUI;
	int nCurSel = _plbHost->GetCursor();
	Assert(nCurSel >= -1);
	
	// if we are a dropdownlist combo box then just forward the message on to the 
	// list box 
	if (_cbType == kDropDownList)
	{
		switch (wparam)
		{		
		case VK_F4:
			if (_fListVisible)
				break;;
			fExtUI = 1;
			Assert(fExtUI && !_fListVisible);
			// fall through case		
			
		case VK_DOWN:
			if (fExtUI && !_fListVisible)
			{
				ShowListBox(TRUE);
				TxSetCapture(TRUE);			
				_fCapture = TRUE;
				return 1;			
			}		
			// Fall through case
			
		case VK_UP:
		case VK_NEXT:
		case VK_PRIOR:		
		case VK_RETURN:
		case VK_ESCAPE:	
		case VK_HOME:
		case VK_END:
			break;	

		//bug fix #5318
		/*
		case VK_DELETE:
		case VK_CLEAR:
		case VK_INSERT:
		*/

		default:
			// There no reason for us to pass these keys to ITextServices since the control is suppose
			// to be read-only
			return 0;
		}
	}
	else 
	{
		fUpdateCursor = TRUE;

		switch (wparam)
		{		
		case VK_F4:
			if (_fListVisible)
				break;
			fExtUI = 1;
			Assert(fExtUI && !_fListVisible);
			// fall through case		
			
		case VK_DOWN:
			if (fExtUI && !_fListVisible)
			{
				ShowListBox(TRUE);
				TxSetCapture(TRUE);			
				_fCapture = TRUE;
				return 0;			
			}		
			// Fall through case
			
		case VK_UP:
		case VK_NEXT:
		case VK_PRIOR:
			if (_fListVisible)
			{				
				if (_fCapture)
				{
					// release our capture flag and tell lb to start tracking
					_fCapture = 0;
					_plbHost->OnCBTracking(LBCBM_START, _fMousedown);
				}

				// selecting the top index and then sending the keydown to the 
				// listbox causes 2 moves so handle this ourselves
				if (nCurSel == -1)
				{
					LRESULT lResult = RichListBoxWndProc(_hwndList, LB_SETCURSEL, _plbHost->GetTopIndex(), 0);
					UpdateEditBox();
					UpdateCbWindow();
					if (lResult != LB_ERR)
						TxNotify(CBN_SELCHANGE, NULL);
					return 0;
				}
			}
			else
			{
				// if Listbox isn't visible and the listbox cursor is -1
				// then we should try to select the correct item in the list
				// box
				if (nCurSel == -1)
				{
					UpdateListBox(TRUE);
					if (_plbHost->GetCursor() >= 0)
					{
						HiliteEdit(TRUE);
						return 0;
					} else if (!_plbHost->GetCount())
					{
						return 0;
					}
				}
			}
			break;
		
		case VK_RETURN:
		case VK_ESCAPE:	
			break;		

		default:
			// return zero to say we didn't handle this
			return 1;
		}
	}
	// pass message to list box
	_plbHost->OnKeyDown(wparam, lparam, 0);
	UpdateCbWindow();

	if (fUpdateCursor)
		_nCursor = _plbHost->GetCursor();

	return 0; 
	
}

/*
 *	CCmbBxWinHost::OnSyskeyDown(WORD, DWORD)
 *
 *	@mfunc
 *		handles the WM_SYSKEYDOWN message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnSyskeyDown(
	WORD wparam, 
	DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSyskeyDown");

	if (lparam & 0x20000000L)  /* Check if the alt key is down */ 
	{
	    // Handle Combobox support.  We want alt up or down arrow to behave
	    // like F4 key which completes the combo box selection
		if (lparam & 0x1000000)
		{
			// We just want to ignore keys on the number pad...
	        // This is an extended key such as the arrow keys not on the
	        // numeric keypad so just drop the combobox.
	        if (wparam != VK_DOWN && wparam != VK_UP)
	            return 1;
		}
		else if (GetKeyState(VK_NUMLOCK) & 0x1) 
	    {
	        //If numlock down, just send all system keys to dwp
	        return 1;
	    } 
	    else 
	    {
			if (wparam != VK_DOWN && wparam != VK_UP)
				return 1;	    	
	    }

	    // If the listbox isn't visible, just show it
	    if (!_fListVisible) 
		{
			ShowListBox(TRUE);
			TxSetCapture(TRUE);			
			_fCapture = TRUE;
		}
	    else  	//Ok, the listbox is visible.  So hide the listbox window.
	        HideListBox(TRUE, TRUE);
	    return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnCaptureChanged(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_CAPTURECHANGED message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnCaptureChanged(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCaptureChanged");
    if (_fCapture) 
    {   
        // Pop combo listbox back up, canceling.
        if (_fListVisible)
            HideListBox(TRUE, FALSE);
        else
        {
        	_fCapture = FALSE;
   			_fMousedown = FALSE;
        	DrawButton(NULL, FALSE);
        }
		return 0;
    }
	return 1;
}


/*
 *	CCmbBxWinHost::OnMouseMove(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_MOUSEMOVE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseMove(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnMouseMove");

	if (((CTxtEdit *) _pserv)->_fCustomLook &&
		!_fMouseover && 
		W32->TrackMouseLeave(_hwnd))
	{
		if (_fFocus || W32->IsForegroundFrame(_hwnd))
		{
			_fMouseover = TRUE;
			// Force redraw
			InvalidateRect(_hwnd, NULL, TRUE);
		}
	}

	// We do the following if we have mouse captured or if the listbox is visible
	if (_cbType != kSimple && _fCapture)
	{
		// get the point coordinates of mouse
		POINT pt;
		POINTSTOPOINT(pt, lparam);
		if (_fListVisible)
		{
			// if the listbox is visible visible check if the cursor went over 
			// list box
			RECT rc;
			POINT ptScreen = pt;
			GetWindowRect(_hwndList, &rc);
			TxClientToScreen(&ptScreen);			
			if (PtInRect(&rc, ptScreen))
			{
				// Release the capture state of the mouse
				if (_fCapture)
				{
					_fCapture = FALSE;
					TxSetCapture(FALSE);
				}

				// notify the listbox to start tracking
				Assert(_plbHost);
				// BUGBUG REVIEW JMO Wrong PostMessage????
				::PostMessage(_hwndList, LBCB_TRACKING, LBCBM_START, _fMousedown);
				_fMousedown = 0;
			}
		}
		DrawButton(NULL, _fMousedown ? PtInRect(&_rcButton, pt) : FALSE);
		return FALSE;
	}
#ifdef DEBUG
	if (_cbType != kSimple)
		Assert(!_fListVisible);
#endif
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnMouseLeave(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_MOUSELEAVE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseLeave(
	WPARAM wparam, 
	LPARAM lparam)
{
	if (!_fListVisible && _fMouseover)
	{
		_fMouseover = FALSE;
		InvalidateRect(_hwnd, NULL, TRUE);
	}
	return 0;
}

/*
 *	CCmbBxWinHost::OnSetEditStyle(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_MOUSELEAVE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnSetEditStyle(
	WPARAM wparam, 
	LPARAM lparam)
{
	LRESULT	lres;
	_pserv->TxSendMessage(EM_SETEDITSTYLE, wparam, lparam, &lres);
	if (lparam & SES_CUSTOMLOOK)
	{
		if (wparam & SES_CUSTOMLOOK)
		{
			_dwExStyle &= ~WS_EX_CLIENTEDGE;
			_fBorder = 1;
		}
		else
			_dwExStyle |= WS_EX_CLIENTEDGE;

		SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
	}
	return lres;
}
	
/*
 *	CCmbBxWinHost::OnLButtonUp(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_LBUTTONUP message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnLButtonUp(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnLButtonUp");
 
    if (_fMousedown) 
	{
        _fMousedown = FALSE;
        if (_cbType != kSimple) 
		{
            // If an item in the listbox matches the text in the edit
            // control, scroll it to the top of the listbox. Select the
            // item only if the mouse button isn't down otherwise we
            // will select the item when the mouse button goes up.
			if (_cbType == kDropDown)
			{
				UpdateListBox(TRUE);
				AutoUpdateEdit(-1);		
			}
			
			// if we recieved a mouse up and the listbox is still visible then user 
			// hasn't selected any items from the listbox so don't release the capture yet
			if (_fCapture && !_fListVisible)
			{
				_fCapture = FALSE;
				TxSetCapture(FALSE);
			}

			DrawButton(NULL, FALSE);
			if (_fButtonDown)
			{
				_fButtonDown = 0;
#ifndef NOACCESSIBILITY
				W32->NotifyWinEvent(EVENT_OBJECT_STATECHANGE, _hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
#endif
			}
			return FALSE;
		}
    }
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnLButtonDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the client edges of the combo box
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnLButtonDown(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnLButtonDown");

	// check if we should dropdown the list box
	POINT pt;
	POINTSTOPOINT(pt, lparam);
	RECT	rcEdit = _rcWindow;
	BOOL	fListVisibleBefore = _fListVisible;
	LRESULT	retCode = 1;

	rcEdit.bottom = _cyCombo;

	// if we don't have focus then set the focus first
	if (!_fFocus)
	{
		TxSetFocus();
		if (_cbType != kDropDownList)
			retCode = 0;
	}
	_fFocus = 1;

	if (fListVisibleBefore && !_fListVisible)	// This is the case where OnSetFocus 
		return 0;								//	has hide the listbox already

	// listbox is down so pop it back up
	if (_fListVisible)
		return !HideListBox(TRUE, FALSE);

	if ((_cbType == kDropDownList && PtInRect(&rcEdit, pt))
		|| (_cbType == kDropDown && PtInRect(&_rcButton, pt)))
	{
		// need to show listbox
		ShowListBox(TRUE);
		_fMousedown = TRUE;
					
		TxSetCapture(TRUE);			
		_fCapture = TRUE;

#ifndef NOACCESSIBILITY
		if (_cbType == kDropDown)
		{
			_fButtonDown = TRUE;
			W32->NotifyWinEvent(EVENT_OBJECT_STATECHANGE, _hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
		}
#endif
		return 0;
	}
	return retCode;
}

/*
 *	CCmbBxWinHost::OnMouseWheel(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the client edges of the combo box
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseWheel(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnMouseWheel");
	
    // Handle only scrolling.
    if (wparam & (MK_CONTROL | MK_SHIFT))
        return 1;

    // If the listbox is visible, send it the message to scroll.
    // if the listbox is 
	if (_fListVisible)
	{
		_plbHost->OnMouseWheel(wparam, lparam);
		return 0;
	}
		
    // If we're in extended UI mode or the edit control isn't yet created,
    // bail.
    if (_fExtendedUI)
        return 0;

    // Emulate arrow up/down messages to the edit control.
    int i = abs(((short)HIWORD(wparam))/WHEEL_DELTA);
    wparam = ((short)HIWORD(wparam) > 0) ? VK_UP : VK_DOWN;

    while (i-- > 0) 
        OnKeyDown(wparam, lparam);

	return 0;
}


/*
 *	CCmbBxWinHost::OnSetCursor(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Changes the cursor depending on where the cursor is
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
LRESULT CCmbBxWinHost::OnSetCursor(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetCursor");

	POINT pt;
	GetCursorPos(&pt);
	::ScreenToClient(_hwnd, &pt);

	if ((_cbType == kDropDownList) || 
		(_cbType == kDropDown && ((_fRightAlign) ? _rcButton.right >= pt.x : _rcButton.left <= pt.x)))
	{
		TxSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
	}
	else
		_pserv->OnTxSetCursor(DVASPECT_CONTENT,	-1,	NULL, NULL, NULL, NULL,
			NULL, pt.x, pt.y);

	return TRUE;
}

/*
 *	CCmbBxWinHost::OnSetFocus(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
LRESULT CCmbBxWinHost::OnSetFocus(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetFocus");

    _fFocus = TRUE;

	// Hide the list box
	if (_fListVisible)		    	
    	HideListBox(TRUE, _bSelOk);
    else if (_fOwnerDraw && _cbType == kDropDownList)
    	CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	else    
		DrawEditFocus(NULL);    // Draw the focus 

    // Notify the parent we have the focus iff this function
    // wasn't called in response to LBCB_TRACKING
    if (_fLBCBMessage)
    	_fLBCBMessage = 0;
    else
	    TxNotify(CBN_SETFOCUS, NULL);

	// we return 1 if we are owner draw or if
	// we are a kDropDownList, this is because
	// we have to prevent the message from being passed
	// to _pserv
    return (_cbType == kDropDownList);
}


/*
 *	CCmbBxWinHost::OnKillFocus(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
LRESULT CCmbBxWinHost::OnKillFocus(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnKillFocus");

	// if we never had focus or if not list window just get out
	if (_hwndList == NULL)
	      return 0;

	BOOL fHideListBox = FALSE;

    if ((HWND)wparam != _hwndList) 
    {
		// We only give up the focus if the new window getting the focus
        // doesn't belong to the combo box.
	    
	    // The combo box is losing the focus.  Send buttonup clicks so that
	    // things release the mouse capture if they have it...  If the
	    // pwndListBox is null, don't do anything.  This occurs if the combo box
	    // is destroyed while it has the focus.
	    OnLButtonUp(0L, 0xFFFFFFFFL);

		if (_fListVisible)
		{
			fHideListBox = TRUE;
			HideListBox(TRUE, FALSE);
		}
	}

	//bug fix #4013
	if (!_fFocus)
		return 0;
	_fFocus = FALSE;

	if (!fHideListBox)
		TxNotify(CBN_SELENDCANCEL, NULL);	// System Combo is always sending this notification

	// Remove Focus Rect
	if (_cbType != kDropDownList)
	{		
		HiliteEdit(FALSE);

		// Hide any selections
		_pserv->TxSendMessage(EM_HIDESELECTION, 1, 0, NULL);
	}
	else if (_fOwnerDraw)
		CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	else
		DrawEditFocus(NULL);
		
		
	TxNotify(CBN_KILLFOCUS, NULL); 

	if (_cbType == kDropDownList)
		return 1;
	return 0;
}


/*
 *	CCmbBxWinHost::OnSize(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = Processed ? FALSE : TRUE
 */
LRESULT CCmbBxWinHost::OnSize(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCbSize");

    // only deal with this message if we didn't generate the message and
    // the new size is a valid one
    if (!_fResizing && _hwndList)
    {
    	_fResizing = 1;
    	RECT rc;
    	GetWindowRect(_hwnd, &rc);
    	rc.right -= rc.left;
    	rc.bottom -= rc.top;    	
    	rc.left = rc.top = 0;
    	CbCalcControlRects(&rc, FALSE);
    	
    	// Need to resize the list box
		if (_cbType != kSimple)
			SetDropSize(&_rcList);
		_fResizing = 0;
    } 
	_pserv->TxSendMessage(WM_SIZE, wparam, lparam, NULL);
	CTxtWinHost::OnSize(_hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));	
	return FALSE;
}

/*
 *	CCmbBxWinHost::OnGetDlgCode(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
LRESULT CCmbBxWinHost::OnGetDlgCode(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnGetDlgCode");

	// call the parents GetDlgCode first	
	LRESULT code = DLGC_WANTCHARS | DLGC_WANTARROWS;
	if (_cbType != kDropDownList)
		code |= DLGC_HASSETSEL;

	// If the listbox is dropped and the ENTER key is pressed,
	// we want this message so we can close up the listbox
	if ((lparam != 0) &&
	    (((LPMSG)lparam)->message == WM_KEYDOWN) &&
	    _fListVisible &&
	    ((wparam == VK_RETURN) || (wparam == VK_ESCAPE)))
	{
	    code |= DLGC_WANTMESSAGE;
	}
	_fInDialogBox = TRUE;
		
	return((LRESULT)code);
}

/*
 *	CCmbBxWinHost::OnSetTextEx(WPARAM, LPARAM)
 *
 *	@mfunc
 *		The first item is sent to the editbox and the rest
 *	of the string is sent to the listbox.
 *
 *	@rdesc
 *		LRESULT
 */
LRESULT CCmbBxWinHost::OnSetTextEx(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetTextEx");

	WCHAR	*psz = (WCHAR*)lparam;

	_nCursor = -2;			// Reset last selected item
	if (!psz || *psz == L'\0')
	{
		// Null string
		_pserv->TxSendMessage(EM_SETTEXTEX, wparam, lparam, NULL);
		return S_OK;
	}

	while (*psz != L'\r' && *psz)
		psz++;

	long cch = (psz - (WCHAR*)lparam);

	WCHAR *pwch = new WCHAR[cch + 1];

	if (!pwch)			// No memory?
	{
		TxNotify((unsigned)CBN_ERRSPACE, NULL);
		return S_OK;
	}

	if (cch)
		memcpy(pwch, (void *)lparam, cch * sizeof(WCHAR));

	_pserv->TxSendMessage(EM_SETTEXTEX, wparam, (LPARAM)pwch, NULL);

	delete [] pwch;

	if (*psz == L'\0')
		return S_OK;

	// Send rest of strings to REListbox.
	psz++;

	return SendMessage(_hwndList, EM_SETTEXTEX, wparam, (LPARAM)psz);
}

/*
 *	CCmbBxWinHost::OnPaint(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = processed ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnPaint(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnPaint");

	PAINTSTRUCT ps;
	HPALETTE hpalOld = NULL;
	HDC hdc = BeginPaint(_hwnd, &ps);
	RECT rcClient;

	_fIgnoreUpdate = 1;		// Ignore EN_UPDATE from host

	// Since we are using the CS_PARENTDC style, make sure
	// the clip region is limited to our client window.
	GetClientRect(_hwnd, &rcClient);

	// pass message on to the parentwindow if owner draw
	if (_cbType != kDropDownList || !_fOwnerDraw)
	{
		RECT rcFocus = rcClient;
		
		// Set up the palette for drawing our data
		if (_hpal)
		{
			hpalOld = SelectPalette(hdc, _hpal, TRUE);
			RealizePalette(hdc);
		}

		SaveDC(hdc);

		IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
			rcClient.bottom);

		// Fill-in the gap between the button and richedit control
		RECT rcGap;
		if (_fRightAlign)
		{
			rcGap.left = _rcButton.right;
			rcGap.right = rcGap.left + _xInset + 1;
		}
		else
		{
			rcGap.right = _rcButton.left;
			rcGap.left = rcGap.right - _xInset - 1;
		}
		rcGap.top = rcClient.top;
		rcGap.bottom = rcClient.bottom;			
		FillRect(hdc, &rcGap, (HBRUSH)(DWORD_PTR)(((_fDisabled) ? COLOR_BTNFACE : COLOR_WINDOW) + 1));
	
		if (_fFocus && _cbType == kDropDownList)		
		{	
			//First if there is a focus rect then remove the focus rect
			// shrink the focus rect by the inset
			rcFocus.top += _yInset;
			rcFocus.bottom -= _yInset;			
			
			if (_fRightAlign)
				rcFocus.left = _rcButton.right;
			else
				rcFocus.right = _rcButton.left;

			rcFocus.left += _xInset;

			if (!((CTxtEdit *) _pserv)->_fCustomLook)
				rcFocus.right -= _xInset;

			// We need to erase the focus rect if we haven't already 
			// erased the background
			DrawFocusRect(hdc, &rcFocus);
		}		

		if (_cbType != kSimple)
		{
			if (_fRightAlign)
				rcClient.left = _rcButton.right + _xInset;
			else
				rcClient.right = _rcButton.left - (((CTxtEdit *)_pserv)->_fCustomLook ? 0 : _xInset);
		}


		_pserv->TxDraw(
			DVASPECT_CONTENT,  		// Draw Aspect
			-1,						// Lindex
			NULL,					// Info for drawing optimazation
			NULL,					// target device information
			hdc,					// Draw device HDC
			NULL, 				   	// Target device HDC
			(const RECTL *) &rcClient,// Bounding client rectangle
			NULL, 					// Clipping rectangle for metafiles
			&ps.rcPaint,			// Update rectangle
			NULL, 	   				// Call back function
			NULL,					// Call back parameter
			TXTVIEW_ACTIVE);		// What view - the active one!

		// Restore palette if there is one
		if(hpalOld)
			SelectPalette(hdc, hpalOld, TRUE);

		RestoreDC(hdc, -1);

		//Redraw the focus rect, don't have to recalc since we already did above
		if (_fFocus && _cbType == kDropDownList)
			DrawFocusRect(hdc, &rcFocus);

		DrawButton(hdc, _fMousedown);

		DrawCustomFrame(0, hdc);
	}
	else
	{
		// We have to draw the button first because CbMessageItemHandler
		// will perform a IntersectClipRect which will prevent us from
		// drawing the button later
		DrawButton(hdc, _fMousedown);
		
		CbMessageItemHandler(hdc, ITEM_MSG_DRAWCOMBO, 0, 0);
	}

	EndPaint(_hwnd, &ps);

	_fIgnoreUpdate = 0;
	if (_fSendEditChange)
	{
		TxNotify(EN_UPDATE, NULL);
		_fSendEditChange = 0;
	}
    return FALSE;
}


/*
 *	CCmbBxWinHost::DrawCustomFrame(WPARAM, hDCIn)
 *
 *	@mfunc
 *		Draws the custom frame
 *
 *	@rdesc
 *		BOOL = processed ? TRUE : FALSE
 */
BOOL CCmbBxWinHost::DrawCustomFrame(
	WPARAM	wParam,
	HDC		hDCIn)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawCustomFrame");

	BOOL retCode = FALSE;
	if (((CTxtEdit *) _pserv)->_fCustomLook)
	{
		HDC		hdc = hDCIn;
		BOOL	fReleaseDC = hDCIn ? FALSE : TRUE;

		if (!hdc)
		{
			if (wParam == 1)
				hdc = ::GetDC(_hwnd);
			else
				hdc = ::GetDCEx(_hwnd, (HRGN)wParam, DCX_WINDOW|DCX_INTERSECTRGN);
		}

		if (hdc)
		{
			RECT rcClient;

			GetClientRect(_hwnd, &rcClient);

			retCode = TRUE;
			// Draw border rectangle using new look
			COLORREF crBorder = W32->GetCtlBorderColor(_fListVisible, _fMouseover);
			HBRUSH hbrBorder = CreateSolidBrush(crBorder);
			::FrameRect(hdc, &rcClient, hbrBorder);
			::DeleteObject(hbrBorder);

			if (fReleaseDC)
				::ReleaseDC(_hwnd, hdc);
		}
	}
	return retCode;
}

#endif // NOLISTCOMBOBOXES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\callmgr.cpp ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	CALLMGR.CPP		CCallMgr implementation |
 *
 *	Purpose:  The call manager controls various aspects of
 *		a client call chain, including re-entrancy management,
 *		undo contexts, and change notifications.
 *
 *	Author:	<nl>
 *		alexgo 2/8/96
 *
 *	See the documentation in reimplem.doc for a detailed explanation
 *	of how all this stuff works.
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_m_undo.h"
#include "_callmgr.h"
#include "_select.h"
#include "_disp.h"
#include "_dxfrobj.h"

#ifndef NOPRIVATEMESSAGE
#include "_MSREMSG.H"
#endif

#define EN_CLIPFORMAT			0x0712
#define ENM_CLIPFORMAT			0x00000080

typedef struct _clipboardformat
{
	NMHDR nmhdr;
	CLIPFORMAT cf;
} CLIPBOARDFORMAT;


ASSERTDATA

/*
 *	CCallMgr::SetChangeEvent(fType)
 *
 *	@mfunc	informs the callmgr that some data in the document 
 *			changed.  The fType parameter describes the actual change
 */
void CCallMgr::SetChangeEvent(
	CHANGETYPE fType)		//@parm the type of change (e.g. text, etc)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetChangeEvent");

	// if another callmgr exists higher up the chain, then 
	// delegate the call to it
	if( _pPrevcallmgr )
	{
		Assert(_fChange == FALSE);
		Assert(_fTextChanged == FALSE);
		_pPrevcallmgr->SetChangeEvent(fType);
	}
	else
	{
		_fChange = TRUE;
		_ped->_fModified = TRUE;
		_ped->_fSaved = FALSE;
		_fTextChanged = !!(fType & CN_TEXTCHANGED);
	}
}

/*
 *	CCallmgr::ClearChangeEvent()
 *
 *	@mfunc	If a change happened, then clear the change event bit. 
 *			This allows callers to make changes to the edit control
 *			_without_ having a notifcation fire.  Sometimes, this
 *			is necessary for backwards compatibility.
 *
 *	@devnote	This is a very dangerous method to use.  If _fChange
 *			is set, it may represent more than 1 change; in other words,
 *			other changes than the one that should be ignored.  However,
 *			for all existing uses of this method, earlier changes are
 *			irrelevant.
 */
void CCallMgr::ClearChangeEvent()
{
	if( _pPrevcallmgr )
	{
		Assert(_fChange == FALSE);
		Assert(_fTextChanged == FALSE);
		_pPrevcallmgr->ClearChangeEvent();
	}
	else
	{
		_fChange = FALSE;
		_fTextChanged = FALSE;
		// caller is responsible for setting _fModifed
	}
}

/*
 *	CCallMgr::SetNewUndo()
 *
 *	@mfunc	Informs the notification code that a new undo action has
 *			been added to the undo stack
 */
void CCallMgr::SetNewUndo()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetNewUndo");

	// we should only ever do this once per call
//	It's assert during IME composition in Outlook.  (see bug #3883)
//  Removing the assert does not caused any side effect.
//	Assert(_fNewUndo == FALSE);


	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetNewUndo();
	}
	else
	{
		_fNewUndo = TRUE;
	}
}

/*
 *		
 *	CCallMgr::SetNewRedo ()
 *
 *	@mfunc	Informs the notification code that a new redo action has
 *			been added to the redo stack.
 */
void CCallMgr::SetNewRedo()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetNewRedo");

	// we should only ever do this once per call.
	// The following assert looks bogus as it is forced to occur when an undo is
	// called with a count greater than 1. Therefore, for now, I (a-rsail) am
	// commenting it out.
	// Assert(_fNewRedo == FALSE);

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetNewRedo();
	}
	else
	{
		_fNewRedo = TRUE;
	}
}

/*
 *	CCallMgr::SetMaxText()
 *
 *	@mfunc	Informs the notification code that the max text limit has
 *			been reached.
 */
 void CCallMgr::SetMaxText()
 {
     TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetMaxText");

	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fMaxText == 0);
		_pPrevcallmgr->SetMaxText();
	}
	else
	{
		_fMaxText = TRUE;
	}
}

/*
 *	CCallMgr::SetSelectionChanged()
 *
 *	@mfunc	Informs the notification code that the selection has
 *			changed
 */
void CCallMgr::SetSelectionChanged()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetSelectionChanged");

    AssertSz(_ped->DelayChangeNotification() ? _ped->Get10Mode() : 1, "Flag only should be set in 1.0 mode");        
    if (_ped->DelayChangeNotification())
        return;
	
	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fSelChanged == 0);
		_pPrevcallmgr->SetSelectionChanged();
	}
	else
	{
		_fSelChanged = TRUE;
	}
}

/*
 *	CCallMgr::SetOutOfMemory()
 *
 *	@mfunc	Informs the notification code that we were unable to allocate
 *			enough memory.
 */
void CCallMgr::SetOutOfMemory()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetOutOfMemory");

	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fOutOfMemory == 0);
		_pPrevcallmgr->SetOutOfMemory();
	}
	else
	{
		_fOutOfMemory = TRUE;
	}
}

/*
 *	CCallMgr::SetInProtected
 *
 *	@mfunc	Indicates that we are currently processing an EN_PROTECTED
 *			notification
 *
 *	@rdesc	void
 */
void CCallMgr::SetInProtected(BOOL flag)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetInProtected");

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetInProtected(flag);
	}
	else
	{
		_fInProtected = flag;
	}
}

/*
 *	CCallMgr:GetInProtected()
 *
 *	@mfunc	retrieves the InProtected flag, whether or not we are currently
 *			processing an EN_PROTECTED notification
 *
 *	@rdesc	TRUE if we're processing an EN_PROTECTED notification
 */
BOOL CCallMgr::GetInProtected()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::GetInProtected");

	if( _pPrevcallmgr )
	{
		return _pPrevcallmgr->GetInProtected();
	}
	else
	{
		return _fInProtected;
	}
}	

/*
 *	CCallMgr::RegisterComponent(pcomp, name)
 *
 *	@mfunc	Registers a subsystem component implementing IReEntrantComponent.
 *			This enables this call manager to inform those objects about
 *			relevant changes in our re-entrancy status.
 */
void CCallMgr::RegisterComponent(
	IReEntrantComponent *pcomp,	//@parm The component to register
	CompName name)				//@parm The name for the component
{
	pcomp->_idName = name;
	pcomp->_pnext = _pcomplist;
	_pcomplist = pcomp;
}

/*
 *	CCallMgr::RevokeComponent(pcomp)
 *
 *	@mfunc	Removes a subsystem component from the list of components.  The
 *			component must have been previously registered with _this_
 *			call context.
 */
void CCallMgr::RevokeComponent(
	IReEntrantComponent *pcomp)	//@parm The component to remove
{
	IReEntrantComponent *plist, **ppprev;
	plist = _pcomplist;
	ppprev = &_pcomplist;

	while( plist != NULL )
	{
		if( plist == pcomp )
		{
			*ppprev = plist->_pnext;
			break;
		}
		ppprev = &(plist->_pnext);
		plist = plist->_pnext;
	} 
}

/*
 *	CCallMgr::GetComponent(name)
 *
 *	@mfunc	Retrieves the earliest instance of a registered sub-component.
 *
 *	@rdesc	A pointer to the component, if one has been registered.  NULL
 *			otherwise.
 */
IReEntrantComponent *CCallMgr::GetComponent(
	CompName name)				//@parm the subsystem to look for
{
	IReEntrantComponent *plist = _pcomplist;

	while( plist != NULL )
	{
		if( plist->_idName == name )
		{
			return plist;
		}
		plist = plist->_pnext;
	}

	// hmm, didn't find anything.  Try contexts higher up, if we're
	// the top context, then just return NULL.

	if( _pPrevcallmgr )
	{
		return _pPrevcallmgr->GetComponent(name);
	}
	return NULL;
}

/*
 *	CCallMgr::CCallMgr(ped)
 *
 *	@mfunc	Constructor
 *
 *	@rdesc	void
 */
CCallMgr::CCallMgr(CTxtEdit *ped)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	// set everthing to NULL
	ZeroMemory(this, sizeof(CCallMgr));

	if(ped)								// If ped is NULL, a zombie has
	{									//  been entered
		_ped = ped;
		_pPrevcallmgr = ped->_pcallmgr;
		ped->_pcallmgr = this;
		NotifyEnterContext();

#ifndef NOPRIVATEMESSAGE
		if (!_pPrevcallmgr && _ped->_pMsgFilter && _ped->_pMsgCallBack)
				_ped->_pMsgCallBack->NotifyEvents(NE_ENTERTOPLEVELCALLMGR);
#endif
	}
}

/*
 *	CCallMgr::~CCallMgr()
 *
 *	@mfunc	Destructor.  If appropriate, we will fire any cached
 *			notifications and cause the edit object to be destroyed.
 *
 *	@rdesc	void
 */
CCallMgr::~CCallMgr()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	if(IsZombie())					// No reentrancy with Zombies
		return;

	if( _pPrevcallmgr )
	{
		// we don't allow these flags to be set in re-entrant call
		// states
		Assert(_fMaxText == FALSE);
		Assert(_fSelChanged == FALSE);
		Assert(_fTextChanged == FALSE);
		Assert(_fChange == FALSE);
		Assert(_fNewRedo == FALSE);
		Assert(_fNewUndo == FALSE);
		Assert(_fOutOfMemory == FALSE);

		// set the ped to the next level of the call state
		_ped->_pcallmgr = _pPrevcallmgr;
	
		return;
	}

	// we're the top level. Note that we explicity do not
	// have an overall guard for cases where we are re-entered
	// while firing these notifications.  This is necessary for
	// better 1.0 compatibility and for Forms^3, which wants
	// to 'guard' their implementation of ITextHost::TxNotify and
	// ignore any notifications that happen while they are 
	// processing our notifications.  Make sense?

	_ped->_pcallmgr = NULL;

	// Process our internal notifications
	if(_ped->_fUpdateSelection)
	{	
		CTxtSelection *psel = _ped->GetSel();

		_ped->_fUpdateSelection = FALSE;

		if(psel && !_ped->_pdp->IsFrozen() && !_fOutOfMemory )
		{
			// this may cause an out of memory, so set things
			// up for that
			CCallMgr callmgr(_ped);
			psel->Update(FALSE);
		}
	}

	// Now fire any external notifications that may be necessary
	if( _fChange || _fSelChanged || _fMaxText || _fOutOfMemory )
	{
		SendAllNotifications();
	}

	// finally, we should check to see if we should delete the 
	// CTxtEdit instance.

	if(!_ped->_fSelfDestruct)
	{
		if( _ped->_unk._cRefs == 0)
		{
			delete _ped;
		}
#ifndef NOPRIVATEMESSAGE
		else
		{
			if (_ped->_pMsgFilter && _ped->_pMsgCallBack)
			{
				DWORD	dwEvents = NE_EXITTOPLEVELCALLMGR;

				if (_fSelChanged)
					dwEvents |= NE_CALLMGRSELCHANGE;

				if (_fChange)
					dwEvents |= NE_CALLMGRCHANGE;

				_ped->_pMsgCallBack->NotifyEvents(dwEvents);
			}
		}
#endif
	}
}

//
//	PRIVATE methods
//

/*
 *	CCallMgr::SendAllNotifications()
 *
 *	@mfunc	sends notifications for any cached notification bits.
 */
void CCallMgr::SendAllNotifications()
{
	//if the ped has already destructed, we cant make calls though it
	if (_ped->_fSelfDestruct)
		return;
	
	ITextHost *phost = _ped->GetHost();
	CHANGENOTIFY	cn;

    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	//
	// COMPATIBILITY ISSUE: The ordering of these events _may_
	// be an issue.  I've attempted to preserve the ordering
	// that the original code would use, but we have ~many~ more
	// control paths, so it's difficult.
	//
	if(	_fMaxText )
	{			
		// Beep if we are to emulate the system edit control
		if (_ped->_fSystemEditBeep)
			_ped->Beep();
		phost->TxNotify(EN_MAXTEXT, NULL);
	}
	
	if( _fSelChanged )
	{ 		
		if( (_ped->_dwEventMask & ENM_SELCHANGE) && !(_ped->_fSuppressNotify))
		{
			CTxtSelection * const psel = _ped->GetSel();
			if(psel)
			{
				SELCHANGE selchg;
				ZeroMemory(&selchg, sizeof(SELCHANGE));
				psel->SetSelectionInfo(&selchg);
			
				if (_ped->Get10Mode())
				{
					selchg.chrg.cpMin = _ped->GetAcpFromCp(selchg.chrg.cpMin);
					selchg.chrg.cpMost = _ped->GetAcpFromCp(selchg.chrg.cpMost);
				}

				phost->TxNotify(EN_SELCHANGE, &selchg);
			}
		}
	}

	if( _fOutOfMemory && !_ped->GetOOMNotified())
	{
		_fNewUndo = 0;
		_fNewRedo = 0;
		_ped->ClearUndo(NULL);
		_ped->_pdp->InvalidateRecalc();
		_ped->SetOOMNotified(TRUE);
		phost->TxNotify(EN_ERRSPACE, NULL);
		_ped->SetOOMNotified(FALSE);

	}

	if( _fChange )
	{
		if( (_ped->_dwEventMask & ENM_CHANGE) && !(_ped->_fSuppressNotify))
		{
			cn.dwChangeType = 0;
			cn.pvCookieData = 0;
			
			if( _fNewUndo )
			{
				Assert(_ped->_pundo);
				cn.dwChangeType |= CN_NEWUNDO;
				cn.pvCookieData = _ped->_pundo->GetTopAECookie();

			}
			else if( _fNewRedo )
			{
				Assert(_ped->_predo);
				cn.dwChangeType |= CN_NEWREDO;
				cn.pvCookieData = _ped->_predo->GetTopAECookie();
			}

			if( _fTextChanged )
			{
				cn.dwChangeType |= CN_TEXTCHANGED;
			}
			_ped->_dwEventMask &= ~ENM_CHANGE;
			phost->TxNotify(EN_CHANGE, &cn);
			_ped->_dwEventMask |= ENM_CHANGE;
		}
	}
	if((_ped->_dwEventMask & ENM_CLIPFORMAT) && _ped->_ClipboardFormat)
	{
		CLIPBOARDFORMAT cf;
		ZeroMemory(&cf, sizeof(CLIPBOARDFORMAT));
		cf.cf = g_rgFETC[_ped->_ClipboardFormat - 1].cfFormat;
		_ped->_ClipboardFormat = 0;
		phost->TxNotify(EN_CLIPFORMAT, &cf);
	}

#if !defined(NOLINESERVICES) && !defined(NOCOMPLEXSCRIPTS)
	extern char *g_szMsgBox;
	if(g_szMsgBox)
	{
		CLock lock;
		if(g_szMsgBox)
		{
			MessageBoxA(NULL, g_szMsgBox, NULL, MB_ICONEXCLAMATION | MB_TASKMODAL | MB_SETFOREGROUND);
			FreePv((void *)g_szMsgBox);
			g_szMsgBox = NULL;
		}
	}
#endif
}

/*
 *	CCallMgr::NotifyEnterContext()
 *
 *	@mfunc	Notify any registered components that a new context
 *			has been entered.
 *
 */
void CCallMgr::NotifyEnterContext()
{
	IReEntrantComponent *pcomp = _pcomplist;

	while( pcomp )
	{
		pcomp->OnEnterContext();
		pcomp = pcomp->_pnext;
	}

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->NotifyEnterContext();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\cicclsid.c ===
//
//  !! WARNING WARNING WARNING !!
// 
//  THIS FILE WAS GENERATED BY CICCLSID.BAT.
//  THESE CLSIDS MUST BE SAME WITH *.RGS FILES UNDER UIM.
//


/* 529A9E6B-6587-4F23-AB9E-9C7D683E3C50 */
const CLSID CLSID_TF_ThreadMgr = { 
    0x529A9E6B,
    0x6587,
    0x4F23,
    {0xAB, 0x9E, 0x9C, 0x7D, 0x68, 0x3E, 0x3C, 0x50}
  };
/* EBB08C45-6C4A-4FDC-AE53-4EB8C4C7DB8E */
const CLSID CLSID_TF_LangBarMgr = { 
    0xEBB08C45,
    0x6C4A,
    0x4FDC,
    {0xAE, 0x53, 0x4E, 0xB8, 0xC4, 0xC7, 0xDB, 0x8E}
  };
/* 3CE74DE4-53D3-4D74-8B83-431B3828BA53 */
const CLSID CLSID_TF_DisplayAttributeMgr = { 
    0x3CE74DE4,
    0x53D3,
    0x4D74,
    {0x8B, 0x83, 0x43, 0x1B, 0x38, 0x28, 0xBA, 0x53}
  };
/* A4B544A1-438D-4B41-9325-869523E2D6C7 */
const CLSID CLSID_TF_CategoryMgr = { 
    0xA4B544A1,
    0x438D,
    0x4B41,
    {0x93, 0x25, 0x86, 0x95, 0x23, 0xE2, 0xD6, 0xC7}
  };
/* 33C53A50-F456-4884-B049-85FD643ECFED */
const CLSID CLSID_TF_InputProcessorProfiles = { 
    0x33C53A50,
    0xF456,
    0x4884,
    {0xB0, 0x49, 0x85, 0xFD, 0x64, 0x3E, 0xCF, 0xED}
  };
/* B9931692-A2B3-4FAB-BF33-9EC6F9FB96AC */
const CLSID CLSID_TF_LangBarItemMgr = { 
    0xB9931692,
    0xA2B3,
    0x4FAB,
    {0xBF, 0x33, 0x9E, 0xC6, 0xF9, 0xFB, 0x96, 0xAC}
  };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\cmsgflt.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	CMSGFLT.CPP	-- Text Message Implementation |
 *	
 *		Most everything to do with IME message handling.
 *
 *	Original Author: <nl>
 *		Hon Wah Chan
 *
 *	History: <nl>
 *		2/6/98  v-honwch
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

#ifndef NOFEPROCESSING

#ifndef NOPRIVATEMESSAGE
#include "_MSREMSG.H"
#endif	

#include "_array.h"
#include "msctf.h"
#include "textstor.h"
#include "msctfp.h"

#include "textserv.h"
#include "_cmsgflt.h"
#include "_ime.h"

#include "_cuim.h"
#include "imeapp.h"


#define MAX_RECONVERSION_SIZE 100
#define CONTROL(_ch) (_ch - 'A' + 1)

/*
 *	void CreateIMEMessageFilter(ITextMsgFilter **ppMsgFilter)
 *
 *	@func
 *		TextMsgFilter class factory.
 */       
void CreateIMEMessageFilter(ITextMsgFilter **ppMsgFilter)
{
	CTextMsgFilter *pNewFilter = new CTextMsgFilter;
	*ppMsgFilter = pNewFilter ? pNewFilter : NULL;
}

/*
 *	void CTextMsgFilter::~CTextMsgFilter
 *
 *	@mfunc
 *		CTextMsgFilter Destructor
 *			Release objects being used.
 *		
 */
CTextMsgFilter::~CTextMsgFilter ()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::~CTextMsgFilter");

	if (_nIMEMode)
	{
		SetIMESentenseMode(FALSE);
		_nIMEMode = 0;
	}

	if (_hIMCContext)
		ImmAssociateContext(_hwnd, _hIMCContext, _fUsingAIMM);	// Restore IME before exit

	if (_pMsgCallBack)
	{		
		delete _pMsgCallBack;
		_pMsgCallBack = NULL;
	}

	// Release various objects
	TurnOffUIM(FALSE);
	
	TurnOffAimm(FALSE);

	if (_pFilter)
		_pFilter->Release();
	
	if (_pTextSel)
		_pTextSel->Release();
	
	_pFilter = NULL;
	_pTextDoc = NULL;
	_pTextSel = NULL;
	_hwnd = NULL;
	_hIMCContext = NULL;
	FreePv(_pcrComp);
	_pcrComp = NULL;
}

/*
 *	STDMETHODIMP CTextMsgFilter::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		IUnknown QueryInterface support
 *
 *	@rdesc
 *		NOERROR if interface supported
 *
 */
STDMETHODIMP CTextMsgFilter::QueryInterface (REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IUnknown *)this;
	}
	else if( IsEqualIID(riid, IID_ITextMsgFilter) )
	{
		*ppv = (ITextMsgFilter *)this;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(ULONG) CTextMsgFilter::AddRef
 *
 *	@mfunc
 *		IUnknown AddRef support
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CTextMsgFilter::AddRef()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::AddRef");

	return ++_crefs;
}

/*
 *	STDMETHODIMP_(ULONG) CTextMsgFilter::Release()
 *
 *	@mfunc
 *		IUnknown Release support - delete object when reference count is 0
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CTextMsgFilter::Release()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	STDMETHODIMP_(HRESULT) CTextMsgFilter::AttachDocument(HWND, ITextDocument2)
 *
 *	@mfunc
 *		Attach message filter. Perform genral initialization
 *
 *	@rdesc
 *		NOERROR
 */
STDMETHODIMP_(HRESULT) CTextMsgFilter::AttachDocument( HWND hwnd, ITextDocument2 *pTextDoc, IUnknown *punk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::AttachDocument");

	// Cache the values for possible later use.
	// The TextDocument interface pointer is not AddRefed because it is a back pointer
	// and the lifetime of message filters is assumed to be nested inside text documents	
	_hwnd = hwnd;
	_pTextDoc = pTextDoc;
	_pTextService = (ITextServices *)punk;

	// Don't get selection until it is needed
	_pTextSel = NULL;

	_fUnicodeWindow = 0;	
	if (hwnd)
		_fUnicodeWindow = IsWindowUnicode(hwnd);

	_fUsingAIMM = 0; 

	_pTim = NULL;
	_pCUIM = NULL;	
	_fUsingUIM = 0;

	// Check if current keyboard is MSIME98 or later.
	CheckIMEType(NULL);

	// Initialize some member data
	_fHangulToHanja = FALSE;
	_fIMECancelComplete = FALSE;	
	_fIMEAlwaysNotify = FALSE;
	_hIMCContext = NULL;
	_pcrComp = NULL;
	_pMsgCallBack = NULL;

	_pTextDoc->GetFEFlags(&_lFEFlags);
	_fRE10Mode = (_lFEFlags & tomRE10Mode);

	_uSystemCodePage = GetACP();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(HRESULT) CTextMsgFilter::HandleMessage(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Main Message filter message loop handling
 *
 *	@rdesc
 *		S_OK		if we have handled the message
 *		S_FALSE		if we want the caller to process the message
 */
STDMETHODIMP_(HRESULT) CTextMsgFilter::HandleMessage( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::HandleMessage");

	HRESULT hr = S_FALSE;
	BOOL	bReleaseSelction = FALSE;
	HRESULT hResult;

	// Give other message filters a chance to handle message
	// Stop with the first guy that handles the message
	if (_pFilter)	 
		hr = _pFilter->HandleMessage(pmsg, pwparam, plparam, plres);

	if (hr == S_OK)
		return hr;

 	if (IsIMEComposition() || _pCUIM && _pCUIM->IsUIMTyping())
	{
		// During IME Composition, there are some messages we should
		// not handle.  Also, there are other messages we need to handle by
		// terminating the IME composition first.
		// For WM_KEYDOWN, this is handled inside edit.c OnTxKeyDown().
		switch( *pmsg )
		{
			case WM_COPY:
			case WM_CUT:
			case WM_DROPFILES:
			case EM_REDO:
			case EM_SETCHARFORMAT:			
			case WM_SETFONT:
				return S_OK;					// Just ignore these

			
			case EM_UNDO:
			case WM_UNDO:
				// just terminate and exist for undo cases
				CompleteUIMTyping(CIme::TERMINATE_NORMAL);
				return S_OK;

			case WM_SETTEXT:
			case WM_CLEAR:
			case EM_STREAMIN:
				// these messages are used to reset our state, so reset
				// IME as well
				CompleteUIMTyping(CIme::TERMINATE_FORCECANCEL);
				break;

			case EM_SETTEXTEX:
				if (!_fRE10Mode)			// Don't terminate if running in 10 mode			
					CompleteUIMTyping(CIme::TERMINATE_FORCECANCEL);
				break;

			case WM_SYSKEYDOWN:
				// Don't terminate IME composition on VK_PROCESSKEY (F10) since Japanese 
				// IME will process the F10 key
				if (*pwparam != VK_PROCESSKEY)
					CompleteUIMTyping(CIme::TERMINATE_NORMAL);	// otherwise we want to terminate the IME
				break;

			case WM_CHAR:
			case WM_UNICHAR:
				if (IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3 && !_fReceivedKeyDown)
					return S_OK;				// Ignore this during IME composition and we haven't seen 
												//	any keydown message,
												//	else fall thru to terminate composition
				_fReceivedKeyDown = 0;

			case EM_SETWORDBREAKPROC:
 			case WM_PASTE:
			case EM_PASTESPECIAL:					  			
 			case EM_SCROLL:
			case EM_SCROLLCARET:
 			case WM_VSCROLL:
			case WM_HSCROLL:
			case EM_SETREADONLY:
			case EM_SETPARAFORMAT:
			case WM_INPUTLANGCHANGEREQUEST:	
			case EM_REPLACESEL:
			case EM_STREAMOUT:
				CompleteUIMTyping(CIme::TERMINATE_NORMAL);
				break;

			case WM_KILLFOCUS:
				CompleteUIMTyping(CIme::TERMINATE_NORMAL, FALSE);
				break;

			case EM_SETSEL:
				if (IsIMEComposition())
					CompleteUIMTyping(CIme::TERMINATE_NORMAL);
				else
					return S_OK;					// Ignore this during Cicero typing

			case WM_KEYUP:
				_fReceivedKeyDown = 0;
				break;

			case WM_KEYDOWN:
				_fReceivedKeyDown = 1;
				if(GetKeyState(VK_CONTROL) & 0x8000)
				{	
					// During IME Composition, there are some key events we should
					// not handle.  Also, there are other key events we need to handle by
					// terminating the IME composition first.			
					switch((WORD) *pwparam)
					{
					case VK_TAB:
		   			case VK_CLEAR:
					case VK_NUMPAD5:
					case 'A':						// Ctrl-A => select all
					case 'C':						// Ctrl-C => copy
					case 'X':						// Ctrl-X => cut
					case 'Y':						// Ctrl-Y => redo
						return S_OK;				// Just ignore these

					case 'V':						// Ctrl-V => paste
					case 'Z':						// Ctrl-Z => undo	
						CompleteUIMTyping(CIme::TERMINATE_NORMAL);						
						if ((WORD) *pwparam == 'Z')	// Early exist for undo case
							return S_OK;
					}
				}
				else
				{
					switch((WORD) *pwparam)
					{					
					case VK_F16:
						return S_OK;				// Just ignore these
					
					case VK_BACK:
					case VK_INSERT:					// Ins			
					case VK_LEFT:					// Left arrow
					case VK_RIGHT:					// Right arrow
					case VK_UP:						// Up arrow
					case VK_DOWN:					// Down arrow
					case VK_HOME:					// Home
					case VK_END:					// End
					case VK_PRIOR:					// PgUp
					case VK_NEXT:					// PgDn
					case VK_DELETE:					// Del
					case CONTROL('J'):
					case VK_RETURN:
						CompleteUIMTyping(CIme::TERMINATE_NORMAL);
						break;
					}
				}
				break;

			default:
				// Only need to handle mouse related msgs during composition
				if (IN_RANGE(WM_MOUSEFIRST, *pmsg, WM_MBUTTONDBLCLK) || *pmsg == WM_SETCURSOR)
				{
					if (IsIMEComposition())
					{
						bReleaseSelction = GetTxSelection();
						if (_pTextSel)
							hr = IMEMouseCheck( *this, pmsg, pwparam, plparam, plres);
						goto Exit;
					}

					// Cicero composition
					if (_pCUIM->_fMosueSink)
					{
						bReleaseSelction = GetTxSelection();
						if (_pTextSel)
							hr = _pCUIM->MouseCheck(pmsg, pwparam, plparam, plres);
						goto Exit;
					}
					if (IN_RANGE(WM_LBUTTONDOWN, *pmsg, WM_MOUSELAST) && !(*pmsg == WM_LBUTTONUP || *pmsg == WM_RBUTTONUP || *pmsg == WM_MBUTTONUP))
						CompleteUIMTyping(CIme::TERMINATE_NORMAL);		// Terminate on Mouse down and double-click messages
				}
				break;
		}
	}

	// Get Fe Flags for ES_NOIME or ES_SELFIME setting
	_lFEFlags = 0;

	// ... Local mucking with msg, params, etc, ...
	switch ( *pmsg )
	{
		case WM_CHAR:
			hr = OnWMChar (pmsg, pwparam, plparam, plres);
			break;

		case WM_IME_CHAR:
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if ((_lFEFlags & ES_NOIME))
				hr = S_OK;
			else
				hr = OnWMIMEChar (pmsg, pwparam, plparam, plres);
			break;
		
		case WM_IME_STARTCOMPOSITION:
			_fReceivedKeyDown = 0;
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{				
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
					hr = StartCompositionGlue (*this);
			}
			break;

		case WM_IME_COMPOSITION:
			_fReceivedKeyDown = 0;
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			
			if ((_lFEFlags & ES_NOIME) && !IsIMEComposition())
				hr = S_OK;			
			else if (!(_lFEFlags & ES_SELFIME))
			{
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					hr = CompositionStringGlue ( *plparam, *this );
					// Turn off Result string bit to avoid WM_IME_CHAR message.
					*plparam &= ~GCS_RESULTSTR;
				}
			}

			if (_hwnd && IsIMEComposition() && _ime->IgnoreIMECharMsg())
			{
				_ime->AcceptIMECharMsg();
				if (fHaveAIMM)
					hr = CallAIMMDefaultWndProc(_hwnd, *pmsg, *pwparam, *plparam, plres);
				else
					*plres = ::DefWindowProc(_hwnd, *pmsg, *pwparam, *plparam);				

				hr = S_OK;
			}

			break;

		case WM_IME_ENDCOMPOSITION:
			_fReceivedKeyDown = 0;
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{			
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
					hr = EndCompositionGlue ( *this, FALSE );
			}
			break;

		case WM_IME_NOTIFY:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)			
					hr = IMENotifyGlue ( *pwparam, *plparam, *this );
			}
			break;

		case WM_IME_COMPOSITIONFULL:	// Level 2 comp string about to overflow.
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{
				IMECompositionFull ( *this );
			}
			hr = S_FALSE;
			break;

		case WM_KEYDOWN:
			if (*pwparam == VK_KANJI)
			{
				hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
				
				_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
				// for Korean, need to convert the next Korean Hangul character to Hanja
				if(CP_KOREAN == _uKeyBoardCodePage && !(_lFEFlags & (ES_SELFIME | ES_NOIME)))
				{
					bReleaseSelction = GetTxSelection();
					if (_pTextSel)
						hr = IMEHangeulToHanja ( *this );
				}
			}
			break;

		case WM_INPUTLANGCHANGE: 
			CheckIMEType((HKL)*plparam);
			if (_nIMEMode && GetFocus() == _hwnd)
				SetIMESentenseMode(TRUE, (HKL)*plparam);
			hr = S_FALSE;
			break;
			
		case WM_INPUTLANGCHANGEREQUEST:
			if (_nIMEMode && GetFocus() == _hwnd)
				SetIMESentenseMode(FALSE);
			break;

		case WM_KILLFOCUS:
			OnKillFocus();
			break;
		
		case WM_SETFOCUS:
			OnSetFocus();
			break;

		case EM_SETIMEOPTIONS:
			*plres = OnSetIMEOptions(*pwparam, *plparam);
			hr = S_OK;
			break;

		case EM_GETIMEOPTIONS:
			*plres = OnGetIMEOptions();
			hr = S_OK;
			break;

		case WM_IME_REQUEST:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{				
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
					if (*pwparam == IMR_RECONVERTSTRING || *pwparam == IMR_CONFIRMRECONVERTSTRING
						|| *pwparam == IMR_DOCUMENTFEED)			
						hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, _fUnicodeWindow);	
					else if (*pwparam == IMR_QUERYCHARPOSITION)
						hr = OnIMEQueryPos(pmsg, pwparam, plparam, plres, _fUnicodeWindow);
				}				
			}
			break;

		case EM_RECONVERSION:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{
				// Application initiates reconversion
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					if (!(IsIMEComposition() || _pCUIM && _pCUIM->IsUIMTyping()))
					{
						if (_pCUIM && _pCUIM->Reconverse() >= 0)
							break;

						if (_fMSIME && MSIMEReconvertRequestMsg)
							IMEMessage( *this, MSIMEReconvertRequestMsg, 0, (LPARAM)_hwnd, TRUE );				
						else
						{
							hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, TRUE);							
							*plres = 0;
						}
					}
				}
			}
			hr = S_OK;
			break;

		case EM_SETLANGOPTIONS:
			// Setup IME related setting.
			// hr is not S_OK so textserv could handle other language setting
			_fIMEAlwaysNotify = (*plparam & IMF_IMEALWAYSSENDNOTIFY) != 0;
			_fIMECancelComplete = (*plparam & IMF_IMECANCELCOMPLETE) != 0;
			*plres = 1;
			break;

		case EM_GETLANGOPTIONS:
			// Report IME related setting.
			// hr is not S_OK so textserv could fill in other language setting
			if ( _fIMECancelComplete ) 
				*plres |= IMF_IMECANCELCOMPLETE;
			if ( _fIMEAlwaysNotify )
				*plres |= IMF_IMEALWAYSSENDNOTIFY;
			break;

		case EM_GETIMECOMPMODE:
			// Get current IME level
			if (_pCUIM && _pCUIM->IsUIMTyping())
				*plres = ICM_CTF;
			else
				*plres = OnGetIMECompositionMode( *this );
			hr = S_OK;
			break;
		
		case EM_SETUIM:
			// This is RE private message equivalent to EM_SETEDITSTYLE
			if (!_fNoIme)							// Ignore if no IME
			{
				if (!_fUsingUIM && !_fUsingAIMM)	// Ignore if we already using something
				{
					if (*pwparam == SES_USEAIMM11 || *pwparam == SES_USEAIMM12)
					{
						if (!_fTurnOffAIMM)
						StartAimm(*pwparam == SES_USEAIMM12);
					}
					else if (!_fTurnOffUIM)			// Client doesn't want UIM?
						StartUIM();
				}
			}
						
			hr = S_OK;
			break;

		case EM_SETEDITSTYLE:
			if (*plparam & SES_USECTF)
			{
				if ((*pwparam & SES_USECTF))
				{
					if (!_fRE10Mode)
					{
						if (_fUsingAIMM)
							TurnOffAimm(TRUE);						
						
						// Turn on Cicero
						if (!_fUsingUIM)
							StartUIM();

						goto SKIP_AIMM;
					}
				}
				else
				{
					// Turn off Cicero
					_fTurnOffUIM = 1;					// Flag to ignore in EM_SETUIM
					if (_fUsingUIM)
						TurnOffUIM(TRUE);
				}
			}

			if ((*pwparam & SES_USEAIMM) && ((*plparam & SES_USEAIMM) || *plparam == 0))
			{
				if (_fUsingUIM)
						TurnOffUIM(TRUE);
					
				if (!_fUsingAIMM)
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					if (!(_lFEFlags & ES_NOIME))		// No IME style on?
						StartAimm(TRUE);
				}
			}
			else if ((*plparam & SES_USEAIMM))
			{
				_fTurnOffAIMM = 1;					// Flag to ignore in EM_SETUIM
				TurnOffAimm(TRUE);
			}

SKIP_AIMM:
			if ((*plparam == 0 || *plparam & SES_NOIME) && _hwnd)
			{
				if (*pwparam & SES_NOIME)
				{
					_fNoIme = 1;
					TurnOffUIM(TRUE);
					TurnOffAimm(TRUE);

					if (!_hIMCContext)
						_hIMCContext = ImmAssociateContext(_hwnd, NULL, _fUsingAIMM);	// turn off IME									
				}
				else if (*plparam & SES_NOIME)
				{
					_fNoIme = 0;
					if (_hIMCContext)
						ImmAssociateContext(_hwnd, _hIMCContext, _fUsingAIMM);			// turn on IME
					_hIMCContext = NULL;
				}
			}			

			if (*plparam & SES_CTFALLOWEMBED)
				_fAllowEmbedded = (*pwparam & SES_CTFALLOWEMBED) ? 1 : 0;

			if (*plparam & (SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING))
				HandleCTFService(*pwparam, *plparam);

			// remove settings that are handled.
			*pwparam &= ~(SES_NOIME | SES_USEAIMM | SES_USECTF | SES_CTFALLOWEMBED | SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING);
			*plparam &= ~(SES_NOIME | SES_USEAIMM | SES_USECTF | SES_CTFALLOWEMBED | SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING);

			// fall thru to return the edit style

		case EM_GETEDITSTYLE:
			if (_hIMCContext)
				*plres = SES_NOIME;			// IME has been turned off
			if (_fUsingAIMM)
				*plres |= SES_USEAIMM;		// AIMM is on
			if (_fUsingUIM)
				*plres |= SES_USECTF;		// Cicero is on

			// Cicero services
			if (_fAllowEmbedded)
				*plres |= SES_CTFALLOWEMBED;
			if (_fAllowSmartTag)
				*plres |= SES_CTFALLOWSMARTTAG;
			if (_fAllowProofing)
				*plres |= SES_CTFALLOWPROOFING;

			break;

		case EM_SETIMECOLOR:
			if (_fRE10Mode)
			{
				COMPCOLOR* pcrComp = GetIMECompAttributes();

				if (pcrComp)
				{
					memcpy(pcrComp, (const void *)(*plparam), sizeof(COMPCOLOR) * 4);
					*plres = 1;
				}
			}
			hr = S_OK;
			break;

		case EM_GETIMECOLOR:
			if (_fRE10Mode)
			{
				COMPCOLOR* pcrComp = GetIMECompAttributes();

				if (pcrComp)
				{
					memcpy((void *)(*plparam), pcrComp, sizeof(COMPCOLOR) * 4);
					*plres = 1;
				}
			}
			hr = S_OK;
			break;

		case EM_SETIMEMODEBIAS:
			OnSetIMEMode(*pwparam, *plparam);
				// following thru to return EM_GETIMEMODEBIAS
		case EM_GETIMEMODEBIAS:
			*plres = OnGetIMEMode();
			hr = S_OK;
			break;

		case EM_SETCTFMODEBIAS:
			OnSetUIMMode(*pwparam);
				// following thru to return EM_GETCTFMODEBIAS
		case EM_GETCTFMODEBIAS:
			*plres = OnGetUIMMode();
			hr = S_OK;
			break;

		case EM_SETCTFOPENSTATUS:
		case EM_GETCTFOPENSTATUS:
			*plres = 0;
			if (_pCUIM)
				*plres = _pCUIM->CTFOpenStatus(*pmsg == EM_GETCTFOPENSTATUS, *pwparam != 0);
			hr = S_OK;
			break;

		case EM_ISIME:
			*plres = CheckIMEType(NULL, 0);
			hr = S_OK;
			break;

		case EM_GETIMEPROPERTY:
			*plres = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), *pwparam, _fUsingAIMM);
			hr = S_OK;
			break;

		case EM_GETIMECOMPTEXT:
			*plres = OnGetIMECompText(*pwparam, *plparam);
			hr = S_OK;
			break;

		case WM_SIZE:
		case WM_MOVE:
			if (_pMsgCallBack)
				_pMsgCallBack->NotifyEvents(NE_LAYOUTCHANGE);
			break;

		case EM_GETOLEINTERFACE:
			if(*plparam && *pwparam == 0x0435446)		// 'CTF'
			{
				if (_pCUIM && _pCUIM->GetITfContext())
				{
					*(ITfContext **)(*plparam) = _pCUIM->GetITfContext();
					_pCUIM->GetITfContext()->AddRef();
				}
				else
					*(IUnknown **)(*plparam) = 0;
				
				*plres = TRUE;
				hr = S_OK;
			}
			break;

		default:
			if (*pmsg)
			{
				// Look for IME messages
				if (*pmsg == MSIMEReconvertMsg || *pmsg == MSIMEDocFeedMsg
					|| *pmsg == MSIMEQueryPositionMsg)
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
					{
						bReleaseSelction = GetTxSelection();
						if (_pTextSel)
						{
							if (*pmsg == MSIMEQueryPositionMsg)
								hr = OnIMEQueryPos(pmsg, pwparam, plparam, plres, TRUE);
							else
								hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, TRUE);
						}
					}
				}

				if (_pCUIM && _pCUIM->_fMosueSink && 
					(IN_RANGE(WM_MOUSEFIRST, *pmsg, WM_MBUTTONDBLCLK) || *pmsg == WM_SETCURSOR))
				{
					bReleaseSelction = GetTxSelection();

					if (_pTextSel)
						hr = _pCUIM->MouseCheck(pmsg, pwparam, plparam, plres);
				}
			}
			break;
	}

Exit:
	// Release Selection if we get it for this message
	if (bReleaseSelction && _pTextSel)
	{
		_pTextSel->Release();
		_pTextSel = NULL;
	}

	// Return the value that will cause message to be processed normally
	return hr;
}

/*
 *	HRESULT CTextMsgFilter::AttachMsgFilter(ITextMsgFilter *)
 *
 *	@mfunc
 *		Add another message filter to the chain
 *
 *	@rdesc
 *		NOERROR if added
 */
HRESULT STDMETHODCALLTYPE CTextMsgFilter::AttachMsgFilter( ITextMsgFilter *pMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::AttachMsgFilter");

	HRESULT hr = NOERROR;
	if (_pFilter)
		hr = _pFilter->AttachMsgFilter( pMsgFilter );
	else
	{
		_pFilter = pMsgFilter;
		_pFilter->AddRef();
	}
	return hr;
}

/*
 *	HRESULT CTextMsgFilter::OnWMChar(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle WM_CHAR message - look for Japanese keyboard with Kana key on
 *		Convert the SB Kana to Unicode if needed.
 *
 *	@rdesc
 *		S_FALSE so caller will handle the modified character in wparam
 */
HRESULT CTextMsgFilter::OnWMChar( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnWMChar");

	// For Japanese keyboard, if Kana mode is on,
	// Kana characters (single byte Japanese chars) are coming in via WM_CHAR.
	if ( GetKeyState(VK_KANA) & 0x1 )
	{
		_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);

		if (_uKeyBoardCodePage == CP_JAPAN)
		{
			// check if this is a single byte character.
 			TCHAR	unicodeConvert;
			BYTE	bytes[2];
			bytes[0] = (BYTE)(*pwparam >> 8);	// Interchange DBCS bytes in endian
			bytes[1] = (BYTE)*pwparam;			// independent fashion (use byte array)

			if (!bytes[0])
			{
				if(UnicodeFromMbcs((LPWSTR)&unicodeConvert, 1, 
					(LPCSTR)&bytes[1], 1, _uKeyBoardCodePage) == 1)
					*pwparam = unicodeConvert;
			}
			
			return InputFEChar(*pwparam);
		}
	}

	return S_FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnWMIMEChar(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle WM_IMECHAR message - convert the character to unicode.
 *
 *	@rdesc
 *		S_OK - caller to ignore the message
 *		S_FALSE - caller to handle the message.  wparam may contains a new char
 */
HRESULT CTextMsgFilter::OnWMIMEChar( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnWMIMEChar");

	TCHAR	unicodeConvert;
	BYTE	bytes[2];

	// We may receive IMECHAR even if we have handled the composition char already.
	// This is the case when the host does not call the DefWinProc with the composition
	// bit masked off.  So, we need to ignore this message to avoid double entry.
	if (IsIMEComposition() && _ime->IgnoreIMECharMsg())
	{
		_ime->SkipIMECharMsg();		// Skip this ime char msg
		return S_OK;	
	}

	if (_fUnicodeWindow && !W32->OnWin9x())
		return S_FALSE;

	bytes[0] = *pwparam >> 8;		// Interchange DBCS bytes in endian
	bytes[1] = *pwparam;			// independent fashion (use byte array)
	
	// need to convert both single-byte KANA and DBC
	if (!bytes[0] || GetTrailBytesCount(bytes[0], _uKeyBoardCodePage))
	{
		if( UnicodeFromMbcs((LPWSTR)&unicodeConvert, 1, 
			bytes[0] == 0 ? (LPCSTR)&bytes[1] : (LPCSTR)bytes,
			bytes[0] == 0 ? 1 : 2,
			_uKeyBoardCodePage) == 1 )
			*pwparam = unicodeConvert;

		return InputFEChar(*pwparam);
	}

	return S_FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnIMEReconvert(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle IME Reconversion and Document feed. We only handle Unicode messages.
 *		We use a limit of MAX_RECONVERSION_SIZE(100) characters in both cases.
 *
 *	@rdesc
 *		S_OK		if we have handled the message
 */
HRESULT CTextMsgFilter::OnIMEReconvert( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres,
		BOOL		fUnicode)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnIMEReconvert");

	HRESULT		hr = S_OK;
	LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)(*plparam);
	long		cbStringSize;
	long		cpMin, cpMax;
	long		cpParaStart, cpParaEnd;
	HRESULT		hResult;
	ITextRange *pTextRange, *pTempTextRange;
	long		cbAdded;				
	BOOL		bDocumentFeed;
	long		cLastChar;
	BOOL		fAdjustedRange = FALSE;

	*plres = 0;

	// NT doesn't support Ansi window when the CP_ACP isn't the same
	// as keyboard codepage.
	if (!fUnicode && !(W32->OnWin9x()) && _uKeyBoardCodePage != _uSystemCodePage)
		return S_OK;

	bDocumentFeed = (MSIMEDocFeedMsg && *pmsg == MSIMEDocFeedMsg)
					|| (*pmsg == WM_IME_REQUEST && *pwparam == IMR_DOCUMENTFEED);

	if (bDocumentFeed && IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3)
	{
		// Composition in progress, use composition string as selection
		cpMin = ((CIme_Lev3 *)_ime)->GetIMECompositionStart();
		cpMax = ((CIme_Lev3 *)_ime)->GetIMECompositionLen() + cpMin;
	}
	else
	{
		// Get current selection
		hResult	= _pTextSel->GetStart(&cpMin);
		hResult	= _pTextSel->GetEnd(&cpMax);
	}

	// Expand to include the current paragraph
	hResult = _pTextDoc->Range(cpMin, cpMax, &pTextRange);
	Assert (pTextRange != NULL);
	if (hResult != NOERROR)
		return S_OK;

	hResult = pTextRange->Expand(tomParagraph, &cbAdded);

	// Fail to get Paragraph, get the story
	// Note:- Expand will return S_FALSE for plain text when
	// the whole story is selected
	if (hResult != NOERROR)		
		hResult = pTextRange->Expand(tomStory, &cbAdded);

	hResult = pTextRange->GetStart(&cpParaStart);
	hResult = pTextRange->GetEnd(&cpParaEnd);

	if (*pwparam == IMR_CONFIRMRECONVERTSTRING)
	{
		*plres = CheckIMEChange(lpRCS, cpParaStart, cpParaEnd, cpMin, cpMax, fUnicode);		
		goto Exit;
	}
		
	// Initialize to hugh number
	_cpReconvertStart = tomForward;

	// Check if Par included	
	hResult = _pTextDoc->Range(cpParaEnd-1, cpParaEnd, &pTempTextRange);
	if (hResult != NOERROR)
		goto Exit;
	Assert (pTempTextRange != NULL);

	hResult	= pTempTextRange->GetChar(&cLastChar);
	pTempTextRange->Release();

	if (hResult == NOERROR && (WCHAR)cLastChar == CR)
	{
		if (cpMax == cpParaEnd)
		{								
			// Par is selected, change selection to exclude the par char
			cpMax--;
			_pTextSel->SetEnd(cpMax);

			if (cpMin > cpMax)
			{
				// Adjust cpMin as well
				cpMin = cpMax;
				_pTextSel->SetStart(cpMin);
			}
		}

		// Get rid of par char 
		cpParaEnd--;
		fAdjustedRange = TRUE;
	}

	// Check for MAX_RECONVERSION_SIZE since we don't want to pass a hugh buffer
	// to IME
	long	cchSelected;

	cchSelected = cpMax - cpMin;
	if (cpParaEnd - cpParaStart > MAX_RECONVERSION_SIZE)
	{
		// Too many character selected, forget it
		if (cchSelected > MAX_RECONVERSION_SIZE)
			goto Exit;

		if (cchSelected == MAX_RECONVERSION_SIZE)
		{
			// Selection reaches the limit
			cpParaStart = cpMin;
			cpParaEnd = cpMax;
		}
		else
		{
			long	cchBeforeSelection = cpMin - cpParaStart;
			long	cchAfterSelection = cpParaEnd - cpMax;
			long	cchNeeded = MAX_RECONVERSION_SIZE - cchSelected;
			
			if (cchBeforeSelection < cchNeeded/2)
			{
				// Put in all characters from the Par start
				// and move Par end
				cpParaEnd = cpParaStart + MAX_RECONVERSION_SIZE - 1;
			}
			else if (cchAfterSelection < cchNeeded/2)
			{
				// Put in all character to the Par end
				// and move Par start
				cpParaStart = cpParaEnd - MAX_RECONVERSION_SIZE + 1;

			}
			else
			{
				// Adjust both end
				cpParaStart = cpMin - cchNeeded/2;
				cpParaEnd = cpParaStart + MAX_RECONVERSION_SIZE - 1;
			}
		}
		fAdjustedRange = TRUE;
	}

	if (fAdjustedRange)
	{
		// Adjust the text range
		hResult	= pTextRange->SetRange(cpParaStart, cpParaEnd);
		
		if (hResult != NOERROR)
			goto Exit;
	}

	cbStringSize = (cpParaEnd - cpParaStart) * 2;

	// No char in current par, forget it.
	if (cbStringSize <= 0)
		goto Exit;

	if (EM_RECONVERSION == *pmsg)
	{
		// RE reconversion msg, allocate the Reconversion buffer
		lpRCS = (LPRECONVERTSTRING) PvAlloc(sizeof(RECONVERTSTRING) + cbStringSize + 2, GMEM_ZEROINIT);
		Assert(lpRCS != NULL);

		if (lpRCS)
			lpRCS->dwSize = sizeof(RECONVERTSTRING) + cbStringSize + 2;
	}

	if (lpRCS)
	{
		BSTR		bstr = NULL;
		LPSTR		lpReconvertBuff;

		hResult = pTextRange->GetText(&bstr);

		if (hResult != NOERROR || bstr == NULL)
		{
			if (EM_RECONVERSION == *pmsg)
				FreePv(lpRCS);
			goto Exit;						// forget it		
		}
		
		if (lpRCS->dwSize - sizeof(RECONVERTSTRING) - 2 < (DWORD)cbStringSize)
			cbStringSize = lpRCS->dwSize - sizeof(RECONVERTSTRING) - 2;
		
		lpReconvertBuff = (LPSTR)(lpRCS) + sizeof(RECONVERTSTRING);

		if (fUnicode)
		{
			// fill in the buffer
			memcpy(lpReconvertBuff, (LPSTR)bstr, cbStringSize);

			*(lpReconvertBuff+cbStringSize) = '\0';
			*(lpReconvertBuff+cbStringSize+1) = '\0';
			
			lpRCS->dwStrLen = (cpParaEnd - cpParaStart);					
			lpRCS->dwCompStrLen = (cpMax - cpMin);
			lpRCS->dwCompStrOffset = (cpMin - cpParaStart)*2;	// byte offset from beginning of string
		}
		else
		{
			// Ansi case, need to find byte offset and Ansi string
			long	cch = WideCharToMultiByte(_uKeyBoardCodePage, 0, bstr, -1, lpReconvertBuff, cbStringSize+1, NULL, NULL);
			Assert (cch > 0);
			if (cch > 0)
			{
				CTempCharBuf tcb;
				char *psz = tcb.GetBuf(cch);

				if (!psz)			// No memory
					goto CleanUp;	//	forget it.

				if (cch > 1 && lpReconvertBuff[cch-1] == '\0')
					cch--;			// Get rid of the null char

				int cpOffset = cpMin - cpParaStart;

				Assert(cpOffset >= 0);
				lpRCS->dwStrLen = cch;
				lpRCS->dwCompStrOffset = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
					bstr, cpOffset, psz, cch, NULL, NULL);

				lpRCS->dwCompStrLen = 0;
				if (cpMax > cpMin)				
					lpRCS->dwCompStrLen = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
						bstr+cpOffset, cpMax - cpMin, psz, cch, NULL, NULL);				
			}
			else
			{
CleanUp:
				SysFreeString (bstr);
				if (EM_RECONVERSION == *pmsg)
					FreePv(lpRCS);
				goto Exit;						// forget it
			}
		}

		// Fill in the rest of the RCS struct
		lpRCS->dwVersion = 0;		
		lpRCS->dwStrOffset = sizeof(RECONVERTSTRING);		// byte offset from beginning of struct		
		lpRCS->dwTargetStrLen = lpRCS->dwCompStrLen;
		lpRCS->dwTargetStrOffset = lpRCS->dwCompStrOffset;
		
		*plres = sizeof(RECONVERTSTRING) + cbStringSize + 2;

		// Save this for the CONFIRMRECONVERTSTRING handling
		_cpReconvertStart = cpParaStart;
		_cpReconvertEnd = cpParaEnd;
		
		SysFreeString (bstr);

		if (EM_RECONVERSION == *pmsg)
		{
			HIMC	hIMC = LocalGetImmContext(*this);

			if (hIMC)
			{
				DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_SETCOMPSTR, _fUsingAIMM);

				if ((imeProperties & (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
					== (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
				{
					if (ImmSetCompositionStringW(hIMC, SCS_QUERYRECONVERTSTRING, lpRCS, *plres, NULL, 0, _fUsingAIMM))
					{
						// Check if there is any change in selection
						CheckIMEChange(lpRCS, cpParaStart, cpParaEnd, cpMin, cpMax, TRUE);
						ImmSetCompositionStringW(hIMC, SCS_SETRECONVERTSTRING, lpRCS, *plres, NULL, 0, _fUsingAIMM);
					}
				}
				LocalReleaseImmContext(*this, hIMC);
			}

			FreePv(lpRCS);
		}
	}
	else
	{
		// return size for IME to allocate the buffer
		*plres = sizeof(RECONVERTSTRING) + cbStringSize + 2;	
	}

Exit:
	pTextRange->Release();

	return hr;
}

/* 
 *  BOOL  CTextMsgFilter::CheckIMEChange(LPRECONVERTSTRING,long,long,long,long)
 *
 *	@mfunc
 *	 	Verify if IME wants to re-adjust the selection
 *
 *	@rdesc
 *		TRUE - allow IME to change the selection
 */
BOOL  CTextMsgFilter::CheckIMEChange(
	LPRECONVERTSTRING	lpRCS,
	long				cpParaStart, 
	long				cpParaEnd,
	long				cpMin,
	long				cpMax,
	BOOL				fUnicode)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::CheckIMEChange");

	long		cpImeSelectStart = 0;
	long		cpImeSelectEnd = 0;
	HRESULT		hResult;	

	if (!lpRCS || _cpReconvertStart == tomForward)
		// Never initialize, forget it
		return FALSE;

	if (fUnicode)
	{
		cpImeSelectStart = _cpReconvertStart + lpRCS->dwCompStrOffset / 2;
		cpImeSelectEnd = cpImeSelectStart + lpRCS->dwCompStrLen;
	}
	else
	{
		// Need to convert the byte offset to char offset.
		ITextRange *pTextRange;
		BSTR		bstr = NULL;

		hResult = _pTextDoc->Range(_cpReconvertStart, _cpReconvertEnd, &pTextRange);
		if (hResult != NOERROR)
			return FALSE;
				
		// Get the text
		hResult = pTextRange->GetText(&bstr);

		if (hResult == S_OK)
		{
			long	cchReconvert = _cpReconvertEnd - _cpReconvertStart + 1;
			CTempCharBuf tcb;
			char *psz = tcb.GetBuf((cchReconvert)*2);

			hResult = S_FALSE;
			if (psz)
			{
				long cch = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
					bstr, -1, psz, (cchReconvert)*2, NULL, NULL);

				if (cch > 0)
				{
					long dwCompStrOffset, dwCompStrLen;
					CTempWcharBuf	twcb;
					WCHAR			*pwsz = twcb.GetBuf(cchReconvert);

					if (pwsz)
					{
						dwCompStrOffset = MultiByteToWideChar(_uKeyBoardCodePage, 0, 
							psz, lpRCS->dwCompStrOffset, pwsz, cchReconvert);

						dwCompStrLen = MultiByteToWideChar(_uKeyBoardCodePage, 0, 
							psz+lpRCS->dwCompStrOffset, lpRCS->dwCompStrLen, pwsz, cchReconvert);

						Assert(dwCompStrOffset > 0 || dwCompStrLen > 0);

						cpImeSelectStart = _cpReconvertStart + dwCompStrOffset;
						cpImeSelectEnd = cpImeSelectStart + dwCompStrLen;
						hResult = S_OK;
					}
				}
			}
		}

		if (bstr)
			SysFreeString (bstr);
			
		pTextRange->Release();

		if (hResult != S_OK)
			return FALSE;
	}

	if (cpParaStart <= cpImeSelectStart && cpImeSelectEnd <= cpParaEnd)
	{
		if (_pTextSel && (cpImeSelectStart != cpMin || cpImeSelectEnd != cpMax))
		{
			// IME changes selection.
			hResult	= _pTextSel->SetRange(cpImeSelectStart, cpImeSelectEnd);

			if (hResult != NOERROR)
				return FALSE;
		}
		return TRUE;		// Allow Ime to change selection
	}

	return FALSE;
}

/* 
 *  BOOL  CTextMsgFilter::GetTxSelection()
 *
 *	@mfunc
 *	 	Get Selection if we haven't got it before
 *
 *	@rdesc
 *		TRUE if this is first time getting the selection
 *		FALSE if it is already exist or no selection available.
 */
BOOL  CTextMsgFilter::GetTxSelection()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::GetTxSelection");

	HRESULT hResult;

	if (_pTextSel)
		return FALSE;					// Already there

	hResult = _pTextDoc->GetSelectionEx(&_pTextSel);

	return _pTextSel ? TRUE : FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnIMEQueryPos(UINT *, WPARAM *, LPARAM *, LRESULT *, BOOL)
 *
 *	@mfunc
 *		Fill in the current character size and window rect. size.  
 *
 *	@rdesc
 *		S_OK
 *		*plres = 0 if we do not filled in data
 */
HRESULT CTextMsgFilter::OnIMEQueryPos( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres,
		BOOL		fUnicode)		
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnIMEQueryPos");

	HRESULT				hResult;
	PIMECHARPOSITION	pIMECharPos = (PIMECHARPOSITION)*plparam;
	long				cpRequest;
	RECT				rcArea;
	ITextRange			*pTextRange = NULL;
	POINT				ptTopPos, ptBottomPos = {0, 0};
	bool				fGetBottomPosFail = false;

	if (pIMECharPos->dwSize != sizeof(IMECHARPOSITION))
		goto Exit;

	// NT doesn't support Ansi window when the CP_ACP isn't the same
	// as keyboard codepage.
	if (!fUnicode && !(W32->OnWin9x()) && _uKeyBoardCodePage != _uSystemCodePage)
		goto Exit;

	if (IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3)
	{
		cpRequest = ((CIme_Lev3 *)_ime)->GetIMECompositionStart();
		if (fUnicode)
			cpRequest += pIMECharPos->dwCharPos;
		else if (pIMECharPos->dwCharPos > 0)
		{
			// Need to convert pIMECharPos->dwCharPos from Acp to Cp
			long	cchComp = ((CIme_Lev3 *)_ime)->GetIMECompositionLen();
			long	cchAcp = (long)(pIMECharPos->dwCharPos);
			BSTR	bstr;
			WCHAR	*pChar;

			if (cchComp)
			{
				hResult = _pTextDoc->Range(cpRequest, cpRequest+cchComp, &pTextRange);
				
				Assert (pTextRange != NULL);				
				if (hResult != NOERROR || !pTextRange)
					goto Exit;
				
				hResult = pTextRange->GetText(&bstr);
				if (hResult != NOERROR )
					goto Exit;

				// The algorithm assumes that for a DBCS charset any character
				// above 128 has two bytes, except for the halfwidth KataKana,
				// which are single bytes in ShiftJis.
				pChar = (WCHAR *)bstr;
				Assert (pChar);

				while (cchAcp > 0 && cchComp > 0)
				{
					cchAcp--;
					if(*pChar >= 128 && (CP_JAPAN != _uKeyBoardCodePage ||
						!IN_RANGE(0xFF61, *pChar, 0xFF9F)))
						cchAcp--;

					pChar++;
					cchComp--;
					cpRequest++;
				}

				SysFreeString (bstr);
				pTextRange->Release();
				pTextRange = NULL;
			}
		}
	}
	else if (pIMECharPos->dwCharPos == 0)
	{
		// Get current selection
		hResult	= _pTextSel->GetStart(&cpRequest);
		if (hResult != NOERROR)
			goto Exit;
	}
	else
		goto Exit;

	// Get requested cp location in screen coordinates
	hResult = _pTextDoc->Range(cpRequest, cpRequest+1, &pTextRange);
	Assert (pTextRange != NULL);	
	if (hResult != NOERROR || !pTextRange)
		goto Exit;

	long lTextFlow;	
	long lTopType;
	long lBottomType;

	lTextFlow = _lFEFlags & tomTextFlowMask;	
	lTopType = tomStart+TA_TOP+TA_LEFT;
	lBottomType = tomStart+TA_BOTTOM+TA_LEFT;
	
	if (lTextFlow == tomTextFlowWN)
	{
		lTopType = tomStart+TA_TOP+TA_RIGHT;
		lBottomType = tomStart+TA_BOTTOM+TA_RIGHT	;
	}

	hResult = pTextRange->GetPoint( lTopType,
			&(ptTopPos.x), &(ptTopPos.y) );

	if (hResult != NOERROR)
	{
		// Scroll and try again
		hResult = pTextRange->ScrollIntoView(tomStart);
		if (hResult == NOERROR)
			hResult = pTextRange->GetPoint( lTopType,
				&(ptTopPos.x), &(ptTopPos.y) );
	}

	if (hResult == NOERROR)
	{
		hResult = pTextRange->GetPoint( lBottomType,
				&(ptBottomPos.x), &(ptBottomPos.y) );
		if (hResult != NOERROR)
			fGetBottomPosFail = true;
	}

	pIMECharPos->pt = ptTopPos;

	// Get application rect in screen coordinates
	hResult = _pTextDoc->GetClientRect(tomIncludeInset,
				&(rcArea.left), &(rcArea.top),
				&(rcArea.right), &(rcArea.bottom));	

	if (hResult != NOERROR)
		goto Exit;

	// Get line height in pixel
	if (fGetBottomPosFail)
		pIMECharPos->cLineHeight = rcArea.bottom - ptTopPos.y;
	else
	{
		if (lTextFlow == tomTextFlowSW || lTextFlow == tomTextFlowNE)
			pIMECharPos->cLineHeight = abs(ptTopPos.x - ptBottomPos.x);			
		else
			pIMECharPos->cLineHeight = abs(ptBottomPos.y - ptTopPos.y);

		if (lTextFlow == tomTextFlowWN)
			pIMECharPos->pt = ptBottomPos;
	}

	pIMECharPos->rcDocument = rcArea;

	*plres = TRUE;

Exit:
	if (pTextRange)
		pTextRange->Release();

	return S_OK;
}

/*
 *	CTextMsgFilter::CheckIMEType(HKL hKL, DWORD dwFlags)
 *
 *	@mfunc
 *		Check for FE IME keyboard and/or MSIME98 or later
 *
 *	@rdesc
 *		TRUE if FE IME keyboard
 */
BOOL CTextMsgFilter::CheckIMEType(
	HKL		hKL,
	DWORD	dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::CheckIMEType");

	BOOL	fFEKeyboard = FALSE;
	
	if (!hKL)
		hKL = GetKeyboardLayout(0x0FFFFFFFF);				// Get default HKL if caller pass in NULL

	// initialize to non MS IME
	if (dwFlags & CHECK_IME_SERVICE)		// Check MSIME98?
		_fMSIME	= 0;

	if (IsFELCID((WORD)hKL) && ImmIsIME(hKL, _fUsingAIMM))
	{
		fFEKeyboard = TRUE;

		if (dwFlags & CHECK_IME_SERVICE)		// Check MSIME98?
		{
			if (MSIMEServiceMsg && IMEMessage( *this, MSIMEServiceMsg, 0, 0, FALSE ))
				_fMSIME = 1;
		}
	}
	return fFEKeyboard;
}

/*
 *	CTextMsgFilter::InputFEChar(WCHAR	wchFEChar)
 *
 *	@mfunc
 *		Input the FE character and ensure we have a correct font.
 *
 *	@rdesc
 *		S_OK if handled
 */
HRESULT CTextMsgFilter::InputFEChar(
	WCHAR	wchFEChar)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::InputFEChar");

	BOOL	bReleaseSelction = GetTxSelection();
	long	cchExced;
	HRESULT	hr = S_FALSE;
	
	if (wchFEChar > 256 
		&& _pTextSel->CanEdit(NULL) == NOERROR
		&& _pTextDoc->CheckTextLimit(1, &cchExced) == NOERROR
		&& cchExced == 0)
	{
		// setup FE font to handle the FE character
		long		cpMin, cpMax;
		TCHAR		wchFE[2];
		BOOL		fSelect = FALSE;
		ITextRange	*pTextRange = NULL;
		ITextFont	*pTextFont = NULL;
		ITextFont	*pFEFont = NULL;
		HRESULT		hResult = S_FALSE;
		BSTR		bstr = NULL;

		// Inform client IME compostion is on to by-pass some font setting
		// problem in Arabic systems
		_pTextDoc->IMEInProgress(tomTrue);

		wchFE[0] = wchFEChar;
		wchFE[1] = L'\0';				
		
		_pTextSel->GetStart(&cpMin);
		_pTextSel->GetEnd(&cpMax);
		
		// For selection case, we want font to the right of first character
		if (cpMin != cpMax)
		{
			hResult = _pTextDoc->Range(cpMin, cpMin, &pTextRange);
			if (hResult != S_OK)
				goto ERROR_EXIT;

			hResult = pTextRange->GetFont(&pTextFont);

			cpMin++;
			fSelect = TRUE;
		}
		else
			hResult = _pTextSel->GetFont(&pTextFont);

		// Get a duplicate font and setup the correct FE font
		hResult = pTextFont->GetDuplicate(&pFEFont);

		if (hResult != S_OK)
			goto ERROR_EXIT;				

		CIme::CheckKeyboardFontMatching (cpMin, this, pFEFont);
		
		if (fSelect)
			_pTextSel->SetText(NULL);		// Delete the selection

		bstr = SysAllocString(wchFE);
		if (!bstr)
		{
			hResult = E_OUTOFMEMORY;
			goto ERROR_EXIT;				
		}

		_pTextSel->SetFont(pFEFont);		// Setup FE font
		_pTextSel->TypeText(bstr);			// Input the new FE character
					
ERROR_EXIT:
		if (hResult == S_OK)
			hr = S_OK;

		if (pFEFont)
			pFEFont->Release();

		if (pTextFont)
			pTextFont->Release();

		if (pTextRange)
			pTextRange->Release();

		if (bstr)
			SysFreeString(bstr);

		// Inform client IME compostion is done
		_pTextDoc->IMEInProgress(tomFalse);
	}


	if (bReleaseSelction && _pTextSel)
	{
		_pTextSel->Release();
		_pTextSel = NULL;
	}

	return hr;
}

/*
 *	CTextMsgFilter::OnSetFocus()
 *
 *	@mfunc
 *		Restore the previous keyboard if we are in FORCEREMEMBER mode.  
 *		Otherwise, setup the FE keyboard.
 *		
 */
void CTextMsgFilter::OnSetFocus()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnSetFocus");

	if (_fUsingUIM && _pCUIM)
	{
		_pCUIM->OnSetFocus();
	}
	else if (_fForceRemember && _fIMEHKL)
	{
		// Restore previous keyboard
		ActivateKeyboardLayout(_fIMEHKL, 0);
		if (IsFELCID((WORD)_fIMEHKL))
		{
			// Set Open status and Conversion mode
			HIMC	hIMC = LocalGetImmContext(*this);
			if (hIMC)
			{
				if (ImmSetOpenStatus(hIMC, _fIMEEnable, _fUsingAIMM) && _fIMEEnable)
					ImmSetConversionStatus(hIMC, _fIMEConversion, _fIMESentence, _fUsingAIMM); // Set conversion status

				LocalReleaseImmContext(*this, hIMC);
			}			
		}
	}
	else
		SetupIMEOptions();

	if (_nIMEMode)
		SetIMESentenseMode(TRUE);
}

/*
 *	CTextMsgFilter::OnKillFocus()
 *
 *	@mfunc
 *		If we are in FORCE_REMEMBER mode, save the current keyboard
 *	and conversion setting.
 *		
 */
void CTextMsgFilter::OnKillFocus()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnKillFocus");

	// Windowless mode, need to inform Cicero
	if (!_hwnd && _fUsingUIM && _pCUIM)
		_pCUIM->OnSetFocus(FALSE);

	if (_fForceRemember)
	{
		// Get current keyboard
		_fIMEHKL = GetKeyboardLayout(0x0FFFFFFFF);

		if (IsFELCID((WORD)_fIMEHKL))
		{
			// Get Open status
			HIMC	hIMC = LocalGetImmContext(*this);
			if (hIMC)
			{
				_fIMEEnable = ImmGetOpenStatus(hIMC, _fUsingAIMM);

				if (_fIMEEnable)					
					ImmGetConversionStatus(hIMC, &_fIMEConversion, &_fIMESentence, _fUsingAIMM); // get conversion status

				LocalReleaseImmContext(*this, hIMC);
			}			
		}
	}
	if (_nIMEMode)
		SetIMESentenseMode(FALSE);
}

/*
 *	CTextMsgFilter::OnSetIMEOptions(WPARAM wparam, LPARAM lparam)
 *
 *	@mfunc
 *	
 *	@rdesc
 */
LRESULT CTextMsgFilter::OnSetIMEOptions(
	WPARAM	wparam,
	LPARAM	lparam)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnSetIMEOptions");

	LRESULT lIMEOptionCurrent = OnGetIMEOptions();
	LRESULT lIMEOptionNew = 0;

	// Mask off bits that we will support for now
	lparam &= (IMF_FORCEACTIVE | IMF_FORCEENABLE | IMF_FORCEREMEMBER);

	switch(wparam)
	{
	case ECOOP_SET:
		lIMEOptionNew = lparam;
		break;

	case ECOOP_OR:
		lIMEOptionNew = lIMEOptionCurrent | lparam;
		break;

	case ECOOP_AND:
		lIMEOptionNew = lIMEOptionCurrent & lparam;
		break;

	case ECOOP_XOR:
		lIMEOptionNew = lIMEOptionCurrent ^ lparam;
		break;

	default:
		return 0;		// Bad option
	}

	if (lIMEOptionNew == lIMEOptionCurrent)			// Nothing change
		return 1;

	_fForceActivate = FALSE;
	if (lIMEOptionNew & IMF_FORCEACTIVE)
		_fForceActivate = TRUE;

	_fForceEnable = FALSE;
	if (lIMEOptionNew & IMF_FORCEENABLE)
		_fForceEnable = TRUE;
	
	_fForceRemember = FALSE;
	if (lIMEOptionNew & IMF_FORCEREMEMBER)
		_fForceRemember = TRUE;

	SetupIMEOptions();

	return 1;
}

/*
 *	CTextMsgFilter::OnGetIMEOptions()
 *
 *	@mfunc
 *	
 *	@rdesc
 */
LRESULT CTextMsgFilter::OnGetIMEOptions()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnGetIMEOptions");

	LRESULT		lres = 0;

	if (_fForceActivate)
		lres |= IMF_FORCEACTIVE;		

	if (_fForceEnable)
		lres |= IMF_FORCEENABLE;

	if (_fForceRemember)
		lres |= IMF_FORCEREMEMBER;

	return lres;
}

/*
 *	CTextMsgFilter::SetupIMEOptions()
 *
 *	@mfunc
 *	
 */
void CTextMsgFilter::SetupIMEOptions()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::SetupIMEOptions");

	if (!_hwnd)
		return;

	_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);	

	if (_fForceEnable)
	{		
		LONG	cpgLocale = GetACP();
		INT		iCharRep = CharRepFromCodePage(cpgLocale);

		if (W32->IsFECodePage(cpgLocale))
		{
			if (_uKeyBoardCodePage != (UINT)cpgLocale)
				W32->CheckChangeKeyboardLayout(iCharRep);

			HIMC	hIMC = LocalGetImmContext(*this);

			if (hIMC)
			{
				if (ImmSetOpenStatus(hIMC, TRUE, _fUsingAIMM) && _fForceActivate)
				{
					// Activate native input mode
					DWORD	dwConversion;
					DWORD	dwSentence;

					if (ImmGetConversionStatus(hIMC, &dwConversion, &dwSentence, _fUsingAIMM))
					{
						dwConversion |= IME_CMODE_NATIVE;
						if (iCharRep == SHIFTJIS_INDEX)
							dwConversion |= IME_CMODE_FULLSHAPE;
						ImmSetConversionStatus(hIMC, dwConversion, dwSentence, _fUsingAIMM);
					}
				}
				LocalReleaseImmContext(*this, hIMC);
			}			
		}
	}
}

/*
 *	CTextMsgFilter::OnSetIMEMode(WPARAM wparam, LPARAM lparam)
 *
 *	@mfunc
 *		Handle EM_SETIMEMODE message to setup or clear the IMF_SMODE_PHRASEPREDICT mode
 *
 */
void CTextMsgFilter::OnSetIMEMode(
	WPARAM	wparam,
	LPARAM	lparam)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnSetIMEMode");

	BOOL	fNotifyUIM = FALSE;

	if (!(lparam & (IMF_SMODE_PLAURALCLAUSE | IMF_SMODE_NONE)))		// Only IMF_SMODE_PHRASEPREDICT for now	
		return;										//	Bad mask option

	if ((wparam & (IMF_SMODE_PLAURALCLAUSE | IMF_SMODE_NONE)) == _nIMEMode)	// Nothing change...
		return;														//	Done.

	_nIMEMode = wparam & (IMF_SMODE_PLAURALCLAUSE | IMF_SMODE_NONE);

	if (_hwnd && GetFocus() == _hwnd)
		SetIMESentenseMode(_nIMEMode);

	// Setup UIM mode bias
	if (_nIMEMode)
	{
		if (_nIMEMode == IMF_SMODE_PLAURALCLAUSE && _wUIMModeBias != CTFMODEBIAS_NAME)
		{
			_wUIMModeBias = CTFMODEBIAS_NAME;
			fNotifyUIM = TRUE;
		}
		else if (_nIMEMode == IMF_SMODE_NONE && _wUIMModeBias != CTFMODEBIAS_DEFAULT)
		{
			_wUIMModeBias = CTFMODEBIAS_DEFAULT;
			fNotifyUIM = TRUE;
		}
	}
	else
	{
		_wUIMModeBias = 0;
		fNotifyUIM = TRUE;
	}

	if (fNotifyUIM && _pMsgCallBack)
		_pMsgCallBack->NotifyEvents(NE_MODEBIASCHANGE);
}

/*
 *	CTextMsgFilter::SetIMESentenseMode()
 *
 *	@mfunc
 *		Setup phrase mode or restore previous sentence mode
 */
void CTextMsgFilter::SetIMESentenseMode(
	BOOL	fSetup,
	HKL		hKL)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::SetIMESentenseMode");

	if (_hwnd && CheckIMEType(hKL, 0) &&		// FE IME Keyboard?
		(fSetup || _fRestoreOLDIME))
	{
		HIMC	hIMC = LocalGetImmContext(*this);

		if (hIMC)
		{
			DWORD	dwConversion;
			DWORD	dwSentence;

			if (ImmGetConversionStatus(hIMC, &dwConversion, &dwSentence, _fUsingAIMM))
			{
				if (fSetup)
				{
					if (!_fRestoreOLDIME)
					{
						// Setup IME Mode
						_wOldIMESentence = dwSentence & 0x0FFFF;
						_fRestoreOLDIME = 1;
					}
					dwSentence &= 0x0FFFF0000;
					if (_nIMEMode == IMF_SMODE_PLAURALCLAUSE)
						dwSentence |= IME_SMODE_PLAURALCLAUSE;
					else
						dwSentence |= IME_SMODE_NONE;
				}
				else
				{
					// Restore previous mode
					dwSentence &= 0x0FFFF0000;
					dwSentence |= _wOldIMESentence;
					_fRestoreOLDIME = 0;
				}

				ImmSetConversionStatus(hIMC, dwConversion, dwSentence, _fUsingAIMM);
			}

			LocalReleaseImmContext(*this, hIMC);
		}
	}
}

/*
 *	CTextMsgFilter::OnGetIMECompText(WPARAM wparam, LPARAM lparam)
 *
 *	@mfunc
 *
 *	@rdesc
 */
int CTextMsgFilter::OnGetIMECompText(
	WPARAM	wparam,
	LPARAM	lparam)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnGetIMECompText");
	if (_ime)
	{
		HRESULT hr;
		IMECOMPTEXT *pIMECompText = (IMECOMPTEXT *)wparam;

		if (pIMECompText->flags == ICT_RESULTREADSTR)
		{
			int cbSize = pIMECompText->cb;
			hr = CIme::CheckInsertResultString(0, *this, NULL, &cbSize, (WCHAR *)lparam);

			if (hr == S_OK)
				return cbSize/2;
		}
	}
	return 0;
}

/*
 *	CTextMsgFilter::NoIMEProcess()
 *
 *	@mfunc
 *		check if you should handle IME
 */
BOOL CTextMsgFilter::NoIMEProcess()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::NoIMEProcess");

	if (_fNoIme)
		return TRUE;

	_pTextDoc->GetFEFlags(&_lFEFlags);

	if (_lFEFlags & (ES_NOIME | tomUsePassword))
		return TRUE;

	return FALSE;
}

/*
 *	CTextMsgFilter::MouseOperation(UINT msg, long ichStart, long cchComp, WPARAM wParam,
 *							WPARAM *pwParamBefore, BOOL *pfTerminateIME, HWND	hwndIME)
 *
 *	@mfunc
 *		handle mouse operation for CTF or IME
 *
 *	@rdesc
 *		BOOL-TRUE if CTF or IME handled the mouse events
 */
BOOL CTextMsgFilter::MouseOperation(
	UINT			msg,
	long			ichStart,
	long			cchComp,
	WPARAM			wParam,
	WPARAM			*pwParamBefore,
	BOOL			*pfTerminateIME,
	HWND			hwndIME,
	long			*pCpCursor,
	ITfMouseSink	*pMouseSink)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::MouseOperation");
	BOOL	fRetCode = FALSE;
	BOOL	fButtonPressed = FALSE;
	WORD	wButtons = 0;
	POINT	ptCursor;
	WPARAM	wParamIME;
	WPARAM	fwkeys = wParam;
	BOOL	fHandleIME = hwndIME ? TRUE : FALSE;
	HWND	hHostWnd = _hwnd;
	long	hWnd;

	if (!hHostWnd)									// Windowless mode...
	{
		if (_pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;

		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	*pfTerminateIME = TRUE;

	switch (msg)
	{
		case WM_MOUSEMOVE:
			goto LCheckButton;

		case WM_LBUTTONDOWN:
			fButtonPressed = TRUE;
		case WM_LBUTTONDBLCLK:
			fwkeys |= MK_LBUTTON;
			goto LCheckButton;

		case WM_LBUTTONUP:
			fwkeys &= (~MK_LBUTTON);
			goto LCheckButton;

		case WM_RBUTTONDOWN:
			fButtonPressed = TRUE;
		case WM_RBUTTONDBLCLK:
			fwkeys |= MK_RBUTTON;
			goto LCheckButton;

		case WM_RBUTTONUP:
			fwkeys &= (~MK_RBUTTON);
			goto LCheckButton;

		case WM_MBUTTONUP:
			fwkeys &= (~MK_MBUTTON);
			goto LCheckButton;

		case WM_MBUTTONDOWN:
			fButtonPressed = TRUE;
		case WM_MBUTTONDBLCLK:
			fwkeys |= MK_MBUTTON;
LCheckButton:
			if (fwkeys & MK_LBUTTON)
				wButtons |= IMEMOUSE_LDOWN;
			if (fwkeys & MK_RBUTTON)
				wButtons |= IMEMOUSE_RDOWN;
			if (fwkeys & MK_MBUTTON)
				wButtons |= IMEMOUSE_MDOWN;
			break;

		case WM_SETCURSOR:
			wButtons = LOBYTE(*pwParamBefore);
			break;

		default:
			return FALSE;
	}

	// Kor special - click should terminate IME
	if (fHandleIME && fButtonPressed && _uKeyBoardCodePage == CP_KOREAN)
	{
		*pfTerminateIME = TRUE;
		return FALSE;
	}

	// Change in button since last message?
	if ((wButtons != LOBYTE(LOWORD(*pwParamBefore))) && GetCapture() == hHostWnd)
	{
		fButtonPressed = FALSE;
		wButtons = 0;
		ReleaseCapture();
	}

	if (GetCursorPos(&ptCursor))
	{
		ITextRange *pTextRange;
		HRESULT		hResult;
		long		ichCursor;
		long		lTextFlow;
		POINT		ptCPTop = {0, 0};
		POINT		ptCPBottom = {0, 0};
		POINT		ptCenterTop = {0, 0};
		POINT		ptCenterBottom = {0, 0};
		BOOL		fWithinCompText = FALSE;

		// Get cp at current Cursor position
		hResult = _pTextDoc->RangeFromPoint(ptCursor.x, ptCursor.y,
			&pTextRange);

		if (hResult != NOERROR)
			return FALSE;

		_pTextDoc->GetFEFlags(&lTextFlow);
		lTextFlow &= tomTextFlowMask;

		hResult = pTextRange->GetStart(&ichCursor);
		pTextRange->GetPoint(TA_TOP, &(ptCPTop.x), &(ptCPTop.y));
		pTextRange->GetPoint(TA_BOTTOM, &(ptCPBottom.x), &(ptCPBottom.y));
		pTextRange->Release();
		pTextRange = NULL;
		if (hResult != NOERROR)
			return FALSE;

		if (pCpCursor)
			*pCpCursor = ichCursor;

		// Click within composition text?
		if (ichStart <= ichCursor && ichCursor <= ichStart + cchComp)
		{
			WORD	wPos = 0;

			LONG lTestCursor = TestPoint(ptCPTop, ptCPBottom, ptCursor, TEST_ALL, lTextFlow);

			if (lTestCursor & (TEST_TOP | TEST_BOTTOM))
					goto HIT_OUTSIDE;

			// Cursor locates to the left of the first composition character
			// or cursor locates to the right of the last composition character
			if (ichStart == ichCursor && (lTestCursor & TEST_LEFT) ||
				ichCursor == ichStart + cchComp && (lTestCursor & TEST_RIGHT))
				goto HIT_OUTSIDE;

			// Need to calculate the relative position of the Cursor and the center of character:
			//
			// If Cursor locates to the Left of the cp, 
			//		If Cursor is more than 1/4 the character width from the cp
			//			wPos = 0;
			//		Otherwise
			//			wPos = 1;
			//
			// If Cursor locates to the Right of the cp, 
			//		If Cursor is less than 1/4 the character width from the cp
			//			wPos = 2;
			//		Otherwise
			//			wPos = 3;
			//
			if (lTestCursor & TEST_LEFT)
				hResult = _pTextDoc->Range(ichCursor-1, ichCursor, &pTextRange);
			else
				hResult = _pTextDoc->Range(ichCursor, ichCursor+1, &pTextRange);

			if (pTextRange)
			{
				LONG	lTestCenter = 0;
				LONG	uMouse = 0;
				LONG	uHalfCenter = 0;

				pTextRange->GetPoint(tomStart + TA_TOP + TA_CENTER, &(ptCenterTop.x), &(ptCenterTop.y));
				pTextRange->GetPoint(tomStart + TA_BOTTOM + TA_CENTER, &(ptCenterBottom.x), &(ptCenterBottom.y));
				pTextRange->Release();

				lTestCenter = TestPoint(ptCPTop, ptCPBottom, ptCenterBottom, TEST_ALL, lTextFlow);

				if (lTestCenter & (TEST_TOP | TEST_BOTTOM))
					goto HIT_OUTSIDE;					// Not on the same line

				if (lTextFlow == tomTextFlowES || lTextFlow == tomTextFlowWN)
				{
					uMouse = ptCursor.x - ptCPBottom.x;
					uHalfCenter = ptCenterBottom.x - ptCPBottom.x;
				}
				else
				{
					uMouse = ptCursor.y - ptCPBottom.y;
					uHalfCenter = ptCenterBottom.y - ptCPBottom.y;
				}

				uMouse = abs(uMouse);
				uHalfCenter = abs(uHalfCenter) / 2;

				if (lTestCursor & TEST_LEFT)
				{
					if (lTestCenter & TEST_LEFT)
						wPos = uMouse > uHalfCenter ? 0: 1;
				}
				else if (lTestCenter & TEST_RIGHT)
					wPos = uMouse >= uHalfCenter ? 3: 2;

				wButtons = MAKEWORD(wButtons, wPos);
			}

			wParamIME = MAKEWPARAM(wButtons, ichCursor - ichStart);
			fButtonPressed &= (*pwParamBefore & 0xff) == 0;

			if (*pwParamBefore != wParamIME || fHandleIME && msg == WM_MOUSEMOVE && !fButtonPressed)
			{
				*pwParamBefore = wParamIME;
				if (fHandleIME)	// IME case
				{
					HIMC hIMC = LocalGetImmContext(*this);

					if (hIMC)
					{
						fRetCode = SendMessage(hwndIME, MSIMEMouseMsg, *pwParamBefore, hIMC);
						LocalReleaseImmContext(*this, hIMC);
					}
				}
				else			// Cicero case
				{
					BOOL	fEaten = FALSE;
					DWORD	dwBtn = 0;

					dwBtn |= wButtons & IMEMOUSE_LDOWN ? MK_LBUTTON : 0;
					dwBtn |= wButtons & IMEMOUSE_MDOWN ? MK_MBUTTON : 0;
					dwBtn |= wButtons & IMEMOUSE_RDOWN ? MK_RBUTTON : 0;

					if (S_OK == pMouseSink->OnMouseEvent(ichCursor - ichStart, wPos, dwBtn, &fEaten) && fEaten)
						fRetCode = TRUE;
				}
			}
			else
				fRetCode = TRUE;		// No change from last time, no need to send message to IME

			fWithinCompText = TRUE;
			if (fHandleIME && fRetCode && fButtonPressed && GetCapture() != hHostWnd)
				SetCapture(hHostWnd);
		}

HIT_OUTSIDE:
		if (!fWithinCompText && (GetCapture() == hHostWnd || msg == WM_LBUTTONUP))	//We don't want to determine while dragging...
			fRetCode = TRUE;
	}

	*pfTerminateIME = !fRetCode;
	return fRetCode;
}

/*
 *	CTextMsgFilter::CompleteUIMTyping(LONG mode, BOOL fTransaction)
 *
 *	@mfunc
 *		Terminate IME or UIM composition 
 *	
 */
void CTextMsgFilter::CompleteUIMTyping(
	LONG mode,
	BOOL fTransaction)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::CompleteUIMTyping");

	if (_ime)
	{
		Assert(!(_pCUIM && _pCUIM->IsUIMTyping()));
		_ime->TerminateIMEComposition(*this, (CIme::TerminateMode)mode);
	}
	else
	{
		Assert (_pCUIM);
		if (_pCUIM && _fSendTransaction == 0)
		{
			if (fTransaction)
			{
				ITextStoreACPSink *ptss = _pCUIM->_ptss;

				if (ptss)
				{
					_fSendTransaction = 1;
					ptss->OnStartEditTransaction();
				}
			}
			_pCUIM->CompleteUIMText();
		}
	}
}

/*
 *	CTextMsgFilter::GetIMECompAttributes()
 *
 *	@mfunc
 *		Get the 1.0 mode IME color and underline for displaying cmposition strings
 *
 *	@rdesc
 *		COMPCOLOR *.  Could be NULL if PvAlloc failed
 *	
 */
COMPCOLOR* CTextMsgFilter::GetIMECompAttributes()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::GetIMECompAttributes");

	// For 1.0 mode IME color 
	if (!_pcrComp)
	{
		_pcrComp = (COMPCOLOR *)PvAlloc(sizeof(COMPCOLOR) * 4, GMEM_ZEROINIT);

		if (_pcrComp)
		{
			// Init. IME composition color/underline the same way as RE1.0			
			_pcrComp[0].crBackground = 0x0ffffff;
			_pcrComp[0].dwEffects = CFE_UNDERLINE;
			_pcrComp[1].crBackground = 0x0808080;
			_pcrComp[2].crBackground = 0x0ffffff;
			_pcrComp[2].dwEffects = CFE_UNDERLINE;
			_pcrComp[3].crText = 0x0ffffff;
		}
	}

	return _pcrComp;
}

/*
 *	CTextMsgFilter::SetupCallback()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::SetupCallback()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::SetupCallback");

	if (!_pMsgCallBack)
		_pMsgCallBack = new CMsgCallBack(this);
	if (_pMsgCallBack)
	{
		LRESULT lresult;
		_pTextService->TxSendMessage(EM_SETCALLBACK, 0, (LPARAM)_pMsgCallBack, &lresult);
	}
}

/*
 *	CTextMsgFilter::SetupLangSink()
 *
 *	@mfunc
 *		Setup the Language sink to catch the keyboard changing event.  We are not
 *	getting WM_INPUTLANGCHANGEREQUEST and thus need this sink.
 *
 */
void CTextMsgFilter::SetupLangSink()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::SetupLangSink");

	if (!_pITfIPP)
	{
		CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
			IID_ITfInputProcessorProfiles, (void**)&_pITfIPP);

		if (_pITfIPP)
		{
			_pCLangProfileSink = new CLangProfileSink();
			if (_pCLangProfileSink)
			{
				if (_pCLangProfileSink->_Advise(this, _pITfIPP) != S_OK)
				{
					_pCLangProfileSink->Release();
					_pCLangProfileSink = NULL;
					_pITfIPP->Release();
					_pITfIPP = NULL;
				}
			}
			else
			{
				_pITfIPP->Release();
				_pITfIPP = NULL;
			}
		}
	}
}

/*
 *	CTextMsgFilter::ReleaseLangSink()
 *
 *	@mfunc
 *		Release the lang sink object
 *
 */
void CTextMsgFilter::ReleaseLangSink()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::ReleaseLangSink");

	if (_pITfIPP)
	{
		Assert(_pCLangProfileSink);

		_pCLangProfileSink->_Unadvise();
		_pCLangProfileSink->Release();
		_pCLangProfileSink = NULL;

		_pITfIPP->Release();
		_pITfIPP = NULL;
	}
}

/*
 *	CTextMsgFilter::StartUIM()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::StartUIM()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::StartUIM");

	if (NoIMEProcess())
		return;

	_fUsingUIM = CreateUIM(this);

	if (_fUsingUIM)
	{
		SetupCallback();
		SetupLangSink();
	}
}

/*
 *	CTextMsgFilter::StartAimm()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::StartAimm(BOOL fUseAimm12)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::StartAimm");

	if (!_hwnd || NoIMEProcess())
		return;

	if (LoadAIMM(fUseAimm12))
	{
		HRESULT	hResult = ActivateAIMM(FALSE);

		if (hResult == NOERROR)
		{
			DWORD	dwAtom;
			ATOM	aClass;

			// filter client windows
			if (dwAtom = GetClassLong(_hwnd, GCW_ATOM))
			{
				aClass = dwAtom;				
				hResult = FilterClientWindowsAIMM(&aClass, 1, _hwnd);
			}
			_fUsingAIMM = 1;
			SetupCallback();

			if (!fLoadAIMM10)
				SetupLangSink();
		}
	}
}

/*
 *	CTextMsgFilter::TurnOffUIM()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::TurnOffUIM(BOOL fSafeToSendMessage)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::TurnOffUIM");

	if (fSafeToSendMessage && _fUsingUIM && _pCUIM && _pCUIM->IsUIMTyping())
		CompleteUIMTyping(CIme::TERMINATE_NORMAL);

	_fUsingUIM = FALSE;

	ReleaseLangSink();

	// Release various objects
	if (_pCUIM)
	{
		CUIM *pCUIM = _pCUIM;
		LRESULT lresult;

		_pCUIM = NULL;

		if (fSafeToSendMessage)
			_pTextService->TxSendMessage(EM_SETUPNOTIFY, 0, (LPARAM)(ITxNotify *)pCUIM, &lresult);
		else
			pCUIM->_fShutDown = 1;

		pCUIM->Uninit();
		pCUIM->Release();
	
	}

	if (_pTim)
	{
		ITfThreadMgr *pTim = _pTim;
		
		_pTim = NULL;
		pTim->Deactivate();
		pTim->Release();
	}

	// Turn off Callback
	if (fSafeToSendMessage && _pMsgCallBack)
	{
		LRESULT lresult;
		_pTextService->TxSendMessage(EM_SETCALLBACK, 0, (LPARAM)0, &lresult);
		delete _pMsgCallBack;
		_pMsgCallBack = NULL;
	}
}

/*
 *	CTextMsgFilter::HandleCTFService(wparam, lparam)
 *
 *	@mfunc
 *		Setup Cicero setting to handle or disable smarttag and proofing services
 *	
 */
void CTextMsgFilter::HandleCTFService(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::HandleCTFService");

	BOOL	fChangeInSetting = FALSE;

	if (lparam & SES_CTFALLOWSMARTTAG)
	{
		BOOL fAllowSmartTagLocal = (wparam & SES_CTFALLOWSMARTTAG) ? 1 : 0;

		if ((BOOL)_fAllowSmartTag != fAllowSmartTagLocal)
		{
			_fAllowSmartTag = fAllowSmartTagLocal;
			fChangeInSetting = TRUE;
		}
	}
	if (lparam & SES_CTFALLOWPROOFING)
	{
		BOOL fAllowProofLocal = (wparam & SES_CTFALLOWPROOFING) ? 1 : 0;

		if ((BOOL)_fAllowProofing != fAllowProofLocal)
		{
			_fAllowProofing = fAllowProofLocal;
			fChangeInSetting = TRUE;
		}
	}

	if (fChangeInSetting)
	{
		if (_fUsingUIM && _pCUIM)
			_pCUIM->NotifyService();
	}
}

/*
 *	CTextMsgFilter::TurnOffAimm()
 *
 *	@mfunc
 *		Turn off Aimm.
 *	
 */
void CTextMsgFilter::TurnOffAimm(BOOL fSafeToSendMessage)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::TurnOffAimm");

	if (_fUsingAIMM)
	{
		if (IsIMEComposition())
		{
			if (fSafeToSendMessage)
				CompleteUIMTyping(CIme::TERMINATE_NORMAL);
			else
			{
				delete _ime;
				_ime = NULL;
			}
		}

		_fUsingAIMM = FALSE;

		UnfilterClientWindowsAIMM(_hwnd);
		DeactivateAIMM();

		ReleaseLangSink();

		// Turn off Callback
		if (fSafeToSendMessage && _pMsgCallBack)
		{
			LRESULT lresult;
			_pTextService->TxSendMessage(EM_SETCALLBACK, 0, (LPARAM)0, &lresult);
			delete _pMsgCallBack;
			_pMsgCallBack = NULL;
		}
	}
}

/*
 *	void CTextMsgFilter::OnSetUIMMode()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::OnSetUIMMode(WORD wUIMModeBias) 
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnSetUIMMode");

	if (_wUIMModeBias != wUIMModeBias && 
		IN_RANGE(CTFMODEBIAS_DEFAULT, wUIMModeBias, CTFMODEBIAS_HALFWIDTHALPHANUMERIC))
	{
		_wUIMModeBias = wUIMModeBias;

		if (_pMsgCallBack)
			_pMsgCallBack->NotifyEvents(NE_MODEBIASCHANGE);
	}
}

/*
 *	HRESULT CMsgCallBack::HandlePostMessage()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
HRESULT CMsgCallBack::HandlePostMessage(
	HWND hWnd,
	UINT msg, 
	WPARAM wparam, 
	LPARAM lparam, 
	LRESULT *plres)
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CMsgCallBack::HandlePostMessage");

	if (_pTextMsgFilter->_fUsingAIMM)
		return CallAIMMDefaultWndProc(hWnd, msg, wparam, lparam, plres);

	return S_FALSE;
}

/*
 *	HRESULT CMsgCallBack::NotifyEvents()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
HRESULT CMsgCallBack::NotifyEvents(DWORD dwEvents)
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CMsgCallBack::NotifyEvents");

	CUIM	*pCUIM = _pTextMsgFilter->_pCUIM;

	if (pCUIM)
	{
		ITextStoreACPSink *ptss = pCUIM->_ptss;

		if (dwEvents & NE_ENTERTOPLEVELCALLMGR)
		{
			pCUIM->_cCallMgrLevels++;
		}
		else if (dwEvents & NE_EXITTOPLEVELCALLMGR)
		{
			Assert (pCUIM->_cCallMgrLevels > 0);
			pCUIM->_cCallMgrLevels--;
		}

		if (pCUIM->_cCallMgrLevels)
		{
			// Save events to be sent later
			if ((dwEvents & NE_CALLMGRSELCHANGE) && !pCUIM->_fReadLockOn)
				pCUIM->_fSelChangeEventPending = 1;

			if (dwEvents & (NE_CALLMGRCHANGE | NE_LAYOUTCHANGE))
				pCUIM->_fLayoutEventPending = 1;

			if (dwEvents & NE_MODEBIASCHANGE)
				pCUIM->_fModeBiasPending = 1;
		}
		else
		{
			if (pCUIM->_fSelChangeEventPending || (dwEvents & NE_CALLMGRSELCHANGE))
			{
				pCUIM->_fSelChangeEventPending = 0;
				if (ptss && !pCUIM->_fHoldCTFSelChangeNotify && !pCUIM->_fReadLockOn)
					ptss->OnSelectionChange();
			}

			if (pCUIM->_fLayoutEventPending || (dwEvents & (NE_CALLMGRCHANGE | NE_LAYOUTCHANGE)))
			{
				pCUIM->_fLayoutEventPending = 0;
				if (ptss)
					ptss->OnLayoutChange(TS_LC_CHANGE, 0);	
			}

			if (pCUIM->_fModeBiasPending || (dwEvents & NE_MODEBIASCHANGE))
			{
				pCUIM->_fModeBiasPending = 0;
				if (ptss)
				{	
					LONG	ccpMax = 0;

					if (pCUIM->GetStoryLength(&ccpMax) != S_OK)
						ccpMax = tomForward;

					ptss->OnAttrsChange(0, ccpMax, 1, &GUID_PROP_MODEBIAS);		// only ModeBias for now
				}
			}

			// Probably safe to let UIM to lock data now
			if (ptss && (pCUIM->_fReadLockPending || pCUIM->_fWriteLockPending))
			{
				HRESULT hResult;
				HRESULT hResult1;

				hResult = pCUIM->RequestLock(pCUIM->_fWriteLockPending ? TS_LF_READWRITE : TS_LF_READ, &hResult1);
			}

			if (_pTextMsgFilter->_fSendTransaction)
			{
				_pTextMsgFilter->_fSendTransaction = 0;
				if (ptss)
					ptss->OnEndEditTransaction();
			}

			pCUIM->_fHoldCTFSelChangeNotify = 0;
		}
	}

	return S_OK;
}

/*
 *	CLangProfileSink::QueryInterface()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDAPI CLangProfileSink::QueryInterface(REFIID riid, void **ppvObj)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::QueryInterface");

	*ppvObj = NULL;

	if (IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_ITfLanguageProfileNotifySink))
		*ppvObj = this;

	if (*ppvObj)
	{
		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;
}

/*
 *	CLangProfileSink::AddRef()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDAPI_(ULONG) CLangProfileSink::AddRef()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::AddRef");

	return ++_cRef;
}

/*
 *	CLangProfileSink::Release()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDAPI_(ULONG) CLangProfileSink::Release()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::Release");

	long cr;

	cr = --_cRef;
	Assert(cr >= 0);

	if (cr == 0)
		delete this;

	return cr;
}

/*
 *	CLangProfileSink::CLangProfileSink()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
CLangProfileSink::CLangProfileSink()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::CLangProfileSink");

	_cRef = 1;
	_dwCookie = (DWORD)(-1);
}

/*
 *	CLangProfileSink::OnLanguageChange()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDMETHODIMP CLangProfileSink::OnLanguageChange(LANGID langid, BOOL *pfAccept)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::OnLanguageChange");

	Assert (pfAccept);

	*pfAccept = TRUE;

	if (_pTextMsgFilter->_hwnd && GetFocus() == _pTextMsgFilter->_hwnd)
	{
		LRESULT		lresult = 0;
		if ( S_OK == _pTextMsgFilter->_pTextService->TxSendMessage(
				EM_GETDOCFLAGS, GDF_ALL, 0, &lresult))
		{
			if (lresult & GDF_SINGLECPG)
			{
				LCID syslcid = GetSysLCID();

				// Check if new langid supported by the system
				if (langid != syslcid)
				{
					LOCALESIGNATURE ls;

					if(GetLocaleInfoA(langid, LOCALE_FONTSIGNATURE, (LPSTR)&ls, sizeof(ls)))
					{
						CHARSETINFO cs;
						HDC hdc = GetDC(_pTextMsgFilter->_hwnd);
						TranslateCharsetInfo((DWORD *)(DWORD_PTR)GetTextCharsetInfo(hdc, NULL, 0), &cs, TCI_SRCCHARSET);
						ReleaseDC(_pTextMsgFilter->_hwnd, hdc);
						DWORD fsShell = cs.fs.fsCsb[0];
						if (!(fsShell & ls.lsCsbSupported[0]))
							*pfAccept = FALSE;
					}
				}
			}
		}

		if (*pfAccept == TRUE && _pTextMsgFilter-> _nIMEMode)
			_pTextMsgFilter->SetIMESentenseMode(FALSE);
	}

    return S_OK;
}

/*
 *	CLangProfileSink::OnLanguageChanged()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDMETHODIMP CLangProfileSink::OnLanguageChanged()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::OnLanguageChanged");

    return S_OK;
}

/*
 *	CLangProfileSink::_Advise()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
HRESULT CLangProfileSink::_Advise(
	CTextMsgFilter *pTextMsgFilter,
	ITfInputProcessorProfiles *pipp)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::_Advise");

    HRESULT hr;
    ITfSource *pSource = NULL;

	_pTextMsgFilter = pTextMsgFilter;
    _pITFIPP = pipp;
    hr = E_FAIL;

    if (FAILED(_pITFIPP->QueryInterface(IID_ITfSource, (void **)&pSource)))
        goto Exit;

    if (FAILED(pSource->AdviseSink(IID_ITfLanguageProfileNotifySink, this, &_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    pSource->Release();
    return hr;
}

/*
 *	CLangProfileSink::_Unadvise()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
HRESULT CLangProfileSink::_Unadvise()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::_Unadvise");

	HRESULT hr;
	ITfSource *pSource = NULL;

	hr = E_FAIL;

	if (_pITFIPP == NULL)
		return hr;

	if (FAILED(_pITFIPP->QueryInterface(IID_ITfSource, (void **)&pSource)))
		return hr;

	if (FAILED(pSource->UnadviseSink(_dwCookie)))
		goto Exit;

	hr = S_OK;

Exit:
	pSource->Release();
	return hr;
}

#endif // NOFEPROCESSING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\cfpf.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	CFPF.C -- -- RichEdit CCharFormat and CParaFormat Classes |
 *
 *	Created: <nl>
 *		9/1995 -- Murray Sargent <nl>
 *
 *	@devnote
 *		The this ptr for all methods points to an internal format class, i.e.,
 *		either a CCharFormat or a CParaFormat, which uses the cbSize field as
 *		a reference count.  The pCF or pPF argument points at an external
 *		CCharFormat or CParaFormat class, that is, pCF->cbSize and pPF->cbSize
 *		give the size of their structure.  The code still assumes that both
 *		internal and external forms are derived from the CHARFORMAT(2) and
 *		PARAFORMAT(2) API structures, so some redesign would be necessary to
 *		obtain a more space-efficient internal form.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_array.h"					// for fumemmov()
#include "_rtfconv.h"				// for IsCharSetValid()
#include "_font.h"					// for GetFontNameIndex(), GetFontName()

ASSERTDATA


// Table of formatting info for Normal and Heading styles
const STYLEFORMAT g_Style[] =		// {dwEffects; yHeight}
{							// Measurements in points
	{CFE_BOLD,				14},	// Heading 1
	{CFE_BOLD + CFE_ITALIC,	12},	// Heading 2
	{0,						12},	// Heading 3
	{CFE_BOLD,				12},	// Heading 4
	{0,						11},	// Heading 5
	{CFE_ITALIC,			11},	// Heading 6
	{0,						 0},	// Heading 7
	{CFE_ITALIC,			 0},	// Heading 8
	{CFE_BOLD + CFE_ITALIC,	 9}		// Heading 9
};


BOOL IsValidTwip(LONG dl)
{
	static const LONG dlMax =  0x00FFFFFF;
	static const LONG dlMin = -0x00FFFFFF;
	if (dl > dlMax || dl < dlMin)
		return FALSE;
	return TRUE;
}

//------------------------- CCharFormat Class -----------------------------------

/*
 *	CCharFormat::Apply(pCF, dwMask, dwMask2)
 *
 *	@mfunc
 *		Apply *<p pCF> to this CCharFormat as specified by nonzero bits in
 *		dwMask and dwMask2
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@devnote
 *		Autocolor is dealt with through a neat little hack made possible
 *		by the choice CFE_AUTOCOLOR = CFM_COLOR (see richedit.h).  Hence
 *		if <p pCF>->dwMask specifies color, it automatically resets autocolor
 *		provided (<p pCF>->dwEffects & CFE_AUTOCOLOR) is zero.
 *
 *		*<p pCF> is an external CCharFormat, i.e., it's either a CHARFORMAT
 *		or a CHARFORMAT2 with the appropriate size given by cbSize. But
 *		this CCharFormat is internal and cbSize is used as a reference count.
 */
HRESULT CCharFormat::Apply (
	const CCharFormat *pCF,	//@parm	CCharFormat to apply to this CF
	DWORD dwMask,			//@parm Mask corresponding to CHARFORMAT2
	DWORD dwMask2)			//@parm Mask for additional internal parms
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Apply");

	DWORD	dwEffectMask = dwMask & CFM_EFFECTS2;
	bool	fNewCharset = false;

	// Reset effect bits to be modified and OR in supplied values
	_dwEffects &= ~dwEffectMask;
	_dwEffects |= pCF->_dwEffects & dwEffectMask;

	// Ditto for additional effects given by dwMask2
	dwEffectMask = dwMask2 & 0xBBFC0000;	// Don't allow autocolors, sub/sups
	_dwEffects	&= ~dwEffectMask;
	_dwEffects	|= pCF->_dwEffects & dwEffectMask;

	// Setup Temp. display attributes idx
	if (dwMask2 & CFM2_USETMPDISPATTR)
		_sTmpDisplayAttrIdx = pCF->_sTmpDisplayAttrIdx;

	// If CFM_BOLD is specified, it overrides the font weight
	if(dwMask & CFM_BOLD)
		_wWeight = (pCF->_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

	// Handle CFM_COLOR since it's overloaded with CFE_AUTOCOLOR
	if(dwMask & CFM_COLOR)
		_crTextColor = pCF->_crTextColor;

	if(dwMask & ~CFM_EFFECTS)				// Early out if only dwEffects
	{										//  is modified. Note that
		if(dwMask & CFM_SIZE)				//  CFM_EFFECTS includes CFM_COLOR
		{
			// If dwMask2 CFM2_USABLEFONT bit is set, pCF->_yHeight (from
			// EM_SETFONTSIZE wparam) is signed increment in points.
			_yHeight = dwMask2 & CFM2_USABLEFONT
					? GetUsableFontHeight(_yHeight, pCF->_yHeight)
					: pCF->_yHeight;
		}

		if(dwMask & CFM_OFFSET)
			_yOffset = pCF->_yOffset;

		if((dwMask & CFM_CHARSET) &&

			// Caller guarantees no check needed
			(dwMask2 & (CFM2_NOCHARSETCHECK | CFM2_MATCHFONT) ||

			// Caller is itemizer. Change to ANSI_CHARSET only if current is BiDi,
			// dont change if current is DBCS/FE charset or symbol.
			(dwMask2 & CFM2_SCRIPT && 
			 (!pCF->_iCharRep && IsBiDiCharRep(_iCharRep) || 
			  pCF->_iCharRep && _iCharRep < NCHARSETS && !IsFECharRep(_iCharRep) &&
			  !IsSymbolOrOEMCharRep(_iCharRep) && !(_dwEffects & CFE_RUNISDBCS))) ||

			// Caller is not itemizer. Allow consistent direction
			(!(dwMask2 & CFM2_SCRIPT) && 
			 (!(IsRTLCharRep(_iCharRep) ^ IsRTLCharRep(pCF->_iCharRep)) ||
			  IsSymbolOrOEMCharRep(pCF->_iCharRep)))))
		{
			fNewCharset = TRUE;
			_iCharRep = pCF->_iCharRep;
		}
			
		if ((dwMask2 & (CFM2_MATCHFONT | CFM2_ADJUSTFONTSIZE)) == (CFM2_MATCHFONT | CFM2_ADJUSTFONTSIZE) &&
			_iCharRep != pCF->_iCharRep && (dwMask & CFM_SIZE))
		{
			// Check if we need to adjust the font size
			_yHeight = W32->GetPreferredFontHeight(
				(dwMask2 & CFM2_UIFONT) != 0,
				pCF->_iCharRep,
				_iCharRep,
				_yHeight);
		}

		if(dwMask & CFM_FACE)
		{
			_bPitchAndFamily = pCF->_bPitchAndFamily;
			_iFont = pCF->_iFont;
			
			const WCHAR *pch = GetFontName((LONG)_iFont);
			WCHAR ch = pch[0];
			
			if (!fNewCharset && ch == L'\0')
			{
				// API to choose default font								
				BYTE	bDefPitchAndFamily;
				SHORT	iDefFont;
				int		iCharRep = GetLocaleCharRep();
				BYTE	yDefHeight;

				// Get default font name and charset
				bool	fr = W32->GetPreferredFontInfo(
							iCharRep, FALSE, iDefFont, 
							(BYTE&)yDefHeight, bDefPitchAndFamily );
					
				if (fr) 
				{
					_iCharRep = iCharRep;
					_iFont = iDefFont;
						
					if(!(dwMask & CFM_SIZE) || _yHeight < yDefHeight * 20)	// Setup default height if needed.
						_yHeight = yDefHeight * 20;

					_bPitchAndFamily = bDefPitchAndFamily;
				}				
			}
			else if(GetCharFlags(pch, 2) & FFE && !IsFECharRep(_iCharRep))
			{
				// make sure that we dont end up having DBCS facename with Non-FE charset
				QWORD qwFontSig;
				if (GetFontSignatureFromFace(_iFont, &qwFontSig))
				{
					qwFontSig &= FFE ;		// Only interest in FE charset
					if (qwFontSig)
						_iCharRep = GetFirstAvailCharRep(qwFontSig);
				}
			}
#ifdef DEBUG
			_pchFaceName = GetFontName((LONG)_iFont);
#endif
		}

		if(!(dwMask2 & CFM2_CHARFORMAT) && (dwMask & ~CFM_ALL))	// CHARFORMAT2 extensions
		{
			if((dwMask & (CFM_WEIGHT | CFM_BOLD)) == CFM_WEIGHT) 
			{			
				_wWeight		= pCF->_wWeight;
				_dwEffects	   |= CFE_BOLD;			// Set above-average
				if(_wWeight < 551)					//  weights to bold
					_dwEffects &= ~CFE_BOLD;
			}

			if(dwMask & CFM_BACKCOLOR)
				_crBackColor	= pCF->_crBackColor;

			if(dwMask & CFM_LCID)
			{
				_lcid			= pCF->_lcid;
				if(!(dwMask & CFM_CHARSET) && !IsFECharRep(_iCharRep) && PRIMARYLANGID(_lcid))
					_iCharRep	= CharRepFromLID(_lcid);
			}

			if(dwMask & CFM_SPACING)
				_sSpacing		= pCF->_sSpacing;

			if(dwMask & CFM_KERNING)
				_wKerning		= pCF->_wKerning;

			if(dwMask & CFM_STYLE)
				_sStyle			= pCF->_sStyle;

			if(dwMask & CFM_UNDERLINETYPE)
			{
				_bUnderlineType	= pCF->_bUnderlineType;
				if(!(dwMask & CFM_UNDERLINE))		// If CFE_UNDERLINE
				{									//  isn't defined,
					_dwEffects	&= ~CFE_UNDERLINE;	//  set it according to
					if(_bUnderlineType)				//  bUnderlineType
						_dwEffects |= CFE_UNDERLINE;
				}
				else
					_bUnderlineColor = pCF->_bUnderlineColor;
			}

			if((dwMask & CFM_ANIMATION) && pCF->_bAnimation <= 18)
				_bAnimation		= pCF->_bAnimation;

			if(dwMask & CFM_REVAUTHOR)
				_bRevAuthor		= pCF->_bRevAuthor;
    	}
	}

	// RichEdit currently doesn't do a good job of assigning LangIDs to text,
	// primarily assigning them only on initialization, when the keyboard
	// changes, and when LangIDs are read in from RTF. The following weak
	// LangID recognizer uses the facts that most languages are associated
	// with a single CharRep and that the keyboard provides a good hint as
	// to which	language. The else if could be expanded to include more
	// CharReps than Arabic, Hebrew, and Ansi, e.g., CJK. More generally,
	// LangID recognition requires natural language processing beyond the
	// choice of the writing system, which is given in RichEdit by _iCharRep.
	if(CharRepFromLID(_lcid) != _iCharRep)
	{
		LONG lcid = (WORD)W32->GetPreferredKbd(_iCharRep);
		if(lcid)
			_lcid = lcid;					// Use keyboard lang for _iCharRep

		else if(_iCharRep == ANSI_INDEX)	// No ANSI_CHARSET keyboard
			_lcid = MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT);

		else if(IsBiDiCharRep(_iCharRep))	// Use default langs for BiDi
			_lcid = MAKELANGID(_iCharRep == HEBREW_INDEX ? LANG_HEBREW : LANG_ARABIC,
							   SUBLANG_DEFAULT);
	}

	if(dwMask2 & CFM2_SCRIPT)
		_wScript = pCF->_wScript;

	return NOERROR;
}

/*
 *	CCharFormat::ApplyDefaultStyle(Style)
 *
 *	@mfunc	
 *		Set default style properties in this CCharFormat
 */
void CCharFormat::ApplyDefaultStyle (
	LONG Style)		//@parm Style to use
{
	Assert(IsKnownStyle(Style));

	if(IsHeadingStyle(Style))
	{
		LONG i = -Style + STYLE_HEADING_1;
		_dwEffects = (_dwEffects & 0xFFFFFF00) | g_Style[i].bEffects;
		_wWeight = (_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

		if(g_Style[i].bHeight)
			_yHeight = g_Style[i].bHeight * 20;

		QWORD qwFontSig;
		LONG  iFont = _iFont;			// Save _iFont in case Arial doesn't
		_iFont = IFONT_ARIAL;			//  support _bCharSet

		GetFontSignatureFromFace(_iFont, &qwFontSig);
		if(FontSigFromCharRep(_iCharRep) & qwFontSig)
			_bPitchAndFamily = FF_SWISS;// Arial supports _iCharRep
		else
			_iFont = iFont;				// Restore iFont
#ifdef DEBUG
		_pchFaceName = GetFontName((LONG)_iFont);
#endif
	}
}

BOOL CCharFormat::CanKernWith(const CCharFormat *pCF) const
{
	const DWORD dwMask = CFE_ITALIC;

	return this == pCF ||
			(!((_dwEffects ^ pCF->_dwEffects) & dwMask) &&
			_iFont == pCF->_iFont &&
			_yHeight == pCF->_yHeight &&
			_wWeight == pCF->_wWeight);
}

/*
 *	CCharFormat::Compare(pCF)
 *
 *	@mfunc
 *		Compare this CCharFormat to *<p pCF>
 *
 *	@rdesc
 *		TRUE if they are the same not including _cRefs
 */
BOOL CCharFormat::Compare (
	const CCharFormat *pCF) const	//@parm	CCharFormat to compare this
{									//  CCharFormat to
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Compare");

	return !CompareMemory(this, pCF, sizeof(CCharFormat));
}

/*
 *	CCharFormat::Delta(pCF, fCHARFORMAT)
 *
 *	@mfunc
 *		Calculate dwMask for differences between this CCharformat and
 *		*<p pCF>
 *
 *	@rdesc
 *		return dwMask of differences (1 bit means a difference)
 */
DWORD CCharFormat::Delta (
	CCharFormat *pCF,		//@parm	CCharFormat to compare this one to
	BOOL fCHARFORMAT) const	//@parm Only compare CHARFORMAT members
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Delta");
												// Collect bits for properties
	LONG dw = _dwEffects ^ pCF->_dwEffects;		//  that change. Note: auto
												//  color is handled since
	if(_yHeight		!= pCF->_yHeight)			//  CFM_COLOR = CFE_AUTOCOLOR
		dw |= CFM_SIZE;

	if(_yOffset		!= pCF->_yOffset)
		dw |= CFM_OFFSET;

	if(_crTextColor	!= pCF->_crTextColor)
		dw |= CFM_COLOR;

	if(_iCharRep	!= pCF->_iCharRep)
		dw |= CFM_CHARSET;

	if(_iFont		!= pCF->_iFont)
		dw |= CFM_FACE;

	if(fCHARFORMAT)
		return dw;							// Done with CHARFORMAT stuff

	if(_crBackColor	!= pCF->_crBackColor)	// CHARFORMAT2 stuff
		dw |= CFM_BACKCOLOR;

	if(_wKerning	!= pCF->_wKerning)
		dw |= CFM_KERNING;

	if(_lcid		!= pCF->_lcid)
		dw |= CFM_LCID;

	if(_wWeight		!= pCF->_wWeight)
		dw |= CFM_WEIGHT;

	if(_sSpacing	!= pCF->_sSpacing)
		dw |= CFM_SPACING;

	if(_sStyle		!= pCF->_sStyle)
		dw |= CFM_STYLE;

	if(_bUnderlineType != pCF->_bUnderlineType)
		dw |= CFM_UNDERLINETYPE;

	if(_bAnimation	!= pCF->_bAnimation)
		dw |= CFM_ANIMATION;

	if(_bRevAuthor	!= pCF->_bRevAuthor)
		dw |= CFM_REVAUTHOR;

	return dw;
}

/*
 *	CCharFormat::fSetStyle(dwMask)
 *
 *	@mfunc
 *		return TRUE iff pCF specifies that the style should be set. See
 *		code for list of conditions for this to be true
 *
 *	@rdesc
 *		TRUE iff pCF specifies that the style _sStyle should be set
 */
BOOL CCharFormat::fSetStyle(DWORD dwMask, DWORD dwMask2) const
{
	return	dwMask != CFM_ALL2		&&
			dwMask &  CFM_STYLE		&&
			!(dwMask2 & CFM2_CHARFORMAT) &&
			IsKnownStyle(_sStyle);
}

/*
 *	CCharFormat::Get(pCF, CodePage)
 *
 *	@mfunc
 *		Copy this CCharFormat to the CHARFORMAT or CHARFORMAT2 *<p pCF>
 */
void CCharFormat::Get (
	CHARFORMAT2 *pCF2,		//@parm CHARFORMAT to copy this CCharFormat to
	UINT CodePage) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Get");

	pCF2->dwMask		= CFM_ALL;				// Use CHARFORMAT
	pCF2->dwEffects		= _dwEffects;
	pCF2->yHeight		= _yHeight;
	pCF2->yOffset		= _yOffset;
	pCF2->crTextColor	= _crTextColor;
	pCF2->bCharSet		= CharSetFromCharRep(_iCharRep);
	pCF2->bPitchAndFamily = _bPitchAndFamily;

	UINT cb = pCF2->cbSize;
	const WCHAR *pch = GetFontName((LONG)_iFont);

	AssertSz((CodePage != 1200) ^ IsValidCharFormatW(pCF2),
		"CCharFormat::Get: wrong codepage for CHARFORMAT");
	
	if(CodePage != 1200)
	{
		if(_dwEffects & CFE_FACENAMEISDBCS)
		{
			// The face name is actually DBCS stuffed into the unicode
			// buffer, so simply un-stuff this DBCS into the ANSI string
			char *pachDst = (char *)pCF2->szFaceName;

			while(*pch)
				*pachDst++ = *pch++;

			*pachDst = 0;
		}
		else
		{
			MbcsFromUnicode((char *)pCF2->szFaceName, LF_FACESIZE,
							pch, -1, CodePage, UN_NOOBJECTS);
		}
	}
	else
		wcscpy(pCF2->szFaceName, pch);
	
	if (cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))	// We're done
		return;

	char *pvoid = (char *)&pCF2->wWeight;
	if(pCF2->cbSize == sizeof(CHARFORMAT2A))
		pvoid -= sizeof(CHARFORMAT2W) - sizeof(CHARFORMAT2A);
	else
		Assert(pCF2->cbSize == sizeof(CHARFORMAT2));// Better be a CHARFORMAT2

	pCF2->dwMask = CFM_ALL2;
	CopyMemory(pvoid, &_wWeight, 3*sizeof(DWORD));
	CopyMemory(pvoid + 4*sizeof(DWORD),  &_sStyle,  2*sizeof(DWORD));
	*(DWORD *)(pvoid + 3*sizeof(DWORD)) = 0;
}

/*
 *	CCharFormat::InitDefault(hfont)
 *
 *	@mfunc	
 *		Initialize this CCharFormat with information coming from the font
 *		<p hfont>
 *	
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CCharFormat::InitDefault (
	HFONT hfont)		//@parm Handle to font info to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::InitDefault");

	LOGFONT lf;
	BOOL	fUseStockFont = hfont == NULL;

	ZeroMemory(this, sizeof(CCharFormat));

	// If hfont isn't defined, get LOGFONT for default font
	if(!hfont)
		hfont = W32->GetSystemFont();

	// Get LOGFONT for passed hfont
	if(!W32->GetObject(hfont, sizeof(LOGFONT), &lf))
		return E_FAIL;

	_yHeight = (lf.lfHeight * LY_PER_INCH) / W32->GetYPerInchScreenDC();
	if(_yHeight <= 0)
		_yHeight = -_yHeight;
	else if (fUseStockFont)		// This is Cell Height for System Font case
		_yHeight -= (W32->GetSysFontLeading() * LY_PER_INCH) / W32->GetYPerInchScreenDC();
	else
	{
		// This is Cell Height, need to get the character height by subtracting 
		// the tm.tmInternalLeading.
		CLock		lock;
		HDC			hdc = W32->GetScreenDC();
		HFONT		hOldFont = SelectFont(hdc, hfont);
		TEXTMETRIC	tm;

		if(hOldFont)
		{
			if(GetTextMetrics(hdc, &tm))			
    			_yHeight -= (tm.tmInternalLeading * LY_PER_INCH) / W32->GetYPerInchScreenDC();

			SelectFont(hdc, hOldFont); 
		}
	}

	_dwEffects = (CFM_EFFECTS | CFE_AUTOBACKCOLOR) & ~(CFE_PROTECTED | CFE_LINK);

	if(lf.lfWeight < FW_BOLD)
		_dwEffects &= ~CFE_BOLD;

	if(!lf.lfItalic)
		_dwEffects &= ~CFE_ITALIC;

	if(!lf.lfUnderline)
		_dwEffects &= ~CFE_UNDERLINE;

	if(!lf.lfStrikeOut)
		_dwEffects &= ~CFE_STRIKEOUT;

	_wWeight		= (WORD)lf.lfWeight;
	_lcid			= GetSystemDefaultLCID();
	_iCharRep		= CharRepFromCharSet(lf.lfCharSet);
	_bPitchAndFamily= lf.lfPitchAndFamily;
	_iFont			= GetFontNameIndex(lf.lfFaceName);
	_bUnderlineType	= CFU_UNDERLINE;			// Default solid underlines
												// Are gated by CFE_UNDERLINE
	// Qualify the charformat produced by incoming hfont before exit.
	// We did this to make sure that the charformat we derived from hfont is usable
	// since caller can send us bad font like given facename can't handle given charset.
	if (!fUseStockFont)
	{
		QWORD qwFontSig;
		if (GetFontSignatureFromFace(_iFont, &qwFontSig) &&
			!(FontSigFromCharRep(_iCharRep) & qwFontSig))
			_iCharRep = GetFirstAvailCharRep(qwFontSig);
		_bQuality = lf.lfQuality;
	}

	// Initialize to no temp. display attr.
	_sTmpDisplayAttrIdx = -1;

#ifdef DEBUG
	_pchFaceName = GetFontName((LONG)_iFont);
#endif
	return NOERROR;
}

/*
 *	CCharFormat::Set(pCF, CodePage)
 *
 *	@mfunc
 *		Copy the CHARFORMAT or CHARFORMAT2 *<p pCF> to this CCharFormat 
 */
void CCharFormat::Set (
	const CHARFORMAT2 *pCF2, 	//@parm	CHARFORMAT to copy to this CCharFormat
	UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Set");
	
	_dwEffects			= pCF2->dwEffects;
	_iCharRep			= CharRepFromCharSet(pCF2->bCharSet);
	_bPitchAndFamily	= pCF2->bPitchAndFamily;
	if(pCF2->dwMask & CFM_FACE)
	{
		AssertSz((CodePage != 1200) ^ IsValidCharFormatW(pCF2),
			"CCharFormat::Set: wrong codepage for CHARFORMAT");

		if(CodePage != 1200)
		{
			WCHAR sz[LF_FACESIZE + 1];
			UnicodeFromMbcs(sz, LF_FACESIZE, (char *)pCF2->szFaceName, LF_FACESIZE,
							CodePage);
			_iFont		= GetFontNameIndex(sz);
		}
		else
			_iFont		= GetFontNameIndex(pCF2->szFaceName);
	}
	_yHeight			= Get16BitTwips(pCF2->yHeight);
	_yOffset			= Get16BitTwips(pCF2->yOffset);
	_crTextColor		= pCF2->crTextColor;
	

	UINT cb = pCF2->cbSize;
	if(cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))
	{
		_dwEffects |= CFE_AUTOBACKCOLOR;
		_bUnderlineType = CFU_UNDERLINE;
		ZeroMemory((LPBYTE)&_wWeight,
			sizeof(CCharFormat) - offsetof(CCharFormat, _wWeight));
#ifdef DEBUG
		_pchFaceName = GetFontName((LONG)_iFont);
#endif
		return;
	}

	char *pvoid = (char *)&pCF2->wWeight;
	if(pCF2->cbSize == sizeof(CHARFORMAT2A))
		pvoid -= sizeof(CHARFORMAT2W) - sizeof(CHARFORMAT2A);
	else
		Assert(pCF2->cbSize == sizeof(CHARFORMAT2));// Better be a CHARFORMAT2

	CopyMemory(&_wWeight, pvoid, 3*sizeof(DWORD));
	CopyMemory(&_sStyle,  pvoid + 4*sizeof(DWORD),  2*sizeof(DWORD));

#ifdef DEBUG
	_pchFaceName = GetFontName((LONG)_iFont);
#endif
}


//------------------------- CParaFormat Class -----------------------------------

/*
 *	CParaFormat::AddTab(tbPos, tbAln, tbLdr, prgxTabs)
 *
 *	@mfunc
 *		Add tabstop at position <p tbPos>, alignment type <p tbAln>, and
 *		leader style <p tbLdr>
 *
 *	@rdesc
 *		(success) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Tab struct that overlays LONG in internal _rgxTabs is
 *
 *			DWORD	tabPos : 24;
 *			DWORD	tabType : 4;
 *			DWORD	tabLeader : 4;
 */
HRESULT CParaFormat::AddTab (
	LONG	tbPos,		//@parm New tab position
	LONG	tbAln,		//@parm New tab alignment type
	LONG	tbLdr,		//@parm New tab leader style
	LONG *	prgxTabs)	//@parm Where the tabs are
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::AddTab");

	if (IsTableRowDelimiter() ||
		(DWORD)tbAln > tomAlignBar ||			// Validate arguments
		(DWORD)tbLdr > tomEquals ||				// Comparing DWORDs causes
		(DWORD)tbPos > 0xffffff || !tbPos)		//  negative values to be
	{											//  treated as invalid
		return E_INVALIDARG;
	}

	LONG iTab;
	LONG tbValue = tbPos + (tbAln << 24) + (tbLdr << 28);

	for(iTab = 0; iTab < _bTabCount &&			// Determine where to
		tbPos > GetTabPos(prgxTabs[iTab]); 		//  insert new tabstop
		iTab++) ;

	if(iTab >= MAX_TAB_STOPS)
		return S_FALSE;

	LONG tbPosCurrent = GetTabPos(prgxTabs[iTab]);
	if(iTab == _bTabCount || tbPosCurrent != tbPos)
	{
		if(_bTabCount >= MAX_TAB_STOPS)
			return S_FALSE;

		MoveMemory(&prgxTabs[iTab + 1],			// Shift array down
			&prgxTabs[iTab],					//  (unless iTab = Count)
			(_bTabCount - iTab)*sizeof(LONG));

		_bTabCount++;							// Increment tab count
	}
	prgxTabs[iTab] = tbValue;
	return NOERROR;
}

/*
 *	CParaFormat::Apply(pPF, dwMask, dwMask2)
 *
 *	@mfunc
 *		Apply *<p pPF> to this CParaFormat as specified by nonzero bits in
 *		<p pPF>->dwMask
 *
 *	@rdesc
 *		HRESULT = E_INVALIDARG or NOERROR
 */
HRESULT CParaFormat::Apply (
	const CParaFormat *pPF,	//@parm CParaFormat to apply to this PF
	DWORD	dwMask,			//@parm mask to use
	DWORD	dwMask2)		//@parm Mask for additional internal parms
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Apply");

	const DWORD dwMaskApply	= dwMask;
	BOOL		fPF = dwMask2 & PFM2_PARAFORMAT;
	WORD		wEffectMask;

	if(dwMaskApply & PFM_NUMBERING)
		_wNumbering = pPF->_wNumbering;

	if(dwMaskApply & PFM_OFFSET)
	{
		if (!IsValidTwip(pPF->_dxOffset))
			return E_INVALIDARG;
		_dxOffset = pPF->_dxOffset;
	}

	if(dwMaskApply & PFM_STARTINDENT)
	{
		if (!IsValidTwip(pPF->_dxStartIndent))
			return E_INVALIDARG;

		_dxStartIndent = pPF->_dxStartIndent;
	}
	else if(dwMaskApply & PFM_OFFSETINDENT)
	{
		if (!IsValidTwip(pPF->_dxStartIndent))
			return E_INVALIDARG;

		// bug fix #5761
		LONG dx = max(0, _dxStartIndent + pPF->_dxStartIndent);

		// Disallow shifts that move start of first or subsequent lines left of left margin.
		// Normally we just make indent zero in paraformat check below, 
		//	but in the case of bullet we want some space left.
		
		if(!_wNumbering || dx + _dxOffset >= 0)
			_dxStartIndent = dx;
	}

	if(dwMaskApply & PFM_RIGHTINDENT)
	{
		if (!IsValidTwip(pPF->_dxRightIndent))
			return E_INVALIDARG;

		_dxRightIndent = pPF->_dxRightIndent;
	}

	if(dwMaskApply & PFM_ALIGNMENT)
	{
		if(!fPF && !IN_RANGE(PFA_LEFT, pPF->_bAlignment, PFA_SNAP_GRID))
		{
			TRACEERRORSZ("CParaFormat::Apply: invalid Alignment ignored");
			return E_INVALIDARG;
		}
		if(pPF->_bAlignment <= PFA_SNAP_GRID)
			_bAlignment = pPF->_bAlignment;
	}

	// Reset effect bits to be modified and OR in supplied values
	wEffectMask	= (WORD)((dwMaskApply >> 16) |
						 (dwMask2 & PFM2_TABLEROWSHIFTED));
	_wEffects &= ~wEffectMask;				
	_wEffects |= pPF->_wEffects & wEffectMask;

	if(dwMaskApply & PFM_TABSTOPS)
	{
		LONG cmax  = IsTableRowDelimiter() ? MAX_TABLE_CELLS :	MAX_TAB_STOPS;
		_bTabCount = (BYTE)min(pPF->_bTabCount, cmax);
		_bTabCount = (BYTE)max(_bTabCount, 0);
		_iTabs	   = pPF->_iTabs;
		AssertSz(!_bTabCount || _iTabs >= 0,
			"CParaFormat::Apply: illegal _iTabs value");
	}

	if ((dwMaskApply & PFM_RTLPARA) && !(dwMaskApply & PFM_ALIGNMENT) &&
		_bAlignment != PFA_CENTER)
	{
		_bAlignment = IsRtlPara() ? PFA_RIGHT : PFA_LEFT;
	}

	// PARAFORMAT check
	if(fPF)
	{
		if(dwMaskApply & (PFM_STARTINDENT | PFM_OFFSET))
		{
			if(_dxStartIndent < 0)				// Don't let indent go
				_dxStartIndent = 0;				//  negative

			if(_dxStartIndent + _dxOffset < 0)	// Don't let indent +
				_dxOffset = -_dxStartIndent;	//  offset go negative
		}
		return NOERROR;							// Nothing more for
	}											//  PARAFORMAT

	// PARAFORMAT2 extensions
	if(dwMaskApply & PFM_SPACEBEFORE)
	{
		_dySpaceBefore = 0;

		if (pPF->_dySpaceBefore > 0)
			_dySpaceBefore	= pPF->_dySpaceBefore;
	}

	if(dwMaskApply & PFM_SPACEAFTER)
	{
		_dySpaceAfter = 0;

		if (pPF->_dySpaceAfter > 0)
			_dySpaceAfter	= pPF->_dySpaceAfter;
	}

	if(dwMaskApply & PFM_LINESPACING)
	{
		_dyLineSpacing	  = pPF->_dyLineSpacing;
		_bLineSpacingRule = pPF->_bLineSpacingRule;
	}

	if(dwMaskApply & PFM_OUTLINELEVEL)
		_bOutlineLevel	= pPF->_bOutlineLevel;

	if(dwMaskApply & PFM_STYLE)
		HandleStyle(pPF->_sStyle);

	Assert((_bOutlineLevel & 1) ^ IsHeadingStyle(_sStyle));

	if(dwMaskApply & PFM_SHADING)
	{
		_wShadingWeight	= pPF->_wShadingWeight;
		_wShadingStyle	= pPF->_wShadingStyle;
	}

	if(dwMaskApply & PFM_NUMBERINGSTART)
		_wNumberingStart = pPF->_wNumberingStart;

	if(dwMaskApply & PFM_NUMBERINGSTYLE)
		_wNumberingStyle = pPF->_wNumberingStyle;

	if(dwMaskApply & PFM_NUMBERINGTAB)
		_wNumberingTab	= pPF->_wNumberingTab;

	if(dwMaskApply & PFM_BORDER)
	{
		_dwBorderColor	= pPF->_dwBorderColor;
		_wBorders		= pPF->_wBorders;
		_wBorderSpace	= pPF->_wBorderSpace;
		_wBorderWidth	= pPF->_wBorderWidth;
	}

	if(dwMaskApply & PFM_TABLE)
		_bTableLevel	= pPF->_bTableLevel;


#ifdef DEBUG
	ValidateTabs();
	AssertSz((!(_wEffects & PFE_TABLE) || _bTableLevel) && _bTableLevel >= 0,
		"CParaFormat::Apply: invalid table level");
#endif // DEBUG

	return NOERROR;
}

/*
 *	CParaFormat::ApplyDefaultStyle(Style)
 *
 *	@mfunc	
 *		Copy default properties for Style
 */
void CParaFormat::ApplyDefaultStyle (
	LONG Style)		//@parm Style to apply
{
	Assert(IsKnownStyle(Style));

	if(IsHeadingStyle(Style))				// Set Style's dySpaceBefore,
	{										//  dySpaceAfter (in twips)
		_dySpaceBefore = 12*20;				//  (same for all headings)
		_dySpaceAfter  =  3*20;
		_wNumbering	   = 0;					// No numbering
	}
}

/*
 *	CParaFormat::DeleteTab(tbPos)
 *
 *	@mfunc
 *		Delete tabstop at position <p tbPos>
 *
 *	@rdesc
 *		(success) ? NOERROR : S_FALSE
 */
HRESULT CParaFormat::DeleteTab (
	LONG	tbPos,			//@parm Tab position to delete
	LONG *	prgxTabs)		//@parm Tab array to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::DeleteTab");

	if(tbPos <= 0 || IsTableRowDelimiter())
		return E_INVALIDARG;

	LONG Count	= _bTabCount;
	for(LONG iTab = 0; iTab < Count; iTab++)	// Find tabstop for position
	{
		if(GetTabPos(prgxTabs[iTab]) == tbPos)
		{
			MoveMemory(&prgxTabs[iTab],			// Shift array down
				&prgxTabs[iTab + 1],			//  (unless iTab is last tab)
				(Count - iTab - 1)*sizeof(LONG));
			_bTabCount--;						// Decrement tab count and
			return NOERROR;						//  signal no error
		}
	}
	return S_FALSE;
}

/*
 *	CParaFormat::Delta(pPF, fPARAFORMAT)
 *
 *	@mfunc
 *		return mask of differences between this CParaFormat and *<p pPF>.
 *		1-bits indicate corresponding parameters differ; 0 indicates they
 *		are the same
 *
 *	@rdesc
 *		mask of differences between this CParaFormat and *<p pPF>
 */
DWORD CParaFormat::Delta (
	CParaFormat *pPF,		 		//@parm	CParaFormat to compare this
	BOOL		fPARAFORMAT) const	//		CParaFormat to
{									
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Delta");

	LONG dwT = 0;								// No differences yet

	if(_wNumbering	  != pPF->_wNumbering)
		dwT |= PFM_NUMBERING;					// _wNumbering values differ

	if(_dxStartIndent != pPF->_dxStartIndent)
		dwT |= PFM_STARTINDENT;					// ...

	if(_dxRightIndent != pPF->_dxRightIndent)
		dwT |= PFM_RIGHTINDENT;

	if(_dxOffset	  != pPF->_dxOffset)
		dwT |= PFM_OFFSET;

	if(_bAlignment	  != pPF->_bAlignment)
		dwT |= PFM_ALIGNMENT;

	AssertSz(pPF->_bTabCount >= 0 && pPF->_bTabCount <= 
			(pPF->IsTableRowDelimiter() ? MAX_TABLE_CELLS : MAX_TAB_STOPS),
		"RTR::GetParaFormat(): illegal tab count");

	if (_bTabCount != pPF->_bTabCount)
		dwT |= PFM_TABSTOPS;
	else if (_bTabCount > 0)
	{
		const LONG	*pTabs1 = GetTabs();
		const LONG	*pTabs2 = pPF->GetTabs();
		LONG cb = _bTabCount * sizeof(LONG);

		if(IsTableRowDelimiter())
			cb *= CELL_EXTRA + 1;
		if (pTabs1 != pTabs2 &&
			(pTabs1 == 0 || pTabs2 == 0 || CompareMemory(pTabs1, pTabs2, cb)))
			dwT |= PFM_TABSTOPS;
	}

	dwT |= (_wEffects ^ pPF->_wEffects) << 16;


	if(!fPARAFORMAT)
	{
		if(_dySpaceBefore	!= pPF->_dySpaceBefore)
			dwT |= PFM_SPACEBEFORE;

		if(_dySpaceAfter	!= pPF->_dySpaceAfter)
			dwT |= PFM_SPACEAFTER;

		if (_dyLineSpacing	!= pPF->_dyLineSpacing	||
		   _bLineSpacingRule!= pPF->_bLineSpacingRule)
		{
			dwT |= PFM_LINESPACING;
		}

		if(_sStyle			!= pPF->_sStyle)
			dwT |= PFM_STYLE;

		if (_wShadingWeight	!= pPF->_wShadingWeight ||
			_wShadingStyle	!= pPF->_wShadingStyle)
		{
			dwT |= PFM_SHADING;
		}

		if(_wNumberingStart	!= pPF->_wNumberingStart)
			dwT |= PFM_NUMBERINGSTART;

		if(_wNumberingStyle	!= pPF->_wNumberingStyle)
			dwT |= PFM_NUMBERINGSTYLE;

		if(_wNumberingTab	!= pPF->_wNumberingTab)
			dwT |= PFM_NUMBERINGTAB;

		if (_wBorders		!= pPF->_wBorders	 ||
			_wBorderWidth	!= pPF->_wBorderWidth ||
			_wBorderSpace	!= pPF->_wBorderSpace ||
			_dwBorderColor	!= pPF->_dwBorderColor)
		{
			dwT |= PFM_BORDER;
		}
		if(_bTableLevel != pPF->_bTableLevel)
			dwT |= PFM_TABLEROWDELIMITER;
	}

	return dwT;
}		

#define PFM_IGNORE	(PFM_OUTLINELEVEL | PFM_COLLAPSED | PFM_BOX | PFM_TABLE | PFM_TABLEROWDELIMITER)

/*
 *	CParaFormat::fSetStyle(dwMask, dwMask2)
 *
 *	@mfunc
 *		Return TRUE iff this PF specifies that the style should be set.
 *		See code for list of conditions for this to be true
 *
 *	@rdesc
 *		TRUE iff pCF specifies that the style _sStyle should be set
 */
BOOL CParaFormat::fSetStyle(
	DWORD	dwMask,			//@parm mask to use
	DWORD	dwMask2) const	//@parm Mask for additional internal parms
{
	return	(dwMask & ~PFM_IGNORE) != (PFM_ALL2 & ~(PFM_TABLE | PFM_TABLEROWDELIMITER)) &&
			!(dwMask2 & (PFM2_PARAFORMAT | PFM2_ALLOWTRDCHANGE))		&&
			dwMask & PFM_STYLE && IsKnownStyle(_sStyle);
}

/*
 *	CParaFormat::Get(pPF2)
 *
 *	@mfunc
 *		Copy this CParaFormat to *<p pPF>
 */
void CParaFormat::Get (
	PARAFORMAT2 *pPF2) const	//@parm	PARAFORMAT2 to copy this CParaFormat to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Get");

	LONG cb = pPF2->cbSize;

	pPF2->dwMask = PFM_ALL2;					// Default PARAFORMAT2
	if(cb != sizeof(PARAFORMAT2))				// It isn't
	{
		pPF2->dwMask = PFM_ALL;					// Make it PARAFORMAT
		Assert(cb == sizeof(PARAFORMAT));		// It better be a PARAFORMAT
	}
	CopyMemory(&pPF2->wNumbering, &_wNumbering, (char *)&_bAlignment - (char *)&_wNumbering);
	pPF2->wAlignment = _bAlignment;
	pPF2->cTabCount	= _bTabCount;

	LONG cb1 = _bTabCount*sizeof(LONG);
	if(_bTabCount)
	{
		// Need API for handling table cells. For now, just don't overwrite
		// pPF2->rgxTabs[].
		cb1 = min(cb1, (LONG)MAX_TAB_STOPS*sizeof(LONG));
		AssertSz(_iTabs >= 0,
			"CParaFormat::Get: illegal _iTabs value");
		CopyMemory(pPF2->rgxTabs, GetTabsCache()->Deref(_iTabs), cb1);
	}
	ZeroMemory(pPF2->rgxTabs + _bTabCount, MAX_TAB_STOPS*sizeof(LONG) - cb1);
	CopyMemory(&pPF2->dySpaceBefore, &_dySpaceBefore,
			   cb - offsetof(PARAFORMAT2, dySpaceBefore));
}

/*
 *	CParaFormat::GetRTLRowLength()
 *
 *	@mfunc
 *		Get the length of the current row if this CParaFormat is a table
 *		row delimiter with a PFE_RTLPara effect.
 *
 *	@rdesc
 *		Length of current row if PFE_TABLEROWDELIMITER and PFE_RTLPARA are
 *		on; else 0
 */
LONG CParaFormat::GetRTLRowLength() const
{
	if ((_wEffects & (PFE_TABLEROWDELIMITER | PFE_RTLPARA))
		!= (PFE_TABLEROWDELIMITER | PFE_RTLPARA))
	{
		return 0;							// Not an RTL row
	}

	const CELLPARMS * prgCellParms = GetCellParms();

	for(LONG i = 0, dulRTLRow = 0; i < _bTabCount; i++)
		dulRTLRow += GetCellWidth(prgCellParms[i].uCell);

	return dulRTLRow;
}

/*
 *	CParaFormat::GetTab (iTab, ptbPos, ptbAln, ptbLdr, prgxTabs)
 *
 *	@mfunc
 *		Get tab parameters for the <p iTab> th tab, that is, set *<p ptbPos>,
 *		*<p ptbAln>, and *<p ptbLdr> equal to the <p iTab> th tab's
 *		displacement, alignment type, and leader style, respectively.  The
 *		displacement is given in twips.
 *
 *	@rdesc
 *		HRESULT = (no <p iTab> tab)	? E_INVALIDARG : NOERROR
 */
HRESULT CParaFormat::GetTab (
	long	iTab,				//@parm Index of tab to retrieve info for
	long *	ptbPos,				//@parm Out parm to receive tab displacement
	long *	ptbAln,				//@parm Out parm to receive tab alignment type
	long *	ptbLdr,				//@parm Out parm to receive tab leader style
	const LONG *prgxTabs) const	//@parm Tab array
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEEXTERN, "CParaFormat::GetTab");

	AssertSz(ptbPos && ptbAln && ptbLdr,
		"CParaFormat::GetTab: illegal arguments");

	if(IsTableRowDelimiter())
		return E_INVALIDARG;

	if(iTab < 0)									// Get tab previous to, at,
	{												//  or subsequent to the
		if(iTab < tomTabBack)						//  position *ptbPos
			return E_INVALIDARG;

		LONG i;
		LONG tbPos = *ptbPos;
		LONG tbPosi;

		*ptbPos = 0;								// Default tab not found
		for(i = 0; i < _bTabCount &&				// Find *ptbPos
			tbPos > GetTabPos(prgxTabs[i]); 
			i++) ;

		tbPosi = GetTabPos(prgxTabs[i]);			// tbPos <= tbPosi
		if(iTab == tomTabBack)						// Get tab info for tab
			i--;									//  previous to tbPos
		else if(iTab == tomTabNext)					// Get tab info for tab
		{											//  following tbPos
			if(tbPos == tbPosi)
				i++;
		}
		else if(tbPos != tbPosi)					// tomTabHere
			return S_FALSE;

		iTab = i;		
	}
	if((DWORD)iTab >= (DWORD)_bTabCount)			// DWORD cast also
		return E_INVALIDARG;						//  catches values < 0

	iTab = prgxTabs[iTab];
	*ptbPos = GetTabPos(iTab);
	*ptbAln = GetTabAlign(iTab);
	*ptbLdr = GetTabLdr(iTab);
	return NOERROR;
}

/*
 *	CParaFormat::GetTabs ()
 *
 *	@mfunc
 *		Get ptr to tab array.  Use GetTabPos(), GetTabAlign(), and
 *		GetTabLdr() to access the tab position, alignment, and leader
 *		type, respectively.
 *
 *	@rdesc
 *		Ptr to tab array.
 */
const LONG * CParaFormat::GetTabs () const
{
	return GetTabsCache()->Deref(_iTabs);
}

/*
 *	CParaFormat::HandleStyle(Style)
 *
 *	@func
 *		If Style is a promote/demote command, i.e., if abs((char)Style)
 *			<= # heading styles - 1, add (char)Style to	sStyle (if heading)
 *			and to bOutlineLevel (subject to defined max and min values);
 *		else sStyle = Style.
 *
 *	@rdesc
 *		return TRUE iff sStyle or bOutlineLevel changed
 *
 *	@devnote
 *		Heading styles are -2 (heading 1) through -10 (heading 9), which
 *		with TOM and WOM. Heading outline levels are 0, 2,..., 16,
 *		corresponding to headings 1 through 9 (NHSTYLES), respectively,
 *		while text that follows has outline levels 1, 3,..., 17.  This value
 *		is used for indentation. Collapsed text has the PFE_COLLAPSED bit set.
 */
BOOL CParaFormat::HandleStyle(
	LONG Style)		//@parm Style, promote/demote code, or collapse-level code
{
	if(IsStyleCommand(Style))					// Set collapse level
	{											
		WORD wEffectsSave = _wEffects;			

		Style = (char)Style;					// Sign extend low byte
		if(IN_RANGE(1, Style, NHSTYLES))
		{
			_wEffects &= ~PFE_COLLAPSED;
			if((_bOutlineLevel & 1) || _bOutlineLevel > 2*(Style - 1))
				_wEffects |= PFE_COLLAPSED;		// Collapse nonheadings and
		}										//  higher numbered headings
		else if(Style == -1)
			_wEffects &= ~PFE_COLLAPSED;		// Expand all

		return _wEffects != wEffectsSave;		// Return whether something
	}											//  changed

	// Ordinary Style specification
	BYTE bLevel = _bOutlineLevel;
	_bOutlineLevel |= 1;						// Default not a heading
	if(IsHeadingStyle(Style))					// Headings have levels
	{											//  0, 2,..., 16, while the
		_bOutlineLevel = -2*(Style				//  text that follows has
						 - STYLE_HEADING_1);	//  1, 3,..., 17.
	}
	if(_sStyle == Style && bLevel == _bOutlineLevel)
		return FALSE;							// No change

	_sStyle = (SHORT)Style;						
	return TRUE;
}

/*
 *	CParaFormat::InitDefault(wDefEffects)
 *
 *	@mfunc
 *		Initialize this CParaFormat with default paragraph formatting
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CParaFormat::InitDefault(
	WORD wDefEffects)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::InitDefault");
	
	ZeroMemory(this, sizeof(CParaFormat));
	_bAlignment		= PFA_LEFT;
	_sStyle			= STYLE_NORMAL;			// Default style
	_wEffects		= wDefEffects;
	_bOutlineLevel	= 1;					// Default highest text outline
	_iTabs			= -1;					//  level
											
#if lDefaultTab <= 0
#error "default tab (lDefaultTab) must be > 0"
#endif

	return NOERROR;
}

/*
 *	CParaFormat::NumToStr(pch, n)
 *
 *	@mfunc	
 *		Convert the list number n to a string taking into consideration
 *		CParaFormat::wNumbering, wNumberingStart, and wNumberingStyle
 *	
 *	@rdesc
 *		cch of string converted
 */
LONG CParaFormat::NumToStr(
	TCHAR *	pch,				//@parm Target string
	LONG	n,					//@parm Number + 1 to convert
	DWORD   grf) const			//@parm Collection of flags
{
	if(IsNumberSuppressed())
	{
		*pch = 0;
		return 0;								// Number/bullet suppressed
	}

	if(!n)										// Bullet of some kind
	{											// CParaFormat::wNumbering
		*pch++ = (_wNumbering > ' ')			//  values > ' ' are Unicode
			   ? _wNumbering : 0x00B7;			//  bullets. Else use bullet
		return 1;								//  in symbol font
	}

	// Numbering of some kind
	//							 i  ii  iii  iv v  vi  vii  viii   ix
	const BYTE RomanCode[]	  = {1, 5, 0x15, 9, 2, 6, 0x16, 0x56, 0xd};
	const char RomanLetter[] = "ivxlcdmno";
	BOOL		fRtlPara = IsRtlPara() && !(grf & fRtfWrite);
	LONG		RomanOffset = 0;
	LONG		cch	= 0;						// No chars yet
	WCHAR		ch	= fRtlPara && (grf & fIndicDigits) ? 0x0660 : '0';	
												// Default char code offset
	LONG		d	= 1;						// Divisor
	LONG		r	= 10;						// Default radix 
	LONG   		quot, rem;						// ldiv result
	LONG		Style = (_wNumberingStyle << 8) & 0xF0000;

	n--;										// Convert to number offset
	if(Style == tomListParentheses ||			// Numbering like: (x)
	   fRtlPara && Style == 0)					// or 1) in bidi text.
	{										
		cch = 1;								// Store leading lparen
		*pch++ = '(';
	}
	else if (Style == tomListPeriod && fRtlPara)
	{
		cch = 1;
		*pch++ = '.';
		Style = tomListPlain;
	}

	if(_wNumbering == tomListNumberAsSequence)
		ch = _wNumberingStart;					// Needs generalizations, e.g.,
												//  appropriate radix
	else
	{
		n += _wNumberingStart;
		if(IN_RANGE(tomListNumberAsLCLetter, _wNumbering, tomListNumberAsUCLetter))
		{
			ch = (_wNumbering == tomListNumberAsLCLetter) ? 'a' : 'A';
			if(_wNumberingStart >= 1)
				n--;
			r = 26;								// LC or UC alphabetic number
		}										// Radix 26
	}

	while(d < n)
	{
		d *= r;									// d = smallest power of r > n
		RomanOffset += 2;
	}
	if(n && d > n)
	{
		d /= r;
		RomanOffset -= 2;
	}

	while(d)
	{
		quot = n / d;
		rem = n % d;
		if(IN_RANGE(tomListNumberAsLCRoman, _wNumbering, tomListNumberAsUCRoman))
		{
			if(quot)
			{
				n = RomanCode[quot - 1];
				while(n)
				{
					ch = RomanLetter[(n & 3) + RomanOffset - 1];
					if(_wNumbering == tomListNumberAsUCRoman)
						ch &= 0x5F;
					*pch++ = ch;
					n >>= 2;
					cch++;
				}
			}
			RomanOffset -= 2;
		}
		else
		{
			n = quot + ch;
			if(r == 26 && d > 1)				// If alphabetic higher-order
				n--;							//  digit, base it on 'a' or 'A'
			*pch++ = (WORD)n;					// Store digit
			cch++;
		}
		n = rem;								// Setup remainder
		d /= r;
	}
	if (Style != tomListPlain &&				// Trailing text
		(!fRtlPara || Style))
	{											// We only do rparen or period
		*pch++ = (Style == tomListPeriod) ? '.' : ')';

		cch++;
	}
	
	*pch = 0;									// Null terminate for RTF writer
	return cch;
}

/*
 *	CParaFormat::Set(pPF2)
 *
 *	@mfunc
 *		Copy PARAFORMAT or PARAFORMAT2 *<p pPF> to this CParaFormat 
 */
void CParaFormat::Set (
	const PARAFORMAT2 *pPF2) 	//@parm	PARAFORMAT to copy to this CParaFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Set");

	CopyMemory(&_wNumbering, &pPF2->wNumbering,
			   (char *)&_bAlignment - (char *)&_wNumbering);
	_bAlignment = (BYTE)pPF2->wAlignment;

	_iTabs = -1;
	_bTabCount = 0;
	_wEffects &= ~PFE_TABLEROWDELIMITER;

	if((pPF2->dwMask & PFM_TABSTOPS) && pPF2->cTabCount)
	{
		LONG cTab = min(pPF2->cTabCount, MAX_TAB_STOPS);
		if (pPF2->dwMask   & PFM_TABLEROWDELIMITER &&
			pPF2->wEffects & PFE_TABLEROWDELIMITER)
		{
			// TODO: create an API for setting cell info
		}
		else
		{
			_bTabCount = cTab;
			_iTabs = GetTabsCache()->Cache(pPF2->rgxTabs, cTab);
		}
	}

	if(pPF2->dwMask & ~PFM_ALL)
	{
		Assert(pPF2->cbSize == sizeof(PARAFORMAT2));

		CopyMemory(&_dySpaceBefore, &pPF2->dySpaceBefore,
			sizeof(PARAFORMAT2) - offsetof(PARAFORMAT2, dySpaceBefore));
	}

#ifdef DEBUG
	ValidateTabs();
#endif // DEBUG
}

/*
 *	CParaFormat::UpdateNumber(n, pPF)
 *
 *	@mfunc
 *		Return new value of number for paragraph described by this PF
 *		following a paragraph described by pPF
 *
 *	@rdesc
 *		New number for paragraph described by this PF
 */
LONG CParaFormat::UpdateNumber (
	LONG  n,						//@parm Current value of number
	const CParaFormat *pPF) const	//@parm Previous CParaFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::UpdateNumber");

	if(!IsListNumbered())			
		return 0;						// No numbering

	if(IsNumberSuppressed())
		return n;						// Number is suppressed, so no change

	if (!pPF || (pPF->_wEffects & PFE_TABLEROWDELIMITER) ||
		_wNumbering != pPF->_wNumbering ||
		(_wNumberingStyle & PFNS_NEWNUMBER) ||
		(_wNumberingStyle != pPF->_wNumberingStyle && !pPF->IsNumberSuppressed()) ||
		_wNumberingStart != pPF->_wNumberingStart)
	{									// Numbering type or style
		return 1;						//  changed, so start over
	}
	return n + 1;						// Same kind of numbering,
}

#ifdef DEBUG
/*
 *	CParaFormat::ValidateTabs()
 *
 *	@mfunc
 *		Makes sure that a set of tabs would make sense for a non-table
 *		paragraph. Is called in places where we have set the tabs.
 *
 *	@rdesc
 *		None.
 */
void CParaFormat::ValidateTabs()
{
	if (_wEffects & PFE_TABLE)
	{
		// It would be nice to assert something reasonable here. However, the
		// rtf reader insists on setting things inconsistenly and I don't
		// have time at the moment to figure out why. (a-rsail)
		//	AssertSz((_bTabCount != 0),
		//	"CParaFormat::ValidateTabs: table with invalid tab count ");
		
		return;
	}

	// Non-table case.

	// It would be nice to assert on the consistency between these _bTabCount and _iTabs
	// but rtf reader has troubles with this. 
	//	AssertSz(((_bTabCount != 0) && (-1 != _iTabs)) || ((-1 == _iTabs) && (0 == _bTabCount)), 
	//	"CParaFormat::ValidateTabs: tab count and default tab index inconsistent");

	if (-1 == _iTabs)
	{
		// No tabs to validate so we are done.
		return;
	}

	const LONG *prgtabs = GetTabs();

	AssertSz(prgtabs != NULL, "CParaFormat::ValidateTabs: missing tab table");

	for (int i = 0; i < _bTabCount; i++)
	{
		AssertSz(GetTabAlign(prgtabs[i]) <= tomAlignBar,
			"CParaFormat::ValidateTabs: Invalid tab being set");
	}
}
#endif // DEBUG

/*
 *	CELLPARMS::ICellFromUCell(prgCell, dul, cCell)
 *
 *	@mfunc
 *		Return iCell such that SUM(CellWidths[iCell]) == dul. Return -1 if
 *		no dul is found in prgCell
 *
 *	@rdesc
 *		iCell such that SUM(CellWidths[iCell]) == dul
 */
LONG CELLPARMS::ICellFromUCell(
	LONG dul,					//@parm Logical x offset of cell right border
	LONG cCell) const			//@parm Count of cells in array
{
	const CELLPARMS *prgCell = this;
	LONG x = 0;

	for(LONG i = 0; i < cCell; i++)
	{
		x += GetCellWidth(prgCell[i].uCell);
		if(x == dul)
			return i;
	}
	return -1;
}


//------------------------- Helper Functions -----------------------------------

// Defines and fixed font size details for increasing/decreasing font size
#define PWD_FONTSIZEPOINTMIN    1
// The following corresponds to the max signed 2-byte TWIP value, (32760)
#define PWD_FONTSIZEPOINTMAX    1638    

typedef struct tagfsFixup
{
    BYTE EndValue;
    BYTE Delta;
}
FSFIXUP;

const FSFIXUP fsFixups[] =
{
    12, 1,
    28, 2,
    36, 0,
    48, 0,
    72, 0,
    80, 0,
  	 0, 10			// EndValue = 0 case is treated as "infinite"
};

#define PWD_FONTSIZEMAXFIXUPS   (sizeof(fsFixups)/sizeof(fsFixups[0]))

/*
 *	GetUsableFontHeight(ySrcHeight, lPointChange)
 *
 *	@func
 *		Return a font size for setting text or insertion point attributes
 *
 *	@rdesc
 *		New TWIPS height
 *
 *	@devnote
 *		Copied from WinCE RichEdit code (written by V-GUYB)
 */
LONG GetUsableFontHeight(
	LONG ySrcHeight,		//@parm Current font size in twips
	LONG lPointChange)		//@parm Increase in pt size, (-ve if shrinking)
{
	LONG	EndValue;
	LONG	Delta;
    int		i;
    LONG	yRetHeight;

    // Input height in twips here, (TWentIeths of a Point).
    // Note, a Point is a 1/72th of an inch. To make these
    // calculations clearer, use point sizes here. Input height
    // in twips is always divisible by 20 (NOTE (MS3): maybe with
	// a truncation, since RTF uses half-point units).
    yRetHeight = (ySrcHeight / 20) + lPointChange;

    // Fix new font size to match sizes used by Word95
    for(i = 0; i < PWD_FONTSIZEMAXFIXUPS; ++i)
    {
		EndValue = fsFixups[i].EndValue;
		Delta	 = fsFixups[i].Delta;

        // Does new height lie in this range of point sizes?
        if(yRetHeight <= EndValue || !EndValue)
        {
            // If new height = EndValue, then it doesn't need adjusting
            if(yRetHeight != EndValue)
            {
                // Adjust new height to fit this range of point sizes. If
                // Delta = 1, all point sizes in this range stay as they are.
                if(!Delta)
                {
                    // Everything in this range is rounded to the EndValue
                    yRetHeight = fsFixups[(lPointChange > 0 ?
                                    i : max(i - 1, 0))].EndValue;
                }
                else if(Delta != 1)
                {
                    // Round new height to next delta in this range
                    yRetHeight = ((yRetHeight +
                        (lPointChange > 0 ? Delta - 1 : 0))
                                / Delta) * Delta;
                }
            }
            break;
        }
    }

    // Limit the new text size. Note, if we fix the text size
    // now, then we won't take any special action if we change
    // the text size later in the other direction. For example,
    // we shrink chars with size 1 and 2. They both change to
    // size 1. Then we grow them both to 2. So they are the
    // same size now, even though they weren't before. This
    // matches Word95 behavior.
    yRetHeight = max(yRetHeight, PWD_FONTSIZEPOINTMIN);
    yRetHeight = min(yRetHeight, PWD_FONTSIZEPOINTMAX);

    return yRetHeight*20;			// Return value in twips
}

/*
 *	IsValidCharFormatW(pCF)
 *
 *	@func
 *		Return TRUE iff the structure *<p pCF> has the correct size to be
 *		a CHARFORMAT or a CHARFORMAT2
 *
 *	@rdesc
 *		Return TRUE if *<p pCF> is a valid CHARFORMAT(2)
 */
BOOL IsValidCharFormatW (
	const CHARFORMAT * pCF) 		//@parm CHARFORMAT to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidCharFormat");

	return pCF && (pCF->cbSize == sizeof(CHARFORMATW) ||
				   pCF->cbSize == sizeof(CHARFORMAT2W));
}

/*
 *	IsValidCharFormatA(pCFA)
 *
 *	@func
 *		Return TRUE iff the structure *<p pCF> has the correct size to be
 *		a CHARFORMATA or a CHARFORMAT2A
 *
 *	@rdesc
 *		Return TRUE if *<p pCF> is a valid CHARFORMAT(2)A
 */
BOOL IsValidCharFormatA (
	const CHARFORMATA * pCFA) 	//@parm CHARFORMATA to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidCharFormatA");

	return pCFA && (pCFA->cbSize == sizeof(CHARFORMATA) ||
					pCFA->cbSize == sizeof(CHARFORMAT2A));
}

/*
 *	IsValidParaFormat(pPF)
 *
 *	@func
 *		Return TRUE iff the structure *<p pPF> has the correct size to be
 *		a PARAFORMAT or a PARAFORMAT2
 *
 *	@rdesc
 *		Return TRUE if *<p pPF> is a valid PARAFORMAT(2)
 */
BOOL IsValidParaFormat (
	const PARAFORMAT * pPF)		//@parm PARAFORMAT to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidParaFormat");

	if (pPF && (pPF->cbSize == sizeof(PARAFORMAT) ||
				pPF->cbSize == sizeof(PARAFORMAT2)))
	{
		return TRUE;
	}
	TRACEERRORSZ("!!!!!!!!!!! bogus PARAFORMAT from client !!!!!!!!!!!!!");
	return FALSE;
}

/*
 *	Get16BitTwips(dy)
 *
 *	@func
 *		Return dy if |dy| < 32768; else return 32767, i.e., max value
 *		that fits into a SHORT
 *
 *	@rdesc
 *		dy if abs(cy) < 32768; else 32767
 */
SHORT Get16BitTwips(LONG dy)
{
	return abs(dy) < 32768 ? (SHORT)dy : 32767;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\ctffunc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for ctffunc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ctffunc_h__
#define __ctffunc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfCandidateString_FWD_DEFINED__
#define __ITfCandidateString_FWD_DEFINED__
typedef interface ITfCandidateString ITfCandidateString;
#endif 	/* __ITfCandidateString_FWD_DEFINED__ */


#ifndef __IEnumTfCandidates_FWD_DEFINED__
#define __IEnumTfCandidates_FWD_DEFINED__
typedef interface IEnumTfCandidates IEnumTfCandidates;
#endif 	/* __IEnumTfCandidates_FWD_DEFINED__ */


#ifndef __ITfCandidateList_FWD_DEFINED__
#define __ITfCandidateList_FWD_DEFINED__
typedef interface ITfCandidateList ITfCandidateList;
#endif 	/* __ITfCandidateList_FWD_DEFINED__ */


#ifndef __ITfFnReconversion_FWD_DEFINED__
#define __ITfFnReconversion_FWD_DEFINED__
typedef interface ITfFnReconversion ITfFnReconversion;
#endif 	/* __ITfFnReconversion_FWD_DEFINED__ */


#ifndef __ITfFnAbort_FWD_DEFINED__
#define __ITfFnAbort_FWD_DEFINED__
typedef interface ITfFnAbort ITfFnAbort;
#endif 	/* __ITfFnAbort_FWD_DEFINED__ */


#ifndef __ITfFnPlayBack_FWD_DEFINED__
#define __ITfFnPlayBack_FWD_DEFINED__
typedef interface ITfFnPlayBack ITfFnPlayBack;
#endif 	/* __ITfFnPlayBack_FWD_DEFINED__ */


#ifndef __ITfFnLangProfileUtil_FWD_DEFINED__
#define __ITfFnLangProfileUtil_FWD_DEFINED__
typedef interface ITfFnLangProfileUtil ITfFnLangProfileUtil;
#endif 	/* __ITfFnLangProfileUtil_FWD_DEFINED__ */


#ifndef __ITfFnConfigure_FWD_DEFINED__
#define __ITfFnConfigure_FWD_DEFINED__
typedef interface ITfFnConfigure ITfFnConfigure;
#endif 	/* __ITfFnConfigure_FWD_DEFINED__ */


#ifndef __ITfFnConfigureRegisterWord_FWD_DEFINED__
#define __ITfFnConfigureRegisterWord_FWD_DEFINED__
typedef interface ITfFnConfigureRegisterWord ITfFnConfigureRegisterWord;
#endif 	/* __ITfFnConfigureRegisterWord_FWD_DEFINED__ */


#ifndef __ITfFnShowHelp_FWD_DEFINED__
#define __ITfFnShowHelp_FWD_DEFINED__
typedef interface ITfFnShowHelp ITfFnShowHelp;
#endif 	/* __ITfFnShowHelp_FWD_DEFINED__ */


#ifndef __ITfFnBalloon_FWD_DEFINED__
#define __ITfFnBalloon_FWD_DEFINED__
typedef interface ITfFnBalloon ITfFnBalloon;
#endif 	/* __ITfFnBalloon_FWD_DEFINED__ */


#ifndef __ITfFnGetSAPIObject_FWD_DEFINED__
#define __ITfFnGetSAPIObject_FWD_DEFINED__
typedef interface ITfFnGetSAPIObject ITfFnGetSAPIObject;
#endif 	/* __ITfFnGetSAPIObject_FWD_DEFINED__ */


#ifndef __ITfFnPropertyUIStatus_FWD_DEFINED__
#define __ITfFnPropertyUIStatus_FWD_DEFINED__
typedef interface ITfFnPropertyUIStatus ITfFnPropertyUIStatus;
#endif 	/* __ITfFnPropertyUIStatus_FWD_DEFINED__ */


#ifndef __ITfFnLMProcessor_FWD_DEFINED__
#define __ITfFnLMProcessor_FWD_DEFINED__
typedef interface ITfFnLMProcessor ITfFnLMProcessor;
#endif 	/* __ITfFnLMProcessor_FWD_DEFINED__ */


#ifndef __ITfFnLMInternal_FWD_DEFINED__
#define __ITfFnLMInternal_FWD_DEFINED__
typedef interface ITfFnLMInternal ITfFnLMInternal;
#endif 	/* __ITfFnLMInternal_FWD_DEFINED__ */


#ifndef __IEnumTfLatticeElements_FWD_DEFINED__
#define __IEnumTfLatticeElements_FWD_DEFINED__
typedef interface IEnumTfLatticeElements IEnumTfLatticeElements;
#endif 	/* __IEnumTfLatticeElements_FWD_DEFINED__ */


#ifndef __ITfLMLattice_FWD_DEFINED__
#define __ITfLMLattice_FWD_DEFINED__
typedef interface ITfLMLattice ITfLMLattice;
#endif 	/* __ITfLMLattice_FWD_DEFINED__ */


#ifndef __ITfFnAdviseText_FWD_DEFINED__
#define __ITfFnAdviseText_FWD_DEFINED__
typedef interface ITfFnAdviseText ITfFnAdviseText;
#endif 	/* __ITfFnAdviseText_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ctffunc_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ctffunc.h


// CTF Function interfaces.

//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#ifndef CTFFUNC_DEFINED
#define CTFFUNC_DEFINED

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifdef __cplusplus
}
#endif  /* __cplusplus */
#define TF_E_NOCONVERSION     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0600)
EXTERN_C const CLSID CLSID_SapiLayr;


extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0000_v0_0_s_ifspec;

#ifndef __ITfCandidateString_INTERFACE_DEFINED__
#define __ITfCandidateString_INTERFACE_DEFINED__

/* interface ITfCandidateString */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCandidateString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("581f317e-fd9d-443f-b972-ed00467c5d40")
    ITfCandidateString : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [out] */ BSTR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [out] */ ULONG *pnIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCandidateStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCandidateString * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCandidateString * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCandidateString * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ITfCandidateString * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            ITfCandidateString * This,
            /* [out] */ ULONG *pnIndex);
        
        END_INTERFACE
    } ITfCandidateStringVtbl;

    interface ITfCandidateString
    {
        CONST_VTBL struct ITfCandidateStringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCandidateString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCandidateString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCandidateString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCandidateString_GetString(This,pbstr)	\
    (This)->lpVtbl -> GetString(This,pbstr)

#define ITfCandidateString_GetIndex(This,pnIndex)	\
    (This)->lpVtbl -> GetIndex(This,pnIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCandidateString_GetString_Proxy( 
    ITfCandidateString * This,
    /* [out] */ BSTR *pbstr);


void __RPC_STUB ITfCandidateString_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCandidateString_GetIndex_Proxy( 
    ITfCandidateString * This,
    /* [out] */ ULONG *pnIndex);


void __RPC_STUB ITfCandidateString_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCandidateString_INTERFACE_DEFINED__ */


#ifndef __IEnumTfCandidates_INTERFACE_DEFINED__
#define __IEnumTfCandidates_INTERFACE_DEFINED__

/* interface IEnumTfCandidates */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfCandidates;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("defb1926-6c80-4ce8-87d4-d6b72b812bde")
    IEnumTfCandidates : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfCandidates **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfCandidateString **ppCand,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfCandidatesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfCandidates * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfCandidates * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfCandidates * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfCandidates * This,
            /* [out] */ IEnumTfCandidates **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfCandidates * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfCandidateString **ppCand,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfCandidates * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfCandidates * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfCandidatesVtbl;

    interface IEnumTfCandidates
    {
        CONST_VTBL struct IEnumTfCandidatesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfCandidates_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfCandidates_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfCandidates_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfCandidates_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfCandidates_Next(This,ulCount,ppCand,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,ppCand,pcFetched)

#define IEnumTfCandidates_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfCandidates_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfCandidates_Clone_Proxy( 
    IEnumTfCandidates * This,
    /* [out] */ IEnumTfCandidates **ppEnum);


void __RPC_STUB IEnumTfCandidates_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCandidates_Next_Proxy( 
    IEnumTfCandidates * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfCandidateString **ppCand,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfCandidates_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCandidates_Reset_Proxy( 
    IEnumTfCandidates * This);


void __RPC_STUB IEnumTfCandidates_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCandidates_Skip_Proxy( 
    IEnumTfCandidates * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfCandidates_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfCandidates_INTERFACE_DEFINED__ */


#ifndef __ITfCandidateList_INTERFACE_DEFINED__
#define __ITfCandidateList_INTERFACE_DEFINED__

/* interface ITfCandidateList */
/* [unique][uuid][object] */ 

typedef /* [public][public][uuid] */  DECLSPEC_UUID("baa898f2-0207-4643-92ca-f3f7b0cf6f80") 
enum __MIDL_ITfCandidateList_0001
    {	CAND_FINALIZED	= 0,
	CAND_SELECTED	= 0x1,
	CAND_CANCELED	= 0x2
    } 	TfCandidateResult;


EXTERN_C const IID IID_ITfCandidateList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3ad50fb-9bdb-49e3-a843-6c76520fbf5d")
    ITfCandidateList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCandidates( 
            /* [out] */ IEnumTfCandidates **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidate( 
            /* [in] */ ULONG nIndex,
            /* [out] */ ITfCandidateString **ppCand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateNum( 
            /* [out] */ ULONG *pnCnt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResult( 
            /* [in] */ ULONG nIndex,
            /* [in] */ TfCandidateResult imcr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCandidateListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCandidateList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCandidateList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCandidateList * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCandidates )( 
            ITfCandidateList * This,
            /* [out] */ IEnumTfCandidates **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidate )( 
            ITfCandidateList * This,
            /* [in] */ ULONG nIndex,
            /* [out] */ ITfCandidateString **ppCand);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateNum )( 
            ITfCandidateList * This,
            /* [out] */ ULONG *pnCnt);
        
        HRESULT ( STDMETHODCALLTYPE *SetResult )( 
            ITfCandidateList * This,
            /* [in] */ ULONG nIndex,
            /* [in] */ TfCandidateResult imcr);
        
        END_INTERFACE
    } ITfCandidateListVtbl;

    interface ITfCandidateList
    {
        CONST_VTBL struct ITfCandidateListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCandidateList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCandidateList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCandidateList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCandidateList_EnumCandidates(This,ppEnum)	\
    (This)->lpVtbl -> EnumCandidates(This,ppEnum)

#define ITfCandidateList_GetCandidate(This,nIndex,ppCand)	\
    (This)->lpVtbl -> GetCandidate(This,nIndex,ppCand)

#define ITfCandidateList_GetCandidateNum(This,pnCnt)	\
    (This)->lpVtbl -> GetCandidateNum(This,pnCnt)

#define ITfCandidateList_SetResult(This,nIndex,imcr)	\
    (This)->lpVtbl -> SetResult(This,nIndex,imcr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCandidateList_EnumCandidates_Proxy( 
    ITfCandidateList * This,
    /* [out] */ IEnumTfCandidates **ppEnum);


void __RPC_STUB ITfCandidateList_EnumCandidates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCandidateList_GetCandidate_Proxy( 
    ITfCandidateList * This,
    /* [in] */ ULONG nIndex,
    /* [out] */ ITfCandidateString **ppCand);


void __RPC_STUB ITfCandidateList_GetCandidate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCandidateList_GetCandidateNum_Proxy( 
    ITfCandidateList * This,
    /* [out] */ ULONG *pnCnt);


void __RPC_STUB ITfCandidateList_GetCandidateNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCandidateList_SetResult_Proxy( 
    ITfCandidateList * This,
    /* [in] */ ULONG nIndex,
    /* [in] */ TfCandidateResult imcr);


void __RPC_STUB ITfCandidateList_SetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCandidateList_INTERFACE_DEFINED__ */


#ifndef __ITfFnReconversion_INTERFACE_DEFINED__
#define __ITfFnReconversion_INTERFACE_DEFINED__

/* interface ITfFnReconversion */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnReconversion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4cea93c0-0a58-11d3-8df0-00105a2799b5")
    ITfFnReconversion : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange *pRange,
            /* [unique][out][in] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfConvertable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReconversion( 
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reconvert( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnReconversionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnReconversion * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnReconversion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnReconversion * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnReconversion * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryRange )( 
            ITfFnReconversion * This,
            /* [in] */ ITfRange *pRange,
            /* [unique][out][in] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfConvertable);
        
        HRESULT ( STDMETHODCALLTYPE *GetReconversion )( 
            ITfFnReconversion * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList);
        
        HRESULT ( STDMETHODCALLTYPE *Reconvert )( 
            ITfFnReconversion * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfFnReconversionVtbl;

    interface ITfFnReconversion
    {
        CONST_VTBL struct ITfFnReconversionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnReconversion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnReconversion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnReconversion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnReconversion_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnReconversion_QueryRange(This,pRange,ppNewRange,pfConvertable)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfConvertable)

#define ITfFnReconversion_GetReconversion(This,pRange,ppCandList)	\
    (This)->lpVtbl -> GetReconversion(This,pRange,ppCandList)

#define ITfFnReconversion_Reconvert(This,pRange)	\
    (This)->lpVtbl -> Reconvert(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnReconversion_QueryRange_Proxy( 
    ITfFnReconversion * This,
    /* [in] */ ITfRange *pRange,
    /* [unique][out][in] */ ITfRange **ppNewRange,
    /* [out] */ BOOL *pfConvertable);


void __RPC_STUB ITfFnReconversion_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnReconversion_GetReconversion_Proxy( 
    ITfFnReconversion * This,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfCandidateList **ppCandList);


void __RPC_STUB ITfFnReconversion_GetReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnReconversion_Reconvert_Proxy( 
    ITfFnReconversion * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfFnReconversion_Reconvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnReconversion_INTERFACE_DEFINED__ */


#ifndef __ITfFnAbort_INTERFACE_DEFINED__
#define __ITfFnAbort_INTERFACE_DEFINED__

/* interface ITfFnAbort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnAbort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17f2317f-addb-49df-870e-66227bc51d1a")
    ITfFnAbort : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnAbortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnAbort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnAbort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnAbort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnAbort * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ITfFnAbort * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfFnAbortVtbl;

    interface ITfFnAbort
    {
        CONST_VTBL struct ITfFnAbortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnAbort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnAbort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnAbort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnAbort_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnAbort_Abort(This,pic)	\
    (This)->lpVtbl -> Abort(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnAbort_Abort_Proxy( 
    ITfFnAbort * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfFnAbort_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnAbort_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0219 */
/* [local] */ 

EXTERN_C const GUID GUID_COMPARTMENT_SAPI_AUDIO;
EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_DICTATIONSTAT;
#define TF_DICTATION_ON          0x00000001
#define TF_DICTATION_ENABLED     0x00000002
#define TF_COMMANDING_ENABLED    0x00000004
#define TF_COMMANDING_ON         0x00000008

EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_UI_STATUS;
#define TF_SHOW_BALLOON          0x00000001
#define TF_DISABLE_BALLOON       0x00000002
EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_CFGMENU;
#define TF_MENUREADY          0x00000001
EXTERN_C const GUID GUID_LBI_SAPILAYR_CFGMENUBUTTON;



extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0219_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0219_v0_0_s_ifspec;

#ifndef __ITfFnPlayBack_INTERFACE_DEFINED__
#define __ITfFnPlayBack_INTERFACE_DEFINED__

/* interface ITfFnPlayBack */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnPlayBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3a416a4-0f64-11d3-b5b7-00c04fc324a1")
    ITfFnPlayBack : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfPlayable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnPlayBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnPlayBack * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnPlayBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnPlayBack * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnPlayBack * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryRange )( 
            ITfFnPlayBack * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfPlayable);
        
        HRESULT ( STDMETHODCALLTYPE *Play )( 
            ITfFnPlayBack * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfFnPlayBackVtbl;

    interface ITfFnPlayBack
    {
        CONST_VTBL struct ITfFnPlayBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnPlayBack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnPlayBack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnPlayBack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnPlayBack_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnPlayBack_QueryRange(This,pRange,ppNewRange,pfPlayable)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfPlayable)

#define ITfFnPlayBack_Play(This,pRange)	\
    (This)->lpVtbl -> Play(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnPlayBack_QueryRange_Proxy( 
    ITfFnPlayBack * This,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfRange **ppNewRange,
    /* [out] */ BOOL *pfPlayable);


void __RPC_STUB ITfFnPlayBack_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnPlayBack_Play_Proxy( 
    ITfFnPlayBack * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfFnPlayBack_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnPlayBack_INTERFACE_DEFINED__ */


#ifndef __ITfFnLangProfileUtil_INTERFACE_DEFINED__
#define __ITfFnLangProfileUtil_INTERFACE_DEFINED__

/* interface ITfFnLangProfileUtil */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnLangProfileUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A87A8574-A6C1-4E15-99F0-3D3965F548EB")
    ITfFnLangProfileUtil : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterActiveProfiles( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsProfileAvailableForLang( 
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnLangProfileUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnLangProfileUtil * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnLangProfileUtil * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnLangProfileUtil * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnLangProfileUtil * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterActiveProfiles )( 
            ITfFnLangProfileUtil * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsProfileAvailableForLang )( 
            ITfFnLangProfileUtil * This,
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAvailable);
        
        END_INTERFACE
    } ITfFnLangProfileUtilVtbl;

    interface ITfFnLangProfileUtil
    {
        CONST_VTBL struct ITfFnLangProfileUtilVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnLangProfileUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnLangProfileUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnLangProfileUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnLangProfileUtil_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnLangProfileUtil_RegisterActiveProfiles(This)	\
    (This)->lpVtbl -> RegisterActiveProfiles(This)

#define ITfFnLangProfileUtil_IsProfileAvailableForLang(This,langid,pfAvailable)	\
    (This)->lpVtbl -> IsProfileAvailableForLang(This,langid,pfAvailable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnLangProfileUtil_RegisterActiveProfiles_Proxy( 
    ITfFnLangProfileUtil * This);


void __RPC_STUB ITfFnLangProfileUtil_RegisterActiveProfiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLangProfileUtil_IsProfileAvailableForLang_Proxy( 
    ITfFnLangProfileUtil * This,
    /* [in] */ LANGID langid,
    /* [out] */ BOOL *pfAvailable);


void __RPC_STUB ITfFnLangProfileUtil_IsProfileAvailableForLang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnLangProfileUtil_INTERFACE_DEFINED__ */


#ifndef __ITfFnConfigure_INTERFACE_DEFINED__
#define __ITfFnConfigure_INTERFACE_DEFINED__

/* interface ITfFnConfigure */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnConfigure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88f567c6-1757-49f8-a1b2-89234c1eeff9")
    ITfFnConfigure : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID rguidProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnConfigureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnConfigure * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnConfigure * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnConfigure * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnConfigure * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfFnConfigure * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID rguidProfile);
        
        END_INTERFACE
    } ITfFnConfigureVtbl;

    interface ITfFnConfigure
    {
        CONST_VTBL struct ITfFnConfigureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnConfigure_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnConfigure_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnConfigure_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnConfigure_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnConfigure_Show(This,hwndParent,langid,rguidProfile)	\
    (This)->lpVtbl -> Show(This,hwndParent,langid,rguidProfile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnConfigure_Show_Proxy( 
    ITfFnConfigure * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID rguidProfile);


void __RPC_STUB ITfFnConfigure_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnConfigure_INTERFACE_DEFINED__ */


#ifndef __ITfFnConfigureRegisterWord_INTERFACE_DEFINED__
#define __ITfFnConfigureRegisterWord_INTERFACE_DEFINED__

/* interface ITfFnConfigureRegisterWord */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnConfigureRegisterWord;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bb95808a-6d8f-4bca-8400-5390b586aedf")
    ITfFnConfigureRegisterWord : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID rguidProfile,
            /* [unique][in] */ BSTR bstrRegistered) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnConfigureRegisterWordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnConfigureRegisterWord * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnConfigureRegisterWord * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnConfigureRegisterWord * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnConfigureRegisterWord * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfFnConfigureRegisterWord * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID rguidProfile,
            /* [unique][in] */ BSTR bstrRegistered);
        
        END_INTERFACE
    } ITfFnConfigureRegisterWordVtbl;

    interface ITfFnConfigureRegisterWord
    {
        CONST_VTBL struct ITfFnConfigureRegisterWordVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnConfigureRegisterWord_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnConfigureRegisterWord_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnConfigureRegisterWord_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnConfigureRegisterWord_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnConfigureRegisterWord_Show(This,hwndParent,langid,rguidProfile,bstrRegistered)	\
    (This)->lpVtbl -> Show(This,hwndParent,langid,rguidProfile,bstrRegistered)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnConfigureRegisterWord_Show_Proxy( 
    ITfFnConfigureRegisterWord * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID rguidProfile,
    /* [unique][in] */ BSTR bstrRegistered);


void __RPC_STUB ITfFnConfigureRegisterWord_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnConfigureRegisterWord_INTERFACE_DEFINED__ */


#ifndef __ITfFnShowHelp_INTERFACE_DEFINED__
#define __ITfFnShowHelp_INTERFACE_DEFINED__

/* interface ITfFnShowHelp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnShowHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AB1D30C-094D-4C29-8EA5-0BF59BE87BF3")
    ITfFnShowHelp : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ HWND hwndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnShowHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnShowHelp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnShowHelp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnShowHelp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnShowHelp * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfFnShowHelp * This,
            /* [in] */ HWND hwndParent);
        
        END_INTERFACE
    } ITfFnShowHelpVtbl;

    interface ITfFnShowHelp
    {
        CONST_VTBL struct ITfFnShowHelpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnShowHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnShowHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnShowHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnShowHelp_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnShowHelp_Show(This,hwndParent)	\
    (This)->lpVtbl -> Show(This,hwndParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnShowHelp_Show_Proxy( 
    ITfFnShowHelp * This,
    /* [in] */ HWND hwndParent);


void __RPC_STUB ITfFnShowHelp_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnShowHelp_INTERFACE_DEFINED__ */


#ifndef __ITfFnBalloon_INTERFACE_DEFINED__
#define __ITfFnBalloon_INTERFACE_DEFINED__

/* interface ITfFnBalloon */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnBalloon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3BAB89E4-5FBE-45F4-A5BC-DCA36AD225A8")
    ITfFnBalloon : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpdateBalloon( 
            /* [in] */ TfLBBalloonStyle style,
            /* [size_is][in] */ const WCHAR *pch,
            /* [in] */ ULONG cch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnBalloonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnBalloon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnBalloon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnBalloon * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateBalloon )( 
            ITfFnBalloon * This,
            /* [in] */ TfLBBalloonStyle style,
            /* [size_is][in] */ const WCHAR *pch,
            /* [in] */ ULONG cch);
        
        END_INTERFACE
    } ITfFnBalloonVtbl;

    interface ITfFnBalloon
    {
        CONST_VTBL struct ITfFnBalloonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnBalloon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnBalloon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnBalloon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnBalloon_UpdateBalloon(This,style,pch,cch)	\
    (This)->lpVtbl -> UpdateBalloon(This,style,pch,cch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnBalloon_UpdateBalloon_Proxy( 
    ITfFnBalloon * This,
    /* [in] */ TfLBBalloonStyle style,
    /* [size_is][in] */ const WCHAR *pch,
    /* [in] */ ULONG cch);


void __RPC_STUB ITfFnBalloon_UpdateBalloon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnBalloon_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0225 */
/* [local] */ 

typedef /* [public][public][uuid] */  DECLSPEC_UUID("36adb6d9-da1f-45d8-a499-86167e0f936b") 
enum __MIDL___MIDL_itf_ctffunc_0225_0001
    {	GETIF_RESMGR	= 0,
	GETIF_RECOCONTEXT	= 0x1,
	GETIF_RECOGNIZER	= 0x2,
	GETIF_VOICE	= 0x3,
	GETIF_DICTGRAM	= 0x4,
	GETIF_RECOGNIZERNOINIT	= 0x5
    } 	TfSapiObject;



extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0225_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0225_v0_0_s_ifspec;

#ifndef __ITfFnGetSAPIObject_INTERFACE_DEFINED__
#define __ITfFnGetSAPIObject_INTERFACE_DEFINED__

/* interface ITfFnGetSAPIObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnGetSAPIObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5c0ab7ea-167d-4f59-bfb5-4693755e90ca")
    ITfFnGetSAPIObject : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ TfSapiObject sObj,
            /* [out] */ IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnGetSAPIObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnGetSAPIObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnGetSAPIObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnGetSAPIObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnGetSAPIObject * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            ITfFnGetSAPIObject * This,
            /* [in] */ TfSapiObject sObj,
            /* [out] */ IUnknown **ppunk);
        
        END_INTERFACE
    } ITfFnGetSAPIObjectVtbl;

    interface ITfFnGetSAPIObject
    {
        CONST_VTBL struct ITfFnGetSAPIObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnGetSAPIObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnGetSAPIObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnGetSAPIObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnGetSAPIObject_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnGetSAPIObject_Get(This,sObj,ppunk)	\
    (This)->lpVtbl -> Get(This,sObj,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnGetSAPIObject_Get_Proxy( 
    ITfFnGetSAPIObject * This,
    /* [in] */ TfSapiObject sObj,
    /* [out] */ IUnknown **ppunk);


void __RPC_STUB ITfFnGetSAPIObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnGetSAPIObject_INTERFACE_DEFINED__ */


#ifndef __ITfFnPropertyUIStatus_INTERFACE_DEFINED__
#define __ITfFnPropertyUIStatus_INTERFACE_DEFINED__

/* interface ITfFnPropertyUIStatus */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnPropertyUIStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2338AC6E-2B9D-44C0-A75E-EE64F256B3BD")
    ITfFnPropertyUIStatus : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [in] */ REFGUID refguidProp,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ REFGUID refguidProp,
            /* [in] */ DWORD dw) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnPropertyUIStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnPropertyUIStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnPropertyUIStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnPropertyUIStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnPropertyUIStatus * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfFnPropertyUIStatus * This,
            /* [in] */ REFGUID refguidProp,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            ITfFnPropertyUIStatus * This,
            /* [in] */ REFGUID refguidProp,
            /* [in] */ DWORD dw);
        
        END_INTERFACE
    } ITfFnPropertyUIStatusVtbl;

    interface ITfFnPropertyUIStatus
    {
        CONST_VTBL struct ITfFnPropertyUIStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnPropertyUIStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnPropertyUIStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnPropertyUIStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnPropertyUIStatus_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnPropertyUIStatus_GetStatus(This,refguidProp,pdw)	\
    (This)->lpVtbl -> GetStatus(This,refguidProp,pdw)

#define ITfFnPropertyUIStatus_SetStatus(This,refguidProp,dw)	\
    (This)->lpVtbl -> SetStatus(This,refguidProp,dw)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnPropertyUIStatus_GetStatus_Proxy( 
    ITfFnPropertyUIStatus * This,
    /* [in] */ REFGUID refguidProp,
    /* [out] */ DWORD *pdw);


void __RPC_STUB ITfFnPropertyUIStatus_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnPropertyUIStatus_SetStatus_Proxy( 
    ITfFnPropertyUIStatus * This,
    /* [in] */ REFGUID refguidProp,
    /* [in] */ DWORD dw);


void __RPC_STUB ITfFnPropertyUIStatus_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnPropertyUIStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0227 */
/* [local] */ 


#define TF_PROPUI_STATUS_SAVETOFILE  0x00000001

EXTERN_C const GUID GUID_TFCAT_TIP_MASTERLM;
EXTERN_C const GUID GUID_MASTERLM_FUNCTIONPROVIDER;
EXTERN_C const GUID GUID_LMLATTICE_CICERO_VER1_0;
EXTERN_C const GUID GUID_PROP_LMLATTICE;


extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0227_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0227_v0_0_s_ifspec;

#ifndef __ITfFnLMProcessor_INTERFACE_DEFINED__
#define __ITfFnLMProcessor_INTERFACE_DEFINED__

/* interface ITfFnLMProcessor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnLMProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7AFBF8E7-AC4B-4082-B058-890899D3A010")
    ITfFnLMProcessor : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfAccepted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryLangID( 
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccepted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReconversion( 
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reconvert( 
            /* [in] */ ITfRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryKey( 
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeydata,
            /* [out] */ BOOL *pfInterested) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeKey( 
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeyData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeFunc( 
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID refguidFunc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnLMProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnLMProcessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnLMProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnLMProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnLMProcessor * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryRange )( 
            ITfFnLMProcessor * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfAccepted);
        
        HRESULT ( STDMETHODCALLTYPE *QueryLangID )( 
            ITfFnLMProcessor * This,
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccepted);
        
        HRESULT ( STDMETHODCALLTYPE *GetReconversion )( 
            ITfFnLMProcessor * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList);
        
        HRESULT ( STDMETHODCALLTYPE *Reconvert )( 
            ITfFnLMProcessor * This,
            /* [in] */ ITfRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *QueryKey )( 
            ITfFnLMProcessor * This,
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeydata,
            /* [out] */ BOOL *pfInterested);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeKey )( 
            ITfFnLMProcessor * This,
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeyData);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeFunc )( 
            ITfFnLMProcessor * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID refguidFunc);
        
        END_INTERFACE
    } ITfFnLMProcessorVtbl;

    interface ITfFnLMProcessor
    {
        CONST_VTBL struct ITfFnLMProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnLMProcessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnLMProcessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnLMProcessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnLMProcessor_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnLMProcessor_QueryRange(This,pRange,ppNewRange,pfAccepted)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfAccepted)

#define ITfFnLMProcessor_QueryLangID(This,langid,pfAccepted)	\
    (This)->lpVtbl -> QueryLangID(This,langid,pfAccepted)

#define ITfFnLMProcessor_GetReconversion(This,pRange,ppCandList)	\
    (This)->lpVtbl -> GetReconversion(This,pRange,ppCandList)

#define ITfFnLMProcessor_Reconvert(This,pRange)	\
    (This)->lpVtbl -> Reconvert(This,pRange)

#define ITfFnLMProcessor_QueryKey(This,fUp,vKey,lparamKeydata,pfInterested)	\
    (This)->lpVtbl -> QueryKey(This,fUp,vKey,lparamKeydata,pfInterested)

#define ITfFnLMProcessor_InvokeKey(This,fUp,vKey,lparamKeyData)	\
    (This)->lpVtbl -> InvokeKey(This,fUp,vKey,lparamKeyData)

#define ITfFnLMProcessor_InvokeFunc(This,pic,refguidFunc)	\
    (This)->lpVtbl -> InvokeFunc(This,pic,refguidFunc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_QueryRange_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfRange **ppNewRange,
    /* [out] */ BOOL *pfAccepted);


void __RPC_STUB ITfFnLMProcessor_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_QueryLangID_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ LANGID langid,
    /* [out] */ BOOL *pfAccepted);


void __RPC_STUB ITfFnLMProcessor_QueryLangID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_GetReconversion_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfCandidateList **ppCandList);


void __RPC_STUB ITfFnLMProcessor_GetReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_Reconvert_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfFnLMProcessor_Reconvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_QueryKey_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ BOOL fUp,
    /* [in] */ WPARAM vKey,
    /* [in] */ LPARAM lparamKeydata,
    /* [out] */ BOOL *pfInterested);


void __RPC_STUB ITfFnLMProcessor_QueryKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_InvokeKey_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ BOOL fUp,
    /* [in] */ WPARAM vKey,
    /* [in] */ LPARAM lparamKeyData);


void __RPC_STUB ITfFnLMProcessor_InvokeKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_InvokeFunc_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ REFGUID refguidFunc);


void __RPC_STUB ITfFnLMProcessor_InvokeFunc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnLMProcessor_INTERFACE_DEFINED__ */


#ifndef __ITfFnLMInternal_INTERFACE_DEFINED__
#define __ITfFnLMInternal_INTERFACE_DEFINED__

/* interface ITfFnLMInternal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnLMInternal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04B825B1-AC9A-4F7B-B5AD-C7168F1EE445")
    ITfFnLMInternal : public ITfFnLMProcessor
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessLattice( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnLMInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnLMInternal * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnLMInternal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnLMInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnLMInternal * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryRange )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfAccepted);
        
        HRESULT ( STDMETHODCALLTYPE *QueryLangID )( 
            ITfFnLMInternal * This,
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccepted);
        
        HRESULT ( STDMETHODCALLTYPE *GetReconversion )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList);
        
        HRESULT ( STDMETHODCALLTYPE *Reconvert )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *QueryKey )( 
            ITfFnLMInternal * This,
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeydata,
            /* [out] */ BOOL *pfInterested);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeKey )( 
            ITfFnLMInternal * This,
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeyData);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeFunc )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID refguidFunc);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessLattice )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfFnLMInternalVtbl;

    interface ITfFnLMInternal
    {
        CONST_VTBL struct ITfFnLMInternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnLMInternal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnLMInternal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnLMInternal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnLMInternal_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnLMInternal_QueryRange(This,pRange,ppNewRange,pfAccepted)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfAccepted)

#define ITfFnLMInternal_QueryLangID(This,langid,pfAccepted)	\
    (This)->lpVtbl -> QueryLangID(This,langid,pfAccepted)

#define ITfFnLMInternal_GetReconversion(This,pRange,ppCandList)	\
    (This)->lpVtbl -> GetReconversion(This,pRange,ppCandList)

#define ITfFnLMInternal_Reconvert(This,pRange)	\
    (This)->lpVtbl -> Reconvert(This,pRange)

#define ITfFnLMInternal_QueryKey(This,fUp,vKey,lparamKeydata,pfInterested)	\
    (This)->lpVtbl -> QueryKey(This,fUp,vKey,lparamKeydata,pfInterested)

#define ITfFnLMInternal_InvokeKey(This,fUp,vKey,lparamKeyData)	\
    (This)->lpVtbl -> InvokeKey(This,fUp,vKey,lparamKeyData)

#define ITfFnLMInternal_InvokeFunc(This,pic,refguidFunc)	\
    (This)->lpVtbl -> InvokeFunc(This,pic,refguidFunc)


#define ITfFnLMInternal_ProcessLattice(This,pRange)	\
    (This)->lpVtbl -> ProcessLattice(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnLMInternal_ProcessLattice_Proxy( 
    ITfFnLMInternal * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfFnLMInternal_ProcessLattice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnLMInternal_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0229 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("1b646efe-3ce3-4ce2-b41f-35b93fe5552f") struct TF_LMLATTELEMENT
    {
    DWORD dwFrameStart;
    DWORD dwFrameLen;
    DWORD dwFlags;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ INT iCost;
        } 	;
    BSTR bstrText;
    } 	TF_LMLATTELEMENT;



extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0229_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0229_v0_0_s_ifspec;

#ifndef __IEnumTfLatticeElements_INTERFACE_DEFINED__
#define __IEnumTfLatticeElements_INTERFACE_DEFINED__

/* interface IEnumTfLatticeElements */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfLatticeElements;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56988052-47DA-4A05-911A-E3D941F17145")
    IEnumTfLatticeElements : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfLatticeElements **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_LMLATTELEMENT *rgsElements,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfLatticeElementsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfLatticeElements * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfLatticeElements * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfLatticeElements * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfLatticeElements * This,
            /* [out] */ IEnumTfLatticeElements **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfLatticeElements * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_LMLATTELEMENT *rgsElements,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfLatticeElements * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfLatticeElements * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfLatticeElementsVtbl;

    interface IEnumTfLatticeElements
    {
        CONST_VTBL struct IEnumTfLatticeElementsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfLatticeElements_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfLatticeElements_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfLatticeElements_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfLatticeElements_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfLatticeElements_Next(This,ulCount,rgsElements,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgsElements,pcFetched)

#define IEnumTfLatticeElements_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfLatticeElements_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfLatticeElements_Clone_Proxy( 
    IEnumTfLatticeElements * This,
    /* [out] */ IEnumTfLatticeElements **ppEnum);


void __RPC_STUB IEnumTfLatticeElements_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLatticeElements_Next_Proxy( 
    IEnumTfLatticeElements * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_LMLATTELEMENT *rgsElements,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfLatticeElements_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLatticeElements_Reset_Proxy( 
    IEnumTfLatticeElements * This);


void __RPC_STUB IEnumTfLatticeElements_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLatticeElements_Skip_Proxy( 
    IEnumTfLatticeElements * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfLatticeElements_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfLatticeElements_INTERFACE_DEFINED__ */


#ifndef __ITfLMLattice_INTERFACE_DEFINED__
#define __ITfLMLattice_INTERFACE_DEFINED__

/* interface ITfLMLattice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLMLattice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4236675-A5BF-4570-9D42-5D6D7B02D59B")
    ITfLMLattice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryType( 
            /* [in] */ REFGUID rguidType,
            /* [out] */ BOOL *pfSupported) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumLatticeElements( 
            /* [in] */ DWORD dwFrameStart,
            /* [in] */ REFGUID rguidType,
            /* [out] */ IEnumTfLatticeElements **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLMLatticeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLMLattice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLMLattice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLMLattice * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryType )( 
            ITfLMLattice * This,
            /* [in] */ REFGUID rguidType,
            /* [out] */ BOOL *pfSupported);
        
        HRESULT ( STDMETHODCALLTYPE *EnumLatticeElements )( 
            ITfLMLattice * This,
            /* [in] */ DWORD dwFrameStart,
            /* [in] */ REFGUID rguidType,
            /* [out] */ IEnumTfLatticeElements **ppEnum);
        
        END_INTERFACE
    } ITfLMLatticeVtbl;

    interface ITfLMLattice
    {
        CONST_VTBL struct ITfLMLatticeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLMLattice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLMLattice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLMLattice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLMLattice_QueryType(This,rguidType,pfSupported)	\
    (This)->lpVtbl -> QueryType(This,rguidType,pfSupported)

#define ITfLMLattice_EnumLatticeElements(This,dwFrameStart,rguidType,ppEnum)	\
    (This)->lpVtbl -> EnumLatticeElements(This,dwFrameStart,rguidType,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLMLattice_QueryType_Proxy( 
    ITfLMLattice * This,
    /* [in] */ REFGUID rguidType,
    /* [out] */ BOOL *pfSupported);


void __RPC_STUB ITfLMLattice_QueryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLMLattice_EnumLatticeElements_Proxy( 
    ITfLMLattice * This,
    /* [in] */ DWORD dwFrameStart,
    /* [in] */ REFGUID rguidType,
    /* [out] */ IEnumTfLatticeElements **ppEnum);


void __RPC_STUB ITfLMLattice_EnumLatticeElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLMLattice_INTERFACE_DEFINED__ */


#ifndef __ITfFnAdviseText_INTERFACE_DEFINED__
#define __ITfFnAdviseText_INTERFACE_DEFINED__

/* interface ITfFnAdviseText */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnAdviseText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3527268B-7D53-4DD9-92B7-7296AE461249")
    ITfFnAdviseText : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnTextUpdate( 
            /* [in] */ ITfRange *pRange,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLatticeUpdate( 
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfLMLattice *pLattice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnAdviseTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnAdviseText * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnAdviseText * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnAdviseText * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnAdviseText * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *OnTextUpdate )( 
            ITfFnAdviseText * This,
            /* [in] */ ITfRange *pRange,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *OnLatticeUpdate )( 
            ITfFnAdviseText * This,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfLMLattice *pLattice);
        
        END_INTERFACE
    } ITfFnAdviseTextVtbl;

    interface ITfFnAdviseText
    {
        CONST_VTBL struct ITfFnAdviseTextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnAdviseText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnAdviseText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnAdviseText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnAdviseText_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnAdviseText_OnTextUpdate(This,pRange,pchText,cch)	\
    (This)->lpVtbl -> OnTextUpdate(This,pRange,pchText,cch)

#define ITfFnAdviseText_OnLatticeUpdate(This,pRange,pLattice)	\
    (This)->lpVtbl -> OnLatticeUpdate(This,pRange,pLattice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnAdviseText_OnTextUpdate_Proxy( 
    ITfFnAdviseText * This,
    /* [in] */ ITfRange *pRange,
    /* [size_is][in] */ const WCHAR *pchText,
    /* [in] */ LONG cch);


void __RPC_STUB ITfFnAdviseText_OnTextUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnAdviseText_OnLatticeUpdate_Proxy( 
    ITfFnAdviseText * This,
    /* [in] */ ITfRange *pRange,
    /* [in] */ ITfLMLattice *pLattice);


void __RPC_STUB ITfFnAdviseText_OnLatticeUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnAdviseText_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0232 */
/* [local] */ 

#endif // CTFFUNC_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0232_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0232_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\coleobj.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	COLEOBJ.CPP	OLE Object management class implemenation |
 *
 * 	Authors:
 *	alexgo  Much of this code is a port from RichEdit 1.0 sources
 *			(cleaned up a bit, ported to C++, etc.)  So if there's any
 *			bit of strangeness, it's probably there for a reason.
 *
 *	KeithCu	Cleaned up (removed _rcPos, ResetPosRect(), ScrollObject,
			fixed undo/resizing issues)
 *			Added textflow support
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_coleobj.h"
#include "_objmgr.h"
#include "_select.h"
#include "_rtext.h"
#include "_disp.h"
#include "_dispprt.h"
#include "_antievt.h"
#include "_dxfrobj.h"

ASSERTDATA

// 
// data private to this file
//
static const OLECHAR szSiteFlagsStm[] = OLESTR("RichEditFlags");	

// 
// EXCEL clsid's.  We have to make some special purpose hacks
// for XL.
const CLSID rgclsidExcel[] =
{
    { 0x00020810L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel Worksheet
    { 0x00020811L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel Chart
    { 0x00020812L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel App1
    { 0x00020841L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel App2
};
const INT cclsidExcel = sizeof(rgclsidExcel) / sizeof(rgclsidExcel[0]);


//
//	WordArt CLSID for more special purpose hacks.
//
const GUID CLSID_WordArt = 
    { 0x000212F0L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} };
const GUID CLSID_PaintbrushPicture = 
    { 0x0003000AL, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };
const GUID CLSID_BitmapImage = 
    { 0xD3E34B21L, 0x9D75, 0x101A, { 0x8C, 0x3D, 0x00, 0xAA, 0x00, 0x1A, 0x16, 0x52 } };

//
//	Ink object
//
const GUID CLSID_Ink = 
	{ 0x13DE4A42, 0x8D21, 0x4C8E, {0xBF, 0x9C, 0x8F, 0x69, 0xCB, 0x06, 0x8F, 0xCA} };
const IID IID_ILineInfo = 
	{ 0x9C1C5AD5, 0xF22F, 0x4DE4, {0xB4, 0x53, 0xA2, 0xCC, 0x48, 0x2E, 0x7C, 0x33} };

#define dxyHandle (6) // Object frame handle size
#define dxyFrameDefault  (1) // Object frame width

// 
// utility functions
//

/*
 *	IsExcelCLSID (clsid)
 *
 *	@func	checks to see if the given clsid is one of XL's
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL IsExcelCLSID(
	REFGUID clsid)
{
    for(LONG i = 0; i < cclsidExcel; i++)
    {
        if(IsEqualCLSID(clsid, rgclsidExcel[i]))
			return TRUE;
    }
    return FALSE;
}

//
//	PUBLIC methods
//

/*
 *	COleObject::QueryInterface(ridd, ppv)
 *
 *	@mfunc	the standard OLE QueryInterface
 *
 *	@rdesc	NOERROR		<nl>
 *			E_NOINTERFACE
 */
STDMETHODIMP COleObject::QueryInterface(
	REFIID	riid,		//@parm Requested interface ID
	void **	ppv)		//@parm Out parm for result
{
	HRESULT hr = NOERROR;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::QueryInterface");

    if(IsZombie())
        return CO_E_RELEASED;
        
	if(!ppv)
		return E_INVALIDARG;
	else
		*ppv = NULL;

	if(IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown *)(IOleClientSite *)this;

	else if(IsEqualIID(riid, IID_IOleClientSite))
		*ppv = (IOleClientSite *)this;

	else if(IsEqualIID(riid, IID_IOleInPlaceSite))
		*ppv = (IOleInPlaceSite *)this;

	else if(IsEqualIID(riid, IID_IAdviseSink))
		*ppv = (IAdviseSink *)this;

	else if(IsEqualIID(riid, IID_IOleWindow))
		*ppv = (IOleWindow *)this;

	else if(IsEqualIID(riid, IID_IRichEditOleCallback))
	{
		// NB!! Returning this pointer in our QI is 
		// phenomenally bogus; it breaks fundamental COM
		// identity rules (granted, not many understand them!).
		// Anyway, RichEdit 1.0 did this, so we better.

		TRACEWARNSZ("Returning IRichEditOleCallback interface, COM "
			"identity rules broken!");

		*ppv = _ped->GetRECallback();
	}
	else
		hr = E_NOINTERFACE;

	if(*ppv)
		(*(IUnknown **)ppv)->AddRef();

	return hr;
}

/*
 *	COleObject::AddRef()
 *
 *	@mfunc	Increments reference count
 *
 *	@rdesc	New reference count
 */
STDMETHODIMP_(ULONG) COleObject::AddRef()
{
    ULONG cRef;
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::AddRef");

    cRef = SafeAddRef();
	
	return cRef;
}

/*
 *	COleObject::Release	()
 *
 *	@mfunc	Decrements reference count
 *
 *	@rdesc	New reference count
 */
STDMETHODIMP_(ULONG) COleObject::Release()
{
    ULONG cRef;
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Release");

	cRef = SafeRelease();

	return cRef;
}

/*
 *	COleObject::SaveObject ()
 *
 *	@mfunc	implemtenation of IOleClientSite::SaveObject
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::SaveObject()
{
	CCallMgr	callmgr(_ped);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SaveObject");

	return SafeSaveObject();
}

/*
 *	COleObject::SafeSaveObject ()
 *
 *	@mfunc	implemtenation of IOleClientSite::SaveObject for internal consumption
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::SafeSaveObject()
{
	IPersistStorage *pps;
	HRESULT hr;
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SafeSaveObject");

	if(!_punkobj || !_pstg)
	{
		TRACEWARNSZ("SaveObject called on invalid object");
		return E_UNEXPECTED;
	}

    if(IsZombie())
        return CO_E_RELEASED;

	hr = _punkobj->QueryInterface(IID_IPersistStorage, (void **)&pps);

	TESTANDTRACEHR(hr);

	if(hr == NOERROR)
	{
        if(IsZombie())
            return CO_E_RELEASED;
        
		SavePrivateState();
		
        if(IsZombie())
            return CO_E_RELEASED;
        
		hr = OleSave(pps, _pstg, TRUE);
	
	    if(IsZombie())
	        return CO_E_RELEASED;
        
		TESTANDTRACEHR(hr);

		// note that SaveCompleted is called even if OleSave fails.
		// If both OleSave and SaveCompleted succeed, then go ahead
		// and commit the changes

		if(pps->SaveCompleted(NULL) == NOERROR && hr == NOERROR)
		{
		    if(IsZombie())
		        return CO_E_RELEASED;
			
			hr = _pstg->Commit(STGC_DEFAULT);

			TESTANDTRACEHR(hr);
		}
        pps->Release();
	}
	return hr;
}

/*
 *	COleObject::GetMoniker (dwAssign, dwWhichMoniker, ppmk)
 *
 *	@mfunc	implementation of IOleClientSite::GetMoniker
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::GetMoniker(
	DWORD		dwAssign,		//@parm	Force an assignment?
	DWORD		dwWhichMoniker,	//@parm	Kind of moniker to get
	IMoniker **	ppmk)			//@parm Out parm for result
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetMoniker");

	TRACEWARNSZ("method not implemented!");

	if(ppmk)
		*ppmk = NULL;

	return E_NOTIMPL;
}
	
/*
 *	COleObject::GetContainer(ppcont)
 *
 *	@mfunc	implementation of IOleClientSite::GetContainer
 *
 *	@rdesc	E_NOINTERFACE
 */
STDMETHODIMP COleObject::GetContainer(
	IOleContainer **ppcont)	//@parm	Out parm for result
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetContainer");

	TRACEWARNSZ("method not implemented!");

	if(ppcont)
		*ppcont = NULL;

	// Richedit 1.0 returns E_NOINTERFACE instead of E_NOTIMPL.  Do
	// the same.
	return E_NOINTERFACE;
}

/*
 *	COleObject::ShowObject()
 *
 *	@mfunc	Implementation of IOleClientSite::ShowObject.  
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::ShowObject()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::ShowObject");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::OnShowWindow (fShow)
 *
 *	@mfunc
 *		implementation of IOleClientSite::OnShowWindow -- notifies
 *		the client site that the object is or is not being shown in its
 *		own application window.  This governs whether or not hatching 
 *		should appear around the object in richedit.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnShowWindow(
	BOOL fShow)		//@parm If TRUE, object is being drawn in its own window
{
	DWORD dwFlags = _pi.dwFlags;
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnShowWindow");

    if(IsZombie())
        return CO_E_RELEASED;

	_pi.dwFlags &= ~REO_OPEN;
	if(fShow)
		_pi.dwFlags |= REO_OPEN;

	// If something changed, redraw object
	if(dwFlags != _pi.dwFlags)
	{
		RECTUV rc;
		GetRectuv(rc);

		// Invalidate rect that we're in.
		_ped->TxInvalidateRect(&rc);

		// We're not allowed to call invalidate rect by itself without
		// terminating it with a call to update window.However, we don't
		// care at this point if things are redrawn right away.
		_ped->TxUpdateWindow();
	}
	return NOERROR;
}

/*
 *	COleObject::RequestNewObjectLayout ()
 *
 *	@mfunc	Implementation of IOleClientSite::RequestNewObjectLayout
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::RequestNewObjectLayout()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::RequestNewObjectLayout");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::GetWindow(phwnd)
 *
 *	@mfunc	Implementation of IOleInPlaceSite::GetWindow
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::GetWindow(
	HWND *phwnd)	//@parm Where to put window
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetWindow");

	// NB! this method is not stabilized.

    if(IsZombie())
        return CO_E_RELEASED;
        
	if(phwnd)
		return _ped->TxGetWindow(phwnd);

	return E_INVALIDARG;
}

/*
 *	COleObject::ContextSensitiveHelp(fEnterMode)
 *
 *	@mfunc	Implemenation of IOleInPlaceSite::ContextSensitiveHelp
 *
 *	@rdesc	HRESULT
 */
 STDMETHODIMP COleObject::ContextSensitiveHelp(
 	BOOL fEnterMode)	//@parm, If TRUE, then we're in help mode
 {
 	IRichEditOleCallback *precall;
	CCallMgr	callmgr(_ped);
	CStabilize	stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::ContextSensitiveHelp");

    if(IsZombie())
        return CO_E_RELEASED;

	CObjectMgr *pobjmgr = _ped->GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;
	
	// If the mode changes
	if(pobjmgr->GetHelpMode() != fEnterMode)
	{
		pobjmgr->SetHelpMode(fEnterMode);

		precall = _ped->GetRECallback();
		if(precall)
			return precall->ContextSensitiveHelp(fEnterMode);
	}
	return NOERROR;
}

/*
 *	COleObject::CanInPlaceActivate()
 *
 *	@mfunc	implementation of IOleInPlaceSite::CanInPlaceActivate
 *
 *	@rdesc	NOERROR or S_FALSE
 */
STDMETHODIMP COleObject::CanInPlaceActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::CanInPlaceActivate");

    if(IsZombie())
        return CO_E_RELEASED;
        
	// If we have a callback && the object is willing to show
	// content, then we can in-place activate

	if(_ped->GetRECallback() && _pi.dvaspect == DVASPECT_CONTENT)
 		return NOERROR;
 
	return S_FALSE;
}

/*
 *	COleObject::OnInPlaceActivate()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnInPlaceActivate
 *
 *	@rdesc	noerror
 */
STDMETHODIMP COleObject::OnInPlaceActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnInPlaceActivate");
	// assume that in-place objects can never be blank.
	_pi.dwFlags &= ~REO_BLANK;
	_fInPlaceActive = TRUE;

	return NOERROR;
}

/*
 *	COleObject::OnUIActivate ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnUIActivate.  Notifies
 *			the container that the object is about to be activated in
 *			place with UI elements suchs as merged menus
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnUIActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnUIActivate");

	CCallMgr	callmgr(_ped);
	CStabilize	stabilize(this);

    if(IsZombie())
        return CO_E_RELEASED;
        
	CObjectMgr *pobjmgr = _ped->GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	IRichEditOleCallback *precall = pobjmgr->GetRECallback();

	if(precall)
	{
		// Force this object to be selected, if it isn't already
		// Update the selection before making the outgoing call
		if(!(_pi.dwFlags & REO_SELECTED))
		{
			CTxtSelection *psel = _ped->GetSel();
			if(psel)
				psel->SetSelection(_cp, _cp + 1);
		}
		precall->ShowContainerUI(FALSE);
	    if(IsZombie())
	        return CO_E_RELEASED;
        
		// This is an optimization for activating multiple
		pobjmgr->SetShowUIPending(FALSE);

		// RAID 7212
		// We don't want to set the in place active object if we are already in the process of activating the pbject.
		// Otherwise, there will be bad interactions with the code in TxDraw for out of process servers.
		// Note : it may be possible to always set this in ActivateObj but I left this here for those cases wher
		// OnUIActivate may be called directly.
		if (!_fActivateCalled)
		{
			Assert(!pobjmgr->GetInPlaceActiveObject());	
			pobjmgr->SetInPlaceActiveObject(this);
			_pi.dwFlags |= REO_INPLACEACTIVE;
		}

		return NOERROR;
	}
	return E_UNEXPECTED;
}

/*
 *	COleObject::GetWindowContext(ppipframe, ppipuidoc, prcPos, prcClip, pipfinfo) 
 *
 *	@mfunc	Implementation of IOleInPlaceSite::GetWindowContext.
 *			Enables the in-place object to retrieve the window
 *			interfaces that form the window object hierarchy.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::GetWindowContext(
	IOleInPlaceFrame **ppipframe,	//@parm	Where to put in-place frame
	IOleInPlaceUIWindow **ppipuidoc,//@parm Where to put ui window
	LPRECT prcPos,					//@parm Position rect
	LPRECT prcClip,					//@parm Clipping rect
	LPOLEINPLACEFRAMEINFO pipfinfo)	//@parm Accelerator information
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);
	
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetWindowContext");
	
    if(IsZombie())
        return CO_E_RELEASED;
        
	// Let container verify other parameters; we don't use them
	if(!prcPos || !prcClip)
		return E_INVALIDARG;
		
	IRichEditOleCallback *precall = _ped->GetRECallback();
	if(precall)
	{
		RECTUV rcuv;
		GetRectuv(rcuv);
		_ped->_pdp->RectFromRectuv(*prcPos, rcuv);

		// FUTURE (alexgo); we may need to get this from the
		// display instead to handle the inactive state if we ever
		// want to support embedded objects with the inactive state.
		_ped->TxGetClientRect(prcClip);
		return precall->GetInPlaceContext(ppipframe, ppipuidoc, pipfinfo);
	}
	return E_UNEXPECTED;
}

/*
 *	COleObject::Scroll(sizeScroll)
 *
 *	@mfunc	implementation of IOleInPlaceSite::Scroll
 *
 *	@rdesc 	E_NOTIMPL;
 */
STDMETHODIMP COleObject::Scroll(
	SIZE sizeScroll)	//@parm Amount to scroll
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Scroll");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::OnUIDeactivate (fUndoable)
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnUIDeactivate.  Notifies
 *			the container that it should re-install its user interface
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnUIDeactivate(
	BOOL fUndoable)		//@parm Whether you can undo anything here
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnUIDeactivate");

    if(IsZombie())
        return CO_E_RELEASED;

	CObjectMgr *pobjmgr = _ped->GetObjectMgr();
	IRichEditOleCallback *precall = _ped->GetRECallback();

	if(_fIsPaintBrush)
	{
		// Hack for RAID 3293.  Bitmap object disappears after editing.
		// Apparently paint only triggers OnUIDeactivate and not OnInPlaceDeactivate
		// assume that in-place objects can never be blank.
		_fInPlaceActive = FALSE;
		// Reset REO_INPLACEACTIVE
		_pi.dwFlags &= ~REO_INPLACEACTIVE;
	}

	if(!precall)
		return E_UNEXPECTED;

	if(_ped->TxIsDoubleClickPending())
		_ped->GetObjectMgr()->SetShowUIPending(TRUE);
	else
	{
		// Ignore any errors; the old code did.
		precall->ShowContainerUI(TRUE);

	    if(IsZombie())
	        return CO_E_RELEASED;
	}
	
	pobjmgr->SetInPlaceActiveObject(NULL);

	if (!_fDeactivateCalled)
	{
		// We got here without DeActiveObj. Since to shutdown correctly
		// we need to call this, we do so here.
		DeActivateObj();
	}

	// Get focus back
	_ped->TxSetFocus();

#ifdef DEBUG
	// the OLE undo model is not very compatible with multi-level undo.
	// For simplicity, just ignore stuff.
	if(fUndoable)
	{
		TRACEWARNSZ("Ignoring a request to keep undo from an OLE object");
	}
#endif

	// Some objects are lame and draw outside the
	// areas they are supposed to.  So we need to 
	// just invalidate everything and redraw.

	_ped->TxInvalidate();
	return NOERROR;
}

/*
 *	COleObject::OnInPlaceDeactivate	()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnInPlaceDeactivate
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP COleObject::OnInPlaceDeactivate()
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::OnInPlaceDeactivate");

	_fInPlaceActive = FALSE;

	//Reset REO_INPLACEACTIVE
	_pi.dwFlags &= ~REO_INPLACEACTIVE;

	if(!_punkobj)
		return E_UNEXPECTED;

    if(IsZombie())
        return CO_E_RELEASED;
        
	// Apparently, WordArt 2.0 had some sizing problems.  The original
	// code has this call to GetExtent-->SetExtent, so I've kept it here.
	if(_fIsWordArt2)
	{
		// Ignore errors.  If anything fails, too bad.
		FetchObjectExtents();	// this will reset _size
		SetExtent(SE_NOTACTIVATING);
	}

	// Some objects are lame and draw outside the
	// areas they are supposed to.  So we need to 
	// just invalidate everything and redraw.

	// Note that we do this in UIDeactivate as well; however, the
	// double invalidation is necessary to cover some re-entrancy 
	// cases where we might be painted before everything is ready.

	_ped->TxInvalidate();
	return NOERROR;
}

/*
 *	COleObject::DiscardUndoState ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::DiscardUndoState.
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP COleObject::DiscardUndoState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::DiscardUndoState");

	// Nothing to do here; we don't keep any OLE-undo state as it's
	// not very compatible with multi-level undo.
	
	return NOERROR;
}

/*
 *	COleObject::DeactivateAndUndo ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::DeactivateAndUndo--
 *			called by an active object when the user invokes undo
 *			in the active object
 *
 *	@rdesc	NOERROR	(yep, richedit1.0 ignored all the errors here)
 */
STDMETHODIMP COleObject::DeactivateAndUndo()
{
	CStabilize	stabilize(this);

  	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::DeactivateAndUndo");

    if(IsZombie())
        return CO_E_RELEASED;
        
	// Ignore error
	_ped->InPlaceDeactivate();

	// COMPATIBILITY ISSUE: we don't bother doing any undo here, as 
	// a multi-level undo model is incompatible with OLE undo.

	return NOERROR;
}

/*
 *	COleObject::OnPosRectChange	(prcPos)
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnPosRectChange.  This
 *			method is called by an in-place object when its extents have
 *			changed
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnPosRectChange(
	LPCRECT prcPos)
{
	IOleInPlaceObject *pipo;
 	RECT rcClip;
	RECT rcNewPos;
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnPosRectChange");
	
	if(!prcPos)
		return E_INVALIDARG;

	if(!_punkobj)
		return E_UNEXPECTED;
		
    if(IsZombie())
        return CO_E_RELEASED;

	if(!_ped->fInplaceActive())
		return E_UNEXPECTED;
        
	// Check to see if the rect moved; we don't allow this, but
	// do allow the object to keep the new size

	rcNewPos = *prcPos;

	rcNewPos.right = rcNewPos.left + (prcPos->right - prcPos->left);
	rcNewPos.bottom = rcNewPos.top + (prcPos->bottom - prcPos->top);		

	_ped->TxGetClientRect(&rcClip);

	HRESULT hr = _punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo);
	if(hr == NOERROR)
	{
		hr = pipo->SetObjectRects(&rcNewPos, &rcClip);
        pipo->Release();

        // bug fix 6073
        // Need to set viewchange flag so we resize the ole object properly on ITextServices::TxDraw
		CObjectMgr * pobjmgr = _ped->GetObjectMgr();
		if (pobjmgr && pobjmgr->GetInPlaceActiveObject() == this)
			_fViewChange = TRUE;
	}
	return hr;
}

/*
 *	COleObject::OnDataChange (pformatetc, pmedium)
 *
 *	@mfunc	implementation of IAdviseSink::OnDataChange
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnDataChange(
	FORMATETC *pformatetc,		//@parm Format of data that changed
	STGMEDIUM *pmedium)			//@parm Data that changed
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnDataChange");
	CCallMgr	callmgr(_ped);

    if(IsZombie())
        return;
	_pi.dwFlags &= ~REO_BLANK;
	// this will also set the modified flag
	_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

	return;
}

/*
 *	COleObject::OnViewChange(dwAspect, lindex) 
 *
 *	@mfunc	implementation of IAdviseSink::OnViewChange.  Notifies
 *			us that the object's view has changed.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP_(void) COleObject::OnViewChange(
	DWORD	dwAspect,		//@parm Aspect that has changed
	LONG	lindex)			//@parm unused
{
	CStabilize	stabilize(this);
	CCallMgr	callmgr(_ped);
		
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnViewChange");
	
	if(!_punkobj)
		return;		// E_UNEXPECTED

    if(IsZombie())
        return;

	if (_fInUndo)	// This object has been deleted, forget view change
		return;

	_pi.dwFlags &= ~REO_BLANK;
	// Richedit 1.0 ignored errors on getting object extents

  	FetchObjectExtents();

    // bug fix 6073
    // Need to set viewchange flag so we resize the ole object properly on ITextServices::TxDraw
    CObjectMgr * pobjmgr = _ped->GetObjectMgr();
	if (pobjmgr && pobjmgr->GetInPlaceActiveObject() == this)
		_fViewChange = TRUE;
      
	CDisplay *pdp = _ped->_pdp;
	if(pdp)
		pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, _cp, _cp + 1, NULL);

	_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
	return;
}
	
/*
 *	COleObject::OnRename (pmk)
 *
 *	@mfunc	implementation of IAdviseSink::OnRename.  Notifies the container
 *			that the object has been renamed
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP_(void) COleObject::OnRename(
	IMoniker *pmk)			//@parm Object's new name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnRename");
	
	TRACEWARNSZ("IAdviseSink::OnRename not implemented!");

	return;	// E_NOTIMPL;
}

/*
 *	COleObject::OnSave ()
 *
 *	@mfunc	implementation of IAdviseSink::OnSave.  Notifies the container
 *			that an object has been saved
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnSave()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnSave");
	_pi.dwFlags &= ~REO_BLANK;
}

/*
 *	COleObject::OnClose	()
 *
 *	@mfunc	implementation of IAdviseSink::OnClose.  Notifies the container
 *			that an object has been closed.
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnClose()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnClose");
	
    if(IsZombie())
        return;
        
	// If the object is blank (i.e. no data in it), we don't want to leave
	// it in the backing store--there is nothing for us to draw && therefore
	// nothing for the user to click on!  So just delete the object with
	// a space.  Note that 1.0 actually deleted the object; we'll just
	// replace it with a space to make everything work out right.
	if(_pi.dwFlags & REO_BLANK)
	{
		CCallMgr	callmgr(_ped);
		CStabilize	stabilize(this);
		CRchTxtPtr	rtp(_ped, _cp);

		// We don't want the delete of this object to go on the undo
		// stack.  We use a space so that cp's will work out right for
		// other undo actions.
		rtp.ReplaceRange(1, 1, L" ", NULL, -1);
	}
	_ped->TxSetForegroundWindow();
}
				
/*
 *	COleObject::OnPreReplaceRange
 *
 *	@mfunc	implementation of ITxNotify::OnPreReplaceRange
 *			called before changes are made to the backing store
 */
void COleObject::OnPreReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	Assert(_fInUndo == FALSE);
}

/*
 *	COleObject::OnPostReplaceRange
 *
 *	@mfunc	implementation of ITxNotify::OnPostReplaceRange
 *			called after changes are made to the backing store
 *	
 *	@comm	we use this method to keep our cp's up-to-date
 */
void COleObject::OnPostReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	// The only case we need to worry about is when changes
	// come before our object

	Assert(_fInUndo == FALSE);
#ifndef NOINKOBJECT
	LONG	cpOld = _cp;
#endif
	_fDraw = TRUE;
	if(cp <= _cp)
	{		
		if(cp + cchDel > _cp)
		{
			_fDraw = FALSE;
			return;
		}
		_cp += (cchNew - cchDel);
	}
#ifndef NOINKOBJECT
	if (_ped && _fIsInkObject && _pILineInfo)
	{
		if (cpFormatMin <= cpOld && cpOld < cpFormatMax)
		{
			// Inform Ink object for the formatting changes
			UINT	iInkWidth = 0;

			_ped->SetInkProps(_cp, _pILineInfo, &iInkWidth);

		}
	}
#endif
}
		
/*
 *	COleObject::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 *
 */
void COleObject::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Zombie");

	_ped = NULL;
}

/*
 *	COleObject::COleObject(ped)
 *
 *	@mfunc	constructor
 */
COleObject::COleObject(
	CTxtEdit *ped)	//@parm context for this object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::COleObject");

	AddRef();

	// Most values will be NULL by virtue of the allocator
	_ped = ped;

	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);
}

/*
 *	COleObject::GetObjectData(preobj, dwFlags)
 *
 *	@mfunc	fills out an REOBJECT structure with information relevant
 *			to this object
 *
 *	@rdesc	HRESULT
 */
HRESULT	COleObject::GetObjectData(
	REOBJECT *preobj, 		//@parm Struct to fill out
	DWORD dwFlags)			//@parm Indicate what data is requested
{
	IOleObject *poo = NULL;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::GetObjectData");

	Assert(preobj);
	Assert(_punkobj);

	preobj->cp = _cp;
	
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		// Don't worry about failures here
		poo->GetUserClassID(&(preobj->clsid));
	}
	
	preobj->dwFlags 	= _pi.dwFlags;
	preobj->dvaspect 	= _pi.dvaspect;
	preobj->dwUser 		= _pi.dwUser;
	memcpy(&preobj->sizel, &_size, sizeof(SIZE));

   	if(dwFlags & REO_GETOBJ_POLEOBJ)
	{
		preobj->poleobj = poo;
		if(poo)
			poo->AddRef();
	}
	else
		preobj->poleobj = NULL;

    if(poo)
        poo->Release();

    if(IsZombie())
        return CO_E_RELEASED;
        
	if(dwFlags & REO_GETOBJ_PSTG)
	{
		preobj->pstg = _pstg;
		if(_pstg)
			_pstg->AddRef();
	}
	else
		preobj->pstg = NULL;

	if(dwFlags & REO_GETOBJ_POLESITE)
	{
		// COMPATIBILITY HACK!!  Note that we don't 'release' any pointer that
		// may already be in the stored in the site.  RichEdit1.0 always sets
		// the value, consequently several apps pass in garbage for the site.
		//
		// If the site was previously set, we will get a reference counting
		// bug, so be sure that doesn't happen!
     
       	preobj->polesite = (IOleClientSite *)this;
       	AddRef();
 	}
	else
		preobj->polesite = NULL;

	return NOERROR;
}	

/*
 *	COleObject::IsLink()
 *
 *	@mfunc	returns TRUE if the object is a link
 *
 *	@rdesc	BOOL
 */
BOOL COleObject::IsLink()
{
	return !!(_pi.dwFlags & REO_LINK);
}

/*
 *	COleObject::InitFromREOBJECT(cp, preobj)
 *
 *	@mfunc	initializes this object's state from the given
 *			REOBJECT data structure
 *
 *	@rdesc	HRESULT
 */
HRESULT COleObject::InitFromREOBJECT(
	LONG	cp,			//@parm cp for the object
	REOBJECT *preobj)	//@parm	Data to use for initialization
{
	IOleLink *plink;
	HRESULT	hr = E_INVALIDARG;
	
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::InitFromREOBJECT");
	
	Assert(_punkobj == NULL);
    if(IsZombie())
        return CO_E_RELEASED;

	_cp = cp;

	if(preobj->poleobj)
		hr = preobj->poleobj->QueryInterface(IID_IUnknown, (void **)&_punkobj);
	else
	{
		_punkobj = (IOleClientSite *) this;
		AddRef();
		hr = NOERROR;
	}
        
	if(hr != NOERROR)
		return hr;
	
	_pstg = preobj->pstg;
	if(_pstg)
		_pstg->AddRef();

	_pi.dwFlags	 = preobj->dwFlags & REO_READWRITEMASK;
	_pi.dwUser	 = preobj->dwUser;
	_pi.dvaspect = preobj->dvaspect;

	preobj->sizel.cx = max(preobj->sizel.cx, 0);
	preobj->sizel.cy = max(preobj->sizel.cy, 0);

	memcpy(&_size, &preobj->sizel, sizeof(SIZE));	// COMPATIBILITY ISSUE: the RE 1.0 code had
													// some stuff to deal with REO_DYNAMICSIZE
													// here. We do not currently support that.
	
	if(_punkobj->QueryInterface(IID_IOleLink, (void **)&plink) == NOERROR)
	{
		_pi.dwFlags |= REO_LINK | REO_LINKAVAILABLE;
		plink->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
        
	if (IsEqualCLSID(preobj->clsid, CLSID_StaticMetafile) ||
		IsEqualCLSID(preobj->clsid, CLSID_StaticDib) ||
		IsEqualCLSID(preobj->clsid, CLSID_Picture_EnhMetafile))
	{
		_pi.dwFlags |= REO_STATIC;
	}
	else if(IsExcelCLSID(preobj->clsid))
		_pi.dwFlags |= REO_GETMETAFILE;

	else if(IsEqualCLSID(preobj->clsid, CLSID_WordArt))
		_fIsWordArt2 = TRUE;

	else if(IsEqualCLSID(preobj->clsid, CLSID_PaintbrushPicture) ||
			IsEqualCLSID(preobj->clsid, CLSID_BitmapImage))
	{
		_fIsPaintBrush = TRUE;

		// These calls will initialize the flag, _fPBUseLocalSize, which
		// indicates that for this PB object, SetExtent calls are not 
		// acknowledged by the object, and we are to use our local value
		// of _size as the object extents.
		FetchObjectExtents();
		SetExtent(SE_NOTACTIVATING);
	}
#ifndef NOINKOBJECT
	else if(IsEqualCLSID(preobj->clsid, CLSID_Ink))
	{
		ILineInfo	*pILineInfo;

		_fIsInkObject = TRUE;

		_pi.dwFlags &= ~REO_RESIZABLE;		// No resizing for ink objects
		_pi.dwFlags |= REO_BELOWBASELINE | REO_INVERTEDSELECT;

		if(_punkobj->QueryInterface(IID_ILineInfo, (void **)&pILineInfo) == NOERROR)
		{
			UINT	iInkWidth = 0;

			_pILineInfo = pILineInfo;
			
			// Inform Ink object for the formatting changes
			_ped->SetInkProps(_cp, _pILineInfo, &iInkWidth);
		}
	}
#endif

	hr = ConnectObject();

    if(IsZombie())
        return CO_E_RELEASED;
        
	if(preobj->sizel.cx || preobj->sizel.cy)
		memcpy(&_size, &preobj->sizel, sizeof(SIZE));
	else
		FetchObjectExtents();

    if(IsZombie())
        return CO_E_RELEASED;

	// We don't do the following anymore although it was originally spec'd as the correct
	// behavior for applications in OLE 2.01. The reason is that no one else seems to and
	// it seems to result in some odd behavior.
#if 0
    // Finally, lock down Link objects so they we don't try to refetch their
	// extents from the server.  After initialization, link object size is
	// entirely determined by the container.
	if(_pi.dwFlags & REO_LINK)
    {
        // so we don't call GetExtents on remeasuring.
        _fSetExtent = TRUE;
	}
#endif 

	return NOERROR;
}

/*
 *	COleObject::MeasureObj(dypInch, dxpInch, dup, dvpAscent, dvpDescent, dvpDescentFont, tflow)
 *
 * Review: (keithcu) Should yDescentFont be descent of font
 * or descent of entire line? LS does one thing, old measurer
 * does another. I'm hoping that this feature is only used on
 * lines with one font..
 *	@mfunc	calculates the size of this object in device units
 */
void COleObject::MeasureObj(
	long	dvpInch,		//@parm	resolution of device
	long	dupInch,
	LONG &	dup,			//@parm Object width
	LONG &	dvpAscent,		//@parm Object ascent
	LONG &  dvpDescent,		//@parm Object descent
	SHORT	dvpDescentFont,	//@parm object's font descent
	TFLOW	tflow)			//@parm textflow
{
	LONG dvp;

	//If we are rotated and the OLE object doesn't understand rotation, then
	//we will measure and draw the object unrotated
	if (IsUVerticalTflow(tflow) && !(_pi.dwFlags & REO_CANROTATE))
	{
		dup = W32->HimetricToDevice(_size.dv, dupInch);
		dvp = W32->HimetricToDevice(_size.du, dvpInch);
	}
	else
	{
		dup = W32->HimetricToDevice(_size.du, dupInch);
		dvp = W32->HimetricToDevice(_size.dv, dvpInch);
	}

	if (_pi.dwFlags & REO_BELOWBASELINE)
	{
		dvpDescent = dvpDescentFont;
		dvpAscent = max(0, dvp - dvpDescent);
	}
	else //The normal case
	{
		dvpAscent = dvp;
		dvpDescent = 0;
	}
}

/* 
 * COleObject::InHandle(x, y, &pt)
 *
 * @mfunc  See if a point is in the rectangle defined by the handle at
 *		the given coordinates.
 *
 * @rdesc True if point is in handle.
 */
BOOL COleObject::InHandle(
	int		up,		//@parm Upper left corner x coordinate of handle box
	int		vp,		//@parm Upper left corner y coordinate of handle box
	const POINTUV &pt)//@parm Point to check
{
    RECTUV    rc;
    
    rc.left = up;
    rc.top = vp;

	// Add one to bottom right because PtInRect does not consider
	// points on bottom or right to be in rect.
    rc.right = rc.left + dxyHandle + 1;
    rc.bottom = rc.top + dxyHandle + 1;
    return PtInRect(&rc, pt);
}  

/*
 *	COleObject::CheckForHandleHit(&pt)
 *
 *	@mfunc	Check for a hit on any of the frame handles.
 *
 *	@rdesc	 NULL if no hit, cursor resource ID if there is a hit.
 */
LPTSTR COleObject::CheckForHandleHit(
	const POINTUV &pt,	//@parm POINT containing client coord. of the cursor.
	BOOL fLogical)		//@parm TRUE if you want the logical as opposed to visual cursor
{
	// If object is not resizeable, no chance of hitting a resize handle!
	if(!(_pi.dwFlags & REO_RESIZABLE) || FWrapTextAround())
		return NULL;

	RECTUV rc;
	GetRectuv(rc);

	if(!_dxyFrame)
		_dxyFrame = dxyFrameDefault;

	// Check to see if point is farther into the interior of the
	// object than the handles extent. If it is we can just bail.
	InflateRect(&rc, -(_dxyFrame + dxyHandle), -(_dxyFrame + dxyHandle));
	if(PtInRect(&rc, pt))
		return NULL;

	WCHAR *idcur = 0;

	// Check to see if point is in any of the handles and
	// return the proper cursor ID if it is.
	InflateRect(&rc, dxyHandle, dxyHandle);

	if(InHandle(rc.left, rc.top, pt) ||
	   InHandle(rc.right-dxyHandle, rc.bottom-dxyHandle, pt))
	{
		idcur = IDC_SIZENWSE;
	}
	else if(InHandle(rc.left, rc.top+(rc.bottom-rc.top-dxyHandle)/2, pt) ||
	   InHandle(rc.right-dxyHandle,
			rc.top+(rc.bottom-rc.top-dxyHandle)/2, pt))
	{
		idcur = IDC_SIZEWE;
	}
	else if(InHandle(rc.left, rc.bottom-dxyHandle, pt) ||
	   InHandle(rc.right-dxyHandle, rc.top, pt))
	{
		idcur = IDC_SIZENESW;
	}
	else if(InHandle(rc.left+(rc.right-rc.left-dxyHandle)/2, rc.top, pt) ||
	   InHandle(rc.left+(rc.right-rc.left-dxyHandle)/2,
			rc.bottom-dxyHandle, pt))
	{
		idcur = IDC_SIZENS;
	}

	//Convert logical cursor to visual cursor
	if (!fLogical && IsUVerticalTflow(_ped->_pdp->GetTflow()))
	{
		if (idcur == IDC_SIZENS)
			idcur = IDC_SIZEWE;
		else if (idcur == IDC_SIZEWE)
			idcur = IDC_SIZENS;
		else if (idcur == IDC_SIZENESW)
			idcur = IDC_SIZENWSE;
		else if (idcur == IDC_SIZENWSE)
			idcur = IDC_SIZENESW;
	}

	return idcur;
}

/* 
 * COleObject::DrawHandle(hdc, x, y)
 *
 * @mfunc  Draw a handle on the object frame at the specified coordinate
 */
void COleObject::DrawHandle(
	HDC hdc,	//@parm HDC to be drawn into
	int x,		//@parm x coordinate of upper-left corner of handle box
	int y)		//@parm y coordinate of upper-left corner of handle box
{
    RECT    rc;
    
	// Draw handle by inverting
    rc.left = x;
    rc.top = y;
    rc.right = x + dxyHandle;
    rc.bottom = y + dxyHandle;
    InvertRect(hdc, &rc);
}  

/*
 *	COleObject::DrawFrame(pdp, hdc, prc)
 *
 *	@mfunc	Draw a frame around the object.  Invert if required and
 *		include handles if required.
 */
void COleObject::DrawFrame(
	const CDisplay *pdp,    //@parm the display to draw to
	HDC             hdc,	//@parm the device context
	RECT           *prc)  //@parm the rect around which to draw
{
	if(_pi.dwFlags & REO_OWNERDRAWSELECT)
		return;

	RECT	rc;
	CopyRect(&rc, prc);

	if(_pi.dwFlags & REO_INVERTEDSELECT)
		InvertRect(hdc, &rc);				//Invert entire object

	else
	{
		// Just the border, so use a null brush
		int ropOld = SetROP2(hdc, R2_NOT);
		HBRUSH hbrOld = (HBRUSH) SelectObject(hdc, GetStockObject(NULL_BRUSH));
		Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
		SelectObject(hdc, hbrOld);
		SetROP2(hdc, ropOld);
	}

	if(_pi.dwFlags & REO_RESIZABLE)
	{
		int     bkmodeOld;
		HPEN	hpen;
		LOGPEN	logpen;

		bkmodeOld = SetBkMode(hdc, TRANSPARENT);

		// Get frame width
		_dxyFrame = dxyFrameDefault;
		hpen = (HPEN)GetCurrentObject(hdc, OBJ_PEN);
		if(W32->GetObject(hpen, sizeof(LOGPEN), &logpen))
		{
			if(logpen.lopnWidth.x)
				_dxyFrame = (SHORT)logpen.lopnWidth.x;
		}

		// Draw handles inside rectangle boundary
 		InflateRect(&rc, -_dxyFrame, -_dxyFrame);

		LONG x = rc.left;

		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.top	 + (rc.bottom - rc.top - dxyHandle)/2);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		x = rc.left + (rc.right - rc.left - dxyHandle)/2; 
		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		x = rc.right - dxyHandle;
		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.top + (rc.bottom - rc.top - dxyHandle)/2);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		SetBkMode(hdc, bkmodeOld);
	}
}


/*
 *	COleObject::CreateDib (hdc)
 *
 *	@mfunc	Create DIB for Windows CE display
 */
void COleObject::CreateDib(
	HDC hdc)
{
	int				nCol = 0;
    BYTE            *pbDib;
	HGLOBAL			hnew = NULL;
	BYTE			*pbSrcBits;
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(_hdata);
	DWORD			dwPixelsPerRow = 0;
	DWORD			dwPixels = 0;

    if(pbmi->bmiHeader.biBitCount <= 8)
    {
	    nCol = 1 << pbmi->bmiHeader.biBitCount;

		// Calculate the number of pixels.  Account for DWORD alignment
		DWORD dwPixelsPerByte = 8 / pbmi->bmiHeader.biBitCount;
		DWORD dwBitsPerRow = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;
		dwBitsPerRow = (dwBitsPerRow + 7) & ~7;				// Round up to byte boundary
		DWORD dwBytesPerRow = dwBitsPerRow / 8;
		dwBytesPerRow = (dwBytesPerRow + 3) & ~3;			// Round up to DWORD
		dwPixelsPerRow = dwBytesPerRow * dwPixelsPerByte;

		// Double check with original
		#ifdef DEBUG
		DWORD dwBlockSize = GlobalSize(_hdata);
		DWORD dwBitMapBytes = dwBlockSize - sizeof(BITMAPINFOHEADER) - (nCol * sizeof(RGBQUAD));
		DWORD dwBitMapPixels = dwBitMapBytes * dwPixelsPerByte;
		dwPixels = dwPixelsPerRow * pbmi->bmiHeader.biHeight;
		Assert(dwPixels == dwBitMapPixels);
		#endif
    }
	else
		dwPixelsPerRow = pbmi->bmiHeader.biWidth;

	dwPixels = dwPixelsPerRow * pbmi->bmiHeader.biHeight;
    
	pbSrcBits = (BYTE*)(pbmi) + sizeof(BITMAPINFOHEADER) + (nCol * sizeof(RGBQUAD));

#ifdef UNDER_NT

	// For NT viewing convert four color bitmaps to 16 color bitmap
	if(nCol == 4)
	{
		// First let's figure out how big the new memory block needs to be.
		DWORD cb = sizeof(BITMAPINFOHEADER) + (16 * sizeof(RGBQUAD));
		cb += dwPixels / 2;
		hnew = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cb);
	
		// Now locate the interesting places
		LPBITMAPINFO pNewBmi = (LPBITMAPINFO) GlobalLock(hnew);
		BYTE *pNewBits = (BYTE*)(pNewBmi) + sizeof(BITMAPINFOHEADER) + (16 * sizeof(RGBQUAD));

		// Modify the header
		pNewBmi->bmiHeader = pbmi->bmiHeader;
		pNewBmi->bmiHeader.biBitCount = 4;
		pNewBmi->bmiHeader.biClrUsed = 4;

		// Set up the DIB RGB Colors.
		for (int i = 0; i < 16; i++)
		{
			BYTE data = 0;
			switch (i % 4)
			{
			case 0:
				break;
			case 1:
				data = 0x55;
				break;
			case 2:
				data = 0xAA;
				break;
			case 3:
				data = 0xFF;
				break;
			}
			pNewBmi->bmiColors[i].rgbBlue = data;
			pNewBmi->bmiColors[i].rgbGreen = data;
			pNewBmi->bmiColors[i].rgbRed = data;
			pNewBmi->bmiColors[i].rgbReserved = 0;
		}

		// Convert the byte array.
		for (DWORD j = 0; j < dwPixels; j++)
		{
			int iSrcByte = j / 4;

			BYTE bits = pbSrcBits[iSrcByte];
			bits >>= 6 - (j%4) * 2;
			bits &= 0x3;
			int iDstByte = j / 2;
			bits <<= 4 - (j%2) * 4;
			pNewBits[iDstByte] |= bits;
		}
		GlobalUnlock(pbmi);
		pbmi = pNewBmi;
		pbSrcBits = pNewBits;
	}
#endif

	_hdib = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, (void**)&pbDib, NULL, 0);
	if(_hdib == NULL)
	{
		_ped->GetCallMgr()->SetOutOfMemory();

        // V-GUYB:
        // Do not attempt to repaint this picture until the user starts typing in the
        // control. This allows the user to dismiss the oom that will appear and then
        // save the document, and then free up some space. If we don't do this here, 
        // every time the oom msg is dismissed it will appear again. This doesn't allow 
        // the user to save the document unless they can find some memory to free.
        _fDraw = FALSE;

		TRACEWARNSZ("Out of memory creating DIB");
		return;
	}

	DWORD nBytes;

	if(nCol)
	{
		DWORD nPixelsPerByte =  8 / pbmi->bmiHeader.biBitCount;
		nBytes = dwPixels / nPixelsPerByte;
	}
	else
		nBytes =  dwPixels * 4;			// Each pixel occupies 4 bytes in DIB
	CopyMemory(pbDib, pbSrcBits, nBytes);

	GlobalUnlock(pbmi);
	GlobalFree(hnew);
}

/*
 *	COleObject::DrawDib (hdc, prc)
 *
 *	@mfunc	Auxiliary function that draws the dib in the given dc
 */
void COleObject::DrawDib(
	HDC hdc,
	RECT *prc)
{
	if(!_hdib)
		CreateDib(hdc);

	// If _hdib is still NULL, just return.  Maybe out of memory.
	if(!_hdib)
		return;

	HDC hdcMem = CreateCompatibleDC(hdc);
	if (!hdcMem)
		return;

	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(_hdata);
	SelectObject(hdcMem, _hdib);
    StretchBlt(hdc, prc->left, prc->top,
			prc->right - prc->left, prc->bottom - prc->top,
			hdcMem, 0, 0, pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biHeight, SRCCOPY);
	GlobalUnlock(pbmi);
	DeleteDC(hdcMem);
}

/*
 *	COleObject::DrawObj (pdp, hdc, fMetafile, ppt, prcRender)
 *
 *	@mfunc	draws the object.
 *	REVIEW (keithcu) How expensive is SaveDC/RestoreDC? We could
 *  have a flag when we know that the object isn't going to totally screw
 *	around with our DC and then not go through that expense.
 *
 */
void COleObject::DrawObj(
	const CDisplay *pdp,	//@parm Display object for the view
	LONG		dypInch,	//@parm Resolution of device
	LONG		dxpInch,
	HDC			hdc,		//@parm Drawing HDC (can differ from display's)
	const RECTUV *prcClip,	//@parm Clipping rectangle
	BOOL		fMetafile,	//@parm Whether the HDC is a metafile
	POINTUV	   *ppt,		//@parm Top left corner of where to draw
	LONG		dvpBaselineLine,
	LONG		dvpDescentMaxCur,
	TFLOW		tflow)
{
	BOOL			 fMultipleSelect = FALSE;
	CObjectMgr *	 pobjmgr = _ped->GetObjectMgr();
	IViewObject *	 pvo;
	CDisplayPrinter *pdpPrint;
	RECT			 rc, rcClip;
	RECTUV			 rcuv;
	LONG			 cpMin, cpMost;
	_ped->GetSelRangeForRender(&cpMin, &cpMost);
	BOOL			 fSelected = _cp >= cpMin && _cp < cpMost && !FWrapTextAround();

	SaveDC(hdc);	 //Anything in this function below could change things.

	if(pdp->IsMain() && !(_pi.dwFlags & REO_OWNERDRAWSELECT))
	{
		if (fSelected)
		{
			if(cpMost - cpMin > 1)
				fMultipleSelect = TRUE;

			// The following overwrites the selection colors currently
			// selected into the hdc. We do this for RE 2.0 compatibility,
			// e.g., else selected name links in Outlook appear yellow
			// after the InvertRect() in DrawFrame() (altho the semicolon
			// blanks appear in selection colors). Note: we could define
			// REO_OWNERDRAWSELECT, which would bypass the following 2 lines
			// and suppress the InvertRect below and in DrawFrame(). Then
			// Outlook's From:, To:, and CC: would have correct selection
			// colors throughout.
			::SetTextColor(hdc, _ped->TxGetForeColor());
			::SetBkColor  (hdc, _ped->TxGetBackColor());
		}
	}

	if(_fInPlaceActive || !_fDraw)
	{
		// If we're inplace active, don't do anything; the server is
		// drawing for us. We also don't do anything prior to the fDraw
		// property being set
		return;
	}

	// Draw object where we are asked within rendering rectangle
	rcuv.left = ppt->u;
	rcuv.bottom = ppt->v + dvpBaselineLine;

	if (IsUVerticalTflow(tflow) && !(_pi.dwFlags & REO_CANROTATE))
	{
		rcuv.right = rcuv.left + W32->HimetricToDevice(_size.dv, dypInch);
		rcuv.top = rcuv.bottom - W32->HimetricToDevice(_size.du, dxpInch);
	}
	else
	{
		rcuv.right = rcuv.left + W32->HimetricToDevice(_size.du, dxpInch);
		rcuv.top = rcuv.bottom - W32->HimetricToDevice(_size.dv, dypInch);
	}

	if (_pi.dwFlags & REO_BELOWBASELINE)
		OffsetRect((RECT*)&rcuv, 0, dvpDescentMaxCur);

	pdp->RectFromRectuv(rc, rcuv);
	pdp->RectFromRectuv(rcClip, *prcClip);

	if (fSelected)
		SetBkMode(hdc, OPAQUE);

	SetTextAlign(hdc, TA_TOP);

	SaveDC(hdc);  // calls to OLE object (IViewObject::Draw or OleDraw) might change HDC

	//Do clipping because OLE doesn't know where to draw
	IntersectClipRect(hdc, rcClip.left, rcClip.top, rcClip.right, rcClip.bottom);

	if(_fIsEBookImage)
	{
		POINT pt = {rc.left, rc.top};
		WinLPtoDP(hdc, &pt, 1);
		if(_ped->fInHost2())
    		(_ped->GetHost())->TxEBookImageDraw(_EBookImageID, hdc, &pt, NULL/*&rc*/,
                                        (pobjmgr->GetSingleSelect()==this));
	}
	else if(_hdata)
	{
		// This is some Windows CE Dib, let's try the direct approach
		DrawDib(hdc, &rc);
	}
	else if(fMetafile)
	{
		if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) 
				== NOERROR)
		{
			pdpPrint = (CDisplayPrinter *)pdp;

			//REVIEW (keithcu) Has this ever been tested? GetPrintPage
			//is in twips while IViewObject::Draw is in metafile units!
			RECT rc1 = pdpPrint->GetPrintPage();

			// Fix up rc for Draw()
			rc1.bottom = rc1.bottom - rc1.top;			    
			rc1.right = rc1.right - rc1.left;

			pvo->Draw(_pi.dvaspect, -1, NULL, NULL, 0, hdc, (RECTL *)&rc,
					(RECTL *)&rc1, NULL, 0);
			pvo->Release();
		}
	}
	else
		OleDraw(_punkobj, _pi.dvaspect, hdc, &rc);

	RestoreDC(hdc, -1);

	// Do selection stuff if this is for the main (screen) view.
	if(pdp->IsMain() && !FWrapTextAround())
	{
		if(_pi.dwFlags & REO_OPEN)
			OleUIDrawShading(&rc, hdc);

		// If the object has been selected by clicking on it, draw
		// a frame and handles around it.  Otherwise, if we are selected
		// as part of a range, invert ourselves.
		if(!fMetafile && pobjmgr->GetSingleSelect() == this)
			DrawFrame(pdp, hdc, &rc);

		else if(fMultipleSelect)
			InvertRect(hdc, &rc);
	}

	RestoreDC(hdc, -1);
}

/*
 *	COleObject::Delete (publdr)
 *
 *	@mfunc	deletes this object from the backing store _without_
 *			making outgoing calls.  The commit on generated anti-events
 *			will handle the outgoing calls
 */
void COleObject::Delete(
	IUndoBuilder *publdr)
{

	Assert(_fInUndo == FALSE);
	_fInUndo = TRUE;

	//REVIEW (keithcu) Too heavy handed?
 //	if (FWrapTextAround())
//		_ped->_pdp->InvalidateRecalc();

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Remove((ITxNotify *)this);

	if(publdr)
	{
		// The anti-event will take care of calling IOO::Close for us
		IAntiEvent *pae = gAEDispenser.CreateReplaceObjectAE(_ped, this);
		if(pae)
			publdr->AddAntiEvent(pae);
	}
	else
	{
		Close(OLECLOSE_NOSAVE);
		MakeZombie();
	}

	// If we're being deleted, we can't be selected anymore
	_pi.dwFlags &= ~REO_SELECTED;
	_fDraw = 0;
}

/*
 *	COleObject::Restore()
 *
 *	@mfunc	restores the object from the undo state back into the
 *			backing store
 *
 *			No outgoing calls will be made
 */
void COleObject::Restore()
{
	Assert(_fInUndo);

	_fInUndo = FALSE;
	_fDraw = TRUE;

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);
}

/*
 *	COleObject::SetREOSELECTED (fSelect)
 *
 *	@mfunc	cmember set REO_SELECTED state
 */
void COleObject::SetREOSELECTED(
	BOOL fSelect)
{
	_pi.dwFlags &= ~REO_SELECTED;
	if(fSelect)
		_pi.dwFlags |= REO_SELECTED;
}
    
/*
 *	COleObject::Close(dwSave)
 *
 *	@mfunc	closes this object
 */
void COleObject::Close(
	DWORD	dwSave)		//same as IOleObject::Close
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::Close");

	if(!_punkobj)
		return;

	IOleObject *poo;
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		poo->Close(dwSave);
		poo->Release();
	}
}

				
//
//	PRIVATE methods
//
/*
 *	COleObject::~COleObject()
 *
 *	@mfunc	destructor
 */
COleObject::~COleObject()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::~COleObject");

	CleanupState();
}

/*
 *	COleObject::SavePrivateState()
 *
 *	@mfunc	Saves information such as the aspect and various flags
 *	into the object's storage.
 *
 *	@devnote	This method is used mostly for compatibility with 
 *	richedit 1.0--we save the same information they did.
 *
 *	Also note that this method returns void--even if any particular
 *	call fails, we should be able to "recover" and limp along.
 *	Richedit 1.0 also had this behavior.
 */
void COleObject::SavePrivateState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::SavePrivateState");
	Assert(_pstg);

	IStream *	pstm;
	HRESULT hr = _pstg->CreateStream(szSiteFlagsStm, STGM_READWRITE |
					STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
    if(IsZombie())
        return;
        
	if(hr == NOERROR)
	{
		pstm->Write(&_pi, sizeof(PersistedInfo), NULL);
		pstm->Release();
	}
}

/*
 *	COleObject::FetchObjectExtents()
 *
 *	@mfunc 	determines the object's size in himetric.  Typically, this
 *			is achieved via IOleObject::GetExtent, but some error 
 *			recovery is implemented
 *
 *	@rdesc	void.  _size is updated
 */
void COleObject::FetchObjectExtents()
{
	HRESULT hr = NOERROR;
	IOleObject *poo;
	IViewObject2 *pvo;

    if(IsZombie())
        return;
        
	// We _don't_ want to make calls to GetExtent if:
	// (1) We have outstanding updates to _size for which we
	//		haven't successfully called SetExtent
	// (2) This is a PaintBrush object and the most recent call 
	//		to SetExtent for this PB object failed

	if(_fIsEBookImage)
	{
		_size.du = _ped->_pdp->DUtoHimetricU(_sizeEBookImage.cx);
		_size.dv = _ped->_pdp->DVtoHimetricV(_sizeEBookImage.cy);
	}
	else
	if(_fAspectChanged || !(_fSetExtent || (_fIsPaintBrush && _fPBUseLocalSize)))
	{	
		// try IOleObject::GetExtent as long as we shouldn't try for
		// the metafile first.

		// If this flag was set, it has done its job so turn it off.
		_fAspectChanged = FALSE;

		if(!(_pi.dwFlags & REO_GETMETAFILE))
		{
			hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
			if(hr == NOERROR)
			{
				hr = poo->GetExtent(_pi.dvaspect, (SIZE*)&_size);
				poo->Release();
			}
			if(IsZombie())
				return;
		}
		else
			hr = E_FAIL;
        
		if(hr != NOERROR)
		{
			if(_punkobj->QueryInterface(IID_IViewObject2, (void **)&pvo) == NOERROR)
			{
				hr = pvo->GetExtent(_pi.dvaspect, -1, NULL, (SIZE*)&_size);
				pvo->Release();
			}
		}

	    if(IsZombie())
	        return;
        
		if(hr != NOERROR || _size.du == 0 || _size.dv == 0)
			_size.du = _size.dv = 2000;
	}
}

/*
 *	COleObject::ConnectObject()
 *
 *	@mfunc	setup the necessary advises to the embedded object.
 *
 *	@rdesc 	HRESULT
 *
 *	@comm	This code is similar to ole2ui's OleStdSetupAdvises
 */
HRESULT COleObject::ConnectObject()
{
	IViewObject *pvo;
	IOleObject *poo;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::ConnectObject");
	
    if(IsZombie())
        return CO_E_RELEASED;
	
	Assert(_punkobj);

	if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) == NOERROR)
	{
		pvo->SetAdvise(_pi.dvaspect, ADVF_PRIMEFIRST, (IAdviseSink *)this);
		pvo->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
	
	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		hr = poo->Advise((IAdviseSink *)this, &_dwConn);

		CObjectMgr *pobjmgr = _ped->GetObjectMgr();
		Assert(pobjmgr);		
		if(!pobjmgr)
		{
			poo->Release();
			return E_OUTOFMEMORY;
		}

		// The doc may be NULL, but not the app.  Don't do anything
		// if the app name is NULL
		if(pobjmgr->GetAppName())
		{
			hr = poo->SetHostNames(pobjmgr->GetAppName(), 
						pobjmgr->GetDocName());
		}
		poo->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
	
	OleSetContainedObject(_punkobj, TRUE);
	return hr;
}

/*
 *	COleObject::DisconnectObject
 *
 *	@mfunc	reverses the connections made in ConnectObject and releases
 *			the object.  Note that the object's storage is _NOT_
 *			released.
 */
void COleObject::DisconnectObject()
{
	IOleObject * poo = NULL;
	IViewObject *pvo = NULL;

	if(IsZombie())
		return;		// Already Disconnected.

	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		poo->SetClientSite(NULL);
		if(_dwConn)
			poo->Unadvise(_dwConn);
	
		poo->Release();
	}

	if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) == NOERROR)
	{
		pvo->SetAdvise(_pi.dvaspect, ADVF_PRIMEFIRST, NULL);
		pvo->Release();
	}

#ifndef NOINKOBJECT
	SafeReleaseAndNULL((IUnknown**)&_pILineInfo);
#endif

	CoDisconnectObject(_punkobj, NULL);
	SafeReleaseAndNULL(&_punkobj);
}

/*
 *	COleObject::MakeZombie()
 *
 *	@mfunc	Force this object to enter a zombie state.  This
 *      is called when we should be gone but aren't.  It cleans
 *      up our state and flags us so we don't do nasty things
 *		between now and the time were are deleted.
 *
 */
void COleObject::MakeZombie()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::MakeZombie");

	CleanupState();
    Zombie();
}

/*
 *	COleObject::CleanupState()
 *
 *	@mfunc	Called on delete and when we become zombied.  It cleans
 *		up our member data and any other dependencies that need to
 *		be resolved.
 */
void COleObject::CleanupState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::CleanupState");
	
	CDocInfo *pDocInfo = NULL;
	if(_ped)
	{
		pDocInfo = _ped->GetDocInfoNC();
		if(!_fInUndo)
		{
			CNotifyMgr *pnm = _ped->GetNotifyMgr();
			if(pnm)
				pnm->Remove((ITxNotify *)this);

			_ped = NULL;
		}
	}

	DisconnectObject();

	if(_pstg)
		SafeReleaseAndNULL((IUnknown**)&_pstg);

	if(_hdib)
	{
		::DeleteObject(_hdib);
		_hdib = NULL;
	}

	if(!pDocInfo || _hdata != pDocInfo->_hdata)
		GlobalFree(_hdata);	// Don't free _hdata if background is using it

	_hdata = NULL;
	if(_pimageinfo)
	{
		delete _pimageinfo;
		_pimageinfo = NULL;
	}
}	

/*
 *	COleObject::ActivateObj	(uiMsg, wParam, lParam)
 *	
 *	@mfunc Activates the object.
 *
 *	@rdesc
 *		BOOL	Whether object has been activated.
 */
BOOL COleObject::ActivateObj(
	UINT uiMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	LPOLEOBJECT		poo;
	HWND			hwnd;
	MSG				msg;
	DWORD			dwPos;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::AcitvateObj");

	if(_ped->TxGetWindow(&hwnd) != NOERROR)
		return FALSE;

	// Fill in message structure
	msg.hwnd = hwnd;
	msg.message = uiMsg;
	msg.wParam = wParam;
	msg.lParam = lParam;
	msg.time = GetMessageTime();
	dwPos = GetMessagePos();
	msg.pt.x = (LONG) LOWORD(dwPos);
	msg.pt.y = (LONG) HIWORD(dwPos);

	// Force this object to be selected, if it isn't already
	// Update the selection before making the outgoing call
	if(!(_pi.dwFlags & REO_SELECTED))
	{
		CTxtSelection *psel = _ped->GetSel();
		if(psel)
			psel->SetSelection(_cp, _cp + 1);
	}

	// Execute the primary verb
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		_fActivateCalled = TRUE;

		// Make sure we tell the object its size has changed if we haven't
		// already notified it.
		if(_fSetExtent)
			SetExtent(SE_ACTIVATING);

		HRESULT	hr;
		RECTUV rc;
		RECT rcPos;

		GetRectuv(rc);
		_ped->_pdp->RectFromRectuv(rcPos, rc);
		hr = poo->DoVerb(OLEIVERB_PRIMARY, &msg, (LPOLECLIENTSITE)this, 0, hwnd, &rcPos);

		if(FAILED(hr))
		{
			ENOLEOPFAILED	enoleopfailed;

			enoleopfailed.iob = _ped->_pobjmgr->FindIndexForCp(GetCp());
			enoleopfailed.lOper = OLEOP_DOVERB;
			enoleopfailed.hr = hr;
	        _ped->TxNotify(EN_OLEOPFAILED, &enoleopfailed);
		}
	    poo->Release();
		if(_fInPlaceActive && !(_pi.dwFlags & REO_INPLACEACTIVE))
		{
			CObjectMgr *pobjmgr = _ped->GetObjectMgr();
			if(!pobjmgr)
			{
				_fActivateCalled = FALSE;
				return FALSE;
			}

			Assert(!pobjmgr->GetInPlaceActiveObject());	
			pobjmgr->SetInPlaceActiveObject(this);
			_pi.dwFlags |= REO_INPLACEACTIVE;
		}
		_fActivateCalled = FALSE;
	}
	else
		return FALSE;

	return TRUE;
}

/*
 *	COleObject::DeActivateObj
 *	
 *	@mfunc Deactivates the object.
 *
 */
HRESULT COleObject::DeActivateObj(void)
{
	IOleInPlaceObject * pipo;
	IOleObject *poo;
	MSG msg;
	HRESULT hr = NOERROR;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::DeActivateObj");

	if (_fDeactivateCalled)
	{
		// There are multiple paths through the deactive code. The assumption
		// with this logic is that it is more disconcerting for an app to
		// get multiple deactivate calls than the opposite. This might
		// prove to be an incorrect assumption. This go put in because I
		// added a DeActivateObj call in DeActivateObj where there wasn't
		// one before and I was afraid that this could cause problems because
		// apps might get a call that they didn't have before. It is important
		// to note that the opposite might be the case. (a-rsail).
		return NOERROR;
	}

	_fDeactivateCalled = TRUE;

	if(_punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo) 
		== NOERROR)
	{
		hr  =_punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
		if(hr == NOERROR) 
		{
			// This code is a bit different from 1.0, but seems to 
			// make things work a bit better.  Basically, we've taken a leaf
			// from various sample apps and do the most brute force "de-activate"
			// possible (you'd think just one call would be enough ;-)

			// Don't bother with the error return here.
			pipo->UIDeactivate();
			
			// Fake something
			ZeroMemory(&msg, sizeof(MSG));
			msg.message = WM_LBUTTONDOWN;	
			_ped->TxGetWindow(&msg.hwnd);

			RECT	rcPos;
			RECTUV rcuv;
			GetRectuv(rcuv);
			_ped->_pdp->RectFromRectuv(rcPos, rcuv);

			// Again, don't bother checking for errors; we need to
			// plow through and get rid of stuff as much as possible.
			poo->DoVerb(OLEIVERB_HIDE, &msg, (IOleClientSite *)this, -1, msg.hwnd, &rcPos);

			// COMPATIBILITY ISSUE (alexgo): the RE1.0 code did some funny
			// stuff with undo here, but I don't think it's necessary now
			// with our multi-level undo model.
			hr = pipo->InPlaceDeactivate();
			poo->Release();
		}
	    pipo->Release();
	}

	_fDeactivateCalled = FALSE;
	return hr; 
}

/*
 *	COleObject::Convert (rclsidNew,	lpstrUserTypeNew)
 *
 *	@mfunc	Converts the object to the specified class.  Does reload
 *		the object but does NOT force an update (caller must do this).
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::Convert(
	REFCLSID rclsidNew,			//@parm Destination clsid
	LPCSTR	 lpstrUserTypeNew)	//@parm New user type name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Convert");

	CLIPFORMAT cfOld;
	CLSID clsidOld;
	LPOLESTR szUserTypeOld = NULL;
	HRESULT hr;
	HRESULT hrLatest;
	UsesMakeOLESTR;


	// If object has no storage, return
	if(!_pstg)
		return ResultFromScode(E_INVALIDARG);

	// Read the old class, format, and user type in
	if ((hr = ReadClassStg(_pstg, &clsidOld)) ||
		(hr = ReadFmtUserTypeStg(_pstg, &cfOld, &szUserTypeOld)))
	{
		return hr;
	}

	// Unload object
	Close(OLECLOSE_SAVEIFDIRTY);
	_punkobj->Release();

    if(IsZombie())
        return CO_E_RELEASED;

	// Write new class and user type, but old format, into storage
	if ((hr = WriteClassStg(_pstg, rclsidNew)) ||
		(hr = WriteFmtUserTypeStg(_pstg, cfOld,
			(LPOLESTR) MakeOLESTR(lpstrUserTypeNew))) ||
		(hr = SetConvertStg(_pstg, TRUE)) ||
		((hr = _pstg->Commit(0)) && (hr = _pstg->Commit(STGC_OVERWRITE))))
	{
		// Uh oh, we're in a bad state; rewrite the original info
		(VOID) WriteClassStg(_pstg, clsidOld);
		(VOID) WriteFmtUserTypeStg(_pstg, cfOld, szUserTypeOld);
	}

    if(IsZombie())
        return CO_E_RELEASED;

	// Reload the object and connect. If we can't reload it, delete it.
	hrLatest = OleLoad(_pstg, IID_IOleObject, (LPOLECLIENTSITE) this,
			(void **)&_punkobj);

	if(hrLatest != NOERROR)
	{
		CRchTxtPtr	rtp(_ped, _cp);

		// we don't want the delete of this object to go on the undo
		// stack.  We use a space so that cp's will work out right for
		// other undo actions.
		rtp.ReplaceRange(1, 1, L" ", NULL, -1);
	}
	else
		ConnectObject();

	// Free the old
	CoTaskMemFree(szUserTypeOld);
	return hr ? hr : hrLatest;
}

/*
 *	COleObject::ActivateAs (rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a particular
 *		class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::ActivateAs(
	REFCLSID rclsid,
	REFCLSID rclsidAs)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::ActivateAs");

	IOleObject * poo = NULL;
	CLSID	clsid;

	// Get clsid of object
	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		// NOTE:  We are depending on the behavior of GetUserClassID to
		// return the current clsid of the object (not the TreatAs id).
		// This should hold true as long as long as we haven't reloaded
		// it yet.  If there are problems with ActivateAs in the future,
		// this might be a suspect.
		hr = poo->GetUserClassID(&clsid);
		poo->Release();
	}

	if(hr != NOERROR)
		return hr;
	
    if(IsZombie())
        return CO_E_RELEASED;

	// Check to see if object clsid matches clsid to be treated as something
	// else. If it is we need to unload and reload the object.
	if(IsEqualCLSID(clsid, rclsid))
	{
		// Unload object
		Close(OLECLOSE_SAVEIFDIRTY);
		_punkobj->Release();

		if(IsZombie())
			return CO_E_RELEASED;

		// Reload object and connect. If we can't reload it, delete it.
		hr = OleLoad(_pstg, IID_IOleObject, (LPOLECLIENTSITE) this,
				(void **)&_punkobj);

		if(hr != NOERROR)
		{
			CRchTxtPtr	rtp(_ped, _cp);

			// We don't want the delete of this object to go on the undo
			// stack.  We use a space so that cp's will work out right for
			// other undo actions.
			rtp.ReplaceRange(1, 1, L" ", NULL, -1);
		}
		else
			ConnectObject();
	}
	return hr;
}

/*
 *	COleObject::SetLinkAvailable(fAvailable)
 *
 *	@mfunc
 *		Allows client to tell us whether the link is available or not.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::SetLinkAvailable(
	BOOL fAvailable)	//@parm	if TRUE, make object linkable
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SetLinkAvailable");
	
	// If this is not a link, return
	if(!(_pi.dwFlags & REO_LINK))
		return E_INVALIDARG;

	// Set flag as appropriate
	_pi.dwFlags &= ~REO_LINKAVAILABLE;
	if(fAvailable)
		_pi.dwFlags |= REO_LINKAVAILABLE;

	return NOERROR;
}

/*
 *	COleObject::WriteTextInfoToEditStream(pes, CodePage)
 *
 *	@mfunc
 *		Used for textize support,  Tries to determine the text representation
 *		for an object and then writes that info	to the given stream. If
 *		CodePage = 1200 (little-endian Unicode), the object is queried for
 *		Unicode text; else it's queried for Ansi text.
 *
 *	@rdesc
 *		LONG	count of chars written
 */
LONG COleObject::WriteTextInfoToEditStream(
	EDITSTREAM *pes,		//@parm Edit stream to write to
	UINT		CodePage)	//@parm CodePage: 1200 uses Unicode; else Ansi
{
	LONG		 cbWritten = 0;
	BOOL		 fUnicode = CodePage == 1200;
	STGMEDIUM	 med;
	IDataObject *pdataobj = NULL;
	IOleObject * poo;

	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		hr = poo->GetClipboardData(0, &pdataobj);
        poo->Release();
	}

	if(FAILED(hr))
	{
		hr = _punkobj->QueryInterface(IID_IDataObject, (void **)&pdataobj);
		if(FAILED(hr))
		{
			pes->dwError = (DWORD) E_FAIL;
			goto Default;
		}
	}

	med.tymed = TYMED_HGLOBAL;
	med.pUnkForRelease = NULL;
	med.hGlobal = NULL;

	hr = pdataobj->GetData(&g_rgFETC[fUnicode ? iUnicodeFETC : iAnsiFETC], &med);
	if(FAILED(hr))
		pes->dwError = (DWORD)hr;
	else
	{
		HANDLE	hGlobal = med.hGlobal;
		LONG	cb = 0;
		BYTE *	pb = (BYTE *)GlobalLock(hGlobal);
		if(pb)
		{
			if(fUnicode)
				for(; (WCHAR)pb[cb]; cb += 2);
			else
				for(; pb[cb]; cb++);

			pes->dwError = pes->pfnCallback(pes->dwCookie, pb, cb, &cbWritten);
			GlobalUnlock(hGlobal);
		}
		ReleaseStgMedium(&med);
	}

Default:
	if(cbWritten <= 0)
	{
		BYTE rgb[] = {' ', 0};

		pes->pfnCallback(pes->dwCookie, rgb, 1 + fUnicode, &cbWritten);
		pes->dwError = 0;
	}

    pdataobj->Release();
	return cbWritten;
}

/*
 *	COleObject::SetDvaspect (dvaspect)
 *
 *	@mfunc	Allows client to tell us which aspect to use and force us
 *		to recompute positioning and redraw.
 */
void COleObject::SetDvaspect(
	DWORD dvaspect)	//@parm	the aspect to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SetDvaspect");

	_pi.dvaspect = dvaspect;
	
	// Force FetchObjectExtents to call through
	_fAspectChanged = TRUE;

	// Cause ourselves to redraw and update
	OnViewChange(dvaspect, (DWORD) -1);
}

/*
 *	COleObject::HandsOffStorage
 *
 *	@mfunc	See IPersistStore::HandsOffStorage.
 *
 */
void COleObject::HandsOffStorage(void)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::HandsOffStorage");

	// Free storage we currently have, if we have one.
	SafeReleaseAndNULL((IUnknown**)&_pstg);
}

/*
 *	COleObject::SaveCompleted
 *
 *	@mfunc	See IPersistStore::SaveCompleted.
 */
void COleObject::SaveCompleted(
	LPSTORAGE lpstg)	//@parm	new storage
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SaveCompleted");

	// Did our caller give us a new storage to remember?
	if(lpstg)
	{
		// Free storage we currently have, if we have one
		if(_pstg)
			SafeReleaseAndNULL((IUnknown**)&_pstg);

		// Remember storage we are given, since we are given one
		lpstg->AddRef();
		_pstg = lpstg;
	}
}

/*
 *	SetAllowedResizeDirections
 *	
 *	@func Resizing helper function
 *
 */
static void SetAllowedResizeDirections(
	const POINTUV  & pt,
	const RECTUV   & rc,
	      LPTSTR   lphand,
	      BOOL   & fTop,
	      BOOL   & fBottom,
	      BOOL   & fLeft,
	      BOOL   & fRight)
{
   	fTop = abs(pt.v - rc.top) < abs(pt.v - rc.bottom);
	fBottom = !fTop;
	fLeft = abs(pt.u - rc.left) < abs(pt.u - rc.right);
	fRight = !fLeft;

	if(lphand == IDC_SIZENS)
		fLeft = fRight = FALSE; 
	else if(lphand == IDC_SIZEWE)
		fTop = fBottom = FALSE;
}

/*
 *	COleObject::HandleResize (&ptxy)
 *	
 *	@mfunc Deal with object resizing.
 *
 *	@rdesc	BOOL
 */
BOOL COleObject::HandleResize(
	const POINT &ptxy)
{
	LPTSTR lphand;
	DWORD  dwFlags = _pi.dwFlags;
 	HWND   hwnd;
	RECT   rcxyPos;
	RECTUV rcPos;
	BOOL   fTop, fBottom, fLeft, fRight, fEscape;
	POINTUV	pt;
	CDisplay *pdp = _ped->_pdp;
	int dupMin = pdp->GetDupSystemFont();
	int dvpMin = pdp->GetDvpSystemFont();

	pdp->PointuvFromPoint(pt, ptxy);

	if(!(dwFlags & REO_SELECTED) || !(dwFlags & REO_RESIZABLE) ||
		(lphand = CheckForHandleHit(pt, TRUE)) == NULL)
		return FALSE;
 	
	GetRectuv(rcPos);
	pdp->RectFromRectuv(rcxyPos, rcPos);

	HDC hdc = pdp->GetDC();
	_ped->TxGetWindow(&hwnd);
	SetCapture(hwnd);
	
	SetAllowedResizeDirections(pt, rcPos, lphand, fTop, fBottom, fLeft, fRight);
	
	// Erase and redraw frame without handles.
	DrawFrame(pdp, hdc, &rcxyPos);
	_pi.dwFlags = REO_NULL;
	DrawFrame(pdp, hdc, &rcxyPos);

	fEscape = FALSE;
	const INT vkey = GetSystemMetrics(SM_SWAPBUTTON) ? VK_RBUTTON : VK_LBUTTON;
	while (GetAsyncKeyState(vkey) & 0x8000)
	{		
		POINT ptLast = ptxy;
		POINT ptxyCur;
		POINTUV ptCur;
		MSG msg;

		// Stop if the ESC key has been pressed
		if(GetAsyncKeyState(VK_ESCAPE) & 0x0001)
		{
			fEscape = TRUE;
			break;
		}
		
		GetCursorPos(&ptxyCur);
		ScreenToClient(hwnd, &ptxyCur);
		pdp->PointuvFromPoint(ptCur, ptxyCur);

#ifndef UNDER_CE
// GetCursorPos() isn't supported on WinCE. We have  it hacked to
// be GetMessagePos() which unfortunately in this case will cause
// ptCur to never change. By removing this check we end up drawing
// multiple times when the user pauses during a resize. 
		// If mouse hasn't moved, try again
		if((ptxyCur.x == ptLast.x) && (ptxyCur.y == ptLast.y))
			continue;
#endif

		ptLast = ptxyCur;

		// Erase old rectangle, update rectangle, and redraw
		DrawFrame(pdp, hdc, &rcxyPos);	

		if(fLeft)   rcPos.left   = min(ptCur.u, rcPos.right - dupMin);
		if(fRight)  rcPos.right  = max(ptCur.u, rcPos.left + dupMin);
		if(fTop)    rcPos.top    = min(ptCur.v, rcPos.bottom - dvpMin);
		if(fBottom) rcPos.bottom = max(ptCur.v, rcPos.top + dvpMin);

		pdp->RectFromRectuv(rcxyPos, rcPos);
		DrawFrame(pdp, hdc, &rcxyPos);

		// FUTURE: (joseogl): It would be cool if we could do something
		// better here, but for now, it appears to be necessary.
		Sleep(100);
		
		// Eat input messages
		if (PeekMessage(&msg, 0, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE) ||
			PeekMessage(&msg, 0, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE | PM_NOYIELD) ||
			PeekMessage(&msg, 0, WM_NCMOUSEMOVE, WM_NCMBUTTONDBLCLK, PM_REMOVE | PM_NOYIELD))
		{
			// Break out of the loop if the Escape key was pressed
		    if(msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
			{
	        	fEscape = TRUE;
				break;
			}
		}
	}

	DrawFrame(pdp, hdc, &rcxyPos);
  	ReleaseCapture();
 	_pi.dwFlags = dwFlags;

	// Resize unless the user aborted
	if(!fEscape)
	{
		SIZEUV size;
		if (IsUVerticalTflow(pdp->GetTflow()) && !(_pi.dwFlags & REO_CANROTATE))
		{
			size.du = rcPos.bottom - rcPos.top;
			size.dv = rcPos.right - rcPos.left;
		}
		else
		{
			size.du = rcPos.right - rcPos.left;
			size.dv = rcPos.bottom - rcPos.top;
		}

		size.du = pdp->DUtoHimetricU(size.du);
		size.dv = pdp->DVtoHimetricV(size.dv);
		Resize(size, TRUE);
	}

	pdp->ReleaseDC(hdc);
	return TRUE;
}

/*
 *	COleObject::Resize(size)
 *	
 *	@mfunc Set new object size.  Handle undo details.
 */
void COleObject::Resize(
	const SIZEUV &size, 
	BOOL  fCreateAntiEvent)
{
	CDisplay *	pdp = _ped->_pdp;
	SIZEUV		sizeold = _size;

	// Change the size of our internal representation.
	_size = size;

	//If size didn't really change, don't do anything else.
	if(size.du != sizeold.du || size.dv != sizeold.dv)
	{
		if(_ped->_fUseUndo && fCreateAntiEvent)
		{
			CGenUndoBuilder undobldr(_ped, UB_AUTOCOMMIT);
			IAntiEvent *pae;

			pae = gAEDispenser.CreateResizeObjectAE(_ped, this, sizeold);
			if(pae)
				undobldr.AddAntiEvent(pae);
		}

		SetExtent(SE_NOTACTIVATING);

		// Force a redraw that will stretch the object.
		pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, _cp, _cp + 1, NULL);

		_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
	}
}

/*
 *	COleObject::OnReposition ()
 *	
 *	@mfunc Set object's new position.  May have changed as a result of scrolling.
 */
void COleObject::OnReposition()
{
	IOleInPlaceObject *pipo;

	if(!_fInPlaceActive)
	{
		// If we're not inplace active, don't do anything
		return;
	}

	if(_punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo) == NOERROR)
	{
		RECTUV rcuvClip, rcuv;
		RECT rcClip, rc;

		_ped->_pdp->GetViewRect(rcuvClip);
		_ped->_pdp->RectFromRectuv(rcClip, rcuvClip);

		GetRectuv(rcuv);
		_ped->_pdp->RectFromRectuv(rc, rcuv);

		pipo->SetObjectRects(&rc, &rcClip);
        pipo->Release();
	}
}

 /*
 *	COleObject::GetRectuv(rc)
 *	
 *	@mfunc Compute the object's position rectangle from its cp.
 */
void COleObject::GetRectuv(
	 RECTUV &rc)
{
	CRchTxtPtr rtp(_ped, _cp);
	POINTUV pt;
	CDispDim dispdim;

	DWORD grf = TA_BASELINE;
	if (_pi.dwFlags & REO_BELOWBASELINE)
		grf = TA_BOTTOM;
	
	if(_ped->_pdp->PointFromTp(rtp, NULL, FALSE, pt, NULL, grf, &dispdim) == -1)
		return;

	rc.left = pt.u;
	rc.right = rc.left + dispdim.dup;
	rc.bottom = pt.v;

	LONG dv = _size.dv;
	if (IsUVerticalTflow(_ped->_pdp->GetTflow()) && !(_pi.dwFlags & REO_CANROTATE))
		dv = _size.du;

	rc.top = rc.bottom - _ped->_pdp->HimetricVtoDV(dv);
}

#ifdef DEBUG
void COleObject::DbgDump(DWORD id)
{
	Tracef(TRCSEVNONE, "Object #%d %X: cp = %d , ",id,this,_cp);
}
#endif

/*	
 *	COleObject:SetExtent(iActivating)
 *
 *	@mfunc A wrapper around IOleObject::SetExtent which makes some additional
 *			checks if the first call to IOleObject::SetExtent fails.  
 *
 *	@rdesc HRESULT
 */
HRESULT COleObject::SetExtent(
	int iActivating) //@parm indicates if object is currently being activated
{
	LPOLEOBJECT poo;

	// If we are connected to a link object, the native extent can't be change,
	// so don't bother doing anything here.
	if(_pi.dwFlags & REO_LINK)
	{
		// So we don't call GetExtents on remeasuring.
		_fSetExtent = TRUE;
		return NOERROR;
	}

	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr != NOERROR)
		return hr;

	// If we are about to activate the object, fall through and OleRun the
	// object prior to attempting to SetExtent.  Otherwise, attempt a SetExtent
	// directly.
	if(iActivating == SE_NOTACTIVATING)
	{
		// By default, we will call SetExtent when the object is next activated.
		_fSetExtent = TRUE;

		hr = poo->SetExtent(_pi.dvaspect, (SIZE*)&_size);

		DWORD dwStatus;

		// If the server is not running we need to to some additional
		// checking. If it was, we do not need to call SetExtent again.

		// Find out if OLEMISC_RECOMPOSEONRESIZE is set.  If it is, we should
		// run the object and call setextent.  If not, we defer calling set
		// extent until we are ready to activate the object.
		if(!(hr == OLE_E_NOTRUNNING &&
			poo->GetMiscStatus(_pi.dvaspect, &dwStatus) == NOERROR &&
			(dwStatus & OLEMISC_RECOMPOSEONRESIZE)))
		{
			goto DontRunAndSetAgain;
		}
		// Fall through and attempt the SetExtent again after running the object
	}

	SIZEUV sizesave;
	sizesave = _size;
	OleRun(_punkobj);		// This call causes _size to be reset 
							// via OLE and FetchObjectExtents.
	_size = sizesave;
	poo->SetExtent(_pi.dvaspect, (SIZE*)&_size);

DontRunAndSetAgain:
	if((hr == NOERROR) || 
		(iActivating == SE_NOTACTIVATING && hr != OLE_E_NOTRUNNING))
	{
		_fSetExtent = FALSE;
	}
	// If the server is still not running, we try again at
	// activation time.  Otherwise the server has either 
	// done its thing or it doesn't do resize.  Either way
	// we don't bother trying again at activation time.

	if(hr == NOERROR && _fIsPaintBrush)
	{
		SIZEUV sizeChk;

		poo->GetExtent(_pi.dvaspect, (SIZE*)&sizeChk);
		_fPBUseLocalSize = !(sizeChk.du == _size.du && sizeChk.dv == _size.dv);
		// HACK:  Calls to SetExtent on PaintBrush objects may not
		// 	actually change the object extents.  In such cases, 
		//	we will rely on local _size for PaintBrush object extents.
	}
	poo->Release();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\dfreeze.cpp ===
/*	@doc INTERNAL
 *
 *	@module _DFREEZE.CPP  Implementation for classes handle freezing the display |
 *	
 *	This module implements non-inline members used by logic to handle freezing the display
 *
 *	History: <nl>
 *		2/8/96	ricksa	Created
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */
#include	"_common.h"
#include	"_disp.h"
#include	"_dfreeze.h"

ASSERTDATA

/*
 *	CAccumDisplayChanges::GetUpdateRegion(pcpStart, pcchDel, pcchNew,
 *										  pfUpdateCaret, pfScrollIntoView)
 *	@mfunc
 *		Get region for display to update
 */
void CAccumDisplayChanges::GetUpdateRegion(
	LONG *pcpStart,			//@parm where to put the cpStart
	LONG *pcchDel,			//@parm where to put the del char count
	LONG *pcchNew,			//@parm where to put the new char count
	BOOL *pfUpdateCaret,	//@parm whether caret update is needed
	BOOL *pfScrollIntoView,	//@parm whether to scroll caret into view
	BOOL *pfNeedRedisplay)	//@parm whether it needs redisplay
{
	LONG cchDel;
	*pcpStart = _cpMin;

	if(pfUpdateCaret)
		*pfUpdateCaret = _fUpdateCaret;
	if(pfScrollIntoView)
		*pfScrollIntoView = _fScrollIntoView;
	if (pfNeedRedisplay)
		*pfNeedRedisplay = _fNeedRedisplay;

	if(_cpMin == CP_INFINITE)
		return;

	cchDel = _cpMax - _cpMin;

	if(pcchDel)
		*pcchDel =  cchDel;

	*pcchNew = cchDel + _delta;

	_cpMin = CP_INFINITE;
}

/*
 *	CAccumDisplayChanges::UpdateRecalcRegion(cpStartNew, cchDel, cchNew)
 *
 *	@mfunc
 *		Merge new update with region to be recalculated
 */
void CAccumDisplayChanges::UpdateRecalcRegion(
	LONG cpStartNew,	//@parm Start of update
	LONG cchDel,		//@parm Count of chars to delete
	LONG cchNew)		//@parm Count of chars to add
{
	if(CP_INFINITE == _cpMin)
	{
		// Object is empty so just assign values
		_cpMin = cpStartNew;
		_cpMax = cpStartNew + cchDel;
		_delta = cchNew - cchDel;
		return;
	}

	// The basic idea of this algorithm is to merge the updates so that
	// they appear to the display sub-system as if only one replace range
	// has occured. To do this we keep track of the start of the update 
	// (_cpMin) relative to the original text and the end of the update 
	// (_cpMax) relative to the original text and the change  in the count 
	// of text (_delta). We can recreate cchDel from _cpMost - _cpMin and 
	// cchNew from cchDel + _delta.

	// Do we need to update _cpMin? - we only need to update _cpMin if the
	// current update begins before the last update because the final update
	// need only know the very start of the range updated.
	if(cpStartNew < _cpMin)
		_cpMin = cpStartNew;

	// Do we need to udpate _cpMax? - we only need to update _cpMax if the
	// current update implies a _cpMax that is greater than the current one.
	// Note that because prior updates affect where the _cpMax is located
	// we need to compare againt the proposed _cpMax against the current
	// _cpMax adjusted by the change in the text since the beginning of the
	// updates.
	if(cpStartNew + cchDel > _cpMax + _delta)
		_cpMax = cpStartNew + cchDel - _delta;

	// Increment the total change by the change for this update.
	_delta += cchNew - cchDel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\dcattrs.h ===
/*
 *
 *  Copyright (C) Microsoft Corporation, 1999-2000
 *
 *  File: dcattrs.h
 *
 *  List of standard attributes.
 *
 */


DEFINE_GUID(DCATTRID_OTHERS,                            0xb3c32af9,0x57d0,0x46a9,0xbc,0xa8,0xda,0xc2,0x38,0xa1,0x30,0x57);

DEFINE_GUID(DCATTRID_Font,                              0x573ea825,0x749b,0x4f8a,0x9c,0xfd,0x21,0xc3,0x60,0x5c,0xa8,0x28);
DEFINE_GUID(DCATTRID_Font_FaceName,                     0xb536aeb6,0x053b,0x4eb8,0xb6,0x5a,0x50,0xda,0x1e,0x81,0xe7,0x2e);
DEFINE_GUID(DCATTRID_Font_SizePts,                      0xc8493302,0xa5e9,0x456d,0xaf,0x04,0x80,0x05,0xe4,0x13,0x0f,0x03);
DEFINE_GUID(DCATTRID_Font_Style,                        0x68b2a77f,0x6b0e,0x4f28,0x81,0x77,0x57,0x1c,0x2f,0x3a,0x42,0xb1);
DEFINE_GUID(DCATTRID_Font_Style_Bold,                   0x48813a43,0x8a20,0x4940,0x8e,0x58,0x97,0x82,0x3f,0x7b,0x26,0x8a);
DEFINE_GUID(DCATTRID_Font_Style_Italic,                 0x8740682a,0xa765,0x48e1,0xac,0xfc,0xd2,0x22,0x22,0xb2,0xf8,0x10);
DEFINE_GUID(DCATTRID_Font_Style_SmallCaps,              0xfacb6bc6,0x9100,0x4cc6,0xb9,0x69,0x11,0xee,0xa4,0x5a,0x86,0xb4);
DEFINE_GUID(DCATTRID_Font_Style_Underline,              0xc3c9c9f3,0x7902,0x444b,0x9a,0x7b,0x48,0xe7,0x0f,0x4b,0x50,0xf7);
DEFINE_GUID(DCATTRID_Font_Style_Underline_Single,       0x1b6720e5,0x0f73,0x4951,0xa6,0xb3,0x6f,0x19,0xe4,0x3c,0x94,0x61);
DEFINE_GUID(DCATTRID_Font_Style_Strikethrough,          0x0c562193,0x2d08,0x4668,0x96,0x01,0xce,0xd4,0x13,0x09,0xd7,0xaf);
DEFINE_GUID(DCATTRID_Font_Style_Strikethrough_Single,   0x75d736b6,0x3c8f,0x4b97,0xab,0x78,0x18,0x77,0xcb,0x99,0x0d,0x31);
DEFINE_GUID(DCATTRID_Font_Style_Overline,               0xe3989f4a,0x992b,0x4301,0x8c,0xe1,0xa5,0xb7,0xc6,0xd1,0xf3,0xc8);
DEFINE_GUID(DCATTRID_Font_Style_Overline_Single,        0x8440d94c,0x51ce,0x47b2,0x8d,0x4c,0x15,0x75,0x1e,0x5f,0x72,0x1b);
DEFINE_GUID(DCATTRID_Font_Style_Subscript,              0x5774fb84,0x389b,0x43bc,0xa7,0x4b,0x15,0x68,0x34,0x7c,0xf0,0xf4);
DEFINE_GUID(DCATTRID_Font_Style_Superscript,            0x2ea4993c,0x563c,0x49aa,0x93,0x72,0x0b,0xef,0x09,0xa9,0x25,0x5b);
DEFINE_GUID(DCATTRID_Font_Style_Color,                  0x857a7a37,0xb8af,0x4e9a,0x81,0xb4,0xac,0xf7,0x00,0xc8,0x41,0x1b);

DEFINE_GUID(DCATTRID_Text_VerticalWriting,              0x6bba8195,0x046f,0x4ea9,0xb3,0x11,0x97,0xfd,0x66,0xc4,0x27,0x4b);
DEFINE_GUID(DCATTRID_Text_RightToLeft,                  0xca666e71,0x1b08,0x453d,0xbf,0xdd,0x28,0xe0,0x8c,0x8a,0xaf,0x7a);
DEFINE_GUID(DCATTRID_Text_Language,                     0xd8c04ef1,0x5753,0x4c25,0x88,0x87,0x85,0x44,0x3f,0xe5,0xf8,0x19);
DEFINE_GUID(DCATTRID_Text_ReadOnly,                     0x85836617,0xde32,0x4afd,0xa5,0x0f,0xa2,0xdb,0x11,0x0e,0x6e,0x4d);

DEFINE_GUID(DCATTRID_Text_Orientation,                  0x6bab707f,0x8785,0x4c39,0x8b,0x52,0x96,0xf8,0x78,0x30,0x3f,0xfb);

DEFINE_GUID(DCATTRID_App,                               0xa80f77df,0x4237,0x40e5,0x84,0x9c,0xb5,0xfa,0x51,0xc1,0x3a,0xc7);
DEFINE_GUID(DCATTRID_App_IncorrectSpelling,             0xf42de43c,0xef12,0x430d,0x94,0x4c,0x9a,0x08,0x97,0x0a,0x25,0xd2);
DEFINE_GUID(DCATTRID_App_IncorrectGrammar,              0xbd54e398,0xad03,0x4b74,0xb6,0xb3,0x5e,0xdb,0x19,0x99,0x63,0x88);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\ctfutb.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for ctfutb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ctfutb_h__
#define __ctfutb_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfLangBarMgr_FWD_DEFINED__
#define __ITfLangBarMgr_FWD_DEFINED__
typedef interface ITfLangBarMgr ITfLangBarMgr;
#endif 	/* __ITfLangBarMgr_FWD_DEFINED__ */


#ifndef __ITfLangBarEventSink_FWD_DEFINED__
#define __ITfLangBarEventSink_FWD_DEFINED__
typedef interface ITfLangBarEventSink ITfLangBarEventSink;
#endif 	/* __ITfLangBarEventSink_FWD_DEFINED__ */


#ifndef __ITfLangBarItemSink_FWD_DEFINED__
#define __ITfLangBarItemSink_FWD_DEFINED__
typedef interface ITfLangBarItemSink ITfLangBarItemSink;
#endif 	/* __ITfLangBarItemSink_FWD_DEFINED__ */


#ifndef __IEnumTfLangBarItems_FWD_DEFINED__
#define __IEnumTfLangBarItems_FWD_DEFINED__
typedef interface IEnumTfLangBarItems IEnumTfLangBarItems;
#endif 	/* __IEnumTfLangBarItems_FWD_DEFINED__ */


#ifndef __ITfLangBarItemMgr_FWD_DEFINED__
#define __ITfLangBarItemMgr_FWD_DEFINED__
typedef interface ITfLangBarItemMgr ITfLangBarItemMgr;
#endif 	/* __ITfLangBarItemMgr_FWD_DEFINED__ */


#ifndef __ITfLangBarItem_FWD_DEFINED__
#define __ITfLangBarItem_FWD_DEFINED__
typedef interface ITfLangBarItem ITfLangBarItem;
#endif 	/* __ITfLangBarItem_FWD_DEFINED__ */


#ifndef __ITfSystemLangBarItemSink_FWD_DEFINED__
#define __ITfSystemLangBarItemSink_FWD_DEFINED__
typedef interface ITfSystemLangBarItemSink ITfSystemLangBarItemSink;
#endif 	/* __ITfSystemLangBarItemSink_FWD_DEFINED__ */


#ifndef __ITfSystemLangBarItem_FWD_DEFINED__
#define __ITfSystemLangBarItem_FWD_DEFINED__
typedef interface ITfSystemLangBarItem ITfSystemLangBarItem;
#endif 	/* __ITfSystemLangBarItem_FWD_DEFINED__ */


#ifndef __ITfSystemDeviceTypeLangBarItem_FWD_DEFINED__
#define __ITfSystemDeviceTypeLangBarItem_FWD_DEFINED__
typedef interface ITfSystemDeviceTypeLangBarItem ITfSystemDeviceTypeLangBarItem;
#endif 	/* __ITfSystemDeviceTypeLangBarItem_FWD_DEFINED__ */


#ifndef __ITfLangBarItemButton_FWD_DEFINED__
#define __ITfLangBarItemButton_FWD_DEFINED__
typedef interface ITfLangBarItemButton ITfLangBarItemButton;
#endif 	/* __ITfLangBarItemButton_FWD_DEFINED__ */


#ifndef __ITfLangBarItemBitmapButton_FWD_DEFINED__
#define __ITfLangBarItemBitmapButton_FWD_DEFINED__
typedef interface ITfLangBarItemBitmapButton ITfLangBarItemBitmapButton;
#endif 	/* __ITfLangBarItemBitmapButton_FWD_DEFINED__ */


#ifndef __ITfLangBarItemBitmap_FWD_DEFINED__
#define __ITfLangBarItemBitmap_FWD_DEFINED__
typedef interface ITfLangBarItemBitmap ITfLangBarItemBitmap;
#endif 	/* __ITfLangBarItemBitmap_FWD_DEFINED__ */


#ifndef __ITfLangBarItemBalloon_FWD_DEFINED__
#define __ITfLangBarItemBalloon_FWD_DEFINED__
typedef interface ITfLangBarItemBalloon ITfLangBarItemBalloon;
#endif 	/* __ITfLangBarItemBalloon_FWD_DEFINED__ */


#ifndef __ITfMenu_FWD_DEFINED__
#define __ITfMenu_FWD_DEFINED__
typedef interface ITfMenu ITfMenu;
#endif 	/* __ITfMenu_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ctfutb_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ctfutb.h


// CTF declarations.

//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR TFPLIED, INCLUDING BUT NOT LIMITED TO
// THE TFPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#ifndef CTFUTB_DEFINED
#define CTFUTB_DEFINED

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define TF_FLOATINGLANGBAR_WNDTITLEW L"TF_FloatingLangBar_WndTitle"
#define TF_FLOATINGLANGBAR_WNDTITLEA "TF_FloatingLangBar_WndTitle"
#ifdef UNICODE
#define TF_FLOATINGLANGBAR_WNDTITLE TF_FLOATINGLANGBAR_WNDTITLEW
#else
#define TF_FLOATINGLANGBAR_WNDTITLE TF_FLOATINGLANGBAR_WNDTITLEA
#endif
#define TF_LBI_ICON                0x00000001
#define TF_LBI_TEXT                0x00000002
#define TF_LBI_TOOLTIP             0x00000004
#define TF_LBI_BITMAP              0x00000008
#define TF_LBI_BTNALL              0x00000007
#define TF_LBI_BMPBTNALL           0x0000000b
#define TF_LBI_BMPALL              0x0000000c
#define TF_LBI_BALLOON             0x00000010
#define TF_LBI_STATUS              0x00010000
#define TF_LBI_STYLE_HIDDENSTATUSCONTROL  0x00000001
#define TF_LBI_STYLE_SHOWNINTRAY        0x00000002
#define TF_LBI_STYLE_HIDEONNOOTHERITEMS 0x00000004
#define TF_LBI_STYLE_SHOWNINTRAYONLY    0x00000008
#define TF_LBI_STYLE_HIDDENBYDEFAULT    0x00000010
#define TF_LBI_STYLE_BTN_BUTTON         0x00010000
#define TF_LBI_STYLE_BTN_MENU           0x00020000
#define TF_LBI_STYLE_BTN_TOGGLE         0x00040000
#define TF_LBI_STATUS_HIDDEN           0x00000001
#define TF_LBI_STATUS_DISABLED         0x00000002
#define TF_LBI_STATUS_BTN_TOGGLED      0x00010000
#define TF_LBI_BMPF_VERTICAL           0x00000001
#define TF_SFT_SHOWNORMAL               0x00000001
#define TF_SFT_DOCK                     0x00000002
#define TF_SFT_MINIMIZED                0x00000004
#define TF_SFT_HIDDEN                   0x00000008
#define TF_SFT_NOTRANSPARENCY           0x00000010
#define TF_SFT_LOWTRANSPARENCY          0x00000020
#define TF_SFT_HIGHTRANSPARENCY         0x00000040
#define TF_SFT_LABELS                   0x00000080
#define TF_SFT_NOLABELS                 0x00000100
#define TF_SFT_EXTRAICONSONMINIMIZED    0x00000200
#define TF_SFT_NOEXTRAICONSONMINIMIZED  0x00000400
#define TF_INVALIDMENUITEM            (UINT)(-1)
#define TF_DTLBI_USEPROFILEICON         0x00000001
#ifdef __cplusplus
}
#endif  /* __cplusplus */







extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0000_v0_0_s_ifspec;

#ifndef __ITfLangBarMgr_INTERFACE_DEFINED__
#define __ITfLangBarMgr_INTERFACE_DEFINED__

/* interface ITfLangBarMgr */
/* [unique][uuid][local][object] */ 

#define	TF_LBESF_GLOBAL	( 0x1 )

#define	TF_LBESF_FLOATING	( 0x2 )

#define	TF_LBSMI_FILTERCURRENTTHREAD	( 0x1 )


EXTERN_C const IID IID_ITfLangBarMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("87955690-e627-11d2-8ddb-00105a2799b5")
    ITfLangBarMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseEventSink( 
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseEventSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadMarshalInterface( 
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadLangBarItemMgr( 
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfLangBarItemMgr **pplbi,
            /* [out] */ DWORD *pdwThreadid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputProcessorProfiles( 
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfInputProcessorProfiles **ppaip,
            /* [out] */ DWORD *pdwThreadid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreLastFocus( 
            DWORD *pdwThreadId,
            BOOL fPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetModalInput( 
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowFloating( 
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShowFloatingStatus( 
            DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventSink )( 
            ITfLangBarMgr * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseEventSink )( 
            ITfLangBarMgr * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadMarshalInterface )( 
            ITfLangBarMgr * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadLangBarItemMgr )( 
            ITfLangBarMgr * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfLangBarItemMgr **pplbi,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputProcessorProfiles )( 
            ITfLangBarMgr * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfInputProcessorProfiles **ppaip,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreLastFocus )( 
            ITfLangBarMgr * This,
            DWORD *pdwThreadId,
            BOOL fPrev);
        
        HRESULT ( STDMETHODCALLTYPE *SetModalInput )( 
            ITfLangBarMgr * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ShowFloating )( 
            ITfLangBarMgr * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowFloatingStatus )( 
            ITfLangBarMgr * This,
            DWORD *pdwFlags);
        
        END_INTERFACE
    } ITfLangBarMgrVtbl;

    interface ITfLangBarMgr
    {
        CONST_VTBL struct ITfLangBarMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarMgr_AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)	\
    (This)->lpVtbl -> AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)

#define ITfLangBarMgr_UnadviseEventSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseEventSink(This,dwCookie)

#define ITfLangBarMgr_GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)	\
    (This)->lpVtbl -> GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)

#define ITfLangBarMgr_GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)	\
    (This)->lpVtbl -> GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)

#define ITfLangBarMgr_GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)	\
    (This)->lpVtbl -> GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)

#define ITfLangBarMgr_RestoreLastFocus(This,pdwThreadId,fPrev)	\
    (This)->lpVtbl -> RestoreLastFocus(This,pdwThreadId,fPrev)

#define ITfLangBarMgr_SetModalInput(This,pSink,dwThreadId,dwFlags)	\
    (This)->lpVtbl -> SetModalInput(This,pSink,dwThreadId,dwFlags)

#define ITfLangBarMgr_ShowFloating(This,dwFlags)	\
    (This)->lpVtbl -> ShowFloating(This,dwFlags)

#define ITfLangBarMgr_GetShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetShowFloatingStatus(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarMgr_AdviseEventSink_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ ITfLangBarEventSink *pSink,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD *pdwCookie);


void __RPC_STUB ITfLangBarMgr_AdviseEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_UnadviseEventSink_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfLangBarMgr_UnadviseEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_GetThreadMarshalInterface_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ DWORD dwType,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppunk);


void __RPC_STUB ITfLangBarMgr_GetThreadMarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_GetThreadLangBarItemMgr_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ DWORD dwThreadId,
    /* [out] */ ITfLangBarItemMgr **pplbi,
    /* [out] */ DWORD *pdwThreadid);


void __RPC_STUB ITfLangBarMgr_GetThreadLangBarItemMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_GetInputProcessorProfiles_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ DWORD dwThreadId,
    /* [out] */ ITfInputProcessorProfiles **ppaip,
    /* [out] */ DWORD *pdwThreadid);


void __RPC_STUB ITfLangBarMgr_GetInputProcessorProfiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_RestoreLastFocus_Proxy( 
    ITfLangBarMgr * This,
    DWORD *pdwThreadId,
    BOOL fPrev);


void __RPC_STUB ITfLangBarMgr_RestoreLastFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_SetModalInput_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ ITfLangBarEventSink *pSink,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfLangBarMgr_SetModalInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_ShowFloating_Proxy( 
    ITfLangBarMgr * This,
    DWORD dwFlags);


void __RPC_STUB ITfLangBarMgr_ShowFloating_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_GetShowFloatingStatus_Proxy( 
    ITfLangBarMgr * This,
    DWORD *pdwFlags);


void __RPC_STUB ITfLangBarMgr_GetShowFloatingStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarMgr_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarEventSink_INTERFACE_DEFINED__
#define __ITfLangBarEventSink_INTERFACE_DEFINED__

/* interface ITfLangBarEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18a4e900-e0ae-11d2-afdd-00105a2799b5")
    ITfLangBarEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSetFocus( 
            /* [in] */ DWORD dwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadTerminate( 
            /* [in] */ DWORD dwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadItemChange( 
            /* [in] */ DWORD dwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnModalInput( 
            /* [in] */ DWORD dwThreadId,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowFloating( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemFloatingRect( 
            /* [in] */ DWORD dwThreadId,
            /* [in] */ REFGUID rguid,
            /* [out] */ RECT *prc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetFocus )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadTerminate )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadItemChange )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *OnModalInput )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *ShowFloating )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFloatingRect )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ REFGUID rguid,
            /* [out] */ RECT *prc);
        
        END_INTERFACE
    } ITfLangBarEventSinkVtbl;

    interface ITfLangBarEventSink
    {
        CONST_VTBL struct ITfLangBarEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarEventSink_OnSetFocus(This,dwThreadId)	\
    (This)->lpVtbl -> OnSetFocus(This,dwThreadId)

#define ITfLangBarEventSink_OnThreadTerminate(This,dwThreadId)	\
    (This)->lpVtbl -> OnThreadTerminate(This,dwThreadId)

#define ITfLangBarEventSink_OnThreadItemChange(This,dwThreadId)	\
    (This)->lpVtbl -> OnThreadItemChange(This,dwThreadId)

#define ITfLangBarEventSink_OnModalInput(This,dwThreadId,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> OnModalInput(This,dwThreadId,uMsg,wParam,lParam)

#define ITfLangBarEventSink_ShowFloating(This,dwFlags)	\
    (This)->lpVtbl -> ShowFloating(This,dwFlags)

#define ITfLangBarEventSink_GetItemFloatingRect(This,dwThreadId,rguid,prc)	\
    (This)->lpVtbl -> GetItemFloatingRect(This,dwThreadId,rguid,prc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_OnSetFocus_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId);


void __RPC_STUB ITfLangBarEventSink_OnSetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_OnThreadTerminate_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId);


void __RPC_STUB ITfLangBarEventSink_OnThreadTerminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_OnThreadItemChange_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId);


void __RPC_STUB ITfLangBarEventSink_OnThreadItemChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_OnModalInput_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfLangBarEventSink_OnModalInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_ShowFloating_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfLangBarEventSink_ShowFloating_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_GetItemFloatingRect_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ REFGUID rguid,
    /* [out] */ RECT *prc);


void __RPC_STUB ITfLangBarEventSink_GetItemFloatingRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItemSink_INTERFACE_DEFINED__
#define __ITfLangBarItemSink_INTERFACE_DEFINED__

/* interface ITfLangBarItemSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItemSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57dbe1a0-de25-11d2-afdd-00105a2799b5")
    ITfLangBarItemSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdate( 
            DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdate )( 
            ITfLangBarItemSink * This,
            DWORD dwFlags);
        
        END_INTERFACE
    } ITfLangBarItemSinkVtbl;

    interface ITfLangBarItemSink
    {
        CONST_VTBL struct ITfLangBarItemSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemSink_OnUpdate(This,dwFlags)	\
    (This)->lpVtbl -> OnUpdate(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemSink_OnUpdate_Proxy( 
    ITfLangBarItemSink * This,
    DWORD dwFlags);


void __RPC_STUB ITfLangBarItemSink_OnUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemSink_INTERFACE_DEFINED__ */


#ifndef __IEnumTfLangBarItems_INTERFACE_DEFINED__
#define __IEnumTfLangBarItems_INTERFACE_DEFINED__

/* interface IEnumTfLangBarItems */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfLangBarItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("583f34d0-de25-11d2-afdd-00105a2799b5")
    IEnumTfLangBarItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfLangBarItems **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ ITfLangBarItem **ppItem,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfLangBarItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfLangBarItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfLangBarItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfLangBarItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfLangBarItems * This,
            /* [out] */ IEnumTfLangBarItems **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfLangBarItems * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ ITfLangBarItem **ppItem,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfLangBarItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfLangBarItems * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfLangBarItemsVtbl;

    interface IEnumTfLangBarItems
    {
        CONST_VTBL struct IEnumTfLangBarItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfLangBarItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfLangBarItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfLangBarItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfLangBarItems_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfLangBarItems_Next(This,ulCount,ppItem,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,ppItem,pcFetched)

#define IEnumTfLangBarItems_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfLangBarItems_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfLangBarItems_Clone_Proxy( 
    IEnumTfLangBarItems * This,
    /* [out] */ IEnumTfLangBarItems **ppEnum);


void __RPC_STUB IEnumTfLangBarItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLangBarItems_Next_Proxy( 
    IEnumTfLangBarItems * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][out] */ ITfLangBarItem **ppItem,
    /* [unique][out][in] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfLangBarItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLangBarItems_Reset_Proxy( 
    IEnumTfLangBarItems * This);


void __RPC_STUB IEnumTfLangBarItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLangBarItems_Skip_Proxy( 
    IEnumTfLangBarItems * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfLangBarItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfLangBarItems_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctfutb_0202 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("12a1d29f-a065-440c-9746-eb2002c8bd19") struct TF_LANGBARITEMINFO
    {
    CLSID clsidTip;
    GUID guidItem;
    DWORD dwStyle;
    ULONG ulSort;
    WCHAR szDescription[ 32 ];
    } 	TF_LANGBARITEMINFO;



extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0202_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0202_v0_0_s_ifspec;

#ifndef __ITfLangBarItemMgr_INTERFACE_DEFINED__
#define __ITfLangBarItemMgr_INTERFACE_DEFINED__

/* interface ITfLangBarItemMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfLangBarItemMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba468c55-9956-4fb1-a59d-52a7dd7cc6aa")
    ITfLangBarItemMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [out] */ IEnumTfLangBarItems **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ REFGUID rguid,
            /* [out] */ ITfLangBarItem **ppItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ ITfLangBarItem *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [in] */ ITfLangBarItem *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseItemSink( 
            /* [in] */ ITfLangBarItemSink *punk,
            /* [out] */ DWORD *pdwCookie,
            /* [in] */ REFGUID rguidItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseItemSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemFloatingRect( 
            /* [in] */ DWORD dwThreadId,
            /* [in] */ REFGUID rguid,
            /* [out] */ RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemsStatus( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const GUID *prgguid,
            /* [size_is][out][in] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemNum( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItems( 
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ ITfLangBarItem **ppItem,
            /* [size_is][out][in] */ TF_LANGBARITEMINFO *pInfo,
            /* [size_is][out][in] */ DWORD *pdwStatus,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseItemsSink( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ ITfLangBarItemSink **ppunk,
            /* [size_is][in] */ const GUID *pguidItem,
            /* [size_is][out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseItemsSink( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ DWORD *pdwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumItems )( 
            ITfLangBarItemMgr * This,
            /* [out] */ IEnumTfLangBarItems **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            ITfLangBarItemMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ ITfLangBarItem **ppItem);
        
        HRESULT ( STDMETHODCALLTYPE *AddItem )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ITfLangBarItem *punk);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveItem )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ITfLangBarItem *punk);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseItemSink )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ITfLangBarItemSink *punk,
            /* [out] */ DWORD *pdwCookie,
            /* [in] */ REFGUID rguidItem);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseItemSink )( 
            ITfLangBarItemMgr * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFloatingRect )( 
            ITfLangBarItemMgr * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ REFGUID rguid,
            /* [out] */ RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemsStatus )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const GUID *prgguid,
            /* [size_is][out][in] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemNum )( 
            ITfLangBarItemMgr * This,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetItems )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ ITfLangBarItem **ppItem,
            /* [size_is][out][in] */ TF_LANGBARITEMINFO *pInfo,
            /* [size_is][out][in] */ DWORD *pdwStatus,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseItemsSink )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ ITfLangBarItemSink **ppunk,
            /* [size_is][in] */ const GUID *pguidItem,
            /* [size_is][out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseItemsSink )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ DWORD *pdwCookie);
        
        END_INTERFACE
    } ITfLangBarItemMgrVtbl;

    interface ITfLangBarItemMgr
    {
        CONST_VTBL struct ITfLangBarItemMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemMgr_EnumItems(This,ppEnum)	\
    (This)->lpVtbl -> EnumItems(This,ppEnum)

#define ITfLangBarItemMgr_GetItem(This,rguid,ppItem)	\
    (This)->lpVtbl -> GetItem(This,rguid,ppItem)

#define ITfLangBarItemMgr_AddItem(This,punk)	\
    (This)->lpVtbl -> AddItem(This,punk)

#define ITfLangBarItemMgr_RemoveItem(This,punk)	\
    (This)->lpVtbl -> RemoveItem(This,punk)

#define ITfLangBarItemMgr_AdviseItemSink(This,punk,pdwCookie,rguidItem)	\
    (This)->lpVtbl -> AdviseItemSink(This,punk,pdwCookie,rguidItem)

#define ITfLangBarItemMgr_UnadviseItemSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseItemSink(This,dwCookie)

#define ITfLangBarItemMgr_GetItemFloatingRect(This,dwThreadId,rguid,prc)	\
    (This)->lpVtbl -> GetItemFloatingRect(This,dwThreadId,rguid,prc)

#define ITfLangBarItemMgr_GetItemsStatus(This,ulCount,prgguid,pdwStatus)	\
    (This)->lpVtbl -> GetItemsStatus(This,ulCount,prgguid,pdwStatus)

#define ITfLangBarItemMgr_GetItemNum(This,pulCount)	\
    (This)->lpVtbl -> GetItemNum(This,pulCount)

#define ITfLangBarItemMgr_GetItems(This,ulCount,ppItem,pInfo,pdwStatus,pcFetched)	\
    (This)->lpVtbl -> GetItems(This,ulCount,ppItem,pInfo,pdwStatus,pcFetched)

#define ITfLangBarItemMgr_AdviseItemsSink(This,ulCount,ppunk,pguidItem,pdwCookie)	\
    (This)->lpVtbl -> AdviseItemsSink(This,ulCount,ppunk,pguidItem,pdwCookie)

#define ITfLangBarItemMgr_UnadviseItemsSink(This,ulCount,pdwCookie)	\
    (This)->lpVtbl -> UnadviseItemsSink(This,ulCount,pdwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_EnumItems_Proxy( 
    ITfLangBarItemMgr * This,
    /* [out] */ IEnumTfLangBarItems **ppEnum);


void __RPC_STUB ITfLangBarItemMgr_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItem_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ ITfLangBarItem **ppItem);


void __RPC_STUB ITfLangBarItemMgr_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_AddItem_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ITfLangBarItem *punk);


void __RPC_STUB ITfLangBarItemMgr_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_RemoveItem_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ITfLangBarItem *punk);


void __RPC_STUB ITfLangBarItemMgr_RemoveItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_AdviseItemSink_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ITfLangBarItemSink *punk,
    /* [out] */ DWORD *pdwCookie,
    /* [in] */ REFGUID rguidItem);


void __RPC_STUB ITfLangBarItemMgr_AdviseItemSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_UnadviseItemSink_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfLangBarItemMgr_UnadviseItemSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItemFloatingRect_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ REFGUID rguid,
    /* [out] */ RECT *prc);


void __RPC_STUB ITfLangBarItemMgr_GetItemFloatingRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItemsStatus_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const GUID *prgguid,
    /* [size_is][out][in] */ DWORD *pdwStatus);


void __RPC_STUB ITfLangBarItemMgr_GetItemsStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItemNum_Proxy( 
    ITfLangBarItemMgr * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB ITfLangBarItemMgr_GetItemNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItems_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][out] */ ITfLangBarItem **ppItem,
    /* [size_is][out][in] */ TF_LANGBARITEMINFO *pInfo,
    /* [size_is][out][in] */ DWORD *pdwStatus,
    /* [unique][out][in] */ ULONG *pcFetched);


void __RPC_STUB ITfLangBarItemMgr_GetItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_AdviseItemsSink_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ ITfLangBarItemSink **ppunk,
    /* [size_is][in] */ const GUID *pguidItem,
    /* [size_is][out] */ DWORD *pdwCookie);


void __RPC_STUB ITfLangBarItemMgr_AdviseItemsSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_UnadviseItemsSink_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ DWORD *pdwCookie);


void __RPC_STUB ITfLangBarItemMgr_UnadviseItemsSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemMgr_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItem_INTERFACE_DEFINED__
#define __ITfLangBarItem_INTERFACE_DEFINED__

/* interface ITfLangBarItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73540d69-edeb-4ee9-96c9-23aa30b25916")
    ITfLangBarItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ TF_LANGBARITEMINFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTooltipString( 
            /* [out] */ BSTR *pbstrToolTip) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItem * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItem * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItem * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItem * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        END_INTERFACE
    } ITfLangBarItemVtbl;

    interface ITfLangBarItem
    {
        CONST_VTBL struct ITfLangBarItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItem_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItem_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItem_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItem_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItem_GetInfo_Proxy( 
    ITfLangBarItem * This,
    /* [out] */ TF_LANGBARITEMINFO *pInfo);


void __RPC_STUB ITfLangBarItem_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItem_GetStatus_Proxy( 
    ITfLangBarItem * This,
    /* [out] */ DWORD *pdwStatus);


void __RPC_STUB ITfLangBarItem_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItem_Show_Proxy( 
    ITfLangBarItem * This,
    /* [in] */ BOOL fShow);


void __RPC_STUB ITfLangBarItem_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItem_GetTooltipString_Proxy( 
    ITfLangBarItem * This,
    /* [out] */ BSTR *pbstrToolTip);


void __RPC_STUB ITfLangBarItem_GetTooltipString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItem_INTERFACE_DEFINED__ */


#ifndef __ITfSystemLangBarItemSink_INTERFACE_DEFINED__
#define __ITfSystemLangBarItemSink_INTERFACE_DEFINED__

/* interface ITfSystemLangBarItemSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSystemLangBarItemSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1449d9ab-13cf-4687-aa3e-8d8b18574396")
    ITfSystemLangBarItemSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitMenu( 
            /* [in] */ ITfMenu *pMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMenuSelect( 
            /* [in] */ UINT wID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSystemLangBarItemSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSystemLangBarItemSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSystemLangBarItemSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSystemLangBarItemSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitMenu )( 
            ITfSystemLangBarItemSink * This,
            /* [in] */ ITfMenu *pMenu);
        
        HRESULT ( STDMETHODCALLTYPE *OnMenuSelect )( 
            ITfSystemLangBarItemSink * This,
            /* [in] */ UINT wID);
        
        END_INTERFACE
    } ITfSystemLangBarItemSinkVtbl;

    interface ITfSystemLangBarItemSink
    {
        CONST_VTBL struct ITfSystemLangBarItemSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSystemLangBarItemSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSystemLangBarItemSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSystemLangBarItemSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSystemLangBarItemSink_InitMenu(This,pMenu)	\
    (This)->lpVtbl -> InitMenu(This,pMenu)

#define ITfSystemLangBarItemSink_OnMenuSelect(This,wID)	\
    (This)->lpVtbl -> OnMenuSelect(This,wID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSystemLangBarItemSink_InitMenu_Proxy( 
    ITfSystemLangBarItemSink * This,
    /* [in] */ ITfMenu *pMenu);


void __RPC_STUB ITfSystemLangBarItemSink_InitMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSystemLangBarItemSink_OnMenuSelect_Proxy( 
    ITfSystemLangBarItemSink * This,
    /* [in] */ UINT wID);


void __RPC_STUB ITfSystemLangBarItemSink_OnMenuSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSystemLangBarItemSink_INTERFACE_DEFINED__ */


#ifndef __ITfSystemLangBarItem_INTERFACE_DEFINED__
#define __ITfSystemLangBarItem_INTERFACE_DEFINED__

/* interface ITfSystemLangBarItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSystemLangBarItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1e13e9ec-6b33-4d4a-b5eb-8a92f029f356")
    ITfSystemLangBarItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIcon( 
            /* [in] */ HICON hIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTooltipString( 
            /* [size_is][in] */ WCHAR *pchToolTip,
            /* [in] */ ULONG cch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSystemLangBarItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSystemLangBarItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSystemLangBarItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSystemLangBarItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIcon )( 
            ITfSystemLangBarItem * This,
            /* [in] */ HICON hIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetTooltipString )( 
            ITfSystemLangBarItem * This,
            /* [size_is][in] */ WCHAR *pchToolTip,
            /* [in] */ ULONG cch);
        
        END_INTERFACE
    } ITfSystemLangBarItemVtbl;

    interface ITfSystemLangBarItem
    {
        CONST_VTBL struct ITfSystemLangBarItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSystemLangBarItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSystemLangBarItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSystemLangBarItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSystemLangBarItem_SetIcon(This,hIcon)	\
    (This)->lpVtbl -> SetIcon(This,hIcon)

#define ITfSystemLangBarItem_SetTooltipString(This,pchToolTip,cch)	\
    (This)->lpVtbl -> SetTooltipString(This,pchToolTip,cch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSystemLangBarItem_SetIcon_Proxy( 
    ITfSystemLangBarItem * This,
    /* [in] */ HICON hIcon);


void __RPC_STUB ITfSystemLangBarItem_SetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSystemLangBarItem_SetTooltipString_Proxy( 
    ITfSystemLangBarItem * This,
    /* [size_is][in] */ WCHAR *pchToolTip,
    /* [in] */ ULONG cch);


void __RPC_STUB ITfSystemLangBarItem_SetTooltipString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSystemLangBarItem_INTERFACE_DEFINED__ */


#ifndef __ITfSystemDeviceTypeLangBarItem_INTERFACE_DEFINED__
#define __ITfSystemDeviceTypeLangBarItem_INTERFACE_DEFINED__

/* interface ITfSystemDeviceTypeLangBarItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSystemDeviceTypeLangBarItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45672eb9-9059-46a2-838d-4530355f6a77")
    ITfSystemDeviceTypeLangBarItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIconMode( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconMode( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSystemDeviceTypeLangBarItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSystemDeviceTypeLangBarItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSystemDeviceTypeLangBarItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSystemDeviceTypeLangBarItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconMode )( 
            ITfSystemDeviceTypeLangBarItem * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconMode )( 
            ITfSystemDeviceTypeLangBarItem * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } ITfSystemDeviceTypeLangBarItemVtbl;

    interface ITfSystemDeviceTypeLangBarItem
    {
        CONST_VTBL struct ITfSystemDeviceTypeLangBarItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSystemDeviceTypeLangBarItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSystemDeviceTypeLangBarItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSystemDeviceTypeLangBarItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSystemDeviceTypeLangBarItem_SetIconMode(This,dwFlags)	\
    (This)->lpVtbl -> SetIconMode(This,dwFlags)

#define ITfSystemDeviceTypeLangBarItem_GetIconMode(This,pdwFlags)	\
    (This)->lpVtbl -> GetIconMode(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSystemDeviceTypeLangBarItem_SetIconMode_Proxy( 
    ITfSystemDeviceTypeLangBarItem * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfSystemDeviceTypeLangBarItem_SetIconMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSystemDeviceTypeLangBarItem_GetIconMode_Proxy( 
    ITfSystemDeviceTypeLangBarItem * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ITfSystemDeviceTypeLangBarItem_GetIconMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSystemDeviceTypeLangBarItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctfutb_0207 */
/* [local] */ 

typedef /* [public][public][public][public][public][uuid] */  DECLSPEC_UUID("8fb5f0ce-dfdd-4f0a-85b9-8988d8dd8ff2") 
enum __MIDL___MIDL_itf_ctfutb_0207_0001
    {	TF_LBI_CLK_NONE	= 0,
	TF_LBI_CLK_RIGHT	= 1,
	TF_LBI_CLK_LEFT	= 2,
	TF_LBI_CLK_RIGHT_DBL	= 3,
	TF_LBI_CLK_LEFT_DBL	= 4
    } 	TfLBIClick;



extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0207_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0207_v0_0_s_ifspec;

#ifndef __ITfLangBarItemButton_INTERFACE_DEFINED__
#define __ITfLangBarItemButton_INTERFACE_DEFINED__

/* interface ITfLangBarItemButton */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItemButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28c7f1d0-de25-11d2-afdd-00105a2799b5")
    ITfLangBarItemButton : public ITfLangBarItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnClick( 
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitMenu( 
            /* [in] */ ITfMenu *pMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMenuSelect( 
            /* [in] */ UINT wID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcon( 
            /* [out] */ HICON *phIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [out] */ BSTR *pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemButton * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemButton * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemButton * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItemButton * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItemButton * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItemButton * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItemButton * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnClick )( 
            ITfLangBarItemButton * This,
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea);
        
        HRESULT ( STDMETHODCALLTYPE *InitMenu )( 
            ITfLangBarItemButton * This,
            /* [in] */ ITfMenu *pMenu);
        
        HRESULT ( STDMETHODCALLTYPE *OnMenuSelect )( 
            ITfLangBarItemButton * This,
            /* [in] */ UINT wID);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            ITfLangBarItemButton * This,
            /* [out] */ HICON *phIcon);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfLangBarItemButton * This,
            /* [out] */ BSTR *pbstrText);
        
        END_INTERFACE
    } ITfLangBarItemButtonVtbl;

    interface ITfLangBarItemButton
    {
        CONST_VTBL struct ITfLangBarItemButtonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemButton_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItemButton_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItemButton_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItemButton_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)


#define ITfLangBarItemButton_OnClick(This,click,pt,prcArea)	\
    (This)->lpVtbl -> OnClick(This,click,pt,prcArea)

#define ITfLangBarItemButton_InitMenu(This,pMenu)	\
    (This)->lpVtbl -> InitMenu(This,pMenu)

#define ITfLangBarItemButton_OnMenuSelect(This,wID)	\
    (This)->lpVtbl -> OnMenuSelect(This,wID)

#define ITfLangBarItemButton_GetIcon(This,phIcon)	\
    (This)->lpVtbl -> GetIcon(This,phIcon)

#define ITfLangBarItemButton_GetText(This,pbstrText)	\
    (This)->lpVtbl -> GetText(This,pbstrText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_OnClick_Proxy( 
    ITfLangBarItemButton * This,
    /* [in] */ TfLBIClick click,
    /* [in] */ POINT pt,
    /* [in] */ const RECT *prcArea);


void __RPC_STUB ITfLangBarItemButton_OnClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_InitMenu_Proxy( 
    ITfLangBarItemButton * This,
    /* [in] */ ITfMenu *pMenu);


void __RPC_STUB ITfLangBarItemButton_InitMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_OnMenuSelect_Proxy( 
    ITfLangBarItemButton * This,
    /* [in] */ UINT wID);


void __RPC_STUB ITfLangBarItemButton_OnMenuSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_GetIcon_Proxy( 
    ITfLangBarItemButton * This,
    /* [out] */ HICON *phIcon);


void __RPC_STUB ITfLangBarItemButton_GetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_GetText_Proxy( 
    ITfLangBarItemButton * This,
    /* [out] */ BSTR *pbstrText);


void __RPC_STUB ITfLangBarItemButton_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemButton_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItemBitmapButton_INTERFACE_DEFINED__
#define __ITfLangBarItemBitmapButton_INTERFACE_DEFINED__

/* interface ITfLangBarItemBitmapButton */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItemBitmapButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a26a0525-3fae-4fa0-89ee-88a964f9f1b5")
    ITfLangBarItemBitmapButton : public ITfLangBarItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnClick( 
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitMenu( 
            /* [in] */ ITfMenu *pMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMenuSelect( 
            /* [in] */ UINT wID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreferedSize( 
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawBitmap( 
            /* [in] */ LONG bmWidth,
            /* [in] */ LONG bmHeight,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HBITMAP *phbmp,
            /* [out] */ HBITMAP *phbmpMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [out] */ BSTR *pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemBitmapButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemBitmapButton * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemBitmapButton * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItemBitmapButton * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItemBitmapButton * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItemBitmapButton * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnClick )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea);
        
        HRESULT ( STDMETHODCALLTYPE *InitMenu )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ ITfMenu *pMenu);
        
        HRESULT ( STDMETHODCALLTYPE *OnMenuSelect )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ UINT wID);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferedSize )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz);
        
        HRESULT ( STDMETHODCALLTYPE *DrawBitmap )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ LONG bmWidth,
            /* [in] */ LONG bmHeight,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HBITMAP *phbmp,
            /* [out] */ HBITMAP *phbmpMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfLangBarItemBitmapButton * This,
            /* [out] */ BSTR *pbstrText);
        
        END_INTERFACE
    } ITfLangBarItemBitmapButtonVtbl;

    interface ITfLangBarItemBitmapButton
    {
        CONST_VTBL struct ITfLangBarItemBitmapButtonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemBitmapButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemBitmapButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemBitmapButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemBitmapButton_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItemBitmapButton_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItemBitmapButton_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItemBitmapButton_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)


#define ITfLangBarItemBitmapButton_OnClick(This,click,pt,prcArea)	\
    (This)->lpVtbl -> OnClick(This,click,pt,prcArea)

#define ITfLangBarItemBitmapButton_InitMenu(This,pMenu)	\
    (This)->lpVtbl -> InitMenu(This,pMenu)

#define ITfLangBarItemBitmapButton_OnMenuSelect(This,wID)	\
    (This)->lpVtbl -> OnMenuSelect(This,wID)

#define ITfLangBarItemBitmapButton_GetPreferedSize(This,pszDefault,psz)	\
    (This)->lpVtbl -> GetPreferedSize(This,pszDefault,psz)

#define ITfLangBarItemBitmapButton_DrawBitmap(This,bmWidth,bmHeight,dwFlags,phbmp,phbmpMask)	\
    (This)->lpVtbl -> DrawBitmap(This,bmWidth,bmHeight,dwFlags,phbmp,phbmpMask)

#define ITfLangBarItemBitmapButton_GetText(This,pbstrText)	\
    (This)->lpVtbl -> GetText(This,pbstrText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_OnClick_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ TfLBIClick click,
    /* [in] */ POINT pt,
    /* [in] */ const RECT *prcArea);


void __RPC_STUB ITfLangBarItemBitmapButton_OnClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_InitMenu_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ ITfMenu *pMenu);


void __RPC_STUB ITfLangBarItemBitmapButton_InitMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_OnMenuSelect_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ UINT wID);


void __RPC_STUB ITfLangBarItemBitmapButton_OnMenuSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_GetPreferedSize_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ const SIZE *pszDefault,
    /* [out] */ SIZE *psz);


void __RPC_STUB ITfLangBarItemBitmapButton_GetPreferedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_DrawBitmap_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ LONG bmWidth,
    /* [in] */ LONG bmHeight,
    /* [in] */ DWORD dwFlags,
    /* [out] */ HBITMAP *phbmp,
    /* [out] */ HBITMAP *phbmpMask);


void __RPC_STUB ITfLangBarItemBitmapButton_DrawBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_GetText_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [out] */ BSTR *pbstrText);


void __RPC_STUB ITfLangBarItemBitmapButton_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemBitmapButton_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItemBitmap_INTERFACE_DEFINED__
#define __ITfLangBarItemBitmap_INTERFACE_DEFINED__

/* interface ITfLangBarItemBitmap */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItemBitmap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73830352-d722-4179-ada5-f045c98df355")
    ITfLangBarItemBitmap : public ITfLangBarItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnClick( 
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreferedSize( 
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawBitmap( 
            /* [in] */ LONG bmWidth,
            /* [in] */ LONG bmHeight,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HBITMAP *phbmp,
            /* [out] */ HBITMAP *phbmpMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemBitmapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemBitmap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemBitmap * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItemBitmap * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItemBitmap * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItemBitmap * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnClick )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferedSize )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz);
        
        HRESULT ( STDMETHODCALLTYPE *DrawBitmap )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ LONG bmWidth,
            /* [in] */ LONG bmHeight,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HBITMAP *phbmp,
            /* [out] */ HBITMAP *phbmpMask);
        
        END_INTERFACE
    } ITfLangBarItemBitmapVtbl;

    interface ITfLangBarItemBitmap
    {
        CONST_VTBL struct ITfLangBarItemBitmapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemBitmap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemBitmap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemBitmap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemBitmap_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItemBitmap_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItemBitmap_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItemBitmap_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)


#define ITfLangBarItemBitmap_OnClick(This,click,pt,prcArea)	\
    (This)->lpVtbl -> OnClick(This,click,pt,prcArea)

#define ITfLangBarItemBitmap_GetPreferedSize(This,pszDefault,psz)	\
    (This)->lpVtbl -> GetPreferedSize(This,pszDefault,psz)

#define ITfLangBarItemBitmap_DrawBitmap(This,bmWidth,bmHeight,dwFlags,phbmp,phbmpMask)	\
    (This)->lpVtbl -> DrawBitmap(This,bmWidth,bmHeight,dwFlags,phbmp,phbmpMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmap_OnClick_Proxy( 
    ITfLangBarItemBitmap * This,
    /* [in] */ TfLBIClick click,
    /* [in] */ POINT pt,
    /* [in] */ const RECT *prcArea);


void __RPC_STUB ITfLangBarItemBitmap_OnClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmap_GetPreferedSize_Proxy( 
    ITfLangBarItemBitmap * This,
    /* [in] */ const SIZE *pszDefault,
    /* [out] */ SIZE *psz);


void __RPC_STUB ITfLangBarItemBitmap_GetPreferedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmap_DrawBitmap_Proxy( 
    ITfLangBarItemBitmap * This,
    /* [in] */ LONG bmWidth,
    /* [in] */ LONG bmHeight,
    /* [in] */ DWORD dwFlags,
    /* [out] */ HBITMAP *phbmp,
    /* [out] */ HBITMAP *phbmpMask);


void __RPC_STUB ITfLangBarItemBitmap_DrawBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemBitmap_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItemBalloon_INTERFACE_DEFINED__
#define __ITfLangBarItemBalloon_INTERFACE_DEFINED__

/* interface ITfLangBarItemBalloon */
/* [unique][uuid][object] */ 

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("f399a969-9e97-4ddd-b974-2bfb934cfbc9") 
enum __MIDL_ITfLangBarItemBalloon_0001
    {	TF_LB_BALLOON_RECO	= 0,
	TF_LB_BALLOON_SHOW	= 1,
	TF_LB_BALLOON_MISS	= 2
    } 	TfLBBalloonStyle;

typedef /* [uuid] */  DECLSPEC_UUID("37574483-5c50-4092-a55c-922e3a67e5b8") struct TF_LBBALLOONINFO
    {
    TfLBBalloonStyle style;
    BSTR bstrText;
    } 	TF_LBBALLOONINFO;


EXTERN_C const IID IID_ITfLangBarItemBalloon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01C2D285-D3C7-4B7B-B5B5-D97411D0C283")
    ITfLangBarItemBalloon : public ITfLangBarItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnClick( 
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreferedSize( 
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBalloonInfo( 
            /* [out] */ TF_LBBALLOONINFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemBalloonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemBalloon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemBalloon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemBalloon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItemBalloon * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItemBalloon * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItemBalloon * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItemBalloon * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnClick )( 
            ITfLangBarItemBalloon * This,
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferedSize )( 
            ITfLangBarItemBalloon * This,
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz);
        
        HRESULT ( STDMETHODCALLTYPE *GetBalloonInfo )( 
            ITfLangBarItemBalloon * This,
            /* [out] */ TF_LBBALLOONINFO *pInfo);
        
        END_INTERFACE
    } ITfLangBarItemBalloonVtbl;

    interface ITfLangBarItemBalloon
    {
        CONST_VTBL struct ITfLangBarItemBalloonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemBalloon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemBalloon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemBalloon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemBalloon_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItemBalloon_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItemBalloon_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItemBalloon_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)


#define ITfLangBarItemBalloon_OnClick(This,click,pt,prcArea)	\
    (This)->lpVtbl -> OnClick(This,click,pt,prcArea)

#define ITfLangBarItemBalloon_GetPreferedSize(This,pszDefault,psz)	\
    (This)->lpVtbl -> GetPreferedSize(This,pszDefault,psz)

#define ITfLangBarItemBalloon_GetBalloonInfo(This,pInfo)	\
    (This)->lpVtbl -> GetBalloonInfo(This,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemBalloon_OnClick_Proxy( 
    ITfLangBarItemBalloon * This,
    /* [in] */ TfLBIClick click,
    /* [in] */ POINT pt,
    /* [in] */ const RECT *prcArea);


void __RPC_STUB ITfLangBarItemBalloon_OnClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBalloon_GetPreferedSize_Proxy( 
    ITfLangBarItemBalloon * This,
    /* [in] */ const SIZE *pszDefault,
    /* [out] */ SIZE *psz);


void __RPC_STUB ITfLangBarItemBalloon_GetPreferedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBalloon_GetBalloonInfo_Proxy( 
    ITfLangBarItemBalloon * This,
    /* [out] */ TF_LBBALLOONINFO *pInfo);


void __RPC_STUB ITfLangBarItemBalloon_GetBalloonInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemBalloon_INTERFACE_DEFINED__ */


#ifndef __ITfMenu_INTERFACE_DEFINED__
#define __ITfMenu_INTERFACE_DEFINED__

/* interface ITfMenu */
/* [unique][uuid][object] */ 

#define	TF_LBMENUF_CHECKED	( 0x1 )

#define	TF_LBMENUF_SUBMENU	( 0x2 )

#define	TF_LBMENUF_SEPARATOR	( 0x4 )

#define	TF_LBMENUF_RADIOCHECKED	( 0x8 )

#define	TF_LBMENUF_GRAYED	( 0x10 )


EXTERN_C const IID IID_ITfMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6F8A98E4-AAA0-4F15-8C5B-07E0DF0A3DD8")
    ITfMenu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddMenuItem( 
            /* [in] */ UINT uId,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ HBITMAP hbmpMask,
            /* [size_is][unique][in] */ const WCHAR *pch,
            /* [in] */ ULONG cch,
            /* [unique][out][in] */ ITfMenu **ppMenu) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMenu * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddMenuItem )( 
            ITfMenu * This,
            /* [in] */ UINT uId,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ HBITMAP hbmpMask,
            /* [size_is][unique][in] */ const WCHAR *pch,
            /* [in] */ ULONG cch,
            /* [unique][out][in] */ ITfMenu **ppMenu);
        
        END_INTERFACE
    } ITfMenuVtbl;

    interface ITfMenu
    {
        CONST_VTBL struct ITfMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMenu_AddMenuItem(This,uId,dwFlags,hbmp,hbmpMask,pch,cch,ppMenu)	\
    (This)->lpVtbl -> AddMenuItem(This,uId,dwFlags,hbmp,hbmpMask,pch,cch,ppMenu)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMenu_AddMenuItem_Proxy( 
    ITfMenu * This,
    /* [in] */ UINT uId,
    /* [in] */ DWORD dwFlags,
    /* [in] */ HBITMAP hbmp,
    /* [in] */ HBITMAP hbmpMask,
    /* [size_is][unique][in] */ const WCHAR *pch,
    /* [in] */ ULONG cch,
    /* [unique][out][in] */ ITfMenu **ppMenu);


void __RPC_STUB ITfMenu_AddMenuItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMenu_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctfutb_0212 */
/* [local] */ 

#endif // CTFUTB_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0212_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0212_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long *, unsigned long            , HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal(  unsigned long *, unsigned char *, HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long *, unsigned char *, HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long *, HBITMAP * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long *, HICON * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\devdsc.cpp ===
/*
 *	DEVDSC.C
 *	
 *	Purpose:
 *		CDevDesc (Device Descriptor) class
 *	
 *	Owner:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 */

#include "_common.h"
#include "_devdsc.h"
#include "_edit.h"
#include "_font.h"

ASSERTDATA

BOOL CDevDesc::SetDC(HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::SetDC");

	AssertSz((NULL == hdc) || (GetDeviceCaps(hdc, TECHNOLOGY) != DT_METAFILE),
		"CDevDesc::SetDC attempting to set a metafile");

	_hdc = hdc;
	if(!_hdc)
	{
	    if(!_ped->_fInPlaceActive || !(hdc = _ped->TxGetDC()))
        {
            _dxpInch = _dypInch = 0;
    	    return FALSE;
        }
    }

	if (dxpInch == -1)
	{
		// Get device metrics - these should both succeed
		_dxpInch = (SHORT)GetDeviceCaps(hdc, LOGPIXELSX);
		AssertSz(_dxpInch != 0, "CDevDesc::SetDC _dxpInch is 0");
	}
	else
		_dxpInch = dxpInch;

	if (dypInch == -1)
	{
		_dypInch = (SHORT)GetDeviceCaps(hdc, LOGPIXELSY);
		AssertSz(_dypInch != 0, "CDevDesc::SetDC _dypInch is 0");
	}
	else
		_dypInch = dypInch;

	if(!_dxpInch || !_dypInch)
		return FALSE;

	// Release DC if we got the window DC
	if(!_hdc)
		_ped->TxReleaseDC(hdc);

	return TRUE;
}


void CDevDesc::SetMetafileDC(
	HDC hdcMetafile,
	LONG xMeasurePerInch,
	LONG yMeasurePerInch)
{
	_fMetafile = TRUE;
	_hdc = hdcMetafile;
	_dxpInch = (SHORT) xMeasurePerInch;
	_dypInch = (SHORT) yMeasurePerInch;
}

HDC CDevDesc::GetScreenDC() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::GetScreenDC");

	Assert(!_hdc);
	Assert(_ped);
	return _ped->TxGetDC();
}

VOID CDevDesc::ReleaseScreenDC(HDC hdc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::ReleaseScreenDC");

	Assert(!_hdc);
	Assert(_ped);
	_ped->TxReleaseDC(hdc);
}


void CDevDesc::LRtoDR(RECT &rcDest, const RECT &rcSrc, TFLOW tflow) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LRtoDR");

	if (!IsUVerticalTflow(tflow))
	{
		rcDest.left = LXtoDX(rcSrc.left);    
		rcDest.right = LXtoDX(rcSrc.right);    
		rcDest.top = LYtoDY(rcSrc.top);    
		rcDest.bottom = LYtoDY(rcSrc.bottom);    
	}
	else
	{
		rcDest.left = LYtoDY(rcSrc.left);    
		rcDest.right = LYtoDY(rcSrc.right);    
		rcDest.top = LXtoDX(rcSrc.top);    
		rcDest.bottom = LXtoDX(rcSrc.bottom);    
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\cuim.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	CUIM.CPP	-- Cicero Implementation
 *	
 *		Most everything to do with Cicero handling.
 *
 *	Original Author: <nl>
 *		Hon Wah Chan
 *
 *	History: <nl>
 *		11/16/1999  honwch
 *
 *	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

#ifndef NOFEPROCESSING

#ifndef NOPRIVATEMESSAGE
#include "_MSREMSG.H"
#endif	

#include "_array.h"
#include "msctf.h"
#include "textstor.h"
#include "ctffunc.h"

#include "msctf_g.c"
#include "msctf_i.c"
#include "textstor_i.c"
#include "ctffunc_i.c"
#include "msctfp.h"
#include "msctfp_g.c"

#include "textserv.h"
#include "_cmsgflt.h"
#include "_ime.h"

#include "_cuim.h"

const IID IID_ITfContextRenderingMarkup = { 
    0xa305b1c0,
    0xc776,
    0x4523,
    {0xbd, 0xa0, 0x7c, 0x5a, 0x2e, 0x0f, 0xef, 0x10}
};

const IID IID_ITfEnableService = {
	0x3035d250,
	0x43b4,
	0x4253,
	{0x81, 0xe6, 0xea, 0x87, 0xfd, 0x3e, 0xed, 0x43}
};

const IID IID_IServiceProvider = {
	0x6d5140c1,
	0x7436,
	0x11ce,
	{0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa}
};

// {35D46968-01FF-4cd8-A379-9A87C9CC789F}
const GUID CLSID_MSFTEDIT = {
	0x35d46968,
	0x01ff,
	0x4cd8,
	{0xa3,0x79,0x9a,0x87, 0xc9,0xcc,0x78,0x9f}
};

#define CONNECT_E_NOCONNECTION MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0200)	// from OLECTL.H

#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const GUID name \
        = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

#include "dcattrs.h"

const TS_ATTRID *_arTSAttridSupported[] =
{
	&DCATTRID_Font_FaceName,			// iattrFacename
	&DCATTRID_Font_SizePts,				// iattrSize
	&DCATTRID_Font_Style_Color,			// iattrColor
	&DCATTRID_Font_Style_Bold,			// iattrBold
	&DCATTRID_Font_Style_Italic,		// iattrItalic
	&DCATTRID_Font_Style_Underline,		// iattrUnderline
	&DCATTRID_Font_Style_Subscript,		// iattrSubscript
	&DCATTRID_Font_Style_Superscript,	// iattrSuperscript
	&DCATTRID_Text_RightToLeft,			// iattrRTL
	&DCATTRID_Text_VerticalWriting,		// iattrVertical
	&GUID_PROP_MODEBIAS,				// iattrBias
	&DCATTRID_Text_Orientation,			// iattrTxtOrient
};

enum IATTR_INDEX
{
	iattrFacename = 0,
	iattrSize,
	iattrColor,
	iattrBold,
	iattrItalic,
	iattrUnderline,
	iattrSubscript,
	iattrSuperscript,
	iattrRTL,
	iattrVertical,
	iattrBias,
	iattrTxtOrient,
	MAX_ATTR_SUPPORT
};


/* GUID_NULL */
const GUID GUID_NULL = {
	0x00000000,
	0x0000,
	0x0000,
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	};

const GUID GUID_DCSERVICE_DATAOBJECT = {
	0x6086fbb5, 
	0xe225, 
	0x46ce, 
	{0xa7, 0x70, 0xc1, 0xbb, 0xd3, 0xe0, 0x5d, 0x7b}
};

const GUID GUID_DCSERVICE_ACCESSIBLE = {
	0xf9786200, 
	0xa5bf, 
	0x4a0f, 
	{0x8c, 0x24, 0xfb, 0x16, 0xf5, 0xd1, 0xaa, 0xbb}
};

const GUID GUID_DCSERVICE_ACTIVEX = {
	0xea937a50, 
	0xc9a6, 
	0x4b7d, 
	{0x89, 0x4a, 0x49, 0xd9, 0x9b, 0x78, 0x48, 0x34}
};

// This array need to match the definition for EM_SETCTFMODEBIAS
const GUID *_arModeBiasSupported[] =
{
	&GUID_MODEBIAS_NONE,
	&GUID_MODEBIAS_FILENAME,
	&GUID_MODEBIAS_NAME,
	&GUID_MODEBIAS_READING,
	&GUID_MODEBIAS_DATETIME,
	&GUID_MODEBIAS_CONVERSATION,
	&GUID_MODEBIAS_NUMERIC,
	&GUID_MODEBIAS_HIRAGANA,
	&GUID_MODEBIAS_KATAKANA,
	&GUID_MODEBIAS_HANGUL,
	&GUID_MODEBIAS_HALFWIDTHKATAKANA,
	&GUID_MODEBIAS_FULLWIDTHALPHANUMERIC,
	&GUID_MODEBIAS_HALFWIDTHALPHANUMERIC,
};

/*
 *	CUIM::CUIM ()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 *
 */
CUIM::CUIM(CTextMsgFilter *pTextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CUIM");

	_crefs = 1;
	_pTextMsgFilter = pTextMsgFilter;
};

/*
 *	CUIM::~CUIM ()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 *
 */
CUIM::~CUIM()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::~CUIM");

	Uninit();
}

/*
 *	STDMETHODIMP CUIM::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		IUnknown QueryInterface support
 *
 *	@rdesc
 *		NOERROR if interface supported
 *
 */
STDMETHODIMP CUIM::QueryInterface (REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_ITextStoreACP) )
		*ppv = (ITextStoreACP *)this;

    else if(IsEqualIID(riid, IID_ITfContextOwnerCompositionSink) )
		*ppv = (ITfContextOwnerCompositionSink *)this;

	else if (IsEqualIID(riid, IID_ITfMouseTrackerACP))
		*ppv = (ITfMouseTrackerACP *)this;

    else if (IsEqualIID(riid, IID_ITfEnableService))
		*ppv = (ITfEnableService *)this;

    else if (IsEqualIID(riid, IID_IServiceProvider))
		*ppv = (IServiceProvider *)this;

	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(ULONG) CUIM::AddRef
 *
 *	@mfunc
 *		IUnknown AddRef support
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CUIM::AddRef()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::AddRef");

	return ++_crefs;
}

/*
 *	STDMETHODIMP_(ULONG) CUIM::Release()
 *
 *	@mfunc
 *		IUnknown Release support - delete object when reference count is 0
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CUIM::Release()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	STDMETHODIMP CUIM::AdviseSink()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::AdviseSink(
	REFIID riid, 
	IUnknown *punk, 
	DWORD dwMask)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::AdviseSink");

    HRESULT hr = E_FAIL;

	if (_fShutDown)
		return E_UNEXPECTED;

    Assert(_ptss == NULL);
    
	if(IsEqualIID(riid, IID_ITextStoreACPSink))
		hr = punk->QueryInterface(riid, (void **)&_ptss);

    return hr == S_OK ? S_OK : E_UNEXPECTED;
}

/*
 *	STDMETHODIMP CUIM::UnadviseSink()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::UnadviseSink(IUnknown *punk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::UnadviseSink");

    Assert(_ptss == punk); // we're dealing with cicero, this should always hold
    _ptss->Release();
	_ptss = NULL;
    return S_OK;
}

/*
 *	STDMETHODIMP CUIM::RequestLock()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RequestLock(
	DWORD dwLockFlags, 
	HRESULT *phrSession)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RequestLock");

	if (!phrSession)
		return E_POINTER;

	if (_fShutDown)
	{
		*phrSession = TS_E_SYNCHRONOUS;
		return S_OK;
	}

	Assert(_ptss);

	if (_cCallMgrLevels && !_fAllowUIMLock ||	// Check if we are ready to grant locks
		_fReadLockOn || _fWriteLockOn)			//  We don't allow re-entrance either.
	{
		// No lock allow
		if (dwLockFlags & TS_LF_SYNC)
			*phrSession = TS_E_SYNCHRONOUS;
		else
		{
			if (dwLockFlags & TS_LF_READ)
				_fReadLockPending = 1;
			if ((dwLockFlags & TS_LF_READWRITE) == TS_LF_READWRITE)
				_fWriteLockPending = 1;

			*phrSession = TS_S_ASYNC; 
		}
		return S_OK;
	}

	IUnknown *pIUnknown = NULL;

	HRESULT hResult = _pTextMsgFilter->_pTextDoc->GetCallManager(&pIUnknown);

	if ((dwLockFlags & TS_LF_READWRITE) == TS_LF_READWRITE)
	{
		_fReadLockPending = 0;
		_fWriteLockPending = 0;
		_fReadLockOn = 1;
		_fWriteLockOn = 1;
	}
	else if ((dwLockFlags & TS_LF_READ) == TS_LF_READ)
	{
		_fReadLockPending = 0;
		_fReadLockOn = 1;
	}

	if (_fWriteLockOn)
	{
		if (W32->IsFECodePage(_pTextMsgFilter->_uKeyBoardCodePage))
			_pTextMsgFilter->_pTextDoc->IMEInProgress(tomTrue);
		EnterCriticalSection(&g_CriticalSection);
	}

	*phrSession = _ptss->OnLockGranted(dwLockFlags);

	if (_fWriteLockOn)
	{
		// Check if any text has been added
		if (_parITfEnumRange && _parITfEnumRange->Count())
		{
			int	idx;
			int idxMax = _parITfEnumRange->Count();

			for (idx = 0 ; idx < idxMax; idx++)
			{
				IEnumTfRanges **ppEnumRange = (IEnumTfRanges **)(_parITfEnumRange->Elem(idx));
				if (ppEnumRange && *ppEnumRange)
				{
					HandleFocusRange(*ppEnumRange);
					(*ppEnumRange)->Release();
				}
			}
			_parITfEnumRange->Clear(AF_KEEPMEM);
		}
	}

	if (_fEndTyping)
		OnUIMTypingDone();

	if (_fWriteLockOn)
	{
		_pTextMsgFilter->_pTextDoc->IMEInProgress(tomFalse);
		LeaveCriticalSection(&g_CriticalSection);
	}

	_fEndTyping = 0;
	_fWriteLockOn = 0;
	_fReadLockOn = 0;
	_fHoldCTFSelChangeNotify = 1;

	if (pIUnknown)
		hResult = _pTextMsgFilter->_pTextDoc->ReleaseCallManager(pIUnknown);

	_fHoldCTFSelChangeNotify = 0;

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::GetStatus()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetStatus(
	TS_STATUS *pdcs)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetStatus");

	if (_fShutDown)
		return S_OK;

	if (pdcs)
	{
		LRESULT		lresult = 0;

		pdcs->dwStaticFlags = (TS_SS_REGIONS | TS_SS_NOHIDDENTEXT);

		if ( S_OK == _pTextMsgFilter->_pTextService->TxSendMessage(
			EM_GETDOCFLAGS, GDF_ALL, 0, &lresult))
		{
			if (lresult & GDF_READONLY)
				pdcs->dwDynamicFlags = TS_SD_READONLY;

			// Don't want to support overtyping in Cicero yet.
			//	if (lresult & GDF_OVERTYPE)
			//		dcs.dwDynamicFlags = TS_SD_OVERTYPE;
		}
	}
	return S_OK;
}
/*
 *	STDMETHODIMP CUIM::QueryInsert()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::QueryInsert(
	LONG		acpTestStart,
	LONG		acpTestEnd,
	ULONG		cch,
	LONG		*pacpResultStart,
	LONG		*pacpResultEnd)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::QueryInsert");

	HRESULT hResult;
	ITextRange *pTextRange = NULL;

	*pacpResultStart = -1;
	*pacpResultEnd = -1;

	if (_fShutDown)
		return S_OK;

	hResult = _pTextMsgFilter->_pTextDoc->Range(acpTestStart, acpTestEnd, &pTextRange);

	if (hResult != S_OK)
		return TS_E_READONLY;

	Assert(pTextRange);
	if(pTextRange->CanEdit(NULL) == S_FALSE)
	{
		hResult = TS_E_READONLY;
		goto EXIT;			// Cannot edit text
	}

	*pacpResultStart = acpTestStart;
	*pacpResultEnd = acpTestEnd;
	hResult = S_OK;

EXIT:
	pTextRange->Release();
	return hResult;
}

/*
 *	STDMETHODIMP CUIM::GetSelection()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetSelection(
	ULONG ulIndex, 
	ULONG ulCount, 
	TS_SELECTION_ACP *pSelection, 
	ULONG *pcFetched)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetSelection");

	HRESULT hResult;
	ITextSelection	*pTextSel = NULL;

	if (!pSelection || !pcFetched)
		return E_POINTER;

	if (!_fReadLockOn)
		return TS_E_NOLOCK;

	*pcFetched = 0;

	if (_fShutDown)
		return TS_E_NOSELECTION;

	if (ulIndex == TS_DEFAULT_SELECTION)
		ulIndex = 0;
	else if (ulIndex > 1)
		return E_INVALIDARG; // We donnot have discontiguous selection.

	if (_fInterimChar)
	{
		pSelection[0].acpStart = _acpInterimStart;
		pSelection[0].acpEnd = _acpInterimEnd;
		pSelection[0].style.ase = (TsActiveSelEnd) _ase;
		pSelection[0].style.fInterimChar = TRUE;

	    *pcFetched = 1;

		return S_OK;
	}

	hResult = _pTextMsgFilter->_pTextDoc->GetSelectionEx(&pTextSel);

	if (pTextSel)
	{
		long	cpMin = 0, cpMax = 0;
		long	lFlags = 0;
		hResult	= pTextSel->GetStart(&cpMin);
		hResult	= pTextSel->GetEnd(&cpMax);
		hResult = pTextSel->GetFlags(&lFlags);

		pSelection[0].acpStart = cpMin;
		pSelection[0].acpEnd = cpMax;
		pSelection[0].style.ase = (lFlags & tomSelStartActive) ? TS_AE_START : TS_AE_END;
		pSelection[0].style.fInterimChar = FALSE;

	    *pcFetched = 1;
		pTextSel->Release();

		return S_OK;	
	}
	return TS_E_NOSELECTION;
}

/*
 *	STDMETHODIMP CUIM::SetSelection()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::SetSelection(
	ULONG ulCount, 
	const TS_SELECTION_ACP *pSelection)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::SetSelection");

	HRESULT hResult;
	ITextRange *pTextRange = NULL;

	if (!pSelection)
		return E_POINTER;

	if (ulCount <= 0)
		return E_INVALIDARG;

	if (!_fWriteLockOn)
		return TS_E_NOLOCK;

	if (_fShutDown)
		return S_OK;

	if (pSelection->style.fInterimChar)
	{
		_pTextMsgFilter->_pTextDoc->SetCaretType(tomKoreanBlockCaret);	// Set Block caret mode
		_acpInterimStart = pSelection[0].acpStart;
		_acpInterimEnd = pSelection[0].acpEnd;
		_fInterimChar = 1;
		_ase = pSelection[0].style.ase;
	}
	else
	{
		if (_fInterimChar)
		{
			_fInterimChar = 0;
			_pTextMsgFilter->_pTextDoc->SetCaretType(tomNormalCaret);		// Reset Block caret mode
		}

		hResult = _pTextMsgFilter->_pTextDoc->Range(pSelection[0].acpStart, pSelection[0].acpEnd, &pTextRange);

		if (pTextRange)
		{
			long	lCount;
			_pTextMsgFilter->_pTextDoc->Freeze(&lCount);		// Turn off display
			pTextRange->Select();
			pTextRange->Release();
			_pTextMsgFilter->_pTextDoc->Unfreeze(&lCount);		// Turn on display
		}
	}
	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::GetText()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetText(
	LONG acpStart, 
	LONG acpEnd, 
	WCHAR *pchPlain, 
	ULONG cchPlainReq, 
	ULONG *pcchPlainOut, 
	TS_RUNINFO *prgRunInfo,
	ULONG ulRunInfoReq, 
	ULONG *pulRunInfoOut, 
	LONG *pacpNext)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetText");

	if (!_fReadLockOn)
		return TS_E_NOLOCK;

	if (pchPlain == NULL && cchPlainReq != 0 ||
		prgRunInfo == NULL && ulRunInfoReq != 0)
		return E_INVALIDARG;

	BOOL	fDoRunInfo = ulRunInfoReq > 0;
	LONG	acpMaxText = 0;
	BOOL	fEOP = FALSE;

	GetStoryLength(&acpMaxText);

	if (acpStart < 0 || acpStart > acpMaxText)
		return TS_E_INVALIDPOS;

	if (acpEnd < 0)
		acpEnd = acpMaxText;
	else if (acpEnd < acpStart)
		return TS_E_INVALIDPOS;

	if (pcchPlainOut)
		*pcchPlainOut = 0;
	if (pulRunInfoOut)
		*pulRunInfoOut = 0;
	if (pacpNext)
		*pacpNext = acpStart;

	if (_fShutDown)
		return S_OK;

	LRESULT		lresult = 0;
	if ( S_OK == _pTextMsgFilter->_pTextService->TxSendMessage(
		EM_GETDOCFLAGS, GDF_ALL, 0, &lresult))
	{
		if ((lresult & GDF_RICHTEXT) && acpEnd == acpMaxText)
			fEOP = TRUE;
	}

	if (cchPlainReq || ulRunInfoReq)
	{
		HRESULT		hResult;
		ITextRange	*pTextRange = NULL;
		long		fHiddenTextInRange = tomFalse;
		BOOL		fCopyData = FALSE;
		long		*pHiddenTxtBlk = NULL;
		long		cHiddenTxtBlk = 0;

		if (cchPlainReq && acpEnd > (long)cchPlainReq + acpStart)
			acpEnd = cchPlainReq + acpStart;

		hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpEnd, &pTextRange);

		if (pTextRange)
		{
			BSTR	bstr = NULL;
			long	cpMin, cpMax;
			ULONG	cch;

			pTextRange->GetStart(&cpMin);
			pTextRange->GetEnd(&cpMax);

			if (fDoRunInfo)
			{
				ITextFont	*pFont = NULL;

				hResult = pTextRange->GetFont(&pFont);

				if (pFont)
				{
					pFont->GetHidden(&fHiddenTextInRange);
					pFont->Release();

					if (fHiddenTextInRange == tomUndefined)		// Some hidden text inside range
						BuildHiddenTxtBlks(cpMin, cpMax, &pHiddenTxtBlk, cHiddenTxtBlk);
				}
			}

			hResult = pTextRange->GetText(&bstr);

			if (bstr)
			{
				cch = cpMax - cpMin;

				if (cchPlainReq)
				{
					if (cchPlainReq > cch)		
						cchPlainReq = cch;
					
					fCopyData = TRUE;
				}
				else
					cchPlainReq = cch;

				// Convert character into special Cicero char.
				long	cpCurrentStart = cpMin;
				long	cpCurrent = cpMin;
				long	idx = 0;
				ULONG	cRunInfo = 0;
				BOOL	fRunInfoNotEnough = FALSE;

				long cpNextHiddenText = tomForward;

				if (fDoRunInfo && pHiddenTxtBlk)
					cpNextHiddenText = pHiddenTxtBlk[0];

				if (fHiddenTextInRange != tomTrue)
				{
					WCHAR *pText = (WCHAR *)bstr;
					while (cpCurrent < cpMax)
					{
						if (cpCurrent == cpNextHiddenText)
						{
							// setup run info for current good text
							if (cpCurrent != cpCurrentStart)
							{
								if (cRunInfo >= ulRunInfoReq)
								{
									fRunInfoNotEnough = TRUE;
									break;
								}
								prgRunInfo[cRunInfo].uCount = cpCurrent - cpCurrentStart;
								prgRunInfo[cRunInfo].type = TS_RT_PLAIN;
								cRunInfo++;
							}

							long cchHiddenText = pHiddenTxtBlk[idx+1];

							// setup run info for hidden text block
							if (cRunInfo >= ulRunInfoReq)
							{
								fRunInfoNotEnough = TRUE;
								break;
							}
							prgRunInfo[cRunInfo].uCount = cchHiddenText;
							prgRunInfo[cRunInfo].type = TS_RT_OPAQUE;
							cRunInfo++;

							idx += 2;
							if (idx < cHiddenTxtBlk)
								cpNextHiddenText = pHiddenTxtBlk[idx];
							else
								cpNextHiddenText = tomForward;

							cpCurrent += cchHiddenText;
							pText += cchHiddenText;
							cpCurrentStart = cpCurrent;
						}
						else
						{
							switch (*pText)
							{
								case WCH_EMBEDDING:
									*pText = TS_CHAR_EMBEDDED;
									break;

								case STARTFIELD:
								case ENDFIELD:
									*pText = TS_CHAR_REGION;
									if (cpCurrent + 1 < cpMax)
									{
										pText++;
										cpCurrent++;
										Assert(*pText == 0x000d);
										*pText = TS_CHAR_REGION;
									}
									break;
							}
							cpCurrent++;
							// Convert EOP into TS_CHAR_REGION
							if (fEOP && cpCurrent == acpMaxText && *pText == CR)
								*pText = TS_CHAR_REGION;
							pText++;
						}
					}
				}

				if (fDoRunInfo)
				{
					// setup run info for last chunk of good text
					if (cpCurrent != cpCurrentStart && cRunInfo < ulRunInfoReq)
					{
						prgRunInfo[cRunInfo].uCount = cpCurrent - cpCurrentStart;
						prgRunInfo[cRunInfo].type = TS_RT_PLAIN;
						cRunInfo++;
					}

					if (pulRunInfoOut)
						*pulRunInfoOut = cRunInfo ? cRunInfo : 1;

					// All the text belong to the same run
					if (cRunInfo == 0)
					{
						prgRunInfo[0].uCount = cchPlainReq;
						prgRunInfo[0].type = (fHiddenTextInRange == tomTrue) ? TS_RT_OPAQUE : TS_RT_PLAIN;
					}
				}

				if (fRunInfoNotEnough)
				{
					// Runinfo too small. need to add cch from all valid runs
					TS_RUNINFO	*prgRunInfoData = prgRunInfo;
					ULONG	idx;
					cchPlainReq = 0;
					for (idx=0; idx < cRunInfo; idx++)
					{
						cchPlainReq += prgRunInfoData->uCount;
						prgRunInfoData++;
					}
				}

				if (fCopyData)
					// fill in the buffer
					memcpy(pchPlain, (LPSTR)bstr, cchPlainReq * sizeof(WCHAR));

				if (pcchPlainOut)
					*pcchPlainOut = cchPlainReq;

				if (pacpNext)
					*pacpNext = cpMin + cchPlainReq;

				SysFreeString(bstr);
			}

			pTextRange->Release();

			FreePv(pHiddenTxtBlk);
		}
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::SetText()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::SetText(
	DWORD dwFlags,
	LONG acpStart, 
	LONG acpEnd, 
	const WCHAR *pchText, 
	ULONG cch, 
	TS_TEXTCHANGE *pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::SetText");

	return InsertData(dwFlags, acpStart, acpEnd, pchText, cch, NULL, pChange);
}

/*
 *	STDMETHODIMP CUIM::InsertData()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::InsertData(
	DWORD			dwFlags,
	LONG			acpStart,
	LONG			acpEnd,
	const WCHAR		*pchText,
	ULONG			cch,
	IDataObject		*pDataObject,
	TS_TEXTCHANGE	*pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertData");

	HRESULT		hResult = S_OK;
	ITextRange	*pTextRange = NULL;
	BOOL		fInsertObject = pDataObject != NULL;

	if (!_fWriteLockOn)
		return TS_E_NOLOCK;

	if (_fShutDown)
		return S_OK;

	hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpEnd, &pTextRange);

	if (pTextRange)
	{
		BSTR	bstr = NULL;

		if(pTextRange->CanEdit(NULL) == S_FALSE)
		{
			pTextRange->Release();
			return TS_E_READONLY;			// Cannot edit text
		}

		LONG	cchExced = 0;
		BOOL	fDelSelection = FALSE;
		if ((LONG)cch > (acpEnd - acpStart) &&
			_pTextMsgFilter->_pTextDoc->CheckTextLimit((LONG)cch - (acpEnd-acpStart), &cchExced) == NOERROR &&
				cchExced > 0)
		{
			// We reach text limit, beep and exit
			_pTextMsgFilter->_pTextDoc->SysBeep();
			pTextRange->Release();
			return E_FAIL;
		}

		if (!fInsertObject)
		{
			bstr = SysAllocStringLen(pchText, cch);

			if (!bstr)
			{
				pTextRange->Release();
				return E_OUTOFMEMORY;
			}
		}

		if (!_fAnyWriteOperation)
		{
			// Start the UIM typing
			ITextFont	*pCurrentFont = NULL;
			BOOL		fRestFont = TRUE;
			_fAnyWriteOperation = 1;
			
			hResult	= pTextRange->GetStart(&_cpMin);

			// Hold notification if needed
			if (!(_pTextMsgFilter->_fIMEAlwaysNotify))
				_pTextMsgFilter->_pTextDoc->SetNotificationMode(tomFalse);

			if (!_bstrComposition)
			{
				if (fRestFont && _pTextFont)
				{
					_pTextFont->Release();
					_pTextFont = NULL;
				}

				if (acpStart != acpEnd)
				{
					if (_pTextFont == NULL)
					{
						ITextRange *pRange = NULL;
						// Get font at cpStart+1
						hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpStart+1, &pRange);
						if (pRange)
						{
							hResult = pRange->GetFont(&pCurrentFont);

							if (pCurrentFont)
							{
								hResult = pCurrentFont->GetDuplicate(&_pTextFont);
								pCurrentFont->Release();
								pCurrentFont = NULL;
							}
							pRange->Release();
						}
					}

					// if any current selection, turn on Undo to delete it....
					_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);
					pTextRange->SetText(NULL);
					_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);
					fDelSelection = TRUE;
				}
				else
				{
					ITextSelection	*pTextSel = NULL;
					hResult = _pTextMsgFilter->_pTextDoc->GetSelectionEx(&pTextSel);
					if (pTextSel)
					{
						long	cpMin = 0;
						hResult	= pTextSel->GetStart(&cpMin);

						if (hResult == S_OK && cpMin == acpStart)
							hResult = pTextSel->GetFont(&pCurrentFont);

						if (!pCurrentFont)
							hResult = pTextRange->GetFont(&pCurrentFont);

						if (pCurrentFont)
						{
							hResult = pCurrentFont->GetDuplicate(&_pTextFont);
							pCurrentFont->Release();
							pCurrentFont = NULL;
						}

						pTextSel->Release();
					}
				}
			}
			Assert (_pTextFont);
			if (_pTextFont)
			{
				long cpMin;
				pTextRange->GetStart(&cpMin);
				_pTextMsgFilter->_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
				CIme::CheckKeyboardFontMatching(cpMin, _pTextMsgFilter, _pTextFont);
			}
		}

		if (fInsertObject)
		{
			LRESULT		lresult;
			CHARRANGE	charRange = {acpStart, acpEnd};

			if (fDelSelection)
				charRange.cpMost = acpStart;

			hResult = _pTextMsgFilter->_pTextService->TxSendMessage(EM_INSERTOBJ, (WPARAM)&charRange,
				(LPARAM)pDataObject, &lresult);

			if (hResult == NOERROR && pChange)
			{
				pChange->acpStart = acpStart;
				pChange->acpOldEnd = acpEnd;
				pChange->acpNewEnd = acpStart+1;
			}
		}
		else
		{
			long	lCount;
			long	cpMin, cpMax;
			_pTextMsgFilter->_pTextDoc->Freeze(&lCount);		// Turn off display
			hResult = pTextRange->SetText(bstr);
			_pTextMsgFilter->_pTextDoc->Unfreeze(&lCount);		// Turn on display

			pTextRange->GetStart(&cpMin);
			pTextRange->GetEnd(&cpMax);

			if (_pTextFont)
				pTextRange->SetFont(_pTextFont);

			POINT	ptBottomPos;

			if (_pTextMsgFilter->_uKeyBoardCodePage == CP_KOREAN)
			{
				if (pTextRange->GetPoint( tomEnd+TA_BOTTOM+TA_LEFT,
					&(ptBottomPos.x), &(ptBottomPos.y) ) != NOERROR)
					pTextRange->ScrollIntoView(tomEnd);
			}

			SysFreeString(bstr);

			// out params
			pChange->acpStart = cpMin;
			pChange->acpOldEnd = acpEnd;
			pChange->acpNewEnd = cpMax;	

			hResult = S_OK;
		}
		pTextRange->Release();
	}
	return hResult;
}

/*
 *	STDMETHODIMP CUIM::GetFormattedText()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetFormattedText(
	LONG acpStart, 
	LONG acpEnd, 
	IDataObject **ppDataObject)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetFormattedText");

	return E_NOTIMPL;
}

/*
 *	STDMETHODIMP CUIM::GetEmbedded()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetEmbedded(
	LONG acpPos, 
	REFGUID rguidService, 
	REFIID riid, 
	IUnknown **ppunk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetEmbedded");

	WORD	wServiceRequested = 0;

	if (!_fReadLockOn)
		return TS_E_NOLOCK;

	if (!ppunk)
		return E_INVALIDARG;

	if (IsEqualIID(rguidService, GUID_DCSERVICE_ACTIVEX))
		wServiceRequested = 1;
	else if (IsEqualIID(rguidService, GUID_DCSERVICE_DATAOBJECT))
		wServiceRequested = 2;
	else
		return E_INVALIDARG;

	ITextRange	*pTextRange = NULL;
	IUnknown	*pIUnk = NULL;
	HRESULT		hResult = _pTextMsgFilter->_pTextDoc->Range(acpPos, acpPos+1, &pTextRange);

	if (SUCCEEDED(hResult) && pTextRange)
	{
		hResult = pTextRange->GetEmbeddedObject(&pIUnk);
		
		if (SUCCEEDED(hResult) && pIUnk)
			hResult = pIUnk->QueryInterface(wServiceRequested == 1 ? riid : IID_IDataObject, 
				(LPVOID FAR *)ppunk);
		else
			hResult = E_FAIL;

		if (pIUnk)
			pIUnk->Release();

		pTextRange->Release();
	}

	return hResult;
}

/*
 *	STDMETHODIMP CUIM::InsertEmbedded()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::InsertEmbedded(
	DWORD dwFlags, 
	LONG acpStart, 
	LONG acpEnd, 
	IDataObject *pDataObject, 
	TS_TEXTCHANGE *pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertEmbedded");

	if (!pDataObject)
		return E_INVALIDARG;

	if (_pTextMsgFilter->_fAllowEmbedded == 0)
		return TS_E_FORMAT;			// Client doesn't want insert embedded

	return InsertData(dwFlags, acpStart, acpEnd, NULL, 1, pDataObject, pChange);
}

/*
 *	STDMETHODIMP CUIM::RequestSupportedAttrs()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RequestSupportedAttrs(
	DWORD dwFlags, 
	ULONG cFilterAttrs, 
	const TS_ATTRID *paFilterAttrs)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RequestSupportedAttrs");

	if (_fShutDown)
		return E_NOTIMPL;

	return GetAttrs(0, cFilterAttrs, paFilterAttrs, TRUE);
}

/*
 *	STDMETHODIMP CUIM::RequestAttrsAtPosition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RequestAttrsAtPosition(
	LONG acpPos, 
	ULONG cFilterAttrs, 
	const TS_ATTRID *paFilterAttrs, 
	DWORD dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RequestAttrsAtPosition");

	if (_fShutDown)
		return E_NOTIMPL;

	return GetAttrs(acpPos, cFilterAttrs, paFilterAttrs, FALSE);
}

/*
 *	STDMETHODIMP CUIM::RequestAttrsTransitioningAtPosition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RequestAttrsTransitioningAtPosition(
	LONG acpPos, 
	ULONG cFilterAttrs, 
	const TS_ATTRID *paFilterAttrs, 
	DWORD dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RequestAttrsTransitioningAtPosition");

	return E_NOTIMPL;
}

/*
 *	STDMETHODIMP CUIM::FindNextAttrTransition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::FindNextAttrTransition(
	LONG acpStart, 
	LONG acpHalt, 
	ULONG cFilterAttrs, 
	const TS_ATTRID *paFilterAttrs,		
	DWORD dwFlags, 
	LONG *pacpNext,
	BOOL *pfFound,
	LONG *plFoundOffset)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::FindNextAttrTransition");

	return E_NOTIMPL;
}

/*
 *	STDMETHODIMP CUIM::RetrieveRequestedAttrs()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RetrieveRequestedAttrs(
	ULONG ulCount, 
	TS_ATTRVAL *paAttrVals, 
	ULONG *pcFetched)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RetrieveRequestedAttrs");

	if (!pcFetched)
		return E_INVALIDARG;

	if (_fShutDown)
		return E_NOTIMPL;

	*pcFetched = 0;

	if (_parAttrsVal && _uAttrsValCurrent < _uAttrsValTotal)
	{
		ULONG cFetched = min(ulCount, _uAttrsValTotal - _uAttrsValCurrent);

		if (cFetched)
		{
			memcpy(paAttrVals, &_parAttrsVal[_uAttrsValCurrent], cFetched * sizeof(TS_ATTRVAL));
			memset(&_parAttrsVal[_uAttrsValCurrent], 0, cFetched * sizeof(TS_ATTRVAL));
			_uAttrsValCurrent += cFetched;
			*pcFetched = cFetched;

			// If everything is fetched, clean up
			if (_uAttrsValCurrent == _uAttrsValTotal)
				InitAttrVarArray();
		}
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::GetEndACP()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetEndACP(LONG *pacp)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetEndACP");

	if (!_fReadLockOn)
		return TS_E_NOLOCK;

	if (!pacp)
		return E_INVALIDARG;

	if (_fShutDown)
		return E_NOTIMPL;

	return GetStoryLength(pacp);
}

/*
 *	STDMETHODIMP CUIM::GetActiveView()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetActiveView(TsViewCookie *pvcView)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetActiveView");

	if (!pvcView)
		return E_INVALIDARG;

	*pvcView = 0;
	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::GetACPFromPoint()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetACPFromPoint(
	TsViewCookie vcView,
	const POINT *pt, 
	DWORD dwFlags, 
	LONG *pacp)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetACPFromPoint");

	if (!pt || !pacp)
		return E_POINTER;

	if (_fShutDown)
		return E_NOTIMPL;

	ITextRange	*pTextRange = NULL;

	HRESULT hResult = _pTextMsgFilter->_pTextDoc->RangeFromPoint(pt->x, pt->y, &pTextRange);

	if (hResult == S_OK && pTextRange)
		hResult = pTextRange->GetStart(pacp);

	if (pTextRange)
		pTextRange->Release();

	return hResult;
}

/*
 *	STDMETHODIMP CUIM::GetTextExt()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetTextExt(
	TsViewCookie vcView,
	LONG acpStart, 
	LONG acpEnd, 
	RECT *prc, 
	BOOL *pfClipped)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetTextExt");

	if (!prc)
		return E_POINTER;

	if (_fShutDown)
		return E_NOTIMPL;

	if (pfClipped)
		*pfClipped = TRUE;

	ITextRange	*pTextRange = NULL;

	HRESULT hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpEnd, &pTextRange);

	if (hResult == S_OK && pTextRange)
	{
		BOOL fClipped = FALSE;

		POINT ptStart, ptEnd;
		hResult = pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT,
				&(ptStart.x), &(ptStart.y) );	
		
		if (hResult != S_OK)
		{
			hResult = pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT+tomAllowOffClient,
				&(ptStart.x), &(ptStart.y) );
			fClipped = TRUE;
		}

		if (hResult == S_OK)
		{
			hResult = pTextRange->GetPoint( acpStart == acpEnd ? tomStart+TA_BOTTOM+TA_LEFT : 
				tomEnd+TA_BOTTOM+TA_LEFT,
				&(ptEnd.x), &(ptEnd.y) );

			if (hResult != S_OK)
			{
				hResult = pTextRange->GetPoint( acpStart == acpEnd ? tomStart+TA_BOTTOM+TA_LEFT+tomAllowOffClient : 
					tomEnd+TA_BOTTOM+TA_LEFT+tomAllowOffClient,
					&(ptEnd.x), &(ptEnd.y) );
				fClipped = TRUE;
			}

			if (hResult == S_OK)
			{
				prc->left	= ptStart.x;
				prc->top	= ptStart.y;
				prc->right	= ptEnd.x;
				prc->bottom = ptEnd.y;
				if (pfClipped)
					*pfClipped = fClipped;
			}
		}
	}

	if (pTextRange)
		pTextRange->Release();

	return hResult;
}

/*
 *	STDMETHODIMP CUIM::GetScreenExt()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetScreenExt(
	TsViewCookie vcView,
	RECT *prc)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetScreenExt");

	if (!prc)
		return E_POINTER;

	return _pTextMsgFilter->_pTextDoc->GetClientRect(tomIncludeInset,
		&(prc->left), &(prc->top), &(prc->right), &(prc->bottom));

}

/*
 *	STDMETHODIMP CUIM::GetWnd()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetWnd(
	TsViewCookie vcView,
	HWND *phwnd)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetWnd");

	if (!phwnd)
		return E_INVALIDARG;

	if (_fShutDown)
		return E_NOTIMPL;

	*phwnd = _pTextMsgFilter->_hwnd;
	if (!*phwnd)								// Windowless mode...
	{
		long	hWnd;
		
		if (_pTextMsgFilter->_pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return E_NOTIMPL;	

		*phwnd = (HWND)(DWORD_PTR)hWnd;
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::QueryInsertEmbedded()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::QueryInsertEmbedded(
	const GUID *pguidService, 
	const FORMATETC *pFormatEtc, 
	BOOL *pfInsertable)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::QueryInsertEmbedded");
	if (!pfInsertable)
		return E_INVALIDARG;

	// Check setting if client wants to support embedded
	*pfInsertable = _pTextMsgFilter->_fAllowEmbedded ? TRUE : FALSE;
	return S_OK; 
}

/*
 *	STDMETHODIMP CUIM::InsertTextAtSelection()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::InsertTextAtSelection(
	DWORD dwFlags,
	const WCHAR *pchText,
	ULONG cch,
	LONG *pacpStart,
	LONG *pacpEnd,
	TS_TEXTCHANGE *pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertTextAtSelection");

	TS_SELECTION_ACP	acpSelection;
	ULONG				cFetched;
    LONG				acpResultStart;
    LONG				acpResultEnd;
	HRESULT				hr;

	if (_fShutDown)
		return E_NOTIMPL;

	if ((dwFlags & TS_IAS_QUERYONLY) || !(dwFlags & TS_IAS_NOQUERY))
	{
		if (!pacpStart || !pacpEnd)
			return E_POINTER;
	}

	hr = GetSelection(TS_DEFAULT_SELECTION, 1, &acpSelection, &cFetched);
	if (hr != S_OK)
		return hr;

	hr = QueryInsert(acpSelection.acpStart, acpSelection.acpEnd, cch,
		&acpResultStart, &acpResultEnd);

	if (hr != S_OK)
		return hr;

	if (dwFlags & TS_IAS_QUERYONLY)
    {
		// Query only, return data
        *pacpStart = acpResultStart;
        *pacpEnd = acpResultEnd;
        return S_OK;
    }

	if (!_fUIMTyping)
	{
		// special case where no OnStartComposition before this call
		_fInsertTextAtSel = 1;
		_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);		// turn off undo
	}

	hr = SetText(0, acpResultStart, acpResultEnd, pchText, cch, pChange);

	if (hr != S_OK)
	{
		if (!_fUIMTyping)
		{
			// SetText fail, reset state before exit
			_fInsertTextAtSel = 0;
			_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);		// turn on undo
		}
		return hr;
	}

	if (!(dwFlags & TS_IAS_NOQUERY) && pChange)
	{
		*pacpStart = pChange->acpStart;
		*pacpEnd = pChange->acpNewEnd;
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::InsertEmbeddedAtSelection()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::InsertEmbeddedAtSelection(
	DWORD dwFlags,
	IDataObject *pDataObject,
	LONG *pacpStart,
	LONG *pacpEnd,
	TS_TEXTCHANGE *pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertEmbeddedAtSelection");
	return E_NOTIMPL; 
}

/*
 *	void CUIM::OnPreReplaceRange()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::OnPreReplaceRange( 
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnPreReplaceRange");

	return;
};

/*
 *	void CUIM::OnPostReplaceRange()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::OnPostReplaceRange( 
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnPostReplaceRange");

	if (_fShutDown)
		return;

	if (cp != CONVERT_TO_PLAIN && cp != CP_INFINITE	&& _ptss && !_fWriteLockOn)
	{
		// Forward change notification to UIM
		TS_TEXTCHANGE	tsTxtChange;
		tsTxtChange.acpStart = cp;

		if (cchDel == cchNew)
		{
			// text modified
			tsTxtChange.acpNewEnd =
				tsTxtChange.acpOldEnd = cp + cchDel;		
			_ptss->OnTextChange(0, &tsTxtChange);
		}
		else
		{
			if (cchDel)
			{
				// text deleted
				tsTxtChange.acpNewEnd = cp;
				tsTxtChange.acpOldEnd = cp + cchDel;		
				_ptss->OnTextChange(0, &tsTxtChange);
			}

			if (cchNew)
			{
				// text added
				tsTxtChange.acpOldEnd = cp;
				tsTxtChange.acpNewEnd = cp + cchNew;
				_ptss->OnTextChange(0, &tsTxtChange);
			}
		}
	}
	return;
};

/*
 *	void CUIM::Zombie()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::Zombie() 
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Zombie");

	return;
};

/*
 *	STDMETHODIMP CUIM::OnStartComposition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDAPI CUIM::OnStartComposition(
	ITfCompositionView *pComposition,
	BOOL *pfOk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnStartComposition");
	if (_fUIMTyping)
		*pfOk = FALSE;
	else
	{
		BOOL fInsertTextCalled = _fInsertTextAtSel;
		BOOL fRetainFont = _fEndTyping;

		*pfOk = TRUE;
		_fUIMTyping = 1;
		_fAnyWriteOperation = _fAnyWriteOperation && (_fEndTyping || fInsertTextCalled);
		_fEndTyping = 0;
		_fInsertTextAtSel = 0;
		if (!fInsertTextCalled)
			_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);		// turn off undo
		_cchComposition = 0;
		_acpFocusRange = tomForward;
		_cchFocusRange = 0;

		CleanUpComposition();

		if (!fInsertTextCalled && pComposition)
		{
			HRESULT		hr;
			ITfRange	*pRangeNew = NULL;

			hr = pComposition->GetRange(&pRangeNew);

			if (pRangeNew)
			{
				LONG	acpStart;
				LONG	cchStart;

				GetExtentAcpPrange(pRangeNew, acpStart, cchStart);
				pRangeNew->Release();

				if (cchStart > 0)
				{
					// Save the original text
					ITextRange	*pTextRange = NULL;
					ITextFont	*pCurrentFont = NULL;
					HRESULT	hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpStart+cchStart, &pTextRange);

					if (!fRetainFont && _pTextFont)
					{
						_pTextFont->Release();
						_pTextFont = NULL;
					}

					if (pTextRange)
					{
						if (fRetainFont && _acpPreFocusRangeLast <= acpStart
							&& (acpStart + cchStart) <= (_acpPreFocusRangeLast + _cchFocusRangeLast))
						{
							// Cont'u from previous composition
							_acpFocusRange = _acpPreFocusRangeLast;
							_cchFocusRange = _cchFocusRangeLast;
						}
						else
						{
							hResult = pTextRange->GetText(&_bstrComposition);
							Assert(!_pObjects);
							_cObjects = BuildObject(pTextRange, _bstrComposition, &_pObjects, 0);
							_acpBstrStart = acpStart;
							_cchComposition = cchStart;
							GetEndACP(&_cpEnd);
						}

						if (!_pTextFont)
						{
							hResult = pTextRange->Collapse(tomTrue);
							hResult = pTextRange->Move(1, tomCharacter, NULL); 
							hResult = pTextRange->GetFont(&pCurrentFont);
							if (pCurrentFont)
							{
								hResult = pCurrentFont->GetDuplicate(&_pTextFont);
								pCurrentFont->Release();

								if (_pTextFont)
								{
									long cpMin;
									pTextRange->GetStart(&cpMin);
									_pTextMsgFilter->_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
									CIme::CheckKeyboardFontMatching(cpMin, _pTextMsgFilter, _pTextFont);
								}
							}
						}
						pTextRange->Release();
					}
				}
			}
		}
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::OnUpdateComposition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDAPI CUIM::OnUpdateComposition(
	ITfCompositionView *pComposition,
	ITfRange *pRangeNew)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnUpdateComposition");

	LONG	acpStart;
	LONG	cchStart;

	if (pRangeNew)
	{
		GetExtentAcpPrange(pRangeNew, acpStart, cchStart);

		if (_bstrComposition)
		{
			long	cpEnd;

			GetEndACP(&cpEnd);

			long	cpCurrentCompEnd = _acpBstrStart + _cchComposition + cpEnd - _cpEnd;
			long	cchExtendAfter = acpStart + cchStart - cpCurrentCompEnd;

			if (_acpBstrStart > acpStart)
			{
				LONG	cchExtendBefore = _acpBstrStart - acpStart;
				ITextRange	*pTextRange = NULL;
				HRESULT	hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, 
					acpStart+cchExtendBefore, &pTextRange);

				if (pTextRange)
				{
					BSTR	bstrExtendBefore = NULL;
					hResult = pTextRange->GetText(&bstrExtendBefore);

					if (bstrExtendBefore)
					{
						BSTR	bstrNew = SysAllocStringLen(NULL, _cchComposition+cchExtendBefore+1);

						if (bstrNew)
						{
							WCHAR	*pNewText = (WCHAR *)bstrNew;
							WCHAR	*pText = (WCHAR *)bstrExtendBefore;

							memcpy(pNewText, pText, cchExtendBefore * sizeof(WCHAR));

							pNewText += cchExtendBefore;
							pText = (WCHAR *)_bstrComposition;
							memcpy(pNewText, pText, _cchComposition * sizeof(WCHAR));
							*(pNewText+_cchComposition) = L'\0';

							SysFreeString(_bstrComposition);
							_bstrComposition = bstrNew;
							_cchComposition += cchExtendBefore;
							_acpBstrStart = acpStart;
						}
						SysFreeString(bstrExtendBefore);
					}
					pTextRange->Release();
				}
			}

			if (cchExtendAfter > 0)
			{
				// Extend beyond current composition, append new text to the original text
				ITextRange	*pTextRange = NULL;
				HRESULT	hResult = _pTextMsgFilter->_pTextDoc->Range(cpCurrentCompEnd, 
					cpCurrentCompEnd+cchExtendAfter, &pTextRange);

				if (pTextRange)
				{
					BSTR	bstrExtend = NULL;

					hResult = pTextRange->GetText(&bstrExtend);

					if (bstrExtend)
					{
						BSTR	bstrNew = SysAllocStringLen(NULL, _cchComposition+cchExtendAfter+1);

						if (bstrNew)
						{
							WCHAR	*pNewText = (WCHAR *)bstrNew;
							WCHAR	*pText = (WCHAR *)_bstrComposition;

							memcpy(pNewText, pText, _cchComposition * sizeof(WCHAR));

							pNewText += _cchComposition;
							pText = (WCHAR *)bstrExtend;
							memcpy(pNewText, pText, cchExtendAfter * sizeof(WCHAR));
							*(pNewText+cchExtendAfter) = L'\0';

							SysFreeString(_bstrComposition);
							_bstrComposition = bstrNew;
							_cchComposition += cchExtendAfter;
						}
						SysFreeString(bstrExtend);
					}
					pTextRange->Release();
				}
			}
		}
	}

	if (pComposition)
	{
		HRESULT		hr;
		ITfRange	*pRangeComp = NULL;

		hr = pComposition->GetRange(&pRangeComp);

		if (pRangeComp)
		{
			GetExtentAcpPrange(pRangeComp, _acpFocusRange, _cchFocusRange);
			pRangeComp->Release();
		}
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::OnEndComposition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDAPI CUIM::OnEndComposition(
	ITfCompositionView *pComposition)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnEndComposition");
	_fUIMTyping = 0;
	_fEndTyping = 1;
	_acpPreFocusRangeLast = _acpFocusRange;
	_cchFocusRangeLast = _cchFocusRange;
	_acpFocusRange = tomForward;
	_cchFocusRange = 0;

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::AdviseMouseSink()
 *
 *	@mfunc
 *		Setup Mouse Sink to handle mouse operation
 *
 *	@rdesc
 *		S_OK is mouse trap is added to link list
 *		CONNECT_E_NOCONNECTION is not added.
 */
STDAPI CUIM::AdviseMouseSink(
	ITfRangeACP *pRangeACP,
	ITfMouseSink *pSinkInput,
	DWORD *pdwCookie)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::AdviseMouseSink");

	if (_fShutDown)
		return CONNECT_E_NOCONNECTION;

	if (!pRangeACP || !pSinkInput || !pdwCookie)
		return E_POINTER;

	CTFMOUSETRAP	*pSinkNew = NULL;
	LONG			cpMouseStart, cchMosueComp;
	ITfMouseSink	*pSinkMouseInput = NULL;

	if (FAILED(pSinkInput->QueryInterface(IID_ITfMouseSink, (void **)&pSinkMouseInput)))
        return E_FAIL;

	if (GetExtentAcpPrange(pRangeACP, cpMouseStart, cchMosueComp))
	{
		if (!_pSinkList)						// No first link
		{
			_pSinkList = new CTFMOUSETRAP;
			pSinkNew = _pSinkList;
		}
		else
		{
			if (!(_pSinkList->pMouseSink))		// The first link is empty
				pSinkNew = _pSinkList;
			else
			{
				pSinkNew = new CTFMOUSETRAP;

				if (pSinkNew)					// Add new trap to the bottom of list
				{
					CTFMOUSETRAP	*pSink = _pSinkList;

					while (pSink->pNext)		// Find the bottom of list
						pSink = pSink->pNext;

					pSink->pNext = pSinkNew;
				}
			}
		}

		if (pSinkNew)
		{
			pSinkNew->dwCookie = *pdwCookie = (DWORD)(DWORD_PTR)pSinkMouseInput;
			pSinkNew->cpMouseStart = cpMouseStart;
			pSinkNew->cchMosueComp = cchMosueComp;
			pSinkNew->pMouseSink = pSinkMouseInput;

			_fMosueSink = 1;

			return S_OK;
		}
	}

	if (pSinkMouseInput)
		pSinkMouseInput->Release();

	return CONNECT_E_NOCONNECTION;
}

/*
 *	STDMETHODIMP CUIM::UnadviseMouseSink()
 *
 *	@mfunc
 *		Remove Mouse Sink
 *
 *	@rdesc
 *
 */
STDAPI CUIM::UnadviseMouseSink(
	DWORD	dwCookie)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::UnadviseMouseSink");

	if (_fShutDown)
		return CONNECT_E_NOCONNECTION;

	if (_fMosueSink == 0)
		return	CONNECT_E_NOCONNECTION;

	Assert(_pSinkList);

	CTFMOUSETRAP	*pSink = _pSinkList;
	CTFMOUSETRAP	*pSinkParent = NULL;

	while (pSink->dwCookie != dwCookie)		// Find the cookie
	{
		pSinkParent = pSink;
		pSink = pSink->pNext;

		if (!pSink)							// Reach list bottom?
			return CONNECT_E_NOCONNECTION;	//	cookie not found
	}
	
	Assert(pSink->pMouseSink);
	if (pSink->pMouseSink)
		pSink->pMouseSink->Release();

	if (pSink == _pSinkList)				// Match the first link?
	{
		if (pSink->pNext)
			_pSinkList = pSink->pNext;
		else
		{
			_fMosueSink = 0;				// No more mouse trap left
			memset(_pSinkList, 0, sizeof(CTFMOUSETRAP));
		}
	}
	else
	{										// Match link other than the first link
		Assert(pSinkParent);
		pSinkParent->pNext = pSink->pNext;
		delete pSink;
	}

	return S_OK;
}
	
/*
 *	STDMETHODIMP CUIM::Init()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::Init()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Init");

	HRESULT hResult;
	
	// Init some CUIM data
	_cCallMgrLevels = 1;
	_fAllowUIMLock = 1;

	hResult = _pTextMsgFilter->_pTim->CreateDocumentMgr(&_pdim);

	if (FAILED(hResult))
		goto ExitError;

	hResult = _pdim->CreateContext(_pTextMsgFilter->_tid, 0, (ITextStoreACP *)this, &_pic, &_editCookie);
	if (FAILED(hResult))
		goto ExitError;

	hResult = _pdim->Push(_pic);
	if (FAILED(hResult))
		goto ExitError;

	// Get the interface for rendering markup
	if (_pic->QueryInterface(IID_ITfContextRenderingMarkup, (void **)&_pContextRenderingMarkup) != S_OK)
		_pContextRenderingMarkup = NULL;

	_pDAM = NULL;
	_pCategoryMgr = NULL;

	hResult = CoCreateInstance(CLSID_TF_DisplayAttributeMgr, NULL, CLSCTX_INPROC_SERVER, 
		IID_ITfDisplayAttributeMgr, (void**)&(_pDAM));

	hResult = CoCreateInstance(CLSID_TF_CategoryMgr, NULL, CLSCTX_INPROC_SERVER, 
		IID_ITfCategoryMgr, (void**)&_pCategoryMgr);

	_pTextEditSink = new CTextEditSink(EndEditCallback, this);

	if (_pTextEditSink)
	{
		if (FAILED(_pTextEditSink->_Advise(_pic)))
		{
			delete _pTextEditSink;
			_pTextEditSink = NULL;
		}
	}

	LRESULT lresult;
	_pTextMsgFilter->_pTextService->TxSendMessage(EM_SETUPNOTIFY, 1, (LPARAM)(ITxNotify *)this, &lresult);
	
	_fAllowUIMLock = 0;

	return S_OK;

ExitError:
	Uninit();
	return hResult;
}

/*
 *	void CUIM::Uninit()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::Uninit()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Uninit");

	if (_pTextFont)
	{
		_pTextFont->Release();
		_pTextFont = NULL;
	}

	if (_parITfEnumRange)
	{
		int idx = _parITfEnumRange->Count();

		for ( ; idx > 0; idx--)
		{
			IEnumTfRanges **ppEnumRange = (IEnumTfRanges **)(_parITfEnumRange->Elem(idx-1));
			if (ppEnumRange && *ppEnumRange)
				(*ppEnumRange)->Release();
		}

		_parITfEnumRange->Clear(AF_DELETEMEM);
		delete _parITfEnumRange;
		_parITfEnumRange = NULL;
	}

	if (_parAttrsVal)
	{
		InitAttrVarArray(FALSE);
		FreePv (_parAttrsVal);
		_parAttrsVal = NULL;
	}

	if (_pSinkList)
	{
		CTFMOUSETRAP	*pSink = _pSinkList;

		_pSinkList = NULL;

		// Delete the Mouse sinks list
		while (1)
		{
			CTFMOUSETRAP	*pNext = pSink->pNext;

			if(pSink->pMouseSink)
				pSink->pMouseSink->Release();

			delete pSink;

			if (!pNext)		// Any more?
				break;		//	Done.

			pSink = pNext;
		}
	}

	if (_pContextRenderingMarkup)
	{
		_pContextRenderingMarkup->Release();
		_pContextRenderingMarkup = NULL;
	}

	if (_pDAM)
	{
		_pDAM->Release();
		_pDAM = NULL;
	}

	if (_pCategoryMgr)
	{
		_pCategoryMgr->Release();
		_pCategoryMgr = NULL;
	}

	if (_pTextEditSink)
	{
		_pTextEditSink->_Unadvise();
		delete _pTextEditSink;
		_pTextEditSink = NULL;
	}

	if (_pdim && _pic)
		_pdim->Pop(TF_POPF_ALL);

	if (_pic)
	{
		_pic->Release();
		_pic = NULL;
	}

	if (_pdim)
	{
		_pdim->Release();
		_pdim = NULL;
	}

	if (_pacrUl)
	{
		_pacrUl->Clear(AF_DELETEMEM);
		delete _pacrUl;
		_pacrUl = NULL;
	}
}

/*
 *	void CreateUIM()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
BOOL CreateUIM(CTextMsgFilter *pTextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CreateUIM");

	BOOL	fCreateUIM = FALSE;

	HRESULT hResult = CoCreateInstance(CLSID_TF_ThreadMgr, NULL, CLSCTX_INPROC_SERVER, 
		IID_ITfThreadMgr, (void**)&(pTextMsgFilter->_pTim));


	if (hResult == S_OK)
	{	
		// ready to start interacting
		if (pTextMsgFilter->_pTim->Activate(&(pTextMsgFilter->_tid)) == S_OK)
		{
			pTextMsgFilter->_pCUIM = new CUIM(pTextMsgFilter);

			if (pTextMsgFilter->_pCUIM)
			{
				hResult = pTextMsgFilter->_pCUIM->Init();
				if (hResult == S_OK)               
					fCreateUIM = TRUE;
				else
				{
					delete pTextMsgFilter->_pCUIM;
					pTextMsgFilter->_pCUIM = NULL;									
				}
			}
		}

		if (!fCreateUIM)
		{
			pTextMsgFilter->_pTim->Release();
			pTextMsgFilter->_pTim = NULL;
		}
		else if (GetFocus() == pTextMsgFilter->_hwnd)
			pTextMsgFilter->_pCUIM->OnSetFocus();
	}
	return fCreateUIM;
}

/*
 *	BOOL CUIM::GetExtentAcpPrange()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
BOOL CUIM::GetExtentAcpPrange(
	ITfRange *ITfRangeIn, 
	long &cpFirst,
	long &cpLim)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetExtentAcpPrange");

	ITfRangeACP *prangeACP = NULL;
	if (SUCCEEDED(ITfRangeIn->QueryInterface(IID_ITfRangeACP, (void **)&prangeACP)))
	{
		prangeACP->GetExtent(&cpFirst, &cpLim);
		
		prangeACP->Release();
	
		return TRUE;
	}

	return FALSE;
}

/*
 *	HRESULT CUIM::EndEditCallback()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CUIM::EndEditCallback(ITfEditRecord *pEditRecord, void *pv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::EndEditCallback");

	HRESULT hr;
	CUIM	*_this = (CUIM *)pv;
	IEnumTfRanges *pEnumRanges;
	const GUID *rgGUID[1];

	if (!(_this->_fWriteLockOn))
	{
		_this->HandleTempDispAttr(pEditRecord);
		return S_OK;
	}

	// Get lid changes
	rgGUID[0] = &GUID_PROP_LANGID;
	hr = pEditRecord->GetTextAndPropertyUpdates(0, (const GUID**)rgGUID, 1, &pEnumRanges);
	if (SUCCEEDED(hr))
	{
		_this->HandleLangID (pEnumRanges);
		pEnumRanges->Release();
	}

	// Get attribute changes
	rgGUID[0] = &GUID_PROP_ATTRIBUTE;
	hr = pEditRecord->GetTextAndPropertyUpdates(0, (const GUID**)rgGUID, 1, &pEnumRanges);
	if (SUCCEEDED(hr))
	{
		_this->HandlePropAttrib (pEnumRanges);
		pEnumRanges->Release();
	}

	rgGUID[0] = &GUID_PROP_COMPOSING;
	hr = pEditRecord->GetTextAndPropertyUpdates(0, (const GUID**)rgGUID, 1, &pEnumRanges);
	if (SUCCEEDED(hr))
	{
		// Save the TextDelta to be process after the lock is off
		if (!(_this->_parITfEnumRange))
			_this->_parITfEnumRange = new CITfEnumRange();

		if (_this->_parITfEnumRange)
		{
			LONG				idxItem;
			IEnumTfRanges		**ppItem;
			ppItem = _this->_parITfEnumRange->Add(1, &idxItem);
			if (ppItem)
				*ppItem = pEnumRanges;
			else						
				pEnumRanges->Release();			// Add fail, forget it
		}
	}

	return S_OK;
}

/*
 *	void CUIM::HandleDispAttr(*pITfRangeProp, var, cp, cch)
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::HandleDispAttr(
	ITfRange *pITfRangeProp, 
	VARIANT  &var,
	long	 acpStartRange,
	long	 cch)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleDispAttr");

	HRESULT hResult = TRUE;

	if (pITfRangeProp)
		hResult = GetExtentAcpPrange(pITfRangeProp, acpStartRange, cch);

	if (hResult && cch > 0)
	{
		ITextRange *pTextRange = NULL;
		hResult = _pTextMsgFilter->_pTextDoc->Range(acpStartRange, acpStartRange+cch, &pTextRange);
		if (pTextRange)
		{
			ITextFont	*pFont = NULL;

			if (_pTextFont)
				_pTextFont->GetDuplicate(&pFont);

			if (pFont)
			{
				if (var.vt == VT_I4)
				{
					GUID guid;
					ITfDisplayAttributeInfo *pDAI = NULL;
					TF_DISPLAYATTRIBUTE da;

					if (_pCategoryMgr->GetGUID(var.ulVal, &guid) == S_OK &&
						SUCCEEDED(_pDAM->GetDisplayAttributeInfo(guid, &pDAI, NULL)))
					{
						COLORREF	cr;
						long		lUnderline;
						long		idx = 0;

						Assert(pDAI);
						pDAI->GetAttributeInfo(&da);

						if (GetUIMAttributeColor(&da.crText, &cr))
							pFont->SetForeColor(cr);

						if (GetUIMAttributeColor(&da.crBk, &cr))
							pFont->SetBackColor(cr);

						lUnderline = GetUIMUnderline(da, idx, cr);
						if (lUnderline != tomNone)
						{
							if (idx)
							{
								hResult = _pTextMsgFilter->_pTextDoc->SetEffectColor(idx, cr);
								if (hResult == S_OK)
									lUnderline += (idx << 8);
							}
							pFont->SetUnderline(lUnderline);
						}
					}
					if (pDAI)
						pDAI->Release();
				}
				pTextRange->SetFont(pFont);
				pFont->Release();
			}
			pTextRange->Release();
		}
	}
}

/*
 *	HRESULT CUIM::HandlePropAttrib(ITfEnumTextDeltas *pEnumTextDeltas)
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CUIM::HandlePropAttrib(IEnumTfRanges *pEnumRanges)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandlePropAttrib");

	ITfRange	*pITfRange = NULL;

	if (!_pDAM || !_pCategoryMgr || _fInterimChar)
		return S_OK;
		
	ITfProperty		*pProp = NULL;
	HRESULT			hResult = _pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp);

	if (SUCCEEDED(hResult))
	{
		long	lCount;
		TS_SELECTION_ACP acpSelection;
		ULONG	cFetched;

		GetSelection(0, 0, &acpSelection, &cFetched);

		_pTextMsgFilter->_pTextDoc->Freeze(&lCount);				// Turn off display
		while (pEnumRanges->Next(1, &pITfRange, NULL) == S_OK)
		{
			BOOL			fAnyPropRange = FALSE;
			IEnumTfRanges	*pEnumPropRange = NULL;
			long			acpRangeStart, ccpRangeStart;
			VARIANT			var;

			GetExtentAcpPrange(pITfRange, acpRangeStart, ccpRangeStart);
			
			// Create a property Enum for ranges within pITfRange
			if (pProp->EnumRanges(_editCookie, &pEnumPropRange, pITfRange) == S_OK)
			{
				ITfRange	*pITfRangeProp = NULL;

				while (pEnumPropRange->Next(1, &pITfRangeProp, NULL) == S_OK)
				{
					VariantInit(&var);
					if (!fAnyPropRange)
					{
						long	acpCurrentRange, ccpCurrent;

						if (GetExtentAcpPrange(pITfRangeProp, acpCurrentRange, ccpCurrent))
						{
							if (acpCurrentRange > acpRangeStart)
								HandleDispAttr(NULL, var, acpRangeStart, acpCurrentRange - acpRangeStart);
						}
						fAnyPropRange = TRUE;
					}

					pProp->GetValue(_editCookie, pITfRangeProp, &var);
					HandleDispAttr(pITfRangeProp, var);

					VariantClear(&var);
					pITfRangeProp->Release();
				}
				pEnumPropRange->Release();
			}

			if (!fAnyPropRange)
			{
				// Whole string doesn't contain any disp. attribute.
				VariantInit(&var);
				HandleDispAttr(pITfRange, var);
			}

			pITfRange->Release();
		}
		pProp->Release();

		// Only want to scroll back if its not a selection
		if (acpSelection.acpStart == acpSelection.acpEnd)
		{
			ITextRange *pTextRange;

			hResult = _pTextMsgFilter->_pTextDoc->Range(acpSelection.acpStart, acpSelection.acpEnd, &pTextRange);
			if (pTextRange)
			{
				pTextRange->Select();
				pTextRange->Release();
			}
		}
		_pTextMsgFilter->_pTextDoc->Unfreeze(&lCount);				// Turn on display
	}

	return S_OK;
}

/*
 *	void CUIM::GetUIMUnderline()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *	
 */
long CUIM::GetUIMUnderline(
	TF_DISPLAYATTRIBUTE &da, 
	long &idx, 
	COLORREF &cr)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetUIMUnderline");

	long lStyle = tomNone;

	idx = 0;

	if (da.lsStyle != TF_LS_NONE)
	{							
		switch(da.lsStyle)
		{
			// case TFLS_SOLID:
			default:
				lStyle = da.fBoldLine ? tomThick : tomSingle;
				break;

			case TF_LS_DOT:
			case TF_LS_DASH:		// Dash line should show as dotted line
				lStyle = tomDotted;
				break;

			case TF_LS_SQUIGGLE:
				lStyle = tomWave;
				break;
		}

		if (GetUIMAttributeColor(&da.crLine, &cr))
		{
			if (!_pacrUl)				// Create the array if it is not there
				_pacrUl = new CUlColorArray(); 

			if (_pacrUl)
			{
				LONG		idxMax = _pacrUl->Count();
				LONG		idxItem;
				COLORREF	*pCr;

				// Check if this item is in the array
				for (idxItem=0; idxItem < idxMax; idxItem++)
				{
					pCr = _pacrUl->Elem(idxItem);
					Assert(pCr);
					if (*pCr == cr)
						idx = idxItem + 1;		// found it
				}

				if (!idx)
				{
					// Add it to array
					pCr = _pacrUl->Add(1, &idxItem);

					if (pCr)
					{
						*pCr = cr;
						idx = idxItem + 1;			// return new idx
					}
				}
			}
		}
	}

	return lStyle;
}

/*
 *	void CUIM::HandleFinalString(ITfRange *pPropRange, long acpStartRange, long cch)
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::HandleFinalString(
	ITfRange *pPropRange,
	long	acpStartRange,
	long	cch,
	BOOL	fEndComposition)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleFinalString");

	HRESULT	hResult = TRUE;

	if (pPropRange)
		hResult = GetExtentAcpPrange(pPropRange, acpStartRange, cch);

	if (hResult == TRUE && cch)
	{
		if (_bstrComposition && !fEndComposition)
			return;

		ITextRange *pTextRange = NULL;
		ITextSelection	*pTextSel = NULL;
		long	cpSelMin = 0, cpSelMax = 0;
		BOOL	fTextSel = FALSE;

		// Need to maintain current selection
		hResult = _pTextMsgFilter->_pTextDoc->GetSelectionEx(&pTextSel);

		if (pTextSel)
		{
			hResult	= pTextSel->GetStart(&cpSelMin);
			hResult	= pTextSel->GetEnd(&cpSelMax);
			pTextSel->Release();
			fTextSel = TRUE;
		}

		if (_bstrComposition)
		{
			long	cpEnd;

			GetEndACP(&cpEnd);

			cch = _cchComposition + cpEnd - _cpEnd;
			acpStartRange = _acpBstrStart;
		}

		hResult = _pTextMsgFilter->_pTextDoc->Range(acpStartRange, acpStartRange+cch, &pTextRange);
		if (pTextRange)
		{
			long		cEmbeddedObjects = 0;
			BSTR		bstr = NULL;

			if (cch)
				hResult = pTextRange->GetText(&bstr);

			if (SUCCEEDED(hResult) && (bstr || cch == 0))
			{
				long	lCount;
				BSTR	bstrTemp = NULL;

				if (!_fAnyWriteOperation)		// No new string
					goto IGNORE_STRING;			//	no need to insert

				if (_bstrComposition)
				{
					if (bstr)
					{
						WCHAR *pStr1 = _bstrComposition;
						WCHAR *pStr2 = bstr;

						while (*pStr1 != 0 && *pStr1 == *pStr2)
						{
							pStr1++;
							pStr2++;
						}

						if (*pStr1 == *pStr2)		// Same data, no need to insert
						{
							if (acpStartRange == cpSelMin)
							{
								pTextRange->Collapse(tomFalse);
								pTextRange->Select();
							}
							goto IGNORE_STRING;
						}
					}

					bstrTemp = _bstrComposition;
				}

				// Build embed object data if necessary
				EMBEDOBJECT	arEmbeddObjects[5];
				EMBEDOBJECT *pEmbeddObjects = arEmbeddObjects;

				if (bstr)
					cEmbeddedObjects = 
						BuildObject(pTextRange, bstr, &pEmbeddObjects, ARRAY_SIZE(arEmbeddObjects));

				_pTextMsgFilter->_pTextDoc->Freeze(&lCount);				// Turn off display

				// We want the final text to be in the undo stack.
				// So, we first delete the final string.
				// Resume undo and add the final string back.  Yuk!
				if (bstrTemp && _cObjects)
				{
					long	cpMin;
					long	cchBstr = SysStringLen(bstrTemp);

					pTextRange->GetStart(&cpMin);
					InsertTextandObject(pTextRange, bstrTemp, _pObjects, _cObjects);
					pTextRange->SetRange(cpMin, cpMin+cchBstr);
				}
				else
					pTextRange->SetText(bstrTemp);

				if (_pTextFont)
					pTextRange->SetFont(_pTextFont);

				_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);
				_pTextMsgFilter->_pTextDoc->SetNotificationMode(tomTrue);

				if (cEmbeddedObjects == 0)
					pTextRange->SetText(bstr);
				else
				{
					InsertTextandObject(pTextRange, bstr, pEmbeddObjects, cEmbeddedObjects);
					CleanUpObjects(cEmbeddedObjects, pEmbeddObjects);
					if (pEmbeddObjects != arEmbeddObjects)
						delete pEmbeddObjects;
				}

				_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);

				// Hold notification if needed
				if (!(_pTextMsgFilter->_fIMEAlwaysNotify))
					_pTextMsgFilter->_pTextDoc->SetNotificationMode(tomFalse);

				if (fTextSel)
				{
					ITextRange *pSelRange = NULL;
					// restore previous selection.
					hResult = _pTextMsgFilter->_pTextDoc->Range(cpSelMin, cpSelMax, &pSelRange);
					if (pSelRange)
					{
						pSelRange->Select();
						pSelRange->Release();
					}
				}
				else
				{
					pTextRange->Collapse(tomFalse);
					pTextRange->Select();
				}

				_pTextMsgFilter->_pTextDoc->Unfreeze(&lCount);				// Turn on display
			}
IGNORE_STRING:
			if (bstr)
				SysFreeString(bstr);
			pTextRange->Release();
		}
	}
}

/*
 *	HRESULT CUIM::HandleFocusRange(IEnumTfRanges *pEnumRanges)
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CUIM::HandleFocusRange(IEnumTfRanges *pEnumRanges)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleFocusRange");

	ITfProperty		*pProp = NULL;	
	ITfRange		*pITfRange;
	HRESULT			hResult = _pic->GetProperty(GUID_PROP_COMPOSING, &pProp);
	BOOL			fAnyPendingFocusRange = FALSE;

	if (SUCCEEDED(hResult))
	{
		// Enumerate all the changes
		pEnumRanges->Reset();
		while (pEnumRanges->Next(1, &pITfRange, NULL) == S_OK)
		{
			BOOL			fAnyPropRange = FALSE;
			IEnumTfRanges	*pEnumPropRange = NULL;

			long			acpStartRange, ccp;

			GetExtentAcpPrange(pITfRange, acpStartRange, ccp);


			// Create a property Enum for ranges within pITfRange
			if (pProp->EnumRanges(_editCookie, &pEnumPropRange, pITfRange) == S_OK)
			{
				ITfRange	*pPropRange = NULL;

				// Try to get a value for the property
				while (pEnumPropRange->Next(1, &pPropRange, NULL) == S_OK)
				{
					VARIANT		var;

					VariantInit(&var);

					if (!fAnyPropRange)
					{
						long	acpCurrentRange, ccpCurrent;

						GetExtentAcpPrange(pPropRange, acpCurrentRange, ccpCurrent);
						if (acpCurrentRange > acpStartRange)
						{
							// We have a final string before the new string.
							HandleFinalString(NULL, acpStartRange, acpCurrentRange - acpStartRange);
						}
						fAnyPropRange = TRUE;
					}

					hResult = pProp->GetValue(_editCookie, pPropRange, &var);

					if (SUCCEEDED(hResult) && var.vt == VT_I4 && var.ulVal == 0)					
						hResult = E_FAIL;				// Just as good as not finding the range
					else
						fAnyPendingFocusRange = TRUE;

					VariantClear(&var);

					if (hResult != S_OK)
						HandleFinalString(pPropRange);

					pPropRange->Release();
				}
				pEnumPropRange->Release();
			}

			if (!fAnyPropRange)					// Any focus range?
				HandleFinalString(pITfRange);	//	No --> the whole string is final string

			if (_fEndTyping && _bstrComposition && _acpBstrStart != tomForward)
				HandleFinalString(NULL, _acpBstrStart, _cchComposition, TRUE);

			pITfRange->Release();
		}
		pProp->Release();		
	}

	return S_OK;
}

/*
 *	HRESULT CUIM::HandleLangID(IEnumTfRanges *pEnumRanges)
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CUIM::HandleLangID(IEnumTfRanges *pEnumRanges)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleLangID");

	ITfProperty		*pProp = NULL;	
	ITfRange		*pITfRange;
	HRESULT			hResult;
	LCID			lcid;

	// TODO:
	// if _pTextFont is NULL, setup _pTextFont to handle the langID.
	if (!_pTextFont)
		return S_OK;

	hResult = _pic->GetProperty(GUID_PROP_LANGID, &pProp);

	if (SUCCEEDED(hResult))
	{
		// Enumerate all the changes
		pEnumRanges->Reset();
		while (pEnumRanges->Next(1, &pITfRange, NULL) == S_OK)
		{
			IEnumTfRanges	*pEnumPropRange = NULL;

			// Create a property Enum for ranges within pITfRange
			if (pProp->EnumRanges(_editCookie, &pEnumPropRange, pITfRange) == S_OK)
			{
				ITfRange	*pPropRange = NULL;
				if (pEnumPropRange->Next(1, &pPropRange, NULL) == S_OK)
				{
					VARIANT		var;

					VariantInit(&var);

					hResult = pProp->GetValue(_editCookie, pITfRange, &var);

					if (SUCCEEDED(hResult) && var.vt == VT_I4)
					{
						lcid = (LCID)var.ulVal;

						UINT		cpgProp = CodePageFromCharRep(CharRepFromLID(lcid));
						ITextFont	*pTextFont=NULL;

						_pTextFont->GetDuplicate(&pTextFont);
						if (pTextFont)
						{
							HRESULT		hResult;
							LONG		acpStart, cchStart;
							ITextRange	*pTextRange;
							UINT		cpgTemp = _pTextMsgFilter->_uKeyBoardCodePage;

							GetExtentAcpPrange(pITfRange, acpStart, cchStart);
							if (cchStart)
							{
								_pTextMsgFilter->_uKeyBoardCodePage = cpgProp;
								CIme::CheckKeyboardFontMatching(acpStart, _pTextMsgFilter, pTextFont);
								_pTextMsgFilter->_uKeyBoardCodePage = cpgTemp;

								hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpStart+cchStart, &pTextRange);
								if (pTextRange)
								{
									pTextRange->SetFont(pTextFont);
									pTextRange->Release();
								}
							}
							pTextFont->Release();
						}
					}
					VariantClear(&var);
					pPropRange->Release();
				}
				pEnumPropRange->Release();
			}
			pITfRange->Release();
		}
		pProp->Release();
	}

	return S_OK;
}

/*
 *	HRESULT CUIM::OnSetFocus(BOOL fEnable)
 *
 *	@mfunc
 *	
 *
 */
void CUIM::OnSetFocus(BOOL fEnable)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnSetFocus");

	_pTextMsgFilter->_pTim->SetFocus(fEnable ? _pdim : NULL);
}

/*
 *	HRESULT CUIM::CompleteUIMText()
 *
 *	@mfunc
 *	
 *
 */
void CUIM::CompleteUIMText()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CompleteUIMText");

	HRESULT								hResult;
	ITfContextOwnerCompositionServices	*pCompositionServices;

	_fAllowUIMLock = 1;

	Assert(_pic);

	if (_pic->QueryInterface(IID_ITfContextOwnerCompositionServices, (void **)&pCompositionServices) == S_OK)
	{
		// passing in NULL means "all compositions"
		hResult = pCompositionServices->TerminateComposition(NULL);
		pCompositionServices->Release();
	}

	_fAllowUIMLock = 0;

}

/*
 *	BOOL CUIM::GetUIMAttributeColor()
 *
 *	@mfunc
 *		Helper routine to get UIM color
 *
 *	@rdesc
 *		TRUE if we setup input pcr with the UIM color 
 *
 */
BOOL CUIM::GetUIMAttributeColor(TF_DA_COLOR *pdac, COLORREF *pcr)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetUIMAttributeColor");

	BOOL	fRetCode = FALSE;
	switch (pdac->type)
	{
		//case TFCT_NONE:
		//	return FALSE;

		case TF_CT_SYSCOLOR:
			*pcr = GetSysColor(pdac->nIndex);
			fRetCode = TRUE;
			break;

		case TF_CT_COLORREF:
			*pcr = pdac->cr;
			fRetCode = TRUE;
			break;
	}
	return fRetCode;    
}

/*
 *	void CUIM::OnUIMTypingDone()
 *
 *	@mfunc
 *		Helper routine to cleanup after UIM Typing is done
 *
 */
void CUIM::OnUIMTypingDone()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnUIMTypingDone");

	if (_pTextFont)
	{
		_pTextFont->Release();
		_pTextFont = NULL;
	}

	CleanUpComposition();

	// Reset Korean block caret if needed
	if (_fInterimChar)
	{
		_fInterimChar = 0;
		_pTextMsgFilter->_pTextDoc->SetCaretType(tomNormalCaret);		// Reset Block caret mode
	}

	_fAnyWriteOperation = 0;
	_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);
	_pTextMsgFilter->_pTextDoc->SetNotificationMode(tomTrue);

	if (_pacrUl)
		_pacrUl->Clear(AF_DELETEMEM);
};

/*
 *	BOOL CUIM::GetGUIDATOMFromGUID()
 *
 *	@mfunc
 *		Helper routine to get GUIDATOM from UIM
 *
 */
BOOL CUIM::GetGUIDATOMFromGUID(
	REFGUID rguid, 
	TfGuidAtom *pguidatom)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetGUIDATOMFromGUID");

	if (_pCategoryMgr && _pCategoryMgr->RegisterGUID(rguid, pguidatom) == S_OK)
		return TRUE;

	return FALSE;
}
/*
 *	BOOL CUIM::GetAttrs()
 *
 *	@mfunc
 *		Helper routine to get Attr
 *
 */
HRESULT CUIM::GetAttrs(
	LONG acpPos,
	ULONG cFilterAttrs,
	const TS_ATTRID *paFilterAttrs, 
	BOOL fGetDefault)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetAttrs");

	HRESULT		hResult;
	ITextFont	*pTextFont = NULL;
	ITextPara	*pTextPara = NULL;
	int			idx;
	BOOL		fRequestedAll = FALSE;
	int			idxAttr;
	TS_ATTRVAL	*pAttrVal;
	ITextRange	*pTextRange = NULL;	

	if (cFilterAttrs == 0)
	{
		fRequestedAll = TRUE;
		cFilterAttrs = MAX_ATTR_SUPPORT;
	}

	InitAttrVarArray();

	if (!_parAttrsVal)
		return E_OUTOFMEMORY;

	if (fGetDefault)
	{
		// Get document defaults font and para
		hResult = _pTextMsgFilter->_pTextDoc->GetDocumentFont(&pTextFont);
		if (FAILED(hResult))
			goto EXIT;
		
		hResult = _pTextMsgFilter->_pTextDoc->GetDocumentPara(&pTextPara);
		if (FAILED(hResult))
			goto EXIT;
	}
	else
	{
		hResult = _pTextMsgFilter->_pTextDoc->Range(acpPos, acpPos, &pTextRange);
		if (FAILED(hResult))
			goto EXIT;

		hResult = pTextRange->GetFont(&pTextFont);
		hResult = pTextRange->GetPara(&pTextPara);
	}

	pAttrVal = _parAttrsVal;
	for (idx = 0; idx < (int)cFilterAttrs; idx++, paFilterAttrs++)
	{
		if (fRequestedAll)
			idxAttr = idx;
		else
			idxAttr = FindGUID(*paFilterAttrs);

		if (idxAttr >= 0)
		{
			if (PackAttrData(idxAttr, pTextFont, pTextPara, pAttrVal))
			{
				_uAttrsValTotal++;
				pAttrVal++;
				
				if (_uAttrsValTotal == MAX_ATTR_SUPPORT)
					break;
			}
		}
	}
	hResult = S_OK;

EXIT:
	if (pTextFont)
		pTextFont->Release();	

	if (pTextPara)
		pTextPara->Release();

	if (pTextRange)
		pTextRange->Release();

	return hResult;
}
/*
 *	int CUIM::FindGUID
 *
 *	@mfunc
 *		Helper routine to check if we supported the requested Attribute GUID
 *
 */
int CUIM::FindGUID(REFGUID guid)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::FindGUID");

	ULONG i;

	for (i=0; i < MAX_ATTR_SUPPORT; i++)
	{
		if (IsEqualIID(*(_arTSAttridSupported[i]), guid))
			return i;
	}

	// not found
	return -1;
}

/*
 *	int CUIM::PackAttrData
 *
 *	@mfunc
 *		Helper routine to fill in data for the given Attrib index
 *
 */
BOOL CUIM::PackAttrData(
	LONG		idx,
	ITextFont	*pITextFont,
	ITextPara	*pITextPara,
	TS_ATTRVAL	*pAttrVal)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::PackAttrData");

	long	lValue;
	float	x;
	BSTR	bstrName;
	HRESULT	hResult;
	const	GUID	*pGUID;
	TfGuidAtom	guidatom;


	if (idx < 0 || idx >= MAX_ATTR_SUPPORT)
		return FALSE;

	if (!pITextFont && idx <= iattrSuperscript)
		return FALSE;

	if (!pITextPara && idx == iattrRTL)
		return FALSE;

	pAttrVal->varValue.vt = VT_BOOL;
	memcpy(&pAttrVal->idAttr, _arTSAttridSupported[idx], sizeof(TS_ATTRID));


	switch(idx)
	{
		case iattrFacename:
			hResult = pITextFont->GetName(&bstrName);
			pAttrVal->varValue.vt = VT_BSTR;
			pAttrVal->varValue.bstrVal = bstrName;				
			break;

		case iattrSize:
			x = 0.0;
			hResult = pITextFont->GetSize(&x);
			lValue = (long)x;
			pAttrVal->varValue.vt = VT_I4;
			pAttrVal->varValue.lVal = x;
			break;

		case iattrColor:
			hResult = pITextFont->GetForeColor(&lValue);
			pAttrVal->varValue.vt = VT_I4;
			pAttrVal->varValue.lVal = lValue;			// TODO: check for tomAutocolor
			break;

		case iattrBold:
			hResult = pITextFont->GetBold(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomTrue ? tomTrue : VARIANT_FALSE;				
			break;

		case iattrItalic:
			hResult = pITextFont->GetItalic(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomTrue ? tomTrue : VARIANT_FALSE;				
			break;

		case iattrUnderline:
			hResult = pITextFont->GetUnderline(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomNone ? VARIANT_FALSE : tomTrue;
			break;

		case iattrSubscript:
			hResult = pITextFont->GetSubscript(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomTrue ? tomTrue : VARIANT_FALSE;
			break;

		case iattrSuperscript:
			hResult = pITextFont->GetSuperscript(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomTrue ? tomTrue : VARIANT_FALSE;
			break;

		case iattrRTL:
			{
				LRESULT lres = 0;
				_pTextMsgFilter->_pTextService->TxSendMessage(
					EM_GETPARATXTFLOW, 0, (LPARAM)pITextPara, &lres);
				pAttrVal->varValue.boolVal = lres ? tomTrue : VARIANT_FALSE;
			}
			break;

		case iattrVertical:
			BOOL fAtFont;
			_pTextMsgFilter->_pTextDoc->GetFEFlags(&lValue);
			fAtFont = lValue & tomUseAtFont;
			lValue &= tomTextFlowMask;
			pAttrVal->varValue.boolVal = (fAtFont && lValue == tomTextFlowSW) ? tomTrue : VARIANT_FALSE;
			break;

		case iattrBias:
			pGUID = &GUID_MODEBIAS_NONE;
			if (IN_RANGE(CTFMODEBIAS_DEFAULT, _pTextMsgFilter->_wUIMModeBias, CTFMODEBIAS_HALFWIDTHALPHANUMERIC))		
				pGUID = _arModeBiasSupported[_pTextMsgFilter->_wUIMModeBias];

			if (!GetGUIDATOMFromGUID(*pGUID, &guidatom))
				guidatom = TF_INVALID_GUIDATOM;

			pAttrVal->varValue.vt = VT_I4;
			pAttrVal->varValue.lVal = guidatom;
			break;

		case iattrTxtOrient:
			// Get Text flow and setup the text rotation
			_pTextMsgFilter->_pTextDoc->GetFEFlags(&lValue);
			lValue &= tomTextFlowMask;
			pAttrVal->varValue.vt = VT_I4;
			pAttrVal->varValue.lVal = 0;
			if (lValue == tomTextFlowSW)
				pAttrVal->varValue.lVal = 2700;
			else if (lValue == tomTextFlowNE)
				pAttrVal->varValue.lVal = 900;

			break;
	}

	return TRUE;
}

/*
 *	STDMETHODIMP CUIM::GetStoryLength
 *
 *	@mfunc
 *		Helper routine to check the attribute filters
 *
 */
STDMETHODIMP CUIM::GetStoryLength(LONG *pacp)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetStoryLength");

	ITextRange	*pTextRange = NULL;

	HRESULT hResult = _pTextMsgFilter->_pTextDoc->Range(0, 0, &pTextRange);
	if (hResult == S_OK && pTextRange)
	{
		long	Count;

		hResult = pTextRange->GetStoryLength(&Count);

		if (hResult == S_OK)
			*pacp = Count;

		pTextRange->Release();
	}
	return hResult;
}

/*
 *	void CUIM::InitAttrVarArray
 *
 *	@mfunc
 *		Helper routine to setup AttrVar Array
 *
 */
void CUIM::InitAttrVarArray(BOOL fAllocData)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InitAttrVarArray");

	if (_parAttrsVal)
	{
		USHORT		uIdx;
		TS_ATTRVAL	*pAttrVal = _parAttrsVal;

		for (uIdx = 0; uIdx < _uAttrsValTotal; uIdx++, pAttrVal++)
			VariantClear(&(pAttrVal->varValue));
					
		memset(_parAttrsVal, 0, _uAttrsValTotal * sizeof(TS_ATTRVAL));

	}
	else if (fAllocData)
	{
		_parAttrsVal= (TS_ATTRVAL *)PvAlloc(sizeof(TS_ATTRVAL) * MAX_ATTR_SUPPORT, GMEM_ZEROINIT);
		Assert(_parAttrsVal);
	}
	_uAttrsValCurrent = 0;
	_uAttrsValTotal = 0;
}

/*
 *	HRESULT CUIM::MouseCheck(UINT *pmsg, WPARAM *pwparam, LPARAM *plparam, LRESULT *plres)
 *
 *	@mfunc
 *		Perform UIM mouse check
 *
 *	@rdesc
 *		int		S_OK	if handled
 *				S_FALSE Don't handle and should be ignored
 *
 */
HRESULT CUIM::MouseCheck(
	UINT *pmsg,
	WPARAM *pwparam,
	LPARAM *plparam,
	LRESULT *plres)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::MouseCheck");

	BOOL fRetCode = FALSE;

	if (_fShutDown)
		return S_FALSE;

	if (_fMosueSink)
	{
		BOOL			fTerminateIME;
		long			cpCusor = -1;
		CTFMOUSETRAP	*pSinkList = _pSinkList;

		Assert(_pSinkList);

		_fAllowUIMLock = 1;

		// Get thru the list until one of the traps has handled the message
		while(fRetCode == FALSE && pSinkList)
		{
			if (cpCusor == -1 || pSinkList->cpMouseStart < cpCusor &&
				cpCusor <= pSinkList->cpMouseStart + pSinkList->cchMosueComp)	// Within composition range?
			{
				fRetCode = _pTextMsgFilter->MouseOperation(*pmsg, pSinkList->cpMouseStart,
						pSinkList->cchMosueComp, *pwparam, &(pSinkList->wParamBefore), &fTerminateIME, 
						NULL, &cpCusor, pSinkList->pMouseSink);
			}

			pSinkList = pSinkList->pNext;
		}

		_fAllowUIMLock = 0;
		if ( !fRetCode && IsUIMTyping() && WM_MOUSEMOVE != *pmsg )
			_pTextMsgFilter->CompleteUIMTyping(CIme::TERMINATE_NORMAL);
	}
	return fRetCode ? S_OK : S_FALSE;
}

/*
 *	HRESULT CUIM::Reconverse
 *
 *	@mfunc
 *		Perform UIM reconversion
 *
 *	@rdesc
 *		int		S_OK	if handled
 *				S_FALSE Don't handle and should be ignored
 *				-1		Don't handle and try IME reconverse
 *
 */
int CUIM::Reconverse()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Reconverse");

	HRESULT					hResult;
	ITfRange				*pITfRange = NULL;
	ITfFnReconversion		*pITfReconverse = NULL;
	ITfFunctionProvider		*pITfFctProvider = NULL;
	TF_SELECTION			TFSel = {0};
	ULONG					cSel;
	int						retCode = -1;
	int						fConvertible = FALSE;

	if (_fUIMTyping)
		return S_FALSE;

	_fAllowUIMLock = 1;
	_fHoldCTFSelChangeNotify = 1;

	hResult = _pTextMsgFilter->_pTim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, &pITfFctProvider);
	if (SUCCEEDED(hResult))
	{
		hResult = pITfFctProvider->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)&pITfReconverse);
		pITfFctProvider->Release();

		if (SUCCEEDED(hResult))
		{
			int fCurrentLock = _fReadLockOn;

			if (!fCurrentLock)
				_fReadLockOn = 1;	// Setup internal read lock

			hResult = _pic->GetSelection(_editCookie, 0, 1, &TFSel, &cSel);

			if (!fCurrentLock)
				_fReadLockOn = 0;	// Clear internal read lock

			if (hResult == S_OK && cSel == 1)
			{
				if (pITfReconverse->QueryRange(TFSel.range, &pITfRange, &fConvertible) == S_OK && fConvertible)
				{
					pITfReconverse->Reconvert(pITfRange);
					retCode = S_OK;
				}
			}
		}
	}

	if (TFSel.range)
		TFSel.range->Release();

	if (pITfRange)
		pITfRange->Release();

	if (pITfReconverse)
		pITfReconverse->Release();

	_fAllowUIMLock = 0;

	return retCode;
}

/*
 *	HRESULT CUIM::FindHiddenText
 *
 *	@mfunc
 *		Find Hidden text and return the end of the range
 *
 *	@rdesc
 *
 */
HRESULT CUIM::FindHiddenText(
	long cp, 
	long cpEnd, 
	long &cpRange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::FindHiddenText");

	HRESULT		hResult;
	long		unitMoved;
	ITextRange	*pTextRange = NULL;

	cpRange = cp;
	if (cpRange >= cpEnd)
		return S_OK;

	hResult = _pTextMsgFilter->_pTextDoc->Range(cpRange, cpRange, &pTextRange);
	if (!SUCCEEDED(hResult))
		return hResult;

	hResult = pTextRange->EndOf(tomHidden, tomExtend, &unitMoved);
	if (SUCCEEDED(hResult))
	{
		Assert(unitMoved);
		cpRange = 0;
		hResult = pTextRange->GetEnd(&cpRange);
		Assert(cpRange);
	}
	pTextRange->Release();
	return hResult;
}

/*
 *	HRESULT CUIM::FindUnhiddenText
 *
 *	@mfunc
 *		Find Unhidden text and return the end of the range
 *
 *	@rdesc
 *
 */
HRESULT CUIM::FindUnhiddenText(
	long cp, 
	long cpEnd, 
	long &cpRange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::FindUnhiddenText");

	HRESULT		hResult;
	long		unitMoved;
	ITextRange	*pTextRange = NULL;
	ITextFont	*pTextFont = NULL;
	long		fHidden;

	cpRange = cp;
	if (cpRange >= cpEnd)
		return S_OK;

	hResult = _pTextMsgFilter->_pTextDoc->Range(cpRange, cpRange, &pTextRange);
	if (!SUCCEEDED(hResult))
		return hResult;

	Assert(pTextRange);
	while (cpRange < cpEnd)
	{
		hResult = pTextRange->MoveEnd(tomCharacter, 1, &unitMoved);
		if (!SUCCEEDED(hResult))
			break;

		if (!unitMoved)
		{
			hResult = E_FAIL;
			break;
		}

		hResult = pTextRange->GetFont(&pTextFont);
		if (!SUCCEEDED(hResult))
			break;

		Assert(pTextFont);
		pTextFont->GetHidden(&fHidden);
		pTextFont->Release();

		if (fHidden)
			break;

		hResult = pTextRange->EndOf(tomCharFormat, tomMove, &unitMoved);
		if (!SUCCEEDED(hResult))
			break;

		if (unitMoved > 0)
		{
			cpRange = 0;
			hResult = pTextRange->GetEnd(&cpRange);
			if (!SUCCEEDED(hResult))
				break;
			Assert(cpRange);
		}
		else
			cpRange = cpEnd;
	}

	pTextRange->Release();
	return hResult;
}

/*
 *	void CUIM::BuildHiddenTxtBlks
 *
 *	@mfunc
 *		Build hidden text blocks
 *
 *
 */
void CUIM::BuildHiddenTxtBlks(
	long &cpMin, 
	long &cpMax, 
	long **ppHiddenTxtBlk, 
	long &cHiddenTxtBlk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::BuildHiddenTxtBlks");

	long		cHiddenTxtBlkAlloc = 0;
	long		*pHiddenTxtBlk;
	long		cpCurrent = cpMin;
	long		cpNext;
	HRESULT		hResult;

	cHiddenTxtBlkAlloc = 20;
	pHiddenTxtBlk = (long *)PvAlloc(cHiddenTxtBlkAlloc * sizeof(long), GMEM_ZEROINIT);

	if (pHiddenTxtBlk)
	{
		pHiddenTxtBlk[0] = tomForward;
		while (cpCurrent < cpMax)
		{
			hResult = FindUnhiddenText(cpCurrent, cpMax, cpNext);
			if (!SUCCEEDED(hResult))
				break;

			if (cpNext >= cpMax)
				break;

			hResult = FindHiddenText(cpNext, cpMax, cpCurrent);
			if (!SUCCEEDED(hResult))
				break;

			Assert(cpCurrent > cpNext);

			// Save the hidden text block cp and length
			pHiddenTxtBlk[cHiddenTxtBlk] = cpNext;
			cpCurrent = min(cpCurrent, cpMax);
			pHiddenTxtBlk[cHiddenTxtBlk+1] = cpCurrent - cpNext;
			cHiddenTxtBlk += 2;
			if (cHiddenTxtBlk >= cHiddenTxtBlkAlloc)
			{
				cHiddenTxtBlkAlloc += 20;
				pHiddenTxtBlk = (long *)PvReAlloc(pHiddenTxtBlk, cHiddenTxtBlkAlloc * sizeof(long));

				if (!pHiddenTxtBlk)
					break;
			}
		}
	}
	*ppHiddenTxtBlk = pHiddenTxtBlk;
}

/*
 *	BOOL CUIM::CTFOpenStatus
 *
 *	@mfunc
 *		Get/Set current CTF open status
 *
 *	@rdesc
 *		For GetOpenStatus
 *			return 1 is Open, 0 if Close or fail
 *
 *		For SetOpenStatus
 *			return TRUE is set status without problem, FALSE if fail
 *
 */
BOOL CUIM::CTFOpenStatus(
	BOOL fGetOpenStatus,
	BOOL fOpen)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CTFOpenStatus");

	HRESULT				hr;
	VARIANT				var;
	BOOL				fRet = FALSE;
	ITfCompartment		*pComp = NULL;
	ITfCompartmentMgr	*pCompMgr = NULL;


	hr = _pTextMsgFilter->_pTim->QueryInterface(IID_ITfCompartmentMgr, (void **)&pCompMgr);

	if (SUCCEEDED(hr))
	{
		Assert(pCompMgr);

		hr = pCompMgr->GetCompartment(GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, &pComp);

		if (SUCCEEDED(hr))
		{
			Assert(pComp);

			VariantInit(&var);
			if (fGetOpenStatus)
			{
				if (pComp->GetValue(&var) == S_OK)
				{
					Assert(var.vt == VT_I4);
					fRet = var.lVal ? TRUE : FALSE ;
				}
			}
			else
			{
				var.vt = VT_I4;
				var.lVal = fOpen;
				hr = pComp->SetValue(_pTextMsgFilter->_tid, &var);
				fRet = SUCCEEDED(hr);
			}
			VariantClear(&var);
		}
	}

	if (pComp)
		pComp->Release();

	if (pCompMgr)
		pCompMgr->Release();

	return fRet;
}

/*
 *	BOOL CUIM::BuildObject
 *
 *	@mfunc
 *		Build an array of embedded objects
 *
 *	@rdesc
 *		return Number of objects in the array returned in pEmbeddObjects
 *
 */
int CUIM::BuildObject(
	ITextRange	*pTextRange, 
	BSTR		bstr, 
	EMBEDOBJECT **ppEmbeddObjects,
	int			cSize)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::BuildObject");

	long	cpMin;
	HRESULT hResult = pTextRange->GetStart(&cpMin);
	WCHAR	*pText = (WCHAR *)bstr;
	EMBEDOBJECT	*pEmbeddObjStart =  *ppEmbeddObjects;
	EMBEDOBJECT *pEmbeddObj = *ppEmbeddObjects;
	BOOL	fAllocateBuffer = FALSE;

	long	cObjects = 0;
	long	cchBstr = SysStringLen(bstr);

	if (hResult == S_OK)
	{
		for(long i = 0; i < cchBstr; i++, pText++)
		{
			if (*pText == WCH_EMBEDDING)
			{
				// Get IDataObject
				HRESULT hr;
				IDataObject *pIDataObj = NULL;
				BOOL fReadLockOld = _fReadLockOn;

				_fReadLockOn = TRUE;
				hr = GetEmbedded(cpMin+i, GUID_DCSERVICE_DATAOBJECT, IID_IDataObject, (IUnknown **)&pIDataObj);

				_fReadLockOn = fReadLockOld;
				// Store it in the memory
				if (cObjects < cSize)
				{
					pEmbeddObj->cpOffset = i;
					pEmbeddObj->pIDataObj = pIDataObj;
					pEmbeddObj++;
					cObjects++;
				}
				else
				{
					long cNewSize = cSize + 5;
					EMBEDOBJECT *pEmbeddObjTemp;
					if (fAllocateBuffer)
					{
						pEmbeddObjTemp = (EMBEDOBJECT *)PvReAlloc(pEmbeddObjStart, sizeof(EMBEDOBJECT) * cNewSize);

						if (pEmbeddObjTemp)
						{
							pEmbeddObjStart = pEmbeddObjTemp;
							pEmbeddObj = pEmbeddObjStart + cSize;
							cSize = cNewSize;
							pEmbeddObj->cpOffset = i;
							pEmbeddObj->pIDataObj = pIDataObj;
							pEmbeddObj++;
							cObjects++;
						}
						else
						{
							// Cleanup here
							pIDataObj->Release();
							break;
						}
					}
					else
					{
						fAllocateBuffer = TRUE;

						pEmbeddObjTemp = (EMBEDOBJECT *)PvAlloc(sizeof(EMBEDOBJECT) * cNewSize, GMEM_ZEROINIT);
						if (pEmbeddObjTemp)
						{
							if (cSize)
							{
								// Copy previous data to new buffer
								memcpy(pEmbeddObjTemp, pEmbeddObjStart, sizeof(EMBEDOBJECT) * cSize);
							}
							pEmbeddObjStart = pEmbeddObjTemp;
							pEmbeddObj = pEmbeddObjStart + cSize;
							cSize = cNewSize;
							pEmbeddObj->cpOffset = i;
							pEmbeddObj->pIDataObj = pIDataObj;
							pEmbeddObj++;
							cObjects++;
						}
						else
						{
							// Cleanup here
							pIDataObj->Release();
							break;
						}
					}
				}
			}
		}
	}

	*ppEmbeddObjects = pEmbeddObjStart;

	return cObjects;
}

/*
 *	BOOL CUIM::InsertTextandObject
 *
 *	@mfunc
 *		Insert text and embedded objects
 *
 */
void CUIM::InsertTextandObject(
	ITextRange	*pTextRange, 
	BSTR		bstr, 
	EMBEDOBJECT *pEmbeddObjects, 
	long		cEmbeddedObjects)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertTextandObject");

	WCHAR	*pText = (WCHAR *)bstr;
	WCHAR	*pTextStart = pText;
	long	cObjects = 0;
	long	cchBstr = SysStringLen(bstr);
	HRESULT hr;

	for(long i = 0; i < cchBstr; i++, pText++)
	{
		if (*pText == WCH_EMBEDDING)
		{
			// Insert Text if necessary
			if (pTextStart != pText)
			{
				BSTR	bstr = SysAllocStringLen(pTextStart, pText-pTextStart);

				if (bstr)
				{
					hr = pTextRange->SetText(bstr);

					SysFreeString(bstr);
					pTextRange->Collapse(tomFalse);
				}
			}

			if (cObjects < cEmbeddedObjects)
			{
				LRESULT				lresult;
				long	cpMin = 0, cpMax = 0;
				HRESULT	hResult	= pTextRange->GetStart(&cpMin);
				hResult	= pTextRange->GetEnd(&cpMax);
				CHARRANGE	charRange = {cpMin, cpMax};

				hr = _pTextMsgFilter->_pTextService->TxSendMessage(EM_INSERTOBJ, (WPARAM)&charRange,
					(LPARAM)(pEmbeddObjects->pIDataObj), &lresult);

				hr = pTextRange->Move(tomCharacter, 1, NULL);	// move over the embedded char
				cObjects++;
				pEmbeddObjects++;
			}

			// Setup for next string after the embedded object
			pTextStart = pText + 1;
		}
	}

	// Insert last Text if necessary
	if (pTextStart != pText)
	{
		BSTR	bstr = SysAllocStringLen(pTextStart, pText-pTextStart);

		if (bstr)
		{
			hr = pTextRange->SetText(bstr);
			SysFreeString(bstr);
		}
	}
}

/*
 *	BOOL CUIM::CleanUpObjects
 *
 *	@mfunc
 *		Free the objects
 *
 */
void CUIM::CleanUpObjects(
	long cObjects,
	EMBEDOBJECT *pObjects)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CleanUpObjects");

	for (long i = 0; i < cObjects; i++, pObjects++)
	{
		if (pObjects->pIDataObj)
			pObjects->pIDataObj->Release();
	}
}

/*
 *	void CUIM::CleanUpComposition
 *
 *	@mfunc
 *		Free the composition string and objects list
 *
 */
void CUIM::CleanUpComposition()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CleanUpComposition");

	if (_bstrComposition)
	{
		SysFreeString (_bstrComposition);
		_bstrComposition = NULL;
	}

	_acpBstrStart = tomForward;
	if (_cObjects)
	{
		CleanUpObjects(_cObjects, _pObjects);
		delete _pObjects;
		_cObjects = 0;
		_pObjects = NULL;
	}
}

/*
 *	BOOL CUIM::HandleTempDispAttr
 *
 *	@mfunc
 *		This routine handle temp. display attribute that are set
 *	outside CTF composition.  It is using ITfContextRenderingMarkup
 *	to get the range and display data.
 *
 */
void CUIM::HandleTempDispAttr(
	ITfEditRecord *pEditRecord)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleTempDispAttr");

	if (_pContextRenderingMarkup)
	{
		HRESULT hr;
		const GUID *rgGUID[1];
		IEnumTfRanges *pEnumRanges = NULL;

		// Get attribute changes
		rgGUID[0] = &GUID_PROP_ATTRIBUTE;
		hr = pEditRecord->GetTextAndPropertyUpdates(0, (const GUID**)rgGUID, 1, &pEnumRanges);
		if (SUCCEEDED(hr))
		{
			ITfRange	*pITfRange = NULL;

			while (pEnumRanges->Next(1, &pITfRange, NULL) == S_OK)
			{
				IEnumTfRenderingMarkup *pEnumMarkup;
				TF_RENDERINGMARKUP tfRenderingMarkup;
				long acpStartRange, cch;

				if (_pContextRenderingMarkup->GetRenderingMarkup(_editCookie, TF_GRM_INCLUDE_PROPERTY, pITfRange, &pEnumMarkup) == S_OK)
				{
					while (pEnumMarkup->Next(1, &tfRenderingMarkup, NULL) == S_OK)
					{
						HRESULT hResult;

						hResult = GetExtentAcpPrange(tfRenderingMarkup.pRange, acpStartRange, cch);
						if (hResult && cch > 0)
						{
							ITextRange *pTextRange = NULL;
							hResult = _pTextMsgFilter->_pTextDoc->Range(acpStartRange, acpStartRange+cch, &pTextRange);
							if (pTextRange)
							{
								ITextFont	*pFont = NULL;

								hResult = pTextRange->GetFont(&pFont);

								if (pFont)
								{
									long		lStyle;
									COLORREF	cr;

									_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);

									TF_DISPLAYATTRIBUTE da = tfRenderingMarkup.tfDisplayAttr;

									pFont->Reset(tomApplyTmp);

									switch (da.lsStyle)
									{
										// case TFLS_SOLID:
										default:
											lStyle = da.fBoldLine ? tomThick : tomSingle;
											break;

										case TF_LS_DOT:
										case TF_LS_DASH:		// Dash line should show as dotted line
											lStyle = tomDotted;
											break;

										case TF_LS_SQUIGGLE:
											lStyle = tomWave;
											break;

										case TF_LS_NONE:
											lStyle = tomNone;
											break;
									}
									if (lStyle != tomNone)
									{
										pFont->SetUnderline(lStyle);

										if (GetUIMAttributeColor(&da.crLine, &cr))
											pFont->SetUnderline(cr | 0x0FF000000);
									}

									if (GetUIMAttributeColor(&da.crText, &cr))
										pFont->SetForeColor(cr);

									if (GetUIMAttributeColor(&da.crBk, &cr))
										pFont->SetBackColor(cr);

									pFont->Reset(tomApplyNow);
									pFont->Release();

									_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);
								}
								pTextRange->Release();
							}
						}
					}
					pEnumMarkup->Release();
				}
				pITfRange->Release();
			}
		}

		if (pEnumRanges)
			pEnumRanges->Release();
	}
}

/*
 *	STDAPI	CUIM::QueryService(REFGUID guidService, REFIID riid, void **ppv)
 *
 *	@mfunc
 *		Handle ITfEnableService::QueryService. Cicero/tip call this interface to obtain
 *	IID_ITfEnableService i/f
 *
 *	@rdesc
 *		S_OK if service supported
 *
 */
STDAPI CUIM::QueryService(
	REFGUID guidService,
	REFIID riid,
	void **ppv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::QueryService");

	if (ppv == NULL)
		return E_INVALIDARG;

	*ppv = NULL;

	// we support just one service
	if (!IsEqualGUID(guidService, GUID_SERVICE_TEXTSTORE))
		return E_NOINTERFACE;

	if (IsEqualIID(riid, IID_IServiceProvider))
	{
		*ppv = (IServiceProvider *)this;
	}
	else if (IsEqualIID(riid, IID_ITfEnableService))
	{
		*ppv = (ITfEnableService *)this;
	}

	if (*ppv == NULL)
		return E_NOINTERFACE;

	AddRef();

	return S_OK;
}

/*
 *	STDAPI	CUIM::IsEnabled(REFGUID rguidServiceCategory, CLSID clsidService, IUnknown *punkService, BOOL *pfOkToRun)
 *
 *	@mfunc
 *		Handle ITfEnableService::QueryService. Cicero/tip call this interface to check
 *	if we support the service
 *
 *	@rdesc
 *		S_OK if service supported
 *
 */
STDAPI CUIM::IsEnabled(
	REFGUID rguidServiceCategory,
	CLSID clsidService,
	IUnknown *punkService,
	BOOL *pfOkToRun)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::IsEnabled");
    
	if (pfOkToRun == NULL)
		return E_INVALIDARG;

	// default is disallow
	*pfOkToRun = FALSE;

	// clsidService identifies the particular tip, but we don't use it here
	// punkService is a custom interface, probably for config, but we don't use it here yet

	if (IsEqualGUID(rguidServiceCategory, GUID_TFCAT_TIP_SMARTTAG))
	{
		*pfOkToRun = _pTextMsgFilter->_fAllowSmartTag ? TRUE : FALSE;
	}
	else if (IsEqualGUID(rguidServiceCategory, GUID_TFCAT_TIP_PROOFING))
	{
		*pfOkToRun = _pTextMsgFilter->_fAllowProofing ? TRUE : FALSE;;
	}

	return S_OK;
}

/*
 *	STDAPI	CUIM::GetId(GUID *pguidId)
 *
 *	@mfunc
 *		get the RE clid
 *
 *	@rdesc
 *		S_OK
 *
 */
STDAPI CUIM::GetId(
	GUID *pguidId)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetId");
    
	if (pguidId == NULL)
        return E_INVALIDARG;

    *pguidId = CLSID_MSFTEDIT;
    return S_OK;
}

/*
 *	void	CUIM::NotifyService()
 *
 *	@mfunc
 *		Notify Cicero about change in services.
 *
 *
 */
void CUIM::NotifyService()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::NotifyService");

	ITfCompartmentMgr *pCompartmentMgr;
	ITfCompartment *pCompartment;
	VARIANT varValue;

	if (_pic->QueryInterface(IID_ITfCompartmentMgr, (void **)&pCompartmentMgr) != S_OK)
		return;

	// give any waiting tips a heads up we've changed our state
	if (pCompartmentMgr->GetCompartment(GUID_COMPARTMENT_ENABLESTATE, &pCompartment) == S_OK)
	{
		varValue.vt = VT_I4;
		varValue.lVal = 1; // arbitrary value, we just want to generate a change event

		pCompartment->SetValue(_pTextMsgFilter->_tid, &varValue);
		pCompartment->Release();
	}

	pCompartmentMgr->Release();
}

/*
 *	STDAPI CTextEditSink::QueryInterface
 *
 *	@mfunc
 *		IUnknown QueryInterface support
 *
 *	@rdesc
 *		NOERROR if interface supported
 *
 */
STDAPI CTextEditSink::QueryInterface(REFIID riid, void **ppvObj)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextEditSink))
    {
        *ppvObj = (CTextEditSink *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

/*
 *	STDMETHODIMP_(ULONG) CTextEditSink::AddRef
 *
 *	@mfunc
 *		IUnknown AddRef support
 *
 *	@rdesc
 *		Reference count
 */
STDAPI_(ULONG) CTextEditSink::AddRef()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::AddRef");

    return ++_cRef;
}


/*
 *	STDMETHODIMP_(ULONG) CTextEditSink::Release()
 *
 *	@mfunc
 *		IUnknown Release support - delete object when reference count is 0
 *
 *	@rdesc
 *		Reference count
 */
STDAPI_(ULONG) CTextEditSink::Release()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::Release");

    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*
 *	CTextEditSink::CTextEditSink()
 *
 *	@mfunc
 *
 *		ctor
 *
 */
CTextEditSink::CTextEditSink(PTESCALLBACK pfnCallback, void *pv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::CTextEditSink");

    _cRef = 1;
    _dwCookie = 0x0FFFFFFFF;

    _pfnCallback = pfnCallback;
    _pv = pv;
}

/*
 *	STDAPI CTextEditSink::OnEndEdit()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDAPI CTextEditSink::OnEndEdit(
	ITfContext *pic,
	TfEditCookie ecReadOnly, 
	ITfEditRecord *pEditRecord)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::OnEndEdit");

	return _pfnCallback(pEditRecord, _pv);
}

/*
 *	HRESULT CTextEditSink::_Advise
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CTextEditSink::_Advise(ITfContext *pic)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::_Advise");

    HRESULT hr;
    ITfSource *source = NULL;

    _pic = NULL;
    hr = E_FAIL;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        return E_FAIL;

    if (FAILED(source->AdviseSink(IID_ITfTextEditSink, this, &_dwCookie)))
        goto Exit;

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    source->Release();
    return hr;
}

/*
 *	HRESULT CTextEditSink::_Unadvise
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CTextEditSink::_Unadvise()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::_Unadvise");

    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        return E_FAIL;

    if (FAILED(_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        return E_FAIL;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    source->Release();
    _pic->Release();
	_pic = NULL;
    return hr;
}

#endif	//	NOFEPROCESSING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\ctffunc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for ctffunc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITfCandidateString,0x581f317e,0xfd9d,0x443f,0xb9,0x72,0xed,0x00,0x46,0x7c,0x5d,0x40);


MIDL_DEFINE_GUID(IID, IID_IEnumTfCandidates,0xdefb1926,0x6c80,0x4ce8,0x87,0xd4,0xd6,0xb7,0x2b,0x81,0x2b,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfCandidateList,0xa3ad50fb,0x9bdb,0x49e3,0xa8,0x43,0x6c,0x76,0x52,0x0f,0xbf,0x5d);


MIDL_DEFINE_GUID(IID, IID_ITfFnReconversion,0x4cea93c0,0x0a58,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfFnAbort,0x17f2317f,0xaddb,0x49df,0x87,0x0e,0x66,0x22,0x7b,0xc5,0x1d,0x1a);


MIDL_DEFINE_GUID(IID, IID_ITfFnPlayBack,0xa3a416a4,0x0f64,0x11d3,0xb5,0xb7,0x00,0xc0,0x4f,0xc3,0x24,0xa1);


MIDL_DEFINE_GUID(IID, IID_ITfFnLangProfileUtil,0xA87A8574,0xA6C1,0x4E15,0x99,0xF0,0x3D,0x39,0x65,0xF5,0x48,0xEB);


MIDL_DEFINE_GUID(IID, IID_ITfFnConfigure,0x88f567c6,0x1757,0x49f8,0xa1,0xb2,0x89,0x23,0x4c,0x1e,0xef,0xf9);


MIDL_DEFINE_GUID(IID, IID_ITfFnConfigureRegisterWord,0xbb95808a,0x6d8f,0x4bca,0x84,0x00,0x53,0x90,0xb5,0x86,0xae,0xdf);


MIDL_DEFINE_GUID(IID, IID_ITfFnShowHelp,0x5AB1D30C,0x094D,0x4C29,0x8E,0xA5,0x0B,0xF5,0x9B,0xE8,0x7B,0xF3);


MIDL_DEFINE_GUID(IID, IID_ITfFnBalloon,0x3BAB89E4,0x5FBE,0x45F4,0xA5,0xBC,0xDC,0xA3,0x6A,0xD2,0x25,0xA8);


MIDL_DEFINE_GUID(IID, IID_ITfFnGetSAPIObject,0x5c0ab7ea,0x167d,0x4f59,0xbf,0xb5,0x46,0x93,0x75,0x5e,0x90,0xca);


MIDL_DEFINE_GUID(IID, IID_ITfFnPropertyUIStatus,0x2338AC6E,0x2B9D,0x44C0,0xA7,0x5E,0xEE,0x64,0xF2,0x56,0xB3,0xBD);


MIDL_DEFINE_GUID(IID, IID_ITfFnLMProcessor,0x7AFBF8E7,0xAC4B,0x4082,0xB0,0x58,0x89,0x08,0x99,0xD3,0xA0,0x10);


MIDL_DEFINE_GUID(IID, IID_ITfFnLMInternal,0x04B825B1,0xAC9A,0x4F7B,0xB5,0xAD,0xC7,0x16,0x8F,0x1E,0xE4,0x45);


MIDL_DEFINE_GUID(IID, IID_IEnumTfLatticeElements,0x56988052,0x47DA,0x4A05,0x91,0x1A,0xE3,0xD9,0x41,0xF1,0x71,0x45);


MIDL_DEFINE_GUID(IID, IID_ITfLMLattice,0xD4236675,0xA5BF,0x4570,0x9D,0x42,0x5D,0x6D,0x7B,0x02,0xD5,0x9B);


MIDL_DEFINE_GUID(IID, IID_ITfFnAdviseText,0x3527268B,0x7D53,0x4DD9,0x92,0xB7,0x72,0x96,0xAE,0x46,0x12,0x49);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for ctffunc.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITfCandidateString,0x581f317e,0xfd9d,0x443f,0xb9,0x72,0xed,0x00,0x46,0x7c,0x5d,0x40);


MIDL_DEFINE_GUID(IID, IID_IEnumTfCandidates,0xdefb1926,0x6c80,0x4ce8,0x87,0xd4,0xd6,0xb7,0x2b,0x81,0x2b,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfCandidateList,0xa3ad50fb,0x9bdb,0x49e3,0xa8,0x43,0x6c,0x76,0x52,0x0f,0xbf,0x5d);


MIDL_DEFINE_GUID(IID, IID_ITfFnReconversion,0x4cea93c0,0x0a58,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfFnAbort,0x17f2317f,0xaddb,0x49df,0x87,0x0e,0x66,0x22,0x7b,0xc5,0x1d,0x1a);


MIDL_DEFINE_GUID(IID, IID_ITfFnPlayBack,0xa3a416a4,0x0f64,0x11d3,0xb5,0xb7,0x00,0xc0,0x4f,0xc3,0x24,0xa1);


MIDL_DEFINE_GUID(IID, IID_ITfFnLangProfileUtil,0xA87A8574,0xA6C1,0x4E15,0x99,0xF0,0x3D,0x39,0x65,0xF5,0x48,0xEB);


MIDL_DEFINE_GUID(IID, IID_ITfFnConfigure,0x88f567c6,0x1757,0x49f8,0xa1,0xb2,0x89,0x23,0x4c,0x1e,0xef,0xf9);


MIDL_DEFINE_GUID(IID, IID_ITfFnConfigureRegisterWord,0xbb95808a,0x6d8f,0x4bca,0x84,0x00,0x53,0x90,0xb5,0x86,0xae,0xdf);


MIDL_DEFINE_GUID(IID, IID_ITfFnShowHelp,0x5AB1D30C,0x094D,0x4C29,0x8E,0xA5,0x0B,0xF5,0x9B,0xE8,0x7B,0xF3);


MIDL_DEFINE_GUID(IID, IID_ITfFnBalloon,0x3BAB89E4,0x5FBE,0x45F4,0xA5,0xBC,0xDC,0xA3,0x6A,0xD2,0x25,0xA8);


MIDL_DEFINE_GUID(IID, IID_ITfFnGetSAPIObject,0x5c0ab7ea,0x167d,0x4f59,0xbf,0xb5,0x46,0x93,0x75,0x5e,0x90,0xca);


MIDL_DEFINE_GUID(IID, IID_ITfFnPropertyUIStatus,0x2338AC6E,0x2B9D,0x44C0,0xA7,0x5E,0xEE,0x64,0xF2,0x56,0xB3,0xBD);


MIDL_DEFINE_GUID(IID, IID_ITfFnLMProcessor,0x7AFBF8E7,0xAC4B,0x4082,0xB0,0x58,0x89,0x08,0x99,0xD3,0xA0,0x10);


MIDL_DEFINE_GUID(IID, IID_ITfFnLMInternal,0x04B825B1,0xAC9A,0x4F7B,0xB5,0xAD,0xC7,0x16,0x8F,0x1E,0xE4,0x45);


MIDL_DEFINE_GUID(IID, IID_IEnumTfLatticeElements,0x56988052,0x47DA,0x4A05,0x91,0x1A,0xE3,0xD9,0x41,0xF1,0x71,0x45);


MIDL_DEFINE_GUID(IID, IID_ITfLMLattice,0xD4236675,0xA5BF,0x4570,0x9D,0x42,0x5D,0x6D,0x7B,0x02,0xD5,0x9B);


MIDL_DEFINE_GUID(IID, IID_ITfFnAdviseText,0x3527268B,0x7D53,0x4DD9,0x92,0xB7,0x72,0x96,0xAE,0x46,0x12,0x49);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\debug.cpp ===
/*
 *	DEBUG.CPP
 *	
 *	Purpose:
 *		RICHEDIT debugging support--commented out in ship builds
 *
 *	History: <nl>
 *		7/29/98	KeithCu Wrote it stealing much from Rich Arneson's code
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

//Module is empty if this is a retail build.
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)

#ifdef NOFULLDEBUG
PFNASSERTHOOK pfnAssert = NULL;   //Assert hook function
#else

DWORD dwDebugOptions = 0;         //Debug option flags
PFNASSERTHOOK pfnAssert = NULL;   //Assert hook function
PFNTRACEHOOK pfnTrace = NULL;     //Trace hook function

// Static variables
static HINSTANCE ghMod;                        //Dll module handle
static DWORD TlsIndex;                      //Debug output indent level
static HANDLE hLogFile = NULL;              //Log file handle
static BOOL fIgnoreAsserts = FALSE;         //Ignore all asserts if true
static CRITICAL_SECTION csLog;              //Critical section for log file i/o
static CRITICAL_SECTION csAssert;           //Critical section for asserts
static HANDLE hEventAssert1 = NULL;         //Event for assert syncing
static HANDLE hEventAssert2 = NULL;         //Event for assert syncing
static HWND hwndAssert = NULL;           	//Assert dialog window handle
static HANDLE hAssertThrd = NULL;           //Assert thread handle
static char szAssert[MAXDEBUGSTRLEN];       //Assert message buffer
static int idAssert = -1;                   //Assert button pressed by user
DWORD WINAPI AssertThread(LPVOID lParam);	//Assert thread entry point
static BOOL fDllDetach = FALSE;				//True if we are in dll detach

//Strings for subsystem element of message
static char* TrcSubsys [] =
{
    "",
    "Display",
    "Wrapper",
    "Edit",
    "TextServices",
    "TOM",
    "OLE Object Support",
    "Store",
    "Selection",
    "WinHost",
    "DataXfer",
    "MultiUndo",
    "Range",
    "Util",
    "Notification Mgr.",
    "RTF Reader",
    "RTF Writer",
    "Printing",
    "East Asia",
	"Font"
};

//Strings for severity element of message
static char* TrcSeverity [] =
{
    "",
    "WARNING",
    "ERROR",
    "ASSERT",
    "INFO",
	"MEMORY"
};

//Strings for scope element of message
static char* TrcScope [] =
{
    "",
    "External",
    "Internal"
};

//Structure for lookup tables
typedef struct
{
    DWORD dwKey;
    char * sz;
} TabElem;

//Lookup table for CTrace param strings
static TabElem TrcParamTab [] = 
{
//Richedit Messages
    {(DWORD)EM_GETLIMITTEXT, "EM_GETLIMITTEXT"},
    {(DWORD)EM_POSFROMCHAR, "EM_POSFROMCHAR"},
    {(DWORD)EM_CHARFROMPOS, "EM_CHARFROMPOS"},
    {(DWORD)EM_SCROLLCARET, "EM_SCROLLCARET"},
    {(DWORD)EM_CANPASTE, "EM_CANPASTE"},
    {(DWORD)EM_DISPLAYBAND, "EM_DISPLAYBAND"},
    {(DWORD)EM_EXGETSEL, "EM_EXGETSEL"},
    {(DWORD)EM_EXLIMITTEXT, "EM_EXLIMITTEXT"},
    {(DWORD)EM_EXLINEFROMCHAR, "EM_EXLINEFROMCHAR"},
    {(DWORD)EM_EXSETSEL, "EM_EXSETSEL"},
    {(DWORD)EM_FINDTEXT, "EM_FINDTEXT"},
    {(DWORD)EM_FORMATRANGE, "EM_FORMATRANGE"},
    {(DWORD)EM_GETCHARFORMAT, "EM_GETCHARFORMAT"},
    {(DWORD)EM_GETEVENTMASK, "EM_GETEVENTMASK"},
    {(DWORD)EM_GETOLEINTERFACE, "EM_GETOLEINTERFACE"},
    {(DWORD)EM_GETPARAFORMAT, "EM_GETPARAFORMAT"},
    {(DWORD)EM_GETSELTEXT, "EM_GETSELTEXT"},
    {(DWORD)EM_HIDESELECTION, "EM_HIDESELECTION"},
    {(DWORD)EM_PASTESPECIAL, "EM_PASTESPECIAL"},
    {(DWORD)EM_REQUESTRESIZE, "EM_REQUESTRESIZE"},
    {(DWORD)EM_SELECTIONTYPE, "EM_SELECTIONTYPE"},
    {(DWORD)EM_SETBKGNDCOLOR, "EM_SETBKGNDCOLOR"},
    {(DWORD)EM_SETCHARFORMAT, "EM_SETCHARFORMAT"},
    {(DWORD)EM_SETEVENTMASK, "EM_SETEVENTMASK"},
    {(DWORD)EM_SETOLECALLBACK, "EM_SETOLECALLBACK"},
    {(DWORD)EM_SETPARAFORMAT, "EM_SETPARAFORMAT"},
    {(DWORD)EM_SETTARGETDEVICE, "EM_SETTARGETDEVICE"},
    {(DWORD)EM_STREAMIN, "EM_STREAMIN"},
    {(DWORD)EM_STREAMOUT, "EM_STREAMOUT"},
    {(DWORD)EM_GETTEXTRANGE, "EM_GETTEXTRANGE"},
    {(DWORD)EM_FINDWORDBREAK, "EM_FINDWORDBREAK"},
    {(DWORD)EM_SETOPTIONS, "EM_SETOPTIONS"},
    {(DWORD)EM_GETOPTIONS, "EM_GETOPTIONS"},
    {(DWORD)EM_FINDTEXTEX, "EM_FINDTEXTEX"},
    {(DWORD)EM_GETWORDBREAKPROCEX, "EM_GETWORDBREAKPROCEX"},
    {(DWORD)EM_SETWORDBREAKPROCEX, "EM_SETWORDBREAKPROCEX"},
    {(DWORD)EM_SETUNDOLIMIT, "EM_SETUNDOLIMIT"},
    {(DWORD)EM_REDO, "EM_REDO"},
    {(DWORD)EM_CANREDO, "EM_CANREDO"},
    {(DWORD)EM_SETPUNCTUATION, "EM_SETPUNCTUATION"},
    {(DWORD)EM_GETPUNCTUATION, "EM_GETPUNCTUATION"},
    {(DWORD)EM_SETWORDWRAPMODE, "EM_SETWORDWRAPMODE"},
    {(DWORD)EM_GETWORDWRAPMODE, "EM_GETWORDWRAPMODE"},
    {(DWORD)EM_SETIMECOLOR, "EM_SETIMECOLOR"},
    {(DWORD)EM_GETIMECOLOR, "EM_GETIMECOLOR"},
    {(DWORD)EM_SETIMEOPTIONS, "EM_SETIMEOPTIONS"},
    {(DWORD)EM_GETIMEOPTIONS, "EM_GETIMEOPTIONS"},
    {(DWORD)EN_MSGFILTER, "EN_MSGFILTER"},
    {(DWORD)EN_REQUESTRESIZE, "EN_REQUESTRESIZE"},
    {(DWORD)EN_SELCHANGE, "EN_SELCHANGE"},
    {(DWORD)EN_DROPFILES, "EN_DROPFILES"},
    {(DWORD)EN_PROTECTED, "EN_PROTECTED"},
    {(DWORD)EN_CORRECTTEXT, "EN_CORRECTTEXT"},
    {(DWORD)EN_STOPNOUNDO, "EN_STOPNOUNDO"},
    {(DWORD)EN_IMECHANGE, "EN_IMECHANGE"},
    {(DWORD)EN_SAVECLIPBOARD, "EN_SAVECLIPBOARD"},
    {(DWORD)EN_OLEOPFAILED, "EN_OLEOPFAILED"},

//Window Messages

	{(DWORD)WM_NULL, "WM_NULL"},
	{(DWORD)WM_CREATE, "WM_CREATE"},
	{(DWORD)WM_DESTROY, "WM_DESTROY"},
	{(DWORD)WM_MOVE, "WM_MOVE"},
	{(DWORD)WM_SIZE, "WM_SIZE"},
	{(DWORD)WM_ACTIVATE, "WM_ACTIVATE"},
	{(DWORD)WM_SETFOCUS, "WM_SETFOCUS"},
	{(DWORD)WM_KILLFOCUS, "WM_KILLFOCUS"},
	{(DWORD)WM_ENABLE, "WM_ENABLE"},
	{(DWORD)WM_SETREDRAW, "WM_SETREDRAW"},
	{(DWORD)WM_SETTEXT, "WM_SETTEXT"},
	{(DWORD)WM_GETTEXT, "WM_GETTEXT"},
	{(DWORD)WM_GETTEXTLENGTH, "WM_GETTEXTLENGTH"},
	{(DWORD)WM_PAINT, "WM_PAINT"},
	{(DWORD)WM_CLOSE, "WM_CLOSE"},
	{(DWORD)WM_QUERYENDSESSION, "WM_QUERYENDSESSION"},
	{(DWORD)WM_QUIT, "WM_QUIT"},
	{(DWORD)WM_QUERYOPEN, "WM_QUERYOPEN"},
	{(DWORD)WM_ERASEBKGND, "WM_ERASEBKGND"},
	{(DWORD)WM_SYSCOLORCHANGE, "WM_SYSCOLORCHANGE"},
	{(DWORD)WM_ENDSESSION, "WM_ENDSESSION"},
	{(DWORD)WM_SHOWWINDOW, "WM_SHOWWINDOW"},
	{(DWORD)WM_WININICHANGE, "WM_WININICHANGE"},
	{(DWORD)WM_SETTINGCHANGE, "WM_SETTINGCHANGE"},
	{(DWORD)WM_DEVMODECHANGE, "WM_DEVMODECHANGE"},
	{(DWORD)WM_ACTIVATEAPP, "WM_ACTIVATEAPP"},
	{(DWORD)WM_FONTCHANGE, "WM_FONTCHANGE"},
	{(DWORD)WM_TIMECHANGE, "WM_TIMECHANGE"},
	{(DWORD)WM_CANCELMODE, "WM_CANCELMODE"},
	{(DWORD)WM_SETCURSOR, "WM_SETCURSOR"},
	{(DWORD)WM_MOUSEACTIVATE, "WM_MOUSEACTIVATE"},
	{(DWORD)WM_CHILDACTIVATE, "WM_CHILDACTIVATE"},
	{(DWORD)WM_QUEUESYNC, "WM_QUEUESYNC"},
	{(DWORD)WM_GETMINMAXINFO, "WM_GETMINMAXINFO"},
	{(DWORD)WM_PAINTICON, "WM_PAINTICON"},
	{(DWORD)WM_ICONERASEBKGND, "WM_ICONERASEBKGND"},
	{(DWORD)WM_NEXTDLGCTL, "WM_NEXTDLGCTL"},
	{(DWORD)WM_SPOOLERSTATUS, "WM_SPOOLERSTATUS"},
	{(DWORD)WM_DRAWITEM, "WM_DRAWITEM"},
	{(DWORD)WM_MEASUREITEM, "WM_MEASUREITEM"},
	{(DWORD)WM_DELETEITEM, "WM_DELETEITEM"},
	{(DWORD)WM_VKEYTOITEM, "WM_VKEYTOITEM"},
	{(DWORD)WM_CHARTOITEM, "WM_CHARTOITEM"},
	{(DWORD)WM_SETFONT, "WM_SETFONT"},
	{(DWORD)WM_GETFONT, "WM_GETFONT"},
	{(DWORD)WM_SETHOTKEY, "WM_SETHOTKEY"},
	{(DWORD)WM_GETHOTKEY, "WM_GETHOTKEY"},
	{(DWORD)WM_QUERYDRAGICON, "WM_QUERYDRAGICON"},
	{(DWORD)WM_COMPAREITEM, "WM_COMPAREITEM"},
	{(DWORD)WM_COMPACTING, "WM_COMPACTING"},
	{(DWORD)WM_COMMNOTIFY, "WM_COMMNOTIFY"},
	{(DWORD)WM_WINDOWPOSCHANGING, "WM_WINDOWPOSCHANGING"},
	{(DWORD)WM_WINDOWPOSCHANGED, "WM_WINDOWPOSCHANGED"},
	{(DWORD)WM_POWER, "WM_POWER"},
	{(DWORD)WM_COPYDATA, "WM_COPYDATA"},
	{(DWORD)WM_CANCELJOURNAL, "WM_CANCELJOURNAL"},
	{(DWORD)WM_NOTIFY, "WM_NOTIFY"},
	{(DWORD)WM_INPUTLANGCHANGEREQUEST, "WM_INPUTLANGCHANGEREQUEST"},
	{(DWORD)WM_INPUTLANGCHANGE, "WM_INPUTLANGCHANGE"},
	{(DWORD)WM_TCARD, "WM_TCARD"},
	{(DWORD)WM_HELP, "WM_HELP"},
	{(DWORD)WM_USERCHANGED, "WM_USERCHANGED"},
	{(DWORD)WM_NOTIFYFORMAT, "WM_NOTIFYFORMAT"},
	{(DWORD)WM_CONTEXTMENU, "WM_CONTEXTMENU"},
	{(DWORD)WM_STYLECHANGING, "WM_STYLECHANGING"},
	{(DWORD)WM_STYLECHANGED, "WM_STYLECHANGED"},
	{(DWORD)WM_DISPLAYCHANGE, "WM_DISPLAYCHANGE"},
	{(DWORD)WM_GETICON, "WM_GETICON"},
	{(DWORD)WM_SETICON, "WM_SETICON"},
	{(DWORD)WM_NCCREATE, "WM_NCCREATE"},
	{(DWORD)WM_NCDESTROY, "WM_NCDESTROY"},
	{(DWORD)WM_NCCALCSIZE, "WM_NCCALCSIZE"},
	{(DWORD)WM_NCHITTEST, "WM_NCHITTEST"},
	{(DWORD)WM_NCPAINT, "WM_NCPAINT"},
	{(DWORD)WM_NCACTIVATE, "WM_NCACTIVATE"},
	{(DWORD)WM_GETDLGCODE, "WM_GETDLGCODE"},
	{(DWORD)WM_NCMOUSEMOVE, "WM_NCMOUSEMOVE"},
	{(DWORD)WM_NCLBUTTONDOWN, "WM_NCLBUTTONDOWN"},
	{(DWORD)WM_NCLBUTTONUP, "WM_NCLBUTTONUP"},
	{(DWORD)WM_NCLBUTTONDBLCLK, "WM_NCLBUTTONDBLCLK"},
	{(DWORD)WM_NCRBUTTONDOWN, "WM_NCRBUTTONDOWN"},
	{(DWORD)WM_NCRBUTTONUP, "WM_NCRBUTTONUP"},
	{(DWORD)WM_NCRBUTTONDBLCLK, "WM_NCRBUTTONDBLCLK"},
	{(DWORD)WM_NCMBUTTONDOWN, "WM_NCMBUTTONDOWN"},
	{(DWORD)WM_NCMBUTTONUP, "WM_NCMBUTTONUP"},
	{(DWORD)WM_NCMBUTTONDBLCLK, "WM_NCMBUTTONDBLCLK"},
	{(DWORD)WM_KEYFIRST, "WM_KEYFIRST"},
	{(DWORD)WM_KEYDOWN, "WM_KEYDOWN"},
	{(DWORD)WM_KEYUP, "WM_KEYUP"},
	{(DWORD)WM_CHAR, "WM_CHAR"},
	{(DWORD)WM_DEADCHAR, "WM_DEADCHAR"},
	{(DWORD)WM_SYSKEYDOWN, "WM_SYSKEYDOWN"},
	{(DWORD)WM_SYSKEYUP, "WM_SYSKEYUP"},
	{(DWORD)WM_SYSCHAR, "WM_SYSCHAR"},
	{(DWORD)WM_SYSDEADCHAR, "WM_SYSDEADCHAR"},
	{(DWORD)WM_KEYLAST, "WM_KEYLAST"},
	{(DWORD)WM_IME_STARTCOMPOSITION, "WM_IME_STARTCOMPOSITION"},
	{(DWORD)WM_IME_ENDCOMPOSITION, "WM_IME_ENDCOMPOSITION"},
	{(DWORD)WM_IME_COMPOSITION, "WM_IME_COMPOSITION"},
	{(DWORD)WM_IME_KEYLAST, "WM_IME_KEYLAST"},
	{(DWORD)WM_INITDIALOG, "WM_INITDIALOG"},
	{(DWORD)WM_COMMAND, "WM_COMMAND"},
	{(DWORD)WM_SYSCOMMAND, "WM_SYSCOMMAND"},
	{(DWORD)WM_TIMER, "WM_TIMER"},
	{(DWORD)WM_HSCROLL, "WM_HSCROLL"},
	{(DWORD)WM_VSCROLL, "WM_VSCROLL"},
	{(DWORD)WM_INITMENU, "WM_INITMENU"},
	{(DWORD)WM_INITMENUPOPUP, "WM_INITMENUPOPUP"},
	{(DWORD)WM_MENUSELECT, "WM_MENUSELECT"},
	{(DWORD)WM_MENUCHAR, "WM_MENUCHAR"},
	{(DWORD)WM_ENTERIDLE, "WM_ENTERIDLE"},
	{(DWORD)WM_CTLCOLORMSGBOX, "WM_CTLCOLORMSGBOX"},
	{(DWORD)WM_CTLCOLOREDIT, "WM_CTLCOLOREDIT"},
	{(DWORD)WM_CTLCOLORLISTBOX, "WM_CTLCOLORLISTBOX"},
	{(DWORD)WM_CTLCOLORBTN, "WM_CTLCOLORBTN"},
	{(DWORD)WM_CTLCOLORDLG, "WM_CTLCOLORDLG"},
	{(DWORD)WM_CTLCOLORSCROLLBAR, "WM_CTLCOLORSCROLLBAR"},
	{(DWORD)WM_CTLCOLORSTATIC, "WM_CTLCOLORSTATIC"},
	{(DWORD)WM_MOUSEFIRST, "WM_MOUSEFIRST"},
	{(DWORD)WM_MOUSEMOVE, "WM_MOUSEMOVE"},
	{(DWORD)WM_LBUTTONDOWN, "WM_LBUTTONDOWN"},
	{(DWORD)WM_LBUTTONUP, "WM_LBUTTONUP"},
	{(DWORD)WM_LBUTTONDBLCLK, "WM_LBUTTONDBLCLK"},
	{(DWORD)WM_RBUTTONDOWN, "WM_RBUTTONDOWN"},
	{(DWORD)WM_RBUTTONUP, "WM_RBUTTONUP"},
	{(DWORD)WM_RBUTTONDBLCLK, "WM_RBUTTONDBLCLK"},
	{(DWORD)WM_MBUTTONDOWN, "WM_MBUTTONDOWN"},
	{(DWORD)WM_MBUTTONUP, "WM_MBUTTONUP"},
	{(DWORD)WM_MBUTTONDBLCLK, "WM_MBUTTONDBLCLK"},
	{(DWORD)WM_MOUSELAST, "WM_MOUSELAST"},
	{(DWORD)WM_PARENTNOTIFY, "WM_PARENTNOTIFY"},
	{(DWORD)WM_ENTERMENULOOP, "WM_ENTERMENULOOP"},
	{(DWORD)WM_EXITMENULOOP, "WM_EXITMENULOOP"},
	{(DWORD)WM_NEXTMENU, "WM_NEXTMENU"},
	{(DWORD)WM_SIZING, "WM_SIZING"},
	{(DWORD)WM_CAPTURECHANGED, "WM_CAPTURECHANGED"},
	{(DWORD)WM_MOVING, "WM_MOVING"},
	{(DWORD)WM_POWERBROADCAST, "WM_POWERBROADCAST"},
	{(DWORD)WM_DEVICECHANGE, "WM_DEVICECHANGE"},
	{(DWORD)WM_IME_SETCONTEXT, "WM_IME_SETCONTEXT"},
	{(DWORD)WM_IME_NOTIFY, "WM_IME_NOTIFY"},
	{(DWORD)WM_IME_CONTROL, "WM_IME_CONTROL"},
	{(DWORD)WM_IME_COMPOSITIONFULL, "WM_IME_COMPOSITIONFULL"},
	{(DWORD)WM_IME_SELECT, "WM_IME_SELECT"},
	{(DWORD)WM_IME_CHAR, "WM_IME_CHAR"},
	{(DWORD)WM_IME_KEYDOWN, "WM_IME_KEYDOWN"},
	{(DWORD)WM_IME_KEYUP, "WM_IME_KEYUP"},
	{(DWORD)WM_MDICREATE, "WM_MDICREATE"},
	{(DWORD)WM_MDIDESTROY, "WM_MDIDESTROY"},
	{(DWORD)WM_MDIACTIVATE, "WM_MDIACTIVATE"},
	{(DWORD)WM_MDIRESTORE, "WM_MDIRESTORE"},
	{(DWORD)WM_MDINEXT, "WM_MDINEXT"},
	{(DWORD)WM_MDIMAXIMIZE, "WM_MDIMAXIMIZE"},
	{(DWORD)WM_MDITILE, "WM_MDITILE"},
	{(DWORD)WM_MDICASCADE, "WM_MDICASCADE"},
	{(DWORD)WM_MDIICONARRANGE, "WM_MDIICONARRANGE"},
	{(DWORD)WM_MDIGETACTIVE, "WM_MDIGETACTIVE"},
	{(DWORD)WM_MDISETMENU, "WM_MDISETMENU"},
	{(DWORD)WM_ENTERSIZEMOVE, "WM_ENTERSIZEMOVE"},
	{(DWORD)WM_EXITSIZEMOVE, "WM_EXITSIZEMOVE"},
	{(DWORD)WM_DROPFILES, "WM_DROPFILES"},
	{(DWORD)WM_MDIREFRESHMENU, "WM_MDIREFRESHMENU"},
	{(DWORD)WM_CUT, "WM_CUT"},
	{(DWORD)WM_COPY, "WM_COPY"},
	{(DWORD)WM_PASTE, "WM_PASTE"},
	{(DWORD)WM_CLEAR, "WM_CLEAR"},
	{(DWORD)WM_UNDO, "WM_UNDO"},
	{(DWORD)WM_RENDERFORMAT, "WM_RENDERFORMAT"},
	{(DWORD)WM_RENDERALLFORMATS, "WM_RENDERALLFORMATS"},
	{(DWORD)WM_DESTROYCLIPBOARD, "WM_DESTROYCLIPBOARD"},
	{(DWORD)WM_DRAWCLIPBOARD, "WM_DRAWCLIPBOARD"},
	{(DWORD)WM_PAINTCLIPBOARD, "WM_PAINTCLIPBOARD"},
	{(DWORD)WM_VSCROLLCLIPBOARD, "WM_VSCROLLCLIPBOARD"},
	{(DWORD)WM_SIZECLIPBOARD, "WM_SIZECLIPBOARD"},
	{(DWORD)WM_ASKCBFORMATNAME, "WM_ASKCBFORMATNAME"},
	{(DWORD)WM_CHANGECBCHAIN, "WM_CHANGECBCHAIN"},
	{(DWORD)WM_HSCROLLCLIPBOARD, "WM_HSCROLLCLIPBOARD"},
	{(DWORD)WM_QUERYNEWPALETTE, "WM_QUERYNEWPALETTE"},
	{(DWORD)WM_PALETTEISCHANGING, "WM_PALETTEISCHANGING"},
	{(DWORD)WM_PALETTECHANGED, "WM_PALETTECHANGED"},
	{(DWORD)WM_HOTKEY, "WM_HOTKEY"},
	{(DWORD)WM_PRINT, "WM_PRINT"},
	{(DWORD)WM_PRINTCLIENT, "WM_PRINTCLIENT"},
	{(DWORD)WM_HANDHELDFIRST, "WM_HANDHELDFIRST"},
	{(DWORD)WM_HANDHELDLAST, "WM_HANDHELDLAST"},
	{(DWORD)WM_AFXFIRST, "WM_AFXFIRST"},
	{(DWORD)WM_AFXLAST, "WM_AFXLAST"},
	{(DWORD)WM_PENWINFIRST, "WM_PENWINFIRST"},
	{(DWORD)WM_PENWINLAST, "WM_PENWINLAST"},
	{(DWORD)WM_APP, "WM_APP"}
};

// release + asserts build has no memory checking
#ifndef _RELEASE_ASSERTS_

void DlgDisplayVrgmst(HWND hListMemory)
{
	char szTemp[300];
	int cbTotal = 0;
	for(int imst = 0; vrgmst[imst].szFile != 0; imst++)
		{
		cbTotal += vrgmst[imst].cbAlloc;
		wsprintfA(szTemp, "%6.d   %s", vrgmst[imst].cbAlloc, vrgmst[imst].szFile);
		SendMessage(hListMemory, LB_ADDSTRING, 0,  (LPARAM) szTemp);
		}

	wsprintfA(szTemp, "%6.d   %s", cbTotal, "--- Total ---");
	SendMessage(hListMemory, LB_ADDSTRING, 0,  (LPARAM) szTemp);
}

HFONT hf = 0;

INT_PTR CALLBACK FDlgRicheditDebugCentral(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	HWND hListMemory;
	switch (message)
		{
		case WM_INITDIALOG:
			hListMemory = GetDlgItem(hdlg, IDC_MEMORY_STATISTICS);
			LOGFONTA lf;
			ZeroMemory(&lf, sizeof(lf));
			lf.lfHeight = 14;
			memcpy(lf.lfFaceName, "Courier New", 12);
			hf = CreateFontIndirectA(&lf);
			SendMessage(hListMemory, WM_SETFONT, (WPARAM)hf, FALSE);
			UpdateMst();
			DlgDisplayVrgmst(hListMemory);
			return FALSE;

		case WM_COMMAND:
			switch (wParam)
				{
				case IDOK:
					EndDialog(hdlg, IDOK);
					return TRUE;
				case IDCANCEL:
					EndDialog(hdlg, IDCANCEL);
					return TRUE;
				}
			break;
		}

	return FALSE;
}

void RicheditDebugCentral(void)
{
	DialogBoxA(hinstRE, MAKEINTRESOURCEA(IDD_DEBUG), NULL, FDlgRicheditDebugCentral);
	DeleteObject(hf);
}

#endif //!_RELEASE_ASSERTS_


/*
 *  DebugMain
 *	
 *  @mfunc
 *      Dll entry point.  See Win32 SDK documentation for details.
 *          hDLL - handle of DLL
 *          dwReason - indicates why DLL called
 *          lpReserved - reserved
 *
 *  @rdesc
 *      TRUE (always)
 *
 */
BOOL WINAPI DebugMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // DLL is attaching to the address space of the current process.
            //
            ghMod = hDLL;
            TlsIndex = TlsAlloc();
            TlsSetValue(TlsIndex, (LPVOID)-1);
            InitializeCriticalSection(&csLog);
            InitializeCriticalSection(&csAssert);

			//Create a separate thread to handle asserts.
            //We use events to halt the the asserting thread
            //during an assert, and to halt the assert thread the rest of
            //the time.  Note that these are autoreset events.
            hEventAssert1= CreateEventA(NULL, FALSE, FALSE, NULL);
            hEventAssert2= CreateEventA(NULL, FALSE, FALSE, NULL);

            INITDEBUGSERVICES(OPTUSEDEFAULTS, NULL, NULL);

            break;
        }

        case DLL_THREAD_ATTACH:
        {

            //
            // A new thread is being created in the current process.
            //
            TlsSetValue(TlsIndex, (LPVOID)-1);
            break;
        }

        case DLL_THREAD_DETACH:
        {
            //
            // A thread is exiting cleanly.
            //
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // The calling process is detaching the DLL from its address space.
            //
			fDllDetach = TRUE;

            //Clean up after ourselves.
            TlsFree(TlsIndex);
            SETLOGGING(FALSE);

			//Clean up the assert thread stuff.
            if (NULL != hAssertThrd)
                TerminateThread(hAssertThrd, 0);
            if (NULL != hEventAssert1)
                CloseHandle(hEventAssert1);
            if (NULL != hEventAssert2)
                CloseHandle(hEventAssert2);

            DeleteCriticalSection(&csLog);
            DeleteCriticalSection(&csAssert);

            break;
        }
    }   

    return TRUE;
}


//This is not in release asserts build
#ifndef _RELEASE_ASSERTS_

/*
 *  SetLogging
 *	
 *  @mfunc
 *      This function starts and stops logging of output from
 *      the debug services.  If logging is being started, it
 *      creates a new file for logging (path and name specified
 *      in win.ini).  fStartLog is TRUE and logging is already
 *      on, or fStartLog is FALSE and logging is off, this
 *      nothing happens.
 *
 *      fStartLog - TRUE to start logging, FALSE to stop logging.
 *
 */
void WINAPI SetLogging(BOOL fStartLog)
{
    //Don't start logging if it's already on.
    if (fStartLog && !fLogging)
    {
        char szLogFile[MAX_PATH];

        //Set option flag telling everyone we're on
        dwDebugOptions |= OPTLOGGINGON;

        //Get file name
        GetProfileStringA("RICHEDIT DEBUG", "LOGFILE", "", szLogFile, MAX_PATH);

        //Create new file
        hLogFile = CreateFileA(szLogFile, GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        //If we didn't succed creating the file, reset flags and tell user.
        if (INVALID_HANDLE_VALUE == hLogFile)
        {
            dwDebugOptions &= ~OPTLOGGINGON;
            MessageBoxA(NULL, "Unable to open log file.", "Richedit Debug", MB_OK);
        }
    }
    //Don't stop logging if it's not on.
    else if (!fStartLog && fLogging)
    {
        //Set option flag telling everyone we're off, and close file.
        dwDebugOptions &= ~OPTLOGGINGON;
        CloseHandle(hLogFile);
    }
}

#endif //!_RELEASE_ASSERTS_


/*
 *  InitDebugServices
 *	
 *  @mfunc
 *      This function initializes the options for the debug
 *      services.  If this function is not called, all optional
 *      debug services are left off by default.
 *      If OPTUSEDEFAULTS is specified for dwOpts, options are
 *      loaded from win.ini, otherwise  the caller specified
 *      options are set.  If the caller wishes to specify options
 *      they must specify all options they want turned on.  Any
 *      options not explicitly specified will be turned off.
 *      The function also takes a pointer to an assert hook
 *      function and a trace hook function.
 *
 *      dwOpts - Debug options to be set.
 *      pfnAssertHook - Pointer to assert hook function (NULL if none).
 *      pfnTraceHook - Pointer to trace hook function (NULL if none).
 *
 */
DllExport void WINAPI InitDebugServices(DWORD dwOpts,
    PFNASSERTHOOK pfnAssertHook, PFNTRACEHOOK pfnTraceHook)
{
    // Check to see if OPTUSEDEFAULTS was specified.  If so, get
    // values from win.ini.  Otherwise, set options to values
    // specified by caller.
    if (dwOpts & OPTUSEDEFAULTS)
    {
        SETLOGGING(GetProfileIntA("RICHEDIT DEBUG", "LOGGING", 0));
        SETVERBOSE(GetProfileIntA("RICHEDIT DEBUG", "VERBOSE", 0));
        SETINFO(GetProfileIntA("RICHEDIT DEBUG", "INFO", 0));
        SETMEMORY(GetProfileIntA("RICHEDIT DEBUG", "MEMORY", 0));
        SETTRACING(GetProfileIntA("RICHEDIT DEBUG", "TRACE", 0));
        SETTRACEEXT(GetProfileIntA("RICHEDIT DEBUG", "TRACEEXT", 0));
        SETOPT(OPTTRACEDISP, GetProfileIntA("RICHEDIT DEBUG", "TRACEDISP", 0));
        SETOPT(OPTTRACEWRAP, GetProfileIntA("RICHEDIT DEBUG", "TRACEWRAP", 0));
        SETOPT(OPTTRACEEDIT, GetProfileIntA("RICHEDIT DEBUG", "TRACEEDIT", 0));
        SETOPT(OPTTRACETS, GetProfileIntA("RICHEDIT DEBUG", "TRACETS", 0));
        SETOPT(OPTTRACETOM, GetProfileIntA("RICHEDIT DEBUG", "TRACETOM", 0));
        SETOPT(OPTTRACEOLE, GetProfileIntA("RICHEDIT DEBUG", "TRACEOLE", 0));
        SETOPT(OPTTRACEBACK, GetProfileIntA("RICHEDIT DEBUG", "TRACEBACK", 0));
        SETOPT(OPTTRACESEL, GetProfileIntA("RICHEDIT DEBUG", "TRACESEL", 0));
        SETOPT(OPTTRACEHOST, GetProfileIntA("RICHEDIT DEBUG", "TRACEHOST", 0));
        SETOPT(OPTTRACEDTE, GetProfileIntA("RICHEDIT DEBUG", "TRACEDTE", 0));
        SETOPT(OPTTRACEUNDO, GetProfileIntA("RICHEDIT DEBUG", "TRACEUNDO", 0));
        SETOPT(OPTTRACERANG, GetProfileIntA("RICHEDIT DEBUG", "TRACERANG", 0));
        SETOPT(OPTTRACEUTIL, GetProfileIntA("RICHEDIT DEBUG", "TRACEUTIL", 0));
        SETOPT(OPTTRACENOTM, GetProfileIntA("RICHEDIT DEBUG", "TRACENOTM", 0));
        SETOPT(OPTTRACERTFR, GetProfileIntA("RICHEDIT DEBUG", "TRACERTFR", 0));
        SETOPT(OPTTRACERTFW, GetProfileIntA("RICHEDIT DEBUG", "TRACERTFW", 0));
        SETOPT(OPTTRACEPRT, GetProfileIntA("RICHEDIT DEBUG", "TRACEPRT", 0));
        SETOPT(OPTTRACEFE, GetProfileIntA("RICHEDIT DEBUG", "TRACEFE", 0));
        SETOPT(OPTTRACEFONT, GetProfileIntA("RICHEDIT DEBUG", "TRACEFONT", 0));
    }
    else
    {
        //Set up logging before we set dwDebugOptions because
        //SetLogging will not turn logging on if the flag
        //indicates it is already on.
        SETLOGGING(dwOpts & OPTLOGGINGON);
        dwDebugOptions = dwOpts;
    }

    SETASSERTFN(pfnAssertHook);
    SETTRACEFN(pfnTraceHook);
}


/*
 *  AssertProc
 *	
 *  @mfunc
 *      This is the dialog proc for the assert message.
/ *
 *      lParam - The string to display in the dialog.
 *
 */
INT_PTR CALLBACK AssertProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            {
                RECT rcDlg, rcDesk;

                GetWindowRect(hwndDlg, &rcDlg);
                GetWindowRect(GetDesktopWindow(), &rcDesk);

                SetWindowPos(hwndDlg, HWND_TOP,
                ((rcDesk.right - rcDesk.left ) - (rcDlg.right - rcDlg.left))/2,
                ((rcDesk.bottom - rcDesk.top ) - (rcDlg.bottom - rcDlg.top))/2,
                0, 0, SWP_NOSIZE);


                if (NULL != lParam)
                    SetDlgItemTextA(hwndDlg, IDC_MSG, (LPSTR)lParam);

                //Sometimes we don't always end up on top.  I don't know why.
                SetForegroundWindow(hwndDlg);                
            }
            break;

        case WM_COMMAND:
            //Kill dialog and return button id that was pressed.
            EndDialog(hwndDlg, LOWORD(wParam));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


/*
 *  AssertThread
 *	
 *  @mfunc
 *      This is the entry point for the thread created for the
 *      assert dialog.
 *
 *      lParam - Data passed to thread...not used.
 *
 *  @rdesc
 *      Should not return.  It will be explicitly terminated.
 *
 */
DWORD WINAPI AssertThread(LPVOID lParam)
{
    //This should run until it is explicitly terminated in
    //process detach.
    while(TRUE)
    {
		//We go into a wait state until the event is signaled,
		//which means we are handling an assert.
        WaitForSingleObject(hEventAssert1, INFINITE);
        idAssert = DialogBoxParamA(ghMod, MAKEINTRESOURCEA(IDD_ASSERT),
            NULL, AssertProc, (LPARAM)szAssert);
		//The asserting thread will be waiting on this event so
		//set it to allow the asserting thread continue.
        SetEvent(hEventAssert2);
    }

    return 0;
}

/*
 *  AssertSzFn
 *	
 *  @mfunc
 *      Display a message for the user and give the
 *      option to abort, ignore, or ignore all.
 *      Selecting ignore all causes all asserts to be
 *      ignored from that time forward.  It cannot be
 *      reset.  If the assert dialog cannot be created
 *      A message box is used.  The message box has one
 *      button (OK) which will cause an abort.
 *
 *      szFile - the file the warning occured in.
 *      iLine - the line number the warning occured at.
 *      szUserMsg - User define message string
 *
 */
void AssertSzFn(LPSTR szUserMsg, LPSTR szFile, int iLine)
{
    char szModuleName[MAX_PATH];
    char * pszModuleName;
    DWORD pid;
    DWORD tid;
    DWORD dwAssertTID;

    //Check to see if an assert hook has been set. If it has, call
    //it with pointers to all our parameters (they can be modified
    //this way if desired).  If the hook returns false, return.
    //Otherwise, continue with our assert with the potentially
    //modified parameters.
    if (NULL != pfnAssert)
        if (!pfnAssert(szUserMsg, szFile, &iLine))
            return;


    if( NULL == hAssertThrd )
    {
        if( NULL != hEventAssert1 && NULL != hEventAssert2)
        {
            hAssertThrd = CreateThread(NULL, 0, AssertThread,
                NULL, 0, &dwAssertTID);
        }
    }

    //This critical section will prevent us from being entered simultaneously
    //by multiple threads.  This alone will not prevent reentrance by our own thread
    //once the assert dialog is up. Under normal circumstances a special thread
    //exists to run the assert dialog and Event objects are used to halt this
    //thread while the assert dialog is up (see WaitForSingleObject
    //further down).  If the assert thread does not exist, a MessageBox is used
    //and we can be reentered (this is a fallback position and there's
    //not much we can do about it).
    EnterCriticalSection(&csAssert);

    pid = GetCurrentProcessId();
    tid = GetCurrentThreadId();

    //Get the module name to include in assert message.
    if (GetModuleFileNameA(NULL, szModuleName, MAX_PATH))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }


    //Send a message to the debug output and build a string for the
    //assert dialog.  The string depends on whether the user provided
    //a message.
    if (NULL != szUserMsg)
    {
		TRACEASSERTSZ(szUserMsg, szFile, iLine);
        sprintf(szAssert,
            "PROCESS: %s, PID: %d, TID: %d\nFILE: %s (%d)\n%s\n",
             pszModuleName, pid, tid, szFile, iLine, szUserMsg);
    }
    else
    {
		TRACEASSERT(szFile, iLine);
        sprintf(szAssert,
            "PROCESS: %s, PID: %d, TID: %d\nFILE: %s (%d)\n",
             pszModuleName, pid, tid, szFile, iLine);
    }


    //If the user did not disable asserts on a previous assert,
    //put up a dialog with the assert message.
    if (!fIgnoreAsserts)
    {
        idAssert = -1;

		//If we are in the middle of process detach, the assert thread
		//will not execute so pop the dialog here ourselves.  Presumably there
		//is little change of reentrancy at this point.  If we are not
		//in process detach, let the assert thread handle the assert.
		if (fDllDetach)
		{
            idAssert = DialogBoxParamA(ghMod, MAKEINTRESOURCEA(IDD_ASSERT),
                NULL, AssertProc, (LPARAM)szAssert);
		}
        else
        {
            SetEvent(hEventAssert1);
            WaitForSingleObject(hEventAssert2, INFINITE);
        }

        //The assert thread doesn't exist or the dialogbox create failed so
        //use a message box instead.  In this case, since we
        //are obviously having problems, we are only going to
        //give the user one choice...abort.
        if (-1 == idAssert)
        {
            idAssert = MessageBoxA(NULL,
                             szAssert,
                             "Richedit Assert - (retry will be ignored)",
                              MB_SETFOREGROUND | MB_TASKMODAL |
                              MB_ICONEXCLAMATION | MB_ABORTRETRYIGNORE);

            //
            // If id == 0, then an error occurred.  There are two possibilities
            // that can cause the error:  Access Denied, which means that this
            // process does not have access to the default desktop, and everything
            // else (usually out of memory).
            //
            if (!idAssert)
            {
                if (GetLastError() == ERROR_ACCESS_DENIED)
                {
                    //
                    // Retry this one with the SERVICE_NOTIFICATION flag on.  That
                    // should get us to the right desktop.
                    //
                    idAssert = MessageBoxA(   NULL,
                                        szAssert,
                                        "Richedit Assert - (retry will be ignored)",
                                        MB_SETFOREGROUND | MB_TASKMODAL | MB_ICONEXCLAMATION | 
                                        MB_ABORTRETRYIGNORE);

                }
            }
        }

        if (idAssert == ID_IGNOREALL)
        {
            fIgnoreAsserts = TRUE;
        }

        if (idAssert == IDABORT )
        {
            //This will cause a break when debugging, and
            //an exception leading to termination otherwise.
            DebugBreak();
			return;
        }
    }

    LeaveCriticalSection(&csAssert);
}


/*
 *  TabLookup
 *	
 *  @mfunc
 *      This function searches an array of TabElem
 *      structures looking for an entry whose key
 *      matches the one we were given. If found, it
 *      copies the string associated with the key into
 *      the supplied buffer.
 *      
 *      Table - TabElem pointer to start of array.
 *      TabSize - Size of array in bytes.
 *      dwKey - Key to match.
 *      szBuf - Buffer to hold string (assumed MAXDEBUGSTRLEN in size).
 *
 *  @rdesc
 *      FALSE if key not found, TRUE if found.
 *
 */
BOOL TabLookup(TabElem * Table, UINT TabSize, DWORD dwKey, LPSTR szBuf)
{
    BOOL fRet = FALSE;
    UINT cTab, index;
    
    cTab = TabSize/sizeof(TabElem);

    for (index = 0; index < cTab; index++)
    {
        if (Table[index].dwKey == dwKey)
            break;
    }

    if (index < cTab)
    {
        lstrcpyA(szBuf, Table[index].sz);
        fRet = TRUE;
    }

    return fRet;
}

/*
 *  GetHResultSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with a given HRESULT.  This string can then be used
 *      in the output from TraceMsg.
 *      
 *      hr - HRESULT on which the string will be based.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetHResultSz(HRESULT hr, LPSTR szBuf)
{
    // Build string based on FormatMessageA
    if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD)hr,
        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        szBuf, MAXDEBUGSTRLEN, NULL))
    {
        // Build default string
        sprintf(szBuf, "hr = %d: Unrecognized HRESULT.", hr);
    }
    else
    {
        int cch;
        char * pch;

        //Need to get rid of the CRLF from FormatMessageA.
        pch = szBuf;
        cch = strlen(szBuf);
        pch += (cch - 2);
        *pch = '\0';
    }
}


/*
 *  GetParamSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with a param from the text message handler.
 *      This string can then be used in the output from
 *      TraceMsg.
 *      
 *      dwParam - param on which the string will be based.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 */
void GetParamSz(DWORD dwParam, LPSTR szBuf)
{
    char szTemp[MAXDEBUGSTRLEN];

    if (!TabLookup(TrcParamTab, sizeof(TrcParamTab), (DWORD)dwParam, szTemp))
	{
        sprintf(szBuf, "PARAM = %d: Unrecognized PARAM.", dwParam);
	}
	else
	{
        sprintf(szBuf, "PARAM: %s", szTemp);
	}
}

/*
 *  GetDefaultSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with either the value from GetLastError, or with a
 *      default string. This string can then be used in the
 *      output from TraceMsg.
 *      
 *      dwError - Value from GetLastError.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetDefaultSz(DWORD dwError, LPSTR szBuf)
{
    //Check to see if we have an error value
    if (dwError)
    {
        // Build string based on FormatMessageA
        if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError,
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
            szBuf, MAXDEBUGSTRLEN, NULL))
        {
            // Build default string
            lstrcpyA(szBuf, "Reason unknown.");
        }
        else
        {
            int cch;
            char * pch;

            //Need to get rid of the CRLF from FormatMessageA.
            pch = szBuf;
            cch = strlen(szBuf);
            pch += (cch - 2);
            *pch = '\0';
        }
    }
    else
    {
        // Build default string
        lstrcpyA(szBuf, "Reason unknown.");
    }
}

//The following are not used by the release with asserts build
#ifndef _RELEASE_ASSERTS_

/*
 *  GetDataSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string representing
 *      data passed to TraceMsg in one of it's DWORDS data
 *      parameters. This string can then be used in the
 *      output from TraceMsg.
 *      
 *      uDataType - This is the type of data we are dealing with.
 *      dwData - This is the data itself.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetDataSz(UINT uDataType, DWORD dwData, LPSTR szBuf)
{
    switch (uDataType)
    {
        // Data is an HRESULT
        case TRCDATAHRESULT:
            GetHResultSz((HRESULT)dwData, szBuf);
            break;

        // Data is a string (copy to szBuf and pass it through)
        case TRCDATASTRING:
            lstrcpyA(szBuf, (LPSTR)(DWORD_PTR)dwData);
            break;

        // Data is a parameter value
        case TRCDATAPARAM:
            GetParamSz(dwData, szBuf);
            break;

        // Get string based on GetLastError
        case TRCDATADEFAULT:
        default:
            GetDefaultSz(dwData, szBuf);
            break;
    }
}


/*
 *  LogDebugString
 *	
 *  @mfunc
 *      This function writes a string to the log file.  The file must
 *      be opened already and hLogFile must contain the handle.
 *      
 *      szDebugMsg - String to write to log file.
 *
 */
void LogDebugString(LPSTR szDebugMsg)
{
    if ((NULL != hLogFile) && (INVALID_HANDLE_VALUE != hLogFile))
    {
        DWORD dwMsgBytes, dwBytes;

        dwMsgBytes = strlen(szDebugMsg)*sizeof(char);

        //Prevent other threads from trying to write at same time.
        EnterCriticalSection(&csLog);
        SetFilePointer(hLogFile, 0, NULL, FILE_END);
        WriteFile (hLogFile, szDebugMsg, dwMsgBytes, &dwBytes, NULL);
        LeaveCriticalSection(&csLog);
    }
}


/*
 *  TraceMsg
 *	
 *  @mfunc
 *      This is the central message generating facility for
 *      the debug tools.  All messages to the debug output
 *      or log file are generated here. This function takes
 *      a DWORD (dwFlags) that consists of packed values that determine
 *      the kind of message to generated.  It takes two DWORD
 *      data parameters that can contain several different
 *      types of data (string, HRESULT, etc.)  These are interpreted
 *      using dwFlags. It also takes the file and line associated with
 *      the point in the source where it was called.
 *      
 *      dwFlags - Packed values tell us how to generate the message.
 *      dwData1 - The first of two data parameters.
 *      dwData2 - The second of two data parameters.
 *      szFile  - File name we were called from.
 *      iLine   - Line number we were called from.
 *
 */
void TraceMsg(DWORD dwFlags, DWORD dwData1, DWORD dwData2,
    LPSTR szFile, int iLine)
{
    //The following three buffers are used to build our message.
    char szTemp[MAXDEBUGSTRLEN];
    char szTemp2[MAXDEBUGSTRLEN];
    char szDebugMsg[MAXDEBUGSTRLEN];
    char* pch;
    int cch;
    TrcFlags trcf; //Used to decode dwFlags
    DWORD pid;
    DWORD tid;
    DWORD dwError;
    int indent, tls;
    
    //Check to see if a Trace hook has been set. If it has, call
    //it with pointers to all our parameters (they can be modified
    //this way if desired).  If the hook returns false, return.
    //Otherwise, continue with our message output with the potentially
    //modified parameters.
    if (NULL != pfnTrace)
        if (!pfnTrace(&dwFlags, &dwData1, &dwData2, szFile, &iLine))
            return;

    trcf.dw = dwFlags;

    //Return if this is an informational message and they are disabled.
    if ((TRCSEVINFO == trcf.fields.uSeverity) && !fInfo)
        return;

     // Call GetLastError now in case we need it later.
    // This way api calls downstream won't disturb the value
    // we need.
    dwError = GetLastError();
    pid = GetCurrentProcessId();
    tid = GetCurrentThreadId();
    szTemp[0] = '\0';
    szTemp2[0] = '\0';
    szDebugMsg[0] = '\0';

    // Handle indentation (TLSindent is set by CTrace)
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    indent = (tls < 0 ? 0 : tls);
    memset(szDebugMsg, ' ', 2*indent*sizeof(char));
    szDebugMsg[2*indent] = '\0';

    // Handle severity (Warning, Error, etc.)
    if (TRCSEVNONE != trcf.fields.uSeverity)
    {
        sprintf(szTemp, "%s: ", TrcSeverity[trcf.fields.uSeverity]);
        strcat(szDebugMsg, szTemp);
    }
    
    // Interpret the first data value
    if (TRCDATANONE != trcf.fields.uData1)
    {
        if (TRCDATADEFAULT == trcf.fields.uData1)
            dwData1 = dwError;
        GetDataSz(trcf.fields.uData1, dwData1, szTemp2);
        lstrcpyA(szTemp, szDebugMsg);
        wsprintfA(szDebugMsg, "%s%s ", szTemp, szTemp2);
    }

    // Interpret the second data value.
    if (TRCDATANONE != trcf.fields.uData2)
    {
        if (TRCDATADEFAULT == trcf.fields.uData2)
            dwData2 = dwError;
        GetDataSz(trcf.fields.uData2, dwData2, szTemp2);
        lstrcpyA(szTemp, szDebugMsg);
        wsprintfA(szDebugMsg, "%s%s", szTemp, szTemp2);
    }

    if (fVerbose)
    {
        // Handle scope (Internal/External call)
        if (TRCSCOPENONE != trcf.fields.uScope)
        {
            sprintf(szTemp, "SCOPE: %s ", TrcScope[trcf.fields.uScope]);
            strcat(szDebugMsg, szTemp);
        }

        // Handle subsytem (TOM, ITextServices, etc.)
        if (TRCSUBSYSNONE != trcf.fields.uSubSystem)
        {
            sprintf(szTemp, "SUBSYSTEM: %s ", TrcSubsys[trcf.fields.uSubSystem]);
            strcat(szDebugMsg, szTemp);
        }

        // Handle process ID, thread ID, file and line.
        sprintf(szTemp, "PID: %u TID: %u ", pid, tid);
        strcat(szDebugMsg, szTemp);
    }

    // Up to now there is no real danger of overflowing our buffer since
    // we were dealing with strings of small size.  Now we will be running
    // in to paths and user strings.  We will use _snprintf to concatonate
    // new stuff to our message.  This is not the most effecient way since
    // it involves alot of copying, but it is a fairly simple way to keep
    // adding to our string without having to worry about how much room is
    // left in the buffer.  It will truncate if we go past the end.
    if (NULL != szFile)
    {
        lstrcpyA(szTemp, szDebugMsg);

        if (0 != iLine)
        {
            wsprintfA(szDebugMsg, "%sFILE: %s (%u) ",
                szTemp, szFile, iLine);
        }
        else
        {
            wsprintfA(szDebugMsg, "%sFILE: %s ",
                szTemp, szFile);
        }
    }

    // Append a CRLF to the end of the string (make sure we don't overflow)
    cch = strlen(szDebugMsg);
    pch = szDebugMsg;
    if (cch < (MAXDEBUGSTRLEN - 3))
        pch += cch;
    else
        pch += (MAXDEBUGSTRLEN - 3);

    lstrcpyA(pch, "\r\n");

    if (fLogging)
        LogDebugString(szDebugMsg);

    // Write to debug output.
    OutputDebugStringA(szDebugMsg);
}

/*
 *	Tracef
 *
 *	@mfunc:
 *      The given format string and parameters are used to render a
 *      string into a buffer. This string is passed to TraceMsg.
 *      The severity parameter determines the type of message.  The
 *      following values are valid: TRCSEVWARN, TRCSEVERR, TRCSEVINFO.
 *	
 *	Arguments:
 *      dwSev   Severity of message.
 *		szFmt	Format string for wvsprintf (qqv)
 */
void Tracef(DWORD dwSev, LPSTR szFmt, ...)
{
	va_list	valMarker;
    char rgchTraceTagBuffer[MAXDEBUGSTRLEN];

	//	format out a string
	va_start(valMarker, szFmt);
	wvsprintfA(rgchTraceTagBuffer, szFmt, valMarker);
	va_end(valMarker);

	if (dwSev == TRCSEVERR)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else if (dwSev == TRCSEVWARN)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
    else if (dwSev == TRCSEVINFO)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVINFO, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else if (dwSev == TRCSEVMEM)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVMEM, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVNONE, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
}

/*
 *	TraceError
 *
 *	@mfunc:
 *		This function is for compatibility with old debug functionality.
 *      An error message is generated and sent to TraceMsg.
 *	
 */
void TraceError(LPSTR sz, LONG sc)
{
	if (FAILED(sc))
	{
        char rgchTraceTagBuffer[MAXDEBUGSTRLEN];

		wsprintfA(rgchTraceTagBuffer,
				  "%s, error=%ld (%#08lx).", sz, sc, sc);
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	}
}

/*
 *  CheckTrace
 *	
 *  @mfunc
 *      This function checks to see if tracing should be performed
 *      in a function given the debug options set and the subsystem
 *      the function is in.
 *      ptrcf   - Pointer to TrcFlags structure passed to CTrace.
 *
 *  @rdesc
 *      True if tracing should be performed, false otherwise.
 *
 */
static BOOL CheckTrace(TrcFlags * ptrcf)
{
    DWORD dwOpt;

    //Set dwOpt to the correct value for the subsytem we are
    //in.
    switch (ptrcf->fields.uSubSystem)
    {
        case TRCSUBSYSDISP: dwOpt = OPTTRACEDISP;   break;
        case TRCSUBSYSWRAP: dwOpt = OPTTRACEWRAP;   break;
        case TRCSUBSYSEDIT: dwOpt = OPTTRACEEDIT;   break;
        case TRCSUBSYSTS:   dwOpt = OPTTRACETS;     break;
        case TRCSUBSYSTOM:  dwOpt = OPTTRACETOM;    break;
        case TRCSUBSYSOLE:  dwOpt = OPTTRACEOLE;    break;
        case TRCSUBSYSBACK: dwOpt = OPTTRACEBACK;   break;
        case TRCSUBSYSSEL:  dwOpt = OPTTRACESEL;    break;
        case TRCSUBSYSHOST: dwOpt = OPTTRACEHOST;   break;
        case TRCSUBSYSDTE:  dwOpt = OPTTRACEDTE;    break;
        case TRCSUBSYSUNDO: dwOpt = OPTTRACEUNDO;   break;
        case TRCSUBSYSRANG: dwOpt = OPTTRACERANG;   break;
        case TRCSUBSYSUTIL: dwOpt = OPTTRACEUTIL;   break;
        case TRCSUBSYSNOTM: dwOpt = OPTTRACENOTM;   break;
        case TRCSUBSYSRTFR: dwOpt = OPTTRACERTFR;   break;
        case TRCSUBSYSRTFW: dwOpt = OPTTRACERTFW;   break;
        case TRCSUBSYSPRT:  dwOpt = OPTTRACEPRT;    break;
        case TRCSUBSYSFE:   dwOpt = OPTTRACEFE;     break;
        case TRCSUBSYSFONT: dwOpt = OPTTRACEFONT;   break;
        default:
             return FALSE;
    }

    //If there is no tracing at any level enabled, return false.
    if (!ISOPTSET(dwOpt) && !fTrace
        && !(fTraceExt && (ptrcf->fields.uScope == TRCSCOPEEXTERN)))
        return FALSE;

    return TRUE;
}

/*
 *  CTrace::CTrace
 *	
 *  @mfunc
 *      This constructor is used to generate output about the function
 *      it is called from.  Creating an instance of this class on the
 *      stack at the beginning of a function, will cause a trace message
 *      to be sent to the debug output.  When the function returns, the
 *      destructor will be called automatically and another message
 *      will be sent to the debug output.
 *      This constructor takes several parameters to pass on to
 *      TraceMsg and it also stores certain data for use by the destructor.
 *      
 *      dwFlags - Packed values tell us how to generate the message.
 *      dw1     - The first of two data parameters.  This must be
 *                the name of the function we were called from.
 *      dw2     - The second of two data parameters.  This will be either
 *                unused or it will be a parameter to be interpreted by
 *                TraceMsg.
 *      szFile  - File name we were called from.
 *
 */
CTrace::CTrace(DWORD dwFlags, DWORD dw1, DWORD dw2, LPSTR szFile)
{
    char szFunc[80];
    int tls;

    trcf.dw = dwFlags;

    //Return if tracing is not enabled.
    if (!CheckTrace(&trcf))
        return;

    //Increment indentation level on entrance to function
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    tls++;
    TlsSetValue(TlsIndex, (LPVOID)(DWORD_PTR)tls);

    szFunc[0] = '\0';
    lstrcpyA(szFileName, szFile);
    lstrcpyA(szFuncName, (LPSTR)(DWORD_PTR)dw1);

    sprintf(szFunc, "IN : %s.", szFuncName);

    TraceMsg (trcf.dw, (DWORD)(DWORD_PTR)szFunc, dw2, szFileName, 0);
}


/*
 *  CTrace::~CTrace
 *	
 *  @mfunc
 *      This destructor is used to generate output about the function
 *      it is called from.  Creating an instance of this class on the
 *      stack at the beginning of a function, will cause a trace message
 *      to be sent to the debug output.  When the function returns, the
 *      destructor will be called automatically and another message
 *      will be sent to the debug output.
 *
 *
 */
CTrace::~CTrace()
{
    char szFunc[80];
    int tls;

    //Return if tracing is not enabled.
    if (!CheckTrace(&trcf))
        return;

    szFunc[0] = '\0';
    sprintf(szFunc, "OUT: %s.", szFuncName);

    trcf.fields.uData2 = TRCDATANONE;
    TraceMsg (trcf.dw, (DWORD)(DWORD_PTR)szFunc, 0, szFileName, 0);

    //Decrement indentation level on exit from function
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    tls--;
    TlsSetValue(TlsIndex, (LPVOID)(DWORD_PTR)tls);
}

#endif //!_RELEASE_ASSERTS_

#endif // NOFULLDEBUG

#endif // !!(DEBUG) && !! _RELEASE_ASSERTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\disp.cpp ===
/*
 *	DISP.CPP
 *	
 *	Purpose:
 *		CDisplay class
 *	
 *	Owner:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *		Jon Matousek - smooth scrolling.
 *		Keith Curtis - cleanup metafile handling, generalized textflow support,
 *		changed our clipping model to work better with italics.
 *
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_disp.h"
#include "_edit.h"
#include "_select.h"
#include "_font.h"
#include "_measure.h"
#include "_osdc.h"
#include "_dfreeze.h"

ASSERTDATA

// Decimal point precision of smooth scrolling calculations.
#define SMOOTH_PRECISION (100000L)


// ===========================  Invariant stuff  ======================================================

#define DEBUG_CLASSNAME CDisplay
#include "_invar.h"

#ifdef DEBUG
BOOL
CDisplay::Invariant( void ) const
{
	AssertSz(_dvpView >= 0, "CDisplay::Invariant invalid _dvpView");
	AssertSz(_dvpClient	>= 0, 
		"CDisplay::Invariant invalid _dvpClient");

	return TRUE;
}
#endif


// Auto scroll constants
#define dwAutoScrollUp		1
#define dwAutoScrollDown	2
#define dwAutoScrollLeft	3
#define dwAutoScrollRight	4


//Text flow utility functions

void GetDupDvpFromRect(const RECT &rc, TFLOW tflow, LONG &dup, LONG &dvp)
{
	LONG dxp = rc.right - rc.left;
	LONG dyp = rc.bottom - rc.top;
	if (!IsUVerticalTflow(tflow)) //Normal case
	{
		dup = dxp;
		dvp = dyp;
	}
	else
	{
		dup = dyp;
		dvp = dxp;
	}
}

void GetDxpDypFromDupDvp(LONG dup, LONG dvp, TFLOW tflow, LONG &dxp, LONG &dyp)
{
	switch(tflow)
	{
	case tflowES:
		dxp = dup;
		dyp = dvp;
		break;
	case tflowSW:
		dxp = -dvp;
		dyp = dup;
		break;
	case tflowWN:
		dyp = -dvp;
		dxp = -dup;
		break;
	case tflowNE:
		dyp = -dup;
		dxp = dvp;
		break;
	default:
		Assert(0);
	}
}

void GetDxpDypFromRectuv(const RECTUV &rc, TFLOW tflow, LONG &dxp, LONG &dyp)
{
	LONG dup = rc.right - rc.left;
	LONG dvp = rc.bottom - rc.top;
	if (!IsUVerticalTflow(tflow)) //Normal case
	{
		dxp = dup;
		dyp = dvp;
	}
	else
	{
		dxp = dvp;
		dyp = dup;
	}
}

// ===========================  CLed  =====================================================


void CLed::SetMax(const CDisplay * const pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLed::SetMax");

	_cpMatchNew	 = _cpMatchOld	= pdp->_ped->GetTextLength();
	_iliMatchNew = _iliMatchOld = max(0, pdp->LineCount() - 1);
	_vpMatchNew	 = _vpMatchOld	= pdp->GetHeight();
}


// ===========================  CDisplay  =====================================================


DWORD 	CDisplay::_dwTimeScrollNext;	// time for next scroll step
DWORD 	CDisplay::_dwScrollLast;		// last scroll action

/*
 *	CDisplay::ConvertScrollToUPos(uPos)
 *
 *	@mfunc	
 *		Calculate real scroll position from scroll position
 *
 *	@rdesc
 *		X position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 */
LONG CDisplay::ConvertScrollToUPos(
	LONG uPos)		//@parm Scroll position 
{
	LONG uMax = GetMaxUScroll();

	// Has maximum scroll range exceeded 16-bits?
	if (uMax >= _UI16_MAX)
	{
		// Yes - Extrapolate to the "real" x Positioin
		uPos = MulDiv(uPos, uMax, _UI16_MAX);
	}
	return uPos;
}

/*
 *	CDisplay::ConvertUPosToScrollPos(uPos)
 *
 *	@mfunc	
 *		Calculate scroll position from X position in document.
 *
 *	@rdesc
 *		Scroll position from X position
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 *
 */
LONG CDisplay::ConvertUPosToScrollPos(
	LONG uPos)		//@parm Y position in document
{
	LONG uMax = GetMaxUScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(uMax >= _UI16_MAX)
	{
		// Yes - Extrapolate to the scroll bar position		
		uPos = MulDiv(uPos, _UI16_MAX, uMax);
	}
	return uPos;
}

/*
 *	CDisplay::ConvertVPosToMax(vPos)
 *
 *	@mfunc	
 *		Calculate the real scroll position from the scroll position
 *
 *	@rdesc
 *		V position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the V position
 *		gets greater than that.
 */
LONG CDisplay::ConvertVPosToScrollPos(
	LONG vPos)		//@parm Scroll position 
{
	// Default is single line edit control which cannot have Y-Scroll bars
	return 0;
}

CDisplay::CDisplay (CTxtEdit* ped) :
	CDevDesc (ped)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::CDisplay");

	_TEST_INVARIANT_
	_fRecalcDone = TRUE;
}

CDisplay::~CDisplay()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::~CDisplay");
				 
	_TEST_INVARIANT_
	
	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Remove(this);

	CheckRemoveSmoothVScroll();

	if (_padc)
		delete _padc;

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif
}

/*
 *	CDisplay::InitFromDisplay(pdp)
 *
 *	@mfunc initialize this display from another display instance.
 *
 *	@comment
 *			copy *only* the members that will remain constant
 *		   	between two different display instances.  Currently, that
 *			is only the view variables and device descriptor info.
 */
void CDisplay::InitFromDisplay(
	const CDisplay *pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::InitFromDisplay");

	_dupView	= pdp->_dupView;
	_dvpView	= pdp->_dvpView;
	_dvpClient	= pdp->_dvpClient;

	// Don't save DC; just coordinate information.
	_dxpInch		= pdp->_dxpInch;
	_dypInch		= pdp->_dypInch;

	SetTflow(pdp->GetTflow());
	// If display we are copying from is active display,
	// then this new display is the active display.
	_fActive		= pdp->_fActive;
}

/*
 *	CDisplay::Init()
 *
 *	@mfunc Initializes CDisplay
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplay::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::Init");

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Add(this);

	return TRUE;
}

/*
 *	CDisplay::GetSelBarInPixels()
 *
 *	@mfunc
 *		Helper that returns size of selection bar in device units.
 *
 *	@rdesc
 *		Size of selection bar (is 0 if none).
 */
LONG CDisplay::GetSelBarInPixels() const
{
	return HimetricUtoDU(_ped->TxGetSelectionBarWidth());
}


//================================  Device drivers  ===================================
/*
 *	CDisplay::SetMainTargetDC(hdc, dulTarget)
 *
 *	@mfunc
 *		Sets a target device for this display and updates view 
 *
 *  Note:
 *      No support for targetDC in the base CDisplay class.
 *
 *	Note:
 *		Target device can't be a metafile (can get char width out of a 
 *		metafile)
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::SetMainTargetDC(
	HDC	 hdc,			//@parm Target DC, NULL for same as rendering device
	LONG dulTarget)		//@parm Max width of lines (not used if target device is screen)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetMainTargetDC");

	_TEST_INVARIANT_

	return TRUE;
}

BOOL CDisplay::SetTargetDC(
	HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetTargetDC");

	_TEST_INVARIANT_

	return TRUE;
}

/* 
 *	CDisplay::SetDrawInfo(pdi, dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev)
 *
 *	@mfunc
 *		Sets the drawing information into the display
 *
 *	@rdesc	
 *		void - this cannot fail
 *
 *	@devnote
 *		The key point to this routine is that the caller of this routine
 *		is the owner of the memory for the drawing information. It is the
 *		callers responsiblity to call ReleaseDrawInfo to tell the display
 *		that it is done with the drawing information.
 */
void CDisplay::SetDrawInfo(
	CDrawInfo *pdi,		//@parm memory for draw info if there is not one already
	DWORD dwDrawAspect,	//@parm draw aspect
	LONG  lindex,		//@parm currently unused
	void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,//@parm information on target device								
	HDC hicTargetDev)	//@parm	target information context
{
	HDC hicTargetToUse = hicTargetDev;
	const CDevDesc *pdd;

	// Set up the target device if we need to use the default
	if ((NULL == hicTargetToUse))
	{
		pdd = GetDdTarget();
		if(pdd)
			hicTargetToUse = pdd->GetDC();	
	}

	if (NULL == _pdi)
	{
		// Draw structure not yet allocated so use the one
		// passed in
		_pdi = pdi;
	}

	// Reset the parameters
	_pdi->Init(
		dwDrawAspect,
		lindex,
		pvAspect,
		ptd,
		hicTargetToUse);
}

/* 
 *	CDisplay::ReleaseDrawInfo ()
 *
 *	@mfunc
 *		Releases drawing information from display
 *
 *	@rdesc	
 *		void - this cannot fail
 *
 *	@devnote
 *		Since the display does not own the memory for the drawing information,
 *		this only NULLs out the pointer in the drawing information pointer. It
 *		is the responsiblity of the caller to free the memory for the drawing
 *		information.
 */
void CDisplay::ReleaseDrawInfo()
{
	if(_pdi && !_pdi->Release())
	{
		// This object is no longer referenced so we toss our reference.
		_pdi = NULL;
	}
}

/* 
 *	CDisplay::GetTargetDev ()
 *
 *	@mfunc
 *		Get the target device if one is available
 *
 *	@rdesc	
 *		Pointer to device description object or NULL if none is available.
 *
 *	@devnote
 *		This uses the draw info if it is available and then the main target DC
 *		if it is available.
 */
const CDevDesc*CDisplay::GetTargetDev() const
{
	const CDevDesc *pdd = NULL;

	if(_pdi && _pdi->GetTargetDD())
		pdd = _pdi->GetTargetDD();

	return pdd ? pdd : GetDdTarget();
}


//================================  Background Recalc  ===================================
/*
 *	CDisplay::StepBackgroundRecalc()
 *
 *	@mfunc
 *		Steps background line recalc (at GetCp()CalcMax position)
 *		Called by timer proc. No effect for base class
 *
 *	??? CF - Should use an idle thread
 */
void CDisplay::StepBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::StepBackgroundRecalc");

	_TEST_INVARIANT_
}

/*
 *	CDisplay::WaitForRecalc(cpMax, vpMax)
 *
 *	@mfunc
 *		Ensures that lines are recalced until a specific character
 *		position or vPos. Always TRUE for base CDisplay class.
 *						
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::WaitForRecalc(
	LONG cpMax,		//@parm Position recalc up to (-1 to ignore)
	LONG vpMax)		//@parm vPos to recalc up to (-1 to ignore)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalc");

	_TEST_INVARIANT_

	return TRUE;
}

/*
 *	CDisplay::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Returns TRUE if lines were recalc'd up to ili
 *      Always the case for base CDisplay class.
 */
BOOL CDisplay::WaitForRecalcIli(
	LONG ili)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalcIli");

	_TEST_INVARIANT_

    return TRUE;
}

/*
 *	CDisplay::WaitForRecalcView()
 *
 *	Purpose
 *		Ensure visible lines are completly recalced
 *      Always the case for base CDisplay class
 */
BOOL CDisplay::WaitForRecalcView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalcView");

	_TEST_INVARIANT_

	return TRUE;
}


//====================================  Rendering  =======================================
/*
 * 	CDisplay::Draw(hdcDraw, hicTargetDev, prcClient, prcWBounds,
 *				   prcUpdate, pfnContinue, dwContinue)
 *	@mfunc
 *		General drawing method called by IViewObject::Draw() or in
 *		response to WM_PAINT
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT	CDisplay::Draw(
	HDC		hdcDraw,			//@parm	Rendering device context
	HDC		hicTargetDev,		//@parm	Target information context
	LPCRECT	prcClient,			//@parm	Bounding (client) rectangle
	LPCRECT	prcWBounds,			//@parm Clipping rect for metafiles
    LPCRECT prcUpdate,			//@parm	Dirty rect inside prcClient
	BOOL (CALLBACK *pfnContinue)(DWORD),//@parm Callback for interrupting
								//	long display (currently unused)
	DWORD	dwContinue)			//@parm	Param to pass to pfnContinue
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::Draw");

	_TEST_INVARIANT_

	HRESULT hr = S_OK;

	// Store current depth in drawing locally so we can tell
	// whether we need to actually render.
	DWORD dwDepthThisDraw = _pdi->GetDrawDepth();

    RECTUV rcView, rcClient, rcRender;
	CTxtSelection *psel = _ped->GetSelNC();

	if(!prcWBounds)		// No metafile, so just set rendering DC
	{
		if(!SetDC(hdcDraw))
		{
			hr = E_FAIL;
			goto Cleanup;
		}
	}
	else				// Rendering to a metafile
	{
		//Forms^3 draws using screen resolution, while OLE specifies HIMETRIC
		long dxpInch = GetPed()->fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
		long dypInch = GetPed()->fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

		SetWindowOrgEx(hdcDraw, prcWBounds->left, prcWBounds->top, NULL);
		SetWindowExtEx(hdcDraw, prcWBounds->right, prcWBounds->bottom, NULL);

		SetMetafileDC(hdcDraw, dxpInch, dypInch);
	}

    // Get client rect
    if(prcClient)
		RectuvFromRect(rcClient, *prcClient);
    else
    {
        AssertSz(_ped->_fInPlaceActive, 
        	"CDisplay::GetViewRect() - Not in-place and !prcClient");
        _ped->TxGetClientRect(&rcClient);
    }

	// Compute view rectangle (rcView) from client rectangle (account for
	// inset and selection bar width)
  	GetViewRect(rcView, &rcClient);

	// If this view is not active and it is not to be recalc'd then
	// we only decide to use it if the size matches and return S_FALSE
	// if it doesn't so the caller can create a new display to use for
	// drawing.
	if(!IsActive() && !_fNeedRecalc)
	{
		if (rcView.right - rcView.left != GetDupView() ||
			rcView.bottom - rcView.top != GetDvpView())
		{
			hr = S_FALSE;
			goto Cleanup;
		}
	}

	// Make sure our client rectangle is set correctly.
	_dvpClient = rcClient.bottom - rcClient.top;

    // Recalc view 
    // bug fix #5521
    // RecalcView can potentially call RequestResize which would
    // change the client rect.  Send rect down to update the client rect
    if(!RecalcView(rcView, &rcClient))
		goto Cleanup;

	if(dwDepthThisDraw != _pdi->GetDrawDepth())
	{
		// A draw happened recursively to this draw. Therefore,
		// the screen has already been rendered so we don't need
		// to do anything more here.
		goto Cleanup;
	}

    // Compute rect to render
    if(!prcUpdate)						// Update full view
        rcRender = rcClient;			
	else								// Clip rendering to client rect 
	{
		RECTUV rcUpdate;
		RectuvFromRect(rcUpdate, *prcUpdate);
        if(!IntersectRect(&rcRender, &rcClient, &rcUpdate))
            goto Cleanup;
    }
    
    if(psel)
        psel->ClearCchPending();

    if(IsMain())
        _ped->TxNotify(EN_UPDATE, NULL);

    // Now render
    Render(rcView, rcRender);

	// Update cursor if we need to
	if(_fUpdateCaret)
	{
		// The caret only belongs in an active view with
		// a selection on a control that has the focus
		if (IsActive() && psel && _ped->_fFocus)
		{
			// Update the caret if there is a selection object.
			// Note: we only scroll the caret into view, if
			// it was previously in the view. This avoids having
			// window pop to caret if it is resized and the
			// caret is not in the view.
			psel->UpdateCaret(psel->IsCaretInView());
		}
		_fUpdateCaret = FALSE;
	}

Cleanup:

   	// Reset DC in device descriptor
 	ResetDC();

	return hr;
}	


//====================================  View Recalc  ===================================
/*
 *	CDisplay::UpdateViewRectState(prcClient)
 *
 *	@mfunc	Compares new view to cached and updates the view as well as the
 *	what type of view recalculation needs to occur.
 */
void CDisplay::UpdateViewRectState(
	const RECTUV *prcClient)	//@parm New client rectangle
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateViewRectState");

	LONG dupView = prcClient->right - prcClient->left;
	LONG dvpView = prcClient->bottom -  prcClient->top;

    // Check whether the view rect has changed since last rendering
    // If width has changed, need complete line recalc.
    // If height has changed, recalc all visible and update scrollbars
    if(dupView != _dupView)
    {
		_dupView = dupView;

        _fViewChanged = TRUE;            
        _fNeedRecalc = TRUE;    // need full recalc
    }

    if(dvpView != _dvpView) 
    {
        _dvpView = dvpView;

		// The height can go negative when there is an inset and
		// the client rect is very small. We just set it to 0 because
		// that is the smallest the view can actually get.
		if (_dvpView < 0)
			_dvpView = 0;

        _fViewChanged = TRUE;
    } 
}

/*
 *	CDisplay::RecalcView(rcView)
 *
 *	@mfunc
 *		RecalcView after the view rect changed
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::RecalcView (
	const RECTUV &rcView, RECTUV* prcClient)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::RecalcView");

	_TEST_INVARIANT_

	// Update the x and y coordinates of the view based on the client rect
	UpdateViewRectState(&rcView);

	// Ensure lines are recalced
	if(_fNeedRecalc)
	{
		// Display got recalculated so the caret needs to be repositioned.
		_fUpdateCaret = TRUE;
    	return RecalcView(TRUE, prcClient);
	}
	if(_fViewChanged)
	{
		// The scroll bars are up to date so we can turn off the notification.
		_fViewChanged = FALSE;

		// A height change was noticed in UpdateViewRectState so make sure
		// the horizontal scroll bar (if any is correct).
		UpdateScrollBar(SB_VERT);
	}
    return WaitForRecalcView();
}


//====================================  View Update  ===================================

/*
 *	CDisplay::UpdateView()
 *
 *	@mfunc
 *		Fully recalc all lines and update the visible part of the display 
 *		(the "view") on the screen.
 *
 *	Returns:
 *		TRUE if success
 */
BOOL CDisplay::UpdateView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateView");

	_TEST_INVARIANT_

	if(_fNoUpdateView)
		return TRUE;

	if(!_ped->_fInPlaceActive)
    {
        // If not active, just invalidate everything
        InvalidateRecalc();
        _ped->TxInvalidate();
		_ped->TxUpdateWindow();
        return TRUE;
    }

	if(_ped->_pdp->IsFrozen())
	{
		_ped->_pdp->SetNeedRedisplayOnThaw(TRUE);
		return TRUE;
	}

	// If we get here, we are updating some general characteristic of the
	// display and so we want the cursor updated as well as the general
	// change; otherwise the cursor will land up in the wrong place.
	_fUpdateCaret = TRUE;

	RECTUV rcView;

	// Get view rectangle
  	GetViewRect(rcView);

	// Update size of view, which could have changed
	UpdateViewRectState(&rcView);

	if(!CDevDesc::IsValid())
	{
		// Make our device valid
		SetDC(NULL);
	}

    // Recalc everything
    RecalcView(TRUE);

	// Invalidate entire view
	_ped->TxInvalidate();
	
	return TRUE;
}

/*
 *	CDisplay::RoundToLine(hdc, width, pheight)
 *
 *	@mfunc
 *		Calculate number of default lines to fit in input height
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT CDisplay::RoundToLine(
	HDC hdc, 	//@parm DC for the window
	LONG dup,	//@parm in - width of window; out max width
	LONG *pdvp)	//@parm in - proposed height; out - actual
{
	CLock lock;					// Uses global (shared) FontCache
	SetDC(hdc);					// Set DC

	// Set height temporarily so zoom factor will work out
	LONG dvpOrigHeightClient = SetClientHeight(*pdvp);

	// Use this to adjust for inset height
	LONG dvpAdjForInset = *pdvp;

	// Get rectangle adjusted for insets
	GetViewDim(dup, *pdvp);

	// Save proposed height
	LONG dvpProposed = *pdvp;

	// Calc inset adjusted height
	dvpAdjForInset -= dvpProposed;

	// Get font
	const CCharFormat *pCF = _ped->GetCharFormat(-1);
	Assert(pCF);

	// Get font cache object
	LONG dvpInch = GetDeviceCaps(hdc, LOGPIXELSY);
	dvpInch = Zoom(dvpInch);

	CCcs *pccs = _ped->GetCcs(pCF, dvpInch);
	LONG dvpAdjustFE = pccs->AdjustFEHeight(!_ped->fUseUIFont() && IsMultiLine());
	
	// Get height of font
	LONG dvpFont = pccs->_yHeight + (dvpAdjustFE << 1);

	pccs->Release();

	// Figure out how many lines fit into the input height
	LONG cLines = dvpProposed / dvpFont;

	// See if we need to round up
	if(dvpProposed % dvpFont|| !cLines)
		cLines++;

	// Set height to new value
	*pdvp = dvpFont * cLines + dvpAdjForInset;

	// Set client height back to what it was
	SetClientHeight(dvpOrigHeightClient);

	// Reset the DC
	ResetDC();

	return NOERROR;
}


/*
 * 	CDisplay::RequestResize()
 *
 *	@mfunc
 *		Forces the control to resize vertically so that all text fit into it
 *
 *	@rdesc
 *		HRESULT = (autosize) ? TxNotify(EN_REQUESTRESIZE, &resize) : S_OK
 */
HRESULT CDisplay::RequestResize()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::RequestResize");

	_TEST_INVARIANT_

	CTxtEdit *	ped = GetPed();

	if (IsActive())
		ped->TxShowCaret(FALSE);

	if(ped->TxGetAutoSize())
	{
		REQRESIZE resize;
		LONG dup, dvp;

		// If word wrapping is on, then the width is the normal
		// client width.  Otherwise, it's the width of the longest
		// line.
		dup = GetWordWrap() ? _dupView : GetDupLineMax() + ped->GetCaretWidth();

		// Get view inset for adjusting width
	 	RECTUV rcInset;
		ped->TxGetViewInset(&rcInset, this);
		
		resize.nmhdr.hwndFrom = NULL;
		resize.nmhdr.idFrom = NULL;
		resize.nmhdr.code = EN_REQUESTRESIZE;

		resize.rc.top = resize.rc.left = 0;
		dvp = GetResizeHeight();

		// 1.0 COMPATABILITY
        // 1.0 included the borders when requesting resize
        if (ped->Get10Mode())
        {
            AssertSz(ped->fInplaceActive(), "In 1.0 mode but not inplace active!!");
            HWND hwnd = NULL;
            ped->TxGetWindow(&hwnd);
            if (hwnd)
            {
                RECT rcClient, rcWindow;
                ped->TxGetClientRect(&rcClient);                
                GetWindowRect(hwnd, &rcWindow);
                dvp += max(rcWindow.bottom - rcWindow.top - rcClient.bottom, 0);
				dvp += rcInset.bottom + rcInset.top;
                dup = rcWindow.right - rcWindow.left;
            }
        }
		else
		{
			// Adjust width by inset and selection bar 
			dup += rcInset.left + rcInset.right	+ GetSelBarInPixels();
		}

		if (IsUVerticalTflow(GetTflow()))
		{
			resize.rc.right = dvp;
			resize.rc.bottom = dup;
		}
		else
		{
			resize.rc.right = dup;
			resize.rc.bottom = dvp;
		}
  
  		return ped->TxNotify(EN_REQUESTRESIZE, &resize);
	}
	return S_OK;
}
/*
 *	CDisplay::GetViewRect(RECTUV &rcView, LPCRECT prcClient)
 *
 *	@mfunc
 *		Compute and return the view rectangle in window's client 
 *      area coordinates.
 *
 *	@comm
 *      prcClient is client rect (in window's client coords), which can be
 *		NULL if we are in-place.
 */
void CDisplay::GetViewRect(
	RECTUV &rcView,		//@parm Reference to rect to return
	const RECTUV *prcClient)	//@parm Client rect (in window's client coords)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetViewRect");

	_TEST_INVARIANT_

	RECTUV rcInset;
    
    // If client rect wasn't passed in, get it from host
    if(prcClient)
        rcView = *prcClient;
    else
    {
        AssertSz(_ped->_fInPlaceActive,	"CDisplay::GetViewRect() - Not in-place and !prcClient");
        _ped->TxGetClientRect(&rcView);
    }

	//REVIEW (keithcu) GetViewRect has side affects?!
	_dvpClient = rcView.bottom - rcView.top;
    
    _ped->TxGetViewInset(&rcInset, this);
    
    rcView.left	  += rcInset.left;			// Add in inset offsets
    rcView.top	  += rcInset.top;			// rcView is in device coords
    rcView.right  -= rcInset.right;
    rcView.bottom -= rcInset.bottom;

	// Add in selection bar space
	long dupSelBar = GetSelBarInPixels();
	if (_ped->IsSelectionBarRight())
		rcView.right -= dupSelBar;
	else
		rcView.left += dupSelBar;
}


//===============================  Scrolling  ==============================

/*
 *	CDisplay::VScroll(wCode, vPos)
 *
 *	@mfunc
 *		Scroll the view vertically in response to a scrollbar event
 *      >>> Should be called when in-place active only <<<
 *
 *  Note:
 *      No support for vertical scroll in base CDisplay. No action.
 *
 *	@rdesc
 *		LRESULT formatted for WM_VSCROLL message		
 */
LRESULT CDisplay::VScroll(
	WORD wCode,	   //@parm Scrollbar event code
	LONG vPos)	   //@parm Thumb position (vPos < 0 for EM_SCROLL behavior)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::VScroll");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::UScroll(wCode, uPos)
 *
 *	@mfunc
 *		Scroll uPos in response to a scrollbar event
 *      >>> Should be called when in-place active only <<<
 */
void CDisplay::UScroll(
	WORD wCode,	   //@parm Scrollbar event code
	LONG uPos)	   //@parm Thumb position 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UScroll");

	_TEST_INVARIANT_

	BOOL fTracking = FALSE;
	LONG upScroll = _upScroll;

	if (uPos != 0)
	{
		// Convert x position from scroll bar to offset horizontally
		// in the document.
		uPos = ConvertScrollToUPos(uPos);
	}
    
    AssertSz(_ped->_fInPlaceActive, "CDisplay::UScroll() called when not in place");

	switch(wCode)
	{
	case SB_BOTTOM:
		upScroll = GetDupLineMax();
		break;

	case SB_LINEDOWN:
		// Future: Make this depend on a the current first visible character
		upScroll += GetDupSystemFont();
		break;

	case SB_LINEUP:
		// Future: Make this depend on a the current first visible character
		upScroll -= GetDupSystemFont();
		break;

	case SB_PAGEDOWN:
		upScroll += _dupView;
		break;

	case SB_PAGEUP:
		upScroll -= _dupView;
		break;

	case SB_THUMBTRACK:
	case SB_THUMBPOSITION:
		if(uPos < 0)
			return;
		upScroll = uPos;
		fTracking = TRUE;
		break;

	case SB_TOP:
		upScroll = 0;
		break;

	case SB_ENDSCROLL:
		UpdateScrollBar(SB_HORZ);
		return;

	default:
		return;
	}

	if (upScroll < 0)
	{
		// upScroll is the new proposed scrolling position and
		// therefore cannot be less than 0.
		upScroll = 0;
	}

	ScrollView(upScroll, -1, fTracking, FALSE);

	// force position update if we just finished a track
	if(wCode == SB_THUMBPOSITION)
		UpdateScrollBar(SB_HORZ);
}


/*
 *	CDisplayML::SmoothVScroll ( int direction, WORD cLines,
 *								int speedNum, int speedDenom, BOOL fAdditive )
 *
 *	@mfunc
 *		Setup to handle fractional scrolls, at a particular speed. This was
 *		probably initiated via a Magellan mouse roller movement, or a MButton
 *		down message.
 */
void CDisplay::SmoothVScroll ( int direction, WORD cLines, int speedNum, int speedDenom, BOOL fMouseRoller )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::SmoothVScroll");

	int vDelta;
	int cLinesAndDir;

	int	smoothVDelta;

	Assert ( speedDenom );

	if ( IsVScrollEnabled() )						// Can scroll vertically?
	{
		_fFinishSmoothVScroll = FALSE;				// We're smoothing again.

													// Get total pixels.
		if ( CheckInstallSmoothVScroll() )			// Install periodic update
		{
			_totalSmoothVScroll		= 0;
			_nextSmoothVScroll		= 0;
		}
													// Pixels per epoch
		cLinesAndDir = (direction < 0) ? cLines : -cLines;

		if( cLines )
		{
			vDelta = CalcVLineScrollDelta ( cLinesAndDir, FALSE );
		}
		else
		{
			vDelta = (direction < 0 ) ? _dvpClient : -_dvpClient;
			cLines = 1;		// for the MulDiv calculation below.
		}

		if ( vDelta )								// If something to scroll.
		{
			smoothVDelta = MulDiv( SMOOTH_PRECISION,// NB-Because no FLOAT type
								MulDiv(vDelta, speedNum, speedDenom), cLines);

			_smoothVDelta				= smoothVDelta;
			if ( fMouseRoller )						// roller event.
			{										//  -> additive.
				_totalSmoothVScroll		+= vDelta;
				_continuedsmoothVDelta	= 0;
				_continuedSmoothVScroll	= 0;
			}										// mButton event
			else
			{
				if ( 0 == _totalSmoothVScroll )
					_totalSmoothVScroll	= vDelta;

				_continuedsmoothVDelta	= smoothVDelta;
				_continuedSmoothVScroll	= vDelta;	
			}
		}
	}
}

/*
 *	CDisplay::SmoothVScrollUpdate()
 *
 *	@mfunc
 *		Supports SmoothVScroll. Scroll a small number of pixels.
 *		We are called via a periodic timing task.
 */
void CDisplay::SmoothVScrollUpdate()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::SmoothVScrollUpdate");

	LONG	vDelta;									//  Magellan mouse.
	BOOL	fImmediateUpdate = FALSE;
	
	_nextSmoothVScroll += _smoothVDelta;
													// Remove fractional amt.
	vDelta = _nextSmoothVScroll / SMOOTH_PRECISION;

													// Don't overshoot.
	if ( 0 == _continuedSmoothVScroll
		&& (	(_totalSmoothVScroll <= 0 && vDelta < _totalSmoothVScroll)
			||	(_totalSmoothVScroll >= 0 && vDelta > _totalSmoothVScroll)) )
	{
		vDelta = _totalSmoothVScroll;
	}
											 
	if ( vDelta )									// Scroll vDelta, the
	{												//  integral amount.
		_totalSmoothVScroll -= vDelta;
		_nextSmoothVScroll -= vDelta * SMOOTH_PRECISION;
		FractionalScrollView( vDelta );
	}
	else if ( 0 == _totalSmoothVScroll )			// Starting to wind down?
	{
		 _nextSmoothVScroll -= _smoothVDelta;
		 fImmediateUpdate = TRUE;
	}
													// Finished scrolling?
	if ( (vDelta <= 0 && _totalSmoothVScroll >= 0) || (vDelta >= 0 && _totalSmoothVScroll <= 0 ) )
	{
		LONG cLinesAndDir;

		if ( _continuedsmoothVDelta )				// mButton continuation.
		{
			_smoothVDelta = _continuedsmoothVDelta;
			_totalSmoothVScroll += _continuedSmoothVScroll;
		}
		else
		{
			if ( _continuedSmoothVScroll )
			{
				_fFinishSmoothVScroll	= TRUE;		// Winding down scroll.     
				_continuedSmoothVScroll = 0;		
													// Last line's remainder... 
				cLinesAndDir = _smoothVDelta < 0 ? -1 : 1;
				_totalSmoothVScroll = CalcVLineScrollDelta ( cLinesAndDir, TRUE );

													// check for line boundry.
				if ( _totalSmoothVScroll
					==	CalcVLineScrollDelta ( cLinesAndDir, FALSE ) )
				{
					_totalSmoothVScroll = 0;
				}

				if ( fImmediateUpdate )				// do 'this' epochs scroll.
					SmoothVScrollUpdate();
			}
			else
			{
				CheckRemoveSmoothVScroll();			// All done, remove timer.
			}
		}
	}
}

/*
 *	CDisplay::FinishSmoothVScroll
 *
 *	@mfunc
 *		Cause smooth scroll to finish off the last fractional lines worth of
 *		scrolling and then stop.
 */
VOID CDisplay::FinishSmoothVScroll( )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::FinishSmoothVScroll");

													// any non-zero value.

	if ( !_fFinishSmoothVScroll && _totalSmoothVScroll )
	{
		_fFinishSmoothVScroll	= TRUE;
		_continuedSmoothVScroll = 1;					
		_continuedsmoothVDelta	= 0;				// So smooth scroll stops.
		_totalSmoothVScroll		= 0;
	}
}

/*
 *	CTxtEdit::CheckInstallSmoothScroll()
 *
 *	@mfunc
 *		Install a new smooth scroll timer if not already scrolling.
 */
BOOL CDisplay::CheckInstallSmoothVScroll()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::CheckInstallSmoothVScroll");

	_TEST_INVARIANT_
	
	BOOL	fJustInstalled = FALSE;

	if(!_fSmoothVScroll && _ped->TxSetTimer(RETID_SMOOTHSCROLL, 25))
	{
		_fSmoothVScroll = TRUE;
		fJustInstalled = TRUE;
	}

	return fJustInstalled;
}

/*
 *	CTxtEdit::CheckRemoveSmoothVScroll ( )
 *
 *	@mfunc
 *		Finish smooth scroll. If not a forced stop, then check
 *		to see if smooth scrolling should continue, and if so, setup
 *		to continue smooth scrolling.
 */
VOID CDisplay::CheckRemoveSmoothVScroll ( )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::CheckRemoveSmoothVScroll");

	_TEST_INVARIANT_

	if(	_fSmoothVScroll )
	{
		ScrollToLineStart( _continuedSmoothVScroll );	// Ensure stopped on a line.

		_ped->TxKillTimer(RETID_SMOOTHSCROLL);
		_fSmoothVScroll = FALSE;
	}
}

/*
 *	CDisplay::LineScroll(cli, cch)
 *
 *	@mfunc
 *		Scroll the view horizontally in response to a scrollbar event
 *
 *  Note:
 *      No support for vertical scroll in base CDisplay. No action.
 */
void CDisplay::LineScroll(
	LONG cli,	//@parm Count of lines to scroll vertically
	LONG cch)	//@parm Count of chars to scroll horizontally
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::LineScroll");

	_TEST_INVARIANT_

    return;
}

void CDisplay::FractionalScrollView (
	LONG vDelta )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::FractionalScrollView");

	_TEST_INVARIANT_

    return;
}

VOID CDisplay::ScrollToLineStart ( LONG iDirection )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::ScrollToLineStart");

	_TEST_INVARIANT_

    return;
}

LONG CDisplay::CalcVLineScrollDelta ( LONG cli, BOOL fFractionalFirst )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::CalcVLineScrollDelta");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::DragScroll(ppt)
 *
 *	@mfunc
 *		Auto scroll when dragging the mouse out of the visible view
 *
 *	Arguments:
 *		ppt 	mouse position (in client coordinates)
 */
BOOL CDisplay::DragScroll(const POINT * ppt)	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::DragScroll");

	_TEST_INVARIANT_

	const DWORD dwTime = GetTickCount();
	BOOL fScrolled = FALSE;
	DWORD dwScroll = 0;
	RECTUV rc;
    int nScrollInset;

    AssertSz(_ped->_fInPlaceActive, "CDisplay::DragScroll() called when not in-place");

    GetViewRect(rc);
    nScrollInset = (int)W32->GetScrollInset();
	InflateRect((RECT*)&rc, - nScrollInset, - nScrollInset);

	if(_fVScrollEnabled && (_ped->TxGetScrollBars() & ES_AUTOVSCROLL))
	{
    	const vpScroll = ConvertVPosToScrollPos(GetVpScroll());

		if(ppt->y <= rc.top)
		{
			dwScroll = dwAutoScrollUp;
		}
		else if(ppt->y > rc.bottom) 
		{
			LONG vpMax = GetScrollRange(SB_VERT);
			if(vpScroll < vpMax)
				dwScroll = dwAutoScrollDown;
		}
	}
	
	if(!dwScroll && _fUScrollEnabled && (_ped->TxGetScrollBars() & ES_AUTOHSCROLL))
	{
    	const upScroll = ConvertUPosToScrollPos(GetUpScroll());

		if((ppt->x <= rc.left) && (upScroll > 0))
		{
			dwScroll = dwAutoScrollLeft;
		}
		else if(ppt->x > rc.right) 
		{
			LONG xMax = GetScrollRange(SB_HORZ);
			if(upScroll < xMax)
    			dwScroll = dwAutoScrollRight;
		}
	}

	if(dwScroll)
	{
		if(_dwScrollLast != dwScroll)
		{
			// entered or moved to a different auto scroll area
			// reset delay counter
			TRACEINFOSZ("enter auto scroll area");
			_dwTimeScrollNext = dwTime + cmsecScrollDelay;
		}
		else if(dwTime >= _dwTimeScrollNext)
		{
			WORD wScrollCode = SB_LINEDOWN;

			switch(dwScroll)
			{
			case dwAutoScrollUp:
				wScrollCode = SB_LINEUP;
				// fall through to dwAutoScrollDown
			case dwAutoScrollDown:
				// OnVScroll() doesn't scroll enough for our desires
				VScroll(wScrollCode, 0);
				VScroll(wScrollCode, 0);
				break;

			case dwAutoScrollLeft:
				wScrollCode = SB_LINEUP;
				// fall through to dwAutoScrollRight
			case dwAutoScrollRight:
				// UScroll() doesn't scroll enough for our desires
				UScroll(wScrollCode, 0);
				UScroll(wScrollCode, 0);
				UScroll(wScrollCode, 0);
				UScroll(wScrollCode, 0);
				break;
#ifdef DEBUG
			default:
				Tracef(TRCSEVWARN, "Unexpected dwScroll %lx", dwScroll);
				TRACEERRSZSC("Unexpected dwScroll", E_INVALIDARG);
				break;
#endif
			}
			// reset interval counter
			_dwTimeScrollNext = dwTime + cmsecScrollInterval;
			fScrolled = TRUE;
		}
	}
#if !defined(NOFULLDEBUG) && defined(DEBUG)
	else if(_dwScrollLast)
		TRACEINFOSZ("moved out of auto scroll area");
#endif
	_dwScrollLast = dwScroll;

	return fScrolled;
}

/*
 *	CDisplay::AutoScroll(pt, upScrollInset, vpScrollInset)
 *
 *	@mfunc:
 *		Given the current point, determine whether we need to
 *		scroll the client area.
 *
 *	Requires:
 *		This function should only be called during a drag drop
 *		operation.
 *
 *	@rdesc
 *		True if we are in the drag scrolling hot zone, false otherwise.
 *
 */
#define ScrollUp	0x0001	//These eight macros indicate the areas
#define ScrollDown	0x0010	//of the drag scrolling hot zone that tell
#define ScrollLeft	0x0100	//which direction to scroll.
#define ScrollRight 0x1000	//The last four are ambiguous (the corners)
#define ScrollUL	0x0101	//and require a little extra work.
#define ScrollUR	0x1001
#define ScrollDL	0x0110
#define ScrollDR	0x1010

BOOL CDisplay::AutoScroll(
	POINTUV pt,				 //@parm Cursor location in client coordinates
	const WORD upScrollInset,
	const WORD vpScrollInset)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDisplay::AutoScroll");

	static DWORD hotticks = 0;			//Ticks when we entered hot zone.
	static DWORD lastscrollticks = 0;	//Ticks when we last scroll.
	static DWORD lastticks = 0;			//Ticks when last called.
	DWORD delta;						//Ticks since last called.
	DWORD ticks;						//GetTickCount ticks.
	RECT rcClient;						//Client rect of control.
	WORD wScrollDir = 0;				//Scroll direction.
	BOOL fScroll = FALSE;				//TRUE if we should try to scroll this time.
    BOOL fEnabled = FALSE;              //TRUE if scrolling is possible

	//Get the current ticks and calculate ticks since last called.
	//Note that if _drags does not have valid data this will be a
	//bogus value, but that is handled later.
	ticks = GetTickCount();
	delta = ticks - lastticks;
	lastticks = ticks;

	//Don't do anything if no ticks since last time we were called.
	if (delta)
	{
		// Get our client rect.
		_ped->TxGetClientRect(&rcClient);

		//Find out if we are in the hot zone.
		//Note that if we are in one of the corners
		//we will indicate two scrolling directions.
		//This ambiguity will be sorted out later.
		//For now we just want to know if we are in
		//the zone.
		if (pt.u <= (LONG)(rcClient.left + upScrollInset))
			wScrollDir |= (WORD)ScrollLeft;
		else if (pt.u >= (LONG)(rcClient.right - upScrollInset))
			wScrollDir |= (WORD)ScrollRight;

		if (pt.v <= (LONG)(rcClient.top + vpScrollInset))
			wScrollDir |= (WORD)ScrollUp;
		else if (pt.v >= (LONG)(rcClient.bottom - vpScrollInset))
			wScrollDir |= (WORD)ScrollDown;
			
		//If we are somewhere in the hot zone.
		if (wScrollDir)
		{
			//If we just entered hotzone remember the current ticks.
			if (!hotticks)
				hotticks = ticks;

			//If we have been in the hot zone long enough, and
			//the required interval since the last scroll has elapsed
			//allow another scroll. Note that if we haven't scrolled yet,
			//lastscrollticks will be zero so the delta is virtually
			//guaranteed to be greater than ScrollInterval.
			if ((ticks - hotticks) >= (DWORD)W32->GetScrollDelay() &&
			    (ticks - lastscrollticks) >= (DWORD)W32->GetScrollInterval())
				fScroll = TRUE;

    		//If we are in one of the corners, we scroll
    		//in the direction of the edge we are closest
    		//to.
    		switch (wScrollDir)
    		{
    			case ScrollUL:
    			{
    				if ((pt.v - rcClient.top) <= (pt.u - rcClient.left))
    					wScrollDir = ScrollUp;
    				else
    					wScrollDir = ScrollLeft;
    				break;
    			}
    			case ScrollUR:
    			{
    				if ((pt.v - rcClient.top) <= (rcClient.right - pt.u))
    					wScrollDir = ScrollUp;
    				else
    					wScrollDir = ScrollRight;
    				break;
    			}
    			case ScrollDL:
    			{
    				if ((rcClient.bottom - pt.v) <= (pt.u - rcClient.left))
    					wScrollDir = ScrollDown;
    				else
    					wScrollDir = ScrollLeft;
    				break;
    			}
    			case ScrollDR:
    			{
    				if ((rcClient.bottom - pt.v) <= (rcClient.right - pt.u))
    					wScrollDir = ScrollDown;
    				else
    					wScrollDir = ScrollRight;
    				break;
    			}
    		}
		}
		else
		{
			//We aren't in the hot zone so reset hotticks as a
			//flag so we know the first time we reenter it.
			hotticks = 0;
		}

        //Do processing for horizontal scrolling if necessary
		if (wScrollDir == ScrollLeft || wScrollDir == ScrollRight)
		{
            LONG xRange, upScroll, dx;

            upScroll = ConvertUPosToScrollPos(GetUpScroll());
            xRange = GetScrollRange(SB_HORZ);
			dx = W32->GetScrollHAmount();

            fEnabled = IsUScrollEnabled();
            if (wScrollDir == ScrollLeft)
            {
                fEnabled = fEnabled && (upScroll > 0);
               	upScroll -= dx;
                upScroll = max(upScroll, 0);
            }
            else
            {
                fEnabled = fEnabled && (upScroll < xRange);
				upScroll += dx;
                upScroll = min(upScroll, xRange);
            }

            //Do the actual scrolling if necessary.
			if (fEnabled && fScroll)
			{
                UScroll(SB_THUMBPOSITION, upScroll);
				lastscrollticks = ticks;
			}
		}
        //Do processing for Vertical scrolling if necessary
        else if (wScrollDir == ScrollUp || wScrollDir == ScrollDown)
		{
            LONG yRange, vpScroll, dy;

            vpScroll = ConvertVPosToScrollPos(GetVpScroll());
            yRange = GetScrollRange(SB_VERT);
    		dy = W32->GetScrollVAmount();
	
            fEnabled = IsVScrollEnabled();
            if (wScrollDir == ScrollUp)
            {
                fEnabled = fEnabled && (vpScroll > 0);
                vpScroll -= dy;
                vpScroll = max(vpScroll, 0);
            }
            else
            {
                fEnabled = fEnabled && (vpScroll < yRange);
    			vpScroll += dy;
                vpScroll = min(vpScroll, yRange);
            }

	        //Do the actual scrolling if necessary.
    		if (fEnabled && fScroll)
			{
				// We need to scroll fractionally because the scroll logic tries
				// to put a full line on the top and if the scroll amount is less
				// than a full line, the scrolling will get stuck on that line.
				ScrollView(_upScroll, vpScroll, FALSE, TRUE);
				lastscrollticks = ticks;
			}
		}
	}

	return fEnabled;
}

/*
 *	CDisplay::AdjustToDisplayLastLine(yBase, vpScroll)
 *
 *	@mfunc
 *		Calculate the yscroll necessary to get the last line to display
 *
 *	@rdesc
 *		Updated vpScroll
 *
 *	@devnote:
 *		This method is only really useful for ML displays. This method
 *		here is a placeholder which does nothing which is useful for
 *		all other displays.
 */
LONG CDisplay::AdjustToDisplayLastLine(
	LONG yBase,			//@parm Actual vpScroll to display
	LONG vpScroll)		//@parm Proposed amount to scroll
{
	return vpScroll;
}

/*
 *	CDisplay::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range
 *      No scrollbar support in the base class: returns 0.
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplay::GetScrollRange(
	INT nBar) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetScrollRange");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update either the horizontal or vertial scroll bar
 *		Also figure whether the scroll bar should be visible or not
 *      No scrollbar support in the base class: no action.
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplay::UpdateScrollBar(
	INT	 nBar,
	BOOL fUpdateRange)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateScrollBar");

	_TEST_INVARIANT_

	return TRUE;
}

/*
 *	CDisplay::GetZoomDenominator()
 *
 *	@mfunc
 *		Get zoom denominator  
 *
 *	@rdesc
 *		Returns zoom denominator
 *
 *	@devnote:
 *		FUTURE: (Ricksa) we should investigate how to cache this data since
 *				the display needs to keep a temporary zoom denominator anyway.
 */
LONG CDisplay::GetZoomDenominator() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetZoomDenominator");

	if(_ped->GetZoomDenominator())				// Simple EM_SETZOOM API
		return _ped->GetZoomDenominator();		//  supercedes complicated
												//  Forms^3 API
	// Default zoom to error case. The error case is a very low
	// probability event that we can do nothing to recover. So we 
	// just set the value to something reasonable and continue.
	LONG lZoomDenominator = _dvpClient;

	// Is temporary zoom denominator set?
	if(INVALID_ZOOM_DENOMINATOR == _lTempZoomDenominator)
	{
		// No - Get extent size from host
		SIZEL sizelExtent;
		if(SUCCEEDED(_ped->TxGetExtent(&sizelExtent)))
		{
			// Convert height to device units. Note that by definition, we
			// can ignore horizontal extents so we do. Use CDevDesc conversion
			// to avoid infinite recursion
			lZoomDenominator = CDevDesc::HimetricYtoDY(
				IsUVerticalTflow(GetTflow()) ? sizelExtent.cx : sizelExtent.cy);
		}
	}
	else	// Temporary zoom denominator is set: use it
		lZoomDenominator = CDevDesc::HimetricYtoDY(_lTempZoomDenominator);

	return lZoomDenominator > 0 ? lZoomDenominator : 1;
}

/*
 *	CDisplay::GetZoomNumerator()
 *
 *	@mfunc
 *		Get zoom numerator  
 *
 *	@rdesc
 *		Returns zoom numerator
 */
LONG CDisplay::GetZoomNumerator() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetZoomNumerator");

	if(_ped->GetZoomNumerator())				// Simple EM_SETZOOM API
		return _ped->GetZoomNumerator();		//  supercedes complicated
												//  Forms^3 API
	return _dvpClient > 0 ? _dvpClient : 1;
}

/*
 *	CDisplay::Zoom(x)
 *
 *	@mfunc
 *		Get zoomed x  
 *
 *	@rdesc
 *		Returns zoomed x
 */
// REVIEW (keithcu) Why does Zoom do anything when we are in print preview?
LONG CDisplay::Zoom(LONG x) const
{
	return MulDiv(x, GetZoomNumerator(), GetZoomDenominator());
}

/*
 *	CDisplay::UnZoom(x)
 *
 *	@mfunc
 *		Get unzoomed x  
 *
 *	@rdesc
 *		Returns unzoomed x
 */
LONG CDisplay::UnZoom(LONG x) const
{
	return MulDiv(x, GetZoomDenominator(), GetZoomNumerator());
}

/*
 *	CDisplay::HimetricUtoDU(u)
 *
 *	@mfunc
 *		Get device u coordinate corresponding to Himetric u coordinate  
 *
 *	@rdesc
 *		Returns device coordinate
 */
LONG CDisplay::HimetricUtoDU(
	LONG u) const
{
	u = Zoom(u);

	if (!IsUVerticalTflow(GetTflow()))
		return CDevDesc::HimetricXtoDX(u);
	else
		return CDevDesc::HimetricYtoDY(u);
}

/*
 *	CDisplay::HimetricVtoDV(v)
 *
 *	@mfunc
 *		Get device v coordinate corresponding to Himetric v coordinate  
 *
 *	@rdesc
 *		Returns device coordinate
 */
LONG CDisplay::HimetricVtoDV(
	LONG v) const
{
	v = Zoom(v);

	if (!IsUVerticalTflow(GetTflow()))
		return CDevDesc::HimetricYtoDY(v);
	else
		return CDevDesc::HimetricXtoDX(v);
}

/*
 *	CDisplay::DUtoHimetricU(du)
 *
 *	@mfunc
 *		Get Himetric u coordinate corresponding to device u coordinate  
 *
 *	@rdesc
 *		Returns Himetric coordinate
 */
LONG CDisplay::DUtoHimetricU(
	LONG du) const
{
	if (!IsUVerticalTflow(GetTflow()))
		du = CDevDesc::DXtoHimetricX(du);
	else
		du = CDevDesc::DYtoHimetricY(du);

	return UnZoom(du);
}

/*
 *	CDisplay::DVtoHimetricV(dv)
 *
 *	@mfunc
 *		Get Himetric v coordinate corresponding to device v coordinate  
 *
 *	@rdesc
 *		Returns Himetric coordinate
 */
LONG CDisplay::DVtoHimetricV(
	LONG dv) const
{
	if (!IsUVerticalTflow(GetTflow()))
		dv = CDevDesc::DYtoHimetricY(dv);
	else
		dv = CDevDesc::DXtoHimetricX(dv);

	return UnZoom(dv);
}

/*
 *	CDisplay::SetClientHeight(yNewClientHeight)
 *
 *	@mfunc
 *		Reset height of client rectangle
 *
 *	@rdesc
 *		Returns previous height of the client rectangle
 */
LONG CDisplay::SetClientHeight(
	LONG yNewClientHeight)	//@parm New height for the client rectangle.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetClientHeight");

	LONG yOldHeight = _dvpClient;
	_dvpClient = yNewClientHeight;
	return yOldHeight;
}

/*
 *	CDisplay::GetCachedSize(pdupClient, pdvpClient)
 *
 *	@mfunc		calculates the client size
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
 HRESULT CDisplay::GetCachedSize( 
 	LONG *pdupClient,  	//@parm	where to put the width
 	LONG *pdvpClient)	//@parm where to put the height
	const
 {
 	RECTUV rcInset;

	_ped->TxGetViewInset(&rcInset, this);

	*pdvpClient = _dvpClient;
	*pdupClient = _dupView + rcInset.left + rcInset.right + GetSelBarInPixels();

	return NOERROR;
}

/*
 *	CDisplay::TransparentHitTest(hdc, prcClient, pt, pHitResult)
 *
 *	@mfunc
 *		Determine if the hit is on a transparent control
 *
 *	@rdesc
 *		Returns HRESULT of call usually S_OK.
 *
 *	@devnote
 *		FUTURE: This code needs to be investigated for possible optimizations.
 *
 *		This code is assumes that all remeasuring needed has been done before 
 *		this routine is called.
 */

// How close hit needs to be to the text
const int HIT_CLOSE_RECT_INC = 5;

HRESULT CDisplay::TransparentHitTest(
	HDC		hdc,		//@parm DC for actual drawing
	LPCRECT	prcClient,	//@parm Client rectangle for rendering
	POINTUV pt,			//@parm Point to hittest against
	DWORD *	pHitResult)	//@parm	Result of the hit test see TXTHITRESULT 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::TransparentHitTest");

	COLORREF	 crBackground = _ped->TxGetBackColor();
	HDC			 hdcMem = NULL;
	HRESULT		 hr = E_FAIL;
	int			 uRow, vCol;
	COffscreenDC osdc;
	RECTUV		 rcClient, rcRender, rcView;
	RECT		 rcxyClient;

	rcxyClient.left = rcxyClient.top = 0;
	rcxyClient.right = prcClient->right  - prcClient->left;
	rcxyClient.bottom = prcClient->bottom - prcClient->top;
	
	// Render view to a memory DC
	// Compute zero based client rectangle
	RectuvFromRect(rcClient, rcxyClient);

	// Create a memory DC
	hdcMem = osdc.Init(hdc, rcxyClient.right - rcxyClient.left, rcxyClient.bottom - rcxyClient.top, crBackground);
	if(!hdcMem)
		goto Cleanup;

	// Initialize display
	osdc.FillBitmap(rcxyClient.bottom, rcxyClient.right);

	// Set the DC to the memory DC
	SetDC(hdcMem);

	// Get view rectangle that we need for rendering
  	GetViewRect(rcView, &rcClient);

	// Adjust point to be relative to the memory display
	pt.u -= prcClient->left;
	pt.v -= prcClient->top;

	// Initalize box around point. Note that we only really need to render
	// the data inside this box because this is the only area that we will
	// test.
	rcRender.top = pt.v - HIT_CLOSE_RECT_INC;
	if (rcRender.top < 0)
		rcRender.top = 0;

	rcRender.bottom = pt.v + HIT_CLOSE_RECT_INC;
	if (rcRender.bottom > rcClient.bottom)
		rcRender.bottom = rcClient.bottom;	

	rcRender.left = pt.u - HIT_CLOSE_RECT_INC;
	if (rcRender.left < 0)
		rcRender.left = 0;

	rcRender.right = pt.u + HIT_CLOSE_RECT_INC;
	if (rcRender.right > rcClient.right)
		rcRender.right = rcClient.right;

    // Now render
    Render(rcView, rcRender);

	// Hit test
	// Assume no hit
	*pHitResult = TXTHITRESULT_TRANSPARENT;

	// At this point we won't fail this
	hr = S_OK;

	// Is there an exact hit?
	POINT ptxy;
	PointFromPointuv(ptxy, pt);
	if (GetPixel(hdcMem, ptxy.x, ptxy.y) != crBackground)
	{
		*pHitResult = TXTHITRESULT_HIT;
		goto Cleanup;
	}

	// Is it close? We determine closeness by putting
	// a 10 x 10 pixel box around the hit point and 
	// seeing if there is a hit there.

	// Loop examining each bit in the box to see if it is on.
	for (uRow = rcRender.top; uRow <= rcRender.bottom; uRow++)
	{
		for (vCol = rcRender.left; vCol <= rcRender.right; vCol++)
		{
			pt.u = uRow;
			pt.v = vCol;
			PointFromPointuv(ptxy, pt);
			if (GetPixel(hdcMem, ptxy.x, ptxy.y) != crBackground)
			{
				*pHitResult = TXTHITRESULT_CLOSE;
				goto Cleanup;
			}
		}
	}

Cleanup:
	ResetDC(); //REVIEW (keithcu) shouldn't be needed!
	return hr;
}

//============================ ITxNotify Interface ==========================
/*
 *	CDisplay::OnPreReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		Preprocess a change in backing store
 *
 *	@devnote
 *		This display doesn't care about before changes
 */
void CDisplay::OnPreReplaceRange( 
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnPreReplaceRange");

	// Display doesn't care about before the fact
}

/*
 *	CDisplay::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		Process a change to the backing store as it applies to the display
 */
void CDisplay::OnPostReplaceRange( 
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnPostReplaceRange");

	// There is one NO-OP's for the display:
	// currently loading a file.
	//
	// We NO-OP the load case because loading an RTF file can consist
	// of potentially very many small actions as we peice together
	// the various bits of formatted text.  Once done, the load code
	// will go through and do an update-all to the display.
	Assert (cp != CONVERT_TO_PLAIN);			// Handled with PreReplace notifications

	// Figure out range needed to update
	LONG cpNew = min(cp, cpFormatMin);

	if(CP_INFINITE == cpNew)
	{
		// If both cp's are infinite we don't need to bother with
		// this operation.
		return;
	}

	if(!_ped->_fInPlaceActive)
    {
        // If not active, just invalidate everything
        InvalidateRecalc();
        _ped->TxInvalidate();
		_ped->TxUpdateWindow();
        return;
    }

	// Adjust cp for further calculations
	if(CP_INFINITE == cp)
		cp = 0;

	// find the new max end of the original region.
	LONG	cpForEnd = max( (cp + cchDel), cpFormatMax);

	// Number of deleted characters is the difference between the previous two
	LONG cchDelForDisplay = cpForEnd - cpNew;

	// The number deleted is simply number of new characters adjusted by
	// the change in the number of characters.
	LONG cchNewForDisplay = cchDelForDisplay + (cchNew - cchDel);

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	if(_padc)
	{
		// Display is frozen so accumulate the change instead of actually
		// displaying it on the screen.
		_padc->UpdateRecalcRegion(cpNew, cchDelForDisplay, cchNewForDisplay);
		return;
	}		

	// Tell display to update
	CRchTxtPtr rtp(_ped, cpNew);

	UpdateView(rtp, cchDelForDisplay, cchNewForDisplay);
}

/*
 *	CDisplay::SetWordWrap(fWordWrap)
 *
 *	@mfunc
 *		Sets the no wrap flag
 *
 *	@devnote
 *		We will always allow the property to be set but we will not
 *		necessarily pay attention. In other words, word wrap has no
 *		effect on a single line edit control.
 */
void CDisplay::SetWordWrap(
	BOOL fWordWrap)		//@param TRUE - turn on word wrap.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetWordWrap");

	AssertSz((fWordWrap == TRUE) ||	(fWordWrap == FALSE),
		"CDisplay::SetWordWrap bad input flag");

	// Set nowrap to whatever is coming in.
	_fWordWrap = fWordWrap;
}

/*
 *	CDisplay::GetWordWrap()
 *
 *	@mfunc
 *		Return state of word wrap property
 *
 *	@rdesc
 *		TRUE - word wrap is on
 *		FALSE - word wrap is is off.
 *
 *	@devnote
 *		Derived classes such as CDisplaySL override this.
 */
BOOL CDisplay::GetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetWordWrap");

	return _fWordWrap;
}

/*
 *	CDisplay::GetViewDim(dup, dvp)
 *
 *	@mfunc
 *		Return the height & width of view adjusted for view inset
 */
void CDisplay::GetViewDim(
	LONG& dup,		//@parm Where to return the width
	LONG& dvp)		//@parm Where to return the height
{
	// We build a client rectangle to take advantage of GetViewRect routine
	// which really does all the work for us.
	RECTUV rcClient;
	rcClient.left = 0;
	rcClient.top = 0;
	rcClient.right = dup;
	rcClient.bottom = dvp;

	// Take into account inset and selection bar. The parameters here are a bit
	// of a trick. The second parameter gets copied into the first and since
	// we don't need the original client rect we save a rect off the stack.
	GetViewRect(rcClient, &rcClient);
	dup = rcClient.right - rcClient.left;
	dvp = rcClient.bottom - rcClient.top;
}

/*
 *	CDisplay::SaveUpdateCaret (fScrollIntoView)
 *
 *	@mfunc	Save UpdateCaret parameter so update caret can be called
 *			after the display is thawed.
 *
 *	@rdesc	None.
 *
 *	@devnote
 *			This should only be called if IsFrozen is true.
 */
void CDisplay::SaveUpdateCaret(
	BOOL fScrollIntoView)
{
#ifdef DEBUG
	if (_padc == NULL)
	{
		TRACEERRORSZ("CDisplay::SaveUpdateCaret called on thawed display");
	}
#endif // DEBUG
	if(_padc)
		_padc->SaveUpdateCaret(fScrollIntoView);
}

/*
 *	CDisplay::SetNeedRedisplayOnThaw
 *
 *	@mfunc
 *		Automatically redisplay control on thaw
 */
void CDisplay::SetNeedRedisplayOnThaw(BOOL fNeedRedisplay)
{
	Assert (_padc);
	_padc->SetNeedRedisplayOnThaw(fNeedRedisplay);
}

/*
 *	CDisplay::Freeze
 *
 *	@mfunc
 *		Prevent any updates from occuring in the display
 */
void CDisplay::Freeze()
{
	if(NULL == _padc)
	{
		// Allocate object to keep track of changes
		_padc = new CAccumDisplayChanges();

		// We can now return because the accum object has a reference
		// or the memory allocation failed. If the memory allocation 
		// failed, This really isn't a catastrophe because all it means 
		// is that things will get displayed ugly temporarily, so we can 
		// pretend it didn't happen.
		return;
	}

	// Tell object that an additional freeze has occurred.
	_padc->AddRef();
}

/*
 *	CDisplay::Thaw()
 *
 *	@mfunc
 *		If this is the last thaw, then cause display to be updated.
 *
 */
void CDisplay::Thaw()
{
	BOOL fUpdateCaret, fScrollIntoView, fNeedRedisplay;
	LONG cp, cchNew, cchDel;
	CTxtSelection *psel;

	if(_padc)
	{
		// Release reference to accum object
		if(_padc->Release() == 0)
		{
			// Last thaw so we need to update display

			// Get the changes
			_padc->GetUpdateRegion(&cp, &cchDel, &cchNew, 
				&fUpdateCaret, &fScrollIntoView, &fNeedRedisplay);

			// Clear the object - note we do this before
			// the update just on the off chance that
			// a new freeze manages to get in during the 
			// update of the display.
			delete _padc;
			_padc = NULL;

			if(cp != CP_INFINITE)
			{
				// Display changed
				if(!_ped->fInplaceActive())
				{
					// Are not inplace active so we need to put this operation
					// off till a more appropriate time.

					InvalidateRecalc();
					_ped->TxInvalidate();
					_ped->TxUpdateWindow();
					return;
				}
				// Update display
				CRchTxtPtr rtp(_ped, cp);
				if(!UpdateView(rtp, cchDel, cchNew))
					return;							// Update failed
			}

			if (fNeedRedisplay)
				_ped->TxInvalidate();

			// Did selection request a caret update?
			if(fUpdateCaret && _ped->fInplaceActive())
			{
				psel = _ped->GetSel();
				psel->UpdateCaret(fScrollIntoView);
			}
		}
	}
}

/*
 *	CDisplay::IsPrinter
 *
 *	@mfunc
 *		Returns whether this is a printer
 *
 *	@rdesc
 *		TRUE - is a display to a printer
 *		FALSE - is not a display to a printer
 *
 *	@devnote
 *		No display except a display	CDisplayPrinter should
 *		ever have a chance to return TRUE to this function.
 */
BOOL CDisplay::IsPrinter() const
{
	return FALSE;
}

/*
 *	CDisplay::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDisplay::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CDisplay::Zombie");

}

/*
 *	CDisplay::IsUScrollEnabled ()
 *
 *	@mfunc
 *		Return whether horizontal scroll bar is enabled
 *
 *	@rdesc
 *		TRUE - yes
 *		FALSE - no
 *
 *	@devnote
 *		The reason for this routine is that _fUScrollEnabled means
 *		to scroll text and can be set even if there is no scroll
 *		bar. Therefore, we need to look at the host properties
 *		as well to tell use whether this means there are scroll
 *		bars.
 */
BOOL CDisplay::IsUScrollEnabled()	  
{
	return _fUScrollEnabled && ((_ped->TxGetScrollBars() & WS_HSCROLL) != 0);
}

/*
 *	CDisplayML::GetPage(piPage, dwFlags, pcrg)
 *
 *	@mfunc
 *		Get page number for first visible line
 *
 *	@rdesc
 *		HRESULT = E_FAIL
 */						     
HRESULT CDisplay::GetPage(
	LONG *piPage,		//@parm Out parm for page number
	DWORD dwFlags, 		//@parm Flags for which page to use
	CHARRANGE *pcrg)	//@parm Out parm for CHARRANGE for page
{
	return E_FAIL;
}

/*
 *	CDisplay::SetPage(iPage)
 *
 *	@mfunc
 *		Set page number for _iliFirstVisible
 */						     
HRESULT CDisplay::SetPage (
	LONG iPage)
{
	return E_FAIL;
}

/*
 *	CDisplay::Paginate(ili)
 *
 *	@mfunc
 *		Recompute page breaks from iLineFirst on
 *
 *	@rdesc
 *		TRUE if success
 */						     
BOOL CDisplay::Paginate (
	LONG ili,					//@parm Line to redo pagination from
	BOOL fRebindFirstVisible)	//@parm If TRUE, call RebindFirstVisible()
{
	return FALSE;		// Only ML displays can paginate
}

/*
 *	CDisplay::PointFromPointuv(pt, ptuv)
 *
 *	@mfunc
 *		convert a pointuv to a point.
 *		fExtTextOutBug is to work around a display bug in Windows. This might not happen
 *		on all platforms...
 *
 */						     
void CDisplay::PointFromPointuv(POINT &pt, const POINTUV &ptuv, BOOL fExtTextOut) const
{
	TFLOW tflow = GetTflow();
	if (tflow == tflowES)
	{
		memcpy(&pt, &ptuv, sizeof(pt));
		return;
	}

	long dupClient, dvpClient;
	GetCachedSize(&dupClient, &dvpClient);

	switch(tflow)
	{
	case tflowSW:
		pt.x = dvpClient - ptuv.v - 1;
		pt.y = ptuv.u;
		break;

	case tflowWN:
		pt.x = dupClient - ptuv.u - 1;
		pt.y = dvpClient - ptuv.v - 1;
		break;

	case tflowNE:
		pt.x = ptuv.v + fExtTextOut ? 1 : 0;
		pt.y = dupClient - ptuv.u - 1;
		break;
	}
}

/*
 *	CDisplay::PointuvFromPoint(ptuv, pt)
 *
 *	@mfunc
 *		convert a point to a pointuv.
 *
 */						     
void CDisplay::PointuvFromPoint(POINTUV &ptuv, const POINT &pt) const
{
	TFLOW tflow = GetTflow();
	if (tflow == tflowES)
	{
		memcpy(&ptuv, &pt, sizeof(pt));
		return;
	}

	long dupClient, dvpClient;
	GetCachedSize(&dupClient, &dvpClient);

	switch(tflow)
	{
	case tflowSW:
		ptuv.u = pt.y;
		ptuv.v = dvpClient - pt.x - 1;
		break;

	case tflowWN:
		ptuv.u = dupClient - pt.x - 1;
		ptuv.v = dvpClient - pt.y - 1;
		break;

	case tflowNE:
		ptuv.u = dupClient - pt.y - 1;
		ptuv.v = pt.x;
		break;
	}
}

/*
 *	CDisplay::RectFromRectuv(rc, rcuv)
 *
 *	@mfunc
 *		convert a RECT from a RECTUV.
 *
 */						     
void CDisplay::RectFromRectuv(RECT& rc, const RECTUV& rcuv) const
{
	TFLOW tflow = GetTflow();
	if (tflow == tflowES)
	{
		memcpy(&rc, &rcuv, sizeof(rcuv));
		return;
	}

	long dvp = rcuv.bottom - rcuv.top;
	long dup = rcuv.right - rcuv.left;

	long dupClient, dvpClient;
	GetCachedSize(&dupClient, &dvpClient);

	switch(tflow)
	{
	case tflowSW:
		rc.left = dvpClient - rcuv.bottom;
		rc.top = rcuv.left;
		rc.right = rc.left + dvp;
		rc.bottom = rc.top + dup;
		break;

	case tflowWN:
		rc.right = dupClient - rcuv.left;
		rc.bottom = dvpClient - rcuv.top;
		rc.left = rc.right - dup;
		rc.top = rc.bottom - dvp;
		break;

	case tflowNE:
		rc.left = rcuv.top;
		rc.top = dupClient - rcuv.right;
		rc.right = rc.left + dvp;
		rc.bottom = rc.top + dup;
		break;
	}
}

/*
 *	CDisplay::RectFromRectuv(rc, rcuv)
 *
 *	@mfunc
 *		convert a RECTUV from a RECT.
 *
 */						     
void CDisplay::RectuvFromRect(RECTUV &rcuv, const RECT& rc) const
{
	TFLOW tflow = GetTflow();
	if (tflow == tflowES)
	{
		memcpy(&rcuv, &rc, sizeof(rcuv));
		return;
	}

	long dyp = rc.bottom - rc.top;
	long dxp = rc.right - rc.left;

	long dupClient, dvpClient;
	GetCachedSize(&dupClient, &dvpClient);

 	switch(tflow)
	{
	case tflowSW:
		rcuv.left = rc.top;
		rcuv.top = dvpClient - rc.right;
		rcuv.right = rcuv.left + dyp;
		rcuv.bottom = rcuv.top + dxp;
		break;

	case tflowWN:
		rcuv.left = dupClient - rc.right;
		rcuv.top = dvpClient - rc.bottom;
		rcuv.right = rcuv.left + dxp;
		rcuv.bottom = rcuv.top + dyp;
		break;

	case tflowNE:
		rcuv.left = dupClient - rc.bottom;
		rcuv.top = rc.left;
		rcuv.right = rcuv.left + dyp;
		rcuv.bottom = rcuv.top + dxp;
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\dispprt.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	dispprt.cpp	-- Special logic for printer object |
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Jon Matousek
 */
#include "_common.h"
#include "_dispprt.h"
#include "_edit.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_select.h"

#define PARA_NUMBER_NOT_SET ((WORD) -1)

ASSERTDATA

/*
 *	CDisplayPrinter::CDisplayPrinter(ped, hdc, x, y, prtcon)
 *
 *	@mfunc
 *		Contructs a object that can be used to print a text control
 */
CDisplayPrinter::CDisplayPrinter(
	CTxtEdit* ped,		//@parm CTxtEdit
	HDC hdc, 			//@parm HDC for drawing
	RECT *prc, 			//@parm dimensions of current area to print to.
	SPrintControl prtcon//@parm Special controls for this print object
)	
	: CDisplayML(ped), _prtcon(prtcon)
{
	TRACEBEGIN(TRCSUBSYSPRT, TRCSCOPEINTERN, "CDisplayPrinter::CDisplayPrinter");
	Assert (hdc);

	_fNoUpdateView = TRUE;

	SetTflow(ped->_pdp->GetTflow());

	GetDupDvpFromRect(*prc, GetTflow(), _dulTarget, _dvlTarget);
	_wNumber = PARA_NUMBER_NOT_SET;
}

/*
 *	CDisplayPrinter::SetPrintDimensions(prc)
 *
 *	@mfunc
 *		Set area to print.
 */
void CDisplayPrinter::SetPrintDimensions(
	RECT *prc)			//@parm dimensions of current area to print to.
{
	GetDupDvpFromRect(*prc, GetTflow(), _dulTarget, _dvlTarget);
}

/*
 *	CDisplayPrinter::FormatRange(cpFirst, cpMost)
 *
 *	@mfunc
 *		Format a range of text into this display and used only for printing.
 *
 *	@rdesc
 *		actual end of range position (updated)	
 */
LONG CDisplayPrinter::FormatRange(
	LONG cpFirst, 		//@parm Start of text range
	LONG cpMost,		//@parm End of text range
	BOOL fWidowOrphanControl)	//@parm If TRUE, suppress widow/orphan
{
	TRACEBEGIN(TRCSUBSYSPRT, TRCSCOPEINTERN, "CDisplayPrinter::FormatRange");

	LONG		cch;
	WCHAR		ch;
	BOOL		fFirstInPara = TRUE;
	CLine		liTarget;
	CLine	*	pliNew = NULL;
	LONG		dvp;
	LONG		dvt;
	const CDevDesc *pddTarget = GetDdTarget() ? GetDdTarget() : this;

	// Set client height for zooming
	_dvpClient = LYtoDY(_dvlTarget);

	// Set maximum in terms of target DC.
	LONG	dvtMax = pddTarget->LYtoDY(_dvlTarget);

	if(cpMost < 0)
		cpMost = _ped->GetTextLength();

	CMeasurer me(this);
	
	cpFirst = me.SetCp(cpFirst);		// Validate cpFirst while setting me
	ch = me.GetChar();

	// TODO: COMPATIBILITY ISSUE:  Richedit 1.0 adjusted to before a
	// CRLF/CRCRLF boundary.  if_ped->fUseCRLF(), adjust accordingly

	_cpMin = cpFirst;
	_cpFirstVisible = cpFirst;
	
	dvt = 0;
	dvp = 0;
	if(me.GetCp())
		fFirstInPara = me._rpTX.IsAfterEOP();

	// Clear line CArray
	DeleteSubLayouts(0, -1);
	Clear(AF_DELETEMEM);

	// Assume that we will break on words
	UINT uiBreakAtWord = MEASURE_BREAKATWORD;

	if(_prtcon._fPrintFromDraw)
	{
		// This is from Draw so we want to take inset into account
		LONG dut = LYtoDY(_dulTarget);

		GetViewDim(dut, dvtMax);
		_dupView = dut;

		// Restore client height
		_dvpClient = this->LYtoDY(_dvlTarget);
	}
	else			// Message-based printing always does word wrap
		SetWordWrap(TRUE);

	// Set paragraph numbering. This is a fairly difficult problem
	// because printing can start anywhere and end anywhere. However,
	// most printing will involve a contiguous range of pages. Therefore,
	// we cache the paragraph number and the cp for that number and
	// only resort to looking in the line array if the cached information
	// has become invalid.
	if ((PARA_NUMBER_NOT_SET == _wNumber) || (cpFirst != _cpForNumber))
	{
		CLinePtr rp(_ped->_pdp);
		rp.SetCp(cpFirst, FALSE);
		_wNumber = rp.GetNumber();
		_cpForNumber = cpFirst;
	}
	
	me.SetNumber(_wNumber);
	
	while(me.GetCp() < cpMost)
	{
		// Add one new line
		pliNew = Add(1, NULL);
		if(!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto err;
		}

		// Store the current number of the paragraph. We do it
		// here because we have to measure and that potentially
		// updates the number of the paragraph in the measurer
		// for a line that might not be on the page.
		_wNumber = me.GetNumber();

		// Stuff some text into this new line
		if(!Measure(me, pliNew, Count() - 1, uiBreakAtWord | (fFirstInPara ? MEASURE_FIRSTINPARA : 0), &liTarget))
		{
			Assert(FALSE);
			goto err;
		}

		//FUTURE (keithcu) We break tables across pages on row boundaries which
		//isn't very granular--especially in the HTML world.

		// Note, we always put at least one line on a page. Otherwise, if the 
		// first line is too big, we would cause our client to infinite loop
		// because we would never advance the print cp.
		if(_cel > 1 && (dvt + liTarget.GetHeight() > dvtMax))
		{
			cch = -pliNew->_cch;		// Bump last line to next page
			_cel--;						// One less line

#if 0
			CLine *pli = pliNew - 1;	// Point at previous line

			// If this line and the previous one are in the same para and
			// either this one ends in an EOP or the previous one starts
			// a para, bump both to following page (widow/orphan)
			if(fWidowOrphanControl)
			{
				if(_cel > 1 && !fFirstInPara &&
				   (pli->_bFlags & fliFirstInPara || (pliNew->_bFlags & fliHasEOP)))
				{
					cch -= pli->_cch;
					_cel--;					// One less line
					pli--;					// Point to previous line
				}
				if(_cel > 1 && pli->_nHeading)
				{							// Don't end page with a heading
					cch -= pli->_cch;
					_cel--;					// One less line
				}
			}
#endif
			me.Move(cch);			// Move back over lines discarded
			delete pliNew->GetPlo(); //Delete the CLayout which didn't get added to the CLineArray
			break;
		}

		fFirstInPara = (pliNew->_fHasEOP);

		dvt += liTarget.GetHeight();
		dvp += pliNew->GetHeight();
		if (me.GetPrevChar() == FF)
			break;
	}

	// If there was no text, then add a single blank line
	if(!pliNew)
	{
		pliNew = Add(1, NULL);
		if(!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto err;
		}
		me.NewLine(fFirstInPara);
		*pliNew = me._li;
	}

	// Update display height
	_dvp = dvp;

	// Update display width
	_dupLineMax = CalcDisplayDup();

	cpMost = me.GetCp();
	_cpCalcMax = cpMost;
	_vpCalcMax = _dvp;

	// Update paragraph caching information.
	_cpForNumber = cpMost;

	return cpMost;

err:
	DeleteSubLayouts(0, -1);
	Clear(AF_DELETEMEM);
	_dupLineMax = 0;
	_dvp = 0;
	return -1;
}

/*
 *	CDisplayPrinter::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height for TXTNS_FITTOCONTENT.
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 *
 *	@devnote
 *		This assumes that FormatRange was called just prior to this.
 */
HRESULT	CDisplayPrinter::GetNaturalSize(
	HDC hdcDraw,		//@parm DC for drawing
	HDC hicTarget,		//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Width in device units to use for fitting 
	LONG *pheight)		//@parm Height in device units to use for fitting
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayPrinter::GetNaturalSize");

	*pwidth = _dupLineMax;
	*pheight = _dvp;
	return S_OK;
}

/*
 *	CDisplayPrinter::IsPrinter()
 *
 *	@mfunc
 *		Returns whether this is a printer
 *
 *	@rdesc
 *		TRUE - is a display to a printer
 *		FALSE - is not a display to a printer
 */
BOOL CDisplayPrinter::IsPrinter() const
{
	AssertSz(_hdc, "CDisplayPrinter::IsPrinter no hdc set");
	
	return GetDeviceCaps(_hdc, TECHNOLOGY) == DT_RASPRINTER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\dispsl.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	DISPSL.CPP -- CDisplaySL class |
 *
 *		This is the Single-line display engine.  See disp.c for the base class
 *		methods and dispml.c for the Multi-line display engine.
 *	
 *	Owner:<nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_dispsl.h"
#include "_measure.h"
#include "_select.h"
#include "_render.h"
#include "_font.h"
#include "_dfreeze.h"

ASSERTDATA

const LONG CALC_XSCROLL_FROM_FIRST_VISIBLE = -2;

/*
 *	CDisplaySL::CDisplaySL
 *
 *	Purpose	
 *		Constructor
 */
CDisplaySL::CDisplaySL ( CTxtEdit* ped )
  : CDisplay( ped )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CDisplaySL");

	Assert(!_fMultiLine);
}

/*
 *	CDisplaySL::Init()
 *
 *	@mfunc	
 *		Init this display for the screen
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplaySL::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::Init");

	// Initialize our base class
	if(!CDisplay::Init())
		return FALSE;

    SetWordWrap(FALSE);
    return TRUE;
}

/*
 *	CDisplaySL::InitVars()
 *
 */
void CDisplaySL::InitVars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InitVars");

    _upScroll = 0;
	SetCpFirstVisible(0);
}

/*
 *	CDisplaySL::RecalcView(fUpdateScrollBars, prc)
 *
 *	@mfunc
 *		Recalc all lines breaks and update first visible line
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::RecalcView(
	BOOL	fUpdateScrollBars,	//@param TRUE - update scroll bars
	RECTUV* prc)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::RecalcView");
	LONG dupOld = _dup;

    if(!RecalcLine())
        return FALSE;

    if(_fViewChanged)
    {
		if(IsActive() || _dup <= GetDupView())
		{
			_upScroll = 0;
			SetCpFirstVisible(0);
		}
		else if(CALC_XSCROLL_FROM_FIRST_VISIBLE == _upScroll)
		{
			// In this case we want to set our upScroll by a visible. The
			// only way to get here is if the active view has been cloned
			// for displaying an inactive view.
 			_upScroll = 0;				// Assume that first visible is 0
			if(GetFirstVisibleCp())		// Check first visible
			{
				CMeasurer me(this);		// Start at cp 0
				me.NewLine(*this);		// Measure from there to where we are
		
				// Scroll is length to character
				_upScroll = CLine::UpFromCch(me, GetFirstVisibleCp(), TA_TOP);
			}
		}
		if(fUpdateScrollBars)
       		UpdateScrollBar(SB_HORZ, TRUE);

		_fViewChanged = FALSE;
    }

	// We only resize if width of single line control has changed.
	if(_dup != dupOld)
	{
		if (FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();

		else if (prc && _ped->_fInOurHost) /*bug fix# 5830, forms3 relies on old behavior*/
			_ped->TxGetClientRect(prc);
	}
    return TRUE;
}

/*
 *	CDisplaySL::RecalcLine()
 *
 *	@mfunc
 *		Recalculate a line
 *
 *	@rdesc
 *		TRUE if success <nl>
 *		FALSE if failure <nl>
 */
BOOL CDisplaySL::RecalcLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::RecalcLine");

    Assert( _ped );

	// Create a measurer starting at cp = 0
	CMeasurer me(this);

	LONG dupOld = _dup;
	BOOL fMeasured = CLine::Measure(me, MEASURE_FIRSTINPARA);

	if(!fMeasured)
	{
		Assert(FALSE);						// Should succeed
	    InitVars();
	    return FALSE;
	}

	_fNeedRecalc = FALSE;
	_fRecalcDone = TRUE;

	if(dupOld != _dup)
		_fViewChanged = TRUE;

	_fLineRecalcErr = FALSE;
	return fMeasured;
}

/*
 *	CDisplaySL::Render(rcView, rcRender)
 *
 *	@mfunc	
 *		Renders this line
 */
void CDisplaySL::Render(
	const RECTUV &rcView,	//@parm View RECT
	const RECTUV &rcRender)	//@parm RECT to render (must be contained in
							//		client rect)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::Render");
    POINTUV	pt;

	_fRectInvalid = FALSE;

	CRenderer re(this);

    if(!re.StartRender(rcView, rcRender))
        return;

    // Set renderer at top/left of view rect
    pt.u = rcView.left - _upScroll;
    pt.v = rcView.top;
    re.SetCurPoint(pt);
    // Renderer is set at cp = 0 at the moment
	CLine::Render(re, TRUE);
	re.EndRender(this, this, 0, pt);

	if(_fOffscreenOnce)
		_fUseOffscreenDC = _fOffscreenOnce = FALSE;

    // If line metrics are not yet up to date, get them from renderer
    if(_dup == -1)
    {
        _dup			= re._li._dup;
        _dvpHeight		= re._li._dvpHeight;
        _dvpDescent		= re._li._dvpDescent;
    }
}

/*
 *	CDisplaySL::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Wait until line array is recalculated up to line <p ili>
 *
 *	@rdesc
 *		Returns TRUE if lines were recalc'd up to ili (TRUE if ili == 0)
 */
BOOL CDisplaySL::WaitForRecalcIli (
	LONG ili)		//@parm Line index to recalculate line array up to
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::WaitForRecalcIli");

    return ili == 0;
}

/*
 *	CDisplaySL::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range for scrollbar <p nBar>
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplaySL::GetScrollRange(
	INT nBar) const		//@parm Scroll bar to interrogate (SB_VERT or SB_HORZ)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetScrollRange");

    Assert( IsMain() );

	LONG lRange = 0; 

    if(nBar != SB_VERT && _fUScrollEnabled)
    {
	    if(_ped->TxGetScrollBars() & WS_HSCROLL)
		{
			lRange = max(0, _dup + _ped->GetCaretWidth());
			lRange = min(lRange, _UI16_MAX);
		}
    }
	return lRange;
}

/*
 *	CDisplaySL::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update horizontal scroll bar
 *		Also figure whether the scroll bar should be visible or not
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplaySL::UpdateScrollBar (
	INT	 nBar,				//@parm Which scrollbar: SB_HORZ or SB_VERT
	BOOL fUpdateRange)		//@parm Should range be recomputed and updated
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::UpdateScrollBar");

	// Note: In the old days we didn't allow autosize & scroll bars, so to keep
	// forms working, we need this special logic with respect to autosize.
	if (!IsActive() || SB_VERT == nBar ||
		!_ped->fInOurHost() && _ped->TxGetAutoSize())
	{
		// Scroll bars are only updated on active views.
		return FALSE;
	}

	const DWORD dwScrollBars = _ped->TxGetScrollBars();
	const BOOL fHide = !(dwScrollBars & ES_DISABLENOSCROLL);
	BOOL fReturn = FALSE;
	BOOL fEnabled = TRUE;
	BOOL fEnabledOld = FALSE;
	LONG lScroll = 0;
	CTxtSelection *psel = _ped->GetSelNC();

	// Get scrolling position
	if(nBar == SB_HORZ)
	{
		if(!(dwScrollBars & WS_HSCROLL))
		{
			// even if we don't have scrollbars, we may allow horizontal
			// scrolling.

			if(!_fUScrollEnabled)
				_fUScrollEnabled = !!(dwScrollBars & ES_AUTOHSCROLL);
			return FALSE;
		}

		fEnabledOld = _fUScrollEnabled;
		lScroll = ConvertUPosToScrollPos(_upScroll);

        if(_dup <= _dupView)
            fEnabled = FALSE;
	}

	// !s beforehand because all true values aren't necessarily equal
	if(!fEnabled != !fEnabledOld)
	{
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			if (nBar == SB_HORZ)
				_fUScrollEnabled = fEnabled;
			else
				_fVScrollEnabled = fEnabled;
		}

		if(!_fDeferUpdateScrollBar)
		{
    		if(!fHide)					// Don't hide scrollbar, just disable
    			_ped->TxEnableScrollBar(nBar, fEnabled ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
    		else 
    		{
    			fReturn = TRUE;
    			// Make sure to hide caret before showing scrollbar
    			if(psel)
    				psel->ShowCaret(FALSE);

    			// Hide or show scroll bar
    			_ped->TxShowScrollBar(nBar, fEnabled);

    			if(psel)
    				psel->ShowCaret(TRUE);
            }
		}
	}
	
	// Set scrollbar range and thumb position
	if(fEnabled)
	{
        if(fUpdateRange)
        {
			if(!_fDeferUpdateScrollBar)
				_ped->TxSetScrollRange(nBar, 0, GetScrollRange(nBar), FALSE);
        }
        
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
			_ped->TxSetScrollPos(nBar, lScroll, TRUE);
	}
	else if (!_fDeferUpdateScrollBar)
	{
		// This turns off the scroll bar and only needs to happen when a change 
		// occurs so we can count on the change in state check above to set
		// _fUpdateScrollBarDeferred.
		if (!fEnabled && fEnabledOld)
			_ped->TxSetScrollRange(nBar, 0, 0, FALSE);
	}
	return fReturn;
}

BOOL CDisplaySL::IsMain() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::IsMain");

    return TRUE;
}

LONG CDisplaySL::GetDupLineMax() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetWidth");

    return CLine::_dup;
}

LONG CDisplaySL::GetHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetHeight");

    return CLine::_dvpHeight;
}

LONG CDisplaySL::GetResizeHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetResizeHeight");

    return CLine::_dvpHeight;
}

LONG CDisplaySL::LineCount() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::LineCount");

    return 1; 
}

/*
 *	CDisplaySL::GetCliVisible()
 *
 *	@mfunc
 *		Get count of visible lines and update GetCp()MostVisible for PageDown()
 *
 *	@rdesc
 *		count of visible lines
 */
LONG CDisplaySL::GetCliVisible (
	LONG* pcpMostVisible,				//@parm Returns cpMostVisible
	BOOL fLastCharOfLastVisible) const 	//@parm Want cp of last visible char
										// (ignored here).
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetCliVisible");

    if (pcpMostVisible)
        *pcpMostVisible = CLine::_cch;
    
    return 1;
}

LONG CDisplaySL::GetFirstVisibleLine() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetFirstVisibleLine");

    return 0;
}

/*
 *	CDisplaySL::GetLineText(ili, pchBuff, cchMost)
 *
 *	@mfunc
 *		Copy given line of this display into a character buffer
 *
 *	@rdesc
 *		number of character copied
 */
LONG CDisplaySL::GetLineText (
	LONG	ili,		//@parm Line to get text of
	TCHAR *	pchBuff,	//@parm Buffer to stuff text into
	LONG	cchMost)	//@parm Length of buffer
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetLineText");

    if(ili == 0)
    {
        cchMost = min(cchMost, _ped->GetTextLength());
        if(cchMost > 0)
        {
            CTxtPtr tp(_ped, 0);
            return tp.GetText( cchMost, pchBuff );
        }
    }
    return 0;
}

/*
 *	CDisplaySL::CpFromLine(ili, pdvp)
 *
 *	@mfunc
 *		Computes cp at start of given line 
 *		(and top of line position relative to this display)
 *
 *	@rdesc
 *		cp of given line; here always 0
 */
LONG CDisplaySL::CpFromLine (
	LONG ili,		//@parm Line we're interested in (if <lt> 0 means caret line)
	LONG *pdvp)		//@parm Returns top of line relative to display 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CpFromLine");
					//  	(NULL if don't want that info)
    Assert( ili == 0 );
    
    if(pdvp)
        *pdvp = 0;
    
    return 0;
}

/*
 *	CDisplaySL::LineFromCp(cp, fAtEnd)
 *
 *	@mfunc
 *		Computes line containing given cp.
 *
 *	@rdesc
 *		index of line found; here returns 0 always
 */
LONG CDisplaySL::LineFromCp(
	LONG cp,		//@parm cp to look for
	BOOL fAtEnd)	//@parm If true, return previous line for ambiguous cp
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::LineFromCp");

    return 0;
}

/*
 *	CDisplaySL::CpFromPoint(pt, prcClient, ptp, prp, fAllowEOL, pHit, pdispdim)
 *
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CDisplaySL::CpFromPoint(
	POINTUV		pt,			//@parm Point to compute cp at (client coords)
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const ptp,	//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual,	//@parm Out cp that pt is above
	CLine *		pliParent)	//@parm Parent pli for table row displays
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CpFromPoint");

    RECTUV  rcView;
	LONG cp = 0;
	LONG cch = 0;

	HITTEST		hit = HT_Nothing;

    GetViewRect(rcView, prcClient);

	if (pt.v >= rcView.top && pt.v <= rcView.bottom)
	{

		// Create measurer at cp(0)
		CMeasurer me(this);

		// Get character in the line
		pt.u += _upScroll - rcView.left;		// Transform to galley coordinates
		pt.v -= rcView.top;
		cch = CLine::CchFromUp(me, pt, pdispdim, &hit, pcpActual);

		// Don't allow click at EOL to select EOL marker and take into account
		// single line edits as well
		if(!fAllowEOL && cch == CLine::_cch && CLine::_cchEOP)
			me._rpTX.BackupCRLF();

		cp = me.GetCp();
	}

	if (phit)
		*phit = hit;
    if(ptp)
        ptp->SetCp(cp);
    if(prp)
        prp->Set(0, cch);
 
 	return cp;   
}

/*
 *	CDisplaySL::PointFromTp(tp, fAtEnd, pt, prp, taMode, pdx)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CDisplaySL::PointFromTp(
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of previous line for ambiguous cp
	POINTUV &		pt,		//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::PointFromTp");

	LONG	 dy = 0;
    RECTUV	 rcView;
    CLinePtr rp(this);

    if(!rp.SetCp(rtp.GetCp(), fAtEnd))
        return -1;

    AssertSz(_ped->_fInPlaceActive || prcClient, 
		"CDisplaySL::PointFromTp() called with invalid client rect");

    GetViewRect(rcView, prcClient);

    pt.u = rcView.left - _upScroll;
    pt.v = rcView.top;

    CMeasurer me(this, rtp);
    me.Move(-rp.GetIch());		// Backup to start of line      
    me.NewLine(*rp);				// Measure from there to where we are

	pt.u += CLine::UpFromCch(me, rp.GetIch(), taMode, pdispdim, &dy);
	pt.v += dy;

    if(prp)
        *prp = rp;
    return rp;
}

/*
 *	CDisplaySL::UpdateView(&tpFirst, cchOld, cchNew)
 *
 *	@mfunc
 *		Update visible part of display (the "view" on the screen).
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::UpdateView(
	CRchTxtPtr &tpFirst,	//@parm Text ptr where change happened
	LONG cchOld,			//@parm Count of chars deleted
	LONG cchNew)			//@parm Count of chars inserted
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::UpdateView");

    BOOL fUpdateScrollBarHorz = FALSE;
    BOOL fReturn = TRUE;
    RECTUV rcView;
	CTxtSelection *psel = _ped->GetSelNC();
	LONG dupOld = _dup;
	BOOL fScrollChanged = FALSE;
	RECTUV rcClient;
	RECTUV rc;
	LONG dvpOld = _dvpHeight;
                                                              
    if (_fNoUpdateView)
        return fReturn;

	AssertSz(_ped->_fInPlaceActive, "CDisplaySL::UpdateView(...) called when inactive");

    _ped->TxGetClientRect(&rcClient);
    GetViewRect(rcView, &rcClient);
    
    if(psel && !psel->PuttingChar())
        psel->ClearCchPending();

    if(!RecalcLine())
    {
        // We're in deep crap now, the recalc failed. Let's try to get
		// out of this with our head still mostly attached
        fReturn = FALSE;
    }

	// An update has occurred. Go offscreen to be flicker-free.
	if(!_fUseOffscreenDC)
		_fUseOffscreenDC = _fOffscreenOnce = TRUE;

	//If we tried to go offscreen, but the edit changed the first
	//character, it might be the WM_SETTEXT case called when dialogs
	//are instantiated, and so it doesn't make sense to go offscreen there.
	if (_fOffscreenOnce && tpFirst.GetCp() == 0)
		_fOffscreenOnce = _fUseOffscreenDC = FALSE;

    if(_dup <= _dupView)
    {
        // x scroll range is smaller than the view width
        // force x scrolling position = 0
        _upScroll = 0;
		SetCpFirstVisible(0);
		_fViewChanged = TRUE;
        fUpdateScrollBarHorz = TRUE;
    }

	_fRectInvalid = TRUE;

	// Only resize a Single Line edit control if the width changes
	if(_dup != dupOld)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
	}

	// If view changed, update scroll bars
    if(_fViewChanged)
	{
		_fViewChanged = FALSE;
        fScrollChanged = UpdateScrollBar(SB_HORZ);
	}

	// Scroll bar state did not change so we need to update screen
	// Build an invalidation rectangle. 
	rc = rcClient;
	if(dvpOld == _dvpHeight)
	{
		// Height of control did not change so we can minimize the update 
		// rectangle to the height of the control.
		rc.bottom = rcView.top + _dvpHeight;
	}

	// Tell display to update when it gets a chance
	_ped->TxInvalidateRect(&rc);

    return fReturn;
}


/*
 *	CDisplaySL::ScrollView(upScroll, vpScroll, fTracking, fFractionalScroll)
 *
 *	@mfunc
 *		Scroll view to new x and y position
 *
 *	@devnote
 *		This method tries to adjust the y scroll pos before
 *		scrolling to display complete line at top. x scroll 
 *		pos is adjusted to avoid scrolling all text off the 
 *		view rectangle.
 *
 *		Must be able to handle vpScroll <gt> pdp->yHeight and vpScroll <lt> 0
 *
 *	@rdesc
 *		TRUE if actual scrolling occurred, 
 *		FALSE if no change
 */
BOOL CDisplaySL::ScrollView (
	LONG upScroll,		//@parm New x scroll position
	LONG vpScroll,		//@parm New y scroll position
	BOOL fTracking,		//@parm TRUE indicates we are tracking scrollbar thumb
	BOOL fFractionalScroll)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::ScrollView");
	LONG dupMax;
	LONG dx = 0;
    RECTUV rcClient, rcClip;
	CTxtSelection *psel = _ped->GetSelNC();
	COleObject *pipo;

    AssertSz(_ped->_fInPlaceActive, "CDisplaySL::ScrollView() called when not in-place");
	
	if(upScroll == -1)
		return FALSE;

 	//For scrolling purposes, we clip to rcView's top and bottom, but rcClient's left and right
   	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcClip, &rcClient);
	rcClip.left = rcClient.left;
	rcClip.right = rcClient.right;
	
	// Determine horizontal scrolling pos.
	dupMax = _dup;
	upScroll = min(upScroll, dupMax);
	upScroll = max(0, upScroll);

	dx = _upScroll - upScroll;
	if(dx)
    {
		_upScroll = upScroll;

		// Calculate new first visible
		CMeasurer me(this);				// Create measurer at cp(0)
		POINTUV pt = {upScroll, 0};
		CDispDim dispdim;
		HITTEST Hit;
		LONG	cpActual;
		CLine::CchFromUp(me, pt, &dispdim, &Hit, &cpActual);
		
		SetCpFirstVisible(cpActual);	// Save character position
    }

	AssertSz(IsMain(), "CDisplaySL::ScrollView non-main SL control");

	// Now perform the actual scrolling
	if(dx)
	{
		if(!_fRectInvalid)
		{
			// Scroll only if scrolling < view dimensions and we are in-place
			// Note that we only scroll the active view and we can be in-place
			// active and have multiple inactive views.
			if(IsActive() && !IsTransparent() && dx < _dupView)
			{
				if(psel)
					psel->ShowCaret(FALSE);

				RECT rcxyClip;
				RectFromRectuv(rcxyClip, rcClip);

				_ped->TxScrollWindowEx(dx, 0, NULL, &rcxyClip);

				if(psel)
					psel->ShowCaret(TRUE);
			}
			else
				_ped->TxInvalidateRect(&rcClip);
		}

		if(psel)
			psel->UpdateCaret(FALSE);

		if(!fTracking && dx)
		{		
			_ped->SendScrollEvent(EN_HSCROLL);
			UpdateScrollBar(SB_HORZ);
		}
				
		_ped->TxUpdateWindow();

		// FUTURE: since we're now repositioning in place active 
		// objects every time we draw, this call seems to be 
		// superfluous (AndreiB)

		// Tell object subsystem to reposition any in place objects
		if(_ped->GetObjectCount())
		{
			pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
			if(pipo)
				pipo->OnReposition();
		}
	}
	return dx;
}

/*
 *	CDisplaySL::InvertRange(cp, cch, selAction)
 *
 *	@mfunc
 *		Invert a given range on screen (for selection)
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::InvertRange (
	LONG	cp,					//@parm Active end of range to invert
	LONG	cch,				//@parm Signed length of range
	SELDISPLAYACTION selAction)	//@parm What we are doing to the selection
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InvertRange");

	if(cch < 0)						//make cch negative, make cp the minimum
		cch = -cch;
	else
		cp -= cch;

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	// If display is frozen, just update recalc region and move on.
	if(_padc)
	{
		AssertSz(cp >= 0, "CDisplayML::InvertRange: range (cp) goes below"
				"zero!!" );
		// Make sure these values are bounded.
		if(cp > _ped->GetTextLength())	// Don't bother updating region;
			return TRUE;				//  it's out of bounds

		if(cp + cch > _ped->GetTextLength())
			cch -= cp + cch - _ped->GetTextLength();

		_padc->UpdateRecalcRegion(cp, cch, cch);
		return TRUE;
	}

	// Ensure all visible lines are recalced
	if(!WaitForRecalcView())
		return FALSE;

	//REVIEW (keithcu) CDisplayML::InvertRange() has a different order WRT
	//frozen displays and OLE objects.
	
	// If an object is being inverted, and that is all that
	// is being inverted, delegate to the ObjectMgr.
	if (cch == 1 && _ped->GetObjectCount() &&
		(selAction == selSetNormal || selAction == selSetHiLite) )
	{
		CObjectMgr* pobjmgr = _ped->GetObjectMgr();
		CTxtPtr		tp(_ped, cp);

		if(tp.GetChar() == WCH_EMBEDDING && pobjmgr)
			pobjmgr->HandleSingleSelect(_ped, cp, selAction == selSetHiLite);
	}

	// Get view rectangle
    AssertSz(_ped->_fInPlaceActive, "CDisplaySL::InvertRange() called when not in-place active");

	_ped->TxInvalidate();
	return TRUE;
}

/*
 *	CDisplaySL::InitLinePtr (&lp)
 *
 *	@mfunc
 *		Initialize a CLinePtr properly
 */
void CDisplaySL::InitLinePtr (
	CLinePtr & lp )		//@parm Ptr to line to initialize
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InitLinePtr");

    lp.Init(*this);
}

/*
 *	CDisplaySL::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT	CDisplaySL::GetNaturalSize(
	HDC	  hdcDraw,		//@parm DC for drawing
	HDC	  hicTarget,	//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Input/output width parm 
	LONG *pheight)		//@parm	Input/output height parm
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetNaturalSize");

	// Assume this won't work
	HRESULT hr = E_FAIL;

	// Set height temporarily so zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight(*pheight);

	// Adjust height and width by view inset
	LONG widthView  = *pwidth;
	LONG heightView = *pheight;
	GetViewDim(widthView, heightView);

	// Store adjustment so we can restore it to height & width
	LONG widthAdj  = *pwidth  - widthView;
	LONG heightAdj = *pheight - heightView;
	LONG uCaret = !_ped->fInOurHost() && !_ped->fInHost2() ? duCaret : 0;

	// Recalculate size needed
   	// Create a measurer starting at cp = 0
	CMeasurer me(this);
	CLine	  liNew;

	if(liNew.Measure(me, MEASURE_FIRSTINPARA))
	{
		*pwidth  = liNew._dup;
		if(dwMode == TXTNS_FITTOCONTENT2)
			*pwidth += liNew._upStart + me.GetRightIndent();
		*pheight = liNew._dvpHeight;
		hr = S_OK;
	}

	// Restore insets so output reflects true client rect needed
	*pwidth  += widthAdj + uCaret;
	*pheight += heightAdj;

	// Restore client height to match current cache
	SetClientHeight(yOrigHeightClient);
    return hr;
}

/*
 *	CDisplaySL::GetWordWrap()
 *
 *	@mfunc
 *		Gets the wrap flag  
 *
 *	@rdesc
 *		TRUE - Word wrap
 *		FALSE - No word Word wrap
 *
 *	@devnote
 *		Single line controls cannot word wrap.
 */
BOOL CDisplaySL::GetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetNoWrap");

	return FALSE;
}

/*
 *	CDisplaySL::Clone()
 *
 *	@mfunc
 *		Make a copy of this object
 *
 *	@rdesc
 *		NULL - failed
 *		CDisplay *
 */
CDisplay *CDisplaySL::Clone() const
{
	CDisplaySL *pdp = new CDisplaySL(_ped);
	if(pdp)
	{
		// Initialize our base class
		if(pdp->CDisplay::Init())
		{
			pdp->InitFromDisplay(this);

			// Setting scroll to 0 means use the first visible character
			pdp->_upScroll = CALC_XSCROLL_FROM_FIRST_VISIBLE;
			pdp->_fVScrollEnabled = _fVScrollEnabled;
			pdp->_fWordWrap = _fWordWrap;
			pdp->ResetDrawInfo(this);
			pdp->SetCpFirstVisible(GetFirstVisibleCp());

			// This can't be active view since it is a clone of some view
			pdp->SetActiveFlag(FALSE);
		}
	}
	return pdp;
}

/*
 *	CDisplaySL::GetMaxUScroll()
 *
 *	@mfunc
 *		Get the maximum u scroll value
 *
 *	@rdesc
 *		Maximum u scroll value
 *
 */
LONG CDisplaySL::GetMaxUScroll() const
{
	LONG uCaret = !_ped->fInOurHost() && !_ped->fInHost2() ? duCaret : 0;
	return _dup + uCaret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\dispml.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	DISPML.CPP -- CDisplayML class |
 *
 *		This is the Multi-line display engine.  See disp.c for the base class
 *		methods and dispsl.c for the single-line display engine.
 *	
 *	Owner:<nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *		Rick Sailor (for most of RE 2.0)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_dispml.h"
#include "_edit.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_select.h"
#include "_dfreeze.h"

/*
#include "icecap.h"

class CCapProfile
{
public:
	CCapProfile() { StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID); }
	~CCapProfile() { StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID); }
};
*/
ASSERTDATA

//
//	Invariant support
//
#define DEBUG_CLASSNAME	CDisplayML
#include "_invar.h"

// Timer tick counts for background task
#define cmsecBgndInterval 	300
#define cmsecBgndBusy 		100

// Lines ahead
const LONG cExtraBeforeLazy = 60;

// cursor.  NB!  6144 is not a measured number; 4096 was the former number,
// and it wasn't measured either; it just seemed like a good one.  We bumped
// the number to 6144 as a safe-fix to a problem which caused cursor-flashing
// for the eBook reader.  The eBook reader's idle process pumps up to
// 5120 characters into RichEdit between ReCalc attempts.  However, each
// recalc can still work on more that 5120 characters; if the
// insertion started at the middle of a line, then recalc starts
// at the beginning of the line, picking up a few extra characters.
#define NUMCHARFORWAITCURSOR	6144

#ifndef DEBUG
#define CheckView()
#define	CheckLineArray()
#endif
	

// ===========================  CDisplayML  =====================================================

#ifdef DEBUG
/*
 *	CDisplayML::Invariant
 *
 *	@mfunc	Make sure the display is in a valid state
 *
 *	@rdesc	TRUE if the tests succeeded, FALSE otherwise
 */
BOOL CDisplayML::Invariant(void) const
{
	CDisplay::Invariant();

	return TRUE;
}
#endif // DEBUG

/*
 *	CDisplayML::CalcScrollHeight()
 *
 *	@mfunc	
 *		Calculate the maximum Y scroll position.
 *
 *	@rdesc
 *		Maximum possible scrolling position
 *
 *	@devnote
 *		This routine exists because plain text controls do not have
 *		the auto-EOP and so the scroll height is different than
 *		the height of the control if the text ends in an EOP type
 *		character.
 */
LONG CDisplayML::CalcScrollHeight(LONG dvp) const
{
	// The max scroll height for plain text controls is calculated
	// differently because they don't have an automatic EOP character.
	if(!_ped->IsRich() && Count())
	{
		// If last character is an EOP, bump scroll height
		CLine *pli = Elem(Count() - 1);	// Get last line in array
		if(pli->_cchEOP)
			dvp += pli->GetHeight();
	}
	return dvp;
}

/*
 *	CDisplayML::GetMaxVpScroll()
 *
 *	@mfunc	
 *		Calculate the maximum Y scroll position.
 *
 *	@rdesc
 *		Maximum possible scrolling position
 *
 *	@devnote
 *		This routine exists because we may have to come back and modify this 
 *		calculation for 1.0 compatibility. If we do, this routine only needs
 *		to be changed in one place rather than the three at which it is used.
 *
 */
inline LONG CDisplayML::GetMaxVpScroll() const
{
	// The following code is turn off because we don't want to support 
	// 1.0 mode unless someone complained about it.  
#if 0		
 	if (_ped->Get10Mode())
	{
		// Ensure last line is always visible
		// (use dy as temp to calculate max scroll)
		vpScroll = Elem(max(0, Count() - 1))->_dvp;

		if(vpScroll > _dvpView)
			vpScroll = _dvpView;

		vpScroll = _dvp - vpScroll;
	}
#endif //0

	return CalcScrollHeight(_dvp);
}

/*
 *	CDisplayML::ConvertScrollToVPos(vPos)
 *
 *	@mfunc	
 *		Calculate the real scroll position from the scroll position
 *
 *	@rdesc
 *		Y position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the V position
 *		gets greater than that.
 */
LONG CDisplayML::ConvertScrollToVPos(
	LONG vPos)		//@parm Scroll position 
{
	// Get maximum scroll range
	LONG vpRange = GetMaxVpScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(vpRange >= _UI16_MAX)
	{
		// Yes - Extrapolate to "real" vPos		
		vPos = MulDiv(vPos, vpRange, _UI16_MAX);
	}
	return vPos;
}

/*
 *	CDisplayML::ConvertVPosToScrollPos()
 *
 *	@mfunc	
 *		Calculate the scroll position from the V position in the document.
 *
 *	@rdesc
 *		Scroll position from V position
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the V position
 *		gets greater than that.
 *
 */
inline LONG CDisplayML::ConvertVPosToScrollPos(
	LONG vPos)		//@parm V position in document
{
	// Get maximum scroll range
	LONG vRange = GetMaxVpScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(vRange >= _UI16_MAX)
	{
		// Yes - Extrapolate to "real" vPos		
		vPos = MulDiv(vPos, _UI16_MAX, vRange);
	}
	return vPos;
}

CDisplayML::CDisplayML (CTxtEdit* ped)
  : CDisplay (ped), _pddTarget(NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CDisplayML");

	Assert(!_dulTarget && !_dvlTarget);

	_fMultiLine = TRUE;
}

CDisplayML::~CDisplayML()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::~CDisplayML");

	delete _pddTarget;
}

/*
 *	CDisplayML::Init()
 *
 *	@mfunc	
 *		Init this display for the screen
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplayML::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Init");

	// Initialize our base class
	if(!CDisplay::Init())
		return FALSE;

	AssertSz(_ped, "CDisplayML::Init(): _ped not initialized in display");
	// Verify allocation zeroed memory out
	Assert(!_vpCalcMax && !_dupLineMax && !_dvp && !_cpMin);
	Assert(!_fBgndRecalc && !_fVScrollEnabled && !_fUScrollEnabled);

	// The printer view is not main, therefore we do this to make
	// sure scroll bars are not created for print views.
	DWORD dwScrollBars = _ped->TxGetScrollBars();

	if(IsMain() && (dwScrollBars & ES_DISABLENOSCROLL))
	{
		if(dwScrollBars & WS_VSCROLL)
		{
			// This causes wlm to assert on the mac. something about 
			// scrollbar being disabled
			_ped->TxSetScrollRange (SB_VERT, 0, 1, TRUE);
			_ped->TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
		}

		// Set horizontal scroll range and pos
		if(dwScrollBars & WS_HSCROLL) 
		{
			_ped->TxSetScrollRange (SB_HORZ, 0, 1, TRUE);
			_ped->TxEnableScrollBar(SB_HORZ, ESB_DISABLE_BOTH);
		}
	}

	SetWordWrap(_ped->TxGetWordWrap());
	_cpFirstVisible = _cpMin;
	
	Assert(!_upScroll && !_vpScroll && !_iliFirstVisible &&
		   !_cpFirstVisible && !_dvpFirstVisible);

    _TEST_INVARIANT_

	return TRUE;
}


//================================  Device drivers  ===================================
/*
 *	CDisplayML::SetMainTargetDC(hdc, dulTarget)
 *
 *	@mfunc
 *		Sets a target device for this display and updates view 
 *
 *	@devnote
 *		Target device can't be a metafile (can't get char width out of a 
 *		metafile)
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::SetMainTargetDC (
	HDC hdc,			//@parm Target DC, NULL for same as rendering device
	LONG dulTarget)		//@parm Max line width (not used for screen)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::SetMainTargetDC");

	if(SetTargetDC(hdc))
	{
		// This is here because this is what RE 1.0 did. 
		SetWordWrap(hdc || !dulTarget);

		// If dulTarget is greater than zero, then the caller is
		// trying to set the maximum width of the window (for measuring,
		// line breaking, etc.)  However,in order to make our measuring
		// algorithms more reasonable, we force the max size to be
		// *at least* as wide as the width of a character.
		// Note that dulTarget = 0 means use the view rect width
		_dulTarget = (dulTarget <= 0) ? 0 : max(DXtoLX(GetDupSystemFont()), dulTarget);
		// Need to do a full recalc. If it fails, it fails, the lines are
		// left in a reasonable state. No need to call WaitForRecalc()
		// because UpdateView() starts at position zero and we're always
		// calc'd up to there
		CDisplay::UpdateView();

		// Caret/selection has most likely moved
		CTxtSelection *psel = _ped->GetSelNC();
		if(psel) 
			psel->UpdateCaret(FALSE);
		return TRUE;
	}
	return FALSE;
}

// Useful for both main and printing devices. jonmat 6/08/1995
BOOL CDisplayML::SetTargetDC( HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::SetTargetDC");

	CDevDesc *pddTarget = NULL;

	// Don't allow metafiles to be set as the target device
	if(hdc && GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)
		return FALSE;

	if(hdc)
	{
		// Allocate device first to see if we can. We don't want to change
		// our state if this is going to fail.
		pddTarget = new CDevDesc(_ped);
		if(!pddTarget)
			return FALSE;				// We couldn't so we are done
	}

	// Remove any cached information for the old target device
	if(_pddTarget)
	{
		delete _pddTarget;
		_pddTarget = NULL;
	}
	if(hdc)
	{
		_pddTarget = pddTarget;			// Update device because we have one
		_pddTarget->SetDC(hdc, dxpInch, dypInch);
	}
	return TRUE;
}

//=================================  Line recalc  ==============================
/*
 *	CDisplayML::RecalcScrollBars()
 *
 *	@mfunc
 *		Recalculate the scroll bars if the view has changed.
 *
 *
 *	@devnote	There is a possibility of recursion here, so we
 *				need to protect ourselves.
 *
 *	To visualize this, consider two types of characters, 'a' characters 
 *	which are small in height and 'A' 's which are really tall, but the same 
 *	width as an 'a'. So if I have
 *
 *	a a A						<nl>
 *	A							<nl>
 *
 *	I'll get a calced size that's basically 2 * heightof(A).
 *	With a scrollbar, this could wordwrap to 
 *
 *	a a							<nl>
 *	A A							<nl>
 *
 *	which is of calced size heightof(A) + heightof(a); this is
 *	obviously less than the height in the first case.
 */
void CDisplayML::RecalcScrollBars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcScrollBars");

	if(_fViewChanged)
	{
  		_fViewChanged = FALSE;
		UpdateScrollBar(SB_VERT, TRUE);
    	UpdateScrollBar(SB_HORZ, TRUE);
    }
}

/*
 *	CDisplayML::RecalcLines(rtp, fWait)
 *
 *	@mfunc
 *		Recalc all line breaks. 
 *		This method does a lazy calc after the last visible line
 *		except for a bottomless control
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::RecalcLines (
	CRchTxtPtr &rtp,	//@parm Where change happened
	BOOL	    fWait)	//@parm Recalc lines down to _cpWait/_vpWait; then be lazy
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcLines");

	LONG		cliWait = cExtraBeforeLazy;	// Extra lines before being lazy
	BOOL		fDone = TRUE;
	BOOL		fFirstInPara = TRUE;
	CLine *		pliNew = NULL;
	LONG		dupLineMax;
	LONG		dvp = 0;
    LONG        cchText = _ped->GetTextLength();
	BOOL		fWaitingForFirstVisible = TRUE;
	LONG		dvpView = _dvpView;
	LONG		dvpScrollOld = GetMaxVpScroll();
	LONG		dvpScrollNew;

	DeleteSubLayouts(0, -1);
	Remove(0, -1);							// Remove all old lines from *this
	_vpCalcMax = 0;							// Set both maxes to start of text
	_cpCalcMax = 0;

	// Don't stop at bottom of view if we're bottomless and active.
	if(!_ped->TxGetAutoSize() && IsActive())
	{
		// Be lazy - don't bother going past visible portion
		_cpWait = -1;
		_vpWait = -1;
		fWait = TRUE;
	}

	CMeasurer me(this, rtp);
	me.SetCp(0);
	me.SetNumber(0);

	// The following loop generates new lines
	while(me.GetCp() < cchText)
	{
		// Add one new line
		pliNew = Add(1, NULL);
		if (!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			TRACEWARNSZ("Out of memory Recalc'ing lines");
			goto err;
		}

		// Stuff text into new line
		UINT uiFlags = MEASURE_BREAKATWORD | 
						(fFirstInPara ? MEASURE_FIRSTINPARA : 0);

    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		if(!Measure(me, pliNew, Count() - 1, uiFlags))
		{
			Assert(FALSE);
			goto err;
		}

		fFirstInPara = pliNew->_fHasEOP;
		dvp += pliNew->GetHeight();
		_cpCalcMax = me.GetCp();
		AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");

		if(fWait)
		{
			// Do we want to do a background recalc? - the answer is yes if
			// three things are true: (1) We have recalc'd beyond the old first
			// visible character, (2) We have recalc'd beyond the visible 
			// portion of the screen and (3) we have gone beyond the next
			// cExtraBeforeLazy lines to make page down go faster.

			if(fWaitingForFirstVisible)
			{
				if(me.GetCp() > _cpFirstVisible)
				{
					_vpWait = dvp + dvpView;
					fWaitingForFirstVisible = FALSE;
				}
			}
			else if(dvp > _vpWait && cliWait-- <= 0 && me._rgpobjWrap.Count() == 0)
			{
				fDone = FALSE;
				break;
			}
		}
	}

	//Create 1 line for empty controls
	if(!Count())
		CreateEmptyLine();

    Paginate(0);

	_vpCalcMax = dvp;
	_fRecalcDone = fDone;
    _fNeedRecalc = FALSE;
	dvpScrollNew = CalcScrollHeight(dvp);

	if(fDone && (dvp != _dvp || dvpScrollNew != dvpScrollOld)
		|| dvpScrollNew > dvpScrollOld)
	{
		_fViewChanged = TRUE;
	}

	_dvp = dvp;
	dupLineMax = CalcDisplayDup();
    if(fDone && dupLineMax != _dupLineMax || dupLineMax > _dupLineMax)
    {
        _dupLineMax = dupLineMax;
		_fViewChanged = TRUE;
    }    

	Tracef(TRCSEVINFO, "CDisplayML::RecalcLine() - Done. Recalced down to line #%d", Count());

	if(!fDone)						// if not done, do rest in background
		fDone = StartBackgroundRecalc();

	if(fDone)
	{
		_vpWait = -1;
		_cpWait = -1;
		CheckLineArray();
		_fLineRecalcErr = FALSE;
	}

#if defined(DEBUG) && !defined(NOFULLDEBUG)
	if( 1 )
    {
		_TEST_INVARIANT_
	}
	//Array memory allocation tracking
	{
	void **pv = (void**)((char*)this + sizeof(CDisplay) + sizeof(void*));
	PvSet(*pv);
	}
#endif

	return TRUE;

err:
	TRACEERRORSZ("CDisplayML::RecalcLines() failed");

	if(!_fLineRecalcErr)
	{
		_cpCalcMax = me.GetCp();
		AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");
		_vpCalcMax = dvp;
		_fLineRecalcErr = TRUE;
		_ped->GetCallMgr()->SetOutOfMemory();
		_fLineRecalcErr = FALSE;			//  fix up CArray & bail
	}
	return FALSE;
}

/*
 *	CDisplayML::RecalcLines(rtp, cchOld, cchNew, fBackground, fWait, pled)
 *
 *	@mfunc
 *		Recompute line breaks after text modification
 *
 *	@rdesc
 *		TRUE if success
 *
 *	@devnote
 *		Most people call this the trickiest piece of code in RichEdit...
 */						     
BOOL CDisplayML::RecalcLines (
	CRchTxtPtr &rtp,		//@parm Where change happened
	LONG cchOld,			//@parm Count of chars deleted
	LONG cchNew,			//@parm Count of chars added
	BOOL fBackground,		//@parm This method called as background process
	BOOL fWait,				//@parm Recalc lines down to _cpWait/_vpWait; then be lazy
	CLed *pled)				//@parm Returns edit impact on lines (can be NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcLines");

	LONG		cchEdit;
	LONG		cchSkip;
	LONG		cliBackedUp = 0;
	LONG		cliWait = cExtraBeforeLazy;	
	BOOL		fDone = TRUE;
	BOOL		fFirstInPara = TRUE;
	LONG		ili;
	CLed		led;
	LONG		lT = 0;							// long Temporary
	LONG		iliMain;
	CLine *		pliMain;
	CLine *		pliNew;
	CLinePtr	rpOld(this);
	LONG		dupLineMax;
	LONG		dvp;
	LONG		dvpPrev = 0;
    LONG        cchText = _ped->GetTextLength();
    UINT        uiFlags;
	BOOL 		fReplaceResult;
	LONG		dvpExtraLine = 0;
	LONG		dvpScrollOld = GetMaxVpScroll();
	LONG		dvpScrollNew;
	WORD		wNumber = 0;
	CLineArray  rgliNew;
	DWORD		dwBgndTickMax = fBackground ? GetTickCount() + cmsecBgndBusy : 0;

	if(!pled)
		pled = &led;

#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	LONG cp = rtp.GetCp();

	if(cp > _cpCalcMax)
		Tracef(TRCSEVERR, "rtp %ld, _cpCalcMax %ld", cp, _cpCalcMax);

	AssertSz(cp <= _cpCalcMax, "CDisplayML::RecalcLines Caller didn't setup RecalcLines()");
	AssertSz(!(fWait && fBackground), "CDisplayML::RecalcLines wait and background both true");
	AssertSz(!(fWait && (-1 == _cpWait) && (-1 == _vpWait)),
		"CDisplayML::RecalcLines background recalc parms invalid");
#endif

	// We will not use background recalc if this is already a background recalc,
	// or if the control is not active or if this is an auto sized control.
	if(!IsActive() || _ped->TxGetAutoSize())
		fWait = FALSE;

	// Init line pointer on old CLayout and backup to start of line
	rpOld.SetCp(rtp.GetCp(), FALSE);
	cchSkip = rpOld.GetIch();
	rpOld.Move(-cchSkip);					// Point rp at 1st char in line

	ili = rpOld;							// Save line # at change for
	if(!Elem(ili)->IsNestedLayout())		//  numbering
	{
		if(ili && (IsInOutlineView() ||		// Back up if not first number
			rtp.GetPF()->IsListNumbered()))	//  in list or if in OutlineView
		{									//  (Outline symbol may change)
			ili--;						 
		}

		// Back up at least one line in case we can now fit more on it
		// If on a line border, e.g., just inserted an EOP, backup 2; else 1
		lT = !cchSkip + 1;

		while(rpOld > 0 &&
			  ((lT-- && (!rpOld[-1]._cchEOP || ili < rpOld)) || 
			  (rpOld[-1]._cObjectWrapLeft || rpOld[-1]._cObjectWrapRight)))
		{
			cliBackedUp++;
			rpOld--;
			cchSkip += rpOld->_cch;
		}
	}

	// Init measurer at rtp
	CMeasurer me(this, rtp);

	me.Move(-cchSkip);						// Point at start of text to measure
	cchEdit = cchNew + cchSkip;				// Number of chars affected by edit
	me.SetNumber(rpOld.GetNumber());		// Initialize list number
	
	// Determine whether we're on first line of paragraph
	if(rpOld > 0)
	{
		fFirstInPara = rpOld[-1]._fHasEOP;
		me.SetIhyphPrev(rpOld[-1]._ihyph);
	}

	dvp = VposFromLine(this, rpOld);

	// Update first-affected and pre-edit-match lines in pled
	pled->_iliFirst = rpOld;
	pled->_cpFirst	= pled->_cpMatchOld	= me.GetCp();
	pled->_vpFirst	= pled->_vpMatchOld	= dvp;
	AssertSz(pled->_vpFirst >= 0, "CDisplayML::RecalcLines _vpFirst < 0");
	
	Tracef(TRCSEVINFO, "Start recalcing from line #%d, cp=%d", pled->_iliFirst, pled->_cpFirst);

	// In case of error, set both maxes to where we are now
	_vpCalcMax = dvp;
	_cpCalcMax = me.GetCp();
	AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");

	// If we are past the requested area to recalc and background recalc is
	// allowed, then just go directly to background recalc. If there is no
	// height, we just go ahead and calculate some lines anyway. This
	// prevents any weird background recalcs from occuring when it is
	// unnecessary to go into background recalc.
	if(fWait && _vpWait > 0 && dvp > _vpWait && me.GetCp() > _cpWait)
	{
		_dvp = dvp;
		DeleteSubLayouts((LONG)rpOld, -1);
		rpOld.Remove(-1);				// Remove all old lines from here on
		StartBackgroundRecalc();		// Start up the background recalc		
		pled->SetMax(this);
		return TRUE;
	}

	pliMain = NULL;
	iliMain = rpOld.GetLineIndex();
	if (iliMain)
	{
		iliMain--;
		pliMain = rpOld.GetLine() - 1;
	}
    pliNew = NULL;

	// The following loop generates new lines for each line we backed
	// up over and for lines directly affected by edit
	while(cchEdit > 0)
	{
		pliNew = rgliNew.Add(1, NULL);		// Add one new line
		if (!pliNew)
		{
			TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLine in CLineArray");
			goto errspace;
		}

		uiFlags = MEASURE_BREAKATWORD | (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

		// Stuff text into new line
    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		dvpExtraLine = 0;
		if(!Measure(me, pliNew, rgliNew.Count() - 1, uiFlags, 0, iliMain, pliMain, &dvpExtraLine))
		{
			Assert(FALSE);
			goto err;
		}

		Assert(pliNew->_cch);

		fFirstInPara = pliNew->_fHasEOP;
		dvpPrev	 = dvp;
		dvp		+= pliNew->GetHeight();
		cchEdit	-= pliNew->_cch;
		AssertSz(cchEdit + me.GetCp() <= cchText, "CDisplayML::RecalcLines: want to measure beyond EOD");

		// Calculate on what line the edit started. We do this because
		// we want to render the first edited line off screen so if
		// the line is being edited via the keyboard we don't clip
		// any characters.
		if(cchSkip > 0)
		{
			// Check whether we backed up and the line we are examining
			// changed at all. Even if it didn't change in outline view
			// have to redraw in case outline symbol changes
			if (cliBackedUp && cchSkip >= pliNew->_cch && 
				pliNew->IsEqual(*(CLine *)(rpOld.GetLine())) && !IsInOutlineView()
				&& !pliNew->_cObjectWrapLeft && !pliNew->_cObjectWrapRight)
			{
				// Perfect match, this line was not the first edited.
               	Tracef(TRCSEVINFO, "New line matched old line #%d", (LONG)rpOld);

				cchSkip -= rpOld->_cch;

				// Update first affected line and match in pled
				pled->_iliFirst++;
				pled->_cpFirst	  += rpOld->_cch;
				pled->_cpMatchOld += rpOld->_cch;
				pled->_vpFirst	  += rpOld->GetHeight();
				AssertSz(pled->_vpFirst >= 0, "CDisplayML::RecalcLines _vpFirst < 0");
				pled->_vpMatchOld  += rpOld->GetHeight();
				cliBackedUp--;
			
				rgliNew.Clear(AF_KEEPMEM);		// Discard new line
				if(!(rpOld++))					// Next line
					cchSkip = 0;
			}
			else								// No match in the line, so 
				cchSkip = 0;					//  this line is the first to
		}										//  be edited

		if(fBackground && GetTickCount() >= dwBgndTickMax)
		{
			fDone = FALSE;						// took too long, stop for now
			goto no_match;
		}

		if (fWait && dvp > _vpWait && me.GetCp() > _cpWait && cliWait-- <= 0)
		{
			// Not really done, just past region we're waiting for
			// so let background recalc take it from here
			fDone = FALSE;
			goto no_match;
		}
	}											// while(cchEdit > 0) { }

   	Tracef(TRCSEVINFO, "Done recalcing edited text. Created %d new lines", rgliNew.Count());

	// Edit lines have been exhausted.  Continue breaking lines,
	// but try to match new & old breaks

	wNumber = me._wNumber;

	while(me.GetCp() < cchText)
	{
		// We are trying for a match so assume that there
		// is a match after all
		BOOL frpOldValid = TRUE;

		// Look for match in old line break CArray
		lT = me.GetCp() - cchNew + cchOld;
		while (rpOld.IsValid() && pled->_cpMatchOld < lT)
		{
			pled->_vpMatchOld  += rpOld->GetHeight();
			pled->_cpMatchOld += rpOld->_cch;

			if(!rpOld.NextRun())
			{
				// No more line array entries so we can give up on
				// trying to match for good.
				frpOldValid = FALSE;
				break;
			}
		} 

		// If perfect match, stop.
		if (frpOldValid && rpOld.IsValid() && pled->_cpMatchOld == lT && 
			rpOld->_cch && me._wNumber == rpOld->_bNumber)
		{
           	Tracef(TRCSEVINFO, "Found match with old line #%d", rpOld.GetLineIndex());

			// Update fliFirstInPara flag in 1st old line that matches.  Note
			// that if the new array doesn't have any lines, we have to look
			// into the line array preceding the current change.
			rpOld->_fFirstInPara = TRUE;
			if(rgliNew.Count() > 0) 
			{
				if(!(rgliNew.Elem(rgliNew.Count() - 1)->_fHasEOP))
					rpOld->_fFirstInPara = FALSE;
			}
			else if(rpOld >= pled->_iliFirst && pled->_iliFirst)
			{
				if(!(rpOld[pled->_iliFirst - rpOld - 1]._fHasEOP))
					rpOld->_fFirstInPara = FALSE;
			}

			pled->_iliMatchOld = rpOld;

			// Replace old lines by new ones
			lT = rpOld - pled->_iliFirst;
			rpOld = pled->_iliFirst;
			DeleteSubLayouts(pled->_iliFirst, lT);
			if(!rpOld.Replace (lT, &rgliNew))
			{
				TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLines in rpOld");
				goto errspace;
			}
			frpOldValid = rpOld.ChgRun(rgliNew.Count());
			rgliNew.Clear(AF_KEEPMEM);	 		// Clear aux array

			// Remember information about match after editing
			Assert((cp = rpOld.CalculateCp()) == me.GetCp());
			pled->_vpMatchOld  += dvpExtraLine;
			pled->_vpMatchNew	= dvp + dvpExtraLine;
			pled->_vpMatchNewTop = dvpPrev;
			pled->_iliMatchNew	= rpOld;
			pled->_cpMatchNew	= me.GetCp();

			// Compute height and cp after all matches
			_cpCalcMax = me.GetCp();
			AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");

			if(frpOldValid && rpOld.IsValid())
			{
				do
				{
					dvp	   += rpOld->GetHeight();
					_cpCalcMax += rpOld->_cch;
				}
				while( rpOld.NextRun() );
#ifdef DEBUG
				CTxtPtr tp(_ped, _cpCalcMax);
				AssertSz(!IN_RANGE(STARTFIELD, tp.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");
#endif
			}

			// Make sure _cpCalcMax is sane after the above update
			AssertSz(_cpCalcMax <= cchText, "CDisplayML::RecalcLines match extends beyond EOF");

			// We stop calculating here.Note that if _cpCalcMax < size 
			// of text, this means a background recalc is in progress.
			// We will let that background recalc get the arrays
			// fully in sync.  

			AssertSz(_cpCalcMax == cchText || _fBgndRecalc,
					"CDisplayML::Match less but no background recalc");

			if(_cpCalcMax != cchText)
			{
				// This is going to be finished by the background recalc
				// so set the done flag appropriately.
				fDone = FALSE;
			}
			goto match;
		}

		// Add a new line
		pliNew = rgliNew.Add(1, NULL);
		if(!pliNew)
		{
			TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLine in CLineArray");
			goto errspace;
		}

    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		// Stuff some text into new line
		wNumber = me._wNumber;
		if(!Measure(me, pliNew, rgliNew.Count() - 1, 
					MEASURE_BREAKATWORD | (fFirstInPara ? MEASURE_FIRSTINPARA : 0), 0,
					iliMain, pliMain))
		{
			Assert(FALSE);
			goto err;
		}
		
		fFirstInPara = pliNew->_fHasEOP;
		dvp += pliNew->GetHeight();

		if(fBackground && GetTickCount() >= (DWORD)dwBgndTickMax)
		{
			fDone = FALSE;			// Took too long, stop for now
			break;
		}

		if(fWait && dvp > _vpWait && me.GetCp() > _cpWait
			&& cliWait-- <= 0 && me._rgpobjWrap.Count() == 0)
		{							// Not really done, just past region we're
			fDone = FALSE;			//  waiting for so let background recalc
			break;					//  take it from here
		}
	}								// while(me < cchText) ...

no_match:
	// Didn't find match: whole line array from _iliFirst needs to be changed
	pled->_iliMatchOld	= Count(); 
	pled->_cpMatchOld	= cchText;
	pled->_vpMatchNew	= dvp;
	pled->_vpMatchNewTop = dvpPrev;
	pled->_vpMatchOld	= _dvp;
	_cpCalcMax			= me.GetCp();
	AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");

	// Replace old lines by new ones
	rpOld = pled->_iliFirst;

	// We store the result from the replace because although it can fail the 
	// fields used for first visible must be set to something sensible whether 
	// the replace fails or not. Further, the setting up of the first visible 
	// fields must happen after the Replace because the lines could have 
	// changed in length which in turns means that the first visible position
	// has failed.

	DeleteSubLayouts(rpOld, -1);
	fReplaceResult = rpOld.Replace(-1, &rgliNew);

	// _iliMatchNew & _cpMatchNew are used for first visible constants so we
	// need to set them to something reasonable. In particular the rendering
	// logic expects _cpMatchNew to be set to the first character of the first
	// visible line. rpOld is used because it is convenient.

	// Note we can't use RpBindToCp at this point because the first visible
	// information is screwed up because we may have changed the line that
	// the first visible cp is on. 
	rpOld.BindToCp(me.GetCp(), cchText);
	pled->_iliMatchNew = rpOld.GetLineIndex();
	pled->_cpMatchNew = me.GetCp() - rpOld.GetIch();

	if (!fReplaceResult)
	{
		TRACEERRORSZ("CDisplayML::RecalcLines rpOld.Replace() failed");
		goto errspace;
	}

    // Adjust first affected line if this line is gone
    // after replacing by new lines
    if(pled->_iliFirst >= Count() && Count() > 0)
    {
        Assert(pled->_iliFirst == Count());
        pled->_iliFirst = Count() - 1;
		pliNew = Elem(pled->_iliFirst);
        pled->_vpFirst -= pliNew->GetHeight();
		AssertSz(pled->_vpFirst >= 0, "CDisplayML::RecalcLines _vpFirst < 0");
        pled->_cpFirst -= pliNew->_cch;
    }
    
#ifdef DEBUG
	if (_ped->GetTextLength())
		Assert(Count());
#endif

	//Create 1 line for empty controls
	if(!Count())
		CreateEmptyLine();

match:
	_fRecalcDone = fDone;
    _fNeedRecalc = FALSE;
	_vpCalcMax = dvp;

	Tracef(TRCSEVINFO, "CDisplayML::RecalcLine(rtp, ...) - Done. Recalced down to line #%d", Count() - 1);

	// Clear wait fields since we want caller's to set them up.
	_vpWait = -1;
	_cpWait = -1;

	if(fDone && fBackground)
	{
		TRACEINFOSZ("Background line recalc done");
		_ped->TxKillTimer(RETID_BGND_RECALC);
		_fBgndRecalc = FALSE;
		_fRecalcDone = TRUE;
	}

	// Determine display height and update scrollbar
	dvpScrollNew = CalcScrollHeight(dvp);

	if (_fViewChanged || fDone && (dvp != _dvp || dvpScrollNew != dvpScrollOld)
		|| dvpScrollNew > dvpScrollOld) 
	{
	    //!NOTE:
	    // UpdateScrollBar can cause a resize of the window by hiding or showing
	    // scrollbars.  As a consequence of resizing the lines may get recalculated
	    // therefore updating _dvp to a new value, something != to dvp.
		_dvp = dvp;
   		UpdateScrollBar(SB_VERT, TRUE);
	}
	else
		_dvp = dvp;				// Guarantee heights agree

	// Determine display width and update scrollbar
	dupLineMax = CalcDisplayDup();
    if(_fViewChanged || (fDone && dupLineMax != _dupLineMax) || dupLineMax > _dupLineMax)
    {
        _dupLineMax = dupLineMax;
   		UpdateScrollBar(SB_HORZ, TRUE);
    }    

    _fViewChanged = FALSE;

	// If not done, do the rest in background
	if(!fDone && !fBackground)
		fDone = StartBackgroundRecalc();

	if(fDone)
	{
		CheckLineArray();
		_fLineRecalcErr = FALSE;
	}

#ifdef DEBUG
	if( 1 )
    {
		_TEST_INVARIANT_
	}
#endif // DEBUG

	Paginate(pled->_iliFirst);
	return TRUE;

errspace:
	_ped->GetCallMgr()->SetOutOfMemory();
	_fNeedRecalc = TRUE;
	_cpCalcMax = _vpCalcMax = 0;
	_fLineRecalcErr = TRUE;

err:
	if(!_fLineRecalcErr)
	{
		_cpCalcMax = me.GetCp();
		AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");
		_vpCalcMax = dvp;
	}

	TRACEERRORSZ("CDisplayML::RecalcLines() failed");

	if(!_fLineRecalcErr)
	{
		_fLineRecalcErr = TRUE;
		_ped->GetCallMgr()->SetOutOfMemory();
		_fLineRecalcErr = FALSE;			//  fix up CArray & bail
	}
	pled->SetMax(this);

	return FALSE;
}

/*
 *	CDisplayML::CalcDisplayDup()
 *
 *	@mfunc
 *		Calculates width of this display by walking line CArray and
 *		returning widest line.  Used for horizontal scrollbar routines.
 *
 *	@rdesc
 *		Widest line width in display
 */
LONG CDisplayML::CalcDisplayDup()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CalcDisplayDup");

	LONG	 dupLineMax = 0;

	if (_ped->fInOurHost() && (_ped->GetHost())->TxGetHorzExtent(&dupLineMax) == S_OK)
	{
		return dupLineMax;
	}

	LONG	 ili = Count();
	CLine 	*pli;

	if(ili)
	{
		LONG dupLine;
		pli = Elem(0);
		
		for(dupLineMax = 0; ili--; pli++)
		{
			dupLine = pli->_upStart + pli->_dup;
			dupLineMax = max(dupLineMax, dupLine);
		}
	}
    return dupLineMax;
}

/*
 *	CDisplayML::StartBackgroundRecalc()
 *
 *	@mfunc
 *		Starts background line recalc (at _cpCalcMax position)
 *
 *	@rdesc
 *		TRUE if done with background recalc
 */
BOOL CDisplayML::StartBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::StartBackgroundRecalc");

	if(_fBgndRecalc)
		return FALSE;					// Already in background recalc

	AssertSz(_cpCalcMax <= _ped->GetTextLength(), "_cpCalcMax > text length");

	if(_cpCalcMax == _ped->GetTextLength())
		return TRUE;					// Enough chars are recalc'd

	if(!_ped->TxSetTimer(RETID_BGND_RECALC, cmsecBgndInterval))
	{
		// Could not instantiate a timer so wait for recalculation
		WaitForRecalc(_ped->GetTextLength(), -1);
		return TRUE;
	}

	_fRecalcDone = FALSE;
	_fBgndRecalc = TRUE;
	return FALSE;
}

/*
 *	CDisplayML::StepBackgroundRecalc()
 *
 *	@mfunc
 *		Steps background line recalc (at _cpCalcMax position)
 *		Called by timer proc and also when going inactive.
 */
void CDisplayML::StepBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::StepBackgroundRecalc");

    _TEST_INVARIANT_
	
	if(!_fBgndRecalc)					// Not in background recalc,
		return;							//  so don't do anything

	LONG cch = _ped->GetTextLength() - _cpCalcMax;

	// Don't try recalc when processing OOM or had an error doing recalc or
	// if we are asserting.
#ifdef DEBUG
	if(_fInBkgndRecalc || _fLineRecalcErr)
	{
		if(_fInBkgndRecalc)
			TRACEINFOSZ("avoiding reentrant background recalc");
		else
			TRACEINFOSZ("OOM: not stepping recalc");
		return;
	}
#else
	if(_fInBkgndRecalc || _fLineRecalcErr)
		return;
#endif

	_fInBkgndRecalc = TRUE;
	if(!IsActive())
	{
		// Background recalc is over if we are no longer active	because
		// we can no longer get the information we need for recalculating.
		// But, if we are half recalc'd we need to set ourselves up to 
		// recalc again when we go active.
		InvalidateRecalc();
		cch = 0;
	}

	// Background recalc is over if no more chars or no longer active
	if(cch <= 0)
	{
		TRACEINFOSZ("Background line recalc done");
		_ped->TxKillTimer(RETID_BGND_RECALC);
		_fBgndRecalc = FALSE;
		_fRecalcDone = TRUE;
		_fInBkgndRecalc = FALSE;
		CheckLineArray();
		return;
	}

	CRchTxtPtr rtp(_ped, _cpCalcMax);
	AssertSz(!IN_RANGE(STARTFIELD, rtp.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");
	RecalcLines(rtp, cch, cch, TRUE, FALSE, NULL);

	_fInBkgndRecalc = FALSE;
}

/*
 *	CDisplayML::WaitForRecalc(cpMax, vpMax)
 *
 *	@mfunc
 *		Ensures that lines are recalced until a specific character
 *		position or vPos.
 *
 *	@rdesc
 *		success
 */
BOOL CDisplayML::WaitForRecalc(
	LONG cpMax,		//@parm Position recalc up to (-1 to ignore)
	LONG vpMax)		//@parm vPos to recalc up to (-1 to ignore)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalc");

    _TEST_INVARIANT_

	if(IsFrozen())
		return TRUE;

	BOOL fReturn = TRUE;
	LONG cch;

	if((vpMax < 0 || vpMax >= _vpCalcMax) &&
	   (cpMax < 0 || cpMax >= _cpCalcMax))
    {
    	cch = _ped->GetTextLength() - _cpCalcMax;
    	if(cch > 0 || Count() == 0)
    	{
    		HCURSOR hcur = NULL;

    		_cpWait = cpMax;
    		_vpWait = vpMax;
		
			if(cch > NUMCHARFORWAITCURSOR)
    			hcur = _ped->TxSetCursor(LoadCursor(0, IDC_WAIT));
    		TRACEINFOSZ("Lazy recalc");
		
			CRchTxtPtr rtp(_ped, _cpCalcMax);
    		if(!_cpCalcMax || _fNeedRecalc)
			{
    			fReturn = RecalcLines(rtp, TRUE);
				RebindFirstVisible();
				if(!fReturn)
					InitVars();
			}
    		else
    			fReturn = RecalcLines(rtp, cch, cch, FALSE, TRUE, NULL);

			if(hcur)
    			 _ped->TxSetCursor(hcur);
    	}
		else if(!cch)
		{
			// If there was nothing else to calc, make sure that we think
			// recalc is done.
#ifdef DEBUG
			if( !_fRecalcDone )
			{
				TRACEWARNSZ("For some reason we didn't think background "
					"recalc was done, but it was!!");
			}
#endif // DEBUG
			_fRecalcDone = TRUE;
		}
    }

	// If view rect changed, make sure to update scrollbars
	RecalcScrollBars();

	return fReturn;
}

/*
 *	CDisplayML::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Wait until line array is recalculated up to line <p ili>
 *
 *	@rdesc
 *		Returns TRUE if lines were recalc'd up to ili
 */
//REVIEW (keithcu) This recalcs up to the end! I'm not certain how great
//our background recalc, etc. stuff is. It seems not to work all that well for
//the complexity it adds to our codebase. I think we should either throw it
//away or redo it.
BOOL CDisplayML::WaitForRecalcIli (
	LONG ili)		//@parm Line index to recalculate line array up to
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalcIli");

	LONG cchGuess;

	while(!_fRecalcDone && ili >= Count())
	{
		// just go ahead and recalc everything.
		cchGuess = _ped->GetTextLength();
		if(IsFrozen() || !WaitForRecalc(cchGuess, -1))
			return FALSE;
	}
	return ili < Count();
}

/*
 *	CDisplayML::WaitForRecalcView()
 *
 *	@mfunc
 *		Ensure visible lines are completly recalced
 *
 *	@rdesc TRUE iff successful
 */
BOOL CDisplayML::WaitForRecalcView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalcView");

	return WaitForRecalc(-1, _vpScroll + _dvpView);
}

/*
 *	CDisplayML::InitLinePtr ( CLinePtr & plp )
 *
 *	@mfunc
 *		Initialize a CLinePtr properly
 */
void CDisplayML::InitLinePtr (
	CLinePtr & plp )		//@parm Ptr to line to initialize
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InitLinePtr");

    plp.Init( *this );
}

/*
 *	CDisplayML::GetLineText(ili, pchBuff, cchMost)
 *
 *	@mfunc
 *		Copy given line of this display into a character buffer
 *
 *	@rdesc
 *		number of character copied
 */
LONG CDisplayML::GetLineText(
	LONG ili,			//@parm Line to get text of
	TCHAR *pchBuff,		//@parm Buffer to stuff text into
	LONG cchMost)		//@parm Length of buffer
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetLineText");
    
	_TEST_INVARIANT_

	CTxtPtr tp (_ped, 0);

	if(ili >= 0 && (ili < Count() || WaitForRecalcIli(ili)))
	{
		cchMost = min(cchMost, Elem(ili)->_cch);
		if(cchMost > 0)
		{
			tp.SetCp(CpFromLine(ili, NULL));
			return tp.GetText(cchMost, pchBuff);
		}
	}
	*pchBuff = TEXT('\0');
	return 0;
}

/*
 *	CDisplayML::LineCount
 *
 *	@mfunc	returns the number of lines in this control.  Note that for plain
 *			text mode, we will add on an extra line of the last character is
 *			a CR.  This is for compatibility with MLE
 *
 *	@rdesc	LONG
 */
LONG CDisplayML::LineCount() const
{
	LONG cLine = Count();

	if (!_ped->IsRich() && (!cLine || 	   // If plain text with no lines
		 Elem(cLine - 1)->_cchEOP))		   //  or last line ending with a CR,
	{									   //  then inc line count
		cLine++;
	}
	return cLine;
}

// ================================  Line info retrieval  ====================================


/*
 *	CDisplayML::CpFromLine(ili, pdvp)
 *
 *	@mfunc
 *		Computes cp at start of given line 
 *		(and top of line position relative to this display)
 *
 *	@rdesc
 *		cp of given line
 */
LONG CDisplayML::CpFromLine (
	LONG ili,		//@parm Line we're interested in (if <lt> 0 means caret line)
	LONG *pdvp)		//@parm Returns top of line relative to display 
					//  	(NULL if don't want that info)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CpFromLine");

    _TEST_INVARIANT_
						
	LONG cli;
	LONG vp = _vpScroll + _dvpFirstVisible;
	LONG cp = _cpFirstVisible;
	CLine  *pli;
	LONG iStart = _iliFirstVisible;

	cli = ili - _iliFirstVisible;
	if(cli < 0 && -cli >= ili)
	{
		// Closer to first line than to first visible line,
		// so start at the first line
		cli = ili;
		vp = 0;
		cp = 0;
		iStart = 0;
	}
	else if( cli <= 0 )
	{
		CheckView();
		for(ili = _iliFirstVisible-1; cli < 0; cli++, ili--)
		{
			pli = Elem(ili);
			vp -= pli->GetHeight();
			cp -= pli->_cch;
		}
		goto end;
	}

	for(ili = iStart; cli > 0; cli--, ili++)
	{
		pli = Elem(ili);
		if(!IsMain() || !WaitForRecalcIli(ili))
			break;
		vp += pli->GetHeight();
		cp += pli->_cch;
	}

end:
	if(pdvp)
		*pdvp = vp;

	return cp;
}



/*
 *	CDisplayML::LineFromCp(cp, fAtEnd)
 *
 *	@mfunc
 *		Computes line containing given cp.
 *
 *	@rdesc
 *		index of line found, -1 if no line at that cp.
 */
LONG CDisplayML::LineFromCp(
	LONG cp,		//@parm cp to look for
	BOOL fAtEnd)	//@parm If true, return previous line for ambiguous cp
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineFromCp");
    
	_TEST_INVARIANT_

	CLinePtr rp(this);
	
	if(!WaitForRecalc(cp, -1) || !rp.SetCp(cp, fAtEnd))
		return -1;

	return (LONG)rp;
}

/*
 *	CDisplayML::CpFromPoint(pt, prcClient, prtp, prp, fAllowEOL, phit,
 *							pdispdim, pcpActual)
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CDisplayML::CpFromPoint(
	POINTUV		pt,			//@parm Point to compute cp at (client coords)
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const prtp,//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual,	//@parm Out cp that pt is above
	CLine *		pliParent)	//@parm Parent pli for table row displays
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CpFromPoint");
	CMeasurer me(this);

	return CLayout::CpFromPoint(me, pt, prcClient, prtp, prp, fAllowEOL, phit, pdispdim, pcpActual);
}

/*
 *	CDisplayML::PointFromTp(rtp, prcClient, fAtEnd, pt, prp, taMode, pdispdim)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CDisplayML::PointFromTp(
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of prev line for ambiguous cp
	POINTUV &		pt,		//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::PointFromTp");
	CMeasurer me(this, rtp);
	return CLayout::PointFromTp(me, rtp, prcClient, fAtEnd, pt, prp, taMode, pdispdim);
}

/*
 *	Render(rcView, rcRender)
 *
 *	@mfunc	
 *		Renders text.
 */
void CDisplayML::Render(
	const RECTUV &rcView,	//@parm View RECT
	const RECTUV &rcRender)	//@parm RECT to render (must be container in client rect)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Render");

    _TEST_INVARIANT_
								
    LONG	cp;
	LONG	ili;
	LONG	lCount = Count();
	CTxtSelection *psel = _ped->GetSelNC();
	POINTUV	pt;
    LONG	vpLine;

    if(psel)
		psel->ClearCchPending();

	// Calculate line and cp to start display at
	if(IsInPageView())
	{
		cp = _cpFirstVisible;
		ili = _iliFirstVisible;
		vpLine = _vpScroll;
	}
	else
		ili	= LineFromVpos(this, rcRender.top + _vpScroll - rcView.top, &vpLine, &cp);

	CLine *pli = Elem(ili);
	CLine *pliFirst = pli;
	LONG	dvpBottom = BottomOfRender(rcView, rcRender);
	LONG	vpLi = pli->GetHeight();

	// Calculate point where text will start being displayed
   	pt.u = rcView.left - _upScroll;
   	pt.v = rcView.top  - _vpScroll + vpLine;

	// Create and prepare renderer
	CRenderer re(this);

	if(!re.StartRender(rcView, rcRender))
		return;
	
	// Init renderer at start of first line to render
	re.SetCurPoint(pt);
	POINTUV ptFirst = pt;
   	LONG cpFirst = cp = re.SetCp(cp);
    vpLi = pt.v;

	// Render each line in update rectangle
	for (;; pli++, ili++)
	{
		BOOL fLastLine = ili == lCount - 1 ||
			re.GetCurPoint().v + pli->GetHeight() >= dvpBottom ||
			IsInPageView() && ili + 1 < lCount && (pli + 1)->_fFirstOnPage;

		//Support khyphChangeAfter
		if (ili > 0)
			re.SetIhyphPrev((pli - 1)->_ihyph);

		//Don't draw the line if it doesn't intersect the rendering area,
		//but draw at least 1 line so that we erase the control
		if (pt.v + pli->GetHeight() < rcRender.top && !fLastLine)
		{
			pt.v += pli->GetHeight();
			re.SetCurPoint(pt);
			re.Move(pli->_cch);
		}
		else if (!CLayout::Render(re, pli, &rcView, fLastLine, ili, lCount))
			break;

		if (fLastLine)
			break;

#ifdef DEBUG
		cp  += pli->_cch;
		vpLi += pli->GetHeight();

		// Rich controls with password characters stop at EOPs, 
		// so re.GetCp() may be less than cp.
		AssertSz(_ped->IsRich() && _ped->fUsePassword() || re.GetCp() == cp, "cp out of sync with line table");
#endif
		pt = re.GetCurPoint();
		AssertSz(pt.v == vpLi, "CDisplayML::RenderView() - y out of sync with line table");

	}

	re.EndRender(pliFirst, pli, cpFirst, ptFirst);
}


//===================================  View Updating  ===================================
/*
 *	CDisplayML::RecalcView(fUpdateScrollBars)
 *
 *	@mfunc
 *		Recalc all lines breaks and update first visible line
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::RecalcView(
	BOOL fUpdateScrollBars, RECTUV* prc)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcView");

	BOOL fRet = TRUE;
	LONG dvpOld = _dvp;
	LONG vpScrollHeightOld = GetMaxVpScroll();
	LONG dupOld = _dupLineMax;
	LONG vpScrollHeightNew;

	// Full recalc lines
    CRchTxtPtr rtp(_ped, 0);
	if(!RecalcLines(rtp, FALSE))
	{
		// We're in deep crap now, the recalc failed. Let's try to get out
		// of this with our head still mostly attached
		InitVars();
		fRet = FALSE;
        goto Done;
	}

    // Force _upScroll = 0 if x scroll range is smaller than the view width
    if(_dupLineMax <= _dupView)
        _upScroll = 0;

	vpScrollHeightNew = GetMaxVpScroll();
	RebindFirstVisible(vpScrollHeightNew <= _dvpView);

	CheckView();

	// We only need to resize if the size needed to display the object has 
	// changed.
	if (dvpOld != _dvp || vpScrollHeightOld != vpScrollHeightNew ||
		dupOld  != _dupLineMax)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		else if (prc && _ped->_fInOurHost)/*bug fix# 5830, forms3 relies on old behavior*/
			_ped->TxGetClientRect(prc);
	}

Done:

    // Now update scrollbars
	if(fUpdateScrollBars)
		RecalcScrollBars();

    return fRet;
}

/*
 *	CDisplayML::UpdateView(&rtp, cchOld, cchNew)
 *
 *	@mfunc
 *		Recalc lines and update the visible part of the display 
 *		(the "view") on the screen.
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::UpdateView(
	CRchTxtPtr &rtp,	//@parm Text ptr where change happened
	LONG cchOld,		//@parm Count of chars deleted
	LONG cchNew)		//@parm Count of chars inserted
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::UpdateView");

	BOOL fReturn = TRUE;
	BOOL fRecalcVisible = TRUE;
	RECTUV rcClient;
    RECTUV rcView;
	CLed led;
	CTxtSelection *psel = _ped->GetSelNC();
	LONG cpStartOfUpdate = rtp.GetCp();
	BOOL fNeedViewChange = FALSE;
	LONG dvpOld = _dvp;
	LONG vpScrollHeightOld = GetMaxVpScroll();
	LONG dupOld = _dupLineMax;
	LONG vpScrollOld = _vpScroll;
	LONG cpNewFirstVisible;

	if(_fNoUpdateView)
		return fReturn;

	AssertSz(_ped->_fInPlaceActive, "CDisplayML::UpdateView called when inactive");

	if(rtp.GetCp() > _cpCalcMax || _fNeedRecalc)
	{
		// We haven't even calc'ed this far, so don't bother with updating
		// here.  Background recalc will eventually catch up to us.
		if(!rtp.GetCp())				
		{								// Changes started at start of doc
			_cpCalcMax = 0;				//  so previous calc'd state is
			_vpCalcMax = 0;				//  completely invalid
		}
		return TRUE;
	}

	AssertSz(rtp.GetCp() <= _cpCalcMax, "CDisplayML::UpdateView: rtp > _cpCalcMax");

	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcView, &rcClient);

	if(psel && !psel->PuttingChar())
		psel->ClearCchPending();

	DeferUpdateScrollBar();

	// In general, background recalc should not start until both the scroll 
	// position is beyond the visible view and the cp is beyond the first visible 
	// character. However, for the recalc we will only wait on the height. 
	// Later calls to WaitForRecalc will wait on cpFirstVisible if that is 
	// necessary.
	_vpWait = _vpScroll + _dvpView;
	_cpWait = -1;

	if(!RecalcLines(rtp, cchOld, cchNew, FALSE, TRUE, &led))
	{
		// We're in deep crap now, the recalc failed. Let's try to get
		// out of this with our head still mostly attached
		InitVars();
		fRecalcVisible = TRUE;
		fReturn = FALSE;
		_ped->TxInvalidate();
		fNeedViewChange = TRUE;
		goto Exit;
	}

	if(_dupLineMax <= _dupView)
    {
		// x scroll range is smaller than the view width, force x scrolling position = 0
		// we have to redraw all when this means scrolling back to home.
		// Problem lines are lines with trailing spaces crossing _dupView. UpdateCaret forces redraw
		// only when such lines are growing, misses shrinking.
		if (_upScroll != 0)
			_ped->TxInvalidate();	//REVIEW: find a smaller rectangle?
			
		_upScroll = 0;
    }

	if(led._vpFirst >= _vpScroll + _dvpView)
	{
		// Update is after view: don't do anything
		fRecalcVisible = FALSE;
		AssertNr(VerifyFirstVisible());
		goto finish;
	}
	else if(led._vpMatchNew <= _vpScroll + _dvpFirstVisible &&
			led._vpMatchOld <= _vpScroll + _dvpFirstVisible &&
			_vpScroll < _dvp)
	{
		if (_dvp != 0)
		{
			// Update is entirely before view: just update scroll position
			// but don't touch the screen
			_vpScroll += led._vpMatchNew - led._vpMatchOld;
			_iliFirstVisible += led._iliMatchNew - led._iliMatchOld;
			_iliFirstVisible = max(_iliFirstVisible, 0);

			_cpFirstVisible += led._cpMatchNew - led._cpMatchOld;
			_cpFirstVisible = min(_ped->GetTextLength(), _cpFirstVisible);
			_cpFirstVisible = max(0, _cpFirstVisible);
			fRecalcVisible = FALSE;
			Sync_yScroll();
		}
		else
		{
			// Odd outline case. Height of control can be recalc'd to zero due 
			// when outline mode collapses all lines to 0. Example of how to 
			// do this is tell outline to collapse to heading 1 and there is none.
			_vpScroll = 0;
			_iliFirstVisible = 0;
			_cpFirstVisible = 0;
			_sPage = 0;
		}

		AssertNr(VerifyFirstVisible());
	}
	else
	{
		// Update overlaps visible view
		RECTUV rc = rcClient;

		// Do we need to resync the first visible?  Note that this if check
		// is mostly an optmization; we could decide to _always_ recompute
		// this _iliFirstVisible if we wanted to unless rtp is inside a table,
		// in which case _cpFirstVisible won't change and the following may
		// mess up _dvpFirstVisible.
		const CParaFormat *pPF = rtp.GetPF();

		if((!pPF->_bTableLevel || rtp._rpTX.IsAtTRD(0)) &&
		   (cpStartOfUpdate  <= _cpFirstVisible  || 
			led._iliMatchOld <= _iliFirstVisible ||
			led._iliMatchNew <= _iliFirstVisible ||
			led._iliFirst    <= _iliFirstVisible ))
		{
			// Edit overlaps the first visible. We try to maintain
			// approximately the same place in the file visible.
			cpNewFirstVisible = _cpFirstVisible;

			if(_iliFirstVisible - 1 == led._iliFirst)
			{
				// Edit occurred on line before visible view. Most likely
				// this means that the first character got pulled back to
				// the previous line so we want that line to be visible.
				cpNewFirstVisible = led._cpFirst;
			}

			// Change first visible entries because CLinePtr::SetCp() and
			// VposFromLine() use them, but they're not valid
			_dvpFirstVisible = 0;
			_cpFirstVisible = 0;
			_iliFirstVisible = 0;
			_vpScroll = 0;

			// With certain formatting changes, it's possible for 
			// cpNewFirstVisible to be less that what's been calculated so far 
			// in RecalcLines above. Wait for things to catch up.

			WaitForRecalc(cpNewFirstVisible, -1);
			Set_yScroll(cpNewFirstVisible);
		}
		AssertNr(VerifyFirstVisible());

		// Is there a match in the display area? - this can only happen if the
		// old match is on the screen and the new match will be on the screen
		if (led._vpMatchOld < vpScrollOld + _dvpView &&
			led._vpMatchNew < _vpScroll + _dvpView)
		{
			// We have a match inside visible view
			// Scroll the part that is below the old y pos of the match
			// or invalidate if the new y of the match is now below the view
			rc.top = rcView.top + (led._vpMatchOld - vpScrollOld);
			if(rc.top < rc.bottom)
			{
				// Calculate difference between new and old screen positions
				const INT dvp = (led._vpMatchNew - _vpScroll) - (led._vpMatchOld - vpScrollOld);

				if(dvp)
				{
					if(!IsTransparent() && _ped->GetBackgroundType() == -1)
					{
						LONG dxp, dyp;
						GetDxpDypFromDupDvp(0, dvp, GetTflow(), dxp, dyp);

						RECTUV rcClip = {rcClient.left, rcView.top, rcClient.right, rcView.bottom };
						RECT rcxyClip, rcxy;
						RectFromRectuv(rcxyClip, rcClip);
						RectFromRectuv(rcxy, rc);

    					_ped->TxScrollWindowEx(dxp, dyp, &rcxy, &rcxyClip);
						fNeedViewChange = TRUE;

    					if(dvp < 0)
	    				{
		    				rc.top = rc.bottom + dvp;

			    			_ped->TxInvalidateRect(&rc);
							fNeedViewChange = TRUE;
				    	}
    				}
                    else
                    {
						// Just invalidate cuz we don't scroll in transparent
						// mode
						RECTUV	rcInvalidate = rc;
   						rcInvalidate.top += dvp;

                        _ped->TxInvalidateRect(&rcInvalidate);
						fNeedViewChange = TRUE;
                    }
				}
			}
			else
			{
				rc.top = rcView.top + led._vpMatchNew - _vpScroll;
				_ped->TxInvalidateRect(&rc);
				fNeedViewChange = TRUE;
			}

			// Since we found that the new match falls on the screen, we can
			// safely set the bottom to the new match since this is the most
			// that can have changed.
			rc.bottom = rcView.top + max(led._vpMatchNew, led._vpMatchOld) - _vpScroll;
		}

		rc.top = rcView.top + led._vpFirst - _vpScroll;

		// Set first line edited to be rendered using off-screen bitmap
		if (led._iliFirst < Count() && !IsTransparent() && !Elem(led._iliFirst)->_fUseOffscreenDC)
			Elem(led._iliFirst)->_fOffscreenOnce = Elem(led._iliFirst)->_fUseOffscreenDC = TRUE;
		
		// Invalidate part of update that is above match (if any)
		_ped->TxInvalidateRect (&rc);
		fNeedViewChange = TRUE;
	}

finish:
	if(fRecalcVisible)
	{
		fReturn = WaitForRecalcView();
		if(!fReturn) 
			return FALSE;
	}
	if(fNeedViewChange)
		_ped->GetHost()->TxViewChange(FALSE);

	CheckView();

	// We only need to resize if size needed to display object has changed
	if (dvpOld != _dvp || vpScrollHeightOld != GetMaxVpScroll() ||
		dupOld  != _dupLineMax)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
	}
	if(DoDeferredUpdateScrollBar())
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		DoDeferredUpdateScrollBar();
	}

Exit:
	return fReturn;
}

/*
 *	CDisplayML::RecalcLine(cp)
 *
 *	@mfunc
 *		Show line
 */
void CDisplayML::RecalcLine(
	LONG cp)			//@parm cp line to recalc
{
	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();
	if(pnm)
		pnm->NotifyPostReplaceRange(NULL, cp, 0, 0, cp, cp);
}

void CDisplayML::InitVars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InitVars");

	_vpScroll = _upScroll = 0;
	_iliFirstVisible = 0;
	_cpFirstVisible = _cpMin = 0;
	_dvpFirstVisible = 0;
	_sPage = 0;
}


/*
 *	CDisplayML::GetCliVisible(pcpMostVisible)
 *
 *	@mfunc	
 *		Get count of visible lines and update _cpMostVisible for PageDown()
 *
 *	@rdesc
 *		count of visible lines
 */
LONG CDisplayML::GetCliVisible(
	LONG* pcpMostVisible, 				//@parm Returns cpMostVisible
	BOOL fLastCharOfLastVisible) const 	//@parm Want cp of last visible char
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetCliVisible");

	LONG cli	 = 0;							// Initialize count
	LONG ili	 = _iliFirstVisible;			// Start with 1st visible line
	LONG dvp = _dvpFirstVisible;
    LONG cp;
	const CLine *pli = Elem(ili);

	for(cp = _cpFirstVisible;
		dvp < _dvpView && ili < Count();
		cli++, ili++, pli++)
	{
		dvp	+= pli->GetHeight();

		//Note: I removed the support to give the last visible non-white character.
		//Does anyone want that? It never worked in LS displays.
		if (fLastCharOfLastVisible && dvp > _dvpView)
			break;

		if(IsInPageView() && cli && pli->_fFirstOnPage)
			break;

		cp += pli->_cch;
	}

    if(pcpMostVisible)
        *pcpMostVisible = cp;

	return cli;
}

//==================================  Inversion (selection)  ============================

/*
 *	CDisplayML::InvertRange(cp, cch)
 *
 *	@mfunc
 *		Invert a given range on screen (for selection)
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::InvertRange (
	LONG cp,					//@parm Active end of range to invert
	LONG cch,					//@parm Signed length of range
	SELDISPLAYACTION selAction)	//@parm Describes what we are doing to the selection
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InvertRange");

	LONG	 cpMost;
	RECTUV	 rc, rcClient, rcView;
	CLinePtr rp(this);
	CRchTxtPtr  rtp(_ped);
	LONG	 y;
	LONG	 cpActive = _ped->GetSel()->GetCp();

    AssertSz(_ped->_fInPlaceActive,	"CDisplayML::InvertRange() called when not in-place active");

	if(cch < 0)						// Define cpMost, set cp = cpMin,
	{								//  and cch = |cch|
		cpMost = cp - cch;
		cch = -cch;
	}
	else
	{
		cpMost = cp;
		cp -= cch;
	}

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	// If an object is being inverted, and nothing else is being inverted,
	// delegate to the ObjectMgr.  If fIgnoreObj is TRUE we highlight normally
	if (cch == 1 && _ped->GetObjectCount() &&
		(selAction == selSetNormal || selAction == selSetHiLite))
	{
		CObjectMgr* pobjmgr = _ped->GetObjectMgr();

		rtp.SetCp(cp);
		if(rtp.GetChar() == WCH_EMBEDDING)
		{
			if(pobjmgr)
				pobjmgr->HandleSingleSelect(_ped, cp, selAction == selSetHiLite);
			return TRUE;
		}
	}

	// If display is frozen, just update recalc region and move on.
	if(_padc)
	{
		AssertSz(cp >= 0, "CDisplayML::InvertRange: range (cp) goes below"
				"zero!!" );
		// Make sure these values are bounded.
		if(cp > _ped->GetTextLength())	// Don't bother updating region;
			return TRUE;				//  it's out of bounds

		if(cp + cch > _ped->GetTextLength())
			cch -= cp + cch - _ped->GetTextLength();

		_padc->UpdateRecalcRegion(cp, cch, cch);
		return TRUE;
	}

	if(!WaitForRecalcView())			// Ensure all visible lines are
		return FALSE;					//  recalc'd

	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcView, &rcClient);
	
	// Compute first line to invert and where to start on it
	if(cp >= _cpFirstVisible)
	{
		POINTUV pt;
		rtp.SetCp(cp);
		if(PointFromTp(rtp, NULL, FALSE, pt, NULL, TA_TOP) < 0)
			return FALSE;

		//We don't use the rp returned from PointFromTp because
		//we need the outermost rp for best results. In the future
		//we could consider writing code which doesn't invalidate so much.
		rp.SetCp(cp, FALSE, 0);
		rc.top = pt.v;
	}
	else
	{
		cp = _cpFirstVisible;
		rp = _iliFirstVisible;
		rc.top = rcView.top + _dvpFirstVisible;
	}				

	// Loop on all lines of range
	while (cp < cpMost && rc.top < rcView.bottom && rp.IsValid())
	{
		// Calculate rc.bottom first because rc.top takes into account
		// the dy of the first visible on the first loop.
		y = rc.top;
		y += rp->GetHeight();
		rc.bottom = min(y, rcView.bottom);
        rc.top = max(rc.top, rcView.top);

		//If we are inverting the active end of the selection, draw it offscreen
		//to minimize flicker.
		if (IN_RANGE(cp - rp.GetIch(), cpActive, cp - rp.GetIch() + rp->_cch) && 
			!IsTransparent() && !rp->_fUseOffscreenDC)
		{	
			rp->_fOffscreenOnce = rp->_fUseOffscreenDC = TRUE;
		}

		cp += rp->_cch - rp.GetIch();

		rc.left = rcClient.left;
        rc.right = rcClient.right;

	    _ped->TxInvalidateRect(&rc);
		rc.top = rc.bottom;
		if(!rp.NextRun())
			break;
	}
	_ped->TxUpdateWindow();				// Make sure window gets repainted
	return TRUE;
}


//===================================  Scrolling  =============================

/*
 *	CDisplay::VScroll(wCode, vPos)
 *
 *	@mfunc
 *		Scroll the view vertically in response to a scrollbar event
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		LRESULT formatted for WM_VSCROLL message		
 */
LRESULT CDisplayML::VScroll(
	WORD wCode,		//@parm Scrollbar event code
	LONG vPos)		//@parm Thumb position (vPos <lt> 0 for EM_SCROLL behavior)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::VScroll");

	LONG		cliVisible;
	LONG		dy = 0;
	BOOL		fTracking = FALSE;
	LONG		i;
	const LONG	iliSave = _iliFirstVisible;
	CLine *	pli = NULL;
	INT			dvpSys = GetDvpSystemFont();
	LONG		vpScroll = _vpScroll;
    
    AssertSz(_ped->_fInPlaceActive, "CDisplay::VScroll() called when not in-place");

	if(vPos)
	{
		// Convert this from 16-bit to 32-bit if necessary.
		vPos = ConvertScrollToVPos(vPos);
	}

	vPos = min(vPos, _dvp);

	if(IsInPageView())
	{
		BOOL	 fForward;
		BOOL	 fFoundNewPage = FALSE;
		LONG	 ili = _iliFirstVisible;
		LONG	 nLine = Count();
		CLine *pli = Elem(_iliFirstVisible);

		AssertSz(Elem(_iliFirstVisible)->_fFirstOnPage,
			"CDisplayML::VScroll: _iliFirstVisible not top of page");

		if(wCode <= SB_PAGEDOWN)
		{
			fForward = (wCode & 1);
			ili += fForward;
			while(ili && ili < nLine)
			{
				if(fForward > 0)
				{
					vpScroll += pli->GetHeight();

					if(ili == nLine - 1)
						break;
					pli++;
					ili++;
				}
				else
				{
					pli--;
					ili--;
					vpScroll -= pli->GetHeight();
				}
				if(pli->_fFirstOnPage)
				{
					fFoundNewPage = TRUE;
					break;
				}
			}
		}
		else if(wCode == SB_THUMBTRACK || wCode == SB_THUMBPOSITION)
		{
			if (vPos + _dvpView >= _dvp)	// At last page?
					vPos = _dvp;

			if(vPos > vpScroll)
			{
				LONG iliFirst = ili;
				LONG vpScrollPage = vpScroll;

				if(ili < nLine)
				{
					while(vpScroll < vPos)
					{
						vpScroll += pli->GetHeight();	// Advance to vPos

						if(ili == nLine - 1)
							break;

						pli++;
						ili++;

						if(pli->_fFirstOnPage)
						{
							fFoundNewPage = TRUE;
							vpScrollPage = vpScroll;
							iliFirst = ili;
						}
					}
				}
				vpScroll = vpScrollPage;			// Move to top of page
				ili = iliFirst;
			}
			else if(vPos < vpScroll)
			{								 	// Go back to vPos
				if(!ili)
				{
					vpScroll = 0;
					fFoundNewPage = TRUE;
				}
				while(vpScroll > vPos && ili)
				{
					pli--;
					ili--;
					vpScroll -= pli->GetHeight();
					if(pli->_fFirstOnPage)
						fFoundNewPage = TRUE;
				}
				while(!pli->_fFirstOnPage && ili)
				{
					pli--;
					ili--;
					vpScroll -= pli->GetHeight();
				}
			}
			AssertSz(Elem(ili)->_fFirstOnPage,
				"CDisplayML::VScroll: ili not top of page");
		}
		if(!fFoundNewPage)			// Nothing to scroll, early exit
			return MAKELRESULT(0, TRUE);
	}
	else
	{
		switch(wCode)
		{
		case SB_BOTTOM:
			if(vPos < 0)
				return FALSE;
			WaitForRecalc(_ped->GetTextLength(), -1);
			vpScroll = _dvp;
			break;

		case SB_LINEDOWN:
			cliVisible = GetCliVisible();
			if(_iliFirstVisible + cliVisible < Count()
				&& 0 == _dvpFirstVisible)
			{
				i = _iliFirstVisible + cliVisible;
				pli = Elem(i);
				if(IsInOutlineView())
				{	// Scan for uncollapsed line
					for(; pli->_fCollapsed && i < Count();
						pli++, i++);
				}
				if(i < Count())
					dy = pli->GetHeight();
			}
			else if(cliVisible > 1)
			{
				pli = Elem(_iliFirstVisible);
				dy = _dvpFirstVisible;
				// TODO: scan until find uncollapsed line
				dy += pli->GetHeight();
			}
			else
				dy = _dvp - _vpScroll;

			if(dy >= _dvpView)
				dy = dvpSys;

			// Nothing to scroll, early exit
			if ( !dy )
				return MAKELRESULT(0, TRUE); 

			vpScroll += dy;
			break;

		case SB_LINEUP:
			if(_iliFirstVisible > 0)
			{
				pli = Elem(_iliFirstVisible - 1);
				// TODO: scan until find uncollapsed line
				dy = pli->GetHeight();
			}
			else if(vpScroll > 0)
				dy = min(vpScroll, dvpSys);

			if(dy > _dvpView)
				dy = dvpSys;
			vpScroll -= dy;
			break;

		case SB_PAGEDOWN:
			cliVisible = GetCliVisible();
			vpScroll += _dvpView;
			if(vpScroll < _dvp && cliVisible > 0)
			{
				// TODO: Scan until find uncollapsed line
				dy = Elem(_iliFirstVisible + cliVisible - 1)->GetHeight();
				if(dy >= _dvpView)
					dy = dvpSys;

				else if(dy > _dvpView - dy)
				{
					// Go at least a line if line is very big
					dy = _dvpView - dy;
				}
				vpScroll -= dy;
			}
			break;

		case SB_PAGEUP:
			cliVisible = GetCliVisible();
			vpScroll -= _dvpView;

			if (vpScroll < 0)
			{
				// Scroll position can't be negative and we don't
				// need to back up to be sure we display a full line.
				vpScroll = 0;
			}
			else if(cliVisible > 0)
			{
				// TODO: Scan until find uncollapsed line
				dy = Elem(_iliFirstVisible)->GetHeight();
				if(dy >= _dvpView)
					dy = dvpSys;

				else if(dy > _dvpView - dy)
				{
					// Go at least a line if line is very big
					dy = _dvpView - dy;
				}

				vpScroll += dy;
			}
			break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
			if(vPos < 0)
				return FALSE;

			vpScroll = vPos;
			fTracking = TRUE;
			break;

		case SB_TOP:
			if(vPos < 0)
				return FALSE;
			vpScroll = 0;
			break;

		case SB_ENDSCROLL:
			UpdateScrollBar(SB_VERT);
			return MAKELRESULT(0, TRUE);

		default:
			return FALSE;
		}
	}
    
	BOOL fFractional = wCode != SB_PAGEDOWN && wCode != SB_PAGEUP;
	LONG vpLimit = _dvp;

	if(!IsInPageView() && fFractional)
		vpLimit = max(_dvp - _dvpView, 0);

	vpScroll = min(vpScroll, vpLimit);

	ScrollView(_upScroll, vpScroll, fTracking, fFractional);

	// Force position update if we just finished a track
	if(wCode == SB_THUMBPOSITION)
		UpdateScrollBar(SB_VERT);

	// Return how many lines we scrolled
	return MAKELRESULT((WORD) (_iliFirstVisible - iliSave), TRUE);
}

/*
 *	CDisplay::LineScroll(cli, cch)
 *
 *	@mfunc
 *		Scroll view vertically in response to a scrollbar event
 */
void CDisplayML::LineScroll(
	LONG cli,		//@parm Count of lines to scroll vertically
	LONG cch)		//@parm Count of characters to scroll horizontally
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineScroll");
	
	//Make sure the line to scroll to is valid
	if (cli + _iliFirstVisible >= Count())
	{
        // change line count enough to display the last line
		cli = Count() - _iliFirstVisible;
	}

    // Get the absolute vpScroll position by adding the difference of the line
    // we want to go to and the current _vpScroll position
	LONG dvpScroll = CalcVLineScrollDelta(cli, FALSE);
	if(dvpScroll < 0 || _dvp - (_vpScroll + dvpScroll) > _dvpView - dvpScroll)
		ScrollView(_upScroll, _vpScroll + dvpScroll, FALSE, FALSE);
}

/*
 *	CDisplayML::FractionalScrollView (vDelta)
 *
 *	@mfunc
 *		Allow view to be scrolled by fractional lines.
 */
void CDisplayML::FractionalScrollView ( LONG vDelta )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::FractionalScrollView");

	if ( vDelta)
		ScrollView(_upScroll, min(vDelta + _vpScroll, max(_dvp - _dvpView, 0)), FALSE, TRUE);
}

/*
 *	CDisplayML::ScrollToLineStart(iDirection)
 *
 *	@mfunc
 *		If the view is scrolled so that only a partial line is at the
 *		top, then scroll the view so that the entire view is at the top.
 */
void CDisplayML::ScrollToLineStart(
	LONG iDirection)	//@parm the direction in which to scroll (negative
						// means down the screen
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::ScrollToLineStart");

	// This code originally lined things up on a line. However, it doesn't work
	// very well with big objects especially at the end of the document. I am
	// leaving the call here in case we discover problems later. (a-rsail).

#if 0
	// If _dvpFirstVisible is zero, then we're aligned on a line, so
	// nothing more to do.

	if(_dvpFirstVisible)
	{
		LONG vpScroll = _vpScroll + _dvpFirstVisible;

		if(iDirection <= 0) 
		{
			vpScroll += Elem(_iliFirstVisible)->_dvp;
		}

		ScrollView(_upScroll, vpScroll, FALSE, TRUE);
	}
#endif // 0
}

/*
 *	CDisplayML::CalcVLineScrollDelta (cli, fFractionalFirst)
 *
 *	@mfunc
 *		Given a count of lines, positive or negative, calc the number
 *		of vertical units necessary to scroll the view to the start of
 *		the current line + the given count of lines.
 */
LONG CDisplayML::CalcVLineScrollDelta (
	LONG cli,
	BOOL fFractionalFirst )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CalcVLineScrollDelta");

	LONG vpScroll = 0;

	if(fFractionalFirst && _dvpFirstVisible)	// Scroll partial for 1st.
	{
		Assert(_dvpFirstVisible <= 0);		// get jonmat
		if(cli < 0)
		{
			cli++;
			vpScroll = _dvpFirstVisible;
		}
		else
		{
			cli--;
			vpScroll = Elem(_iliFirstVisible)->GetHeight() + _dvpFirstVisible;
		}
	}

	if(cli > 0)
	{
		// Scrolling down
		cli = min(cli, Count() - _iliFirstVisible - 1);

		if (!fFractionalFirst && (0 == cli))
		{
			// If we are scrolling down and on the last line but we haven't scrolled to
			// the very bottom, then do so now.
			AssertSz(0 == vpScroll, 
				"CDisplayML::CalcVLineScrollDelta last line & scroll");
			vpScroll = _dvp - _vpScroll;

			// Limit scroll length to approximately 3 lines.
			vpScroll = min(vpScroll, 3 * GetDvpSystemFont());
		}
	}
	else if(cli < 0)
	{
		// Scrolling up
		cli = max(cli, -_iliFirstVisible);

		// At the top.
		if (!fFractionalFirst && (0 == cli))
		{
			// Make sure that we scroll back so first visible is 0.
			vpScroll = _dvpFirstVisible;

			// Limit scroll length to approximately 3 lines.
			vpScroll = max(vpScroll, -3 * GetDvpSystemFont());
		}
	}

	if(cli)
		vpScroll += VposFromLine(this, _iliFirstVisible + cli) - VposFromLine(this, _iliFirstVisible);
	return vpScroll;
}

/*
 *	CDisplayML::ScrollView(upScroll, vpScroll, fTracking, fFractionalScroll)
 *
 *	@mfunc
 *		Scroll view to new x and y position
 *
 *	@devnote 
 *		This method tries to adjust the y scroll pos before
 *		scrolling to display complete line at top. x scroll 
 *		pos is adjusted to avoid scrolling all text off the 
 *		view rectangle.
 *
 *		Must be able to handle vpScroll <gt> pdp->dvp and vpScroll <lt> 0
 *
 *	@rdesc
 *		TRUE if actual scrolling occurred, 
 *		FALSE if no change
 */
BOOL CDisplayML::ScrollView (
	LONG upScroll,		//@parm New x scroll position
	LONG vpScroll,		//@parm New y scroll position
	BOOL fTracking,		//@parm TRUE indicates we are tracking scrollbar thumb
	BOOL fFractionalScroll)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::ScrollView");
	BOOL fTryAgain = TRUE;
	LONG dupMax;
	LONG dup = 0;
	LONG dvp = 0;
    RECTUV rcClient, rcClip;
	CTxtSelection *psel = _ped->GetSelNC();
	COleObject *pipo;
	BOOL fRestoreCaret = FALSE;
	LONG iliFirstVisible = _iliFirstVisible;

    AssertSz(_ped->_fInPlaceActive, "CDisplayML::ScrollView() called when not in-place");

	//For scrolling purposes, we clip to rcView's top and bottom, but rcClient's left and right
   	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcClip, &rcClient);
	rcClip.left = rcClient.left;
	rcClip.right = rcClient.right;
    
	if(upScroll == -1)
        upScroll = _upScroll;
	if(vpScroll == -1)
        vpScroll = _vpScroll;
	
	// Determine vertical scrolling pos
	while(1)
	{
		BOOL fNothingBig = TRUE;
		LONG vFirst;
		LONG dvFirst;
		LONG cpFirst;
		LONG iliFirst;
		LONG vpHeight;
		LONG iliT;

		vpScroll = min(vpScroll, GetMaxVpScroll());
		vpScroll = max(0, vpScroll);
		dvp = 0;

		// Ensure all visible lines are recalced
		if(!WaitForRecalcView())
			return FALSE;

		// Compute new first visible line
		iliFirst = LineFromVpos(this, vpScroll, &vFirst, &cpFirst);
		if(IsInPageView())
		{
			//REVIEW (keithcu) EBOOKS bug 424. Does this need to be here, or 
			//should the logic be somewhere else? Also, would it be better to round
			//rather than to always round down?
			CLine *pli = Elem(iliFirst);
			for(; !pli->_fFirstOnPage && iliFirst; iliFirst--)
			{
				pli--;						// Back up to previous line
				vFirst  -= pli->GetHeight();
				vpScroll -= pli->GetHeight();
				cpFirst -= pli->_cch;
			}
		}

		if( cpFirst < 0 )
		{
			// FUTURE (alexgo) this is pretty bogus, we should try to do
			// better in the next rel.

			TRACEERRORSZ("Display calc hosed, trying again");
			InitVars();
			_fNeedRecalc = TRUE;
			return FALSE;
		}

		if(iliFirst < 0)
		{
			// No line at _vpScroll, use last line instead
			iliFirst = max(0, Count() - 1);
			cpFirst = _ped->GetTextLength() - Elem(iliFirst)->_cch;
			vpScroll = _dvp - Elem(iliFirst)->GetHeight();
			vFirst = _vpScroll;
		}
		if(IsInPageView())
		{
			AssertSz(Elem(iliFirst)->_fFirstOnPage,
				"CDisplayML::ScrollView: _iliFirstVisible not top of page");
			if(vpScroll > vFirst)			// Tried to scroll beyond start
				vpScroll = vFirst;			//  of last line
			goto scrollit;
		}

		dvFirst = vFirst - vpScroll;
		
		// Figure whether there is a big line
		// (more that a third of the view rect)
		for(iliT = iliFirst, vpHeight = dvFirst;
			vpHeight < _dvpView && iliT < Count();
			iliT++)
		{
			const CLine *pli = Elem(iliT);
			if(pli->GetHeight() >= _dvpView / 3)
				fNothingBig = FALSE;
			vpHeight += pli->GetHeight();
		}

		// If no big line and first pass, try to adjust 
		// scrolling pos to show complete line at top
		if(!fFractionalScroll && fTryAgain && fNothingBig && dvFirst != 0)
		{
			fTryAgain = FALSE;		// prevent any infinite loop

			Assert(dvFirst < 0);

			Tracef(TRCSEVINFO, "adjusting scroll for partial line at %d", dvFirst);
			// partial line visible at top, try to get a complete line showing
			vpScroll += dvFirst;

			LONG dvpLine = Elem(iliFirst)->GetHeight();

			// Adjust the height of the scroll by the height of the first 
			// visible line if we are scrolling down or if we are using the 
			// thumb (tracking) and we are on the last page of the view.
			if ((fTracking && vpScroll + _dvpView + dvpLine > _dvp)
				|| (!fTracking && _vpScroll <= vpScroll))
			{
				// Scrolling down so move down a little more
				vpScroll += dvpLine;
			}
		}
		else
		{
			dvp = 0;
			if(vpScroll != _vpScroll)
			{
				_dvpFirstVisible = dvFirst;
scrollit:
				_iliFirstVisible = iliFirst;
				_cpFirstVisible = cpFirst;
				dvp = _vpScroll - vpScroll;
				_vpScroll = vpScroll;

				AssertSz(_vpScroll >= 0, "CDisplayML::ScrollView _vpScroll < 0");
				AssertNr(VerifyFirstVisible());
				if(!WaitForRecalcView())
			        return FALSE;
			}
			break;
		}
	}
	CheckView();

	// Determine horizontal scrolling pos.
	
	dupMax = _dupLineMax;

	// REVIEW (Victork) Restricting the range of the scroll is not really needed and could even be bad (bug 6104)
	
	upScroll = min(upScroll, dupMax);
	upScroll = max(0, upScroll);

	dup = _upScroll - upScroll;
	if(dup)
		_upScroll = upScroll;

	// Now perform the actual scrolling
	if(IsMain() && (dvp || dup))
	{
		// Scroll only if scrolling < view dimensions and we are in-place
		if(IsActive() && !IsTransparent() && 
		    dvp < _dvpView && dup < _dupView && !IsInPageView())
		{
			// FUTURE: (ricksa/alexgo): we may be able to get rid of 
			// some of these ShowCaret calls; they look bogus.
			if (psel && psel->IsCaretShown())
			{
				_ped->TxShowCaret(FALSE);
				fRestoreCaret = TRUE;
			}

			LONG dxp, dyp;
			GetDxpDypFromDupDvp(dup, dvp, GetTflow(), dxp, dyp);

			RECT rcxyClip;
			RectFromRectuv(rcxyClip, rcClip);
			_ped->TxScrollWindowEx(dxp, dyp, NULL, &rcxyClip);

			if(fRestoreCaret)
				_ped->TxShowCaret(FALSE);
		}
		else
			_ped->TxInvalidateRect(&rcClip);

		if(psel)
			psel->UpdateCaret(FALSE);

		if(!fTracking && dvp)
		{
			UpdateScrollBar(SB_VERT);
			_ped->SendScrollEvent(EN_VSCROLL);
		}
		if(!fTracking && dup)
		{
			UpdateScrollBar(SB_HORZ);
			_ped->SendScrollEvent(EN_HSCROLL);
		}
						
		// FUTURE: since we're now repositioning in place active 
		// objects every time we draw, this call seems to be 
		// superfluous (AndreiB)

		// Tell object subsystem to reposition any in place objects
		if(_ped->GetObjectCount())
		{
			pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
			if(pipo)
				pipo->OnReposition();
		}
	}
	bool fNotifyPageChange(false);
	if(IsInPageView() && iliFirstVisible != _iliFirstVisible)
	{
		CalculatePage(iliFirstVisible);
		fNotifyPageChange = true;
	}

	// Update the View after state has been updated
	if(IsMain() && (dvp || dup))
		_ped->TxUpdateWindow();

    if(fNotifyPageChange)
        GetPed()->TxNotify(EN_PAGECHANGE, NULL);

	return dvp || dup;
}

/*
 *	CDisplayML::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range for scrollbar <p nBar>
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplayML::GetScrollRange(
	INT nBar) const		//@parm Scroll bar to interrogate (SB_VERT or SB_HORZ)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetScrollRange");

    Assert( IsMain() );

	LONG lRange = 0;
    
    if(nBar == SB_VERT && _fVScrollEnabled)
    {
	    if(_ped->TxGetScrollBars() & WS_VSCROLL)
			lRange = GetMaxVpScroll();
    }
	else if((_ped->TxGetScrollBars() & WS_HSCROLL) && _fUScrollEnabled)
	{
		// Scroll range is maximum width.
		lRange = max(0, _dupLineMax + _ped->GetCaretWidth());
    }
	// Since thumb messages are limited to 16-bit, limit range to 16-bit
	lRange = min(lRange, _UI16_MAX);
	return lRange;
}

/*
 *	CDisplayML::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update either the horizontal or the vertical scrollbar and
 *		figure whether the scrollbar should be visible or not.
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplayML::UpdateScrollBar(
	INT nBar,				//@parm Which scroll bar : SB_HORZ, SB_VERT
	BOOL fUpdateRange)		//@parm Should the range be recomputed and updated
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::UpdateScrollBar");

	// Note: In the old days we didn't allow autosize & scroll bars, so to keep
	// forms working, we need this special logic with respect to autosize.
	if (!IsActive() || _fInRecalcScrollBars ||
		!_ped->fInOurHost() && _ped->TxGetAutoSize())
	{
		// No scroll bars unless we are inplace active and we are not in the
		// process of updating scroll bars already.
		return TRUE;
	}

	const DWORD dwScrollBars = _ped->TxGetScrollBars();
	const BOOL fHide = !(dwScrollBars & ES_DISABLENOSCROLL);
	BOOL fReturn = FALSE;
	BOOL fEnabled = TRUE;
	BOOL fEnabledOld;
	LONG lScroll;
	CTxtSelection *psel = _ped->GetSelNC();
	BOOL fShowCaret = FALSE;

	// Get scrolling position
	if(nBar == SB_VERT)
	{
		if(!(dwScrollBars & WS_VSCROLL))
			return FALSE;

		fEnabledOld = _fVScrollEnabled;
        if(GetMaxVpScroll() <= _dvpView)
            fEnabled = FALSE;
    }
	else
	{
		if(!(dwScrollBars & WS_HSCROLL))
		{
			// Even if we don't have scrollbars, we may allow horizontal
			// scrolling.
			if(!_fUScrollEnabled && _dupLineMax > _dupView)
				_fUScrollEnabled = !!(dwScrollBars & ES_AUTOHSCROLL);

			return FALSE;
		}

		fEnabledOld = _fUScrollEnabled;
        if(_dupLineMax <= _dupView)
            fEnabled = FALSE;
	}

	// Don't allow ourselves to be re-entered.
	// Be sure to turn this to FALSE on exit
	_fInRecalcScrollBars = TRUE;

	// !s beforehand because all true values aren't necessarily equal
	if(!fEnabled != !fEnabledOld)
	{
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			if (nBar == SB_HORZ)
				_fUScrollEnabled = fEnabled;
			else
				_fVScrollEnabled = fEnabled;
		}

		if(!_fDeferUpdateScrollBar)
		{
    		if(!fHide)
			{
				// Don't hide scrollbar, just disable
    			_ped->TxEnableScrollBar(nBar, fEnabled ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);

				if (!fEnabled)
				{
					// The scroll bar is disabled. Therefore, all the text fits
					// on the screen so make sure the drawing reflects this.
					_vpScroll = 0;
					_dvpFirstVisible = 0;
					_cpFirstVisible = 0;
					_iliFirstVisible = 0;
					_sPage = 0;
					_ped->TxInvalidate();
				}
			}
    		else 
    		{
    			fReturn = TRUE;
    			// Make sure to hide caret before showing scrollbar
    			if(psel)
    				fShowCaret = psel->ShowCaret(FALSE);

    			// Hide or show scroll bar
    			_ped->TxShowScrollBar(nBar, fEnabled);
				// The scroll bar affects the window which in turn affects the 
				// display. Therefore, if word wrap, repaint
				_ped->TxInvalidate();
				// Needed for bug fix #5521
				_ped->TxUpdateWindow();

    			if(fShowCaret)
    				psel->ShowCaret(TRUE);
            }
		}
	}
	
	// Set scrollbar range and thumb position
	if(fEnabled)
	{
        if(fUpdateRange && !_fDeferUpdateScrollBar)
			_ped->TxSetScrollRange(nBar, 0, GetScrollRange(nBar), FALSE);
        
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			lScroll = (nBar == SB_VERT)
				? ConvertVPosToScrollPos(_vpScroll)
				: ConvertUPosToScrollPos(_upScroll);

			_ped->TxSetScrollPos(nBar, lScroll, TRUE);
		}
	}
	_fInRecalcScrollBars = FALSE;
	return fReturn;
}

/*
 *	CDisplayML::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height for TXTNS_FITTOCONTENT[2].
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT	CDisplayML::GetNaturalSize(
	HDC hdcDraw,		//@parm DC for drawing
	HDC hicTarget,		//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Width in device units to use for fitting 
	LONG *pheight)		//@parm Height in device units to use for fitting
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetNaturalSize");

	HRESULT hr = S_OK;

	// Set the height temporarily so the zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight(*pheight);

	// Adjust height and width by view inset
	LONG widthView  = *pwidth;
	LONG heightView = *pheight;
	GetViewDim(widthView, heightView);

	// Store adjustment so we can restore it to height & width
	LONG widthAdj  = *pwidth  - widthView;
	LONG heightAdj = *pheight - heightView;
 	
	// Init measurer at cp = 0
	CMeasurer me(this);
	CLine liNew;
	LONG xWidth = 0, lineWidth;
	LONG dvp = 0;
   	LONG cchText = _ped->GetTextLength();
	BOOL fFirstInPara = TRUE;

	LONG dulMax = GetWordWrap() ? DXtoLX(widthView) : duMax;

	// The following loop generates new lines
	do 
	{	// Stuff text into new line
		UINT uiFlags = 0;

		// If word wrap is turned on, then we want to break on
		// words, otherwise, measure white space, etc.		
		if(GetWordWrap())
			uiFlags =  MEASURE_BREAKATWORD;

		if(fFirstInPara)
			uiFlags |= MEASURE_FIRSTINPARA;
	
		me.SetDulLayout(dulMax);
		if(!Measure(me, &liNew, 0, uiFlags))
		{
			hr = E_FAIL;
			goto exit;
		}
		fFirstInPara = liNew._fHasEOP;

		// Keep track of width of widest line
		lineWidth = liNew._dup;
		if(dwMode == TXTNS_FITTOCONTENT2)
			lineWidth += liNew._upStart + me.GetRightIndent();
		xWidth = max(xWidth, lineWidth);
		dvp += liNew.GetHeight();		// Bump height

	} while (me.GetCp() < cchText);

	// Add caret size to width to guarantee that text fits. We don't
	// want to word break because the caret won't fit when the caller
	// tries a window this size.
	xWidth += _ped->GetCaretWidth();

	*pwidth = xWidth;
	*pheight = dvp;

	// Restore insets so output reflects true client rect needed
	*pwidth += widthAdj;
	*pheight += heightAdj;
		
exit:
	SetClientHeight(yOrigHeightClient);
	return hr;
}

/*
 *	CDisplayML::Clone()
 *
 *	@mfunc
 *		Make a copy of this object
 *
 *	@rdesc
 *		NULL - failed
 *		CDisplay *
 *
 *	@devnote
 *		Caller of this routine is the owner of the new display object.
 */
CDisplay *CDisplayML::Clone() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Clone");

	CDisplayML *pdp = new CDisplayML(_ped);

	if(pdp)
	{
		// Initialize our base class
		if(pdp->CDisplay::Init())
		{
			pdp->InitFromDisplay(this);
			pdp->_upScroll = _upScroll;
			pdp->_fVScrollEnabled = _fVScrollEnabled;
			pdp->_fUScrollEnabled = _fUScrollEnabled;
			pdp->_fWordWrap = _fWordWrap;
			pdp->_cpFirstVisible = _cpFirstVisible;
			pdp->_iliFirstVisible = _iliFirstVisible;
			pdp->_vpScroll = _vpScroll;
			pdp->ResetDrawInfo(this);

			if(_pddTarget)
			{
				// Create a duplicate target device for this object
				pdp->SetMainTargetDC(_pddTarget->GetDC(), _dulTarget);
			}

			// This can't be the active view since it is a clone
			// of some view.
			pdp->SetActiveFlag(FALSE);
		}
	}
	return pdp;
}

void CDisplayML::DeferUpdateScrollBar()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DeferUpdateScrollBar");

	_fDeferUpdateScrollBar = TRUE;
	_fUpdateScrollBarDeferred = FALSE;
}

BOOL CDisplayML::DoDeferredUpdateScrollBar()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DoDeferredUpdateScrollBar");

	_fDeferUpdateScrollBar = FALSE;
	if(!_fUpdateScrollBarDeferred)
		return FALSE;

	_fUpdateScrollBarDeferred = FALSE;
	BOOL fHorizontalUpdated = UpdateScrollBar(SB_HORZ, TRUE);
    
	return UpdateScrollBar(SB_VERT, TRUE) || fHorizontalUpdated;
}

/*
 *	CDisplayML::GetMaxUScroll()
 *
 *	@mfunc
 *		Get the maximum x scroll value
 *
 *	@rdesc
 *		Maximum x scroll value
 *
 */
LONG CDisplayML::GetMaxUScroll() const
{
	return _dupLineMax + _ped->GetCaretWidth();
}

/*
 *	CDisplayML::CreateEmptyLine()
 *
 *	@mfunc
 *		Create an empty line
 *
 *	@rdesc
 *		TRUE - iff successful
 */
BOOL CDisplayML::CreateEmptyLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CreateEmptyLine");

	// Make sure that this is being called appropriately
	AssertSz(_ped->GetTextLength() == 0,
		"CDisplayML::CreateEmptyLine called inappropriately");

	CMeasurer me(this);					// Create a measurer
	CLine * pliNew = Add(1, NULL);	// Add one new line

	if(!pliNew)
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		TRACEWARNSZ("CDisplayML::CreateEmptyLine unable to add CLine to CLineArray");
		return FALSE;
	}

	// Measure the empty line
	me.SetDulLayout(1);
	if(!pliNew->Measure(me, MEASURE_BREAKATWORD | MEASURE_FIRSTINPARA))
	{
		Assert(FALSE);
		return FALSE;
	}
	return TRUE;
}

/*
 *	CDisplayML::AdjustToDisplayLastLine()
 *
 *	@mfunc
 *		Calculate the vpScroll necessary to get the last line to display
 *
 *	@rdesc
 *		Updated vpScroll
 *
 */
LONG CDisplayML::AdjustToDisplayLastLine(
	LONG yBase,			//@parm actual vpScroll to display
	LONG vpScroll)		//@parm proposed amount to scroll
{
	LONG iliFirst;
	LONG vFirst;

	if(yBase >= _dvp)
	{
		// Want last line to be entirely displayed.
		// Compute new first visible line
		iliFirst = LineFromVpos(this, vpScroll, &vFirst, NULL);

		// Is top line partial?
		if(vpScroll != vFirst)
		{
			// Yes - bump scroll to the next line so the ScrollView
			// won't bump the scroll back to display the entire 
			// partial line since we want the bottom to display.
			vpScroll = VposFromLine(this, iliFirst + 1);
		}
	}
	return vpScroll;
}

/*
 *	CDisplayML::GetResizeHeight()
 *
 *	@mfunc
 *		Calculates height to return for a request resize
 *
 *	@rdesc
 *		Updated vpScroll
 */
LONG CDisplayML::GetResizeHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetResizeHeight");

    return CalcScrollHeight(_dvp);
}

/*
 *	CDisplayML::RebindFirstVisible(fResetCp)
 *
 *	@mfunc
 *		rebind the first visible line
 *
 */
void CDisplayML::RebindFirstVisible(
	BOOL fResetCp)		//@parm If TRUE, reset cp to 0 
{
	LONG cp = fResetCp ? 0 : _cpFirstVisible;

	// Change first visible entries because CLinePtr::SetCp() and
	// YPosFromLine() use them, but they're not valid
	_dvpFirstVisible = 0;
	_cpFirstVisible = 0;
	_iliFirstVisible = 0;
	_vpScroll = 0;

	// Recompute scrolling position and first visible values after edit
	Set_yScroll(cp);
}

/*
 *	CDisplayML::Set_yScroll(cp)
 *
 *	@mfunc
 *		Set _yScroll corresponding to cp, making sure that in PageView
 *		the display starts at the top of a page
 */						     
void CDisplayML::Set_yScroll(
	LONG cp)		//@parm cp at which to set valid _yScroll
{
	// Recompute scrolling position and first visible values after edit
	CLinePtr rp(this);

   	if(!rp.SetCp(cp, FALSE))			// Couldn't get to cp, so find out
		cp = rp.CalculateCp();			//  cp we got to

   	_vpScroll = VposFromLine(this, rp);
   	_cpFirstVisible = cp - rp.GetIch();
   	_iliFirstVisible = rp;
	Sync_yScroll();						// Make sure _yScroll, _sPage, etc.,
}										//  are valid in PageView

/*
 *	CDisplayML::Sync_yScroll()
 *
 *	@mfunc
 *		Make sure that in PageView the display starts at the top of a page.
 *		Notify client if page number changes
 */						     
void CDisplayML::Sync_yScroll()
{
	if(IsInPageView())					// _yScroll must be to line at
	{									//  top of page
		CLine *pli = Elem(_iliFirstVisible);
		for(; !pli->_fFirstOnPage && _iliFirstVisible; _iliFirstVisible--)
		{
			pli--;						// Back up to previous line
			_vpScroll -= pli->GetHeight();
			_cpFirstVisible -= pli->_cch;
		}
		LONG sPage = _sPage;
		if(sPage != CalculatePage(0))
		{
			_ped->TxInvalidate();
			_ped->TxNotify(EN_PAGECHANGE, NULL);
		}
	}
}

/*
 *	CDisplayML::Paginate(ili, fRebindFirstVisible)
 *
 *	@mfunc
 *		Recompute page breaks from ili on
 *
 *	@rdesc
 *		TRUE if success
 */						     
BOOL CDisplayML::Paginate (
	LONG ili,					//@parm Line to redo pagination from
	BOOL fRebindFirstVisible)	//@parm If TRUE, call RebindFirstVisible()
{
	LONG cLine = Count();

	if(!IsInPageView() || ili >= cLine || ili < 0)
		return FALSE;

	LONG	iliSave = ili;
	CLine *	pli = Elem(ili);

	// Synchronize to top of current page
	for(; ili && !pli->_fFirstOnPage; pli--, ili--)
		;
	// Guard against widow-orphan changes by backing up an extra page
	if(ili && iliSave - ili < 2)
	{
		for(pli--, ili--; ili && !pli->_fFirstOnPage; pli--, ili--)
			;
	}

	LONG cLinePage = 1;					// One line on new page
	LONG dvpHeight = pli->GetHeight();	// Height on new page

	pli->_fFirstOnPage = TRUE;			// First line on page
	ili++;								// One less line to consider
	pli++;								// Advance to next line

	for(; ili < cLine; ili++, pli++)	// Process all lines from ili to EOD
	{
		dvpHeight += pli->GetHeight();	// Add in current line height
		cLinePage++;					// One more line on page (maybe)
		pli->_fFirstOnPage = FALSE;	

		CLine *pliPrev = pli - 1;		// Point at previous line

		if(dvpHeight > _dvpView || pliPrev->_fHasFF || pli->_fPageBreakBefore)
		{
			cLinePage--;
			if(cLinePage > 1 && !pliPrev->_fHasFF) // && fWidowOrphanControl)
			{
				if(pli->_fHasFF && pli->_cch == 1)	// FF line height causing
					continue;						// eject, so leave it on current page

				//If we are in the middle of a wrapped object, bump it to next page
				//We do not do widow/orphan if it could divide wrapped objects between pages
			if (_ped->IsRich())
			{
				if (pli->_cObjectWrapLeft || pli->_cObjectWrapRight)
				{
					CLine *pliOrig = pli;
					if (pli->_cObjectWrapLeft && !pli->_fFirstWrapLeft)
					{
						while (!pli->_fFirstWrapLeft)
							pli--;
					}
					int cLineBack = pliOrig - pli;
					pli = pliOrig;

					if (pli->_cObjectWrapRight && !pli->_fFirstWrapRight)
					{
						while (!pli->_fFirstWrapRight)
							pli--;
					}
					cLineBack = max(cLineBack, (int)(pliOrig - pli));
					pli = pliOrig;

					if (cLineBack < cLinePage) //Don't do this if object is larger than page
					{
						cLinePage -= cLineBack;
						pliPrev -= cLineBack;
						pli -= cLineBack;
						ili -= cLineBack;
					}
				}

 				// If this line and the previous one are in the same para,
 				// we might need widow/orphan logic
 				if (!pli->_fFirstInPara && !pliPrev->_cObjectWrapLeft &&
					!pliPrev->_cObjectWrapRight && (cLinePage > 1) )
				{
 					// If this line ends in an EOP bump both to following page
					// (widow/orphan), but only if either the line is short, or
					// we absolutely know that there will only be one line on
 					// the page. Do the same if prev line ends in a hyphenated
 					// word, and the preceding line does not
 					if (pli->_cchEOP && (pli->_dup < _dupView/2 || ili >= cLine - 1) ||   // Do we need -2 instead of -1?
						pliPrev->_ihyph && ili > 1 && !pliPrev->_fFirstOnPage && !pliPrev[-1]._ihyph)
 					{
 						cLinePage--;		// Point to previous line
 						pliPrev--;			
 						pli--;
 						ili--;
					}
				}
 	
				// Don't end a page with a heading.
				if(cLinePage > 1 && pliPrev->_nHeading &&
				   !pliPrev->_cObjectWrapLeft && !pliPrev->_cObjectWrapRight)
				{
					cLinePage--;
					pliPrev--;			
					pli--;
					ili--;
				}
			}
			}
			pli->_fFirstOnPage = TRUE;		// Define first line on page
			cLinePage = 1;					// One line on new page
			dvpHeight = pli->GetHeight();	// Current height of new page
		}
	}
	if(fRebindFirstVisible)
		RebindFirstVisible();
	return TRUE;
}

/*
 *	CDisplayML::CalculatePage(iliFirst)
 *
 *	@mfunc
 *		Compute page number for _iliFirstVisible starting with iliFirst
 *
 *	@rdesc
 *		Page number calculated
 */						     
LONG CDisplayML::CalculatePage (
	LONG iliFirst)
{
	if(Count() < 2 || !IsInPageView())
	{
		_sPage = 0;
		return 0;
	}

	if(iliFirst < 1)
		_sPage = 0;

	Assert(iliFirst >= 0 && iliFirst < Count());

	LONG	 iDir = 1;
	LONG	 n	 = _iliFirstVisible - iliFirst;
	CLine *pli  = Elem(iliFirst);		// Point at next/previous line

	if(n < 0)
	{
		n = -n;
		iDir = -1;
	}
	else
		pli++;

	for(; n--; pli += iDir)
		if(pli->_fFirstOnPage)
		{
			_sPage += iDir;
			if(_sPage < 0)
				_sPage = 0;
		}

	AssertSz(Elem(_iliFirstVisible)->_fFirstOnPage,
		"CDisplayML::CalculatePage: _iliFirstVisible not top of page");

	return _sPage;
}

/*
 *	CDisplayML::GetPage(piPage, dwFlags, pcrg)
 *
 *	@mfunc
 *		Get page number for _iliFirstVisible
 *
 *	@rdesc
 *		HRESULT = !piPage ? E_INVALIDARG :
 *				  IsInPageView() ? NOERROR : E_FAIL
 */						     
HRESULT CDisplayML::GetPage(
	LONG *piPage,		//@parm Out parm for page number
	DWORD dwFlags, 		//@parm Flags for which page to use
	CHARRANGE *pcrg)	//@parm Out parm for CHARRANGE for page
{
	if(!piPage)
		return E_INVALIDARG;

	*piPage = 0;

	if(dwFlags)							// No flags defined yet
		return E_INVALIDARG;

	if(!IsInPageView())
		return E_FAIL;

#ifdef DEBUG
	if(_sPage < 20)
	{
		LONG sPage = _sPage;
		CalculatePage(0);
		AssertSz(sPage == _sPage, "CDisplayML::GetPage: invalid cached page number");
	}
#endif

	*piPage = _sPage;
	if(pcrg)
	{
		pcrg->cpMin = _cpFirstVisible;
		GetCliVisible(&pcrg->cpMost, TRUE);
	}
	return NOERROR;
}

/*
 *	CDisplayML::SetPage(iPage)
 *
 *	@mfunc
 *		Go to page iPage
 *
 *	@rdesc
 *		HRESULT
 */						     
HRESULT CDisplayML::SetPage (
	LONG iPage)
{
	if(!IsInPageView())
		return E_FAIL;

	LONG nLine = Count();
				
	if(iPage < 0 || !nLine)
		return E_INVALIDARG;

	CLine *pli = Elem(0);					// Scroll from page 0
	LONG	 vpScroll = 0;
	LONG	 vpScrollLast = 0;

	nLine--;	// Decrement nLine so pli++ below will always be valid
	for(LONG ili = 0; ili < nLine && iPage; ili++)
	{
		vpScroll += pli->GetHeight();

		pli++;
		if(pli->_fFirstOnPage)				// Start of new page
		{
			vpScrollLast = vpScroll;
			iPage--;						// One less to go
		}
	}
	if(!_iliFirstVisible)					// This shouldn't be necessary...
		_vpScroll = 0;

	ScrollView(_upScroll, vpScrollLast, FALSE, FALSE);
	return NOERROR;
}
						   
/*
 *	CDisplayML::GetCurrentPageHeight()
 *
 *	@mfunc
 *		Return page height of current page in PageView mode
 *
 *	@rdesc
 *		page height of current page in PageView mode; else 0;
 */
LONG CDisplayML::GetCurrentPageHeight() const
{
	if(!IsInPageView())
		return 0;

	LONG	cLine = Count();
	LONG	dvp = 0;
	LONG	i = _iliFirstVisible;
	CLine *	pli = Elem(i);

	do
	{
		dvp += pli->GetHeight();		// Add in first line's height in any
		pli++;							//  case
		i++;
	}
	while(i < cLine && !pli->_fFirstOnPage);

	return dvp;
}

		
// ================================  DEBUG methods  ============================================

#ifdef DEBUG
/*
 *	CDisplayML::CheckLineArray()
 *
 *	@mfunc	
 *		DEBUG routine that Asserts unless:
 *			1) sum of all line counts equals count of characters in story
 *			2) sum of all line heights equals height of display galley
 */
void CDisplayML::CheckLineArray() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CheckLineArray");

	LONG ili = Count();

	// If we are marked as needing a recalc or if we are in the process of a
	// background recalc, we cannot verify the line array 
	if(!_fRecalcDone || _fNeedRecalc || !ili)
		return;

	LONG cchText = _ped->GetTextLength();

	if (!cchText)
		return;

	LONG cp = 0;
	BOOL fFirstInPara;
	BOOL fPrevLineEOP = TRUE;
	LONG dvp = 0;
	CLine const *pli = Elem(0);
	CTxtPtr tp(_ped, 0);

	while(ili--)
	{
		fFirstInPara = pli->_fFirstInPara;
		if(fPrevLineEOP	^ fFirstInPara)
		{
			tp.SetCp(cp);
			AssertSz(fFirstInPara && IsASCIIEOP(tp.GetPrevChar()),
				"CDisplayML::CheckLineArray: Invalid first/prev flags");
		}
		AssertSz(pli->_cch,	"CDisplayML::CheckLineArray: cch == 0");

		dvp += pli->GetHeight();
		cp		+= pli->_cch;
		fPrevLineEOP = pli->_fHasEOP;
		pli++;
	}

	if((cp != cchText) && (cp != _cpCalcMax))
	{
		Tracef(TRCSEVINFO, "sigma (*this)[]._cch = %ld, cchText = %ld", cp, cchText);
		AssertSz(FALSE,
			"CDisplayML::CheckLineArray: sigma(*this)[]._cch != cchText");
	}

	if(dvp != _dvp)
	{
		Tracef(TRCSEVINFO, "sigma (*this)[]._dvp = %ld, _dvp = %ld", dvp, _dvp);
		AssertSz(FALSE,
			"CDisplayML::CheckLineArray: sigma(*this)[]._dvp != _dvp");
	}
}

void CDisplayML::DumpLines(
	LONG iliFirst,
	LONG cli)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DumpLines");

	LONG cch;
	LONG ili;
	TCHAR rgch[512];

	if(Count() == 1)
		wcscpy(rgch, TEXT("1 line"));
	else
		wsprintf(rgch, TEXT("%d lines"), Count());
	
#ifdef UNICODE
    // TraceTag needs to take UNICODE...
#else
	TRACEINFOSZ(TRCSEVINFO, rgch);
#endif

	if(cli < 0)
		cli = Count();
	else
		cli = min(cli, Count());
	if(iliFirst < 0)
		iliFirst = Count() - cli;
	else
		cli = min(cli, Count() - iliFirst);

	for(ili = iliFirst; cli > 0; ili++, cli--)
	{
		const CLine * const pli = Elem(ili);

		wsprintf(rgch, TEXT("Line %d (%ldc%ldw%ldh): \""), ili, pli->_cch, 
			pli->_dup, pli->GetHeight());
		cch = wcslen(rgch);
		cch += GetLineText(ili, rgch + cch, CchOfCb(sizeof(rgch)) - cch - 4);
		rgch[cch++] = TEXT('\"');
		rgch[cch] = TEXT('\0');
#ifdef UNICODE
        // TraceTag needs to take UNICODE...
#else
    	TRACEINFOSZ(TRCSEVINFO, rgch);
#endif
	}
}

/*
 *	CDisplayML::CheckView()
 *
 *	@mfunc	
 *		DEBUG routine that checks coherence between _iliFirstVisible,
 *		_cpFirstVisible, and _dvpFirstVisible
 */
void CDisplayML::CheckView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CheckView");

	LONG dvp;
	VerifyFirstVisible(&dvp);

	if(dvp != _vpScroll + _dvpFirstVisible && !IsInPageView())
	{
		Tracef(TRCSEVINFO, "sigma CLine._dvp = %ld, CDisplay.vFirstLine = %ld", dvp, _vpScroll + _dvpFirstVisible);
		AssertSz(FALSE, "CLine._dvp != VIEW.vFirstLine");
	}
}

/*
 *	CDisplayML::VerifyFirstVisible(pHeight)
 *
 *	@mfunc
 *		DEBUG routine that checks coherence between _iliFirstVisible
 *		and _cpFirstVisible
 *
 *	@rdesc	TRUE if things are hunky dory; FALSE otherwise
 */
BOOL CDisplayML::VerifyFirstVisible(
	LONG *pHeight)
{
	LONG	cchSum;
	LONG	ili = _iliFirstVisible;
	CLine const *pli = Elem(0);
	LONG	dvp;

	for(cchSum = dvp = 0; ili--; pli++)
	{
		cchSum  += pli->_cch;
		dvp += pli->GetHeight();
	}

	if(pHeight)
		*pHeight = dvp;

	if(cchSum != _cpFirstVisible)
	{
		Tracef(TRCSEVINFO, "sigma CLine._cch = %ld, CDisplay.cpFirstVisible = %ld", cchSum, _cpMin);
		AssertSz(FALSE, "sigma CLine._cch != VIEW.cpMin");

		return FALSE;
	}
	return TRUE;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\dxfrobj.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	- DXFROBJ.C |
 *
 *		implementation of a generic IDataObject data transfer object.
 *		This object is suitable for use in OLE clipboard and drag drop
 *		operations
 *
 *	Author: <nl>
 *		alexgo (4/25/95)
 *
 *	Revisions: <nl>
 *		murrays (7/13/95) auto-doc'd and added cf_RTF
 *
 *	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dxfrobj.h"
#include "_range.h"
#include "hash.h"

#define NUMOBJCOPIEDFORWAITCURSOR	1
#ifdef SLOWCPU
#define NUMCHARCOPIEDFORWAITCURSOR	4096
#else
#define NUMCHARCOPIEDFORWAITCURSOR	16384
#endif

//
//	Common Data types
//

// If you change g_rgFETC[], change g_rgDOI[] and enum FETCINDEX and CFETC in
// _dxfrobj.h accordingly, and register nonstandard clipboard formats in
// RegisterFETCs(). Order entries in order of most desirable to least, e.g.,
// RTF in front of plain text.

//REVIEW (keithcu) All but the first column is const--separate into 2 data structures?
FORMATETC g_rgFETC[] =
{
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// CF_RTFUTF8
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// cf_RTF
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with NCRs for nonASCII
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbObject
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbSource
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// ObjDesc
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// LnkSource
	{CF_METAFILEPICT,	NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT},
	{CF_DIB,			NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{CF_BITMAP,			NULL, DVASPECT_CONTENT, -1, TYMED_GDI},
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with no objs
	{CF_UNICODETEXT,	NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{CF_TEXT,			NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// Filename
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// CF_RTFASTEXT
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// Text with objs
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE} // Richedit
};

// Keep in sync with above and with FETCINDEX and CFETC
const DWORD g_rgDOI[] =
{
	DOI_CANPASTERICH,						// RTF in UTF8 encoding
	DOI_CANPASTERICH,						// RTF
	DOI_CANPASTERICH,						// RTF with NCRs for nonASCII
	DOI_CANPASTEOLE,						// Embedded Object
	DOI_CANPASTEOLE,						// Embed Source
	DOI_CANPASTEOLE,						// Object Descriptor
	DOI_CANPASTEOLE,						// Link Source
	DOI_CANPASTEOLE,						// Metafile
	DOI_CANPASTEOLE,						// DIB
	DOI_CANPASTEOLE,						// Bitmap
	DOI_CANPASTERICH,						// RTF with no objects
	DOI_CANPASTEPLAIN,						// Unicode plain text
	DOI_CANPASTEPLAIN,						// ANSI plain text
	DOI_CANPASTEOLE,						// Filename
	DOI_CANPASTEPLAIN,						// Pastes RTF as text
	DOI_CANPASTERICH,						// Richedit Text
	DOI_CANPASTERICH						// RichEdit Text w/formatting
};

/*
 *	RegisterFETCs()
 *
 *	@func
 *		Register nonstandard format ETCs.  Called when DLL is loaded
 */
void RegisterFETCs()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "RegisterFETCs");

#ifdef RTF_HASHCACHE
	HashKeyword_Init();			// Init rtf control keyword hash table.
#endif
	g_rgFETC[iRtfFETC].cfFormat	// Note: cfFormats are WORDs
			= (WORD)RegisterClipboardFormatA("Rich Text Format");

	g_rgFETC[iRtfUtf8].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF in UTF8");

	g_rgFETC[iRtfNCRforNonASCII].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF with NCRs for nonASCII");

	g_rgFETC[iRtfAsTextFETC].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF As Text");

	g_rgFETC[iRichEdit].cfFormat
			= (WORD)RegisterClipboardFormatA("RICHEDIT");

	g_rgFETC[iObtDesc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_OBJECTDESCRIPTOR);

	g_rgFETC[iEmbObj].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_EMBEDDEDOBJECT);

	g_rgFETC[iEmbSrc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_EMBEDSOURCE);

	g_rgFETC[iLnkSrc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_LINKSOURCE);

	g_rgFETC[iRtfNoObjs].cfFormat
			= (WORD)RegisterClipboardFormatA("Rich Text Format Without Objects");

	g_rgFETC[iTxtObj].cfFormat
			= (WORD)RegisterClipboardFormatA("RichEdit Text and Objects");

	g_rgFETC[iFilename].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_FILENAME);
}


//
//	CDataTransferObj PUBLIC methods
//

/*
 *	CDataTransferObj::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		 QueryInterface for CDataTransferObj
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::QueryInterface (
	REFIID riid,			// @parm Reference to requested interface ID
	void ** ppv)			// @parm out parm for interface ptr
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::QueryInterface");

	if(!ppv)
		return E_INVALIDARG;

	*ppv = NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

    HRESULT		hresult = E_NOINTERFACE;

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IDataObject) ||
		IsEqualIID(riid, IID_IRichEditDO) )
	{
		*ppv = this;
		AddRef();
		hresult = NOERROR;
	}

	return hresult;
}

/*
 *	CDataTransferObj::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */
STDMETHODIMP_(ULONG) CDataTransferObj::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::AddRef");

	return ++_crefs;
}

/*
 *	CDataTransferObj::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */
STDMETHODIMP_(ULONG) CDataTransferObj::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		GlobalFree(_hPlainText);
		GlobalFree(_hRtfText);
		GlobalFree(_hRtfUtf8);
		GlobalFree(_hRtfNCRforNonASCII);
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDataTransferObj::DAdvise (pFormatetc, advf, pAdvSink, pdwConnection)
 *
 *	@mfunc
 *		establish an advisory connection
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::DAdvise(
	FORMATETC * pFormatetc,
	DWORD advf,
	IAdviseSink *pAdvSink,
	DWORD *pdwConnection)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::DAdvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::DUnadvise (dwConnection)
 *
 *	@mfunc
 *		destroy an advisory connection
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::DUnadvise(
	DWORD dwConnection)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::DUnadvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::EnumDAdvise (ppenumAdvise)
 *
 *	@mfunc
 *		enumerate advisory connections
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::EnumDAdvise(
	IEnumSTATDATA ** ppenumAdvise)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::EnumDAdvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::EnumFormatEtc (dwDirection, ppenumFormatEtc)
 *
 *	@mfunc
 *		returns an enumerator which lists all of the available formats in
 *		this data transfer object
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		we have no 'set' formats for this object
 */
STDMETHODIMP CDataTransferObj::EnumFormatEtc(
	DWORD dwDirection,					// @parm DATADIR_GET/SET
	IEnumFORMATETC **ppenumFormatEtc)	// @parm out parm for enum FETC interface
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::EnumFormatEtc");

	if(!ppenumFormatEtc)
		return E_INVALIDARG;

	*ppenumFormatEtc = NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	HRESULT hr = NOERROR;


	#ifdef DEBUG
	if (dwDirection == DATADIR_SET && !_ped->Get10Mode())
	{
		Tracef(TRCSEVNONE, "RichEdit 2.0 EnumFormatEtc called with DATADIR_SET");
	}
	#endif

	//Need riched10 compatibility hack to ignore dwDirection
	if(dwDirection == DATADIR_GET || _ped->Get10Mode())
		hr = CEnumFormatEtc::Create(_prgFormats, _cTotal, ppenumFormatEtc);

	return hr;
}

/*
 *	CDataTransferObj::GetCanonicalFormatEtc( pformatetc, pformatetcOut)
 *
 *	@mfunc
 *		from the given formatetc, return a more standard (or canonical)
 *		format.
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL
 *
 *	@devnote
 *		(alexgo): we may need to write this routine if we ever do anything
 *		snazzy with printers
 */
STDMETHODIMP CDataTransferObj::GetCanonicalFormatEtc(
	FORMATETC *pformatetc,
	FORMATETC *pformatetcOut)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetCanonicalFormatEtc");

	return E_NOTIMPL;
}

/*
 *	CDataTransferObj::GetData (pformatetcIn, pmedium)
 *
 *	@mfunc
 *		retrieves data of the specified format
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::GetData(
	FORMATETC *pformatetcIn, 
	STGMEDIUM *pmedium )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetData");

	FillMemory(pmedium, '\0', sizeof(STGMEDIUM));
	pmedium->tymed	 = TYMED_NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	CLIPFORMAT	cf = pformatetcIn->cfFormat;
	HRESULT		hr = E_OUTOFMEMORY;                     // Default not enuf RAM

	// now handle 'native' richedit formats.
	if( cf && pformatetcIn->tymed & TYMED_HGLOBAL )
	{
		if( cf == CF_UNICODETEXT )
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hPlainText, tPlain));

		else if(cf == CF_TEXT)
			pmedium->hGlobal = TextHGlobalWtoA(TextToHglobal(_hPlainText, tPlain));

		else if(cf == cf_RTF || cf == cf_RTFASTEXT || cf == cf_RTFNOOBJS)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfText, tRtf));

		else if(cf == cf_RTFUTF8)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfUtf8, tRtfUtf8));

		else if(cf == cf_RTFNCRFORNONASCII)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfNCRforNonASCII, tRtfNCRforNonASCII));
			
		else
		    hr = DV_E_FORMATETC;
		
        if (hr == E_OUTOFMEMORY)
        {
    		if( pmedium->hGlobal )						// Succeeded
    		{
    			pmedium->tymed	 = TYMED_HGLOBAL;
    			hr = NOERROR;
    		}
    		return hr;
    	}
	}
	
	if ((cf == cf_EMBEDDEDOBJECT ||
		 cf == cf_EMBEDSOURCE) &&
		(pformatetcIn->tymed & TYMED_ISTORAGE))
	{
        _pObjStg = GetDataForEmbeddedObject( _pOleObj, pmedium->pstg );
		pmedium->tymed = TYMED_ISTORAGE;
		if (NULL == pmedium->pstg)
			pmedium->pstg = _pObjStg;
		hr = _pObjStg != NULL ? NOERROR : hr;
		return hr;
	} 

	// Go through richedit's formats and see if there are any matches
	if( cf == cf_OBJECTDESCRIPTOR &&
			 (pformatetcIn->tymed & TYMED_HGLOBAL) &&
			 _hObjDesc)
	{    
		pmedium->hGlobal = DuplicateHGlobal(_hObjDesc);
		pmedium->tymed = TYMED_HGLOBAL;
		return NOERROR;
	}

    // First propogate the message to the object and see if it handles the format
    if (_pOleObj)
    {
        // Include the formats supported by the object
        IDataObject * pdataobj = NULL;
        if (FAILED(_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
            _pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);
            
        if (pdataobj)
        {
            hr = pdataobj->GetData(pformatetcIn, pmedium);
            pdataobj->Release();

            if (SUCCEEDED(hr))
            {
                if ((cf == cf_EMBEDDEDOBJECT || cf == cf_EMBEDSOURCE) && _pOleObj)
                {
                    OleSaveSiteFlags(pmedium->pstg, _dwFlags, _dwUser, _dvaspect);
                }
                return S_OK;
            }
        }
    }          

	if( cf == CF_METAFILEPICT )
	{
		pmedium->hMetaFilePict = OleDuplicateData(_hMFPict, CF_METAFILEPICT, 0);
		pmedium->tymed = TYMED_MFPICT;
		return NOERROR;
	}

	if( cf == CF_DIB )
	{
		if( _ped->HasObjects() && _cch == 1 )
		{
			COleObject *pobj = _ped->_pobjmgr->GetObjectFromCp(_cpMin);
			if (pobj)
			{
				HGLOBAL hdib = pobj->GetHdata();
				if (hdib)
				{
					pmedium->hGlobal = DuplicateHGlobal(hdib);
					pmedium->tymed = TYMED_HGLOBAL;
				}
			}
		}
		return NOERROR;
	}

	return DV_E_FORMATETC;
}

/*
 *	CDataTransferObj::GetDataForEmbeddedObject (pformatetc, lpstgdest)
 *
 *	@mfunc
 *		retrieves data for embedded object
 *
 *	@rdesc
 *		LPSTORAGE
 *
 */
LPSTORAGE CDataTransferObj::GetDataForEmbeddedObject(
	LPOLEOBJECT	 pOleObj,
	LPSTORAGE	 lpstgdest)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataForEmbeddedObject");
	
	HRESULT			 hr, hr1;
	LPPERSISTSTORAGE pperstg;

	if (_pObjStg != NULL && lpstgdest != NULL)
	{
		// We saved the data previously. Copy it to destination.
		hr = _pObjStg->CopyTo(0, NULL, NULL, lpstgdest);
		if (hr == NOERROR)
		{
			lpstgdest->Commit(STGC_DEFAULT);
			return _pObjStg;
		}
		return NULL;
	}

	if (_pObjStg != NULL && lpstgdest == NULL)
	{
		// We saved the data previously.  Return a reference
		_pObjStg->AddRef();
		return _pObjStg;
	}

	// We don't have a saved copy.  Create One.
	hr = pOleObj->QueryInterface( IID_IPersistStorage, (void **) &pperstg );
	if (hr != NOERROR)
		return NULL;

	if (lpstgdest == NULL)
	{
		// It is null.  We have to create our own.
		LPLOCKBYTES lpLockBytes = NULL;
		hr = CreateILockBytesOnHGlobal(NULL, TRUE, // delete on release
									   (LPLOCKBYTES *)&lpLockBytes);
		if (hr != NOERROR)
		{
			pperstg->Release();
			return NULL;
		}
		hr = StgCreateDocfileOnILockBytes(
			lpLockBytes,
			STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			0,	// reserved
			&lpstgdest
		);
		lpLockBytes->Release();
		if (hr != NOERROR)
		{
			pperstg->Release();
			return NULL;
		}
		_pObjStg = lpstgdest;
	}
	else
	{
		// Force the data to be saved
		_pObjStg = GetDataForEmbeddedObject( _pOleObj, NULL );
		pperstg->Release();
		return GetDataForEmbeddedObject( _pOleObj, lpstgdest );
	}

    // OLE2NOTE: even if OleSave returns an error you should still call 
    // SaveCompleted.
    hr = OleSave( pperstg, lpstgdest, FALSE /* fSameAsLoad */ );
 	hr1 = pperstg->SaveCompleted(NULL);
	if (hr != NOERROR || hr1 != NOERROR)			// Should we use SUCCEED macros ????
		lpstgdest = NULL;

	pperstg->Release();
	return _pObjStg;
}

/*
 *	CDataTransferObj::GetDataorObjectDescriptor (pformatetc, pmedium)
 *
 *	@mfunc
 *		retrieves data for embedded object descriptor
 *
 *	@rdesc
 *		HRESULT
 */
HGLOBAL CDataTransferObj::GetDataForObjectDescriptor(
	LPOLEOBJECT	 pOleObj,
	DWORD		 dwAspect,
	SIZEUV*      psize)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataForObjectDescriptor");

	POINTL ptl = {0};
	SIZEUV size = {0};
	if (psize)
	{
	    size.du = psize->du;
	    size.dv = psize->dv;
	}

	if (_hObjDesc == NULL)
	{
		_hObjDesc = OleGetObjectDescriptorDataFromOleObject(
			pOleObj,
			dwAspect,
			ptl,
			(SIZEL *)&size
		);
	}
	return _hObjDesc;
}

/*
 *	CDataTransferObj::GetDataHere (pformatetc, pmedium)
 *
 *	@mfunc
 *		retrieves data of the specified format into the given medium
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL
 *
 *	@devnote (alexgo): technically, we're supposed to support transfers
 *		into hglobals, but I'd rather not at the moment.
 */
STDMETHODIMP CDataTransferObj::GetDataHere(
	FORMATETC *pformatetc, 
	STGMEDIUM *pmedium)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataHere");

	CLIPFORMAT	cf = pformatetc->cfFormat;
	HRESULT		hr = DV_E_FORMATETC;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;
	
	if( (cf == cf_EMBEDDEDOBJECT ||
		 cf == cf_EMBEDSOURCE) &&
		(pformatetc->tymed & TYMED_ISTORAGE))
	{
		// For some reason the NT4.0 and Win95 Shell
		//          ask for the EMBEDSOURCE format.
        _pObjStg = GetDataForEmbeddedObject( _pOleObj, pmedium->pstg );
		pmedium->tymed = TYMED_ISTORAGE;
		if (NULL == pmedium->pstg)
			pmedium->pstg = _pObjStg;
		hr = pmedium->pstg != NULL ? NOERROR : hr;
		return hr;
	}
	
	if( cf == cf_OBJECTDESCRIPTOR &&
			 (pformatetc->tymed & TYMED_HGLOBAL) &&
			 _hObjDesc)
	{
		pmedium->hGlobal = DuplicateHGlobal(_hObjDesc);
		pmedium->tymed = TYMED_HGLOBAL;
		return NOERROR;
	}

	// First propogate the message to the object and see if it handles the format
	if (_pOleObj)
	{
        // Include the formats supported by the object
        IDataObject * pdataobj = NULL;
        if (FAILED(_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
            _pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);
            
        if (pdataobj)
        {
            hr = pdataobj->GetData(pformatetc, pmedium);
            pdataobj->Release();
            if (hr == S_OK)
            {
                if ((cf == cf_EMBEDDEDOBJECT || cf == cf_EMBEDSOURCE) && _pOleObj)
                {
                    OleSaveSiteFlags(pmedium->pstg, _dwFlags, _dwUser, _dvaspect);
                }
                return S_OK;
            }            
        }        
	}
	return E_NOTIMPL;
}

/*
 *	CDataTransferObj::QueryGetData (pformatetc)
 *
 *	@mfunc
 *		Queries whether the given format is available in this data object
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::QueryGetData(
	FORMATETC *pformatetc )		// @parm FETC to look for
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::QueryGetData");

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	DWORD	cFETC = _cTotal;

	while (cFETC--)				// Maybe faster to search from start
	{
		if( pformatetc->cfFormat == _prgFormats[cFETC].cfFormat && 
			(pformatetc->tymed & _prgFormats[cFETC].tymed) )
		{
			return NOERROR;
		}
	}

	return DV_E_FORMATETC;
}

/*
 *	CDataTransferObj::SetData (pformatetc, pmedium, fRelease)
 *
 *	@mfunc
 *		allows data to be set into this data object
 *
 *	@rdesc
 *		HRESULT = E_FAIL
 *
 *	@devnote
 *		as we are a data transfer object with a "snapshot" of data,
 *		we do not allow it to be replaced
 */
STDMETHODIMP CDataTransferObj::SetData(
	FORMATETC *pformatetc,
	STGMEDIUM *pmedium,
	BOOL fRelease)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::SetData");

	return E_FAIL;
}


/*
 *	CDataTransferObj::OnPreReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *										 cpFormatMax, pNotifyData)
 *
 *	@mfunc	implementation of ITxNotify::OnPreReplaceRange
 *			called before changes are made to the backing store
 */
void CDataTransferObj::OnPreReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::OnPreReplaceRange");

	if(CONVERT_TO_PLAIN != cp && CP_INFINITE != cp)
	{
		Assert(cpFormatMin <= cp && cpFormatMax >= cp + cchDel);
		if(cpFormatMin >= _cpMin + _cch)
			return;							// Change beyond our extent

		if(cpFormatMax <= _cpMin)
		{
			_cpMin += (cchNew - cchDel);	// Change before our extent
			return;
		}
	}

	// FUTURE (murrays): save only one master format (UTF8 RTF or better
	// CTxtStory) and generate individual ones in GetData and GetDataHere.
	_hPlainText = TextToHglobal(_hPlainText, tPlain);
	_hRtfText	= TextToHglobal(_hRtfText,	 tRtf);
	if(_ped->IsDocMoreThanLatin1Symbol())
		_hRtfUtf8 = TextToHglobal(_hRtfUtf8, tRtfUtf8);
}

/*
 *	CDataTransferObj::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin,
 *										 cpFormatMax, pNotifyData)
 *	@mfunc	implementation of ITxNotify::OnPostReplaceRange
 *			called after changes are made to the backing store
 *
 *	@comm	we use this method to keep our cp's up-to-date
 */
void CDataTransferObj::OnPostReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::OnPostReplaceRange");

	// Nothing to do
	return;
}

/*
 *	CDataTransferObj::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDataTransferObj::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CDataTransferObj::Zombie");

	_ped = NULL;
}

/*
 *	CDataTransferObj::Create(ped, prg, lStreamFormat)
 *
 *	@mfunc
 *		static function to create CDataTransferObj. Used to force users
 *		not to create this object on the stack, which would break OLE's
 *		liveness rules.
 *
 *	@rdesc
 *		new CDataTransferObj *
 */
CDataTransferObj *CDataTransferObj::Create(
	CTxtEdit *ped,			// @parm ped to which this DataObject belongs
	CTxtRange *prg,			// @parm range for the data object
	LONG lStreamFormat)		// @parm stream format to use in Rtf conversion
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::Create");

	Assert(CFETC == ARRAY_SIZE(g_rgFETC) && CFETC == ARRAY_SIZE(g_rgDOI));

	LONG			ch;
	CNotifyMgr *	pnm;
	CDataTransferObj *pdo = new CDataTransferObj(ped);

	if( !pdo )
	{
		ped->GetCallMgr()->SetOutOfMemory();
		return NULL;
	}

	LONG cpMin, cpMost;
	pdo->_cch = prg->GetRange(cpMin, cpMost);
	pdo->_cpMin = cpMin;

	pdo->_lStreamFormat = lStreamFormat;

	pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add( (ITxNotify *) pdo );

	//Set the object count.
	pdo->_cObjs = 0;
	if( ped->HasObjects() )
		pdo->_cObjs = ped->_pobjmgr->CountObjectsInRange(cpMin, cpMost);

	int cTotal = !ped->IsRich() ? 2 :
				 ped->IsDocMoreThanLatin1Symbol() ? 7 : 5;

   	int cExtraFmtEtc = 0;
	COleObject *pobj = NULL;
	FORMATETC rgfetc[255];
	BOOL bValidOleObj = FALSE;

	// We only support 2 formats in the play text case
    if ( !ped->IsRich() )
    {        
        pdo->_cTotal = cTotal;
        pdo->_prgFormats = new FORMATETC[cTotal];
        if (!pdo->_prgFormats)
            goto ErrorExit;
            
		// Plain-text case
		pdo->_prgFormats[0] = g_rgFETC[iAnsiFETC];
		pdo->_prgFormats[1] = g_rgFETC[iUnicodeFETC];
		return pdo;
	}

    // We need to count the number of supported formats
	if (ped->HasObjects() && pdo->_cch == 1 && prg->GetChar(&ch) == NOERROR && ch == WCH_EMBEDDING)
	{
	    pobj = ped->_pobjmgr->GetObjectFromCp(pdo->_cpMin);
	    pdo->_dwFlags = pobj->GetFlags();
        pdo->_dwUser = pobj->GetUser();
        pdo->_dvaspect =pobj->GetAspect();
	    IUnknown * punk = pobj->GetIUnknown();

	    //  We want to query IOleObject on which formats it supports.  And add that to the
	    // FORMATETC array.
	    if (punk &&	punk->QueryInterface(IID_IOleObject,(void **) &pdo->_pOleObj) == NOERROR)
	   	{
	   	    bValidOleObj = TRUE;
	   	    
	        // Include the formats supported by the object
			IDataObject * pdataobj = NULL;
	        if (FAILED(pdo->_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
                pdo->_pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);

            if (pdataobj)
            {
	            IEnumFORMATETC *pifetc = NULL;

	            // 1.0 didn't check the return value of EnumFormatEtc.  This is important because ccMail 
	            // will return an OLE error although it actually succeeds in setting the formatetc
	            if ((SUCCEEDED(pdataobj->EnumFormatEtc( DATADIR_GET, &pifetc)) || ped->Get10Mode()) && pifetc)
	            {
	                AssertSz(pifetc, "IEnumFormatEtc is NULL");
	                
	                // Copy the formats which are supported by the object
	                while((pifetc->Next(1, &rgfetc[cExtraFmtEtc], NULL)) == S_OK && cExtraFmtEtc < 255)
	                    cExtraFmtEtc++;	                
	                pifetc->Release();
	            }
	            pdataobj->Release();
            }
	    }
	}

    pdo->_cTotal = cTotal + cExtraFmtEtc;
	pdo->_prgFormats = new FORMATETC[pdo->_cTotal];
	if (!pdo->_prgFormats) 
	    goto ErrorExit;

    if (pobj)
    {
    	// copy over formats supported by the object itself
    	if (cExtraFmtEtc)
    	    memcpy(pdo->_prgFormats, rgfetc, cExtraFmtEtc * sizeof(FORMATETC));

        // copy formats supported by Richedit as a container
    	// Have an OLE object: offer all OLE formats plus RTF
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iEmbObj];	// EmbeddedObject
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iObtDesc];	// ObjectDescriptor
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iMfPict];	// Metafile
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfFETC];	// RTF 
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfNoObjs];	// RTF with no objects
	}
	else
	{
        // Regular rich-text case
    	pdo->_prgFormats[0] = g_rgFETC[iRtfFETC];		// RTF
    	pdo->_prgFormats[1] = g_rgFETC[iRtfNoObjs];		// RTF with no objects
    	pdo->_prgFormats[2] = g_rgFETC[iRtfAsTextFETC];	// RTF as Text
    	pdo->_prgFormats[3] = g_rgFETC[iAnsiFETC];		// ANSI plain text
    	pdo->_prgFormats[4] = g_rgFETC[iUnicodeFETC];	// Unicode plain text
    	cExtraFmtEtc = 5;
	}


	// We only offer up the six formats that we know how to handle in GetData.
	// The actual values differ somewhat from regular rich text and text
	// with embedded objects
    if (cTotal == 7)
    {
        pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfUtf8];	// RTF in UTF-8
        pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfNCRforNonASCII];
    }

    // Get the embedded object formats now
    if (bValidOleObj)
    {
        SIZEUV size;
        pobj->GetSize(size);        
        pdo->_hObjDesc = pdo->GetDataForObjectDescriptor( pdo->_pOleObj, pobj->GetDvaspect(), &size);
		pdo->_pObjStg = pdo->GetDataForEmbeddedObject( pdo->_pOleObj, NULL );
		pdo->_hMFPict = (HMETAFILE) OleStdGetMetafilePictFromOleObject(	pdo->_pOleObj, 
		                                pobj->GetDvaspect(), NULL, NULL);
    }

    return pdo;

ErrorExit:	
    
	pdo->_cTotal = 0;
	pdo->Release();
	ped->GetCallMgr()->SetOutOfMemory();
	return NULL;
}

/*
 *	CDataTransferObj::TextToHglobal(hText, tKind)
 *
 *	@mfunc
 *		Instantiates text on demand for the data object.
 *
 *	@rdesc
 *		HGLOBAL
 */
HGLOBAL CDataTransferObj::TextToHglobal(
	HGLOBAL &hText,
	TEXTKIND tKind)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::PlainTextToHglobal");

	if (hText == NULL)
	{
		CTxtRange rg(_ped, _cpMin, -_cch);
		if (tKind == tPlain)
		{
			hText = _ped->GetDTE()->UnicodePlainTextFromRange(&rg);
		}
		else if(_ped->IsRich())
		{
			LONG lStreamFormat = _lStreamFormat;
			if(tKind == tRtfUtf8)
				lStreamFormat = LOWORD(lStreamFormat) | SF_USECODEPAGE | (CP_UTF8 << 16);

			else if(tKind == tRtfNCRforNonASCII)
				lStreamFormat |= SF_NCRFORNONASCII;

			hText = _ped->GetDTE()->RtfFromRange(&rg, lStreamFormat);
		}
	}
	return hText;	
}

//
//	CDataTransferObj PRIVATE methods
//

/*
 *	CDataTransferObj::CDataTransferObj()
 *
 *	@mfunc
 *		Private constructor
 */

CDataTransferObj::CDataTransferObj( CTxtEdit *ped )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::CDataTransferObj");

	_ped = ped;
	_crefs = 1;
	_cTotal = CFETC;
	_prgFormats = g_rgFETC;
	_cch = 0;
	_cObjs = 0;
}

/*
 *	CDataTransferObj::~CDataTransferObj
 *
 *	@mfunc
 *		Private destructor
 */
CDataTransferObj::~CDataTransferObj()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::~CDataTransferObj");

	// No need to monitor notifications any more
	CNotifyMgr *pnm;

	if(_ped)
	{
		pnm = _ped->GetNotifyMgr();
		if(pnm)
			pnm->Remove( (ITxNotify *)this );
	}

	if( _prgFormats && _prgFormats != g_rgFETC)
		delete _prgFormats;

	if (_pOleObj)
		_pOleObj->Release();

	if (_pObjStg)
		_pObjStg->Release();

#ifndef NOMETAFILES
	if (_hMFPict)
		(void) DeleteMetaFile(_hMFPict);
#endif

	GlobalFree(_hObjDesc);
}		

//
//	CEnumFormatEtc PUBLIC methods
//

/*
 *	CEnumFormatEtc::QueryInterface (riid, ppvObj)
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface(
	REFIID riid,			// @parm Reference to requested interface ID
	void ** ppv)			// @parm out parm for interface ptr
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::QueryInterface");

    HRESULT		hresult = E_NOINTERFACE;

	*ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumFORMATETC) )
    {
        *ppv = this;
        AddRef();
        hresult = NOERROR;
    }
    return hresult;
}

/*
 *	CEnumFormatEtc::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef( )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::AddRef");

 	return ++_crefs;
}

/*
 *	CEnumFormatEtc::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release( )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CEnumFormatEtc::Next (celt, rgelt, pceltFetched)
 *
 *	@mfunc
 *		fetches the next [celt] elements in our formatetc collection
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Next( ULONG celt, FORMATETC *rgelt,
        ULONG *pceltFetched)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Next");

    HRESULT		hresult = NOERROR;
    ULONG		cFetched;

	if( pceltFetched == NULL && celt != 1 )
    {
        // the spec says that if pceltFetched == NULL, then
        // the count of elements to fetch must be 1
        return E_INVALIDARG;
    }

    // we can only grab as many elements as there are left

    if( celt > _cTotal - _iCurrent )
    {
        cFetched = _cTotal - _iCurrent;
        hresult = S_FALSE;
    }
    else
        cFetched = celt;

    // Only copy if we have elements to copy

    if( cFetched > 0 )
    {
        memcpy( rgelt, _prgFormats + _iCurrent,
            cFetched * sizeof(FORMATETC) );
    }

    _iCurrent += cFetched;

    if( pceltFetched )
        *pceltFetched = cFetched;

    return hresult;
}

/*
 *	CEnumFormatEtc::Skip
 *
 *	@mfunc
 *		skips the next [celt] formats
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Skip( ULONG celt )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Skip");

    HRESULT		hresult = NOERROR;

    _iCurrent += celt;

    if( _iCurrent > _cTotal )
    {
        // whoops, skipped too far ahead.  Set us to the max limit.
        _iCurrent = _cTotal;
        hresult = S_FALSE;
    }

    return hresult;
}

/*
 *	CEnumFormatEtc::Reset
 *
 *	@mfunc
 *		resets the seek pointer to zero
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Reset( void )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Reset");

    _iCurrent = 0;

    return NOERROR;
}

/*
 *	CEnumFormatEtc::Clone
 *
 *	@mfunc
 *		clones the enumerator
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Clone( IEnumFORMATETC **ppIEnum )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Clone");
	
    return CEnumFormatEtc::Create(_prgFormats, _cTotal, ppIEnum);
}

/*
 *	CEnumFormatEtc::Create (prgFormats, cTotal, hr)
 *
 *	@mfunc
 *		creates a new format enumerator
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		*copies* the formats passed in.  We do this as it simplifies
 *		memory management under OLE object liveness rules
 */

HRESULT CEnumFormatEtc::Create( FORMATETC *prgFormats, ULONG cTotal, 
	IEnumFORMATETC **ppenum )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Create");

	CEnumFormatEtc *penum = new CEnumFormatEtc();

	if(penum)
	{
  		// _iCurrent, _crefs are set in the constructor

		if( cTotal > 0 )
		{
			penum->_prgFormats = new FORMATETC[cTotal];
			if( penum->_prgFormats )
			{
				penum->_cTotal = cTotal;
				memcpy(penum->_prgFormats, prgFormats, 
						cTotal * sizeof(FORMATETC));
				*ppenum = penum;
				return NOERROR;
			}	
		}

		delete penum;
	}
	return E_OUTOFMEMORY;
}

//
// CEnumFormatEtc PRIVATE methods
//

/*
 *	CEnumFormatEtc::CEnumFormatEtc()
 *
 *	@mfunc
 *		Private constructor
 */

CEnumFormatEtc::CEnumFormatEtc()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::CEnumFormatEtc");

	_cTotal = 0;
	_crefs	= 1;
	_prgFormats = NULL;
	_iCurrent = 0;
}

/*
 *	CEnumFormatEtc::~CEnumFormatEtc()
 *
 *	@mfunc
 *		Private destructor
 */

CEnumFormatEtc::~CEnumFormatEtc( void )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::~CEnumFormatEtc");

    if( _prgFormats )
        delete _prgFormats;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\dragdrp.cpp ===
/*
 *	DRAGDRP.C
 *
 *	Purpose:
 *		Implementation of Richedit's OLE drag drop objects (namely,
 *		the drop target and drop source objects)
 *
 *	Author:
 *		alexgo (4/24/95)
 *		KeithCu (12/11/99) Simplified by going to an XOR model for the caret
 *		(just like the regular caret) and made work with various textflows.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dragdrp.h"
#include "_disp.h"
#include "_select.h"
#include "_font.h"
#include "_measure.h"


ASSERTDATA

//
//	CDropSource PUBLIC methods
//

/*
 *	CDropSource::QueryInterface (riid, ppv)
 */

STDMETHODIMP CDropSource::QueryInterface(
	REFIID riid,
	void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
		*ppv = (IUnknown *)this;

	else if( IsEqualIID(riid, IID_IDropSource) )
		*ppv = (IDropSource *)this;

	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return NOERROR;
}

/*
 *	CDropSource::AddRef
 */
STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::AddRef");

	return ++_crefs;
}

/*
 *	CDropSource::Release
 *
 *	@devnote.  Do not even think about making an outgoing call here.
 *			   If you do, be sure make sure all callers use a 
 *			   SafeReleaseAndNULL (null the pointer before releasing)
 *			   technique to avoid re-entrancy problems.
 */
STDMETHODIMP_(ULONG) CDropSource::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDropSource::QueryContinueDrag (fEscapePressed, grfKeyState)
 *
 *	@mfunc
 *		determines whether or not to continue a drag drop operation
 *
 *	Algorithm:
 *		if the escape key has been pressed, cancel 
 *		if the left mouse button has been release, then attempt to 
 *			do a drop
 */
STDMETHODIMP CDropSource::QueryContinueDrag(
	BOOL fEscapePressed, 
	DWORD grfKeyState)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::QueryContinueDrag");

    if(fEscapePressed)
        return DRAGDROP_S_CANCEL;

    if(!(grfKeyState & (MK_LBUTTON | MK_RBUTTON)))
        return DRAGDROP_S_DROP;

	return NOERROR;
}

/*
 *	CDropSource::GiveFeedback (dwEffect)
 *
 *	@mfunc
 *		gives feedback during a drag drop operation
 *
 *	Notes:
 *		FUTURE (alexgo): maybe put in some neater feedback effects
 *		than the standard OLE stuff??
 */
STDMETHODIMP CDropSource::GiveFeedback(
	DWORD dwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::GiveFeedback");

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

/*
 *	CDropSource::CDropSource
 */
CDropSource::CDropSource()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::CDropSource");

	_crefs = 1;
}

//
//	CDropSource PRIVATE methods
//

/*
 *	CDropSource::~CDropSource
 */
CDropSource::~CDropSource()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::~CDropSource");

	;
}


//
//	CDropTarget PUBLIC methods
//

/*
 *	CDropTarget::QueryInterface (riid, ppv)
 */
STDMETHODIMP CDropTarget::QueryInterface (
	REFIID riid,
	void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
		*ppv = (IUnknown *)this;

	else if( IsEqualIID(riid, IID_IDropTarget) )
		*ppv = (IDropTarget *)this;

	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return NOERROR;
}

/*
 *	CDropTarget::AddRef
 */
STDMETHODIMP_(ULONG) CDropTarget::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::AddRef");

	return ++_crefs;
}

/*
 *	CDropTarget::Release()
 */
STDMETHODIMP_(ULONG) CDropTarget::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDropTarget::DragEnter (pdo, grfKeyState, pt, pdwEffect)
 *
 *	@mfunc 
 *		Called when OLE drag drop enters our "window"
 *
 *	@devnote
 *		First we check to see if the data object being transferred contains
 *		any data that we support.  Then we verify that the 'type' of drag
 *		is acceptable (i.e., currently, we do not accept links).
 *
 *	FUTURE: (alexgo): we may want to accept links as well.
 */
STDMETHODIMP CDropTarget::DragEnter(
	IDataObject *pdo, 
	DWORD		grfKeyState,
	POINTL		pt, 
	DWORD *		pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragEnter");

	// We don't have a position yet.
	_cpCur = -1;

	HRESULT hr = NOERROR;
	DWORD result;
	CTxtSelection *psel;

	// At drag enter time, we should have no cached info about what the data
	// object supports.  This flag should be cleared in DragLeave.  Note
	// that we slightly override _dwFlags, as it's possible for a data object
	// given during drag drop to also generate DOI_NONE.

	if( !_ped )
		return CO_E_RELEASED;
	 
	Assert(_pcallmgr == NULL);
	Assert(_dwFlags == 0);

	_pcallmgr = new CCallMgr(_ped);

	if( !_pcallmgr )
		return E_OUTOFMEMORY;

	// Find out if we can paste the object
	result = _ped->GetDTE()->CanPaste(pdo, 0, RECO_DROP);

	if( result )
	{
		if( result == DF_CLIENTCONTROL )
			_dwFlags |= DF_CLIENTCONTROL;

		// Create the object that implements the drag caret
		_pdrgcrt = new CDropCaret(_ped);

		if ((NULL == _pdrgcrt) || !_pdrgcrt->Init())
		{
			// Initialization failed so go without a caret
			delete _pdrgcrt;
			_pdrgcrt = NULL;
		}
				
		// cache the current selection so we can restore it on return
		psel = _ped->GetSel();
		Assert(psel);

		_cpSel	= psel->GetCp();
		_cchSel	= psel->GetCch();
		_dwFlags |= DF_CANDROP;

		// just call DragOver to handle our visual feedback
		hr = DragOver(grfKeyState, pt, pdwEffect);
	}
	else if (_ped->fInOurHost())
	{
		// Just tell the caller that we can't drop.
		*pdwEffect = DROPEFFECT_NONE;
	}
	else
	{
		// this is new behaviour for Win95 OLE; if we don't 
		// understand anything about the data object given to us,
		// we return S_FALSE to allow our parent to give the
		// drag drop a try.

		// In theory, only forms^3 uses this information and
		// this return exposes an error in NT OLE, therefore,
		// we only do this now when not in our own host.
		
		hr = S_FALSE;
	}

	if( hr != NOERROR )
	{
		delete _pcallmgr;
		_pcallmgr = NULL;
		_dwFlags = 0;
	}

	return hr;
}

/*
 *	CDropTarget::DragOver (grfKeyState, pt, pdwEffect)
 *
 *	@mfunc
 *		Handles the visual feedback for a drag drop operation zooming
 *		around over text
 *
 *	FUTURE (alexgo): maybe we should do some snazzy visuals here
 */
STDMETHODIMP CDropTarget::DragOver(
	DWORD	grfKeyState, 
	POINTL	pt, 
	DWORD *	pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragOver");

	LONG	cpCur = _cpCur;

	if( !_ped )
		return CO_E_RELEASED;
	Assert(_pcallmgr);

	// note if we're doing right mouse drag drop; note that we 
	// can't do this in UpdateEffect as it's called from Drop
	// as well (and the mouse button is up then!)
	_dwFlags &= ~DF_RIGHTMOUSEDRAG;
	if(grfKeyState & MK_RBUTTON)
		_dwFlags |= DF_RIGHTMOUSEDRAG;

	UpdateEffect(grfKeyState, pt, pdwEffect);

	// only draw if we've changed position	
	if( *pdwEffect != DROPEFFECT_NONE  &&
		(cpCur != _cpCur || _pdrgcrt && _pdrgcrt->NoCaret()))
	{
		DrawFeedback();
	}	
	return NOERROR;
}

/*
 *	CDropTarget::DragLeave
 *
 *	@mfunc
 *		Called when the mouse leaves our window during drag drop.  Here we clean
 *		up any temporary state setup for the drag operation.
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDropTarget::DragLeave()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragLeave");

	CTxtSelection *psel = _ped->GetSel();

	if( !_ped )
		return CO_E_RELEASED;

	Assert(_pcallmgr);

	_dwFlags = 0;

	// now restore the selection

	psel->SetSelection(_cpSel - _cchSel, _cpSel);
	psel->Update(FALSE);

	_cpSel = _cchSel = 0;

	delete _pcallmgr;
	_pcallmgr = NULL;

	delete _pdrgcrt;
	_pdrgcrt = NULL;

	return NOERROR;
}

/*
 *	CDropTarget::Drop (pdo, grfKeyState, pt, pdwEffect)
 *
 *	@mfunc
 *		Called when the mouse button is released.  We should attempt
 *		to 'paste' the data object into a selection corresponding to
 *		the mouse location
 *
 *	@devnote
 *		First we make sure that we can still do a paste (via UpdateEffect).
 *		If so, then set the selection to the current point and then insert
 *		the text.
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDropTarget::Drop(
	IDataObject *pdo,
	DWORD		 grfKeyState, 
	POINTL		 ptl,
	DWORD *		 pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Drop");

	HRESULT	hr = NOERROR;

	if( !_ped )
		return CO_E_RELEASED;

	Assert(_pcallmgr);
	CDropCleanup cleanup(this);

	// see if we can still drop
	UpdateEffect(grfKeyState, ptl, pdwEffect);

	// UpdateEffect will show a drop cursor but at this point we don't need one
	// so we hide the drop cursor here.
	if (_pdrgcrt)
		_pdrgcrt->ShowCaret(FALSE);

	if (_dwFlags & DF_OVERSOURCE)
	{
		*pdwEffect = DROPEFFECT_NONE;
		_dwFlags = 0;
		return NOERROR;
	}
	
	if(*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK))
	{
		IUndoBuilder *	publdr;
		CGenUndoBuilder undobldr( _ped, UB_AUTOCOMMIT, &publdr);
		// If this is a right mouse drag drop; handle that
		if(_dwFlags & DF_RIGHTMOUSEDRAG)
		{
			hr = HandleRightMouseDrop(pdo, ptl);

			// If S_FALSE is returned, treat drag drop normally
			if( hr != S_FALSE )
				goto Exit;
		}

		// Get an undo builder.  If we already have one cached, that means
		// we are dropping onto the same edit instance that started the drag
		// In this case, we want to use the cached undo builder so that 
		// a drag move can be undone as one "operation".

		if(_publdr)
			publdr = _publdr;

		CTxtSelection *psel = _ped->GetSel();
		psel->SetSelection(_cpCur, _cpCur);
		
		if( !_ped->IsProtectedRange(WM_PASTE, 0, 0, psel) )
		{
			hr = _ped->PasteDataObjectToRange(pdo, (CTxtRange *)psel, 
					0, NULL, publdr, PDOR_DROP);
		}

		// If we are dropping onto ourselves, the UI specifies
		// that we should select the entire range dragged.  We use
		// _publdr as an easy way to tell if the drop originated from
		// this instance

		if(SUCCEEDED(hr) && _pdrgcrt)
		{
			// If the drop worked, then we don't want to restore the area
			// where the drop caret used to be since this is not out of date.
			_pdrgcrt->CancelRestoreCaretArea();
		}		

		// Now set the selection anti-events. If the selection preceded the
		// paste poiont subtract its length from the redo position, since
		// the selection will get deleted if we are doing a DRAGMOVE within
		// this instance.
		LONG cpNext  = psel->GetCp();
		LONG cchNext = cpNext - _cpCur;
		if(_cpSel < _cpCur && _publdr && (*pdwEffect & DROPEFFECT_MOVE))
			cpNext -= abs(_cchSel);

		HandleSelectionAEInfo(_ped, publdr, _cpCur, 0, cpNext, cchNext,
							  SELAE_FORCEREPLACE);
		if(_publdr)
		{
			// If we are doing a drag move, then *don't* set the
			// selection directly on the screen--doing so will result in
			// unsightly UI--we'll set the selection to one spot, draw it
			// and then immediately move the selection somewhere else.

			// In this case, just change where the selection range exists.
			// Floating ranges and the drag-move code in ldte.c will take
			// care of the rest.

			if( *pdwEffect == DROPEFFECT_COPY )
				psel->SetSelection(_cpCur, psel->GetCp());
			else
				psel->Set(psel->GetCp(), cchNext);
		}
		else if(publdr)
		{
			// The drop call landed in us from outside, so we need
			// to fire the appropriate notifications.  First, however,
			// commit the undo builder.

			publdr->SetNameID(UID_DRAGDROP);
			publdr->Done();

			if(SUCCEEDED(hr))
			{
				// Make this window the foreground window after the drop. Note
				// that the host needs to support ITextHost2 to really get to
				// be the foreground window. If they don't this is a no-op.
				_ped->TxSetForegroundWindow();
			}
		}

		// If nothing changed on the drop && the effect is a move, then return
		// failure. This is an ugly hack to improve drag-move scenarios; if
		// nothing happened on the drop, then chances are, you don't want
		// to have the correspong "Cut" happen on the drag source side.
		//
		// Of course, this relies on the drag source responding gracefully to
		// E_FAIL w/o hitting too much trauma.
		if (*pdwEffect == DROPEFFECT_MOVE && 
			!_ped->GetCallMgr()->GetChangeEvent() )
		{
			hr = E_FAIL;
		}
	}

Exit:
	_dwFlags = 0;
	return hr;
}

/*
 *	CDropTarget::CDropTarget (ped)
 */
CDropTarget::CDropTarget(
	CTxtEdit *ped)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::CDropTarget");

	_ped 		= ped;
	_crefs 		= 1;
	_dwFlags 	= 0;
	_publdr 	= NULL;
	_cpMin		= -1;
	_cpMost		= -1;
	_pcallmgr	= NULL;
}

/*
 *	CDropTarget::SetDragInfo (publdr, cpMin, cpMost)
 *
 *	@mfunc
 *		Allows the data transfer engine to cache important information
 *		about a drag drop with this drop target.
 *
 *	@devnote
 *		Intra-instance drag drop operations can be treated as a single user
 *		action.  With cpMin and cpMost, we can disable dragging into the
 *		range that is being dragged. This method must be called again in
 *		order to clear the cached info. -1 for cpMin and cpMost will "clear"
 *		those values (as 0 is a valid cp)
 */
void CDropTarget::SetDragInfo(
	IUndoBuilder *publdr,	//@parm Undo builder to use
	LONG cpMin,				//@parm Minimim character position of range that being dragged
	LONG cpMost )			//@parm Maximum character position of range
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::SetDragInfo");

	_publdr = publdr;
	_cpMin 	= cpMin;
	_cpMost	= cpMost;
}

/*
 *	CDropTarget::Zombie
 *
 *	@mfunc	This method clears the state in this drop target object.  It is
 *			used to recover 'gracefully' from reference counting errors
 */
void CDropTarget::Zombie()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Zombie");

	_ped = NULL;
	if( _pcallmgr )
	{
		delete _pcallmgr;
		_pcallmgr = NULL;
	}
}

//
//	CDropTarget PRIVATE methods
//

/*
 *	CDropTarget::~CDropTarget
 */
CDropTarget::~CDropTarget()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::~CDropTarget");

	;
}

/*
 *	CDropTarget::ConvertScreenPtToClientPt (pptScreen, pptClient)
 *
 *	@mfunc
 *		OLE drag drop sends points in using screen coordinates.  However,
 *		all of our display code internally relies on client coordinates
 *		(i.e. the coordinates relative to the window that we are being
 *		drawn in).  This routine will convert between the two
 *
 *	@devnote
 *		The client coordinates use a POINT structure instead of POINTL.
 *		while nominally they are the same, OLE uses POINTL and the display
 *		engine uses POINT. 
 */
void CDropTarget::ConvertScreenPtToClientPt(
	POINTL *pptScreen, 
	POINT *pptClient )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::ConvertScreenPtToClientPt");

	POINT ptS;

	pptClient->x = ptS.x = pptScreen->x;
	pptClient->y = ptS.y = pptScreen->y;

	_ped->TxScreenToClient(pptClient);
}

/*
 *	CDropTarget::UpdateEffect (grfKeyState, ptl, pdwEffect)
 *
 *	@mfunc
 *		Given the keyboard state and point, and knowledge of what
 *		the data object being transferred can offer, calculate
 *		the correct drag drop feedback.
 *
 *	@devnote
 *		This function should only be called during a drag drop 
 *		operation; doing otherwise will simply result in a return
 *		of DROPEFFECT_NONE.
 */

void CDropTarget::UpdateEffect(
	DWORD	grfKeyState, 
	POINTL	ptl, 
	DWORD *	pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::UpdateEffect");

	BOOL fHot = FALSE;
	HRESULT hr;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();

	if (_ped->fInplaceActive())
	{
		POINTUV pt;
		POINT ptClient;
		WORD nScrollInset;

		// first, find out where we are
		ConvertScreenPtToClientPt(&ptl, &ptClient);

		_ped->_pdp->PointuvFromPoint(pt, ptClient);

		_cpCur = _ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE);

		// if we are on top of the range that is being
		// dragged, then remeber it for later
		_dwFlags &= ~DF_OVERSOURCE;
		if( _cpCur > _cpMin && _cpCur < _cpMost )
			_dwFlags |= DF_OVERSOURCE;

		// Scroll if we need to and remember if we are in the hot zone.
		nScrollInset = W32->GetScrollInset();

		if (_pdrgcrt != NULL)
			_pdrgcrt->ShowCaret(FALSE);

		fHot = _ped->_pdp->AutoScroll(pt, nScrollInset, nScrollInset);

		if (_pdrgcrt != NULL)
		{
			if(!(_dwFlags & DF_OVERSOURCE) && !fHot)
				_pdrgcrt->ShowCaret(TRUE);

			else
			{
				// The hide above restored the caret so we just
				// need to turn off the caret while we are over the
				// source.
				_pdrgcrt->CancelRestoreCaretArea();
			}
		}
	}
	// Let the client set the effect if it wants, but first, we need
	// to check for protection.

	if( _ped->IsRich() )
	{
		// We don't allow dropping onto protected text.  Note that
		// the _edges_ of a protected range may be dragged to; therefore,
		// we need to check for protection at _cpCur and _cpCur-1.
		// If both cp's are protected, then we are inside a protected
		// range.
		CTxtRange rg(_ped, _cpCur, 0);
		PROTECT iProt = rg.IsProtected(CHKPROT_EITHER);

		if (iProt == PROTECTED_YES ||
			iProt == PROTECTED_ASK &&
			 (!_ped->IsProtectionCheckingEnabled() || 
			 _ped->QueryUseProtection(&rg, WM_MOUSEMOVE,0, 0)))
		{ 
			*pdwEffect = DROPEFFECT_NONE;
			goto Exit;
		}
	}

	if( precall )
	{
		hr = precall->GetDragDropEffect(FALSE, grfKeyState, pdwEffect);
		// Note : RichEdit 1.0 does not check the return code of this call.
		// If callback specified a single effect, use it.
		// Otherwise pick one ourselves.

		// trick: (x & (x-1)) is non-zero if more than one bit is set.
		if (!(*pdwEffect & (*pdwEffect - 1) ))
			goto Exit;
	}
	
	// If we don't know anything about the data object or the control
	// is read-only, set the effect to none.
	// If the client is handling this, we don't worry about read-only.
	if (!(_dwFlags & DF_CLIENTCONTROL) &&
		(!(_dwFlags & DF_CANDROP) || _ped->TxGetReadOnly()))
	{
		*pdwEffect = DROPEFFECT_NONE;
		_cpCur = -1;
		// no need to do anything else
		return;
	}

	// if we are on top of the range that is being
	// dragged, then we can't drop there!
	if( _dwFlags & DF_OVERSOURCE )
	{
		*pdwEffect = DROPEFFECT_NONE;
		goto Exit;
	}

	// now check the keyboard state and the requested drop effects.
	if(_dwFlags & DF_CANDROP)
	{
		// if we can paste plain text, then see if a MOVE or COPY
		// operation was requested and set the right effect.  Note
		// that we prefer MOVEs over COPY's in accordance with OLE
		// UI guidelines.

		// we do not yet support linking
		if( (grfKeyState & MK_CONTROL) && (grfKeyState & MK_SHIFT) )
		{
			//COMPATIBILITY: Richedit 1.0 did not appear to support drag
			//linking correctly.
			*pdwEffect = DROPEFFECT_NONE;
		}
		else if( !(grfKeyState & MK_CONTROL) && 
			(*pdwEffect & DROPEFFECT_MOVE) )
		{
			// if the control key is *not* depressed, then assume a "move"
			// operation (note that shift and alt or no keys will also give
			// a move) iff the source supports move.

			*pdwEffect = DROPEFFECT_MOVE;
		}
		else if( (grfKeyState & MK_CONTROL) && !((grfKeyState & MK_ALT) &&
			(grfKeyState & MK_SHIFT)) && (*pdwEffect & DROPEFFECT_COPY) )
		{
			// if only the control key is down and we're allowed to do a copy,
			// then do a copy
			*pdwEffect = DROPEFFECT_COPY;
		}
		else if( !(grfKeyState & MK_CONTROL) && 
			(*pdwEffect & DROPEFFECT_COPY) )
		{
			// if the control key is *not* depressed, and we are *not* allowed
			// to do a move (note that this if comes below the second one), then
			// do a COPY operation (if available)
			*pdwEffect = DROPEFFECT_COPY;
		}
		else
			*pdwEffect = DROPEFFECT_NONE;	// not a combination that we support
	}
	else
		*pdwEffect = DROPEFFECT_NONE;

Exit:	

	//Add the scrolling effect if we are in the hot zone.
	if(fHot)
		*pdwEffect |= DROPEFFECT_SCROLL;
}

/*
 *	CDropTarget::DrawFeedback()
 *
 *	@mfunc
 *		draws any feeback necessary on the target side (specifically, setting the
 *		cursor
 *
 *	Notes:
 *		assumes _cpCur is correctly set.
 */

void CDropTarget::DrawFeedback()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DrawFeedback");

	if (_ped && _ped->fInplaceActive() && _pdrgcrt != NULL)
	{
		// We need to indicate a drop location because a drop is possible
		_pdrgcrt->DrawCaret(_cpCur);
	}
}

/*
 *	CDropTarget::HandleRightMouseDrop(pdo, ptl)
 *
 *	@mfunc	Handles calling back to the client to get a context menu 
 *			for a right-mouse drag drop.
 *
 *	@rdesc	HRESULT
 */
HRESULT CDropTarget::HandleRightMouseDrop(
	IDataObject *pdo,		//@parm Data object to drop
	POINTL ptl)				//@parm Location of the drop (screen coords)
{
	LPRICHEDITOLECALLBACK precall = NULL;
	CHARRANGE cr = {_cpCur, _cpCur};
	HMENU hmenu = NULL;
	HWND hwnd, hwndParent;

	precall = _ped->GetRECallback();

	if( !precall || _ped->Get10Mode() )
		return S_FALSE;

	// HACK ALERT! evil pointer casting going on here.
	precall->GetContextMenu( GCM_RIGHTMOUSEDROP, (IOleObject *)(void *)pdo, &cr, &hmenu);

	if( hmenu && _ped->TxGetWindow(&hwnd) == NOERROR )
	{
		hwndParent = GetParent(hwnd);
		if( !hwndParent )
			hwndParent = hwnd;

		TrackPopupMenu(hmenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
			ptl.x, ptl.y, 0, hwndParent, NULL);

		return NOERROR;
	}
	return S_FALSE;
}

/*
 *	CDropCaret::DrawCaret (ped)
 *
 *	@mfunc
 *		Draws a "caret" to indicate where the drop will occur.
 */

CDropCaret::CDropCaret(
	CTxtEdit *ped)			//@parm Edit control
{
	_ped = ped;
	_dvp = -1;
	_hdcWindow = NULL;
	_fCaretOn = FALSE;
}

/*
 *	CDropCaret::~CDropCaret
 *
 *	@mfunc
 *		Clean up caret object
 */

CDropCaret::~CDropCaret()
{
	if (_ped->_pdp && _hdcWindow != NULL)
	{
		// Restore the any updated window area
		ShowCaret(FALSE);

		// Free the DC we held on to
		_ped->_pdp->ReleaseDC(_hdcWindow);
	}
}

/*
 *	CDropCaret::Init ()
 *
 *	@mfunc
 *		Do initialization that can fail
 */

BOOL CDropCaret::Init()
{
	// Get the DC for the window
	_hdcWindow = _ped->_pdp->GetDC();

	if (NULL == _hdcWindow)
	{
		// Could not get a DC, we are toast.
		AssertSz(FALSE, "CDropCaret::Init could not get hdc"); 
		return FALSE;
	}

	return TRUE;
}

/*
 *	CDropCaret::DrawCaret (cpCur)
 *
 *	@mfunc
 *		Draws a "caret" to indicate where the drop will occur.
 */
void CDropCaret::DrawCaret(
	LONG cpCur)				//@parm current cp of where drop would occur
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropCaret::DrawCaret");

	CLock		lock;					// Uses global (shared) FontCache
	CDisplay *	pdp = _ped->_pdp;
	POINTUV		ptNew;
	RECTUV		rcClient;
	CLinePtr	rp(pdp);
	CRchTxtPtr	rtp(_ped, cpCur);

	//Hide caret if appropriate
	ShowCaret(FALSE);

	// We no longer have a caret to restore
	_dvp = -1;

	// Get new cp from point
	pdp->PointFromTp(rtp, NULL, FALSE, ptNew, &rp, TA_TOP | TA_LOGICAL);

	// Get client rectangle
	_ped->TxGetClientRect(&rcClient);
	
	// Figure out height of new caret
	const CCharFormat *pCF = rtp.GetCF();

	// Get zoomed height
	LONG dvpInch = MulDiv(GetDeviceCaps(_hdcWindow, LOGPIXELSY), pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
	CCcs *pccs = _ped->GetCcs(pCF, dvpInch);

	if (NULL == pccs)
		return;	// We can't do anything sensible so give up.

	// Save new height
	_dvp = pccs->_yHeight;

	LONG vpOffset, vpAdjust;
	pccs->GetOffset(pCF, dvpInch, &vpOffset, &vpAdjust);

	// Save new position
	ptNew.v += (rp->GetHeight() - rp->GetDescent() + pccs->_yDescent - _dvp - vpOffset - vpAdjust);

	// Release cache entry since we are done with it.
	pccs->Release();

	// Save new caret position
	_ptCaret.u = ptNew.u;
	_ptCaret.v = ptNew.v;

	// If new point is in client rectangle, show the caret
	if(PtInRect(&rcClient, ptNew))
		ShowCaret(TRUE);
}

/*
 *	CDropCaret::ShowCaret (fShow)
 *
 *	@mfunc
 *		Toggle
 */
void CDropCaret::ShowCaret(
	BOOL fShow)
{
	if (_dvp != -1 && _fCaretOn != fShow)
	{
		RECT rc;
		RECTUV rcuv;

		rcuv.left = _ptCaret.u;
		rcuv.top = _ptCaret.v;
		rcuv.right = rcuv.left + WIDTH_DROPCARET;
		rcuv.bottom = rcuv.top + _dvp;

		_ped->_pdp->RectFromRectuv(rc, rcuv);
		InvertRect(_hdcWindow, &rc);
		_fCaretOn = fShow;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\dynarray.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	DYNARRAY.H -- CDynamicArray class which is used to complement
 *      the CLstBxWndHost object.
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		12/15/97 - v-jerrki Created
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */
#include "_w32sys.h"

#ifndef __DYNARRAY_H__
#define __DYNARRAY_H__


#define DYNARRAY_ARRAY_SIZE		128
#define DYNARRAY_ARRAY_SLOT		256
template<class T>
class CDynamicArray
{
protected:
	T*			_rg[DYNARRAY_ARRAY_SLOT];	
	int 		_nMax;						//indicate maximum valid index

public:
	static T			_sDummy;					// dummy struct if invalid index is requested
	
public:
	CDynamicArray() : _nMax(0) { memset(_rg, 0, sizeof(T*) * DYNARRAY_ARRAY_SLOT); }

	~CDynamicArray() { Clear();	}

	//==========================================================================
	// Reinitializes the class to its construction state
	//==========================================================================	
	void Clear()
	{
		//	Start removing all items from the list
		//	Start removing items from the list
		for (int i = ((_nMax - 1) / DYNARRAY_ARRAY_SIZE); i >= 0; i--)
		{
			if (_rg[i])
				delete _rg[i];
		}
		
		_nMax = 0;
		memset(_rg, 0, sizeof(T*) * DYNARRAY_ARRAY_SLOT);
	}

	
	const T& Get(int i);
	
	T& operator[](int i);
};

//==========================================================================
//	The function returns the requested index. if the requested index is
//  invalid then return dummy variable
//==========================================================================
template <class T>
const T& CDynamicArray<T>::Get(int i)
{
		// If item is negative or equal to zero, for efficiency reasons,
		// then just return the item in the head of array
		Assert(i >= 0);
		Assert(i < DYNARRAY_ARRAY_SLOT * DYNARRAY_ARRAY_SIZE);

		// Get the number of links we have to travel
		int nSlot = i / DYNARRAY_ARRAY_SIZE;		
		int nIdx = i % DYNARRAY_ARRAY_SIZE;

		// That link doesn't exist so just pass dummy struct
		Assert(nSlot < DYNARRAY_ARRAY_SLOT);
		if (i >= _nMax || nSlot >= DYNARRAY_ARRAY_SLOT || _rg[nSlot] == NULL)
		{	
			_sDummy._fSelected = 0;
			_sDummy._lparamData = 0;
			_sDummy._uHeight = 0;
			return _sDummy;
		}
			
		//return value at requested index		
		return _rg[nSlot][nIdx];
}

//==========================================================================
//	The function will be called if a l-value is requested therefore
//	the index does not necessarily have to be valid
//==========================================================================
template <class T>
T& CDynamicArray<T>::operator[](int i)
{
	Assert(i >= 0);

	// Get the slot number and index
	int nSlot = i / DYNARRAY_ARRAY_SIZE;		
	int nIdx = i % DYNARRAY_ARRAY_SIZE;

	// Check if the slot exists
	Assert(nSlot < DYNARRAY_ARRAY_SLOT);
	if (nSlot >= DYNARRAY_ARRAY_SLOT)
		return _sDummy;
	
	if (_rg[nSlot] == NULL)
	{
		//Need to allocate memory for this
		T* prg = new T[DYNARRAY_ARRAY_SIZE];
		if (!prg)
		{	
			_sDummy._fSelected = 0;
			_sDummy._lparamData = 0;
			_sDummy._uHeight = 0;
			return _sDummy;
		}

		memset(prg, 0, sizeof(T) * DYNARRAY_ARRAY_SIZE);
		_rg[nSlot] = prg;

		if (nSlot >= _nMax / DYNARRAY_ARRAY_SIZE)
			_nMax = (nSlot + 1) * DYNARRAY_ARRAY_SIZE;
	}		
			
	//return value at requested index
	return _rg[nSlot][nIdx];
}

#endif //__DYNARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\hash.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module HASH.C -- RTF control word cache |
 *		#ifdef'ed with RTF_HASHCACHE
 *		
 *	Owner: <nl>
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		8/15/95		jonmat first hash-cache for RTF using Brent's Method.
 */
#include "_common.h"

#ifdef RTF_HASHCACHE
					 
#include "hash.h"

ASSERTDATA

extern KEYWORD		rgKeyword[];			// All of the RTF control words.

#define MAX_INAME	3

typedef struct {
	const KEYWORD	*token;
	BOOL			passBit;
} HashEntry;

static HashEntry	*(hashtbl[HASHSIZE]);
static HashEntry	*storage;				// Dynamically alloc for cKeywords.

BOOL				_rtfHashInited = FALSE;

static INT			HashKeyword_Key( const CHAR *szKeyword );

/*
 *	HashKeyword_Insert()
 *	
 *	@func
 *		Insert a KEYWORD into the RTF hash table.
 *	@comm
 *		This function uses the the % for MOD
 *		in order to validate MOD257.
 */
VOID HashKeyword_Insert (
	const KEYWORD *token )//@parm pointer to KEYWORD token to insert.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Insert");

	INT			index, step, position,
				cost, source, sink, index1,
				step1, temp;
	
	BOOL		tmpPassBit;	
	
	static INT	totalKeys = 0;

	CHAR 		*szKeyword;
	
	HashEntry	*np;
	
	AssertSz ( _rtfHashInited, "forgot to call HashKeyword_Init()");
	AssertSz ( totalKeys <= HASHSIZE * 0.7, "prime not large enough to hold total keys");
	
	szKeyword = token->szKeyword;
	
	np = &storage[totalKeys++];
	np->token = token;

	index = HashKeyword_Key(szKeyword) % HASHSIZE;  // Get keys.
	step = 1 + (HashKeyword_Key(szKeyword) % (HASHSIZE-1));

	position = 1;
	cost = HASHSIZE;								// The max collisions for any.
	while(hashtbl[index]!=NULL)						// Find empty slot.
	{
		position++;									// How many collisions.

		// For the keyword stored here, calc # times before it is found.
		temp=1;
		step1= 1+(HashKeyword_Key(hashtbl[index]->token->szKeyword) % (HASHSIZE-1));
		index1= (index+step1)%HASHSIZE;
		while(hashtbl[index1] !=NULL)
		{
			index1=(index1+step1)%HASHSIZE;
			temp++;
		}
		
		// Incremental cost computation, minimizes average # of collisions
		//  for both keywords.
		if (cost>position+temp)
		{
			source=index;
			sink=index1;
			cost=position+temp;
		}
		
		// There will be something stored beyound here, set the passBit.
		hashtbl[index]->passBit=1;

		// Next index to search for empty slot.
		index=(index+step)%HASHSIZE;

	}
	
	if (position<=cost)
	{
		source=sink=index;
		cost=position;
	}
	hashtbl[sink] = hashtbl[source];
	hashtbl[source] = np;
	if (hashtbl[sink] && hashtbl[source])	// jOn hack, we didn't really
	{										//  want to swap pass bits.
		tmpPassBit = hashtbl[sink]->passBit;
		hashtbl[sink]->passBit = hashtbl[source]->passBit;
		hashtbl[source]->passBit = tmpPassBit;
	}

}

/*
 *	static HashKeyword_Key()
 *	
 *	@func
 *		Calculate the hash key.
 *	@comm
 *		Just add up the first few characters.
 *	@rdesc
 *		The hash Key for calculating the index and step.
 */
static INT HashKeyword_Key(
	const CHAR *szKeyword ) //@parm C string to create hash key for.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Key");

	INT i, tot = 0;
	
	/* Just add up first few characters. */
	for (i = 0; i < MAX_INAME && *szKeyword; szKeyword++, i++)
			tot += (UCHAR) *szKeyword;
	return tot;
}	

/*
 *	HashKeyword_Fetch()
 *	
 *	@func
 *		Look up a KEYWORD with the given szKeyword.
 *	@devnote
 *		We have a hash table of size 257. This allows for
 *		the use of very fast routines to calculate a MOD 257.
 *		This gives us a significant increase in performance
 *		over a binary search.
 *	@rdesc
 *		A pointer to the KEYWORD, or NULL if not found.
 */
const KEYWORD *HashKeyword_Fetch (
	const CHAR *szKeyword ) //@parm C string to search for.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Fetch");

	INT 		index, step;
	
	HashEntry *	hashTblPtr;

	BYTE *		pchCandidate;
	BYTE *		pchKeyword;
	
	INT			nComp;

	CHAR		firstChar;

	INT			hashKey;

	AssertSz( HASHSIZE == 257, "Remove custom MOD257.");
	
	firstChar = *szKeyword;
	hashKey = HashKeyword_Key(szKeyword);	// For calc'ing 'index' and 'step'
	
	//index = hashKey%HASHSIZE;				// First entry to search.
	index = MOD257(hashKey);				// This formula gives us 18% perf.

	hashTblPtr = hashtbl[index];			// Get first entry.
	if ( hashTblPtr != NULL )				// Something there?
	{
											// Compare 2 C strings.								
		pchCandidate = (BYTE *)hashTblPtr->token->szKeyword;
		if ( firstChar == *pchCandidate )
		{
			pchKeyword	 = (BYTE *)szKeyword;
			while (!(nComp = *pchKeyword - *pchCandidate)	// Be sure to match
				&& *pchKeyword)								//  terminating 0's
			{
				pchKeyword++;
				pchCandidate++;
			}
											// Matched?
			if ( 0 == nComp )
				return hashTblPtr->token;
		}
		
		if ( hashTblPtr->passBit==1 )		// passBit=>another entry to test
		{

			// step = 1+(hashKey%(HASHSIZE-1));// Calc 'step'
			step = 1 + MOD257_1(hashKey);

											// Get second entry to check.
			index += step;
			index = MOD257(index);
			hashTblPtr = hashtbl[index];

			while (hashTblPtr != NULL )		// While something there.
			{
											// Compare 2 C strings.								
				pchCandidate = (BYTE *)hashTblPtr->token->szKeyword;
				if ( firstChar == *pchCandidate )
				{
					pchKeyword	 = (BYTE *)szKeyword;
					while (!(nComp = *pchKeyword - *pchCandidate)
						&& *pchKeyword)
					{
						pchKeyword++;
						pchCandidate++;
					}
											// Matched?
					if ( 0 == nComp )
						return hashTblPtr->token;
				}

				if ( !hashTblPtr->passBit )// Done searching?
					break;
											// Get next entry.
				index += step;
				index = MOD257(index);
				hashTblPtr = hashtbl[index];
			}
		}
	}
	
	return NULL;
}

/*
 *	HashKeyword_Init()
 *	
 *	@func
 *		Load up and init the hash table with RTF control words.
 *	@devnote
 *		_rtfHashInited will be FALSE if anything here fails.
 */
VOID HashKeyword_Init( )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Init");

	extern SHORT cKeywords;			// How many RTF keywords we currently recognize.

	INT i;

	AssertSz( _rtfHashInited == FALSE, "Only need to init this once.");

									// Create enough storage for cKeywords
	storage = (HashEntry *) PvAlloc( sizeof(HashEntry) * cKeywords, fZeroFill );

									// Load in all of the RTF control words.
	if ( storage )
	{
		_rtfHashInited = TRUE;

		for (i = 0; i < cKeywords; i++ )
		{
			HashKeyword_Insert(&rgKeyword[i]);
		}
#ifdef DEBUG						// Make sure we can fetch all these keywords.
		for (i = 0; i < cKeywords; i++ )
		{
			AssertSz ( &rgKeyword[i] == HashKeyword_Fetch ( rgKeyword[i].szKeyword ),
				"Keyword Hash is not working.");
		}
#endif
	}
}

#endif	// RTF_HASHCACHE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\hash.h ===
#ifndef _HASH_H
#define _HASH_H

#include "tokens.h"

#define		HASHSIZE 	257	// DO NOT CHANGE!
						// this prime has been chosen because
						// there is a fast MOD257
						// if you use the % operator the thing
						// slows down to just about what a binary search is.

#define			MOD257(k) ((k) - ((k) & ~255) - ((k) >> 8) )	// MOD 257
#define			MOD257_1(k) ((k) & 255)	// MOD (257 - 1)

extern BOOL		_rtfHashInited;
VOID			HashKeyword_Init( );

VOID			HashKeyword_Insert ( const KEYWORD *token );
const KEYWORD	*HashKeyword_Fetch ( const CHAR *szKeyword );

#endif	// _HASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\doc.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module DOC.C	CTxtStory and CTxtArray implementation |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini	<nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		6/25/95	alexgo	Cleanup and reorganization
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_doc.h"
#include "_format.h"

ASSERTDATA

// ===========================  Invariant stuff  ======================

#define DEBUG_CLASSNAME CTxtArray
#include "_invar.h"

// ========================  CTxtArray class  =========================

#ifdef DEBUG

/*
 *	CTxtArray::Invariant
 *
 *	@mfunc	Tests CTxtArray's state
 *
 *	@rdesc	Returns TRUE always; failures are indicated by Asserts
 *			Actually in this routine, we return count of chars in blocks
 *			since we need this value for one check.
 */
BOOL CTxtArray::Invariant() const
{
	static LONG	numTests = 0;
	numTests++;				// How many times we've been called.

	LONG cch = 0;
	LONG iMax = Count();

	if(iMax > 0)
	{
		CTxtBlk *ptb = Elem(0);

		// ptb shouldn't be NULL since we're within Count elements
		Assert(ptb);

		for(LONG i = 0; i < iMax; i++, ptb++)
		{
			LONG cchCurr = ptb->_cch;
			cch += cchCurr;
			
			Assert ( cchCurr >= 0 );
			Assert ( cchCurr <= CchOfCb(ptb->_cbBlock) );

			// While we're here, check range of interblock gaps
			Assert (ptb->_ibGap >= 0);
			Assert (ptb->_ibGap <= ptb->_cbBlock);

			LONG cchGap = CchOfCb(ptb->_ibGap);
			Assert ( cchGap >= 0 );
			Assert ( cchGap <= cchCurr );
		}
	}
	return cch;
}

#endif	// DEBUG

/*
 *	CTxtArray::CTxtArray()
 *	
 *	@mfunc		Text array constructor
 */
CTxtArray::CTxtArray() : CArray<CTxtBlk> ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::CTxtArray()");

	AssertSz(CchOfCb(cbBlockMost) - cchGapInitial >= cchBlkInitmGapI * 2, 
		"cchBlockMax - cchGapInitial must be at least (cchBlockInitial - cchGapInitial) * 2");

	Assert(!_cchText && !_iCF && !_iPF);
	// Make sure we have no data to initialize
	Assert(sizeof(CTxtArray) == sizeof(CArray<CTxtBlk>) + sizeof(_cchText) + 2*sizeof(_iCF));
}

/*
 *	CTxtArray::~CTxtArray
 *	
 *	@mfunc		Text array destructor
 */
CTxtArray::~CTxtArray()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::~CTxtArray");

	for(LONG itb = Count(); itb--; )
	{
		CTxtBlk *ptb = Elem(itb);
		if(ptb)
			ptb->FreeBlock();
		else
			AssertSz(FALSE, "CTxtArray::~CTxtArray: NULL block ptr");
	}
}

/*
 *	CTxtArray::CalcTextLength()
 *	
 *	@mfunc		Computes and return length of text in this text array
 *
 *	@rdesc		Count of character in this text array
 *
 *	@devnote	This call may be computationally expensive; we have to
 *				sum up the character sizes of all of the text blocks in
 *				the array.
 */
LONG CTxtArray::CalcTextLength() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::GetCch");

	_TEST_INVARIANT_
		
	LONG	 itb = Count();
	CTxtBlk *ptb = Elem(0);

	if(!itb || !ptb)
		return 0;

	for(LONG cch = 0; itb--; ptb++) 
		cch += ptb->_cch;

	return cch;
}

/*
 *	CTxtArray::AddBlock(itbNew, cb)
 *	
 *	@mfunc		create new text block
 *	
 *	@rdesc
 *		FALSE if block could not be added
 *		non-FALSE otherwise
 *	
 *	@comm 
 *	Side Effects:  
 *		moves text block array
 */
BOOL CTxtArray::AddBlock(
	LONG	itbNew,		//@parm	index of the new block 
	LONG	cb)			//@parm size of new block; if <lt>= 0, default is used
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::AddBlock");

	_TEST_INVARIANT_

	if(cb <= 0)
		cb = cbBlockInitial;

	AssertSz(cb > 0, "CTxtArray::AddBlock() - adding block of size zero");
	AssertSz(cb <= cbBlockMost, "CTxtArray::AddBlock() - block too big");

	CTxtBlk *ptb = Insert(itbNew, 1);
	if(!ptb || !ptb->InitBlock(cb))
	{	
		TRACEERRSZSC("TXTARRAT::AddBlock() - unable to allocate new block", E_OUTOFMEMORY);
		return FALSE;
	}
	return TRUE;
}

/*
 *	CTxtArray::SplitBlock(itb, ichSplit, cchFirst, cchLast, fStreaming)
 *	
 *	@mfunc		split a text block into two
 *	
 *	@rdesc
 *		FALSE if the block could not be split <nl>
 *		non-FALSE otherwise
 *	
 *	@comm
 *	Side Effects: <nl>
 *		moves text block array
 */
BOOL CTxtArray::SplitBlock(
	LONG itb, 			//@parm	index of the block to split
	LONG ichSplit,	 	//@parm	character index within block at which to split
	LONG cchFirst, 		//@parm desired extra space in first block
	LONG cchLast, 		//@parm desired extra space in new block
	BOOL fStreaming)	//@parm TRUE if streaming in new text
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::SplitBlock");

	_TEST_INVARIANT_

	AssertSz(ichSplit > 0 || cchFirst > 0, 
		"CTxtArray::SplitBlock(): splitting at beginning, but not adding anything");
	AssertSz(itb >= 0, "CTxtArray::SplitBlock(): negative itb");

	// Compute size for first half
	AssertSz(cchFirst + ichSplit <= CchOfCb(cbBlockMost),
		"CTxtArray::SplitBlock(): first size too large");
	cchFirst += ichSplit + cchGapInitial;
	cchFirst = min(cchFirst, CchOfCb(cbBlockMost));

	// Compute size for second half
	CTxtBlk *ptb = Elem(itb);
	if(!ptb)
	{
		AssertSz(FALSE, "CTxtArray::SplitBlock: NULL block ptr");
		return FALSE;
	}
	AssertSz(cchLast + ptb->_cch - ichSplit <= CchOfCb(cbBlockMost),
		"CTxtArray::SplitBlock(): second size too large");
	cchLast += ptb->_cch - ichSplit + cchGapInitial;
	cchLast = min(cchLast, CchOfCb(cbBlockMost));

	// Allocate second block and move text to it
	
	// If streaming in, allocate a block that's as big as possible so that
	// subsequent additions of text are faster. We always fall back to
	// smaller allocations so this won't cause unnecessary errors. When
	// we're done streaming we compress blocks, so this won't leave	a
	// big empty gap.  NOTE: ***** moves rgtb *****
	if(fStreaming)
	{
		LONG cb = cbBlockMost;
		const LONG cbMin = CbOfCch(cchLast);

		while(cb >= cbMin && !AddBlock(itb + 1, cb))
			cb -= cbBlockCombine;
		if(cb >= cbMin)
			goto got_block;
	}
	if(!AddBlock(itb + 1, CbOfCch(cchLast)))
	{
		TRACEERRSZSC("CTxtArray::SplitBlock(): unabled to add new block", E_FAIL);
		return FALSE;
	}

got_block:
	LPBYTE	 pbSrc;
	LPBYTE	 pbDst;
	CTxtBlk *ptb1 = Elem(itb+1);

	ptb = Elem(itb);	// Recompute ptb and ptb1 after rgtb moves
	if(!ptb || !ptb1)
	{
		AssertSz(FALSE, "CTxtArray::SplitBlock: NULL block ptr");
		return FALSE;
	}
	ptb1->_cch = ptb->_cch - ichSplit;
	ptb1->_ibGap = 0;
	pbDst = (LPBYTE) (ptb1->_pch - ptb1->_cch) + ptb1->_cbBlock;
	ptb->MoveGap(ptb->_cch); // make sure pch points to a continuous block of all text in ptb.
	pbSrc = (LPBYTE) (ptb->_pch + ichSplit);
	CopyMemory(pbDst, pbSrc, CbOfCch(ptb1->_cch));
	ptb->_cch = ichSplit;
	ptb->_ibGap = CbOfCch(ichSplit);

	// Resize first block
	if(CbOfCch(cchFirst) != ptb->_cbBlock)
	{
//$ FUTURE: don't resize unless growing or shrinking considerably
		if(!ptb->ResizeBlock(CbOfCch(cchFirst)))
		{
			TRACEERRSZSC("TXTARRA::SplitBlock(): unabled to resize block", E_OUTOFMEMORY);
			return FALSE;
		}
	}
	return TRUE;
}

/*
 *	CTxtArray::ShrinkBlocks()
 *	
 *	@mfunc		Shrink all blocks to their minimal size
 */
void CTxtArray::ShrinkBlocks()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::ShrinkBlocks");

	_TEST_INVARIANT_

	for(LONG itb = Count(); itb--; )
	{
		CTxtBlk *ptb = Elem(itb);
		if(ptb)
			ptb->ResizeBlock(CbOfCch(ptb->_cch));
		else
			AssertSz(FALSE, "CTxtArray::ShrinkBlocks: NULL block ptr");
	}
}

/*
 *	CTxtArray::RemoveBlocks(itbFirst, ctbDel)
 *	
 *	@mfunc		remove a range of text blocks
 *	
 *	@comm Side Effects: <nl>
 *		moves text block array
 */
void CTxtArray::RemoveBlocks(
	LONG itbFirst, 		//@parm Index of first block to remove
	LONG ctbDel)		//@parm	Count of blocks to remove
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::RemoveBlocks");

	_TEST_INVARIANT_

	LONG itb = itbFirst;

	AssertSz(itb + ctbDel <= Count(), "CTxtArray::RemoveBlocks(): not enough blocks");

	for(LONG ctb = ctbDel; ctb--; itb++)
	{
		CTxtBlk *ptb = Elem(itb);
		if(ptb)
			ptb->FreeBlock();
		else
			AssertSz(FALSE, "CTxtArray::RemoveBlocks: NULL block ptr");
	}
	Remove(itbFirst, ctbDel);
}

/*
 *	CTxtArray::CombineBlocks(itb)
 *	
 *	@mfunc		combine adjacent text blocks
 *	
 *	@rdesc
 *		nothing
 *	
 *	@comm 
 *	Side Effects: <nl>
 *		moves text block array
 *	
 *	@devnote
 *		scans blocks from itb - 1 through itb + 1 trying to combine
 *		adjacent blocks
 */
void CTxtArray::CombineBlocks(
	LONG itb)		//@parm	index of the first block modified
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::CombineBlocks");

	_TEST_INVARIANT_

	LONG ctb;
	LONG cbT;
	CTxtBlk *ptb, *ptb1;

	if(itb > 0)
		itb--;

	ctb = min(3, Count() - itb);
	if(ctb <= 1)
		return;

	for(; ctb > 1; ctb--)
	{
		ptb  = Elem(itb);							// Can we combine current
		ptb1 = Elem(itb+1);							//  and next blocks ?
		cbT = CbOfCch(ptb->_cch + ptb1->_cch + cchGapInitial);
		if(cbT <= cbBlockInitial)
		{											// Yes
			if(cbT != ptb->_cbBlock && !ptb->ResizeBlock(cbT))
				continue;
			ptb ->MoveGap(ptb->_cch);				// Move gaps at ends of
			ptb1->MoveGap(ptb1->_cch);				//  both blocks
			CopyMemory(ptb->_pch + ptb->_cch,		// Copy next block text
				ptb1->_pch,	CbOfCch(ptb1->_cch));	//  into current block
			ptb->_cch += ptb1->_cch;
			ptb->_ibGap += CbOfCch(ptb1->_cch);
			RemoveBlocks(itb+1, 1);					// Remove next block
		}
		else
			itb++;
	}
}

/*
 *	CTxtArray::GetChunk(ppch, cch, pchChunk, cchCopy)
 *	
 *	@mfunc
 *		Get content of text chunk in this text array into a string	
 *	
 *	@rdesc
 *		remaining count of characters to get
 */
LONG CTxtArray::GetChunk(
	TCHAR **ppch, 			//@parm ptr to ptr to buffer to copy text chunk into
	LONG cch, 				//@parm length of pch buffer
	TCHAR *pchChunk, 		//@parm ptr to text chunk
	LONG cchCopy) const	//@parm count of characters in chunk
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::GetChunk");

	_TEST_INVARIANT_

	if(cch > 0 && cchCopy > 0)
	{
		if(cch < cchCopy)
			cchCopy = cch;						// Copy less than full chunk
		CopyMemory(*ppch, pchChunk, cchCopy*sizeof(TCHAR));
		*ppch	+= cchCopy;						// Adjust target buffer ptr
		cch		-= cchCopy;						// Fewer chars to copy
	}
	return cch;									// Remaining count to copy
}

const CCharFormat* CTxtArray::GetCharFormat(LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtArray::GetCharFormat");

	const CCharFormat *	pCF;
	
	if(iCF < 0)
		iCF = _iCF;
	Assert(iCF >= 0);

	if(FAILED(GetCharFormatCache()->Deref(iCF, &pCF)))
	{
		AssertSz(FALSE, "CTxtArray::GetCharFormat: couldn't deref iCF");
		pCF = NULL;
	}
	return pCF;
}

const CParaFormat* CTxtArray::GetParaFormat(LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtArray::GetParaFormat");

	const CParaFormat *	pPF;
	
	if(iPF < 0)
		iPF = _iPF;
	Assert(iPF >= 0);

	if(FAILED(GetParaFormatCache()->Deref(iPF, &pPF)))
	{
		AssertSz(FALSE, "CTxtArray::GetParaFormat: couldn't deref iPF");
		pPF = NULL;
	}
	return pPF;
}


// ========================  CTxtBlk class  =================================
/*
 *	CTxtBlk::InitBlock(cb)
 *	
 *	@mfunc
 *		Initialize this text block
 *
 *	@rdesc
 *		TRUE if success, FALSE if allocation failed
 */
BOOL CTxtBlk::InitBlock(
	LONG cb)			//@parm	initial size of the text block
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::InitBlock");

	_pch	= NULL;
	_cch	= 0;
	_ibGap	= 0;
	_cbBlock= cb;

	if(cb)
		_pch = (TCHAR*)PvAlloc(cb, GMEM_ZEROINIT);
	return _pch != 0;
}

/*
 *	CTxtBlk::FreeBlock()
 *	
 *	@mfunc
 *		Free this text block
 */
void CTxtBlk::FreeBlock()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::FreeBlock");

	FreePv(_pch);
	_pch	= NULL;
	_cch	= 0;
	_ibGap	= 0;
	_cbBlock= 0;
}

/*
 *	CTxtBlk::MoveGap(ichGap)
 *	
 *	@mfunc
 *		move gap in this text block
 */
void CTxtBlk::MoveGap(
	LONG ichGap)			//@parm	new position for the gap
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::MoveGap");

	LONG cbMove;
	LONG ibGapNew = CbOfCch(ichGap);
	LPBYTE pbFrom = (LPBYTE) _pch;
	LPBYTE pbTo;

	if(ibGapNew == _ibGap)
		return;

	if(ibGapNew < _ibGap)
	{
		cbMove = _ibGap - ibGapNew;
		pbFrom += ibGapNew;
		pbTo = pbFrom + _cbBlock - CbOfCch(_cch);
	}
	else
	{
		cbMove = ibGapNew - _ibGap;
		pbTo = pbFrom + _ibGap;
		pbFrom = pbTo + _cbBlock - CbOfCch(_cch);
	}

	MoveMemory(pbTo, pbFrom, cbMove);
	_ibGap = ibGapNew;
}


/*
 *	CTxtBlk::ResizeBlock(cbNew)
 *	
 *	@mfunc
 *		resize this text block
 *	
 *	@rdesc	
 *		FALSE if block could not be resized <nl>
 *		non-FALSE otherwise
 *	
 *	@comm
 * 	Side Effects: <nl>
 *		moves text block
 */
BOOL CTxtBlk::ResizeBlock(
	LONG cbNew)		//@parm	the new size
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::ResizeBlock");

	TCHAR *pch;
	LONG cbMove;

	AssertSz(cbNew > 0, "resizing block to size <= 0");
	AssertSz(cbNew <= cbBlockMost, "CTxtBlk::ResizeBlock() - block too big");

	if(cbNew < _cbBlock)
	{
		if(_ibGap != CbOfCch(_cch))
		{
			// move text after gap down so that it doesn't get dropped

			cbMove = CbOfCch(_cch) - _ibGap;
			pch = _pch + CchOfCb(_cbBlock - cbMove);
			MoveMemory(pch - CchOfCb(_cbBlock - cbNew), pch, cbMove);
		}
		_cbBlock = cbNew;
	}
	pch = (TCHAR*)PvReAlloc(_pch, cbNew);
	if(!pch)
		return _cbBlock == cbNew;	// FALSE if grow, TRUE if shrink

	_pch = pch;
	if(cbNew > _cbBlock)
	{
		if(_ibGap != CbOfCch(_cch))		// Move text after gap to end so that
		{								// we don't end up with two gaps
			cbMove = CbOfCch(_cch) - _ibGap;
			pch += CchOfCb(_cbBlock - cbMove);
			MoveMemory(pch + CchOfCb(cbNew - _cbBlock), pch, cbMove);
		}
		_cbBlock = cbNew;
	}
	return TRUE;
}


// ========================  CTxtStory class  ============================
/* 
 *	CTxtStory::CTxtStory
 *
 *	@mfunc	Constructor
 *
 *	@devnote	Automatically allocates a text array.  If we want to have a
 *	completely empty edit control, then don't allocate a story.  NB!
 *	
 */
CTxtStory::CTxtStory()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::CTxtStory");

	_pCFRuns = NULL;
	_pPFRuns = NULL;
}

/*
 *	CTxtStory::~CTxtStory
 *
 *	@mfunc	Destructor
 */
CTxtStory::~CTxtStory()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::~CTxtStory");

	// Remove formatting.
	DeleteFormatRuns();
}

/*
 *	DeleteRuns ()
 *
 *	@mfunc
 *		Helper function for DeleteFormatRuns() below.  Releases
 *		formats used by format run collection before deleting the
 *		collection
 */
void DeleteRuns(CFormatRuns *pRuns, IFormatCache *pf)
{
    if(pRuns)									// Format runs may exist
	{
		LONG n = pRuns->Count();
		if(n)
		{
			CFormatRun *pRun = pRuns->Elem(0);
			for( ; n--; pRun++)
				pf->Release(pRun->_iFormat);	// Free run's format
		}
        delete pRuns;
	}	
}

/*
 *	CTxtStory::DeleteFormatRuns ()
 *
 *	@mfunc	Convert to plain - remove format runs
 */
void CTxtStory::DeleteFormatRuns()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::ConvertToPlain");

	DeleteRuns(_pCFRuns, GetCharFormatCache());
	DeleteRuns(_pPFRuns, GetParaFormatCache());

	_pCFRuns = NULL;
	_pPFRuns = NULL;
}


#ifdef DEBUG
//This dumps the contents of the CTxtStory
//TxtBlk & FormatRun arrays to the debug output.
void CTxtStory::DbgDumpStory(void)
{
	CTxtBlk * pblk;
	CFormatRun * pcfr;
	CFormatRun * ppfr;
	LONG ctxtr = 0;
	LONG ccfr = 0;
	LONG cpfr = 0;
	LONG i;

	ctxtr = _TxtArray.Count();

	if (_pCFRuns)
		ccfr = _pCFRuns->Count();
	if (_pPFRuns)
		cpfr = _pPFRuns->Count();

	for(i = 0; i < ctxtr; i++)
	{
		pblk = (CTxtBlk*)_TxtArray.Elem(i);
		Tracef(TRCSEVNONE, "TxtBlk #%d: cch = %d.", (i + 1), pblk->_cch);
	}	

	for(i = 0; i < ccfr; i++)
	{
		pcfr = (CFormatRun*)_pCFRuns->Elem(i);
		Tracef(TRCSEVNONE, "CFR #%d: cch = %d, iFormat = %d.",(i + 1), pcfr->_cch, pcfr->_iFormat);
	}	

	for(i = 0; i < cpfr; i++)
	{
		ppfr = (CFormatRun*)_pPFRuns->Elem(i);
		Tracef(TRCSEVNONE, "PFR #%d: cch = %d, iFormat = %d.",(i + 1), ppfr->_cch, ppfr->_iFormat);
			
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\edit.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	EDIT.C - main part of CTxtEdit |
 *	
 *		See also textserv.cpp (ITextServices and SendMessage interfaces)
 *		and tomDoc.cpp (ITextDocument interface)
 *	
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini, Murray Sargent, Alex Gounares, Rick Sailor,
 *		Jon Matousek
 *	
 *	History: <nl>
 *		12/28/95 jonmat-Added support of Magellan mouse and smooth scrolling.
 *
 *	@devnote
 *		Be sure to set tabs at every four (4) columns.  In fact, don't even
 *		think of doing anything else!
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_rtext.h"
#include "_hyph.h"
#include "_uspi.h"
#include "_urlsup.h"

#ifndef NOLINESERVICES
#include "_ols.h"
#endif

#include "_txtbrk.h"
#include "_clasfyc.h"

#define CONTROL(_ch) (_ch - 'A' + 1)

ASSERTDATA

// This is not public because we don't really want folks using it.
// ITextServices is a private interface.
EXTERN_C const IID IID_ITextServices = { // 8d33f740-cf58-11ce-a89d-00aa006cadc5
	0x8d33f740,
	0xcf58,
	0x11ce,
	{0xa8, 0x9d, 0x00, 0xaa, 0x00, 0x6c, 0xad, 0xc5}
  };

// {13E670F4-1A5A-11cf-ABEB-00AA00B65EA1}
EXTERN_C const GUID IID_ITextHost = 
{ 0x13e670f4, 0x1a5a, 0x11cf, { 0xab, 0xeb, 0x0, 0xaa, 0x0, 0xb6, 0x5e, 0xa1 } };

// {13E670F5-1A5A-11cf-ABEB-00AA00B65EA1}
EXTERN_C const GUID IID_ITextHost2 = 
{ 0x13e670f5, 0x1a5a, 0x11cf, { 0xab, 0xeb, 0x0, 0xaa, 0x0, 0xb6, 0x5e, 0xa1 } };

// this is used internally do tell if a data object is one of our own.
EXTERN_C const GUID IID_IRichEditDO =
{ /* 21bc3b20-e5d5-11cf-93e1-00aa00b65ea1 */
    0x21bc3b20,
    0xe5d5,
    0x11cf,
    {0x93, 0xe1, 0x00, 0xaa, 0x00, 0xb6, 0x5e, 0xa1}
};

// Static data members
DWORD CTxtEdit::_dwTickDblClick;	// time of last double-click
POINT CTxtEdit::_ptDblClick;		// position of last double-click

//HCURSOR CTxtEdit::_hcurCross = 0;	// We don't implement outline drag move
HCURSOR CTxtEdit::_hcurArrow = 0;
HCURSOR CTxtEdit::_hcurHand = 0;
HCURSOR CTxtEdit::_hcurIBeam = 0;
HCURSOR CTxtEdit::_hcurItalic = 0;
HCURSOR CTxtEdit::_hcurSelBar = 0;
HCURSOR CTxtEdit::_hcurVIBeam = 0;
HCURSOR CTxtEdit::_hcurVItalic = 0;

const WCHAR szCRLF[]= TEXT("\r\n");
const WCHAR szCR[]	= TEXT("\r");

WORD	g_wFlags = 0;					// Keyboard controlled flags

/*
 *	GetKbdFlags(vkey, dwFlags)
 *
 *	@func
 *		return bit mask (RSHIFT, LSHIFT, RCTRL, LCTRL, RALT, or LALT)
 *		corresponding to vkey = VK_SHIFT, VK_CONTROL, or VK_MENU and
 *		dwFlags
 *
 *	@rdesc
 *		Bit mask corresponding to vkey and dwFlags
 */
DWORD GetKbdFlags(
	WORD	vkey,		//@parm Virtual key code
	DWORD	dwFlags)	//@parm lparam of WM_KEYDOWN msg
{		
	if(vkey == VK_SHIFT)
		return (LOBYTE(HIWORD(dwFlags)) == 0x36) ? RSHIFT : LSHIFT;

	if(vkey == VK_CONTROL)
		return (HIWORD(dwFlags) & KF_EXTENDED) ? RCTRL : LCTRL;

	Assert(vkey == VK_MENU);

	return (HIWORD(dwFlags) & KF_EXTENDED) ? RALT : LALT;
}

LONG TwipsToHalfPoints(
	LONG x)
{
	return x > 0 ? (x + 5)/10 : 0;		// Convert twips to half points
}

LONG TwipsToQuarterPoints(
	LONG x)
{
	return x > 0 ? (x + 3)/5 : 0;		// Convert twips to quarter points
}

LONG CheckTwips(
	LONG x)
{
	return x > 0 ? min(x, 255) : 0;
}


///////////////// CTxtEdit Creation, Initialization, Destruction ///////////////////////////////////////

/*
 *	CTxtEdit::CTxtEdit()
 *
 *	@mfunc
 *		constructor
 */
CTxtEdit::CTxtEdit(
	ITextHost2 *phost,
	IUnknown * punk)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CTxtEdit");

	_unk.Init();
	_punk = (punk) ? punk : &_unk;
	_ldte.Init(this);
	_phost	  = phost;
	_cpAccelerator = -1;					// Default to no accelerator

	// Initialize _iCF and _iPF to something bogus
	Set_iCF(-1);
	Set_iPF(-1);

	// Initialize local maximum text size to window default
	_cchTextMost = cInitTextMax;

	// This actually counts the number of active ped
	W32->AddRef();
}

/*
 *	CTxtEdit::~CTxtEdit()
 *
 *	@mfunc
 *		Destructor
 */
CTxtEdit::~CTxtEdit ()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::~CTxtEdit");

	Assert(!_fMButtonCapture);				// Need to properly transition
											//  Magellan mouse if asserts!
	_fSelfDestruct = TRUE;					// Tell the Call Mgr not to
											//  call this any more
	// Flush clipboard first
	_ldte.FlushClipboard();

	if(_pDocInfo)							// Do this before closing
	{										//  down internal structures
		CloseFile(TRUE);					// Close any open file
		delete _pDocInfo;					// Delete document info
		_pDocInfo = NULL;
	}

	if(_pdetecturl)
		delete _pdetecturl;

#ifndef NOCOMPLEXSCRIPTS
	if (_pbrk)
		delete _pbrk;
#endif

	if(_pobjmgr)
		delete _pobjmgr;

	// Release our reference to selection object
	if(_psel)
		_psel->Release();

	// Delete undo and redo managers
	if(_pundo)
		_pundo->Destroy();

#ifndef NOPRIVATEMESSAGE
	if (_pMsgNotify)
		delete _pMsgNotify;
#endif

	// Release message filter.
	// Note that the attached message filter must have released this document
	// Otherwise we will never get here.
	if (_pMsgFilter)
	{
		_pMsgFilter->Release();
		_pMsgFilter = 0;
	}

	if(_predo)
		_predo->Destroy();

	ReleaseFormats(Get_iCF(), Get_iPF());	// Release default formats

	delete _pdp;						// Delete displays
	_pdp = NULL;						// Break any further attempts to
										//  use display
	delete _pdpPrinter;

	if (_fHost2)
	{
		// We are in a windows host - need to deal with the shutdown
		// problem where the window can be destroyed before text
		// services is.
		if (!_fReleaseHost)
		{
			((ITextHost2*)_phost)->TxFreeTextServicesNotification();
		}
		else
		{
			// Had to keep host alive so tell it we are done with it.
			_phost->Release();
		}
	}
			
	W32->Release();
}

void CTxtEdit::TxInvalidateRect(const RECT *prc)
{
	_phost->TxInvalidateRect(prc, FALSE);
}

void CTxtEdit::TxInvalidateRect(const RECTUV *prcuv)
{
	CMeasurer me(_pdp);
	RECT rc;
	_pdp->RectFromRectuv(rc, *prcuv);
	_phost->TxInvalidateRect(&rc, FALSE);
}

/*
 *	CTxtEdit::Init (prcClient)
 *
 *	@mfunc
 *		Initializes this CTxtEdit. Called by CreateTextServices()
 *
 *	@rdesc
 *		Return TRUE if successful
 */

BOOL CTxtEdit::Init (
	const RECT *prcClient)		//@parm Client RECT
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::Init");

	CCharFormat 		CF;
	DWORD				dwBits = 0;
	DWORD				dwMask;
	LONG				iCF, iPF;
	CParaFormat 		PF;
	CCallMgr			callmgr(this);

	static BOOL fOnce = FALSE;
	if (!fOnce)
	{
		CLock lock;
		fOnce =	TRUE;
		_fnpPropChg[ 0] = &CTxtEdit::OnRichEditChange;			// TXTBIT_RICHTEXT			
		_fnpPropChg[ 1] = &CTxtEdit::OnTxMultiLineChange;		// TXTBIT_MULTILINE		
		_fnpPropChg[ 2] = &CTxtEdit::OnTxReadOnlyChange;		// TXTBIT_READONLY			
		_fnpPropChg[ 3] = &CTxtEdit::OnShowAccelerator;			// TXTBIT_SHOWACCELERATOR			
		_fnpPropChg[ 4] = &CTxtEdit::OnUsePassword;				// TXTBIT_USEPASSWORD			
		_fnpPropChg[ 5] = &CTxtEdit::OnTxHideSelectionChange;	// TXTBIT_HIDESELECTION			
		_fnpPropChg[ 6] = &CTxtEdit::OnSaveSelection;			// TXTBIT_SAVESELECTION			
		_fnpPropChg[ 7] = &CTxtEdit::OnAutoWordSel;				// TXTBIT_AUTOWORDSEL			
		_fnpPropChg[ 8] = &CTxtEdit::OnTxVerticalChange;		// TXTBIT_VERTICAL			
		_fnpPropChg[ 9] = &CTxtEdit::NeedViewUpdate;			// TXTBIT_SELECTIONBAR			
		_fnpPropChg[10] = &CTxtEdit::OnWordWrapChange;			// TXTBIT_WORDWRAP 			
		_fnpPropChg[11] = &CTxtEdit::OnAllowBeep;				// TXTBIT_ALLOWBEEP				
		_fnpPropChg[12] = &CTxtEdit::OnDisableDrag;    			// TXTBIT_DISABLEDRAG			
		_fnpPropChg[13] = &CTxtEdit::NeedViewUpdate;			// TXTBIT_VIEWINSETCHANGE			
		_fnpPropChg[14] = &CTxtEdit::OnTxBackStyleChange;		// TXTBIT_BACKSTYLECHANGE			
		_fnpPropChg[15] = &CTxtEdit::OnMaxLengthChange;			// TXTBIT_MAXLENGTHCHANGE			
		_fnpPropChg[16] = &CTxtEdit::OnScrollChange;			// TXTBIT_SCROLLBARCHANGE			
		_fnpPropChg[17] = &CTxtEdit::OnCharFormatChange;		// TXTBIT_CHARFORMATCHANGE 			
		_fnpPropChg[18] = &CTxtEdit::OnParaFormatChange;		// TXTBIT_PARAFORMATCHANGE		
		_fnpPropChg[19] = &CTxtEdit::NeedViewUpdate;			// TXTBIT_EXTENTCHANGE			
		_fnpPropChg[20] = &CTxtEdit::OnClientRectChange;		// TXTBIT_CLIENTRECTCHANGE			
	}

	// Set up default CCharFormat and CParaFormat
	if (TxGetDefaultCharFormat(&CF, dwMask) != NOERROR ||
		TxGetDefaultParaFormat(&PF)			!= NOERROR ||
		FAILED(GetCharFormatCache()->Cache(&CF, &iCF)) ||
		FAILED(GetParaFormatCache()->Cache(&PF, &iPF)))
	{
		return FALSE;
	}

	GetTabsCache()->Release(PF._iTabs);
	Set_iCF(iCF);								// Save format indices
	Set_iPF(iPF);

	// Load mouse cursors (but only for first instance)
	if(!_hcurArrow)
	{
		_hcurArrow = LoadCursor(0, IDC_ARROW);
		if(!_hcurHand)
		{
			if (W32->_dwMajorVersion < 5)
				_hcurHand	= LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_HAND));
			else
				_hcurHand	= LoadCursor(0, IDC_HAND);
		}
		if(!_hcurIBeam)							// Load cursor
			_hcurIBeam	= LoadCursor(0, IDC_IBEAM);
		if(!_hcurItalic)
			_hcurItalic	= LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_ITALIC));
		if(!_hcurSelBar)
			_hcurSelBar = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_SELBAR));
		if(!_hcurVItalic)
			_hcurVItalic = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_VITALIC));
		if(!_hcurVIBeam)
			_hcurVIBeam	= LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_VIBEAM));
	}

#ifdef DEBUG
	// The host is going to do some checking on richtext vs. plain text.
	_fRich = TRUE;
#endif // DEBUG

	if(_phost->TxGetPropertyBits (TXTBITS |		// Get host state flags
		TXTBIT_MULTILINE | TXTBIT_SHOWACCELERATOR,	//  that we cache or need
		&dwBits) != NOERROR)						//  for display setup
	{
		return FALSE;
	}												// Cache bits defined by
	_dwFlags = dwBits & TXTBITS;					//  TXTBITS mask

	if ((dwBits & TXTBIT_SHOWACCELERATOR) &&		// They want accelerator,
		FAILED(UpdateAccelerator()))				//  so let's get it
	{
		return FALSE;
	}		

	_fTransparent = TxGetBackStyle() == TXTBACK_TRANSPARENT;
	if(dwBits & TXTBIT_MULTILINE)					// Create and initialize
		_pdp = new CDisplayML(this);				//  display
	else
		_pdp = new CDisplaySL(this);
	Assert(_pdp);

	if(!_pdp || !_pdp->Init())
		return FALSE;

	_fUseUndo  = TRUE;
	_fAutoFont = TRUE;
	_fDualFont = TRUE;
	_f10DeferChangeNotify = 0;

	// Set whether we are in our host or not
	ITextHost2 *phost2;
	if(_phost->QueryInterface(IID_ITextHost2, (void **)&phost2)	== NOERROR)
	{
		// We assume that ITextHost2 means this is our host
		phost2->Release();
		_fHost2 = TRUE;
	}
	else								// Get maximum from our host
		_phost->TxGetMaxLength(&_cchTextMost);

	// Add EOP iff Rich Text
	if(IsRich())
	{
		// We should _not_ be in 10 compatibility mode yet.
		// If we transition into 1.0 mode, we'll add a CRLF
		// at the end of the document.
		SetRichDocEndEOP(0);
	}

#ifndef NOLINESERVICES
	// Allow for win.ini control over use of line services
	if (W32->fUseLs())
	{
		OnSetTypographyOptions(TO_ADVANCEDTYPOGRAPHY, TO_ADVANCEDTYPOGRAPHY);
	}

#ifndef NOCOMPLEXSCRIPTS
	if (W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
		OrCharFlags(FDIGITSHAPE);		// digit substitution presents

	// Initialize the BiDi property
	// It is set to true if OS is BiDi (the system default LCID is a BiDi language)
	// or if the current keyboard code page is a BiDi code page
	// or if system.ini says we should do it.
	if (W32->OnBiDiOS() ||
		IsBiDiCharRep(GetKeyboardCharRep(0xFFFFFFFF)) ||
		W32->fUseBiDi())
	{
		OrCharFlags(FRTL);
	}

	_fAutoKeyboard = IsBiDi() && IsBiDiKbdInstalled();	
#endif // NOCOMPLEXSCRIPTS

#endif

	return TRUE;
}


///////////////////////////// CTxtEdit IUnknown ////////////////////////////////

/*
 *	CTxtEdit::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_NOINTERFACE
 *
 *	@devnote
 *		This interface is aggregated. See textserv.cpp for discussion.
 */
HRESULT CTxtEdit::QueryInterface(
	REFIID riid,
	void **ppv)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::QueryInterface");

	return _punk->QueryInterface(riid, ppv);
}

/*
 *	CTxtEdit::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */
ULONG CTxtEdit::AddRef(void)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::AddRef");

	return _punk->AddRef();
}

/*
 *	CTxtEdit::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */
ULONG CTxtEdit::Release(void)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::Release");

	return _punk->Release();
}

////////////////////////// Undo Management  //////////////////////////////

/*
 *	CTxtEdit::CreateUndoMgr (cUndoLim, flags)
 *
 *	@mfunc
 *		Creates an undo stack
 *
 *	@rdesc
 *		Ptr to new IUndoMgr 
 */
IUndoMgr *CTxtEdit::CreateUndoMgr(
	LONG	cUndoLim,			//@parm Size limit
	USFlags flags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CreateUndoMgr");

	if(!_fUseUndo)
		return NULL;

	IUndoMgr *pmgr = new CUndoStack(this, cUndoLim, flags);
	if(!pmgr)
		return NULL;

	if(!pmgr->GetUndoLimit())
	{
		// The undo stack failed to initialize properly (probably
		// lack of memory). Trash it and return NULL.
		pmgr->Destroy();
		return NULL;
	}
	// We may be asked to create a new undo/redo manager
	// before we are completely done with initialization.
	// We need to clean up memory we have already allocated.
	if(flags & US_REDO)
	{
		if(_predo)
			_predo->Destroy();
		_predo = pmgr;
	}
	else
	{
		if(_pundo)
			_pundo->Destroy();
		_pundo = pmgr;
	}
	return pmgr;
}

/*
 *	CTxtEdit::HandleUndoLimit (cUndoLim)
 *
 *	@mfunc
 *		Handles the EM_SETUNDOLIMIT message
 *
 *	@rdesc	
 *		Actual limit to which things were set.
 */
LRESULT CTxtEdit::HandleSetUndoLimit(
	LONG cUndoLim) 		//@parm	Requested limit size
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::HandleSetUndoLimit");

	if (cUndoLim == tomSuspend ||			// This option really just
		cUndoLim == tomResume)				//  suspends undo, i.e.,
	{										//  doesn't discard existing	
		_fUseUndo = (cUndoLim == tomResume);//  antievents	
		return _pundo ? _pundo->GetUndoLimit() : 0;							
	}

	if(cUndoLim < 0)
		cUndoLim = DEFAULT_UNDO_SIZE;

	if(!cUndoLim)
	{
		_fUseUndo = FALSE;
		if(_pundo)
		{
			_pundo->Destroy();
			_pundo = NULL;
		}
		if(_predo)
		{
			_predo->Destroy();
			_predo = NULL;
		}
	}
	else if(!_pundo)
	{
		_fUseUndo = TRUE;
		// Don't worry about return value; if it's NULL, we're
		// in the same boat as if the API wasn't called (so later
		// on, we might try to allocate the default).
		CreateUndoMgr(cUndoLim, US_UNDO);
	}
	else
	{
		cUndoLim = _pundo->SetUndoLimit(cUndoLim);

		// Setting the undo limit on the undo stack will return to
		// us the actual amount set.  Try to set the redo stack to 
		// the same size.  If it can't go that big, too bad.
		if(_predo)
			_predo->SetUndoLimit(cUndoLim);
	}
	return cUndoLim;
}

/*
 *	CTxtEdit::HandleSetTextMode(mode)
 *
 *	@mfunc	handles setting the text mode
 *
 *	@rdesc	LRESULT; 0 (NOERROR) on success, OLE failure code on failure.
 *
 *	@devnote	the text mode does not have to be fully specified; it
 *			is sufficient to merely specify the specific desired behavior.
 *
 *			Note that the edit control must be completely empty for this
 *			routine to work.
 */
LRESULT CTxtEdit::HandleSetTextMode(
	DWORD mode)			//@parm the desired mode
{
	LRESULT lres = 0;

	// First off, we must be completely empty
	if (GetAdjustedTextLength() || 
		_pundo && _pundo->CanUndo() ||
		_predo && _predo->CanUndo())
	{
		return E_UNEXPECTED;
	}

	// These bits are considered one at a time; thus the absence of
	// any bits does _NOT_ imply any change in behavior.

	// TM_RICHTEXT && TM_PLAINTEXT are mutually exclusive; they cannot
	// be both set.  Same goes for TM_SINGLELEVELUNDO / TM_MULTILEVELUNDO
	// and TM_SINGLECODEPAGE / TM_MULTICODEPAGE
	if((mode & (TM_RICHTEXT | TM_PLAINTEXT)) == (TM_RICHTEXT | TM_PLAINTEXT) ||
	   (mode & (TM_SINGLELEVELUNDO | TM_MULTILEVELUNDO)) ==
			(TM_SINGLELEVELUNDO | TM_MULTILEVELUNDO) ||
	   (mode & (TM_SINGLECODEPAGE | TM_MULTICODEPAGE)) ==
			(TM_SINGLECODEPAGE | TM_MULTICODEPAGE))
	{
		lres = E_INVALIDARG;
	}
	else if((mode & TM_PLAINTEXT) && IsRich())
		lres = OnRichEditChange(FALSE);

	else if((mode & TM_RICHTEXT) && !IsRich())
		lres = OnRichEditChange(TRUE);

	if(!lres)
	{
		if(mode & TM_SINGLELEVELUNDO)
		{
			if(!_pundo)
				CreateUndoMgr(1, US_UNDO);

			if(_pundo)
			{
				// We can 'Enable' single level mode as many times
				// as we want, so no need to check for it before hand.
				lres = ((CUndoStack *)_pundo)->EnableSingleLevelMode();
			}
			else
				lres = E_OUTOFMEMORY;
		}
		else if(mode & TM_MULTILEVELUNDO)
		{
			// If there's no undo stack, no need to do anything,
			// we're already in multi-level mode
			if(_pundo && ((CUndoStack *)_pundo)->GetSingleLevelMode())
				((CUndoStack *)_pundo)->DisableSingleLevelMode();
		}

		if(mode & TM_SINGLECODEPAGE)
			_fSingleCodePage = TRUE;

		else if(mode & TM_MULTICODEPAGE)
			_fSingleCodePage = FALSE;
	}

	// We don't want this marked modified after this operation to make us
	// work better in dialog boxes.
	_fModified = FALSE;

	return lres;
}

/*
 *	CTxtEdit::HandleSetTextFlow(mode)
 *
 *	@mfunc	handles setting the text flow
 *
 *	@rdesc	LRESULT; 0 (NOERROR) on success, 1 (S_FALSE) for invalide mode
 *
 */
LRESULT CTxtEdit::HandleSetTextFlow(
	DWORD mode)			//@parm the desired mode
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::HandleSetTextFlow");

	if (!IN_RANGE(0, mode, 3) || !_pdp)
		return S_FALSE;

	if (mode == _pdp->GetTflow())		// No change
		return NOERROR;

	// We pretend like something actually happened.
	GetCallMgr()->SetChangeEvent(CN_GENERIC);

	_pdp->SetTflow(mode);

	TxShowScrollBar(SB_HORZ, _pdp->IsUScrollEnabled());
	TxShowScrollBar(SB_VERT, _pdp->IsVScrollEnabled());

	NeedViewUpdate(TRUE);
	return NOERROR;
	
}

extern ICustomTextOut *g_pcto;
/*
 *	CTxtEdit::GetCcs()
 *
 *	@mfunc
 *		Fetches a CCcs for a specific CCharFormat
 *
 *	@rdesc
 *		Ptr to CCcs
 */
CCcs* CTxtEdit::GetCcs(
	const CCharFormat *const pCF, 
	const LONG	dvpInch, 
	DWORD		dwFlags, 
	HDC			hdc)
{
	//Note, don't do ClearType for metafiles or printing.
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetCcs");

	CCharFormat CF = *pCF;
	if (g_pcto && FUseCustomTextOut())
		CF._dwEffects |= CFE_CUSTOMTEXTOUT;

#ifndef NODRAFTMODE
	// Use draft mode font only for displays
	if (_fDraftMode && (!hdc || GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY))
	{
		SHORT iFont;
		SHORT yHeight;
		QWORD qwFontSig;
		COLORREF crColor;

		if (W32->GetDraftModeFontInfo(iFont, yHeight, qwFontSig, crColor))
		{
			// Only hammer the name if the charset is OK
			if (FontSigFromCharRep(CF._iCharRep) & qwFontSig)
				CF._iFont = iFont;
			// Hammer the size always
			CF._yHeight = yHeight;
		}
	}
#endif

	if (dwFlags == -1)
		dwFlags = _pdp->GetTflow();

	if (_fUseAtFont)
		dwFlags |= FGCCSUSEATFONT;

	return fc().GetCcs(&CF, dvpInch, dwFlags, hdc);
}


CHyphCache *g_phc;
/*
 *	CTxtEdit::GetHyphCache()
 *
 *	@mfunc
 *		returns a pointer to the CHyphCache class (creating it if necessary)
 *
 *	@rdesc
 *		Ptr to CHyphCache class
 */
CHyphCache* CTxtEdit::GetHyphCache(void)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetHyphCache");
	if (!g_phc)
		g_phc = new CHyphCache();

	return g_phc;
}

////////////////////////// Uniscribe Interface //////////////////////////////
#ifndef NOCOMPLEXSCRIPTS
/*
 *	GetUniscribe()
 *
 *	@mfunc
 *		returns a pointer to the Uniscribe interface object
 *
 *	@rdesc
 *		Ptr to Uniscribe interface
 */
extern BOOL g_fNoUniscribe;
CUniscribe* GetUniscribe()
{
	if (g_pusp)
		return g_pusp;

	if (g_fNoUniscribe)
		return NULL;

	//Attempt to create the Uniscribe object, but make sure the
	//OS is valid and that we can load the uniscribe DLL.
	int cScripts;
	//Find out if OS is valid, or if delay-load fails
	if (!IsSupportedOS() || FAILED(ScriptGetProperties(NULL, &cScripts)))
	{
		g_fNoUniscribe = TRUE;
		return NULL;
	}

	if (!g_pusp)
		g_pusp = new CUniscribe();

	AssertSz(g_pusp, "GetUniscribe(): Create Uniscribe object failed");
	return g_pusp;
}
#endif // NOCOMPLEXSCRIPTS

////////////////////////// Notification Manager //////////////////////////////

/*
 *	CTxtEdit::GetNotifyMgr()
 *
 *	@mfunc
 *		returns a pointer to the notification manager (creating it if necessary)
 *
 *	@rdesc
 *		Ptr to notification manager
 */
CNotifyMgr *CTxtEdit::GetNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetNotifyMgr");

	return &_nm;
}


////////////////////////// Object Manager ///////////////////////////////////

/*
 *	CTxtEdit::GetObjectMgr()
 *
 *	@mfunc
 *		returns a pointer to the object manager (creating if necessary)
 *
 *	@rdesc
 *		pointer to the object manager
 */
CObjectMgr *CTxtEdit::GetObjectMgr()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetObjectMgr");

	if(!_pobjmgr)
		_pobjmgr = new CObjectMgr();

	return _pobjmgr;
}


////////////////////////////// Properties - Selection ////////////////////////////////


LONG CTxtEdit::GetSelMin() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelMin");

	return _psel ? _psel->GetCpMin() : 0;
}

LONG CTxtEdit::GetSelMost() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelMost");

	return _psel ? _psel->GetCpMost() : 0;
}

		
////////////////////////////// Properties - Text //////////////////////////////////////

LONG CTxtEdit::GetTextRange(
	LONG	cpFirst,
	LONG	cch,
	WCHAR *	pch)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetTextRange");

#ifdef DEBUG
	const LONG cchAsk = cch;
#endif
	CTxtPtr	tp(this, cpFirst);
	LONG	cchAdj = GetAdjustedTextLength();

	if(--cch < 0 || cpFirst > cchAdj)
		return 0;

	cch = min(cch, cchAdj - cpFirst);
	if(cch > 0)
	{
		cch = tp.GetPlainText(cch, pch, cpFirst + cch, FALSE, FALSE);
		Assert(cch >= 0);
	}
	pch[cch] = TEXT('\0');

#ifdef DEBUG
	if(cch != cchAsk - 1)
		Tracef(TRCSEVINFO, "CTxtEdit::GetTextRange: only got %ld out of %ld", cch, cchAsk - 1);
#endif

	return cch;
}

/*
 *	CTxtEdit::GetTextEx (pgt, pch)
 *
 *	@mfunc
 *		Grabs text according to various params
 *
 *	@rdesc
 *		Count of bytes gotten
 */
LONG CTxtEdit::GetTextEx(
	GETTEXTEX *pgt,		//@parm Info on what to get
	WCHAR *	   pch)		//@parm Where to put the text
{
	LONG	cb;
	LONG	cch;
	LONG	cchGet = GetAdjustedTextLength();
	LONG	cpMin  = 0;
	LONG	cpMost = tomForward;
	WCHAR *	pchUse = pch;
	CTempWcharBuf twcb;

	if(pgt->flags & GT_SELECTION)			// Get selected text
	{
		cch = GetSel()->GetRange(cpMin, cpMost);
		cchGet = min(cch, cchGet - cpMin);	// Don't include final EOP
	}

	if(pgt->codepage == (unsigned)-1)	// Use default codepage
		pgt->codepage = GetDefaultCodePage(EM_GETTEXTEX);

	if(pgt->cb == (unsigned)-1)			// Client says its buffer is big enuf
	{									
		pgt->cb = cchGet + 1;
		if(W32->IsFECodePage(pgt->codepage) || pgt->codepage == 1200)
			pgt->cb += cchGet;
		else if(pgt->codepage == CP_UTF8 && (_qwCharFlags & ~FASCII))
			pgt->cb *= (_qwCharFlags & FABOVEX7FF) ? 3 : 2;
	}

	// Allocate a big buffer; make sure that we have
	// enough room for lots of CRLFs if necessary
	if(pgt->flags & GT_USECRLF)
		cchGet *= 2;

	if(pgt->codepage != 1200)
	{
		// If UNICODE, copy straight to client's buffer;
		// else, copy to temp buffer and translate cases first
		pchUse = twcb.GetBuf(cchGet + 1);
		if (pch)
			*((char *)pch) = '\0';		// In case something fails
	}
	else						// Be sure to leave room for NULL terminator
		cchGet = min(UINT(pgt->cb/2 - 1), (UINT)cchGet);

	// Now grab the text 
	if(pgt->flags & GT_NOHIDDENTEXT)
	{
		CRchTxtPtr rtp(this, cpMin);
		cch = rtp.GetPlainText(cchGet, pchUse, cpMost, FALSE, pgt->flags & GT_USECRLF);
	}
	else
	{
		CTxtPtr tp(this, cpMin);
		if(pgt->flags & GT_RAWTEXT)
			cch = tp.GetText(cchGet, pchUse);
		else
			cch = tp.GetPlainText(cchGet, pchUse, cpMost, FALSE, pgt->flags & GT_USECRLF);
	}
	pchUse[cch] = L'\0';

	// If we're just doing UNICODE, return number of chars written
	if(pgt->codepage == 1200)
		return cch;

	// Oops, gotta translate to ANSI
	cb = WideCharToMultiByte(pgt->codepage, 0, pchUse, cch + 1, (char *)pch, 
			pgt->cb, pgt->lpDefaultChar, pgt->lpUsedDefChar);

	// Don't count NULL terminator for compatibility with WM_GETTEXT
	return cb ? cb - 1 : 0;
}
			
/*
 *	CTxtEdit::GetTextLengthEx (pgtl)
 *
 *	@mfunc
 *		Calculates text length in various ways.
 *
 *	@rdesc
 *		Text length calculated in various ways
 *
 *	@comm
 *		This function returns an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
LONG CTxtEdit::GetTextLengthEx(
	GETTEXTLENGTHEX *pgtl)	//@parm Info describing how to calculate length
{
	LONG	cchUnicode = GetAdjustedTextLength();
	LONG	cEOP = 0;
	DWORD	dwFlags = pgtl->flags;
	GETTEXTEX gt;

	if(pgtl->codepage == (unsigned)-1)
		pgtl->codepage = GetDefaultCodePage(EM_GETTEXTLENGTHEX);

	// Make sure the flags are defined appropriately
	if ((dwFlags & GTL_CLOSE)    && (dwFlags & GTL_PRECISE) ||
		(dwFlags & GTL_NUMCHARS) && (dwFlags & GTL_NUMBYTES))
	{
		TRACEWARNSZ("Invalid flags for EM_GETTEXTLENGTHEX");
		return E_INVALIDARG;
	}

	// Note in the following if statement, the second part of the
	// and clause will always be TRUE. At some point in the future
	// fUseCRLF and Get10Mode may become independent, in which case
	// the code below will automatically work without change.
	// NEW with 4.0: 1.0 mode gets text as is, so don't add count for CRs.
	// (RichEdit 1.0 only inserts Enters as CRLFs; it doesn't "cleanse"
	// other text insertion strings)
	if((dwFlags & GTL_USECRLF) && !fUseCRLF() && !Get10Mode())
	{
		// Important facts for 1.0 mode (REMARK: this is out of date):
		//
		// (1) 1.0 mode implies that the text is stored with fUseCRLF true.
		// fUseCRLF means that the EOP mark can either be a CR or a
		// CRLF - see CTxtRange::CleanseAndReplaceRange for details. 
		//
		// (2) 1.0 mode has an invariant that the count of text returned 
		// by this call should be enough to hold all the text returned by
		// WM_GETTEXT.
		//
		// (3) The WM_GETEXT call for 1.0 mode will return a buffer in 
		// which all EOPs that consist of a CR are replaced by CRLF.
		//
		// Therefore, for 1.0 mode, we must count all EOPs that consist
		// of only a CR and add addition return character to count the
		// LF that will be added into any WM_GETEXT buffer.

		// For 2.0 mode, the code is much easier, just count up all
		// CRs and bump count of each one by 1.

		CTxtPtr tp(this, 0);
		LONG	Results;

		while(tp.FindEOP(tomForward, &Results))
		{
			// If EOP consists of 1 char, add 1 since is returned by a CRLF.
			// If it consists of 2 chars, add 0, since it's a CRLF and is
			// returned as such.
			if(tp.GetCp() > cchUnicode)		// Don't add correction for
				break;						//  final CR (if any)
			if (!(Results & FEOP_CELL) &&	// CELL gets xlated into TAB,
				tp.GetPrevChar() != FF)		//  and FF into FF,
			{								//  i.e., single chars
				Results &= 3;				// Get advance cch
				if(Results)
					cEOP += 2 - Results;	// Add in xtra if lone CR or LF	
			}
			AssertSz(IN_RANGE(1, Results & 3, 2) || !Results && tp.GetCp() == cchUnicode,
				"CTxtEdit::GetTextLengthEx: CRCRLF found in backing store");
		}
		cchUnicode += cEOP;
	}

	// If we're just looking for the number of characters or if it's an
	// 8-bit codepage in RE 1.0 mode, we've already got the count.
	if ((dwFlags & GTL_NUMCHARS) || !dwFlags ||
		Get10Mode() && Is8BitCodePage(pgtl->codepage))
	{
		return cchUnicode;
	}

	// Hmm, they're looking for number of bytes, but don't care about 
	// precision, just multiply by two.  If neither PRECISE or CLOSE is
	// specified, default to CLOSE. Note if the codepage is UNICODE and
	// asking for number of bytes, we also just multiply by 2.
	if((dwFlags & GTL_CLOSE) || !(dwFlags & GTL_PRECISE) ||
		pgtl->codepage == 1200)
	{
		return cchUnicode *2;
	}

	// In order to get a precise answer, we need to convert (which is slow!).
	gt.cb = 0;
	gt.flags = (pgtl->flags & GT_USECRLF);
	gt.codepage = pgtl->codepage;
	gt.lpDefaultChar = NULL;
	gt.lpUsedDefChar = NULL;

	return GetTextEx(&gt, NULL);
}

/*
 *	CTxtEdit::GetDefaultCodePage (msg)
 *
 *	@mfunc
 *		Return codepage to use for converting the text in RichEdit20A text
 *		messages.
 *
 *	@rdesc
 *		Codepage to use for converting the text in RichEdit20A text messages.
 */
LONG CTxtEdit::GetDefaultCodePage(
	UINT msg)
{
	LONG CodePage = GetACP();

	// FUTURE: For backward compatibility in Office97, We always use ACP for all these 
	// languages. Need review in the future when the world all moves to Unicode.
	if (W32->IsBiDiCodePage(CodePage) || CodePage == CP_THAI || CodePage == CP_VIETNAMESE || 
		W32->IsFECodePage(CodePage) || _fSingleCodePage || msg == EM_GETCHARFORMAT || 
		msg == EM_SETCHARFORMAT)
	{
		return CodePage;
	}
	
	if(Get10Mode())
		return CodePageFromCharRep(GetCharFormat(-1)->_iCharRep);

	return CodePageFromCharRep(GetKeyboardCharRep());
}

//////////////////////////////  Properties - Formats  //////////////////////////////////

/*
 *	CTxtEdit::HandleStyle (pCFTarget, pCF, dwMask, dwMask2)
 *
 *	@mfunc
 *		If pCF specifies a style choice, initialize pCFTarget with the
 *		appropriate style, apply pCF, and return NOERROR.  Else return
 *		S_FALSE or an error
 *
 *	@rdesc
 *		HRESULT = (pCF specifies a style choice) ? NOERROR : S_FALSE or error code
 */
HRESULT CTxtEdit::HandleStyle(
	CCharFormat *pCFTarget,		//@parm Target CF to receive CF style content
	const CCharFormat *pCF,		//@parm Source CF that may specify a style
	DWORD		 dwMask,		//@parm CHARFORMAT2 mask
	DWORD		 dwMask2)		//@parm Second mask
{
	if(pCF->fSetStyle(dwMask, dwMask2))
	{
		// FUTURE: generalize to use client style if specified
		*pCFTarget = *GetCharFormat(-1);
		pCFTarget->ApplyDefaultStyle(pCF->_sStyle);
		return pCFTarget->Apply(pCF, dwMask, dwMask2);
	}
	return S_FALSE;
}

/*
 *	CTxtEdit::HandleStyle (pPFTarget, pPF)
 *
 *	@mfunc
 *		If pPF specifies a style choice, initialize pPFTarget with the
 *		appropriate style, apply pPF, and return NOERROR.  Else return
 *		S_FALSE or an error
 *
 *	@rdesc
 *		HRESULT = (pPF specifies a style choice) ? NOERROR : S_FALSE or error code
 */
HRESULT CTxtEdit::HandleStyle(
	CParaFormat *pPFTarget,		//@parm Target PF to receive PF style content
	const CParaFormat *pPF,		//@parm Source PF that may specify a style
	DWORD		dwMask,			//@parm Mask to use in setting CParaFormat
	DWORD		dwMask2)		//@parm Mask for internal flags
{
	if(pPF->fSetStyle(dwMask, dwMask2))
	{
		// FUTURE: generalize to use client style if specified
		*pPFTarget = *GetParaFormat(-1);
		pPFTarget->ApplyDefaultStyle(pPF->_sStyle);
		return pPFTarget->Apply(pPF, dwMask, dwMask2);
	}
	return S_FALSE;
}

//////////////////////////// Mouse Commands /////////////////////////////////

HRESULT CTxtEdit::OnTxLButtonDblClk(
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonDblClk");

	BOOL			fEnterParaSelMode = FALSE;
	HITTEST			Hit;
	CTxtSelection *	psel = GetSel();
	const POINT		ptxy = {x, y};
	POINTUV			pt;

	AssertSz(psel, "CTxtEdit::OnTxLButtonDblClk() - No selection object !");

    if (StopMagellanScroll())
        return S_OK;
    
	_dwTickDblClick = GetTickCount();
	_ptDblClick.x = x;
	_ptDblClick.y = y;

	TxUpdateWindow();		// Repaint window to show any exposed portions

	if(!_fFocus)
	{
		TxSetFocus();					// Create and display caret
		return S_OK;
	}

	_pdp->PointuvFromPoint(pt, ptxy);

	// Find out what the cursor is pointing at
	_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit); 

	if(Hit == HT_Nothing)
		return S_OK;

	if(Hit == HT_OutlineSymbol)
	{
		CTxtRange rg(*psel);
		rg.ExpandOutline(0, FALSE);
		return S_OK;
	}

	if(Hit == HT_LeftOfText)
		fEnterParaSelMode = TRUE;

	_fWantDrag = FALSE;					// just to be safe

	// If we are over a link, let the client have a chance to process
	// the message
	if(Hit == HT_Link && HandleLinkNotification(WM_LBUTTONDBLCLK, (WPARAM)dwFlags, MAKELPARAM(x, y)))
		return S_OK;

	if(dwFlags & MK_CONTROL)
		return S_OK;

	// Mark mouse down
	_fMouseDown = TRUE;

	if(_pobjmgr && _pobjmgr->HandleDoubleClick(this, pt, dwFlags))
	{
		// The object subsystem handled everything
		_fMouseDown = FALSE;
		return S_OK;
	}

	// Update the selection
	if(fEnterParaSelMode)
		psel->SelectUnit(pt, tomParagraph);
	else
		psel->SelectWord(pt);

	return S_OK;
}

HRESULT CTxtEdit::OnTxLButtonDown(
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonDown");

	BOOL		fEnterLineSelMode = FALSE;
	BOOL		fShift = dwFlags & MK_SHIFT;
	HITTEST		Hit;
	POINTUV		pt;
	const POINT ptxy = {x, y};
	COleObject *pobj;
	BOOL		fMustThaw = FALSE;

	const BOOL fTripleClick = GetTickCount() < _dwTickDblClick + W32->GetDCT() &&
				abs(x - _ptDblClick.x) <= W32->GetCxDoubleClk() &&
				abs(y - _ptDblClick.y) <= W32->GetCyDoubleClk();

    if (StopMagellanScroll())
        return S_OK;

    _pdp->PointuvFromPoint(pt, ptxy);

	// If click isn't inside view, just activate, don't select
	if(!_fFocus)					// Sets focus if not already
	{
		// We may be removing an existing selection, so freeze
		// display to avoid flicker
		_pdp->Freeze();
		fMustThaw = TRUE;
		TxSetFocus();				// creates and displays caret
	}

	// Grab selection object
	CTxtSelection * const psel = GetSel();
	AssertSz(psel,"CTxtEdit::OnTxLButtonDown - No selection object !");

	// Find out what cursor is pointing at
	_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit); 

	if(Hit == HT_LeftOfText)
	{
		// Shift click in sel bar treated as normal click
		if(!fShift)
		{
			// Control selbar click and triple selbar click
			// are select all
			if((dwFlags & MK_CONTROL) || fTripleClick)
			{
				psel->SelectAll();
				goto cancel_modes;
			}
			fEnterLineSelMode = TRUE;
			if(!GetAdjustedTextLength() && !_pdp->IsMultiLine())
			{
				const CParaFormat *pPF = psel->GetPF();
				// Can't see selected para mark when flushed right, so
				// leave selection as an insertion point
				if(pPF->_bAlignment == PFA_RIGHT && !pPF->IsRtlPara())
					fEnterLineSelMode = FALSE;
			}
		}
	}
	else if(Hit == HT_Nothing)
		goto cancel_modes;

	else if(!fShift)
		psel->CancelModes();

	// Let client have a chance to handle this message if we are over a link
	if(Hit == HT_Link && HandleLinkNotification(WM_LBUTTONDOWN, (WPARAM)dwFlags, 
			MAKELPARAM(x, y)))
	{
		goto cancel_modes;
	}

	_fMouseDown = TRUE;						// Flag mouse down
	if(!fShift && _pobjmgr)
	{
		// Deactivate anybody active, etc.
		ClickStatus status = _pobjmgr->HandleClick(this, pt);
		if(status == CLICK_OBJSELECTED)
		{
			// The object subsystem will handle resizing.
			// if not a resize we will signal start of drag
			pobj = _pobjmgr->GetSingleSelect();

			// Because HandleClick returned true, pobj better be non-null.
			Assert(pobj);

            if (!pobj->HandleResize(ptxy))
				_fWantDrag = !_fDisableDrag;

			goto cancel_modes;
		}
		else if(status == CLICK_OBJDEACTIVATED)
			goto cancel_modes;
	}

	_fCapture = TRUE;						// Capture the mouse
	TxSetCapture(TRUE);

	// Check for start of drag and drop
	if(!fTripleClick && !fShift && psel->PointInSel(pt, NULL, Hit) && !_fDisableDrag)
	{	    
		// Assume we want a drag. If we don't CmdLeftUp() needs
		//  this to be set anyway to change the selection
		_fWantDrag = TRUE;
		goto cancel_modes;
	}

	if(fShift)								// Extend selection from current
	{										//  active end to click
		psel->InitClickForAutWordSel(pt);
		psel->ExtendSelection(pt);			
	}
	else if(fEnterLineSelMode)				// Line selection mode: select line
		psel->SelectUnit(pt, tomLine);
	else if(fTripleClick || Hit == HT_OutlineSymbol) // paragraph selection mode
		psel->SelectUnit(pt, tomParagraph);
	else
	{
	    if (Get10Mode())
	        _f10DeferChangeNotify = 1;
		psel->SetCaret(pt);
		_mousePt = ptxy;
	}
        
	if(fMustThaw)
		_pdp->Thaw();

	return S_OK;

cancel_modes:
	psel->CancelModes();

	if(_fWantDrag)
	{
		TxSetTimer(RETID_DRAGDROP, W32->GetDragDelay());
		_mousePt = ptxy;
		_bMouseFlags = (BYTE)dwFlags;
		_fDragged = FALSE;
	}

	if(fMustThaw)
		_pdp->Thaw();
		
	return S_OK;
}

HRESULT CTxtEdit::OnTxLButtonUp(
	INT		x,				//@parm Mouse x coordinate
	INT		y,				//@parm Mouse y coordinate
	DWORD	dwFlags,		//@parm Mouse message wparam
	int	    ffOptions)      //@parm Mouse options, see _edit.h for details
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonUp");
    
	CheckRemoveContinuousScroll();

	// Remove capture before test for mouse down since we wait till
	// we get the mouse button up message to release capture since Forms
	// wants it that way.
	if(_fCapture && (ffOptions & LB_RELEASECAPTURE))
	{
		TxSetCapture(FALSE);
		_fCapture = FALSE;
	}

	// We were delaying selection change.  So send it now...
    if (DelayChangeNotification() && (ffOptions & LB_FLUSHNOTIFY))
    {
        AssertSz(Get10Mode(), "Flag should only be set in 10 mode");
        _f10DeferChangeNotify = 0;
        GetCallMgr()->SetSelectionChanged();        
    }

	if(!_fMouseDown)
	{
		// We noticed the mouse was no longer down earlier so we don't
		// need to do anything.
		return S_OK;
	}

	const BOOL fSetSel = !!_fWantDrag;
	const POINT ptxy = {x, y};
	POINTUV	pt;
	_pdp->PointuvFromPoint(pt, ptxy);

	// Cancel Auto Word Sel if on
	CTxtSelection * const psel = GetSel();
	AssertSz(psel,"CTxtEdit::OnLeftUp() - No selection object !");

	psel->CancelModes(TRUE);

	// Reset flags
	_fMouseDown = FALSE;
	_fWantDrag = FALSE;
	_fDragged = FALSE;
	TxKillTimer(RETID_DRAGDROP);
	if(IsInOutlineView())
		psel->Update(FALSE);

	// Let the client handle this message if we are over a
	// link area
	if(HandleLinkNotification(WM_LBUTTONUP, (WPARAM)dwFlags, 
			MAKELPARAM(x, y)))
	{
		return NOERROR;
	}

	// If we were in drag & drop, put caret under mouse
	if(fSetSel)
	{
		CObjectMgr* pobjmgr = GetObjectMgr();

		// If we were on an object, don't deselect it by setting the caret
		if(pobjmgr && !pobjmgr->GetSingleSelect())
		{
			psel->SetCaret(pt, TRUE);
			if(!_fFocus)
				TxSetFocus();		// create and display caret
		}
	}
	return S_OK;
}

HRESULT CTxtEdit::OnTxRButtonUp(
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags,	//@parm Mouse message wparam
	int     ffOptions)  //@parm option flag
{
	const POINT ptxy = {x, y};
	POINTUV		pt;
	CTxtSelection * psel;
	SELCHANGE selchg;
	HMENU hmenu = NULL;
	IOleObject * poo = NULL;
	COleObject * pobj = NULL;
	IUnknown * pUnk = NULL;
	IRichEditOleCallback * precall = NULL;
	_pdp->PointuvFromPoint(pt, ptxy);

	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxRButtonUp");

	// Make sure we have the focus
	if(!_fFocus)
		TxSetFocus();

	if(_fWantDrag)
	{
		_fDragged = FALSE;
		_fWantDrag = FALSE;
		TxKillTimer(RETID_DRAGDROP);
	}
		
	// Grab selection object
	psel = GetSel();
	psel->SetSelectionInfo(&selchg);

	// We need a pointer to the first object, if any, in the selection.
	if(_pobjmgr)
	{
		//If the point is in the selection we need to find out if there
		//are any objects in the selection.  If the point is not in a
		//selection but it is on an object, we need to select the object.
		if(psel->PointInSel(pt) || (ffOptions & RB_FORCEINSEL))
		{
			pobj = _pobjmgr->GetFirstObjectInRange(selchg.chrg.cpMin,
				selchg.chrg.cpMost);
		}
		else
		{
			//Select the object
			if(_pobjmgr->HandleClick(this, pt) == CLICK_OBJSELECTED)
			{
				pobj = _pobjmgr->GetSingleSelect();
				// Because HandleClick returned true, pobj better be non-null.
				Assert(pobj!=NULL);
				//Refresh our information about the selection
				psel = GetSel();
				psel->SetSelectionInfo(&selchg);
			}
		}
		precall = _pobjmgr->GetRECallback();
	}

	if(pobj)
		pUnk = pobj->GetIUnknown();

	if(pUnk)
		pUnk->QueryInterface(IID_IOleObject, (void **)&poo);

	if(precall)
		precall->GetContextMenu(selchg.seltyp, poo, &selchg.chrg, &hmenu);

	if(hmenu)
	{
		HWND hwnd, hwndParent;
		POINT ptscr;

		if(TxGetWindow(&hwnd) == NOERROR)
		{
			if(!(ffOptions & RB_NOSELCHECK) && !psel->PointInSel(pt) && 
				!psel->GetCch() && !(ffOptions & RB_FORCEINSEL))
				psel->SetCaret(pt);
			ptscr.x = ptxy.x;
			ptscr.y = ptxy.y;
			ClientToScreen(hwnd, &ptscr);

			hwndParent = GetParent(hwnd);
			if(!hwndParent)
				hwndParent = hwnd;

			TrackPopupMenu(hmenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON,
				ptscr.x, ptscr.y, 0, hwndParent, NULL);
		}
		DestroyMenu(hmenu);
	}

	if(poo)
		poo->Release();
	
	return precall ? S_OK : S_FALSE;
}

HRESULT CTxtEdit::OnTxRButtonDown(
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxRButtonDown");

    if (StopMagellanScroll())
        return S_OK;
    
	CTxtSelection *	psel = GetSel();
	const POINT		ptxy = {x, y};
	POINTUV			pt;

	_pdp->PointuvFromPoint(pt, ptxy);
	psel->CancelModes();

	if(psel->PointInSel(pt) && !_fDisableDrag)
	{
		_fWantDrag = TRUE;

		TxSetTimer(RETID_DRAGDROP, W32->GetDragDelay());
		_mousePt = ptxy;
		_bMouseFlags = (BYTE)dwFlags;
		_fDragged = FALSE;
		return S_OK;
	}
	return S_FALSE;
}

HRESULT CTxtEdit::OnTxMouseMove(
	INT		x,				//@parm Mouse x coordinate
	INT		y,				//@parm Mouse y coordinate
	DWORD	dwFlags,		//@parm Mouse message wparam
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMouseMove");

	if(!_fFocus)
		return S_OK;

	RECT rcxy;
	TxGetClientRect(&rcxy);
	if(_fWantDrag || _fCapture)
	{
		LONG nDragMinDist = W32->GetDragMinDist() + 3;
		int  dx = _mousePt.x > x ? _mousePt.x - x : x - _mousePt.x;
		int  dy = _mousePt.y > y ? _mousePt.y - y : y - _mousePt.y;

		if(dx < nDragMinDist && dy < nDragMinDist)
		{
			if(!_fCapture || x > 0 && x < rcxy.right && y > 0 && y < rcxy.bottom)
			{
				_bMouseFlags = (BYTE)dwFlags;
				return S_OK;
			}
		}
		_fDragged = _fWantDrag;
	}
	_mousePt.x = x;									// Remember for scrolling
	_mousePt.y = y;									//  speed, and dir calc.

	// RichEdit 1.0 allows the client to process mouse moves itself if
	// we are over a link (but _not_ doing drag drop).
	if(HandleLinkNotification(WM_MOUSEMOVE, 0, MAKELPARAM(x, y)))
		return NOERROR;

	// If we think mouse is down and it really is, do special processing
	if (GetAsyncKeyState(VK_LBUTTON) < 0 ||
		GetAsyncKeyState(VK_RBUTTON) < 0)
	{
		CTxtSelection * const psel = GetSel();
		AssertSz(psel,"CTxtEdit::OnMouseMove: No selection object !");

		if(_fWantDrag && !_fUsePassword &&
		   !IsProtected(_fReadOnly ? WM_COPY : WM_CUT, dwFlags, MAKELONG(x,y)))
		{
			TxKillTimer(RETID_DRAGDROP);
			_ldte.StartDrag(psel, publdr);
			// The mouse button may still be down, but drag drop is over
			// so we need to _think_ of it as up.
			_fMouseDown = FALSE;

			// Similarly, OLE should have nuked the capture for us, but
			// just in case something failed, release the capture.
			TxSetCapture(FALSE);
			_fCapture = FALSE;
		}
		else if(_fMouseDown)						// We think mouse is down
		{											//  and it is
			POINTUV pt;
			POINT	ptxy = {x, y};
			if(x >= rcxy.right && x < rcxy.right + 5)
				ptxy.x += 5;
			_pdp->PointuvFromPoint(pt, ptxy);
			if(_ldte.fInDrag())						// Only drag scroll if a drag
				_pdp->DragScroll(&_mousePt);		//  operation is in progress
			psel->ExtendSelection(pt);				// Extend the selection
			CheckInstallContinuousScroll();			// Install srolling timer
		}
	}
#ifndef NOMAGELLAN
	else if (!(GetAsyncKeyState(VK_MBUTTON) < 0) && !mouse.IsAutoScrolling())
	{
		if(_fMButtonCapture)						// Ensure we aren't autoscrolling
			OnTxMButtonUp (x, y, dwFlags);			//  via intellimouse

		if(_fMouseDown)
		{
			// Although we thought the mouse was down, at this moment it
			// clearly is not. Therefore, we pretend we got a mouse up
			// message and clear our state to get ourselves back in sync 
			// with what is really happening.
			OnTxLButtonUp(x, y, dwFlags, LB_RELEASECAPTURE);
		}
	}
#endif

	// Either a drag was started or the mouse button was not down. In either
	// case, we want no longer to start a drag so we set the flag to false.
	_fWantDrag = FALSE;
	return S_OK;
}

/*
 *	OnTxMButtonDown (x, y, dwFlags)
 *
 *	@mfunc
 *		The user pressed the middle mouse button, setup to do
 *		continuous scrolls, which may in turn initiate a timer
 *		for smooth scrolling.
 *
 *	@rdesc
 *		HRESULT = S_OK
 */
HRESULT CTxtEdit::OnTxMButtonDown (
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMButtonDown");

#if !defined(NOMAGELLAN)
	POINT	pt = {x,y};

	if(!_fFocus)
		TxSetFocus();
		
	if(!StopMagellanScroll() && mouse.MagellanStartMButtonScroll(*this, pt))
	{
		TxSetCapture(TRUE);

		_fCapture			= TRUE;							// Capture the mouse
		_fMouseDown			= TRUE;
		_fMButtonCapture	= TRUE;
	}
#endif

	return S_OK;
}

/*
 *	CTxtEdit::OnTxMButtonUp (x, y, dwFlags)
 *
 *	@mfunc
 *		Remove timers and capture associated with a MButtonDown
 *		message.
 *
 *	@rdesc
 *		HRESULT = S_OK
 */
HRESULT CTxtEdit::OnTxMButtonUp (
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMButtonUp");

#if !defined(NOMAGELLAN)
    if (mouse.ContinueMButtonScroll(this, x, y))
        return S_OK;

    StopMagellanScroll();
    
#else

	if(_fCapture)
		TxSetCapture(FALSE);

	_fCapture			= FALSE;
	_fMouseDown			= FALSE;
	_fMButtonCapture	= FALSE;
	
#endif

	return S_OK;
}


/*
 *	CTxtEdit::StopMagellanScroll()
 *
 *	@mfunc
 *		Stops the intellimouse autoscrolling and returns
 *      us back into a normal state
 *
 *  BOOL = TRUE if auto scrolling was turned off : FALSE
 *          Autoscrolling was never turned on
 */
 BOOL CTxtEdit::StopMagellanScroll ()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::StopMagellanScroll");

#if !defined(NOMAGELLAN)
    if (!mouse.IsAutoScrolling())
        return FALSE;
        
	mouse.MagellanEndMButtonScroll(*this);

	if(_fCapture)
		TxSetCapture(FALSE);

	_fCapture			= FALSE;
	_fMouseDown			= FALSE;
	_fMButtonCapture	= FALSE;
	return TRUE;
#else
    return FALSE;
#endif
}


/*
 *	CTxtEdit::CheckInstallContinuousScroll ()
 *
 *	@mfunc
 *		There are no events that inform the app on a regular
 *		basis that a mouse button is down. This timer notifies
 *		the app that the button is still down, so that scrolling can
 *		continue.
 */
void CTxtEdit::CheckInstallContinuousScroll ()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CheckInstallContinuousScroll");

	if(!_fContinuousScroll && TxSetTimer(RETID_AUTOSCROLL, cmsecScrollInterval))
		_fContinuousScroll = TRUE;
}

/*
 *	CTxtEdit::CheckRemoveContinuousScroll ()
 *
 *	@mfunc
 *		The middle mouse button, or drag button, is up
 *		remove the continuous scroll timer.
 */
void CTxtEdit::CheckRemoveContinuousScroll ()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CheckRemoveContinuousScroll");

	if(_fContinuousScroll)
	{
		TxKillTimer(RETID_AUTOSCROLL);
		_fContinuousScroll = FALSE;
	}
}

/*
 *	OnTxTimer(idTimer)
 *
 *	@mfunc
 *		Handle timers for doing background recalc and scrolling.
 *
 *	@rdesc
 *		HRESULT = (idTimer valid) ? S_OK : S_FALSE
 */
HRESULT CTxtEdit::OnTxTimer(
	UINT idTimer)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxTimer");

	switch (idTimer)
	{
		case RETID_BGND_RECALC:
			_pdp->StepBackgroundRecalc();
			break;

#if !defined(NOMAGELLAN)
		case RETID_MAGELLANTRACK:
			mouse.TrackUpdateMagellanMButtonDown(*this, _mousePt);
			break;
#endif
		case RETID_AUTOSCROLL:						// Continuous scrolling.
			OnTxMouseMove(_mousePt.x, _mousePt.y,	// Do a select drag scroll.
						  0, NULL);
			break;

#if !defined(NOMAGELLAN)
		case RETID_SMOOTHSCROLL:					// Smooth scrolling
			if(_fMButtonCapture)					// HACK, only 1 timer!
			{										// delivered on Win95
													// when things get busy.
				mouse.TrackUpdateMagellanMButtonDown(*this, _mousePt);	
			}
			if(_pdp->IsSmoothVScolling())			// Test only because of
				_pdp->SmoothVScrollUpdate();		//  above HACK!!
		break;
#endif
		case RETID_DRAGDROP:
			TxKillTimer(RETID_DRAGDROP);
			if (_fWantDrag && _fDragged && !_fUsePassword &&
				!IsProtected(_fReadOnly ? WM_COPY : WM_CUT,
				             _bMouseFlags, MAKELONG(_mousePt.x,_mousePt.y)))
			{
				IUndoBuilder *	publdr;
				CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);
				_ldte.StartDrag(GetSel(), publdr);
				_fWantDrag = FALSE;
				_fDragged = FALSE;
				TxSetCapture(FALSE);
				_fCapture = FALSE;
			}
			break;

		default:
			return S_FALSE;
	}
	return S_OK;
}


/////////////////////////// Keyboard Commands ////////////////////////////////

/*
 *	CTxtEdit::OnTxKeyDown(vkey, dwFlags, publdr)
 *
 *	@mfunc
 *		Handle WM_KEYDOWN message
 *
 *	@rdesc
 *		HRESULT with the following values:
 *
 *		S_OK				if key was understood and consumed
 *		S_MSG_KEY_IGNORED	if key was understood, but not consumed
 *		S_FALSE				if key was not understood or just looked at
 *									and in any event not consumed
 */
HRESULT CTxtEdit::OnTxKeyDown(
	WORD		  vkey,		//@parm Virtual key code
	DWORD		  dwFlags,	//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxKeyDown");

	if(IN_RANGE(VK_SHIFT, vkey, VK_MENU))
	{
		SetKeyboardFlag(GetKbdFlags(vkey, dwFlags));
		return S_FALSE;
	}

	BOOL  fAlt	 = GetKeyboardFlag(ALT, VK_MENU);
	BOOL  fCtrl  = GetKeyboardFlag(CTRL, VK_CONTROL);
	BOOL  fShift = GetKeyboardFlag(SHIFT, VK_SHIFT);

	BOOL  fRet	 = FALSE;			// Converted to HRESULT on return
	LONG  nDeadKey = 0;

	if(fCtrl & fShift)						// Signal NonCtrl/Shift keydown
		SetKeyboardFlag(LETAFTERSHIFT);		//  while Ctrl&Shift are down

	// Handle Hebrew caps and LRM/RLM
#ifndef NOCOMPLEXSCRIPTS
	if (IsBiDi())
	{
		if(IsBiDiCharRep(GetKeyboardCharRep(0xFFFFFFFF)))
		{
			_fHbrCaps = FALSE;
			if(IsRich() && W32->UsingHebrewKeyboard())
			{
				WORD wCapital = GetKeyState(VK_CAPITAL);
				_fHbrCaps = ((wCapital & 1) ^ fShift) &&
							!(wCapital & 0x0080) &&
					     	IN_RANGE('A', vkey, 'Z');
				if(_fHbrCaps)
					W32->ActivateKeyboard(ANSI_INDEX);
	        }
		}
		
		if(vkey == VK_BACK && fShift && W32->OnWin9x())
		{
			// Shift+Backspace generates a LRM | RLM on a BiDi keyboard.
			// Consequently, we must eat the Backspace lest it delete text.
			W32->_fLRMorRLM = 1;
			return S_OK;
		}
	}
#endif

	// If dragging or Alt key down, just look for ESCAPE. Note: if Alt key is
	// down, we should never come here (would generate WM_SYSKEYDOWN message).
	if(_fMouseDown)
	{	    
		if(vkey == VK_ESCAPE)
		{
		    // Turn-off autoscroll.
		    if (StopMagellanScroll())
		        return S_OK;
		    
			POINT pt;
			// Cancel drag select or drag & drop
			GetCursorPos(&pt);
			OnTxLButtonUp(pt.x, pt.y, 0, LB_RELEASECAPTURE | LB_FLUSHNOTIFY);
			return S_OK;
		}
		return OnTxSpecialKeyDown(vkey, dwFlags, publdr);
	}
	
	CTxtSelection * const psel = GetSel();
	AssertSz(psel,"CTxtEdit::OnKeyDown() - No selection object !");

	if(fCtrl)
	{
		if(OnTxSpecialKeyDown(vkey, dwFlags, publdr) == S_OK)
			return S_OK;

		if(fAlt)						// This following code doesn't handle
			return S_FALSE;				//  use Ctrl+Alt, which happens for
										//  AltGr codes (no WM_SYSKEYDOWN)

		// Shift must not be pressed for these.
		if(!fShift)
		{
			switch(vkey)
			{
			case 'E':
			case 'J':
			case 'R':
			case 'L':
			{
				if(!IsRich() || !IsntProtectedOrReadOnly(WM_KEYDOWN, vkey, dwFlags))
					return S_FALSE;

				CParaFormat PF;
				PF._bAlignment = PFA_LEFT;
				if (vkey == 'E')
					PF._bAlignment = PFA_CENTER;
				else if (vkey == 'J')
					PF._bAlignment = PFA_FULL_INTERWORD;
				else if (vkey == 'R')
					PF._bAlignment = PFA_RIGHT;
					
				psel->SetParaFormat(&PF, publdr, PFM_ALIGNMENT,	PFM2_PARAFORMAT);
				break;
			}
			case '1':
			case '2':
			case '5':
			{
				if(!IsRich() || !IsntProtectedOrReadOnly(WM_KEYDOWN, vkey, dwFlags))
					return S_FALSE;

				CParaFormat PF;
				PF._bLineSpacingRule = tomLineSpaceMultiple;
				PF._dyLineSpacing = (vkey - '0') * 20;
				if (vkey == '5')
					PF._dyLineSpacing = 30;

				psel->SetParaFormat(&PF, publdr, PFM_LINESPACING, 0);				
				break;
			}
			default:
				break;
			}
		}

		switch(vkey)
		{
		case VK_TAB:
			return OnTxChar(VK_TAB, dwFlags, publdr);

		case VK_CLEAR:
		case VK_NUMPAD5:
		case 'A':						// Ctrl-A => pselect all
			psel->SelectAll();
			break;

		//Toggle Subscript
		case 187: // = 
		{
			if(!IsRich())
				return S_FALSE;
			ITextFont *pfont;
			psel->GetFont(&pfont);
			if (pfont)
			{
				pfont->SetSubscript(tomToggle);
				pfont->Release();
			}
		}
		break;

		case 'C':						// Ctrl-C => copy
CtrlC:		CutOrCopySelection(WM_COPY, 0, 0, NULL);
			break;

		case 'V':						// Ctrl-V => paste
CtrlV:		if(IsntProtectedOrReadOnly(WM_PASTE, 0, 0))
			{
				PasteDataObjectToRange(NULL, (CTxtRange *)psel, 0, NULL, 
					publdr, PDOR_NONE);
			}
			break;

		case 'X':						// Ctrl-X => cut
CtrlX:		CutOrCopySelection(WM_CUT, 0, 0, publdr);
			break;

		case 'Z':						// Ctrl-Z => undo
			PopAndExecuteAntiEvent(_pundo, 0);
			break;

		case 'Y':						// Ctrl-Y => redo
			PopAndExecuteAntiEvent(_predo, 0);
			break;

#if defined(DEBUG) && !defined(NOFULLDEBUG)
			void RicheditDebugCentral(void);
		case 191:
			RicheditDebugCentral();
			break;
#endif

#if defined(DOGFOOD)
		case '1':						// Shift+Ctrl+1 => start Aimm
			// Activate AIMM by posting a message to RE (Shift+Ctrl+; for now)
			if (fShift && _fInOurHost)
			{
				HWND	hWnd;

				TxGetWindow( &hWnd );

				if (hWnd)
					PostMessage(hWnd, EM_SETEDITSTYLE, SES_USEAIMM, SES_USEAIMM);
			}
			break;
#endif

		case VK_CONTROL:
			goto cont;

// English keyboard defines
#define VK_APOSTROPHE	0xDE
#define VK_GRAVE		0xC0
#define VK_SEMICOLON	0xBA
#define VK_COMMA		0xBC
#define VK_HYPHEN		0xBD

		// REVIEW: restrict VK_HYPHEN to English keyboard?
		case VK_HYPHEN:
			return OnTxChar(fShift ? NBHYPHEN : SOFTHYPHEN, dwFlags, publdr);

		case VK_SPACE:
			if(!fShift)
				goto cont;
			return OnTxChar(NBSPACE, dwFlags, publdr);

		case VK_APOSTROPHE:
			if(fShift)
				g_wFlags ^= KF_SMARTQUOTES;
			else
				nDeadKey = ACCENT_ACUTE;
			break;

		case VK_GRAVE:
			nDeadKey = fShift ? ACCENT_TILDE : ACCENT_GRAVE;
			break;

		case VK_SEMICOLON:
			nDeadKey = ACCENT_UMLAUT;
			break;

		case '6':
			if(!fShift)
				goto cont;
			nDeadKey = ACCENT_CARET;
			break;

		case VK_COMMA:
			nDeadKey = ACCENT_CEDILLA;
			break;

		default:
			goto cont;
		}
		if(nDeadKey)
		{
			// Since deadkey choices vary a bit according to keyboard, we
			// only enable them for English. French, German, Italian, and
			// Spanish keyboards already have a fair amount of accent
			// capability.
			if(PRIMARYLANGID(GetKeyboardLayout(0)) == LANG_ENGLISH)
				SetDeadKey((WORD)nDeadKey);
			else goto cont;
		}
		return S_OK;
	}

cont:	
	switch(vkey)
	{
	case VK_BACK:
	case VK_F16:
		if(_fReadOnly)
		{	
			Beep();
			fRet = TRUE;
		}
		else if(IsntProtectedOrReadOnly(WM_KEYDOWN, VK_BACK, dwFlags))
		{
			fRet = psel->Backspace(fCtrl, publdr);
		} 
		break;

	case VK_INSERT:								// Ins
		if(fShift)								// Shift-Ins
			goto CtrlV;							// Alias for Ctrl-V
		if(fCtrl)								// Ctrl-Ins
			goto CtrlC;							// Alias for Ctrl-C

		if(!_fReadOnly)							// Ins
			_fOverstrike = !_fOverstrike;		// Toggle Ins/Ovr
		fRet = TRUE;
		break;

	case VK_LEFT:								// Left arrow
	case VK_RIGHT:								// Right arrow
		fRet = (vkey == VK_LEFT) ^ (psel->GetPF()->IsRtlPara() != 0)
			 ? psel->Left (fCtrl, fShift)
			 : psel->Right(fCtrl, fShift);
		break;

	case VK_UP:									// Up arrow
		fRet = psel->Up(fCtrl, fShift);
		break;

	case VK_DOWN:								// Down arrow
		fRet = psel->Down(fCtrl, fShift);
		break;

	case VK_HOME:								// Home
		fRet = psel->Home(fCtrl, fShift);
		break;

	case VK_END:								// End
		fRet = psel->End(fCtrl, fShift);
		break;

	case VK_PRIOR:								// PgUp
		// If SystemEditMode and control is single-line, do nothing
		if(!_fSystemEditMode || _pdp->IsMultiLine())
			fRet = psel->PageUp(fCtrl, fShift);
		break;

	case VK_NEXT:								// PgDn
		// If SystemEditMode and control is single-line, do nothing
		if(!_fSystemEditMode || _pdp->IsMultiLine())
			fRet = psel->PageDown(fCtrl, fShift);
		break;

	case VK_DELETE:								// Del
		if(fShift)								// Shift-Del
			goto CtrlX;							// Alias for Ctrl-X

		if(IsntProtectedOrReadOnly(WM_KEYDOWN, VK_DELETE, dwFlags))
			psel->Delete(fCtrl, publdr);
		fRet = TRUE;
		break;

	case CONTROL('J'):							// Ctrl-Return gives Ctrl-J
	case VK_RETURN:								//  (LF), treat it as return
		// If we are in 1.0 mode we need to handle <CR>'s on WM_CHAR
		if(!Get10Mode())
		{
			fRet = InsertEOP(dwFlags, fShift, publdr);
			if(!fRet)
				return S_FALSE;
		}
		break;

	default:
		return S_FALSE;
	}

	return fRet ? S_OK : S_MSG_KEY_IGNORED;
}

/*
 *	CTxtEdit::InsertEOP(dwFlags, fShift, publdr)
 *
 *	@mfunc
 *		Handle inserting EOPs with check for hyperlinks
 *
 *	@rdesc
 *		HRESULT
 */
BOOL CTxtEdit::InsertEOP(
	DWORD		  dwFlags,	//@parm lparam of WM_KEYDOWN msg
	BOOL		  fShift,	//@parm TRUE if Shift key depressed
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{ 
	if(!_pdp->IsMultiLine())
	{
		if (!_fSystemEditMode)
			Beep();
		return FALSE;
	}
	TxSetCursor(0, NULL);

	BOOL fInLink = FALSE;
	if(!fShift)
		HandleLinkNotification(WM_CHAR, 0, 0, &fInLink);

	if(!fInLink && IsntProtectedOrReadOnly(WM_CHAR, VK_RETURN, dwFlags))
		_psel->InsertEOP(publdr, (fShift && IsRich() ? VT : 0));

	return TRUE;
}

/*
 *	CTxtEdit::CutOrCopySelection(msg, wparam, lparam, publdr)
 *
 *	@mfunc
 *		Handle WM_COPY message and its keyboard hotkey aliases
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CTxtEdit::CutOrCopySelection(
	UINT   msg,				//@parm Message (WM_CUT or WM_COPY)
	WPARAM wparam,			//@parm Message wparam for protection check
	LPARAM lparam,			//@parm Message lparam for protection check
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	Assert(msg == WM_CUT || msg == WM_COPY);

	if(!_fUsePassword && IsntProtectedOrReadOnly(msg, wparam, lparam))
	{
		CTxtSelection *psel = GetSel();
		BOOL fCopy = msg == WM_COPY;
		LONG lStreamFormat = psel->CheckTableSelection(fCopy, TRUE, NULL, RR_NO_LP_CHECK)
						   ? SFF_WRITEXTRAPAR : 0;
		return fCopy
			? _ldte.CopyRangeToClipboard((CTxtRange *)psel, lStreamFormat)
			: _ldte.CutRangeToClipboard((CTxtRange *)psel, lStreamFormat, publdr);
	}
	return NOERROR;
}

#define ENGLISH_UK	 MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK)
#define ENGLISH_EIRE MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_EIRE)

/*
 *	CTxtEdit::OnTxSpecialKeyDown(vkey, dwFlags, publdr)
 *
 *	@mfunc
 *		Handle WM_KEYDOWN message for outline mode
 *
 *	@rdesc
 *		HRESULT with the following values:
 *
 *		S_OK				if key was understood and consumed
 *		S_MSG_KEY_IGNORED	if key was understood, but not consumed
 *		S_FALSE				if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxSpecialKeyDown(
	WORD		  vkey,				//@parm Virtual key code
	DWORD		  dwFlags,			//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)			//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxSpecialKeyDown");

	HRESULT	hr = S_FALSE;					// Key not understood yet
	DWORD	dwKbdFlags = GetKeyboardFlags();
	BOOL	fUpdateFormat = TRUE;

	if(!(dwKbdFlags & (CTRL | ALT)))		// All hot keys here have at
		return S_FALSE;						//  least Ctrl or Alt

	if(((dwKbdFlags & ALT) || vkey != 'C' && vkey != 'V' && vkey != 'X') &&
	   !IsntProtectedOrReadOnly(WM_KEYDOWN, VK_BACK, dwFlags, FALSE))
	{
		return S_FALSE;
	}

	CTxtSelection * const psel = GetSel();
	if(dwKbdFlags & ALT && dwKbdFlags & CTRL)
	{
		// AltGr generates LCTRL | RALT, so don't match hot keys with
		// that combination
		if(dwKbdFlags & LCTRL && dwKbdFlags & RALT)
			return S_FALSE;

		if(vkey == 'E')
		{
			LANGID lid = LANGIDFROMLCID(GetKeyboardLayout(0));
			static const LANGID rgLangID[] =
			{
				ENGLISH_UK, ENGLISH_EIRE, LANG_POLISH, LANG_PORTUGUESE,
				LANG_HUNGARIAN, LANG_VIETNAMESE
			};
			for(LONG i = ARRAY_SIZE(rgLangID); i--; )
			{
				// Don't insert Euro if lid matches any LIDs or PLIDs in rgLangID
				if(lid == rgLangID[i] || PRIMARYLANGID(lid) == rgLangID[i])
					return S_FALSE;
			}
			if(psel->PutChar(EURO, _fOverstrike, publdr))
			{
				SetKeyboardFlag(HOTEURO);	// Setup flag to eat the next WM_CHAR w/ EURO
                hr = S_OK;
			}
		}
		else if(dwKbdFlags & SHIFT)
			switch(vkey)
			{
#ifdef ENABLE_OUTLINEVIEW
			// FUTURE: OutlineView hot keys postponed (see below)
			case 'N':						// Alt-Ctrl-N => Normal View
				hr = SetViewKind(VM_NORMAL);
				break;	
			case 'O':						// Alt-Ctrl-O => Outline View
				hr = SetViewKind(VM_OUTLINE);
				break;
#endif
			case VK_F12:					// Shift-Alt-Ctrl-F12 (in case Alt-X taken)
				hr = psel->HexToUnicode(publdr);
				break;

	#if defined(DEBUG) && !defined(NOFULLDEBUG)
			case VK_F10:					// Shift-Alt-Ctrl-F10
				OnDumpPed();
				break;

			case VK_F11:					// Shift-Alt-Ctrl-F11
				if (W32->fDebugFont())
					psel->DebugFont();
				break;
	#endif
			}
		return hr;
	}

	AssertSz(psel, "CTxtEdit::OnTxSpecialKeyDown() - No selection object !");
	CTxtRange rg(*psel);

	if(!IsRich() || !_pdp->IsMultiLine() || !(dwKbdFlags & SHIFT))
		return S_FALSE;

	if(dwKbdFlags & ALT)							// Alt+Shift hot keys
	{
		// NB: Alt and Shift-Alt with _graphics_ characters generate a
		// WM_SYSCHAR, which see

#ifdef ENABLE_OUTLINEVIEW
		// FUTURE: These are Outline related hot keys.  We will postpone these features
		// since we have several bugs related to these hot keys
		// Bug 5687, 5689, & 5691		
		switch(vkey)
		{
		case VK_LEFT:								// Left arrow
		case VK_RIGHT:								// Right arrow
			hr = rg.Promote(vkey == VK_LEFT ? 1 : -1, publdr);
			psel->Update_iFormat(-1);
			psel->Update(FALSE);
			break;

		case VK_UP:									// Up arrow
		case VK_DOWN:								// Down arrow
			hr = MoveSelection(vkey == VK_UP ? -1 : 1, publdr);
			psel->Update(TRUE);
			break;
		}
#endif
		return hr;
	}

	Assert(dwKbdFlags & CTRL && dwKbdFlags & SHIFT);

	// Ctrl+Shift hot keys
	switch(vkey)
	{

#ifdef ENABLE_OUTLINEVIEW
	// FUTUTRE: These are Outline related hot keys.  We will postpone these features
	// since we have several bugs related to these hot keys
	// Bug 5687, 5689, & 5691	
	case 'N':						// Demote to Body
		hr = rg.Promote(0, publdr);
		break;
#endif

	//Toggle superscript
	case 187: // = 
	{
		ITextFont *pfont;
		psel->GetFont(&pfont);
		if (pfont)
		{
			pfont->SetSuperscript(tomToggle);
			pfont->Release();
			hr = S_OK;
			fUpdateFormat = FALSE;
		}
		break;
	}

	case 'A':
	{
		ITextFont *pfont;
		psel->GetFont(&pfont);
		if (pfont)
		{
			pfont->SetAllCaps(tomToggle);
			pfont->Release();
			hr = S_OK;
			fUpdateFormat = FALSE;
		}
		break;
	}

	case 'L':						// Cycle numbering style
	{
		CParaFormat PF;
		DWORD dwMask = PFM_NUMBERING | PFM_OFFSET;

		PF._wNumbering = psel->GetPF()->_wNumbering + 1;
		PF._wNumbering %= tomListNumberAsUCRoman + 1;
		PF._dxOffset = 0;
		if(PF._wNumbering)
		{
			dwMask |= PFM_NUMBERINGSTYLE | PFM_NUMBERINGSTART;
			PF._wNumberingStyle = PFNS_PERIOD;
			PF._wNumberingStart = 1;
			PF._dxOffset = 360;
		}
		hr = psel->SetParaFormat(&PF, publdr, dwMask, 0);
		break;
	}
#define VK_RANGLE	190
#define VK_LANGLE	188

	case VK_RANGLE:					// '>' on US keyboards
	case VK_LANGLE:					// '<' on US keyboards
		hr = OnSetFontSize(vkey == VK_RANGLE ? 1 : -1, 0, publdr)
		   ? S_OK : S_FALSE;
		fUpdateFormat = (hr == S_FALSE);
		break;
	}

	if(hr != S_FALSE)
	{
		if (fUpdateFormat)
			psel->Update_iFormat(-1);
		psel->Update(FALSE);
	}
	return hr;
}				

/*
 *	CTxtEdit::OnTxChar (vkey, dwFlags, publdr)
 *
 *	@mfunc
 *		Handle WM_CHAR message
 *
 *	@rdesc
 *		HRESULT with the following values:
 *
 *		S_OK				if key was understood and consumed
 *		S_MSG_KEY_IGNORED	if key was understood, but not consumed
 *		S_FALSE				if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxChar(
	DWORD		  vkey,		//@parm Translated key code
	DWORD		  dwFlags,	//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxChar");

	// Reset Alt key state if needed
	if (!(HIWORD(dwFlags) & KF_ALTDOWN))
		ResetKeyboardFlag(ALT);

	DWORD dwKbdFlags = GetKeyboardFlags();
	DWORD dwFlagsPutChar = _fOverstrike | KBD_CHAR;
	if(dwKbdFlags & ALTNUMPAD)
	{
		DWORD Number = GetKeyPadNumber();
		if(Number >= 256 || vkey >= 256)
			vkey = Number;
		ResetKeyboardFlag(ALTNUMPAD | ALT0);
		dwFlagsPutChar &= ~KBD_CHAR;		// Need font binding
	}

	if (_fMouseDown || vkey == VK_ESCAPE ||	// Ctrl-Backspace generates VK_F16
		vkey == VK_BACK || vkey==VK_F16)	// Eat it since we process it
	{										//  in WM_KEYDOWN
		return S_OK;
	}

	CTxtSelection * const psel = GetSel();
	AssertSz(psel,
		"CTxtEdit::OnChar() - No selection object !");

	if(_fReadOnly && vkey != 3)				// Don't allow input if read only,
	{										//  but allow copy (Ctrl-C)
		if(vkey >= ' ')
			Beep();
		return S_MSG_KEY_IGNORED;
	}

	if(vkey >= ' ' || vkey == VK_TAB)
	{
		TxSetCursor(0, NULL);
		if(IsntProtectedOrReadOnly(WM_CHAR, vkey, dwFlags))
		{
			LONG nDeadKey = GetDeadKey();
			if(nDeadKey)
			{
				DWORD ch	  = vkey | 0x20;		// Convert to lower case
				BOOL fShift	  = vkey != ch;			//  (if ASCII letter)
				//							   a   b	c	d	 e	 f  g  h    i	j
				const static WORD chOff[] = {0xDF, 0, 0xE7, 0, 0xE7, 0, 0, 0, 0xEB, 0,
				//						k  l  m    n     o   p  q  r  s  t    u
										0, 0, 0, 0xF1, 0xF1, 0, 0, 0, 0, 0, 0xF8};
				SetDeadKey(0);
				if(!IN_RANGE('a', ch, 'u'))			// Not relevant ASCII
					return S_OK;					//  letter
	
				vkey = chOff[ch - 'a'];				// Translate to base char
				if(!vkey)							// No accents available
					return S_OK;					//  in current approach

				if(ch == 'n')
				{
					if(nDeadKey != ACCENT_TILDE)
						return S_OK;
				}
				else if(nDeadKey == ACCENT_CEDILLA)
				{
					if(ch != 'c')
						return S_OK;
				}
				else								// aeiou
				{
					vkey += (WORD)nDeadKey;
					if (nDeadKey >= ACCENT_TILDE &&	// eiu with ~ or :
						(vkey == 0xF0 || vkey & 8))		
					{
						if(nDeadKey != ACCENT_UMLAUT)// Only have umlauts
							return S_OK;
						vkey--;
					}
				}
				if(fShift)							// Convert to upper case						
					vkey &= ~0x20;					
			}
			
			// If character is LRM | RLM character, then convert vkey
			if(W32->_fLRMorRLM && IsBiDi() && IN_RANGE(0xFD, vkey, 0xFE))
				vkey = LTRMARK + (vkey - 0xFD);				

			if(dwKbdFlags & CTRL)
				dwFlagsPutChar |= KBD_CTRL;		// Need for Ctrl+TAB in tables
			psel->PutChar(vkey, dwFlagsPutChar, publdr,
						  GetAdjustedTextLength() ? 0 : LOWORD(GetKeyboardLayout(0xFFFFFFFF)));
		}
	}
	else if(Get10Mode() && (vkey == VK_RETURN || vkey == CONTROL('J')))
		InsertEOP(dwFlags, FALSE, publdr);		// 1.0 handled <CR> on WM_CHAR

#ifndef NOCOMPLEXSCRIPTS	
	if(_fHbrCaps)
	{
		 W32->ActivateKeyboard(HEBREW_INDEX);
		 _fHbrCaps = FALSE;
	}
#endif
	return S_OK;
}

/*
 *	CTxtEdit::OnTxSysChar (vkey, dwFlags, publdr)
 *
 *	@mfunc
 *		Handle WM_SYSCHAR message
 *
 *	@rdesc
 *		HRESULT with the following values:
 *
 *		S_OK				if key was understood and consumed
 *		S_MSG_KEY_IGNORED	if key was understood, but not consumed
 *		S_FALSE				if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxSysChar(
	WORD		  vkey,		//@parm Translated key code
	DWORD		  dwFlags,	//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	if(!(HIWORD(dwFlags) & KF_ALTDOWN) ||
	   !IsntProtectedOrReadOnly(WM_KEYDOWN, vkey, dwFlags, FALSE))
	{
		return S_FALSE;
	}

	BOOL	fWholeDoc = TRUE;
	HRESULT hr = S_FALSE;
	int		level = 0;
	CTxtSelection * const psel = GetSel();

	switch(vkey)
	{
	case VK_BACK:
		return S_OK;

	case 'x':
		hr = psel->HexToUnicode(publdr);
		break;

	case 'X':
		hr = psel->UnicodeToHex(publdr);
		break;

	case '+':
	case '-':
		level = vkey == VK_ADD ? 1 : -1;
		fWholeDoc = FALSE;
		/* Fall through */
	case 'A':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		{
			CTxtRange rg(*psel);
			if(!level)
				level = vkey == 'A' ? 9 : vkey - '0';
			return rg.ExpandOutline(level, fWholeDoc);
		}
	}
	return hr;
}

HRESULT CTxtEdit::OnTxSysKeyDown(
	WORD		  vkey,				//@parm Virtual key code
	DWORD		  dwFlags,			//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)			//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxSysKeyDown");

        
	if(IN_RANGE(VK_SHIFT, vkey, VK_MENU))
	{
		SetKeyboardFlag(GetKbdFlags(vkey, dwFlags));
		SetKeyPadNumber(0);				// Init keypad number to 0
		return S_FALSE;
	}

	if (StopMagellanScroll())
	    return S_FALSE;

	HRESULT hr = OnTxSpecialKeyDown(vkey, dwFlags, publdr);
	if(hr != S_FALSE)
		return hr;

	if(vkey == VK_BACK && (HIWORD(dwFlags) & KF_ALTDOWN))
	{
		if(PopAndExecuteAntiEvent(_pundo, 0) != NOERROR)
			hr = S_MSG_KEY_IGNORED;
	}
	else if(vkey == VK_F10 &&					// F10
			!(HIWORD(dwFlags) & KF_REPEAT) &&	// Key previously up
			(GetKeyboardFlags() & SHIFT))		// Shift is down
	{
		HandleKbdContextMenu();
	}

	return hr;
}

/////////////////////////////// Other system events //////////////////////////////

HRESULT CTxtEdit::OnContextMenu(LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnContextMenu");

	POINT pt;

	pt.x = LOWORD(lparam);
	pt.y = HIWORD(lparam);

	if(TxScreenToClient(&pt))
		return OnTxRButtonUp(pt.x, pt.y, 0, RB_NOSELCHECK);

	return S_FALSE;
}

/*
 *	CTxtEdit::HandleKbdContextMenu ()
 *
 *	@mfunc	decides where to put the context menu on the basis of where the
 *			the selection is.  Useful for shift-F10 and VK_APPS, where
 *			we aren't given a location.
 */
void CTxtEdit::HandleKbdContextMenu()
{
	POINTUV pt;
	RECTUV	rc;
	const CTxtSelection * const psel = GetSel();
	int RbOption = RB_DEFAULT;

	// Figure out where selection ends and put context menu near it
	if(_pdp->PointFromTp(*psel, NULL, FALSE, pt, NULL, TA_TOP) < 0)
		return;

	// Due to various factors, the result of PointFromTp doesn't land
	// in the selection in PointInSel. Therefore, we send in an override
	// here if the selection is non-degenerate and to force the result
	// and thus have the correct context menu appear.

	LONG cpMin;
	LONG cpMost;
	psel->GetRange(cpMin, cpMost);

	if (cpMin != cpMost)
	{
		RbOption = RB_FORCEINSEL;
	}

	// Make sure point is still within bounds of edit control
	_pdp->GetViewRect(rc);
	
	 //REVIEW (keithcu) What is this +2/-2???
	if (pt.u < rc.left)
		pt.u = rc.left;
	if (pt.u > rc.right - 2)
		pt.u = rc.right - 2;
	if (pt.v < rc.top)
		pt.v = rc.top;
	if (pt.v > rc.bottom - 2)
		pt.v = rc.bottom - 2;

	POINT ptxy;
	_pdp->PointFromPointuv(ptxy, pt);

	OnTxRButtonUp(ptxy.x, ptxy.y, 0, RbOption);
}


/////////////////////////////// Format Range Commands //////////////////////////////

/*
 *	CTxtEdit::OnFormatRange (pfr, prtcon, hdcMeasure,
 *							 xMeasurePerInch, yMeasurePerInch)
 *	@mfunc
 *		Format the range given by pfr
 *
 *	@comm
 *		This function inputs API cp's that may differ from the
 *		corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnFormatRange(
	FORMATRANGE * pfr, 
	SPrintControl prtcon,
	BOOL		  fSetupDC)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnFormatRange");

	LONG cpMin  = 0;
	LONG cpMost = 0;

	if(pfr)
	{
		cpMin  = GetCpFromAcp(pfr->chrg.cpMin);
		cpMost = GetCpFromAcp(pfr->chrg.cpMost);
	}
	// Even if there is 0 text, we want to print the control so that it will
	// fill the control with background color.
	// Use Adjusted Text Length.  Embedded objects using RichEdit will get the empty
	// document they expect and will create a default size document.
	if(!pfr || cpMin >= GetAdjustedTextLength() &&
		!prtcon._fPrintFromDraw)
	{	// We're done formatting, get rid of our printer's display context.
		delete _pdpPrinter;
		_pdpPrinter = NULL;

		return GetAcpFromCp(GetAdjustedTextLength());
	}

	LONG cpReturn = -1;
	BOOL fSetDCWorked = FALSE;

	// Fix MFC Print preview in mirrored control
	//
	// MFC CPreviewView sends us a mirrored rendering DC. We need to disable
	// this mirroring effect so our internal state remains consistent with user
	// action. We also need to disable mirrored window mode in CPreviewView
	// window. [wchao - 4/9/1999]
	//
	HDC  hdcLocal = pfr->hdc;

#ifndef NOCOMPLEXSCRIPTS
	DWORD dwLayout = W32GetLayout(hdcLocal);

	if (dwLayout & LAYOUT_RTL)
	{
		HWND hwndView = WindowFromDC(hdcLocal);

		if (hwndView)
		{
			DWORD	dwExStyleView = GetWindowLong(hwndView, GWL_EXSTYLE);
			
			if (dwExStyleView & WS_EX_LAYOUTRTL)
				SetWindowLong(hwndView, GWL_EXSTYLE, dwExStyleView & ~WS_EX_LAYOUTRTL);
		}

		W32SetLayout(hdcLocal, 0);
	}
#endif

	// First time in with this printer, set up a new display context.
	// IMPORTANT: proper completion of the printing process is required
	// to dispose of this context and begin a new context.
	// This is implicitly done by printing the last character, or
	// sending an EM_FORMATRANGE message with pfr equal to NULL.
	if(!_pdpPrinter)	
	{
		_pdpPrinter = new CDisplayPrinter (this, hdcLocal, &pfr->rc, prtcon);
		_pdpPrinter->Init();

		_pdpPrinter->SetWordWrap(TRUE);
		// Future: (ricksa) This is a really yucky way to pass the draw info
		// to the printer but it was quick. We want to make this better.
		_pdpPrinter->ResetDrawInfo(_pdp);

		// Set temporary zoom factor (if there is one).
		_pdpPrinter->SetTempZoomDenominator(_pdp->GetTempZoomDenominator());
	}
	else
		_pdpPrinter->SetPrintDimensions(&pfr->rc);

	LONG dxpInch = 0, dypInch = 0;
	// We set the DC everytime because it could have changed.
	if(GetDeviceCaps(hdcLocal, TECHNOLOGY) != DT_METAFILE)
	{
		// This is not a metafile so do the normal thing
		fSetDCWorked = _pdpPrinter->SetDC(hdcLocal);
	}
	else
	{
		//Forms^3 draws using screen resolution, while OLE specifies HIMETRIC
		dxpInch = fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
		dypInch = fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

		if (!fSetupDC)
		{
			RECT rc;
			rc.left = MulDiv(pfr->rcPage.left, dxpInch, LX_PER_INCH);
			rc.right = MulDiv(pfr->rcPage.right, dxpInch, LX_PER_INCH);
			rc.top = MulDiv(pfr->rcPage.top, dypInch, LY_PER_INCH);
			rc.bottom = MulDiv(pfr->rcPage.bottom, dypInch, LY_PER_INCH);

			SetWindowOrgEx(hdcLocal, rc.left, rc.top, NULL);
			SetWindowExtEx(hdcLocal, rc.right, rc.bottom, NULL);
		}

		_pdpPrinter->SetMetafileDC(hdcLocal, dxpInch, dypInch);
		fSetDCWorked = TRUE;
	}

	if(fSetDCWorked)
	{
		//It is illogical to have the target device be the screen and the presentation
		//device be a HIMETRIC metafile.
		LONG dxpInchT = -1, dypInchT = -1;
		if (dxpInch && GetDeviceCaps(pfr->hdcTarget, TECHNOLOGY) == DT_RASDISPLAY)
		{
			dxpInchT = dxpInch;
			dypInchT = dypInch;
		}

        // We set this every time because it could have changed.
        if(_pdpPrinter->SetTargetDC(pfr->hdcTarget, dxpInchT, dypInchT))
		{
			// Format another, single page worth of text.
			cpReturn = _pdpPrinter->FormatRange(cpMin, cpMost, prtcon._fDoPrint);
			if(!prtcon._fPrintFromDraw)
			{
				// After formatting, we know where the bottom is. But we only 
				// want to set this if we are writing a page rather than
				// displaying a control on the printer.
				pfr->rc.bottom = pfr->rc.top + _pdpPrinter->DYtoLY(_pdpPrinter->GetHeight());
			}
//REVIEW (keithcu) What to do here?

			// Remember this in case the host wishes to do its own banding.
			_pdpPrinter->SetPrintView(pfr->rc);	// we need to save this for OnDisplayBand.
			_pdpPrinter->SetPrintPage(pfr->rcPage);

			// If we're asked to render, then render the entire page in one go.
			if(prtcon._fDoPrint && (cpReturn > 0 || prtcon._fPrintFromDraw))
			{
				OnDisplayBand(&pfr->rc, prtcon._fPrintFromDraw);

				// Note: we can no longer call OnDisplayBand without reformatting.
				_pdpPrinter->DeleteSubLayouts(0, -1);
				_pdpPrinter->Clear(AF_DELETEMEM);
			}
		}
	}

	return cpReturn > 0 ? GetAcpFromCp(cpReturn) : cpReturn;
}

BOOL CTxtEdit::OnDisplayBand(
	const RECT *prcView,
	BOOL		fPrintFromDraw)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDisplayBand");

	HDC		hdcPrinter;
	RECT	rcView, rcPrint;
	RECTUV	rcuvView, rcuvPrint;

	// Make sure OnFormatRange was called and that it actually rendered something.
	if(!_pdpPrinter || !_pdpPrinter->Count())
		return FALSE;

	// Proportionally map to printers extents.
	_pdpPrinter->LRtoDR(rcView, *prcView, _pdpPrinter->GetTflow());

	rcPrint	= _pdpPrinter->GetPrintView();
	_pdpPrinter->LRtoDR(rcPrint, rcPrint, _pdpPrinter->GetTflow());

	_pdpPrinter->RectuvFromRect(rcuvPrint, rcPrint);
	_pdpPrinter->RectuvFromRect(rcuvView, rcView);

	// Get printer DC because we use it below.
	hdcPrinter = _pdpPrinter->GetDC();

	if(fPrintFromDraw)
	{
		// We need to take view inset into account
		_pdpPrinter->GetViewRect(rcuvPrint, &rcuvPrint);
	}

	// Render this band (if there's something to render)
	if(rcuvView.top < rcuvView.bottom)
		_pdpPrinter->Render(rcuvPrint, rcuvView);

	return TRUE;
}

//////////////////////////////// Protected ranges //////////////////////////////////
/*
 *	CTxtEdit::IsProtected (msg, wparam, lparam)
 *
 *	@mfunc
 *		Find out if selection is protected
 *
 *	@rdesc
 *		TRUE iff 1) control is read-only or 2) selection is protected and
 *		parent query says to protect
 */
BOOL CTxtEdit::IsProtected(
	UINT	msg, 		//@parm	Message id
	WPARAM	wparam, 	//@parm WPARAM from window's message
	LPARAM	lparam)		//@parm LPARAM from window's message
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtected");
	
	CHECKPROTECT chkprot = CHKPROT_EITHER;
	CTxtSelection *psel = GetSel();

	if(!psel)
		return FALSE;

	// There are a few special cases to consider, namely backspacing
	// into a protected range, deleting into a protected range, and type
	// with overstrike into a protected range.
	if(msg == WM_KEYDOWN && (wparam == VK_BACK || wparam == VK_F16))
	{
		// Check for format behind selection, if we are trying to 
		// backspace an insertion point.
		chkprot = CHKPROT_BACKWARD;
	}
	else if(msg == WM_KEYDOWN && wparam == VK_DELETE || 
		_fOverstrike && msg == WM_CHAR)
	{
		chkprot = CHKPROT_FORWARD;
	}

	// HACK ALERT: we don't do fIsDBCS protection checking for EM_REPLACESEL,
	// EM_SETCHARFORMAT, or EM_SETPARAFORMAT.  Outlook uses these APIs
	// extensively and DBCS protection checking messes them up. N.B. the
	// following if statement assumes that IsProtected returns a tri-value.
	PROTECT iProt = psel->IsProtected(chkprot);
	if (iProt == PROTECTED_YES && msg != EM_REPLACESEL && 
		msg != EM_SETCHARFORMAT && msg != EM_SETPARAFORMAT ||
		iProt == PROTECTED_ASK && _dwEventMask & ENM_PROTECTED && 
		QueryUseProtection(psel, msg, wparam, lparam))
	{
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtEdit::IsntProtectedOrReadOnly (msg, wparam, lparam, BOOL)
 *
 *	@mfunc
 *		Find out if selection isn't protected or read only. If it is, 
 *		ring bell.  For msg = WM_COPY, only protection is checked.
 *
 *	@rdesc
 *		TRUE iff 1) control isn't read-only and 2) selection either isn't
 *		protected or parent query says not to protect
 *
 *	@devnote	This function is useful for UI operations (like typing).
 */
BOOL CTxtEdit::IsntProtectedOrReadOnly(
	UINT	msg,	//@parm Message
	WPARAM	wparam,	//@parm Corresponding wparam
	LPARAM	lparam,	//@parm Corresponding lparam
	BOOL	fBeep)	//@parm OK to beep
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtectedOrReadOnly");

	if (!IsProtected(msg, wparam, lparam) &&
		(msg == WM_COPY || !_fReadOnly))	// WM_COPY only cares about
	{										//  protection
		return TRUE;
	}
	if (fBeep)
		Beep();
	return FALSE;
}

/*
 *	CTxtEdit::IsProtectedRange (msg, wparam, lparam, prg)
 *
 *	@mfunc
 *		Find out if range prg is protected
 *
 *	@rdesc
 *		TRUE iff control is read-only or range is protected and parent
 *		query says to protect
 */
BOOL CTxtEdit::IsProtectedRange(
	UINT		msg, 		//@parm	Message id
	WPARAM		wparam, 	//@parm WPARAM from window's message
	LPARAM		lparam,		//@parm LPARAM from window's message
	CTxtRange *	prg)		//@parm Range to examine
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtectedRange");
	
	PROTECT iProt = prg->IsProtected(CHKPROT_EITHER);

	if (iProt == PROTECTED_YES ||
		(iProt == PROTECTED_ASK &&  
		 (_dwEventMask & ENM_PROTECTED) &&
		 QueryUseProtection(prg, msg, wparam, lparam)))
	// N.B.  the preceding if statement assumes that IsProtected returns a tri-value
	{
		return TRUE;
	}
	return FALSE;
}

/*
 *	RegisterTypeLibrary
 *
 *	@mfunc
 *		Auxiliary function to ensure the type library is registered if Idispatch is used.
 */
void RegisterTypeLibrary( void )
{
#ifndef NOREGISTERTYPELIB
	static BOOL fOnce = FALSE;

	if (!fOnce)
	{
		CLock Lock;

		fOnce =	TRUE;

		HRESULT  hRes = NOERROR;
		WCHAR    szModulePath[MAX_PATH];
		ITypeLib *pTypeLib = NULL;

		// Obtain the path to this module's executable file
		W32->GetModuleFileName( hinstRE, szModulePath, MAX_PATH );

		// Load and register the type library resource
		if (LoadRegTypeLib(LIBID_tom, 1, 0, LANG_NEUTRAL, &pTypeLib) != NOERROR)
		{
			hRes = W32->LoadTypeLibEx(szModulePath, REGKIND_REGISTER, &pTypeLib);
		}

		if(SUCCEEDED(hRes) && pTypeLib)
		{
			pTypeLib->Release();
		}
	}
#endif
}

/////////////////////////////// Private IUnknown //////////////////////////////

HRESULT __stdcall CTxtEdit::CUnknown::QueryInterface(
	REFIID riid, 
	void **ppvObj)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::QueryInterface");

	CTxtEdit *ped = (CTxtEdit *)GETPPARENT(this, CTxtEdit, _unk);
	*ppvObj = NULL;

	if(IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITextServices)) 
		*ppvObj = (ITextServices *)ped;

	else if(IsEqualIID(riid, IID_IDispatch))
	{
		*ppvObj = (IDispatch *)ped;
		RegisterTypeLibrary();
	}

	else if(IsEqualIID(riid, IID_ITextDocument))
	{
		*ppvObj = (ITextDocument *)ped;
		// No need to do this.  It was put in for Alpha thunking.
		// A better thing to do is to force clients who need this
		// to QI for IDispatch before QI for ITextDocument
		// RegisterTypeLibrary();
	}

	else if(IsEqualIID(riid, IID_ITextDocument2))
		*ppvObj = (ITextDocument2 *)ped;

	else if(IsEqualIID(riid, IID_IRichEditOle))
		*ppvObj = (IRichEditOle *)ped;

	else if(IsEqualIID(riid, IID_IRichEditOleCallback))
	{
		// NB!! Returning this pointer in our QI is 
		// phenomenally bogus; it breaks fundamental COM
		// identity rules (granted, not many understand them!).
		// Anyway, RichEdit 1.0 did this, so we better.
		TRACEWARNSZ("Returning IRichEditOleCallback interface, COM "
			"identity rules broken!");

		*ppvObj = ped->GetRECallback();
	}

	if(*ppvObj)
	{
		((IUnknown *) *ppvObj)->AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

ULONG __stdcall	CTxtEdit::CUnknown::AddRef()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::AddRef");

	return ++_cRefs;
}

ULONG __stdcall CTxtEdit::CUnknown::Release()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::Release");

	// the call manager will take care of deleting our instance if appropriate.
	CTxtEdit *ped = GETPPARENT(this, CTxtEdit, _unk);
	CCallMgr callmgr(ped);

	ULONG culRefs =	--_cRefs;

	if(culRefs == 0)
	{
		// Even though we don't delete ourselves now, dump the callback
		// if we have it.  This make implementation a bit easier on clients.

		if(ped->_pobjmgr)
			ped->_pobjmgr->SetRECallback(NULL);

		// Make sure our timers are gone
		ped->TxKillTimer(RETID_AUTOSCROLL);
		ped->TxKillTimer(RETID_DRAGDROP);
		ped->TxKillTimer(RETID_BGND_RECALC);
		ped->TxKillTimer(RETID_SMOOTHSCROLL);
		ped->TxKillTimer(RETID_MAGELLANTRACK);
	}
	return culRefs;
}

/*
 *  ValidateTextRange(pstrg)
 *
 *  @func
 *	  Makes sure that an input text range structure makes sense.
 *
 *  @rdesc
 *	  Size of the buffer required to accept copy of data or -1 if all the
 *	  data in the control is requested. 
 *
 *  @comm
 *	  This is used both in this file and in the RichEditANSIWndProc
 */
LONG ValidateTextRange(
	TEXTRANGE *pstrg)		//@parm pointer to a text range structure
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "ValidateTextRange");

	// Validate that the input structure makes sense. In the first
	// place it must be big enough. Secondly, the values must sense.
	// Remember that if the cpMost field is -1 and the cpMin field
	// is 0 this means that the call wants the entire buffer. 
	if (IsBadReadPtr(pstrg, sizeof(TEXTRANGE))	||
		((pstrg->chrg.cpMost < 1 || pstrg->chrg.cpMin < 0 ||
		  pstrg->chrg.cpMost <= pstrg->chrg.cpMin) &&
		 !(pstrg->chrg.cpMost == -1 && !pstrg->chrg.cpMin)))
	{
		// This isn't valid so tell the caller we didn't copy any data
		return 0;
	}
	// Calculate size of buffer that we need on return
	return pstrg->chrg.cpMost - pstrg->chrg.cpMin;
}


////////////////////////////////////  Selection  /////////////////////////////////////

CTxtSelection * CTxtEdit::GetSel()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSel");

	if(!_psel && _pdp)
	{
		// There is no selection object available so create it.
		_psel = new CTxtSelection(_pdp);
		if(_psel)
			_psel->AddRef();					// Set reference count = 1
	}

	// It is caller's responsiblity to notice that an error occurred
	// in allocation of selection object.
	return _psel;
}

void CTxtEdit::DiscardSelection()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::DiscardSelection");

	if(_psel)
	{
		_psel->Release();
		if(_psel)
		{
			// The text services reference is not the last reference to the 
			// selection. We could keep track of the fact that text services
			// has released its reference and when text services gets a 
			// reference again, do the AddRef there so that if the last 
			// reference went away while we were still inactive, the selection
			// object would go away. However, it is seriously doubtful that 
			// such a case will be very common. Therefore, just do the simplest
			// thing and put our reference back.
			_psel->AddRef();
		}
	}
}

void CTxtEdit::GetSelRangeForRender(
	LONG *pcpSelMin,
	LONG *pcpSelMost)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelRangeForRender");

	// If we have no selection or we are not active and the selection
	// has been requested to be hidden, there is no selection so we
	// just return 0's.
	if(!_psel || (!_fInPlaceActive && _fHideSelection))
	{
		*pcpSelMin = 0;
		*pcpSelMost = 0;
		return;
	}

	// Otherwise return the state of the current selection.
	*pcpSelMin  = _psel->GetScrSelMin();
	*pcpSelMost = _psel->GetScrSelMost();
}

LRESULT CTxtEdit::OnGetSelText(
	WCHAR *psz)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetSelText");

	LONG cpMin  = GetSelMin();					// length + 1 for the null
	LONG cpMost = GetSelMost();
	return GetTextRange(cpMin, cpMost - cpMin + 1, psz);
}

/*
 *	CTxtEdit::OnExGetSel (pcrSel)
 *
 *	@mfunc
 *		Get the current selection acpMin, acpMost packaged in a CHARRANGE.
 *	
 *	@comm
 *		This function outputs API cp's that may differ from the
 *		corresponding internal Unicode cp's.
 */
void CTxtEdit::OnExGetSel(
	CHARRANGE *pcrSel)	//@parm Output parm to receive acpMin, acpMost
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnExGetSel");

	pcrSel->cpMin  = GetAcpFromCp(GetSelMin());
	pcrSel->cpMost = GetAcpFromCp(GetSelMost());
}

/*
 *	CTxtEdit::OnGetSel (pacpMin, pacpMost)
 *
 *	@mfunc
 *		Get the current selection acpMin, acpMost.
 *	
 *	@rdesc
 *		LRESULT = acpMost > 65535L ? -1 : MAKELRESULT(acpMin, acpMost)
 *
 *	@comm
 *		This function outputs API cp's that may differ from the
 *		corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnGetSel(
	LONG *pacpMin,		//@parm Output parm to receive acpMin
	LONG *pacpMost)		//@parm Output parm to receive acpMost
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetSel");

	CHARRANGE crSel;

	OnExGetSel(&crSel);
	if(pacpMin)
		*pacpMin = crSel.cpMin;
	if(pacpMost)
		*pacpMost = crSel.cpMost;

	return (crSel.cpMost > 65535l)	? (LRESULT) -1
				: MAKELRESULT((WORD) crSel.cpMin, (WORD) crSel.cpMost);
}

/*
 *	CTxtEdit::OnSetSel (acpMin, acpMost)
 *
 *	@mfunc
 *		Implements the EM_SETSEL message
 *
 *	Algorithm:
 *		There are three basic cases to handle
 *
 *		cpMin < 0,  cpMost ???		-- Collapse selection to insertion point
 *									   at text end if cpMost < 0 and else at
 *									   selection active end
 *		cpMin >= 0, cpMost < 0		-- select from cpMin to text end with
 *									   active end at text end
 *
 *		cpMin >= 0, cpMost >= 0		-- Treat as cpMin, cpMost with active
 *									   end at cpMost
 *
 *	@comm
 *		This function inputs API cp's that may differ from the
 *		corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnSetSel(
	LONG acpMin,		//@parm Input acpMin
	LONG acpMost)		//@parm Input acpMost
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetSel");

	// Since this is only called from the window proc, we are always active
	Assert(GetSel());
	
	CTxtSelection * const psel = GetSel();
	LONG cpMin, cpMost;

	if(acpMin < 0)
		cpMin = cpMost = (acpMost < 0) ? tomForward : psel->GetCp();
	else
	{
		cpMin  = GetCpFromAcp(acpMin);
		cpMost = (acpMost < 0) ? tomForward : GetCpFromAcp(acpMost);
	}
	if(Get10Mode() && cpMost < cpMin)	// In 10 mode, ensure
	{									//  cpMost >= cpMin.  In
		cpMin ^= cpMost;				//  SetSelection, we set active
		cpMost ^= cpMin;				//  end to cpMost, which can be
		cpMin ^= cpMost;				//  smaller than cpMin, in spite
	}									//  of its name.
	psel->SetSelection(cpMin, cpMost);
	return GetAcpFromCp(psel->GetCpMost());
}

///////////////////////////////  DROP FILES support  //////////////////////////////////////
#ifndef NODROPFILES

LRESULT CTxtEdit::InsertFromFile (
	LPCTSTR lpFile)
{
	REOBJECT		reobj;
	LPRICHEDITOLECALLBACK const precall = GetRECallback();
	HRESULT			hr = NOERROR;

	if(!precall)
		return E_NOINTERFACE;

	ZeroMemory(&reobj, sizeof(REOBJECT));
	reobj.cbStruct = sizeof(REOBJECT);

	// Get storage for the object from client
	hr = precall->GetNewStorage(&reobj.pstg);
	if(hr)
	{
		TRACEERRORSZ("GetNewStorage() failed.");
		goto err;
	}

	// Create an object site for new object
	hr = GetClientSite(&reobj.polesite);
	if(!reobj.polesite)
	{
		TRACEERRORSZ("GetClientSite() failed.");
		goto err;
	}
	
	hr = OleCreateLinkToFile(lpFile, IID_IOleObject, OLERENDER_DRAW,
				NULL, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);	
	if(hr)
	{
		TRACEERRORSZ("Failure creating link object.");
		goto err;
	}

 	reobj.cp = REO_CP_SELECTION;
	reobj.dvaspect = DVASPECT_CONTENT;

 	//Get object clsid
	hr = reobj.poleobj->GetUserClassID(&reobj.clsid);
	if(hr)
	{
		TRACEERRORSZ("GetUserClassID() failed.");
		goto err;
	}

	// Let client know what we're up to
	hr = precall->QueryInsertObject(&reobj.clsid, reobj.pstg,
			REO_CP_SELECTION);
	if(hr != NOERROR)
	{
		TRACEERRORSZ("QueryInsertObject() failed.");
		goto err;
	}

	hr = reobj.poleobj->SetClientSite(reobj.polesite);
	if(hr)
	{
		TRACEERRORSZ("SetClientSite() failed.");
		goto err;
	}

	if(hr = InsertObject(&reobj))
	{
		TRACEERRORSZ("InsertObject() failed.");
	}

err:
	if(reobj.poleobj)
		reobj.poleobj->Release();

	if(reobj.polesite)
		reobj.polesite->Release();

	if(reobj.pstg)
		reobj.pstg->Release();

	return hr;
}

typedef void (WINAPI*DRAGFINISH)(HDROP);
typedef UINT (WINAPI*DRAGQUERYFILEA)(HDROP, UINT, LPSTR, UINT);
typedef UINT (WINAPI*DRAGQUERYFILEW)(HDROP, UINT, LPTSTR, UINT);
typedef BOOL (WINAPI*DRAGQUERYPOINT)(HDROP, LPPOINT);

LRESULT	CTxtEdit::OnDropFiles(
	HANDLE hDropFiles)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDropFiles");

	UINT	cFiles;
	UINT	iFile;
	char	szFile[MAX_PATH];
	WCHAR	wFile[MAX_PATH];
	POINT	ptDrop;
	CTxtSelection * const psel = GetSel();
	HMODULE		hDLL = NULL;
	DRAGFINISH		fnDragFinish; 
	DRAGQUERYFILEA	fnDragQueryFileA;
	DRAGQUERYFILEW	fnDragQueryFileW;
	DRAGQUERYPOINT	fnDragQueryPoint;

	if (_fReadOnly)
		return 0;

	AssertSz((hDropFiles != NULL), "CTxtEdit::OnDropFiles invalid hDropFiles");

	// dynamic load Shell32

	hDLL = LoadLibrary (TEXT("Shell32.DLL"));
	if(hDLL)
	{
		fnDragFinish = (DRAGFINISH)GetProcAddress (hDLL, "DragFinish");
		fnDragQueryFileA = (DRAGQUERYFILEA)GetProcAddress (hDLL, "DragQueryFileA");
		fnDragQueryFileW = (DRAGQUERYFILEW)GetProcAddress (hDLL, "DragQueryFileW");
		fnDragQueryPoint = (DRAGQUERYPOINT)GetProcAddress (hDLL, "DragQueryPoint");
	}
	else
		return 0;

	if(!fnDragFinish || !fnDragQueryFileA || !fnDragQueryFileW || !fnDragQueryPoint)
	{
		AssertSz(FALSE, "Shell32 GetProcAddress failed");
		goto EXIT0;
	}

	(*fnDragQueryPoint) ((HDROP)hDropFiles, &ptDrop);
	if(W32->OnWin9x())
		cFiles = (*fnDragQueryFileA) ((HDROP)hDropFiles, (UINT)-1, NULL, 0);
	else
		cFiles = (*fnDragQueryFileW) ((HDROP)hDropFiles, (UINT)-1, NULL, 0);

	if(cFiles)
	{
		LONG		cp = 0;
		ptDrop;
		CRchTxtPtr  rtp(this);
		const CCharFormat	*pCF;		
		POINTUV		pt;

		_pdp->PointuvFromPoint(pt, ptDrop);
		if(_pdp->CpFromPoint(pt, NULL, &rtp, NULL, FALSE) >= 0)
		{
			cp = rtp.GetCp();
			pCF = rtp.GetCF();
		}
		else
		{
			LONG iCF = psel->Get_iCF();
			cp = psel->GetCp();	
			pCF = GetCharFormat(iCF);
			ReleaseFormats(iCF, -1);
		}
		
		// Notify user for dropfile
		if(_dwEventMask & ENM_DROPFILES)
		{
			ENDROPFILES endropfiles;

			endropfiles.hDrop = hDropFiles;
			endropfiles.cp = Get10Mode() ? GetAcpFromCp(cp) : cp;
			endropfiles.fProtected = !!(pCF->_dwEffects & CFE_PROTECTED);

			if(TxNotify(EN_DROPFILES, &endropfiles))
				goto EXIT;					// Ignore drop file
			
			cp = Get10Mode() ? GetCpFromAcp(endropfiles.cp) : endropfiles.cp;	// Allow callback to update cp
		}
		psel->SetCp(cp, FALSE);	
	}

	for (iFile = 0;  iFile < cFiles; iFile++)
	{
		if(W32->OnWin9x())
		{
			(*fnDragQueryFileA) ((HDROP)hDropFiles, iFile, szFile, MAX_PATH);
			MultiByteToWideChar(CP_ACP, 0, szFile, -1, 
							wFile, MAX_PATH);
		}
		else
			(*fnDragQueryFileW) ((HDROP)hDropFiles, iFile, wFile, MAX_PATH);

		InsertFromFile (wFile);
	}

EXIT:
	(*fnDragFinish) ((HDROP)hDropFiles);

EXIT0:
	FreeLibrary (hDLL);
	return 0;
}

#else // NODROPFILES

LRESULT	CTxtEdit::OnDropFiles(HANDLE hDropFiles)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDropFiles");

	return 0;
}

#endif	// NODROPFILES


///////////////////////////////  Exposable methods  //////////////////////////////////////

/*
 *	CTxtEdit::TxCharFromPos (ppt, plres)
 *
 *	@mfunc
 *		Get the acp at the point *ppt.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (CpFromPoint succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function outputs an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
HRESULT	CTxtEdit::TxCharFromPos(
	LPPOINT	 ppt,	//@parm Point to find the acp for
	LRESULT *plres)	//@parm Output parm to receive the acp
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxCharFromPos");

	if(!fInplaceActive())
	{
		// We have no valid display rectangle if this object is not active
		*plres = -1;
		return OLE_E_INVALIDRECT;
	}
	POINTUV pt;
	_pdp->PointuvFromPoint(pt, *ppt);
	*plres = _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE);
	if(*plres == -1)
		return E_FAIL;

	*plres = GetAcpFromCp(*plres);
	return S_OK;
}

/*
 *	CTxtEdit::TxPosFromChar (acp, ppt)
 *
 *	@mfunc
 *		Get the point at acp.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (PointFromTp succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function inputs an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxPosFromChar(
	LONG	acp,		//@parm Input cp to get the point for
	POINT *	ppt)		//@parm Output parm to receive the point
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxPosFromChar");

	if(!fInplaceActive())
		return OLE_E_INVALIDRECT;

	CRchTxtPtr rtp(this, GetCpFromAcp(acp));

	POINTUV pt;
	if(_pdp->PointFromTp(rtp, NULL, FALSE, pt, NULL, TA_TOP) < 0)
		return E_FAIL;

	_pdp->PointFromPointuv(*ppt, pt);

	return S_OK;
}

/*
 *	CTxtEdit::TxFindWordBreak (nFunction, acp, plres)
 *
 *	@mfunc
 *		Find word break or classify character at acp.
 *	
 *	@rdesc
 *		HRESULT = plRet ? S_OK : E_INVALIDARG
 *
 *	@comm
 *		This function inputs and exports API cp's and cch's that may differ
 *		from the internal Unicode cp's and cch's.
 */
HRESULT CTxtEdit::TxFindWordBreak(
	INT		 nFunction,	//@parm Word break function
	LONG	 acp,		//@parm Input cp
	LRESULT *plres)		//@parm	cch moved to reach break
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxFindWordBreak");

	CTxtPtr tp(this, GetCpFromAcp(acp));		// This validates cp
	LONG	cpSave = tp.GetCp();				// Save starting value
	
	if(!plres)
		return E_INVALIDARG;
	
	*plres = tp.FindWordBreak(nFunction);

	// WB_CLASSIFY and WB_ISDELIMITER return values; others return offsets
	// this function returns values, so it converts when necessary
	if(nFunction != WB_CLASSIFY && nFunction != WB_ISDELIMITER)
		*plres = GetAcpFromCp(LONG(*plres + cpSave));

	return S_OK;
}

/*
 *	INT CTxtEdit::TxWordBreakProc (pch, ich, cb, action)
 *	
 *	@func
 *		Default word break proc used in conjunction with FindWordBreak. ich
 *		is character offset (start position) in the buffer pch, which is cb
 *		bytes in length.  Possible action values are:
 *
 *	WB_CLASSIFY
 *		Returns char class and word break flags of char at start position.
 *
 *	WB_ISDELIMITER
 *		Returns TRUE iff char at start position is a delimeter.
 *
 *	WB_LEFT
 *		Finds nearest word beginning before start position using word breaks.
 *
 *	WB_LEFTBREAK
 *		Finds nearest word end before start position using word breaks.
 *		Used by CMeasurer::Measure()
 *
 *	WB_MOVEWORDLEFT
 *		Finds nearest word beginning before start position using class
 *		differences. This value is used during CTRL+LEFT key processing.
 *
 *	WB_MOVEWORDRIGHT
 *		Finds nearest word beginning after start position using class
 *		differences. This value is used during CTRL+RIGHT key processing.
 *
 *	WB_RIGHT
 *		Finds nearest word beginning after start position using word breaks.
 *		Used by CMeasurer::Measure()
 *
 *	WB_RIGHTBREAK
 *		Finds nearest word end after start position using word breaks.
 *	
 *	@rdesc
 *		Character offset from start of buffer (pch) of the word break
 */
INT CTxtEdit::TxWordBreakProc(
	WCHAR *	pch,	    //@parm Char buffer
	INT		ich,	    //@parm Char offset of _cp in buffer
	INT		cb,		    //@parm Count of bytes in buffer
	INT		action,	    //@parm Type of breaking action
	LONG    cpStart,    //@parm cp for first character in pch
	LONG	cp)		    //@parm cp associated to ich
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxWordBreakProc");

	if (_pfnWB)
	{
		// Client overrode the wordbreak proc, delegate the call to it.		
		if (!Get10Mode())
		{
		    Assert(!_fExWordBreakProc);
			//8638: return number of characters, not bytes.
		    return _pfnWB(pch, ich, CchOfCb(cb), action);
		}
#ifndef NOANSIWINDOWS
		else
		{
            int ret = 0;
            char sz[256];
            char* pach = sz;
    		if (cb >= 255)
    		    pach = new char [cb + 1];

    		// this indicates if we have to adjust the pach because the api's for
		    // EDITWORDBREAKPROCEX and EDITWORDBREAKPROC are different when looking to the left
            BOOL fAdjustPtr = _fExWordBreakProc && (action == WB_LEFT || action == WB_MOVEWORDLEFT || action == WB_LEFTBREAK);

            // RichEdit 1.0, create a buffer, translate ich and WCTMB
    		// pch into the buffer.  Need codepage to use. Then get translate
    		// return value. Translations are like GetCachFromCch() and
    		// GetCchFromCach()
            if (_fExWordBreakProc)
            {
                Assert(ich == 0 || ich == 1 || ich == CchOfCb(cb));

                // We need to adjust the cp to the starting point of the buffer
                if (!fAdjustPtr)
                {
                    cpStart += ich;
                    pch += ich;
                    cb -= (2 * ich);                    
                }

                // initialize string w/ zero's so we can determine the length of the string for later
                memset(pach, 0, cb + 1);
            }
                
			int nLen = CchOfCb(cb);
    		CRchTxtPtr rtp(this, cpStart);
    		BYTE iCharRep = rtp.GetCF()->_iCharRep;
   	        if (WideCharToMultiByte(CodePageFromCharRep(iCharRep), 0, pch, nLen, pach, cb + 1, NULL, NULL))
       	    {
       	        // Documentation stipulates we need to point to the end of the string
       	        if (fAdjustPtr)
       	            pach += strlen(pach);

        	    if (_fExWordBreakProc)
	                ret = ((EDITWORDBREAKPROCEX)_pfnWB)(pach, nLen, CharSetFromCharRep(iCharRep), action);
	            else
				{
	                ret = ((EDITWORDBREAKPROCA)_pfnWB)(pach, rtp.GetCachFromCch(ich), nLen, action);

					// Need to reset cp position because GetCachFromCch may move the cp
					if (ich)
						rtp.SetCp(cpStart);
				}
	            
	            // For WB_ISDELIMITER and WB_CLASSIFY don't need to convert back
    	        // to ich because return value represents a BOOL
    	        if (action != WB_ISDELIMITER && action != WB_CLASSIFY)
    	            ret = rtp.GetCchFromCach(ret);
            }  		

    	    // Delete any allocated memory
    	    if (pach != sz)
    		    delete [] pach;
    		return ret;
		}
#endif // NOANSIWINDOWS
	}

	LONG	cchBuff = CchOfCb(cb);
	LONG	cch = cchBuff - ich;
	WCHAR	ch;
	WORD	cType3[MAX_CLASSIFY_CHARS];
	INT		kinsokuClassifications[MAX_CLASSIFY_CHARS];
	LCID	lcid = 0;
	WORD *	pcType3;
	INT  *	pKinsoku1, *pKinsoku2;
	WORD *	pwRes;
	WORD	startType3 = 0;
	WORD	wb = 0;
	WORD	wClassifyData[MAX_CLASSIFY_CHARS];	// For batch classifying

	Assert(cchBuff < MAX_CLASSIFY_CHARS);
	Assert(ich >= 0 && ich < cchBuff);

	if(W32->OnWin9x())						// Win9x needs lcid to do conversions
	{									 	// Complete fix would break pch into
    	CFormatRunPtr rpCF(_story.GetCFRuns());//  runs <--> lcid
		rpCF.BindToCp(cp, GetTextLength());
		lcid = GetCharFormat(rpCF.GetFormat())->_lcid;
	}
	// Single character actions
	if ( action == WB_CLASSIFY )
	{
	    // 1.0 COMPATABILITY - 1.0 returned 0 for apostrohpe's
	    WCHAR ch = pch[ich];
		if (Get10Mode() && ( ch ==  0x0027 /*APOSTROPHE*/ ||
	        ch == 0xFF07 /*FULLWIDTH APOSTROPHE*/))
	    {
	        return 0;	        
	    }
		return ClassifyChar(ch, lcid);
	}

	if ( action == WB_ISDELIMITER )
		return !!(ClassifyChar(pch[ich], lcid) & WBF_BREAKLINE);

	// Batch classify buffer for whitespace and kinsoku classes
	BatchClassify(pch, cchBuff, lcid, cType3, kinsokuClassifications, wClassifyData);

#ifndef NOCOMPLEXSCRIPTS
    if (_pbrk && cp > -1)
    {
		cp -= ich;

        for (LONG cbrk = cchBuff-1; cbrk >= 0; --cbrk)
        {
            if (cp + cbrk >= 0 && _pbrk->CanBreakCp(BRK_WORD, cp + cbrk))
            {
                // Mimic class open/close in Kinsoku classification.
                kinsokuClassifications[cbrk] = brkclsOpen;
                if (cbrk > 0)
				{
                    kinsokuClassifications[cbrk-1] = brkclsClose;
                    wClassifyData[cbrk-1] |= WBF_WORDBREAKAFTER;
				}
            }
        }
    }
#endif

	// Setup pointers
	pKinsoku2 = kinsokuClassifications + ich; 		// Ptr to current  kinsoku
	pKinsoku1 = pKinsoku2 - 1;						// Ptr to previous kinsoku

	if(!(action & 1))								// WB_(MOVE)LEFTxxx
	{
		ich--;
		Assert(ich >= 0);
	}
	pwRes	 = &wClassifyData[ich];
	pcType3	 = &cType3[ich];						// for ideographics

	switch(action)
	{
	case WB_LEFT:
		for(; ich >= 0 && *pwRes & WBF_BREAKLINE;	// Skip preceding line
			ich--, pwRes--)							//  break chars
				;									// Empty loop. Then fall
													//  thru to WB_LEFTBREAK
	case WB_LEFTBREAK:
		for(; ich >= 0 && !CanBreak(*pKinsoku1, *pKinsoku2);
			ich--, pwRes--, pKinsoku1--, pKinsoku2--)
				;									// Empty loop
		if(action == WB_LEFTBREAK)					// Skip preceding line
		{											//  break chars
			for(; ich >= 0 && *pwRes & WBF_BREAKLINE;
				ich--, pwRes--)
					;								// Empty loop
		}
		return ich + 1;

	case WB_MOVEWORDLEFT:
		for(; ich >= 0 && (*pwRes & WBF_CLASS) == 2;// Skip preceding blank
			ich--, pwRes--, pcType3--)				//  chars
				;
		if(ich >= 0)								// Save starting wRes and
		{											//  startType3
			wb = *pwRes--;							// Really type1
			startType3 = *pcType3--;				// type3
			ich--;
		}
		// Skip to beginning of current word
		while(ich >= 0 && (*pwRes & WBF_CLASS) != 3 && 
            !(*pwRes & WBF_WORDBREAKAFTER) &&
			(IsSameClass(*pwRes, wb, *pcType3, startType3) ||
			!wb && ich && ((ch = pch[ich]) == '\'' || ch == RQUOTE)))
		{
			ich--, pwRes--, pcType3--;
		}
		return ich + 1;


	case WB_RIGHTBREAK:
		for(; cch > 0 && *pwRes & WBF_BREAKLINE;	// Skip any leading line
			cch--, pwRes++)							//  break chars
				;									// Empty loop
													// Fall thru to WB_RIGHT
	case WB_RIGHT:
		// Skip to end of current word
		for(; cch > 0 && !CanBreak(*pKinsoku1, *pKinsoku2);
			cch--, pKinsoku1++, pKinsoku2++, pwRes++)
				;
		if(action != WB_RIGHTBREAK)					// Skip trailing line
		{											//  break chars
			for(; cch > 0 && *pwRes & WBF_BREAKLINE;
				cch--, pwRes++)
					;
		}
		return cchBuff - cch;

	case WB_MOVEWORDRIGHT:
		if(cch <= 0)								// Nothing to do
			return ich;

		wb = *pwRes;								// Save start wRes
		startType3 = *pcType3;						//  and startType3

		// Skip to end of word
		if (startType3 & C3_IDEOGRAPH ||			// If ideographic or
			(*pwRes & WBF_CLASS) == 3)				//  tab/cell, just
		{
			cch--, pwRes++;							//  skip one char
		}
		else while(cch > 0 && 
            !(*pwRes & WBF_WORDBREAKAFTER) &&
			(IsSameClass(*pwRes, wb, *pcType3, startType3) || !wb &&
			 ((ch = pch[cchBuff - cch]) == '\'' || ch == RQUOTE)))
		{
			cch--, pwRes++, pcType3++;
		}

		for(; cch > 0 && 
			((*pwRes & WBF_CLASS) == 2 				// Skip trailing blank
            || (*pwRes & WBF_WORDBREAKAFTER)); 		// Skip Thai break after
			cch--, pwRes++)							//  chars
					;
		return cchBuff - cch;
	}

	TRACEERRSZSC("CTxtEdit::TxWordBreakProc: unknown action", action);
	return ich;
}


/*
 *	CTxtEdit::TxFindText (flags, cpMin, cpMost, pch, pcpRet)
 *
 *	@mfunc
 *		Find text in direction specified by flags starting at cpMin if
 *		forward search (flags & FR_DOWN nonzero) and cpMost if backward
 *		search.
 *
 *	@rdesc
 *		HRESULT (success) ? NOERROR : S_FALSE
 *
 *	@comm
 *		Caller is responsible for setting cpMin to the appropriate end of
 *		the selection depending on which way the search is proceding.
 */
HRESULT CTxtEdit::TxFindText(
	DWORD		flags,	 //@parm Specify FR_DOWN, FR_MATCHCASE, FR_WHOLEWORD
	LONG		cpStart, //@parm Find start cp
	LONG		cpLimit, //@parm Find limit cp 
	const WCHAR*pch,	 //@parm Null terminated string to search for
	LONG *		pcpMin,	 //@parm Out parm to receive start of matched string
	LONG *		pcpMost) //@parm Out parm to receive end of matched string
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxFindText");

	if(Get10Mode())							// RichEdit 1.0 only searches
	{
		flags |= FR_DOWN;					//  forward
		if (cpLimit < -1)
		    cpLimit = -1;
	}

	DWORD		cchText = GetTextLength();
	LONG		cchToFind;
	const BOOL	fSetCur = (cchText >= 4096);
	HCURSOR		hcur = NULL;				// Init to keep compiler happy

	Assert(pcpMin && pcpMost);

	// Validate parameters
	if(!pch || !(cchToFind = wcslen(pch)) || cpStart < 0 || cpLimit < -1)
		return E_INVALIDARG;				// Nothing to search for

	CTxtPtr	tp(this, cpStart);	  
	
	if(fSetCur)								// In case this takes a while...
		hcur = TxSetCursor(LoadCursor(0, IDC_WAIT), NULL);
	
	*pcpMin  = tp.FindText(cpLimit, flags, pch, cchToFind);
	*pcpMost = tp.GetCp();

	if(fSetCur)
		TxSetCursor(hcur, NULL);
	
	return *pcpMin >= 0 ? NOERROR : S_FALSE;
}

/*
 *	CTxtEdit::TxGetLineCount (plres)
 *
 *	@mfunc
 *		Get the line count.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (WaitForRecalc succeeded) ? S_OK : E_FAIL
 */
HRESULT CTxtEdit::TxGetLineCount(
	LRESULT *plres)		//@parm Output parm to receive line count
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetLineCount");

	AssertSz(plres, "CTxtEdit::TxGetLineCount invalid pcli");

	if(!fInplaceActive())
		return OLE_E_INVALIDRECT;

	if(!_pdp->WaitForRecalc(GetTextLength(), -1))
		return E_FAIL;

	*plres = _pdp->LineCount();
	Assert(*plres > 0);

	return S_OK;
}

/*
 *	CTxtEdit::TxLineFromCp (acp, plres)
 *
 *	@mfunc
 *		Get the line containing acp.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (LineFromCp succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function inputs an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxLineFromCp(
	LONG	 acp,		//@parm Input cp
	LRESULT *plres)		//@parm Ouput parm to receive line number
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineFromCp");

	BOOL	fAtEnd = FALSE;
	LONG	cp = 0;

	AssertSz(plres, "CTxtEdit::TxLineFromCp invalid plres");

	if(!fInplaceActive())
	{
		AssertSz(*plres == 0, 
			"CTxtEdit::TxLineFromCp error return lres not correct");
		return OLE_E_INVALIDRECT;
	}

	if(acp < 0)									// Validate cp
	{
		if(_psel)
		{
			cp = _psel->GetCpMin();
			fAtEnd = !_psel->GetCch() && _psel->CaretNotAtBOL();
		}
	}
	else
	{
		LONG cchText = GetTextLength();
		cp = GetCpFromAcp(acp);
		cp = min(cp, cchText);
	}
 
	*plres = _pdp->LineFromCp(cp, fAtEnd);

	HRESULT hr = *plres < 0 ? E_FAIL : S_OK;

	// Old messages expect 0 as a result of this call if there is an error.
	if(*plres == -1)
		*plres = 0;

	return hr;
}

/*
 *	CTxtEdit::TxLineLength (acp, plres)
 *
 *	@mfunc
 *		Get the line containing acp.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (GetSel() succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function inputs an API cp and outputs an API cch that
 *		may differ from the	corresponding internal Unicode cp and cch.
 */
HRESULT CTxtEdit::TxLineLength(
	LONG	 acp,		//@parm Input cp
	LRESULT *plres)		//@parm Output parm to receive line length 
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineLength");

	LONG cch = 0;
	LONG cp;

	AssertSz(plres, "CTxtEdit::TxLineLength Invalid plres parameter");

	if(!fInplaceActive())
		return OLE_E_INVALIDRECT;

	if(acp < 0)
	{
		if(!_psel)
			return E_FAIL;
		cch = _psel->LineLength(&cp);
	}
	else
	{
		cp = GetCpFromAcp(acp);
		if(cp <= GetAdjustedTextLength())
		{
			CLinePtr rp(_pdp);
			rp.SetCp(cp, FALSE);
			cp -= rp.GetIch();				// Goto start of line
			cch = rp.GetAdjustedLineLength();
		}
	}
	if(fCpMap())							// Can be time consuming, so
	{										//  don't do it unless asked
		CRchTxtPtr rtp(this, cp);			//  for
		cch = rtp.GetCachFromCch(cch);
	}
	*plres = cch;
	return S_OK;
}

/*
 *	CTxtEdit::TxLineIndex (acp, plres)
 *
 *	@mfunc
 *		Get the line containing acp.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (LineCount() && WaitForRecalcIli succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function outputs an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxLineIndex(
	LONG	 ili,		//@parm Line # to find acp for
	LRESULT *plres)		//@parm Output parm to receive acp
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineIndex");

	HRESULT hr;
	AssertSz(plres, "CTxtEdit::TxLineIndex invalid plres");

	*plres = -1;
	if(!fInplaceActive())
		return OLE_E_INVALIDRECT;

	if(ili == -1)
	{
		// Fetch line from the current cp.
		LRESULT lres;					// For 64-bit compatibility
		hr = TxLineFromCp(-1, &lres);
		if(hr != NOERROR)
			return hr;
		ili = (LONG)lres;
	}

	// ili is a zero-based *index*, whereas count returns the total # of lines.
	// Therefore, we use >= for our comparisions.
	if(ili >= _pdp->LineCount() && !_pdp->WaitForRecalcIli(ili))
		return E_FAIL; 

	*plres = GetAcpFromCp(_pdp->CpFromLine(ili, NULL));
	
	return S_OK;
}


///////////////////////////////////  Miscellaneous messages  ////////////////////////////////////

/*
 *	CTxtEdit::OnFindText (msg, flags, pftex)
 *
 *	@mfunc
 *		Find text.
 *	
 *	@rdesc
 *		LRESULT = succeeded ? acpmin : -1
 *
 *	@comm
 *		This function inputs and exports API cp's that may differ
 *		from the internal Unicode cp's.
 */
LRESULT CTxtEdit::OnFindText(
	UINT		msg,
	DWORD		flags,
	FINDTEXTEX *pftex)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnFindText");

	LONG cpMin, cpMost;

	if(TxFindText(flags,
				  GetCpFromAcp(pftex->chrg.cpMin),
				  GetCpFromAcp(pftex->chrg.cpMost),
				  pftex->lpstrText, &cpMin, &cpMost) != S_OK)
	{
		if(msg == EM_FINDTEXTEX || msg == EM_FINDTEXTEXW)
		{
			pftex->chrgText.cpMin  = -1;
			pftex->chrgText.cpMost = -1;
		}
		return -1;
	}

	LONG acpMin  = GetAcpFromCp(cpMin);
	if(msg == EM_FINDTEXTEX || msg == EM_FINDTEXTEXW)	// We send a message
	{													//  back to change
		pftex->chrgText.cpMin  = acpMin;				//  selection to this
		pftex->chrgText.cpMost = GetAcpFromCp(cpMost);
	}
	return (LRESULT)acpMin;
}

	
// For plain-text instances, OnGetParaFormat() and OnSetParaFormat() apply to whole story
LRESULT CTxtEdit::OnGetCharFormat(
	CHARFORMAT2 *pCF2,
	DWORD		 dwFlags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetCharFormat");

	UINT cb = pCF2->cbSize;
	UINT CodePage = 1200;

	if(!IsValidCharFormatW(pCF2))
	{
		if(!IsValidCharFormatA((CHARFORMATA *)pCF2))
			return 0;
		CodePage = GetDefaultCodePage(EM_GETCHARFORMAT);
	}

	if(dwFlags & (SCF_ASSOCIATEFONT | SCF_ASSOCIATEFONT2))
		return OnGetAssociateFont(pCF2, dwFlags);

	if(cb == sizeof(CHARFORMATW) ||	cb == sizeof(CHARFORMATA))
		dwFlags |= CFM2_CHARFORMAT;				// Tell callees that only
												//  CHARFORMAT parms needed
	CCharFormat CF;
	DWORD dwMask = CFM_ALL2;

	if(dwFlags & SCF_SELECTION)
		dwMask = GetSel()->GetCharFormat(&CF, dwFlags);
	else
		CF = *GetCharFormat(-1);

	if(dwFlags & CFM2_CHARFORMAT)				// Maintain CHARFORMAT
	{											//  compatibility
		CF._dwEffects &= CFM_EFFECTS;
		dwMask		  &= CFM_ALL;
	}

	CF.Get(pCF2, CodePage);
	pCF2->dwMask = dwMask;
	return (LRESULT)dwMask;
}

LRESULT CTxtEdit::OnGetParaFormat(
	PARAFORMAT2 *pPF2,
	DWORD		 dwFlags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetParaFormat");

	if(!IsValidParaFormat(pPF2))
		return 0;

	DWORD dwMask2 = 0;
	if(pPF2->cbSize == sizeof(PARAFORMAT))	// Tell callees that only
		dwMask2 = PFM2_PARAFORMAT;			//  PARAFORMAT parms needed

	CParaFormat PF;
	DWORD		dwMask = GetSel()->GetParaFormat(&PF, dwMask2);

	if(dwMask2 & PFM2_PARAFORMAT)
		dwMask &= PFM_ALL;

	PF.Get(pPF2);
	pPF2->dwMask = dwMask;
	return (LRESULT)dwMask;
}

/*
 *	CTxtEdit::OnSetFontSize(yPoint, publdr)
 *
 *	@mfunc
 *		Set new font height by adding yPoint to current height  
 *		and rounding according to the table in cfpf.cpp
 *
 *	@rdesc
 *		LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetFontSize(
	LONG yPoint,			//@parm # pts to add to current height
	DWORD dwFlags,			//@parm Options
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{	
	// TODO: ? Return nonzero if we set a new font size for some text.

	CCharFormat CF;
	CF._yHeight = (SHORT)yPoint;

	return OnSetCharFormat(dwFlags ? dwFlags : SCF_SELECTION, &CF, publdr,
						   CFM_SIZE, CFM2_CHARFORMAT | CFM2_USABLEFONT);
}

/*
 *	CTxtEdit::OnSetFont(hfont)
 *
 *	@mfunc
 *		Set new default font from hfont
 *
 *	@rdesc
 *		LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetFont(
	HFONT hfont)			//@parm Handle of font to use for default
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetFont");

	CCharFormat	CF;
	if(FAILED(CF.InitDefault(hfont)))
		return 0;

	DWORD dwMask2 = CFM2_CHARFORMAT;
	WPARAM wparam = SCF_ALL;

	if(!GetAdjustedTextLength())
	{
		dwMask2 = CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK;
		wparam = 0;
	}

	return !FAILED(OnSetCharFormat(wparam, &CF, NULL, CFM_ALL, dwMask2));
}

/*
 *	CTxtEdit::OnSetCharFormat(wparam, pCF, publdr, dwMask, dwMask2)
 *
 *	@mfunc
 *		Set new default CCharFormat
 *
 *	@rdesc
 *		LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetCharFormat(
	WPARAM		  wparam,	//@parm Selection flag
	CCharFormat * pCF,		//@parm CCharFormat to apply
	IUndoBuilder *publdr,	//@parm Undobuilder to receive antievents
	DWORD		  dwMask,	//@parm CHARFORMAT2 mask
	DWORD		  dwMask2)	//@parm Second mask
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetCharFormat");

	// This says that if there's a selection that's protected and the
	// parent window wants protection notifications and doesn't want
	// changes with a protected selection, then return 0.  This is more
	// stringent than RE 2.0, but it's more like 1.0.
	if (_psel && _psel->IsProtected(CHKPROT_EITHER) == PROTECTED_ASK &&
		_dwEventMask & ENM_PROTECTED)
	{
		CHARFORMAT CF0;					// Selection is protected, client
										//  wants protect notifications
		CF0.cbSize = sizeof(CHARFORMAT);//  and protected mask is on
		CF0.dwEffects = pCF->_dwEffects;// Concoct CHARFORMAT for query
		CF0.dwMask = dwMask;			// Maybe need more fields...			
		if(QueryUseProtection(_psel, EM_SETCHARFORMAT, wparam, (LPARAM)&CF0))
			return 0;					// No deal
	}

	BOOL fRet = TRUE;

	AssertSz(!_fSelChangeCharFormat || IsRich(),
		"Inconsistent _fSelChangeCharFormat flag");

	if ((wparam & SCF_ALL) ||
		!_fSelChangeCharFormat && _story.GetCFRuns() && !(wparam & SCF_SELECTION))
	{	
		CTxtRange rg(this, 0, -GetTextLength());

		if(publdr)
			publdr->StopGroupTyping();

		if ((dwMask & (CFM_CHARSET | CFM_FACE)) == (CFM_CHARSET | CFM_FACE))
		{
			if(GetAdjustedTextLength())
			{
				dwMask2 |= CFM2_MATCHFONT;
				if (_fAutoFontSizeAdjust)
				{
					dwMask2 |= CFM2_ADJUSTFONTSIZE;
					if (fUseUIFont())
						dwMask2 |= CFM2_UIFONT;
				}
			}
			else
				dwMask2 |= CFM2_NOCHARSETCHECK;
		}

		fRet = (rg.SetCharFormat(pCF, 0, publdr, dwMask, dwMask2) == NOERROR);

		// If we have an insertion point, apply format to it as well
		if (_psel && !_psel->GetCch() &&
			_psel->SetCharFormat(pCF, wparam, publdr, dwMask, dwMask2) != NOERROR)
		{
			fRet = FALSE;
		}
	}
	else if(wparam & SCF_SELECTION)
	{
		// Change selection character format unless protected
		if(!_psel || !IsRich())
			return 0;

		return _psel->SetCharFormat(pCF, wparam, publdr, dwMask, dwMask2) 
				== NOERROR;
	}

	// Change default character format
	CCharFormat		   CF;					// Local CF to party on
	LONG			   iCF;					// Possible new CF index
	const CCharFormat *pCF1;				// Ptr to current default CF
	ICharFormatCache  *pICFCache = GetCharFormatCache();

	if(FAILED(pICFCache->Deref(Get_iCF(), &pCF1)))	// Get ptr to current
	{										//  default CCharFormat
		fRet = FALSE;						
		goto Update;
	}
	CF = *pCF1;								// Copy current default CF
	CF.Apply(pCF, dwMask, dwMask2);			// Modify copy
	if(FAILED(pICFCache->Cache(&CF, &iCF)))	// Cache modified copy
	{
		fRet = FALSE;
		goto Update;
	}

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(NULL);
#endif

	pICFCache->Release(Get_iCF());			// Release _iCF regardless
	Set_iCF(iCF);							//  of whether _iCF = iCF,
											//  i.e., only 1 ref count
	if(_psel && !_psel->GetCch() && _psel->Get_iFormat() == -1)
		_psel->UpdateCaret(FALSE);

	if ((dwMask & (CFM_CHARSET | CFM_FACE)) == CFM_FACE &&
		!GetFontName(pCF->_iFont)[0] && GetFontName(CF._iFont)[0] &&
		IsBiDiCharRep(CF._iCharRep))
	{
		// Client requested font/charset be chosen for it according to thread
		// locale. If BiDi, then also set RTL para default
		CParaFormat PF;
		PF._wEffects = PFE_RTLPARA;
		OnSetParaFormat(SPF_SETDEFAULT, &PF, publdr, PFM_RTLPARA, PFM2_PARAFORMAT);
	}

Update:
	// FUTURE (alexgo): this may be unnecessary if the display handles
	// updating more automatically.
	_pdp->UpdateView();
	return fRet;
}

/*
 *	CTxtEdit::OnSetParaFormat(wparam, pPF, publdr, dwMask, dwMask2)
 *
 *	@mfunc
 *		Set new default CParaFormat
 *
 *	@rdesc
 *		LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetParaFormat(
	WPARAM		 wparam,	//@parm wparam passed thru to IsProtected()
	CParaFormat *pPF,		//@parm CParaFormat to use
	IUndoBuilder *publdr,	//@parm Undobuilder to receive antievents
	DWORD		  dwMask,	//@parm CHARFORMAT2 mask
	DWORD		  dwMask2)	//@parm Second mask
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetParaFormat");

	// If we're using context direction in the control, then we disallow
	// the paragraph direction property and the alignment property (unless
	// it's for center alignment).
	if(IsStrongContext(_nContextDir) || IsStrongContext(_nContextAlign))
	{
		Assert(!IsRich());
		if(dwMask & (PFM_RTLPARA | PFM_ALIGNMENT))
		{
			if (IsStrongContext(_nContextAlign) &&
				(pPF->_bAlignment == PFA_LEFT || pPF->_bAlignment == PFA_RIGHT))
			{
				dwMask &= ~PFM_ALIGNMENT;
			}
			if(IsStrongContext(_nContextDir))
				dwMask &= ~PFM_RTLPARA;
		}
	}
	BOOL fMatchKbdToPara = FALSE;

	if(dwMask & PFM_RTLPARA)
	{
		// In plain text allow DIR changes to change DIR and ALIGNMENT
		if(!IsRich())
		{
			// Clear all para masks, except for DIR and ALIGN
			dwMask &= (PFM_RTLPARA | PFM_ALIGNMENT);
			wparam |= SPF_SETDEFAULT;
		}
		if(_psel && _fFocus)
			fMatchKbdToPara = TRUE;
	}
	if(!(wparam & SPF_SETDEFAULT))	
	{
		// If DEFAULT flag is specified, don't change selection
		if(!_psel || IsProtected(EM_SETPARAFORMAT, wparam, (LPARAM)pPF))
			return 0;

		LRESULT lres = NOERROR == (pPF->fSetStyle(dwMask, dwMask2)
			 ? _psel->SetParaStyle(pPF, publdr, dwMask)
			 : _psel->SetParaFormat(pPF, publdr, dwMask, dwMask2));

		// This is a bit funky, but basically, if the text is empty
		// then we also need to set the default paragraph format
		// (done in the code below).  Thus, if we hit a failure or
		// if the document is not empty, go ahead and return.  
		// Otherwise, fall through to the default case.
		if(!lres || GetAdjustedTextLength())
		{
			if(fMatchKbdToPara)
				_psel->MatchKeyboardToPara();
			return lres;
		}
	}

	// No text in document or (wparam & SPF_SETDEFAULT): set default format

	LONG			   iPF;						// Possible new PF index
	CParaFormat		   PF = *GetParaFormat(-1);	// Local PF to party on
	IParaFormatCache  *pPFCache = GetParaFormatCache();

	PF.Apply(pPF, dwMask, dwMask2);				// Modify copy
	if(FAILED(pPFCache->Cache(&PF, &iPF)))		// Cache modified copy
		return 0;
	pPFCache->Release(Get_iPF());				// Release _iPF regardless of
	Set_iPF(iPF);								// Update default format index

	if(PF.IsRtlPara())		
		OrCharFlags(FRTL, publdr);				// BiDi in backing store

	if(!IsRich() && dwMask & PFM_RTLPARA)		// Changing plain-text default PF
	{
		ItemizeDoc(publdr);						// causing re-itemize the whole doc.

		// (#6503) We cant undo the -1 format change in plaintext and that causes
		// many problems when we undo ReplaceRange event happening before the paragraph
		// switches. We better abandon the whole stack for now. (wchao)
		// -FUTURE- We should create an antievent for -1 PF change.
		ClearUndo(publdr);						
	}
	_pdp->UpdateView();
	if (_psel)
		_psel->UpdateCaret(!Get10Mode() || _psel->IsCaretInView());
	if(fMatchKbdToPara)
		_psel->MatchKeyboardToPara();
	return TRUE;
}


////////////////////////////////  System notifications  ////////////////////////////////

LRESULT CTxtEdit::OnSetFocus()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetFocus");

	_fFocus = TRUE;
	
	// Update our idea of the current keyboard layout
	W32->RefreshKeyboardLayout();

	InitKeyboardFlags();

	if(!_psel)
		return 0;

	// _fMouseDown may sometimes be true.
	// This can happen when somebody steals our focus when we were doing
	// something with the mouse down--like processing a click. Thus, we'll
	// never get the MouseUpMessage.
	if(_fMouseDown)
	{
		TRACEWARNSZ("Getting the focus, yet we think the mouse is down");
	}
	_fMouseDown = FALSE;

	BOOL fAutoKeyboard = _fAutoKeyboard;	// Don't change keyboard on SetFocus
	_fAutoKeyboard = FALSE;

	// BUG FIX #5369
	// Special case where we don't have a selection (or a caret). We need
	// to display something on focus so display a caret
	_psel->UpdateCaret(_fScrollCaretOnFocus, _psel->GetCch() == 0);
	_fScrollCaretOnFocus = FALSE;

	_psel->ShowSelection(TRUE);

	// If there is an in-place active object, we need to set the focus to
	// it. (In addition to the work that we do; this maintains compatibility
	// with RichEdit 1.0).
	if(_pobjmgr)
	{
		COleObject *pobj = _pobjmgr->GetInPlaceActiveObject();
		if(pobj)
		{
			IOleInPlaceObject *pipobj;
			
			if(pobj->GetIUnknown()->QueryInterface(IID_IOleInPlaceObject, 
					(void **)&pipobj) == NOERROR)
			{
				HWND hwnd;
				pipobj->GetWindow(&hwnd);

				if(hwnd)
					SetFocus(hwnd);
				pipobj->Release();
			}
		}
	}

	if(IsInPageView())
		TxInvalidate();
	TxNotify(EN_SETFOCUS, NULL);
	_fAutoKeyboard = fAutoKeyboard;			// Restore setting
	return 0;
}

LRESULT CTxtEdit::OnKillFocus()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnKillFocus");

    StopMagellanScroll();
    
	if(_pundo)
		_pundo->StopGroupTyping();

	if(_psel)
	{
		// Scroll back to beginning if necessary
		if (_fScrollCPOnKillFocus)
		{
			bool fHideSelectionLocal = _fHideSelection;

			// cannot hide Selection so cp=0 will be scroll into view.
			_fHideSelection = 0;	
			OnSetSel(0, 0);
			_fHideSelection = fHideSelectionLocal;
		}

		_psel->DeleteCaretBitmap(TRUE);	// Delete caret bitmap if one exists
		if(_fHideSelection)
			_psel->ShowSelection(FALSE);
	}

	_fFocus = FALSE;
	DestroyCaret();
	TxNotify(EN_KILLFOCUS, NULL);

	_fScrollCaretOnFocus = FALSE;		// Just to be safe, clear this
	return 0;
}


#if defined(DEBUG) && !defined(NOFULLDEBUG)
void CTxtEdit::OnDumpPed()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDumpPed");

	char sz[256];
	CTxtSelection * const psel = GetSel();
	SELCHANGE selchg;
	CHARRANGE crg = {0, 0};

	psel->SetSelectionInfo(&selchg);

	LONG cPage = 0;
	LONG nPage = 0;
	if(_pdp->IsMultiLine() && IsInPageView())
	{
		LONG cPageMoved;
		CTxtRange rg(this, 0, 0);

		_pdp->GetPage(&nPage, 0, &crg);
		rg.Set(crg.cpMin, 0);
		rg.Expand(tomPage, NULL);
		Assert(rg.GetCpMost() == crg.cpMost);
		rg.Set(0, 0);
		rg.Move(tomPage, tomForward, &cPageMoved);
		rg.GetIndex(tomPage, &cPage);
		Assert(cPageMoved == cPage ||
			rg.GetCp() == GetAdjustedTextLength() && cPageMoved == cPage - 1);
	}

	wsprintfA(sz,
		"cchText = %ld		cchTextMost = %ld\r\n"
		"cpSelActive = %ld		cchSel = %ld\r\n"
		"wSelType = %x		# lines = %ld\r\n"
		"SysDefLCID = %lx		UserDefLCID = %lx\r\n"
		"Page = %ld			cPage = %ld\r\n"
		"cpMinPage = %ld		cpMostPage = %ld",
		GetTextLength(),	TxGetMaxLength(),
		psel->GetCp(),	psel->GetCch(),
		selchg.seltyp,	_pdp->LineCount(),
		GetSystemDefaultLCID(), GetUserDefaultLCID(),
		nPage, cPage, crg.cpMin, crg.cpMost
	);
	Tracef(TRCSEVINFO, "%s", sz);
	MessageBoxA(0, sz, "ED", MB_OK);
}
#endif					// DEBUG


///////////////////////////// Scrolling Commands //////////////////////////////////////


HRESULT CTxtEdit::TxLineScroll(
	LONG cli,
	LONG cch)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineScroll");

	// Currently cch does nothing in the following call, so we ignore
	// its translation from cach to cch (need to instantiate an rtp
	// for the current line
	_pdp->LineScroll(cli, cch);
	return S_OK;
}

void CTxtEdit::OnScrollCaret()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnScrollCaret");

	if(_psel)
	{
		_psel->SetForceScrollCaret(TRUE);
        _psel->UpdateCaret(TRUE);
		_psel->SetForceScrollCaret(FALSE);
	}
}


///////////////////////////////// Editing messages /////////////////////////////////

void CTxtEdit::OnClear(
	IUndoBuilder *publdr)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnClear");

	if(!_psel || TxGetReadOnly())
	{
		Beep();
		return;
	}
	
	if(_psel->GetCch() && !IsProtected(WM_CLEAR, 0, 0))
	{
		_psel->StopGroupTyping();
		_psel->ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);
	}
}

void CTxtEdit::Beep()
{
	if(_fAllowBeep)
		MessageBeep(0);
}


///////////////////////////////////  Miscellaneous  ///////////////////////////////////////////

/*
 *	CTxtEdit::ItemizeDoc(publdr, cchRange)
 *
 *	@mfunc
 *		Helper routine to itemize the cchRange size of document content
 *		called by various clients outside CTxtRange.
 */
void CTxtEdit::ItemizeDoc(
	IUndoBuilder *	publdr,
	LONG			cchRange)
{
	// If cchRange = -1, itemize the whole doc
	if (cchRange == -1)
		cchRange = GetTextLength();

	// We wouldnt itemize if the doc only contains a single EOP
	// because we dont want Check_rpPF being called when the -1
	// PF format hasnt been properly established.
	// This is kind of hack, should be removed in the future.
	//

	if(cchRange && GetAdjustedTextLength())
	{										// Only itemize if more than
		CTxtRange rg(this, 0, -cchRange);	//  final EOP
		rg.ItemizeRuns(publdr);
	}

#if 0
	// =FUTURE=
	//		Once we open SPF_SETDEFAULT to public. We shall incorporate this code.
	// Basically, one can change the default paragraph reading order at runtime. All
	// PF runs referencing to -1 PF format then need to be reassigned a new paragraph
	// level value and reitemized.(6-10-99, wchao)
	//
    if(cchRange > 0)
    {
        CTxtRange rg(this, 0, -cchRange);

		// -1 PF format may have changed.
		// We shall make sure that the level of each PF run match the reading order
		// before start itemization.
		//
		if (rg.Check_rpPF())
		{
			LONG	cchLeft = cchRange;
			LONG	cchMove = 0;
			LONG	cch;

			while (cchLeft > 0)
			{
				rg._rpPF.GetRun(0)->_level._value = rg.IsParaRTL() ? 1 : 0;

				cch = rg._rpPF.GetCchLeft();

				if (!rg._rpPF.NextRun())
					break;		// no more run

				cchMove += cch;
				cchLeft -= cch;
			}

			Assert (cchMove + cchLeft == cchRange);

			rg._rpPF.Move(-cchMove);	// fly back to cp = 0
		}

		// Now we rerun itemization
        rg.ItemizeRuns(publdr);
    }
#endif
}

/*
 *  CTxtEdit::OrCharFlags(dwFlags, publdr)
 *
 *	@mfunc
 *		Or in new char flags and activate LineServices and Uniscribe
 *		if complex script chars occur.
 */
void CTxtEdit::OrCharFlags(
    QWORD qwFlags,
    IUndoBuilder* publdr)
{
#ifndef NOCOMPLEXSCRIPTS
	// REVIEW: Should we send a notification for LS turn on?
	// Convert dwFlags to new on flags
	qwFlags &= qwFlags ^ _qwCharFlags;
	if(qwFlags)
	{
		_qwCharFlags |= qwFlags;			// Update flags

		qwFlags &= FCOMPLEX_SCRIPT;

		if(qwFlags && (_qwCharFlags & FCOMPLEX_SCRIPT) == qwFlags)
		{
			// REVIEW: Need to check if Uniscribe and LineServices are available...
			OnSetTypographyOptions(TO_ADVANCEDTYPOGRAPHY, TO_ADVANCEDTYPOGRAPHY);
			ItemizeDoc();
            // FUTURE: (#6838) We cant undo operations before the first itemization.
            ClearUndo(publdr);
			_fAutoKeyboard = IsBiDi();
		}

		UINT brk = 0;

		if (qwFlags & FNEEDWORDBREAK)
			brk += BRK_WORD;

		if (qwFlags & FNEEDCHARBREAK)
			brk += BRK_CLUSTER;

		if (brk)
		{
			CUniscribe* pusp = Getusp();

			if (!_pbrk && pusp && pusp->IsValid())
			{
				// First time detecting the script that needs word/cluster-breaker 
				// (such as Thai, Indic, Lao etc.)
				_pbrk = new CTxtBreaker(this);
				Assert(_pbrk);
			}

			if (_pbrk && _pbrk->AddBreaker(brk))
			{
				// Sync up the breaking array(s)
				_pbrk->Refresh();
			}
		}
	}
#endif
}

/*
 *	CTxtEdit::OnSetTypographyOptions(wparam, lparam)
 *
 *	@mfunc
 *		If CTxtEdit isn't a password or accelerator control and wparam
 *		differs from _bTypography, update the latter and the view.
 *
 *	@rdesc
 *		HRESULT = S_OK
 */
HRESULT CTxtEdit::OnSetTypographyOptions(
	WPARAM wparam,		//@parm Typography flags
	LPARAM lparam)		//@parm Typography mask
{
	// Validate params
	if(wparam & ~(TO_SIMPLELINEBREAK | TO_ADVANCEDTYPOGRAPHY | TO_DISABLECUSTOMTEXTOUT | TO_ADVANCEDLAYOUT))
		return E_INVALIDARG;

	DWORD dwTypography = _bTypography & ~lparam;	// Kill current flag values
	dwTypography |= wparam & lparam;				// Or in new values

	if(_cpAccelerator == -1 && _bTypography != (BYTE)dwTypography)
	{
		_bTypography = (BYTE)dwTypography;
		_pdp->InvalidateRecalc();
		TxInvalidate();
	}
	return S_OK;
}

void CTxtEdit::TxGetViewInset(
	RECTUV *prc,
	const CDisplay *pdp) const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetViewInset");
	
	// Get inset, which is in HIMETRIC
	RECTUV rcHimetric;

	if(SUCCEEDED(_phost->TxGetViewInset((RECT*) &rcHimetric)))
	{
		if(!pdp)						// If no display is specified,
			pdp = _pdp;					//  use main display

		AssertSz(pdp->IsValid(), "CTxtEdit::TxGetViewInset Device not valid");

		prc->left	= pdp->HimetricUtoDU(rcHimetric.left);
		prc->top	= pdp->HimetricVtoDV(rcHimetric.top);
		prc->right	= pdp->HimetricUtoDU(rcHimetric.right);
		prc->bottom = pdp->HimetricVtoDV(rcHimetric.bottom);
	}
	else
	{
		// The call to the host failed. While this is highly improbable, we do 
		// want to something reasonably sensible. Therefore, we will just pretend 
		// there is no inset and continue.
		ZeroMemory(prc, sizeof(RECTUV));
	}
}


//
//	helper functions. FUTURE (alexgo) maybe we should get rid of
//  some of these
//

/*	FUTURE (murrays): Unless they are called a lot, the TxGetBit routines
	might be done more compactly as:

BOOL CTxtEdit::TxGetBit(
	DWORD dwMask)
{
	DWORD dwBits = 0;
	_phost->TxGetPropertyBits(dwMask, &dwBits);
	return dwBits != 0;
}

e.g., instead of TxGetSelectionBar(), we use TxGetBit(TXTBIT_SELECTIONBAR).
If they are called a lot (like TxGetSelectionBar()), the bits should probably
be cached, since that saves a bunch of cache misses incurred in going over to
the host.

*/

BOOL CTxtEdit::IsLeftScrollbar() const	
{
	if(!_fHost2)
		return FALSE;

#ifndef NOCOMPLEXSCRIPTS
	DWORD dwStyle, dwExStyle;

	_phost->TxGetWindowStyles(&dwStyle, &dwExStyle);
	return dwExStyle & WS_EX_LEFTSCROLLBAR;
#else
	return FALSE;
#endif
}

TXTBACKSTYLE CTxtEdit::TxGetBackStyle() const					
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetBackStyle");

	TXTBACKSTYLE style = TXTBACK_OPAQUE;
	_phost->TxGetBackStyle(&style);
	return style;
}

BOOL CTxtEdit::TxGetAutoSize() const					
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetAutoSize");

	return (_dwEventMask & ENM_REQUESTRESIZE);
}

BOOL CTxtEdit::TxGetAutoWordSel() const				
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetAutoWordSel");

	DWORD dwBits = 0;
	_phost->TxGetPropertyBits(TXTBIT_AUTOWORDSEL, &dwBits);
	return dwBits != 0;
}

DWORD CTxtEdit::TxGetMaxLength() const					
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetMaxLength");

	// Keep this a DWORD in case client uses a cpMost of 0xFFFFFFFF, which is
	// admittedly a little large, at least for 32-bit address spaces!
	// tomForward would be a more reasonable max length, altho it's also
	// probably larger than possible in a 32-bit address space.
	return _cchTextMost;
}

/*
 *	CTxtEdit::TxSetMaxToMaxText(LONG cExtra)
 *
 *	@mfunc
 *		Set new maximum text length based on length of text and possibly extra chars
 *		to accomodate.
 */
void CTxtEdit::TxSetMaxToMaxText(LONG cExtra)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxSetMaxToMaxText");

	// See if we need to update the text max
	LONG cchRealLen = GetAdjustedTextLength() + cExtra;

	if(_fInOurHost && _cchTextMost < (DWORD)cchRealLen)
		_cchTextMost = cchRealLen;
}

WCHAR CTxtEdit::TxGetPasswordChar() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetPasswordChar");

	if(_fUsePassword)
	{
		WCHAR ch = L'*';
		_phost->TxGetPasswordChar(&ch);

		// We don't allow these characters as password chars
		if(ch < 32 || ch == WCH_EMBEDDING)
			return L'*';
		return ch;
	}
	return 0;
}

void CTxtEdit::TxGetClientRect(RECTUV *prc) const
{
	RECT rc;
	_phost->TxGetClientRect(&rc);
	_pdp->RectuvFromRect(*prc, rc);
}

BOOL CTxtEdit::TxShowScrollBar(INT fnBar, BOOL fShow)
{
	//Convert scrollbar bits from logical to physical
	if (IsUVerticalTflow(_pdp->GetTflow()))
		fnBar = fnBar == SB_HORZ ? SB_VERT : SB_HORZ;

	return _phost->TxShowScrollBar(fnBar, fShow);
}

BOOL CTxtEdit::TxEnableScrollBar (INT fnBar, INT fuArrowFlags)
{
	//Convert scrollbar bits from logical to physical
	if (IsUVerticalTflow(_pdp->GetTflow()))
		fnBar = fnBar == SB_HORZ ? SB_VERT : SB_HORZ;

	return _phost->TxEnableScrollBar(fnBar, fuArrowFlags);
}

BOOL CTxtEdit::TxSetScrollRange(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)
{
	//Convert scrollbar bits from logical to physical
	if (IsUVerticalTflow(_pdp->GetTflow()))
		fnBar = fnBar == SB_HORZ ? SB_VERT : SB_HORZ;

	return _phost->TxSetScrollRange(fnBar, nMinPos, nMaxPos, fRedraw);
}

BOOL CTxtEdit::TxSetScrollPos (INT fnBar, INT nPos, BOOL fRedraw)
{
	//Convert scrollbar bits from logical to physical
	if (IsUVerticalTflow(_pdp->GetTflow()))
		fnBar = fnBar == SB_HORZ ? SB_VERT : SB_HORZ;

	return _phost->TxSetScrollPos(fnBar, nPos, fRedraw);
}

BOOL CTxtEdit::TxSetCaretPos(INT u, INT v)
{
	POINTUV ptuv = {u, v};
	POINT pt;
	_pdp->PointFromPointuv(pt, ptuv);
	return _phost->TxSetCaretPos(pt.x, pt.y);
}

DWORD CTxtEdit::TxGetScrollBars() const					
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetScrollBars");

	DWORD dwScroll;
	_phost->TxGetScrollBars(&dwScroll);

	//Convert scrollbar bits from physical to logical
	if (IsUVerticalTflow(_pdp->GetTflow()))
	{
		DWORD dwScrollT = dwScroll;

		dwScroll &= ~(WS_HSCROLL | WS_VSCROLL);

		if (dwScrollT & WS_VSCROLL)
			dwScroll |= WS_HSCROLL;

		if (dwScrollT & WS_HSCROLL)
			dwScroll |= WS_VSCROLL;
	}

	return dwScroll;
}

LONG CTxtEdit::TxGetSelectionBarWidth() const				
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetSelectionBarWidth");
	
	LONG lSelBarWidth = 0;
	_phost->TxGetSelectionBarWidth(&lSelBarWidth);
	return lSelBarWidth;
}

BOOL CTxtEdit::TxGetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetWordWrap");

	DWORD dwBits = 0;
	_phost->TxGetPropertyBits(TXTBIT_WORDWRAP, &dwBits);
	return dwBits != 0;
}

BOOL CTxtEdit::TxGetSaveSelection() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetSaveSelection");

	DWORD dwBits = 0;
	_phost->TxGetPropertyBits(TXTBIT_SAVESELECTION, &dwBits);
	return dwBits != 0;
}

/* 
 *	CTxtEdit::ClearUndo()
 *
 *	@mfunc	Clear all undo buffers
 */
void CTxtEdit::ClearUndo(
	IUndoBuilder *publdr)	//@parm the current undo context (may be NULL)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::ClearUndo");

	if(_pundo)
		_pundo->ClearAll();

	if(_predo)
		_predo->ClearAll();

	if(publdr)
		publdr->Discard();
}

/////////////////////////////// ITextHost2 Extensions //////////////////////////////

/*
 *	CTxtEdit::TxIsDoubleClickPending ()
 *
 *	@mfunc	calls host via ITextHost2 to find out if double click is pending.
 *
 *	@rdesc 	TRUE/FALSE
 */
BOOL CTxtEdit::TxIsDoubleClickPending()
{
	return _fHost2 ? _phost->TxIsDoubleClickPending() : FALSE;
}			

/*
 *	CTxtEdit::TxGetWindow(phwnd)
 *
 *	@mfunc	calls host via ITextHost2 to get current window for this edit
 *			instance.  This is very helpful for	OLE object support
 *
 *	@rdesc	HRESULT
 */
HRESULT	CTxtEdit::TxGetWindow(
	HWND *phwnd)
{
	return _fHost2 ? _phost->TxGetWindow(phwnd) : E_NOINTERFACE;
}

/*
 *	CTxtEdit::TxSetForegroundWindow ()
 *
 *	@mfunc	calls host via ITextHost2 to make our window the foreground
 *			window. Used to support drag/drop.
 *
 *	@rdesc	HRESULT
 */
HRESULT	CTxtEdit::TxSetForegroundWindow()
{
	return _fHost2 ? _phost->TxSetForegroundWindow() : E_NOINTERFACE;
}

/*
 *	CTxtEdit::TxGetPalette()
 *
 *	@mfunc	calls host via ITextHost2 to get current palette
 *
 *	@rdesc	HPALETTE
 */
HPALETTE CTxtEdit::TxGetPalette()
{
	return _fHost2 ? _phost->TxGetPalette() : NULL;
}

/*
 *	CTxtEdit::TxGetFEFlags(pFEFlags)
 *
 *	@mfunc	calls host via ITextHost2 to get current FE settings
 *
 *	@rdesc	HRESULT
 */
HRESULT	CTxtEdit::TxGetFEFlags(
	LONG *pFEFlags)
{
#ifndef NOFEPROCESSING
	*pFEFlags = 0;						// In case no ITextHost2 methods

	HRESULT hResult = _fHost2 ? _phost->TxGetFEFlags(pFEFlags) : E_NOINTERFACE;

	if (hResult == NOERROR || hResult == E_NOINTERFACE)
	{
		if (Get10Mode())
			*pFEFlags |= tomRE10Mode;
		if (_fUseAtFont)
			*pFEFlags |= tomUseAtFont;
		if (_fUsePassword)
			*pFEFlags |= tomUsePassword;
		*pFEFlags |= (_pdp->GetTflow()) << 2;
	}
	return hResult;
#else
	return E_NOINTERFACE;
#endif
}

/*
 *	CTxtEdit::TxSetCursor(hcur, fText)
 *
 *	@mfunc	calls host via ITextHost2 to set cursor
 *
 *	@rdesc	HCURSOR
 */
HCURSOR CTxtEdit::TxSetCursor(
	HCURSOR	hcur,
	BOOL	fText)
{
	return _fHost2 ? _phost->TxSetCursor2(hcur, fText) : ::SetCursor(hcur);
}


//
//	Event Notification methods
//

/*
 *	CTxtEdit::TxNotify(iNotify, pv)
 *
 *	@mfunc	This function checks bit masks and sends notifications to the
 *			host.
 *
 *	@devnote	Callers should check to see if a special purpose notification
 *			method has already been provided.
 *
 *	@rdesc	S_OK, S_FALSE, or some error
 */
HRESULT CTxtEdit::TxNotify(
	DWORD iNotify, 		//@parm Notification to send
	void *pv)			//@parm Data associated with notification
{
	// First, disallow notifications that we handle elsewhere
	Assert(iNotify != EN_SELCHANGE); 	//see SetSelectionChanged
	Assert(iNotify != EN_ERRSPACE);		//see SetOutOfMemory
	Assert(iNotify != EN_CHANGE);		//see SetChangedEvent
	Assert(iNotify != EN_HSCROLL);		//see SendScrollEvent
	Assert(iNotify != EN_VSCROLL);		//see SendScrollEvent
	Assert(iNotify != EN_MAXTEXT);		//see SetMaxText
	Assert(iNotify != EN_MSGFILTER);	//this is handled specially
										// in TxSendMessage

	// Switch on the event to check masks.  

	DWORD dwMask;
	switch(iNotify)
	{
		case EN_DROPFILES:
			dwMask = ENM_DROPFILES;
			goto Notify;

		case EN_PROTECTED:
			dwMask = ENM_PROTECTED;
			goto Notify;

		case EN_REQUESTRESIZE:
			dwMask = ENM_REQUESTRESIZE;
			goto Notify;

		case EN_PARAGRAPHEXPANDED:
			dwMask = ENM_PARAGRAPHEXPANDED;
			goto Notify;

		case EN_IMECHANGE:
			if (!Get10Mode())
				return S_FALSE;
			dwMask = ENM_IMECHANGE;
			goto Notify;

		case EN_PAGECHANGE:
			dwMask = ENM_PAGECHANGE;
			goto Notify;

		case EN_UPDATE:
		    if (!Get10Mode())
		        break;
		    dwMask = ENM_UPDATE;
		    //FALL THROUGH CASE

		Notify:
			if(!(_dwEventMask & dwMask))
				return NOERROR;			
	}
	return _phost->TxNotify(iNotify, pv);
}
			
/*
 *	CTxtEdit::SendScrollEvent(iNotify)
 *
 *	@mfunc	Sends scroll event if appropriate
 *
 *	@comm	Scroll events must be sent before any view updates have
 *			been requested and only if ENM_SCROLL is set.
 */
void CTxtEdit::SendScrollEvent(
	DWORD iNotify)		//@parm Notification to send
{
	Assert(iNotify == EN_HSCROLL || iNotify == EN_VSCROLL);

	// FUTURE (alexgo/ricksa).  The display code can't really
	// handle this assert yet.  Basically, we're trying to
	// say that scrollbar notifications have to happen
	// _before_ the window is updated.  When we do the
	// display rewrite, try to handle this better.

	// Assert(_fUpdateRequested == FALSE);

	if(_dwEventMask & ENM_SCROLL)
		_phost->TxNotify(iNotify, NULL);
}

/*
 *	CTxtEdit::HandleLowFiRTF (szControl)
 *
 *	@mfunc	Handles sending EN_LOWFIRTF notifications.
 *
 *	@rdesc	TRUE if the EN_LOWFIRTF message was sent and 
 *			processed successfully.
 */
BOOL CTxtEdit::HandleLowFiRTF(
	char * szControl)		//@parm	RTF control word prompting notification
{
	if(!(_dwEventMask & ENM_LOWFIRTF))
		return FALSE;

	ENLOWFIRTF enLowFiRTF;

	ZeroMemory(&enLowFiRTF, sizeof(enLowFiRTF));
	enLowFiRTF.nmhdr.code = EN_LOWFIRTF;
	enLowFiRTF.szControl = szControl;
	return _phost->TxNotify(EN_LOWFIRTF, &enLowFiRTF) == S_FALSE;
}

/*
 *	CTxtEdit::HandleLinkNotification (msg, wparam, lparam, pfInLink)
 *
 *	@mfunc	Handles sending EN_LINK notifications.
 *
 *	@rdesc	TRUE if the EN_LINK message was sent and 
 *			processed successfully.  Typically, that means the
 *			caller should stop whatever processing it was doing.
 */
BOOL CTxtEdit::HandleLinkNotification(
	UINT	msg,		//@parm	msg prompting the link notification
	WPARAM	wparam,		//@parm wparam of the message
	LPARAM	lparam,		//@parm lparam of the message
	BOOL *	pfInLink)	//@parm if non-NULL, indicate if over a link
{
	if(pfInLink)
		*pfInLink = FALSE;

	if(!(_dwEventMask & ENM_LINK) || !_fInPlaceActive)
		return FALSE;

	LONG cp;

	if(msg == WM_CHAR)
	{
		if(!_psel->GetCp() && !_psel->GetCch())
			return FALSE;

		_psel->_rpCF.AdjustBackward();
		DWORD dwEffectsPrev = _psel->GetCF()->_dwEffects;
		_psel->_rpCF.AdjustForward();

		if (!(dwEffectsPrev & CFE_LINK) || (CFE_LINKPROTECTED | CFE_HIDDEN)
			 == (dwEffectsPrev & (CFE_LINKPROTECTED | CFE_HIDDEN)) ||
			!(_psel->GetCF()->_dwEffects & CFE_LINK))
		{
			return FALSE;
		}
		cp = _psel->GetCp();
	}
	else
	{
		HITTEST Hit;
		POINT	ptxy = {LOWORD(lparam), HIWORD(lparam)};
		POINTUV	pt;
		if(msg == WM_SETCURSOR)
		{
			GetCursorPos(&ptxy);
			if(!_phost->TxScreenToClient(&ptxy))
				return FALSE;
		}
		_pdp->PointuvFromPoint(pt, ptxy);
		cp = _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit);

		if(Hit != HT_Link)					// Not a hyperlink
			return FALSE;
	}

	LONG	  cpMin, cpMost;			// It's a hyperlink
	ENLINK	  enlink;
	CTxtRange rg(this, cp, 0);

	ZeroMemory(&enlink, sizeof(enlink));
	enlink.nmhdr.code = EN_LINK;

	if(pfInLink)
		*pfInLink = TRUE;

	rg.SetIgnoreFormatUpdate(TRUE);
	rg.Expander(tomLink, TRUE, NULL, &cpMin, &cpMost);

	//If the previous character of a link is hidden, then
	//this came in as an RTF hyperlink field, so just export
	//the hidden text to the client to be passed to the browser.
	rg.SetCp(cpMin + 1, FALSE);
	if (rg.GetCF()->_dwEffects & CFE_HIDDEN)
	{
		rg.Expander(tomHidden, TRUE, NULL, &cpMin, &cpMost);
		rg.SetCp(cpMin, FALSE);
		WCHAR ch;

		//Go to end of hyperlink (search for k)
		if (rg.CRchTxtPtr::FindText(cpMost, FR_DOWN, L"K", 1) == -1)
			return FALSE;

		cpMin = rg.GetCp();

		//Strip off quotes and spaces
		while ((ch = rg.CRchTxtPtr::GetChar()) == ' ' || ch == '\"')
		{
			rg.Move(1, FALSE);
			cpMin++;
		}

		//Find end of hyperlink. Do not just start from the end as
		//a fldinst can contain stuff which isn't part of the hyperlink
		WCHAR chPrev = rg.CRchTxtPtr::GetPrevChar();

		if (rg.CRchTxtPtr::FindText(cpMost, FR_DOWN, &chPrev, 1) == -1)
			return FALSE;

		cpMost = rg.GetCp() - 1;
	}

	// Fill in ENLINK data structure for our EN_LINK
	// callback asking client what we should do 
	enlink.msg = msg;
	enlink.wParam = wparam;
	enlink.lParam = lparam;
	enlink.chrg.cpMin  = GetAcpFromCp(cpMin);
	enlink.chrg.cpMost = GetAcpFromCp(cpMost);

	if(msg == WM_CHAR)							// Need to send both down and up
	{											//  msgs, since Outlook responds
		enlink.msg = WM_LBUTTONDOWN;			//  to down and others to up
		_phost->TxNotify(EN_LINK, &enlink);
		enlink.msg = WM_LBUTTONUP;
	}
	return _phost->TxNotify(EN_LINK, &enlink) == S_FALSE;
}

/*
 *	CTxtEdit::QueryUseProtection(prg, msg, wparam, lparam)
 *
 *	@mfunc	sends EN_PROTECTED to the host, asking if we should continue
 *	to honor the protection on a given range of characters
 *
 *	@rdesc	TRUE if protection should be honored, FALSE otherwise
 */
BOOL CTxtEdit::QueryUseProtection(
	CTxtRange *prg,	 	//@parm range to check for
	UINT	msg,   		//@parm msg used
	WPARAM	wparam,		//@parm wparam of the msg
	LPARAM 	lparam)		//@parm lparam of the msg
{
	LONG		cpMin, cpMost;
	ENPROTECTED enp;
	BOOL		fRet = FALSE;
	CCallMgr *	pcallmgr = GetCallMgr();

	Assert(_dwEventMask & ENM_PROTECTED);

	if( pcallmgr->GetInProtected() ||
		_fSuppressNotify)		// Don't ask host if we don't want to send notification
		return FALSE;

	pcallmgr->SetInProtected(TRUE);

	ZeroMemory(&enp, sizeof(ENPROTECTED));
	
	prg->GetRange(cpMin, cpMost);

	enp.msg = msg;
	enp.wParam = wparam;
	enp.lParam = lparam;
	enp.chrg.cpMin  = GetAcpFromCp(cpMin);
	enp.chrg.cpMost = GetAcpFromCp(cpMost);

	if(_phost->TxNotify(EN_PROTECTED, &enp) == S_FALSE)
		fRet = TRUE;

	pcallmgr->SetInProtected(FALSE);

	return fRet;
}


#ifdef DEBUG
//This is a debug api used to dump the document runs.
//If a pointer to the ped is passed, it is saved and
//used.  If NULL is passed, the previously saved ped
//pointer is used.  This allows the "context" to be
//setup by a function that has access to the ped and
//DumpDoc can be called lower down in a function that
//does not have access to the ped.
extern "C" {
void DumpStory(void *ped)
{
    static CTxtEdit *pedSave = (CTxtEdit *)ped;
    if(pedSave)
    {
        CTxtStory * pStory = pedSave->GetTxtStory();
        if(pStory)
            pStory->DbgDumpStory();

		CObjectMgr * pobjmgr = pedSave->GetObjectMgr();
        if(pobjmgr)
            pobjmgr->DbgDump();
    }
}
}
#endif

/*
 *	CTxtEdit::TxGetDefaultCharFormat (pCF)
 *
 *	@mfunc	helper function to retrieve character formats from the
 *			host.  Does relevant argument checking
 *
 *	@rdesc	HRESULT
 */
HRESULT CTxtEdit::TxGetDefaultCharFormat(
	CCharFormat *pCF,		//@parm Character format to fill in
	DWORD &		 dwMask)	//@parm Mask supplied by host or default
{
	HRESULT hr = pCF->InitDefault(0);
	dwMask = CFM_ALL2;

	const CHARFORMAT2 *pCF2 = NULL;

	if (_phost->TxGetCharFormat((const CHARFORMAT **)&pCF2) != NOERROR ||
		!IsValidCharFormatW(pCF2))
	{
		return hr;
	}

	dwMask  = pCF2->dwMask;
	DWORD dwMask2 = 0;
	if(pCF2->cbSize == sizeof(CHARFORMAT))
	{
		// Suppress CHARFORMAT2 specifications (except for Forms^3 disabled)
		dwMask	&= fInOurHost() ? CFM_ALL : (CFM_ALL | CFM_DISABLED);
		dwMask2 = CFM2_CHARFORMAT;
	}

	CCharFormat CF;							// Transfer external CHARFORMAT(2)
	CF.Set(pCF2, 1200);						//  parms to internal CCharFormat
	return pCF->Apply(&CF, dwMask, dwMask2);
}

/*
 *	CTxtEdit::TxGetDefaultParaFormat (pPF)
 *
 *	@mfunc	helper function to retrieve  paragraph formats.  Does
 *			the relevant argument checking.
 *
 *	@rdesc	HRESULT
 */
HRESULT CTxtEdit::TxGetDefaultParaFormat(
	CParaFormat *pPF)		//@parm Paragraph format to fill in
{
	HRESULT hr = pPF->InitDefault(0);

	const PARAFORMAT2 *pPF2 = NULL;

	if (_phost->TxGetParaFormat((const PARAFORMAT **)&pPF2) != NOERROR ||
		!IsValidParaFormat(pPF2))
	{
		return hr;
	}

	DWORD dwMask  = pPF2->dwMask;
	DWORD dwMask2 = 0;
	if(pPF2->cbSize == sizeof(PARAFORMAT))	// Suppress all but PARAFORMAT
	{										//  specifications
		dwMask &= PFM_ALL;
		dwMask2 = PFM2_PARAFORMAT;			// Tell Apply() that PARAFORMAT
	}										//  was used

	CParaFormat PF;							// Transfer external PARAFORMAT(2)
	PF.Set(pPF2);							//  parms to internal CParaFormat
	return pPF->Apply(&PF, dwMask, dwMask2);// Apply parms identified by dwMask
}										 


/*
 *	CTxtEdit::SetContextDirection(fUseKbd)
 *
 *	@mfunc
 *		Determine the paragraph direction and/or alignment based on the context
 *		rules (direction/alignment follows first strong character in the
 *		control) and apply this direction and/or alignment to the default
 *		format.
 *
 *	@comment
 *		Context direction only works for plain text controls. Note that 
 *		this routine only switches the default CParaFormat to RTL para if it
 *		finds an RTL char. IsBiDi() will automatically be TRUE for this case,
 *		since each char is checked before entering the backing store.
 */
void CTxtEdit::SetContextDirection(
	BOOL fUseKbd)		//@parm Use keyboard to set context when CTX_NEUTRAL
{
	// It turns out that Forms^3 can send EM_SETBIDIOPTIONS even for non BiDi controls.
	// AssertSz(IsBiDi(), "CTxtEdit::SetContextDirection called for nonBiDi control");
	if(IsRich() || !IsBiDi() || _nContextDir == CTX_NONE && _nContextAlign == CTX_NONE)
		return;

	LONG	cch = GetTextLength();
	CTxtPtr tp(this, 0);
	WCHAR	ch = tp.GetChar();
	WORD	ctx = CTX_NEUTRAL;
	BOOL	fChanged = FALSE;

	// Find first strongly directional character
	while (cch && !IsStrongDirectional(MECharClass(ch)))
	{
		ch = tp.NextChar();
		cch--;
	}

	// Set new context based on first strong character
	// if no strong charactes in ctrl and have Bidi keybd, then make RTL 
	if(cch)
		ctx = IsRTL(MECharClass(ch)) ? CTX_RTL : CTX_LTR;
	else
		ctx = (W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0)))) ? CTX_RTL : CTX_LTR;
	
	// Has context direction or alignment changed?
	if (_nContextDir   != CTX_NONE && _nContextDir   != ctx ||
		_nContextAlign != CTX_NONE && _nContextAlign != ctx)
	{
		// Start with current default CParaFormat
		CParaFormat PF = *GetParaFormat(-1);

		// If direction has changed...
		if(_nContextDir != CTX_NONE && _nContextDir != ctx)
		{
			if(ctx == CTX_LTR || ctx == CTX_RTL || fUseKbd)
			{
				if (ctx == CTX_RTL ||
					ctx == CTX_NEUTRAL && W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))))
				{
					PF._wEffects |= PFE_RTLPARA;
				}
				else
				{
					Assert(ctx == CTX_LTR || ctx == CTX_NEUTRAL);
					PF._wEffects &= ~PFE_RTLPARA;
				}
				fChanged = TRUE;
			}
			_nContextDir = ctx;
		}

		// If the alignment has changed...
		if(_nContextAlign != CTX_NONE && _nContextAlign != ctx)
		{
			if(PF._bAlignment != PFA_CENTER)
			{
				if(ctx == CTX_LTR || ctx == CTX_RTL || fUseKbd)
				{
					if (ctx == CTX_RTL ||
						ctx == CTX_NEUTRAL && W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))))
					{
						PF._bAlignment = PFA_RIGHT;
					}
					else
					{
						Assert(ctx == CTX_LTR || ctx == CTX_NEUTRAL);
						PF._bAlignment = PFA_LEFT;
					}
				}
			}
			_nContextAlign = ctx;
		}

		// Modify default CParaFormat
		IParaFormatCache *pPFCache = GetParaFormatCache();
		LONG iPF;

		if(SUCCEEDED(pPFCache->Cache(&PF, &iPF)))
		{
			pPFCache->Release(Get_iPF());	// Release _iPF regardless of
			Set_iPF(iPF);					// Update default format index
	
			if (fChanged)
				ItemizeDoc(NULL);

			// Refresh display
			Assert(_pdp);
			if(!_pdp->IsPrinter())
			{
				_pdp->InvalidateRecalc();
				TxInvalidate();
			}
		}
	}

	// Reset the first strong cp.
	_cpFirstStrong = tp.GetCp();

	Assert(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE);
}

/*
 *	CTxtEdit::GetAdjustedTextLength ()
 *
 *	@mfunc
 *		retrieve text length adjusted for the default end-of-document marker
 *
 *	@rdesc
 *		Text length without final EOP
 *
 *	@devnote
 *		For Word and RichEdit compatibility, we insert a CR or CRLF at the
 *		end of every new rich-text control.  This routine calculates the
 *		length of the document _without_ this final EOD marker.
 *
 *		For 1.0 compatibility, we insert a CRLF.  However, TOM (and Word)
 *		requires that we use a CR, from 2.0 on, we do that instead.
 */
LONG CTxtEdit::GetAdjustedTextLength()
{
	LONG cchAdjText = GetTextLength();

	Assert(!Get10Mode() || IsRich());		// No RE10 plain-text controls

	if(IsRich())
		cchAdjText -= fUseCRLF() ? 2 : 1;	// Subtract cch of final EOP

	return cchAdjText;
}

/*
 *	CTxtEdit::Set10Mode()
 *
 *	@mfunc
 *		Turns on the 1.0 compatibility mode bit.  If the control is
 *		rich text, it already has a default 'CR' at the end, which
 *		needs to turn into a CRLF for compatibility with RichEdit 1.0.
 *
 *	@devnote
 *		This function should only be called _immediately_ after
 *		creation of text services and before all other work.  There
 *		are Asserts to help ensure this.  Remark (murrays): why not
 *		allow the change provided the control is empty except for the
 *		final CR?
 *
 *		FUTURE: we might want to split _f10Mode into three flags:
 *		1) _fMapCps		// API cp's are MBCS and need conversion to Unicode 
 *		2) _fCRLF		// Use CRLFs for EOPs instead of CRs
 *		3) _f10Mode		// All other RE 1.0 compatibility things
 *
 *		Category 3 includes 1) automatically using FR_DOWN in searches,
 *		2) ignoring direction in CDataTransferObj::EnumFormatEtc(),
 *		3) not resetting _fModified when switching to a new doc,
 */
void CTxtEdit::Set10Mode()
{
	CCallMgr	callmgr(this);
	_f10Mode = TRUE;

	// Make sure nothing important has happened to the control.
	// If these values are non-NULL, then somebody is probably trying
	// to put us into 1.0 mode after we've already done work as
	// a 2.0 control.	
	Assert(GetTextLength() == cchCR);
	Assert(_psel == NULL);
	Assert(_fModified == NULL);

	SetRichDocEndEOP(cchCR);

	if(!_pundo)
		CreateUndoMgr(1, US_UNDO);

	if(_pundo)
		((CUndoStack *)_pundo)->EnableSingleLevelMode();

	// Turn off dual font
	_fDualFont = FALSE;

	// Turn on auto sizing for NTFE systems
	if (OnWinNTFE())
		_fAutoFontSizeAdjust = TRUE;
}

/*
 *	CTxtEdit::SetRichDocEndEOP(cchToReplace)
 *
 *	@mfunc	Place automatic EOP at end of a rich text document.
 */
void CTxtEdit::SetRichDocEndEOP(
	LONG cchToReplace)
{
	CRchTxtPtr rtp(this, 0);

	// Assume this is a 2.0 Doc
	LONG cchEOP = cchCR;
	const WCHAR *pszEOP = szCR;

	if(_f10Mode)
	{
		// Reset update values for a 1.0 doc
		cchEOP = cchCRLF;
		pszEOP = szCRLF;
	}

	rtp.ReplaceRange(cchToReplace, cchEOP, pszEOP, NULL, -1);
	
	_fModified = FALSE;
	_fSaved = TRUE;
	GetCallMgr()->ClearChangeEvent();
}

/*
 *	CTxtEdit::PopAndExecuteAntiEvent(pundomgr, void *pAE)
 *
 *	@mfunc	Freeze display and execute anti-event
 *
 *	@rdesc	HRESULT from IUndoMgr::PopAndExecuteAntiEvent
 */
HRESULT	CTxtEdit::PopAndExecuteAntiEvent(
	IUndoMgr *pundomgr,	//@parm Undo manager to direct call to
	void  *pAE)			//@parm AntiEvent for undo manager
{
	if(!pundomgr || _fReadOnly || !_fUseUndo || !pundomgr->CanUndo())
		return S_FALSE;

	if(_fReadOnly)
		return E_ACCESSDENIED;

	HRESULT hr;
	// Let stack based classes clean up before restoring selection
	{
		CFreezeDisplay		fd(_pdp);
		CSelPhaseAdjuster	selpa(this);

		hr = pundomgr->PopAndExecuteAntiEvent(pAE);
	}

	if(_psel)
	{
		// Once undo/redo has been executed, flush insertion point formatting
		_psel->Update_iFormat(-1);
		_psel->Update(TRUE);
	}
	return hr;
}

/*
 *	CTxtEdit::PasteDataObjectToRange(pdo, prg, cf, rps, publdr, dwFlags)
 *
 *	@mfunc	Freeze display and paste object
 *
 *	@rdesc	HRESULT from IDataTransferEngine::PasteDataObjectToRange
 */
HRESULT	CTxtEdit::PasteDataObjectToRange(
	IDataObject *	pdo, 
	CTxtRange *		prg, 
	CLIPFORMAT		cf, 
	REPASTESPECIAL *rps,
	IUndoBuilder *	publdr, 
	DWORD			dwFlags)
{
	HRESULT hr = _ldte.PasteDataObjectToRange(pdo, prg, cf, rps, publdr, 
		dwFlags);

	if(_psel)
	{
#ifdef DEBUG
		_psel->Invariant();
#endif
		_psel->Update(TRUE);		   // now update the caret
	}

	return hr;
}

/*
 *	GetECDefaultHeightAndWidth (pts, hdc, lZoomNumerator, lZoomDenominator,
 *					yPixelsPerInch, pxAveWidth, pxOverhang, pxUnderhang)
 *
 *	@mfunc	Helper for host to get ave char width and height for default 
 *			character set for the control.
 *
 *	@rdesc	Height of default character set
 *
 *	@devnote:
 *			This really only s/b called by the window's host.
 */
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,			//@parm ITextServices to conver to CTxtEdit.
	HDC hdc,					//@parm DC to use for retrieving the font.
	LONG lZoomNumerator,		//@parm Zoom numerator
	LONG lZoomDenominator,		//@parm Zoom denominator
	LONG yPixelsPerInch,		//@parm Pixels per inch for hdc
	LONG *pxAveWidth,			//@parm Optional ave width of character
	LONG *pxOverhang,			//@parm Optional overhang
	LONG *pxUnderhang)			//@parm Optional underhang
{
	CLock lock;					// Uses global (shared) FontCache
	// Convert the text-edit ptr
	CTxtEdit *ped = (CTxtEdit *) pts;

	// Get the CCcs that has all the information we need
	yPixelsPerInch = MulDiv(yPixelsPerInch, lZoomNumerator, lZoomDenominator);
	CCcs *pccs = ped->GetCcs(ped->GetCharFormat(-1), yPixelsPerInch);

	if(!pccs)
		return 0;

	if(pxAveWidth)
		*pxAveWidth = pccs->_xAveCharWidth;

	if(pxOverhang)
	{
		Assert(pxUnderhang);
		pccs->GetFontOverhang(pxOverhang, pxUnderhang);
	}
	
	SHORT	yAdjustFE = pccs->AdjustFEHeight(!ped->fUseUIFont() && ped->_pdp->IsMultiLine());
	LONG yHeight = pccs->_yHeight + (yAdjustFE << 1);

	pccs->Release();						// Release the CCcs
	return yHeight;
}

/* 
 *	CTxtEdit::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *									lprcUpdate, fupScroll)
 *	@mfunc
 *		Request Text Host to scroll the content of the specified client area
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtEdit::TxScrollWindowEx(
	INT		dx, 			//@parm	Amount of horizontal scrolling
	INT		dy, 			//@parm	Amount of vertical scrolling
	LPCRECT lprcScroll, 	//@parm	Scroll rectangle
	LPCRECT lprcClip)		//@parm	Clip rectangle
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEEXTERN, "CTxtEdit::TxScrollWindowEx");

	if(_fInPlaceActive)
	{
#if !defined(NOMAGELLAN)
		CMagellanBMPStateWrap bmpOff(*this, NULL);
#endif

		_phost->TxScrollWindowEx(dx, dy, lprcScroll, lprcClip, 0, 0, SW_INVALIDATE | SW_SCROLLCHILDREN);

	}
}

/*
 *	CTxtEdit::GetAcpFromCp (cp)
 *
 *	@mfunc
 *		Get API cp (acp) from Unicode cp in this text instance. The API cp
 *		may be Unicode, in which case it equals cp, or MBCS, in which case
 *		it's greater than cp if any Unicode characters preceding cp convert
 *		to double-byte characters.  An MBCS cp is the BYTE index of a character
 *		relative to the start of the story, while a Unicode cp is the character
 *		index.  The values are the same if all charsets are represented by
 *		SBCS charsets, e.g., ASCII.  If all characters are represented by
 *		double-byte characters, then acp = 2*cp.
 *
 *	@rdesc
 *		MBCS Acp from Unicode cp in this text instance
 *
 *	@devnote
 *		This could be made more efficient by having the selection maintain
 *		the acp that corresponds to its _rpTX._cp, provided RE 1.0 mode is
 *		active.  Alternatively CTxtEdit could have a _prg that tracks this
 *		value, but at a higher cost (17 DWORDs instead of 1 per instance).
 *
 *		FUTURE: we might want to have a conversion-mode state instead of just
 *		_f10Mode, since some people might want to know use MBCS cp's even in
 *		RE 3.0.  If so, use the corresponding new state flag instead of
 *		Get10Mode() in the following.
 */
LONG CTxtEdit::GetAcpFromCp(
	LONG cp,				//@parm Unicode cp to convert to MBCS cp
	BOOL fPrecise)			//@parm fPrecise flag to get byte count for MBCS
{
	if(!(IsFE() && (fCpMap() || fPrecise)))	// RE 2.0 and higher use char-count
		return cp;							//  cp's, while RE 1.0 uses byte
											//  counts
											//  bPrecise is for Ansi Apps that want byte counts
											//  (e.g. Outlook Subject line)

	CRchTxtPtr rtp(this);					// Start at cp = 0
	return rtp.GetCachFromCch(cp);
}

LONG CTxtEdit::GetCpFromAcp(
	LONG acp,				//@parm MBCS cp to convert to Unicode cp
	BOOL fPrecise)			//@parm fPrecise flag to get Unicode cp for MBCS
{
	if( acp == -1 || !(IsFE() && (fCpMap() || fPrecise)))
		return acp;

	CRchTxtPtr rtp(this);					// Start at cp = 0
	return rtp.GetCchFromCach(acp);
}


/*
 *	CTxtEdit::GetViewKind (plres)
 *
 *	@mfunc
 *		get view mode
 *
 *	@rdesc
 *		HRESULT = (plres) ? NOERROR : E_INVALIDARG
 *
 *	@devnote
 *		This could be a TOM property method (along with SetViewMode())
 */
HRESULT CTxtEdit::GetViewKind(
	LRESULT *plres)		//@parm Out parm to receive view mode
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetViewKind");

	if(!plres)
		return E_INVALIDARG;

	*plres = IsInOutlineView() ? VM_OUTLINE
		   : IsInPageView()	   ? VM_PAGE : VM_NORMAL;
	return NOERROR;
}

/*
 *	CTxtEdit::SetViewKind (Value)
 *
 *	@mfunc
 *		Turn outline mode on or off
 *
 *	@rdesc
 *		HRESULT = IsRich() ? NOERROR : S_FALSE
 *
 *	@devnote
 *		This could be a TOM property method (along with GetViewMode())
 */
HRESULT CTxtEdit::SetViewKind(
	long Value)		//@parm Turn outline mode on/off for Value nonzero/zero
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::SetViewKind");

	CTxtSelection *psel = GetSel();
	BOOL fPageView = Value == VM_PAGE && _pdp->IsMultiLine();

	if(fPageView || Value == VM_NORMAL && IsInPageView())
	{
		_fPageView = (WORD)fPageView;
		if(!IsInOutlineView())
		{
			_pdp->Paginate(0, TRUE);
			psel->Update(TRUE);
			TxInvalidate();
			return NOERROR;
		}
	}

	if(!IsRich() || !_pdp->IsMultiLine())
		return S_FALSE;

    Value = (Value == VM_OUTLINE);			// Convert to 1/0
	if(_fOutlineView != Value)
	{
		HCURSOR	hcur = TxSetCursor(LoadCursor(0, IDC_WAIT), NULL);

		_fOutlineView = (WORD)Value;
		if(!GetAdjustedTextLength())		// No text in control: in outline
		{									//  view, use Heading 1; in normal
			CParaFormat PF;					//  view, use Normal style
			PF._sStyle = (SHORT)(IsInOutlineView()
					  ? STYLE_HEADING_1 : STYLE_NORMAL);
			psel->SetParaStyle(&PF, NULL, PFM_STYLE);
		}
		else
		{
			// There is text. Make sure there is paragraph formatting.
			_psel->Check_rpPF();
		}

		psel->CheckIfSelHasEOP(-1, 0);
		_pdp->UpdateView();
	    psel->Update(TRUE);
		TxSetCursor(hcur, NULL);
	}
	return NOERROR;
}

/*
 *	CTxtEdit::GetViewScale (pValue)
 *
 *	@mfunc
 *		get view zoom scale in percent
 *
 *	@rdesc
 *		HRESULT = (pValue) ? NOERROR : E_INVALIDARG
 *
 *	@devnote
 *		This could be a TOM property method (along with SetViewScale())
 */
HRESULT CTxtEdit::GetViewScale(
	long *pValue)		//@parm Get % zoom factor
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetViewScale");

	if(!pValue)
		return E_INVALIDARG;

	*pValue = 100;
	if(GetZoomNumerator() && GetZoomDenominator())
		*pValue = (100*GetZoomNumerator())/GetZoomDenominator();

	return NOERROR;
}

/*
 *	CTxtEdit::SetViewScale (Value)
 *
 *	@mfunc
 *		Set zoom numerator equal to the scale percentage Value and
 *		zoom denominator equal to 100
 *
 *	@rdesc
 *		NOERROR
 *
 *	@devnote
 *		This could be a TOM property method (along with GetViewScale())
 */
HRESULT CTxtEdit::SetViewScale(
	long Value)		//@parm Set view scale factor
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::SetViewScale");

	if((unsigned)Value > 2000)
		return E_INVALIDARG;

	SetZoomNumerator(Value);
	SetZoomDenominator(100);
	return NOERROR;
}

/* 
 *	CTxtEdit::UpdateOutline()
 *
 *	@mfunc
 *		Update selection and screen after ExpandOutline() operation
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
HRESULT CTxtEdit::UpdateOutline()
{
	Assert(IsInOutlineView());

	GetSel()->Update(FALSE);
    TxInvalidate();
    return NOERROR;
}

/*
 *	CTxtEdit::MoveSelection(lparam, publdr)
 *
 *	@mfunc
 *		Move selected text up/down by the number of paragraphs given by
 *		LOWORD(lparam).
 *
 *	@rdesc
 *		TRUE iff movement occurred
 */
HRESULT CTxtEdit::MoveSelection (
	LPARAM lparam,			//@parm	# paragraphs to move by
	IUndoBuilder *publdr)	//@parm undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::MoveSelection");

	CFreezeDisplay	fd(_pdp);
	CTxtSelection *	psel = GetSel();
	LONG			cch;
	LONG			cchSel = psel->GetCch();
	LONG			cpMin, cpMost;
	LONG			cpSel = psel->GetCp();
	IDataObject *	pdo = NULL; 
	CTxtRange		rg(*psel); 
	LONG			cpNext = 0;
	LONG			cpCur = 0;
	BOOL			fDeleteCR = FALSE;

	if(publdr)
		publdr->StopGroupTyping();

	rg.Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);
	CPFRunPtr rp(rg);
	cch = rp.FindExpanded();			// Include subordinate paras
	if(cch < 0)
		cch = tomForward;
	rg.Move(cch, TRUE);
	cpMost = rg.GetCpMost();

	if(lparam > 0 && cpMost == GetTextLength())
	{									
		Beep();							// Already at end
		return S_FALSE;
	}

	HRESULT hr = _ldte.RangeToDataObject(&rg, SF_RTF, &pdo);
	if(hr != NOERROR)
		goto error;

	if(lparam > 0)
		psel->EndOf(tomParagraph, FALSE, NULL);
	else
		psel->StartOf(tomParagraph, FALSE, NULL);

	cpCur = psel->GetCp();
	hr = psel->Move(tomParagraph, lparam, NULL);
	if(psel->GetCp() == cpCur)
	{
		psel->Set(cpSel, cchSel);
		Beep();
		goto error;
	}

	// Since psel->Move() calls psel->Update(), the selection is forced
	// to be in noncollapsed text. Going backward, this might leave the
	// selection just before the EOP of a paragraph, instead of being at the
	// start of the paragraph where it should be.  Going forward it may have
	// tried to reach the EOD, but was adjusted backward. This case gets
	// a bit awkward...
	if(psel->GetCp() < cpCur)					// Going backward: be sure
		psel->StartOf(tomParagraph, FALSE, NULL);//  end up at start of para

	else if(!psel->_rpTX.IsAfterEOP())			// Going forward and sel
	{											//  adjusted backward
		psel->Move(tomForward, FALSE);			// Go to final CR, insert a CR
		CTxtRange rgDel(*psel);					//  use psel because UI
		rgDel.ReplaceRange(1, szCR, publdr, SELRR_REMEMBERRANGE);
		psel->Move(1, FALSE);
		fDeleteCR = TRUE;						// Remember to delete it
	}

	cpCur = psel->GetCp();
	hr = _ldte.PasteDataObjectToRange(pdo, psel, 0, NULL, 
									  publdr, PDOR_NONE);
	if(hr != NOERROR)
		goto error;

	if(fDeleteCR)								// Delete CR (final CR becomes
	{											//  CR for this para). Don't
		CTxtRange rgDel(*psel);					//  use psel because UI
		Assert(rgDel._rpTX.IsAfterEOP());		//  restricts it's ability to
		rgDel.Delete(tomCharacter, -1, &cch);	//  delete
	}											
												
	cpNext = psel->GetCp();			
	psel->Set(cpCur, 0);
	psel->CheckOutlineLevel(publdr);
	psel->Set(cpNext, 0);
	psel->CheckOutlineLevel(publdr);

	// Now set selection anti-events. If selection preceded paste point,
	// subtract its length from redo position, since selection will get
	// deleted if we are doing a DRAGMOVE within this instance.
	cch = cpMost - cpMin;						// cch of rg
	if(cpSel < cpCur)
		cpNext -= cch;

	psel->Set(psel->GetCp() + fDeleteCR, cch);	// Include final CR

	// rg.ReplaceRange won't delete final CR, so remember if it's included
	fDeleteCR = rg.GetCpMost() == GetTextLength();
	rg.ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);

	if(fDeleteCR)								// Needed to delete final CR
		rg.DeleteTerminatingEOP(publdr);		// Delete one immediately
												//  before it instead
	rg.CheckOutlineLevel(publdr);
	if(publdr)
	{
		HandleSelectionAEInfo(this, publdr, cpSel, cchSel, cpNext, cch,
							  SELAE_FORCEREPLACE);
	}
	hr = NOERROR;

error:
	if(pdo)
		pdo->Release();
	return hr;
}

/*
 *	CTxtEdit::OnInsertTable(ptrp, pclp)
 *
 *	@mfunc
 *		EM_INSERTTABLE acts similarly to EM_REPLACESEL for a degenerate
 *		selection (insertion point), but inserts a number of identical
 *		empty table rows instead of some plain text. Specifically
 *		it inserts ptrp->cRow empty table rows with the row and cell
 *		parameters given by ptrp and pclp, respectively.  It leaves the
 *		selection pointing to the start of the first cell in the row.  The
 *		client can then populate the table cells by pointing the selection
 *		at the cell end marks and inserting and formatting the desired text.
 *		Such text can include nested table rows, etc.
 *
 *		The format for a table row is
 *
 *		{CR ... }CR
 *
 *		where { stands for STARTGROUP (0xFFF9), CR is 0xD, } stands for
 *		ENDGROUP (0xFFFB) and ... stands for TABLEROWPARMS::cCell cell-end
 *		marks.  A cell-end mark is given by CELL (0x7), which is what Word
 *		also uses for this purposes.  For example, a row with three cells has
 *		the plain text 0xFFF9 0xD 7 7 7 0xFFFB 0xD.  The start and end group
 *		character pairs are assigned identical PARAFORMAT2 information that
 *		describes the row and cell parameters.  If rows with different
 *		parameters are needed, multiple single-row calls can be made with the
 *		desired parameters.
 *
 *	@rdesc
 *		HRESULT = S_OK if row inserted
 */
HRESULT CTxtEdit::OnInsertTable(
	TABLEROWPARMS * ptrp,	//@parm Describes table row parameters
	TABLECELLPARMS *pclp,	//@parm Describes cell parameters
	IUndoBuilder *publdr)	//@parm Undo builder to receive antievents
{
	CParaFormat		PF;
	CTxtSelection *	pSel = GetSel();
	CELLPARMS		rgCellParms[MAX_TABLE_CELLS];

	if (!ptrp || !pclp || !ptrp->cRow ||
		!IN_RANGE(1, ptrp->cCell, MAX_TABLE_CELLS) || 
		ptrp->cbRow  != sizeof(TABLEROWPARMS) ||
		ptrp->cbCell != sizeof(TABLECELLPARMS))
	{
		return E_INVALIDARG;
	}
	if(pSel->GetCch() || !IsRich() || !_pdp || !_pdp->IsMultiLine())
		return E_FAIL;

	LONG cpSelSave = pSel->GetCp();

	pSel->StopGroupTyping();
	while(pSel->GetPF()->IsTableRowDelimiter())
		pSel->AdvanceCRLF(CSC_NORMAL, FALSE);

	PF.InitDefault(0);
	PF._bTabCount	  = ptrp->cCell;
	PF._bAlignment	  = ptrp->nAlignment;
	PF._dxOffset	  = ptrp->dxCellMargin;
	PF._dxStartIndent = ptrp->dxIndent;
	PF._dyLineSpacing = ptrp->dyHeight;
	PF._wEffects	  = PFE_TABLE | PFE_TABLEROWDELIMITER;
	PF._bTableLevel	  = pSel->GetPF()->_bTableLevel + 1;

	if(ptrp->fRTL)
		PF._wEffects |= PFE_RTLPARA;
	if(ptrp->fKeep)
		PF._wEffects |= PFE_KEEP;
	if(ptrp->fKeepFollow)
		PF._wEffects |= PFE_KEEPNEXT;

	LONG uCell;
	LONG dul = 0;
	CCellColor ccr;

	for(LONG i = 0; i < ptrp->cCell; i++)
	{
		uCell = pclp->dxWidth;			// Cell width must be between
		uCell = max(0, uCell);			//  0" and 22"
		uCell = min(1440*22, uCell);
		dul += uCell;
		if(dul > 1440*22)
			return E_INVALIDARG;
		uCell += (pclp->nVertAlign << 24);
		if(pclp->fMergeTop)
			uCell |= fTopCell;
		else if(pclp->fMergePrev)
			uCell |= fLowCell;
		if(pclp->fVertical)
			uCell |= fVerticalCell;

		rgCellParms[i].uCell = uCell;

		rgCellParms[i].dxBrdrWidths = (CheckTwips(pclp->dxBrdrLeft)   << 0*8)
									+ (CheckTwips(pclp->dyBrdrTop)	  << 1*8)
									+ (CheckTwips(pclp->dxBrdrRight)  << 2*8)
									+ (CheckTwips(pclp->dyBrdrBottom) << 3*8);

		rgCellParms[i].dwColors = (ccr.GetColorIndex(pclp->crBrdrLeft)	<< 0*5)
								+ (ccr.GetColorIndex(pclp->crBrdrTop)	<< 1*5)
								+ (ccr.GetColorIndex(pclp->crBrdrRight)	<< 2*5)
								+ (ccr.GetColorIndex(pclp->crBrdrBottom)<< 3*5)
								+ (ccr.GetColorIndex(pclp->crBackPat)	<< 4*5)
								+ (ccr.GetColorIndex(pclp->crForePat)	<< 5*5);
		if(pclp->wShading > 10000)
			return E_INVALIDARG;

		rgCellParms[i].bShading = (BYTE)(pclp->wShading/50);

		if(!ptrp->fIdentCells)
			pclp++;
	}
	if(ccr._crCellCustom1)
	{
		PF._crCustom1 = ccr._crCellCustom1;
		if(ccr._crCellCustom2)
			PF._crCustom2 = ccr._crCellCustom2;
	}

	PF._iTabs = GetTabsCache()->Cache((LONG *)&rgCellParms[0],
									  ptrp->cCell * (CELL_EXTRA + 1));
	HRESULT hr = S_OK;
	for(i = ptrp->cRow; i--; )
	{
		LONG cchCells = pSel->InsertTableRow(&PF, publdr);
		if(!cchCells)
		{
			hr = E_FAIL;
			break;
		}
		pSel->Move(cchCells + 2, FALSE);	// Leave selection at end of row
	}

	GetTabsCache()->Release(PF._iTabs);
	pSel->Update(TRUE);
	if(publdr)
		HandleSelectionAEInfo(this, publdr,
			cpSelSave, 0, pSel->GetCp(), 0, SELAE_FORCEREPLACE);
	return hr;
}

/*
 *	CTxtEdit::SetReleaseHost
 *
 *	@mfunc	Handles notification that edit control must keep its
 *			reference to the host alive.
 */
void CTxtEdit::SetReleaseHost()
{
	_phost->AddRef();
	_fReleaseHost = TRUE;
}

#if !defined(NOMAGELLAN)
/*
 *	CTxtEdit::HandleMouseWheel(wparam, lparam)
 *
 *	@mfunc	Handles scrolling as a result of rotating a mouse roller wheel.
 *
 *	@rdesc	LRESULT
 */
LRESULT	CTxtEdit::HandleMouseWheel(
	WPARAM wparam,
	LPARAM lparam)
{ 	
	// This bit of global state is OK
	static LONG gcWheelDelta = 0;
	short zdelta = (short)HIWORD(wparam);
	BOOL fScrollByPages = FALSE;

	// Cancel middle mouse scrolling if it's going.
	OnTxMButtonUp(0, 0, 0);

	// Handle zoom or data zoom
	if((wparam & MK_CONTROL) == MK_CONTROL)
	{
	    // bug fix 5760
	    // prevent zooming if control is NOT rich or
	    // is a single line control
	    if (!_pdp->IsMultiLine())
	        return 0;
	        
		LONG lViewScale;
		GetViewScale(&lViewScale);
		lViewScale += (zdelta/WHEEL_DELTA) * 10;	// 10% per click
		if(lViewScale <= 500 && lViewScale >= 10)	// Word's limits
		{
			SetViewScale(lViewScale);							
			_pdp->UpdateView();
		}
		return 0;
	}

	if(wparam & (MK_SHIFT | MK_CONTROL))
		return 0;

	gcWheelDelta += zdelta;

	if(abs(gcWheelDelta) >= WHEEL_DELTA)
	{
		LONG cLineScroll = W32->GetRollerLineScrollCount();
		if(cLineScroll != -1)
			cLineScroll *= abs(gcWheelDelta)/WHEEL_DELTA;

		gcWheelDelta %= WHEEL_DELTA;

		// -1 means scroll by pages; so simply call page up/down. 
		if(cLineScroll == -1 || IsInPageView())
		{
			fScrollByPages = TRUE;
			if(_pdp)
				_pdp->VScroll(zdelta < 0 ? SB_PAGEDOWN : SB_PAGEUP, 0);
		}
		else
		{
			mouse.MagellanRollScroll(_pdp, zdelta, cLineScroll, 
				SMOOTH_ROLL_NUM, SMOOTH_ROLL_DENOM, TRUE);
		}

		// notify through the messagefilter that we scrolled
		if(_dwEventMask & ENM_SCROLLEVENTS)
		{
			MSGFILTER msgfltr;
			ZeroMemory(&msgfltr, sizeof(MSGFILTER));
			msgfltr.msg	   = WM_VSCROLL;
			msgfltr.wParam = fScrollByPages ?
								(zdelta < 0 ? SB_PAGEDOWN: SB_PAGEUP):
								(zdelta < 0 ? SB_LINEDOWN: SB_LINEUP);
			
			// We don't check the result of this call --
			// it's not a message we received and we're not going to
			// process it any further
			_phost->TxNotify(EN_MSGFILTER, &msgfltr);			
		}
		return TRUE;
	}
	return 0;
}
#endif

const int cchCorrectMax = 256; //Max characters to be autocorrected (Office spec)
const int cchFromMax = 768;

/*
 *	CTxtEdit::AutoCorrect(psel, ch, publdr)
 *
 *	@mfunc	Call the client to autocorrect the recently added word. Don't replace
 *	the recently added character in string passed to client. (We don't want to
 *	ReplaceRange a CELL character, for example.)
 */
void CTxtEdit::AutoCorrect(
	CTxtSelection *psel,
	WCHAR		   chAdd, 
	IUndoBuilder * publdr)
{
	LONG	cch = 0;
	WCHAR	pchFrom[cchFromMax + 1];
	WCHAR	pchTo[cchCorrectMax + 1];
	CTxtPtr	tp(psel->_rpTX);
	WCHAR	chPrev = tp.GetPrevChar();
	BOOL	fCheckIsLink = (L':' == chPrev || L'.' == chPrev) && GetDetectURL();

	for(LONG i = 4; i-- && tp.GetCp(); )
	{
		LONG cchWord =  -tp.FindWordBreak(WB_MOVEWORDLEFT);
		if (i == 2 && fCheckIsLink)
		{
			BOOL fURLLeadin = FALSE;
			GetDetectURL()->IsURL(tp, cchWord + 1, &fURLLeadin);
			if(fURLLeadin)
				return;	
		}
		if(cch + cchWord > cchFromMax)		// Don't bite off more than
			break;							//  buffer can chew

		cch += cchWord;
		if (IsEOP(tp.GetPrevChar()))		// Don't autocorrect across an EOP
			break;
	}
	// Be sure we don't go into hyperlink or SYMBOL_CHARSET territory
	if(psel->_rpCF.IsValid())
	{
		CCFRunPtr		   rp(*psel);

		for(LONG cchMax = 0; cchMax < cch; rp.SetIch(0))
		{
			rp.AdjustBackward();
			const CCharFormat *pCF = rp.GetCF();
			if (pCF->_dwEffects & (CFE_LINK | CFE_HIDDEN) ||
				pCF->_iCharRep == SYMBOL_INDEX)
			{
				break;
			}
			cchMax += rp.GetIch();
			if(!rp.GetIRun())
				break;						// Reached start of doc
		}
		if(cchMax < cch)					// Hyperlink within words to check
		{
			tp.Move(cch - cchMax);			// Only check chars back to link,
			cch = cchMax;					//  symbols, or CharRep change
		}
	}
	tp.GetText(cch, pchFrom);
	pchFrom[cch] = 0;

	long	  cchTo = cchCorrectMax, cchReplaced = 0;
	CCFRunPtr rp(*psel);
	rp.Move(-2);

	if(_pDocInfo->_pfnAutoCorrect(rp.GetCF()->_lcid, pchFrom, pchTo, cchTo, &cchReplaced))
	{
		// If plain text check for special cases to suppress per bug 8717.		
		// copyright, registered trademark, trademark, ellipses.
		if(!_fRich && (pchTo[0] == 0xA9 || pchTo[0] == 0xAE ||
			pchTo[0] == 0x2122 || pchTo[0] == 0x2026))
		{
			return;
		}

		if (publdr)
		{
			publdr->Done();
			publdr->StopGroupTyping();
		}

		CTxtRange rg(*psel);
		DWORD	  ch = rg.GetPrevChar();
		LONG	  cpSave = psel->GetCp();
		LONG	  cchDelim = 1;

		if(ch >= 0x1100)					// Most East Asian chars aren't delims
		{
			if(ch < 0x1200 || IN_RANGE(0x3040, ch, 0xD7FF) ||
				ch >= 0xF900 && (ch < 0xFAFF || IN_RANGE(0xFF21, ch, 0xFFDF)))
			{
				cchDelim = 0;
			}
		}
		rg.Set(rg.GetCp() - cchDelim, cchReplaced - cchDelim);
		rg.CleanseAndReplaceRange(wcslen(pchTo) - cchDelim, pchTo, FALSE, publdr, pchTo);
		if(!cchDelim)
			psel->SetCp(rg.GetCp(), FALSE);
		if (publdr)
			HandleSelectionAEInfo(this, publdr, cpSave, 0, psel->GetCp(), 0, SELAE_FORCEREPLACE);

//		publdr->SetNameID(UID_AUTOCORRECT);
	}
}

/*
 *	CTxtEdit::OnSetAssociateFont(pCF, dwFlags)
 *
 *	@mfunc	Set the Associate font for the input LCID or charset
 *
 *	@rdesc	LRESULT
 */
LRESULT	CTxtEdit::OnSetAssociateFont(
	CHARFORMAT2 *pCF2,
	DWORD		dwFlags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetAssociateFont");

	int		cpg = 0;
	SHORT	iFont;
	BYTE	yHeight;
	int		cbSize = pCF2->cbSize;

	Assert(cbSize == sizeof(CHARFORMAT2W) || cbSize == sizeof(CHARFORMAT2A));

	int iCharRep = CharRepFromCharSet(pCF2->bCharSet);

	if (pCF2->dwMask & CFM_LCID)
	{
		iCharRep = CharRepFromLID(cbSize == sizeof(CHARFORMAT2W)
								  ? pCF2->lcid : ((CHARFORMAT2A *)pCF2)->lcid,
								  dwFlags & SCF_ASSOCIATEFONT2);
		cpg = CodePageFromCharRep(iCharRep);
	}

	if (iCharRep == -1)
		return 0;							// Can't get Char repertoire, so forget it

	if (cbSize == sizeof(CHARFORMAT2W))
		iFont = GetFontNameIndex(pCF2->szFaceName);
	else
	{
		// need to convert CHARFORMAT2A face name
		LONG	cch;
		BOOL	fMissingCodePage;
		WCHAR	szFaceName[LF_FACESIZE];				

		cch = MBTWC(cpg, 0,
					((CHARFORMAT2A *)pCF2)->szFaceName,	-1, 
					szFaceName, LF_FACESIZE, &fMissingCodePage);

		if (fMissingCodePage || cch <= 0)
			return 0;

		iFont = GetFontNameIndex(szFaceName);
	}

	yHeight = pCF2->yHeight / TWIPS_PER_POINT;

	CLock lock;
	if (W32->SetPreferredFontInfo(iCharRep, dwFlags & SCF_USEUIRULES ? true : false, iFont, yHeight, pCF2->bPitchAndFamily))
		return 1;

	return 0;
}

/*
 *	CTxtEdit::OnGetAssociateFont(pCF, dwFlags)
 *
 *	@mfunc	Get the Associate font for the input LCID or charset
 *
 *	@rdesc	LRESULT
 */
LRESULT	CTxtEdit::OnGetAssociateFont(
	CHARFORMAT2 *pCF2,
	DWORD		dwFlags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetAssociateFont");

	int		cpg = 0;
	SHORT	iFont;
	BYTE	yHeight;
	BYTE	bPitchAndFamily;
	int		cbSize = pCF2->cbSize;

	Assert(cbSize == sizeof(CHARFORMAT2W) || cbSize == sizeof(CHARFORMAT2A));

	int iCharRep = CharRepFromCharSet(pCF2->bCharSet);
	if (pCF2->dwMask & CFM_LCID)
	{
		iCharRep = CharRepFromLID(cbSize == sizeof(CHARFORMAT2W)
								  ? pCF2->lcid : ((CHARFORMAT2A *)pCF2)->lcid,
								  dwFlags & SCF_ASSOCIATEFONT2);
		cpg = CodePageFromCharRep(iCharRep);
	}

	if (iCharRep == -1)
		return 0;							// Can't get char repertoire, so forget it

	if (W32->GetPreferredFontInfo(iCharRep, dwFlags & SCF_USEUIRULES ? true : false, iFont, yHeight, bPitchAndFamily))
	{
		pCF2->yHeight = yHeight * TWIPS_PER_POINT;
		pCF2->bPitchAndFamily = bPitchAndFamily;
		
		if (cbSize == sizeof(CHARFORMAT2W))
			wcscpy(pCF2->szFaceName, GetFontName((LONG)iFont));
		else
		{
			// need to convert CHARFORMAT2A face name
			LONG	cch;
			BOOL	fMissingCodePage;
			const WCHAR	*pszFaceName = GetFontName((LONG)iFont);				

			cch = WCTMB(cpg, 0,
						pszFaceName, -1,
						((CHARFORMAT2A *)pCF2)->szFaceName, LF_FACESIZE, 
						NULL, NULL, &fMissingCodePage);

			if (fMissingCodePage || cch <= 0)
				return 0;
		}
		return 1;
	}
	return 0;
}

#ifndef NOINKOBJECT
/*
 *	CTxtEdit::SetInkProps(ILineInfo *pILineInfo, UINT *piInkWidth)
 *
 *	@mfunc	Setup the Ink object properties
 *
 *	@rdesc	HRESULT
 */
HRESULT	CTxtEdit::SetInkProps(
	LONG		cp,
	ILineInfo	*pILineInfo, 
	UINT		*piInkWidth)
{
	HRESULT		hr = E_FAIL;
	INKMETRIC	inkMetric;
	CTxtRange	rg(this, cp, 1);
	const CCharFormat *pCF = rg.GetCF();
	
	if (pCF)
	{
		memset(&inkMetric, 0, sizeof(inkMetric));

		if (pCF->_wWeight > FW_NORMAL)
			inkMetric.iWeight = 3;								// Bold

		inkMetric.fItalic = !!(pCF->_dwEffects & CFE_ITALIC);	// Italic
																// Height in HIMETRIC
		inkMetric.iHeight = (UINT)MulDiv(pCF->_yHeight, HIMETRIC_PER_INCH, LY_PER_INCH);

		inkMetric.color = pCF->_crTextColor;					// Color

		// Get zoomed height
		LONG dvpInch = MulDiv(GetDeviceCaps(W32->GetScreenDC(), LOGPIXELSY), _pdp->GetZoomNumerator(), _pdp->GetZoomDenominator());
		CCcs *pccs = GetCcs(pCF, dvpInch);

		if (pccs)
		{
			inkMetric.iFontDescent = (UINT)MulDiv(inkMetric.iHeight, pccs->_yDescent, pccs->_yHeight);
			inkMetric.iFontAscent = inkMetric.iHeight - inkMetric.iFontDescent;

			// Release cache entry since we are done with it.
			pccs->Release();
		}

		hr = pILineInfo->SetFormat(&inkMetric);
	}

	return hr;
}
#endif
/*
 *	CTxtEdit::GetCaretWidth()
 *
 *	@mfunc	Get caret width
 *
 *	@rdesc
 *		caret width
 */
HRESULT	CTxtEdit::GetCaretWidth()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetCaretWidth");

	RECT rcInset;

	if(!fInHost2()	||					// Host 1
		SUCCEEDED(_phost->TxGetViewInset(&rcInset)) && !rcInset.right)
		return duCaret;

	return 0;
}

/*
 *	CCellColor::GetColorIndex(cr)
 *
 *	@mfunc
 *		Get color index corresponding to cr. Possible return values are 0
 *		(autocolor), 1-16 (the 16 standard colors: g_Colors), and two custom
 *		colors, 17 and 18 defined on a first-come basis.
 *
 *	@rdesc
 *		Color index corresponding to cr
 */
LONG CCellColor::GetColorIndex(
	COLORREF cr)
{
	if(cr == tomAutoColor)
		return 0;

	for(LONG i = 0; i < 16; i++)
	{
		if(cr == g_Colors[i])
			return i + 1;
	}
	if(!_crCellCustom1 || cr == _crCellCustom1)
	{
		_crCellCustom1 = cr;				// First custom cr 
		return 17;
	}

	if(!_crCellCustom2 || cr == _crCellCustom2)	
	{
		_crCellCustom2 = cr;				// Second custom cr
		return 18;
	}
	return 0;								// No custom cr available	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\format.cpp ===
/*
 *	@doc	INTERNAL
 *	
 *	@module - FORMAT.C
 *		CCharFormatArray and CParaFormatArray classes |
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_format.h"


ASSERTDATA

// ===============================  CFixArrayBase  =================================


CFixArrayBase::CFixArrayBase(
	LONG cbElem)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::CFixArrayBase");

	_prgel = NULL;
	_cel = 0;
	_ielFirstFree = 0;

#ifdef _WIN64
	// Make sure each element + Ref. count is 64-bit aligned.
	LONG	cbTemp = (cbElem + 4) & 7;	// Do a Mod 8

	_cbPad = 0;
	if (cbTemp)							// Need padding?
		_cbPad = 8 - cbTemp;

#endif

	_cbElem = cbElem + 4 + _cbPad;		// 4 is for reference count
}

/*
 *	CFixArrayBase::Add()
 *
 *	@mfunc	
 *		Return index of new element, reallocing if necessary
 *
 *	@rdesc
 *		Index of new element.
 *
 *	@comm
 *		Free elements are maintained in place as a linked list indexed
 *		by a chain of ref-count entries with their sign bits set and the
 *		rest of the entry giving the index of the next element on the
 *		free list.  The list is terminated by a 0 entry. This approach
 *		enables element 0 to be on the free list.
 */
LONG CFixArrayBase::Add()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Add");

	char *pel;
	LONG iel, ielRet;

	if(_ielFirstFree)					// Return first element of free list
	{
		ielRet = _ielFirstFree & ~FLBIT;
		_ielFirstFree = RefCount(ielRet);
	}
	else								// All lower positions taken: need 
	{									//  to add another celGrow elements
		pel = (char*)PvReAlloc(_prgel, (_cel + celGrow) * _cbElem);
		if(!pel)
			return -1;

		// Clear out the *end* of the newly allocated memory
		ZeroMemory(pel + _cel*_cbElem, celGrow*_cbElem);

		_prgel = pel;

		ielRet = _cel;					// Return first one added 
		iel = _cel + 1;
		_cel += celGrow;

		// Add elements _cel+1 thru _cel+celGrow-1 to free list. The last
		// of these retains a 0, stored by fZeroFill in Alloc
		_ielFirstFree = iel | FLBIT;

		for(pel = (char *)&RefCount(iel);
			++iel < _cel;
			pel += _cbElem)
		{
			*(INT *)pel = iel | FLBIT;
		}
	}		
	return ielRet;
}

void CFixArrayBase::Free(
	LONG iel)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Free(iel)");

	// Simply add it to free list
	RefCount(iel) = _ielFirstFree;
	_ielFirstFree = iel | FLBIT;
}

void CFixArrayBase::Free()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Free()");

#if defined(DEBUG) && !defined(NOFULLDEBUG)
	// Only do this validation if all the ped's are gone. Visual basic shutsdown apps
	// without freeing all the resources so this safety check is necessary.
	if (0 == W32->GetRefs())
	{
		// Display message if any CCharFormats, CParaFormats, or CTabs have
		// reference counts > 0.  This only happens if an error has occurred.
		// Since this is called as the RichEdit dll is unloading, we can't use
		// the usual AssertSz() macros.
		BOOL fComplained = FALSE;
		for(LONG iel = 0; iel < Count(); iel++)
		{
			while(RefCount(iel) > 0)
			{
				if (!fComplained)
				{
					fComplained = TRUE;
					AssertSz(FALSE, (_cbElem - _cbPad) == sizeof(CCharFormat) + 4 ? "CCharFormat not free" :
								 (_cbElem - _cbPad) == sizeof(CParaFormat) + 4 ? "CParaFormat not free" :
									 "CTabs not free");
				}
				Release(iel);
			}
		}
	}
#endif
	FreePv(_prgel);
	_prgel = NULL;
	_cel = 0;
	_ielFirstFree = 0;
}

HRESULT CFixArrayBase::Deref(
	LONG iel,
	const void **ppel) const
{
	Assert(ppel);
	AssertSz(iel >= 0,
		"CFixArrayBase::Deref: bad element index" );
	AssertSz(*(LONG *)(_prgel + (iel + 1) * _cbElem - 4) > 0,
		"CFixArrayBase::Deref: element index has bad ref count");

	if(!ppel)
		return E_INVALIDARG;

	*ppel = Elem(iel);
	return S_OK;
}

/*
 *	CFixArrayBase::RefCount(iel)
 *
 *	@mfunc
 *		The reference count for an element is stored as a LONG immediately
 *		following the element in the CFixArray. If the element isn't used
 *		i.e., is free, then the reference count is used as a link to the
 *		next free element.  The last free element in this list has a 0
 *		"reference count", which terminates the list.
 *
 *		The ref count follows the element instead of preceding it because
 *		this allows Elem(iel) to avoid an extra addition.  Elem() is used
 *		widely in the code.
 *
 *	@rdesc
 *		Ptr to reference count
 */
LONG & CFixArrayBase::RefCount(
	LONG iel)
{
	Assert(iel < Count());
	return (LONG &)(*(_prgel + (iel + 1) * _cbElem - 4));
}

LONG CFixArrayBase::Release(
	LONG iel)
{
	LONG  cRef = -1;

	if(iel >= 0)							// Ignore default iel
	{
		CLock lock;
		CheckFreeChain();
		AssertSz(RefCount(iel) > 0, "CFixArrayBase::Release(): already free");

		cRef = --RefCount(iel); 
		if(!cRef)							// Entry no longer referenced
			Free(iel);						// Add it to the free chain
	}
	return cRef;
}

LONG CFixArrayBase::AddRef(
	LONG iel)
{
	LONG  cRef = -1;

	if(iel >= 0)
	{
		CLock lock;
		CheckFreeChain();
    	AssertSz(RefCount(iel) > 0, "CFixArrayBase::AddRef(): add ref to free elem");
		cRef = ++RefCount(iel);
	}
	return cRef;
}

LONG CFixArrayBase::Find(
	const void *pel)
{
	CheckFreeChain();
	
	for(LONG iel = 0; iel < Count(); iel++)
	{
		// RefCount < 0 means entry not in use and is index of next free entry.
		// RefCount = 0 marks last free element in list.  _cbElem = sizeof(ELEM)
		// plus sizeof(RefCount), which is a LONG.
		if (RefCount(iel) > 0 &&
			!CompareMemory(Elem(iel), pel, _cbElem - sizeof(LONG) - _cbPad))
		{
			return iel;
		}
	}
	return -1;
}

HRESULT CFixArrayBase::Cache(
	const void *pel,
	LONG *		piel)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Cache");

	CLock	lock;
	LONG	iel = Find(pel);

	if(iel >= 0)
		RefCount(iel)++;
	else
	{	
		iel = Add();
		if(iel < 0)
			return E_OUTOFMEMORY;
		CopyMemory(Elem(iel), pel, _cbElem - sizeof(LONG) - _cbPad);
		RefCount(iel) = 1;
	}

	CheckFreeChain();
	
	if(piel)
		*piel = iel;
	
	return S_OK;
}

#ifdef DEBUG

void CFixArrayBase::CheckFreeChainFn(
	LPSTR	szFile,
	INT		nLine)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::CheckFreeChainFn");

	LONG cel = 0;
	LONG iel = _ielFirstFree;
	LONG ielT;

	while(iel)
	{
		Assert(iel < 0);
		ielT = RefCount(iel & ~FLBIT);

		if((LONG)(ielT & ~FLBIT) > _cel)
			Tracef(TRCSEVERR, "AttCheckFreeChainCF(): elem %ld points to out of range elem %ld", iel, ielT);

		iel = ielT;
		if(++cel > _cel)
		{
			AssertSzFn("CFixArrayBase::CheckFreeChain() - CF free chain seems to contain an infinite loop", szFile, nLine);
			return;
		}
	}
}

#endif


// ===========================  CCharFormatArray  ===========================================

HRESULT CCharFormatArray::Deref(
	LONG iCF,
	const CCharFormat **ppCF) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Deref");

	return CFixArrayBase::Deref(iCF, (const void **)ppCF);
}

LONG CCharFormatArray::Release(
	LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::ReleaseFormat");

	return CFixArrayBase::Release(iCF);
}

LONG CCharFormatArray::AddRef(
	LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::AddRefFormat");

	return CFixArrayBase::AddRef(iCF);
}

void CCharFormatArray::Destroy()
{
	delete this;
}

LONG CCharFormatArray::Find(
	const CCharFormat *pCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Find");

	LONG iCF;

	#define QUICKCRCSEARCHSIZE	15	// Must be 2^n - 1 for quick MOD
									//  operation, it is a simple hash.
 	static struct {
		BYTE	bCRC;
		LONG	iCF;
	} quickCrcSearch[QUICKCRCSEARCHSIZE+1];
 	BYTE	bCRC;
	WORD	hashKey;

	CheckFreeChain();

	// Check our cache before going sequential
	bCRC = (BYTE)pCF->_iFont;
	hashKey = (WORD)(bCRC & QUICKCRCSEARCHSIZE);
	if(bCRC == quickCrcSearch[hashKey].bCRC)
	{
		iCF = quickCrcSearch[hashKey].iCF - 1;
		if (iCF >= 0 && iCF < Count() && RefCount(iCF) > 0 &&
			!CompareMemory(Elem(iCF), pCF, sizeof(CCharFormat)))
		{
			return iCF;
		}
	}

	for(iCF = 0; iCF < Count(); iCF++)
	{
		if(RefCount(iCF) > 0 && !CompareMemory(Elem(iCF), pCF, sizeof(CCharFormat)))
		{
			quickCrcSearch[hashKey].bCRC = bCRC;
			quickCrcSearch[hashKey].iCF = iCF + 1;
			return iCF;
		}
	}
	return -1;
}

HRESULT CCharFormatArray::Cache(
	const CCharFormat *pCF,
	LONG* piCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Cache");

	CLock lock;
	LONG  iCF = Find(pCF);

	if(iCF >= 0)
		RefCount(iCF)++;
	else
	{
		iCF = Add();
		if(iCF < 0)
			return E_OUTOFMEMORY;
		*Elem(iCF) = *pCF;			// Set entry iCF to *pCF
		RefCount(iCF) = 1;
	}					 

	CheckFreeChain();
	
	if(piCF)
		*piCF = iCF;

	return S_OK;
}


// ===============================  CParaFormatArray  ===========================================

HRESULT CParaFormatArray::Deref(
	LONG iPF,
	const CParaFormat **ppPF) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Deref");

	return CFixArrayBase::Deref(iPF, (const void **)ppPF);
}

LONG CParaFormatArray::Release(
	LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::ReleaseFormat");

	CLock lock;
	LONG  cRef = CFixArrayBase::Release(iPF);

#ifdef TABS
	if(!cRef)
		GetTabsCache()->Release(Elem(iPF)->_iTabs);
#endif
	return cRef;
}

LONG CParaFormatArray::AddRef(
	LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::AddRefFormat");

	return CFixArrayBase::AddRef(iPF);
}

void CParaFormatArray::Destroy()
{
	delete this;
}

HRESULT CParaFormatArray::Cache(
	const CParaFormat *pPF,
	LONG *piPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Cache");

	HRESULT hr = CFixArrayBase::Cache((const void *)pPF, piPF);
#ifdef TABS
	if(hr == NOERROR && RefCount(*piPF) == 1)
		GetTabsCache()->AddRef(pPF->_iTabs);
#endif
	return hr;
}


// ===============================  CTabsArray  ===========================================

CTabsArray::~CTabsArray()
{
	for(LONG iTabs = 0; iTabs < Count(); iTabs++)
	{
		// It shouldn't be necessary to release any tabs, since when all
		// controls are gone, no reference counts should be > 0.
		while(RefCount(iTabs) > 0)
		{
#ifdef DEBUG
			// Only do this validation if all the ped's are gone. Visual basic shutsdown apps
			// without freeing all the resources so this safety check is necessary.
			AssertSz(0 != W32->GetRefs(), "CTabs not free");
#endif
			Release(iTabs);
		}
	}
}

const LONG *CTabsArray::Deref(
	LONG iTabs) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Deref");

	return iTabs >= 0 ? Elem(iTabs)->_prgxTabs : NULL;
}

LONG CTabsArray::Release(
	LONG iTabs)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Release");

	LONG cRef = CFixArrayBase::Release(iTabs);
	if(!cRef)
		FreePv(Elem(iTabs)->_prgxTabs);
	return cRef;
}

LONG CTabsArray::AddRef(
	LONG iTabs)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::AddRef");

	return CFixArrayBase::AddRef(iTabs);
}

LONG CTabsArray::Find(
	const LONG *prgxTabs,	//@parm Array of tab/cell data
	LONG		cTab)		//@parm # tabs or LONGs in cells
{
	CheckFreeChain();

	CTabs *pTab;
	LONG	cb = cTab*sizeof(LONG);
	
	for(LONG iel = 0; iel < Count(); iel++)
	{
		// RefCount < 0 means entry not in use and is index of next free entry.
		// RefCount = 0 marks last free element in list.  _cbElem = sizeof(ELEM)
		// plus sizeof(RefCount), which is a LONG.
		if(RefCount(iel) > 0)
		{
			pTab = Elem(iel);
			if (pTab->_cTab == cTab &&
				!CompareMemory(pTab->_prgxTabs, prgxTabs, cb))
			{
				return iel;
			}
		}
	}
	return -1;
}

LONG CTabsArray::Cache(
	const LONG *prgxTabs,	//@parm Array of tab/cell data
	LONG		cTab)		//@parm # tabs or LONGs in cells
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Cache");

	if(!cTab)
		return -1;						// No tabs defined: use default

	CLock	lock;
	LONG	iTabs = Find(prgxTabs, cTab);

	if(iTabs >= 0)
		RefCount(iTabs)++;
	else
	{
		iTabs = Add();
		if(iTabs < 0)					// Out of memory: use default
			return -1;

		CTabs *pTabs = Elem(iTabs);
		LONG   cb = sizeof(LONG)*cTab;

		pTabs->_prgxTabs = (LONG *)PvAlloc(cb, GMEM_FIXED);
		if(!pTabs->_prgxTabs)
			return -1;					// Out of memory: use default
		CopyMemory(pTabs->_prgxTabs, prgxTabs, cb);
		pTabs->_cTab = cTab;
		RefCount(iTabs) = 1;
	}					 
	return iTabs;
}


// ==================================  Factories  ===========================================

static ICharFormatCache *pCFCache = NULL;		// CCharFormat cache
static IParaFormatCache *pPFCache = NULL;	 	// CParaFormat cache
static CTabsArray *	   pTabsCache = NULL;	 	// CTabs cache

ICharFormatCache *GetCharFormatCache()
{
	return pCFCache;
}

IParaFormatCache *GetParaFormatCache()
{
	return pPFCache;
}

CTabsArray *GetTabsCache()
{
	return pTabsCache;
}

HRESULT CreateFormatCaches()					// Called by DllMain()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CreateFormatCaches");
	CLock	lock;

	pCFCache = new CCharFormatArray();
	if(!pCFCache)
		return E_OUTOFMEMORY;
     
    pPFCache = new CParaFormatArray();
	if(!pPFCache)
	{
		delete pCFCache;
		return E_OUTOFMEMORY;
	}

    pTabsCache = new CTabsArray();
	if(!pTabsCache)
	{
		delete pCFCache;
		delete pPFCache;
		return E_OUTOFMEMORY;
	}
	return S_OK;
}

HRESULT DestroyFormatCaches()					// Called by DllMain()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "DeleteFormatCaches");

	if (pCFCache)
		pCFCache->Destroy();
	if (pPFCache)
		pPFCache->Destroy();
	if (pTabsCache)
		delete pTabsCache;
	return NOERROR;
}

/*
 *	ReleaseFormats(iCF, iPF)
 *
 *	@mfunc
 *		Release char and para formats corresponding to the indices <p iCF>
 *		and <p iPF>, respectively
 */
void ReleaseFormats (
	LONG iCF,			//@parm CCharFormat index for releasing
	LONG iPF)			//@parm CParaFormat index for releasing
{
	AssertSz(pCFCache && pPFCache,
		"ReleaseFormats: uninitialized format caches");
	if (iCF != -1)
		pCFCache->Release(iCF);
	if (iPF != -1)
		pPFCache->Release(iPF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\font.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module FONT.CPP -- font cache |
 *
 *		Includes font cache, char width cache;
 *		create logical font if not in cache, look up
 *		character widths on an as needed basis (this
 *		has been abstracted away into a separate class
 *		so that different char width caching algos can
 *		be tried.) <nl>
 *		
 *	Owner: <nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		7/26/95		jonmat	cleanup and reorganization, factored out
 *					char width caching code into a separate class.
 *		7/1/99	    KeithCu  Removed multiple levels in CWidthCache, cached
 *					30K FE characters in 2 bytes, sped up cache by
 *					lowering acceptable collision rate, halved memory
 *					usage by storing widths in 2 bytes instead of 4
 *					Shrunk much out of CCcs (i.e. LOGFONT)
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */								

#include "_common.h"
#include "_font.h"
#include "_rtfconv.h"	// Needed for GetCodePage
#include "_uspi.h"

#define CLIP_DFA_OVERRIDE   0x40	//  Used to disable Korea & Taiwan font association
#define FF_BIDI		7

extern ICustomTextOut *g_pcto;

ASSERTDATA

// Corresponds to yHeightCharPtsMost in richedit.h
#define yHeightCharMost 32760

// NOTE: this is global across all instances in the same process.
static CFontCache *g_fc;

static FONTINFO *g_pFontInfo = NULL;
static LONG g_cFontInfo = 0;
static LONG g_cFontInfoMax = 0;

//Fonts automatically added to our font table
const WCHAR *szArial			= L"Arial";				// IFONT_ARIAL
const WCHAR *szTimesNewRoman	= L"Times New Roman";	// IFONT_TIMESNEWROMAN
const WCHAR *szSymbol			= L"Symbol";			// IFONT_SYMBOL
const WCHAR *szSystem			= L"System";			// IFONT_SYSTEM
const int cfontsDflt = 4;

//Other fonts that we do use, but aren't automatically added to our font table
const WCHAR *szMicrosSansSerif	= L"Microsoft Sans Serif";
const WCHAR *szMSSansSerif		= L"MS Sans Serif";
const WCHAR *szMangal			= L"Mangal";
const WCHAR *szLatha			= L"Latha";
const WCHAR *szRaavi			= L"Raavi";
const WCHAR *szShruti			= L"Shruti";
const WCHAR *szTunga			= L"Tunga";
const WCHAR *szGautami			= L"Gautami";
const WCHAR *szCordiaNew		= L"Cordia New";
const WCHAR *szTahoma			= L"Tahoma";
const WCHAR *szArialUnicode		= L"Arial Unicode MS";
const WCHAR *szWingdings		= L"Wingdings";
const WCHAR *szSylfaen			= L"Sylfaen";
const WCHAR *szSyriac			= L"Estrangelo Edessa";
const WCHAR *szThaana			= L"MV Boli";

#define szFontOfChoice szArial

/*
 *	GetFontNameIndex(pFontName)
 *
 *	@func
 *		return index into global pszFontName table for fontname pFontName.
 *		If fontname isn't in table, add it and return index.
 *
 *	@rdesc
 *		fontname index corresponding to pFontName
 *
 *	@devnote
 *		This uses a linear search, so the most common font names should be
 *		up front. Internally, we use the fontname indices, so the search
 *		isn't done that often.  Note also that the fontname table only grows,
 *		but this is probably OK for most clients.  Else we need ref counting...
 */
SHORT GetFontNameIndex(
	const WCHAR *pFontName)
{
	CLock Lock;					// Wonder how much this slows things down...

	for(LONG i = 0; i < g_cFontInfo; i++)
	{
		// A hash could speed this up if perf turns out poor
		if(!wcscmp(pFontName, g_pFontInfo[i].szFontName))
			return i;
	}

	if(g_cFontInfo + 1 >= g_cFontInfoMax)
	{
		// Note that PvReAlloc() reverts to PvAlloc() if g_pFontInfo is NULL
		FONTINFO *pFI = (FONTINFO *)PvReAlloc((LPVOID)g_pFontInfo,
									sizeof(FONTINFO) * (8 + g_cFontInfo));
		if(!pFI)
			return IFONT_ARIAL;					// Out of memory...

		// Initialize the structure
		ZeroMemory (&pFI[g_cFontInfo], 8 * sizeof(FONTINFO));

												//  attempts to fill them in
		if(!g_cFontInfoMax)						// First allocation
		{
			Assert(IFONT_ARIAL  == 0 && IFONT_TMSNEWRMN == 1 &&
				   IFONT_SYMBOL == 2 && IFONT_SYSTEM == 3);

			pFI[IFONT_ARIAL].szFontName		= szArial;
			pFI[IFONT_TMSNEWRMN].szFontName = szTimesNewRoman;
			pFI[IFONT_SYMBOL].szFontName	= szSymbol;
			pFI[IFONT_SYSTEM].szFontName	= szSystem;
			g_cFontInfo			 = cfontsDflt;
		}
		g_pFontInfo = pFI;
		g_cFontInfoMax += 8;
	}											

	LONG	cb = (wcslen(pFontName) + 1)*sizeof(WCHAR);
	WCHAR *	pch = (WCHAR *)PvAlloc(cb, GMEM_MOVEABLE);

	if(!pch)
		return IFONT_ARIAL;					// Out of memory...

	g_pFontInfo[g_cFontInfo].szFontName = pch;
	CopyMemory((void *)pch, pFontName, cb);
	return g_cFontInfo++;
}

/*
 *	GetFontName(iFont)
 *
 *	@func
 *		return fontname given by g_pFontInfo[iFont].szFontName.
 *
 *	@rdesc
 *		fontname corresponding to fontname index iFont
 */
const WCHAR *GetFontName(
	LONG iFont)
{
	return (iFont >= 0 && iFont < g_cFontInfo) ? g_pFontInfo[iFont].szFontName : NULL;
}

void SetFontSignature(
	LONG  iFont,
	QWORD qwFontSig)
{
	if(iFont >= 0 && iFont < g_cFontInfo)
		g_pFontInfo[iFont].qwFontSig |= qwFontSig;
}

/*
 *	SetFontLegitimateSize(iFont, fUIFont, bSize, fFEcpg)
 *
 *	@func
 *		Set the legitimate size (readable smallest size to use) of a given font
 *
 *	@rdesc
 *		TRUE if successful
 */
BOOL SetFontLegitimateSize(
	LONG 	iFont,
	BOOL	fUIFont,
	BYTE	bSize,
	BOOL	fFEcpg)
{
	if (iFont < g_cFontInfo)
	{
		// East Asia wanted to do it per codepage.
		//
		// FUTURE: Bear in mind that this approach is bug-prone. Once there's
		// any new FE font created with different metric from the existing one.
		// Font scaling will not perform well or even broken for such font [wchao].

		g_pFontInfo[iFont].ff.fScaleByCpg = fFEcpg;

		if (fUIFont)
		{
			if (!g_pFontInfo[iFont].bSizeUI)
				g_pFontInfo[iFont].bSizeUI = bSize;
			else
				// more than one legit size were updated per font,
				// We fallback to the codepage-driven approach.
				g_pFontInfo[iFont].ff.fScaleByCpg = g_pFontInfo[iFont].bSizeUI != bSize;
		}
		else
		{
			if (!g_pFontInfo[iFont].bSizeNonUI)
				g_pFontInfo[iFont].bSizeNonUI = bSize;
			else
				g_pFontInfo[iFont].ff.fScaleByCpg = g_pFontInfo[iFont].bSizeNonUI != bSize;
		}
		return TRUE;
	}
	return FALSE;
}

/*
 *	GetFontLegitimateSize(iFont, fUIFont, iCharRep)
 *
 *	@func
 *		Get the legitimate size (readable smallest size to use) of a given font
 *
 *	@rdesc
 *		Legitimate size of font
 */
BYTE GetFontLegitimateSize(
	LONG	iFont,			//@parm	Font to get size for
	BOOL	fUIFont,		//@parm	TRUE if for UI font
	int		iCharRep)		//@parm Char repertoire to use
{
	BYTE	bDefPaf;
	SHORT	iDefFont;
	BYTE	yHeight = 0;

	if (iFont < g_cFontInfo && !g_pFontInfo[iFont].ff.fScaleByCpg)
		yHeight = fUIFont ? g_pFontInfo[iFont].bSizeUI : g_pFontInfo[iFont].bSizeNonUI;

	if (!yHeight && fc().GetInfoFlags(iFont).fNonBiDiAscii)
	{
		// Non-BiDi ASCII font uses table font (of the same charset) legitimate height
		QWORD	qwFontSig = GetFontSignatureFromFace(iFont) & ~(FASCII | FFE);
		LONG	iCharRepT = GetFirstAvailCharRep(qwFontSig);
		
		if(W32->GetPreferredFontInfo(iCharRepT, fUIFont ? true : false, iDefFont, yHeight, bDefPaf))
		{
			SetFontLegitimateSize(iFont, fUIFont, yHeight ? yHeight : fUIFont ? 8 : 10,
								  IsFECharRep(iCharRepT));
		}
	}

	if (!yHeight)
	{
		if (fc().GetInfoFlags(iFont).fThaiDTP)
		{
			iCharRep = THAI_INDEX;
			fUIFont = FALSE;
		}
		W32->GetPreferredFontInfo(iCharRep, fUIFont ? true : false, iDefFont, yHeight, bDefPaf);
	}
	return yHeight ? yHeight : fUIFont ? 8 : 10;
}

/*
 *	GetTextCharsetInfoPri(hdc, pFontSig, dwFlags)
 *
 *	@func
 *		Wrapper to GDI's GetTextCharsetInfo. This to handle BiDi old-style fonts
 *
 *	@rdesc
 *		CharSet for info
 */
UINT GetTextCharsetInfoPri(
	HDC				hdc,
	FONTSIGNATURE*	pFontSig,
	DWORD			dwFlags)
{
#ifndef NOCOMPLEXSCRIPTS
	OUTLINETEXTMETRICA 	otm;
	INT					uCharSet = -1;

	if (pFontSig && GetOutlineTextMetricsA(hdc, sizeof(OUTLINETEXTMETRICA), &otm))
	{
		ZeroMemory (pFontSig, sizeof(FONTSIGNATURE));

		switch (otm.otmfsSelection & 0xFF00)
		{
			case 0xB200:	// Arabic Simplified
			case 0xB300:	// Arabic Traditional
			case 0xB400:	// Arabic Old UDF
				uCharSet = ARABIC_CHARSET; break;
			case 0xB100:	// Hebrew Old style
				uCharSet = HEBREW_CHARSET;
		}
	}
	if (uCharSet == -1)
		uCharSet = W32->GetTextCharsetInfo(hdc, pFontSig, dwFlags);

	if (uCharSet == DEFAULT_CHARSET)
		uCharSet = ANSI_CHARSET;	// never return ambiguous

	return (UINT)uCharSet;
#else
	return DEFAULT_CHARSET;
#endif
}

/*
 *	GetFontSignatureFromDC(hdc, &fNonBiDiAscii)
 *
 *	@func
 *		Compute RichEdit font signature for font selected into hdc. Uses
 *		info from OS font signature
 *
 *	@rdesc
 *		RichEdit font signature for font selected into hdc
 */
QWORD GetFontSignatureFromDC(
	HDC		hdc,
	BOOL &	fNonBiDiAscii)
{
	union
	{										// Endian-dependent way of
		QWORD qwFontSig;					//  avoiding 64-bit shifts
		DWORD dwFontSig[2];
	};

#ifndef NOCOMPLEXSCRIPTS

	// Try to get FONTSIGNATURE data
	CHARSETINFO csi;
	UINT 	uCharSet = GetTextCharsetInfoPri(hdc, &(csi.fs), 0);
	DWORD	dwUsb0 = 0;
	DWORD	dwUsb2 = 0;
	if(!W32->OnWin9x())
	{
		dwUsb0 = csi.fs.fsUsb[0];
		dwUsb2 = csi.fs.fsUsb[2];
	}

	if ((csi.fs.fsCsb[0] | dwUsb0 | dwUsb2) ||
		TranslateCharsetInfo((DWORD *)(DWORD_PTR)uCharSet, &csi, TCI_SRCCHARSET))
	{
		DWORD			fsCsb0 = csi.fs.fsCsb[0];
		CUniscribe *	pusp;
		SCRIPT_CACHE	sc = NULL;
		WORD			wGlyph;

		qwFontSig = ((fsCsb0 & 0x1FF) << 8)		// Shift left since we use
				  | ((fsCsb0 & 0x1F0000) << 3);	//  low byte for fBiDi, etc.
		// Also look at Unicode subrange if available
		// FUTURE: we may want to drive Unicode ranges with a
		// table approach, i.e., use for loop shifting dwUsb0 right
		// to convert each bit into an index into a table of BYTEs
		// that return the appropriate script index for rgCpgCharSet:
		//
		//	for(LONG i = 0; dwUsb0; dwUsb0 >>= 1, i++)
		//	{
		//		static const BYTE rgiCharRep[32] = {...};
		//		if(dwUsb0 & 1)
		//			dwFontSig |= FontSigFromCharRep(rgiCharRep[i]);
		//	}
		if(dwUsb0)
		{
			if (dwUsb0 & 0x00000400)
				qwFontSig |= FARMENIAN;

			Assert(FDEVANAGARI == 0x0000000800000000);
			dwFontSig[1] |= (dwUsb0 & 0x00FF8000) >> 12;	// 9 Indic scripts

			if (dwUsb0 & 0x02000000)
				qwFontSig |= FLAO;

			if (dwUsb0 & 0x04000000)
				qwFontSig |= FGEORGIAN;

			if (dwUsb0 & 0x10000000)
				qwFontSig |= FJAMO;
		}

		// The new Unicode 3.0 scripts are defined by dwUsb2 as follows
		// (see \\sparrow\sysnls\nlsapi\font-sig.txt):
		// 128	32	Script
		//----------------------
		//	70	 6	Tibetan
		//	71	 7	Syriac
		//	72	 8	Thaana
		//	73	 9	Sinhala
		//	74	10	Myanmar
		//	75	11	Ethiopic
		//	76	12	Cherokee
		//	77	13	Canadian Aboriginal Syllabics
		//	78	14	Ogham
		//	79	15	Runic
		//	80	16	Khmer
		//	81	17	Mongolian
		//	82	18	Braille
		//	83	19	Yi
		if(dwUsb2 & 0xFFFC0)			// Bits 6 - 19
		{
			if(dwUsb2 & 0x40)						// Bit 6 of dwUsb[2]
				dwFontSig[1] |= FTIBETAN > 32;		//  is Tibetan

			dwFontSig[1] |= (dwUsb2 & 0x180) >> 6;	// Syriac (7), Thaana (8)

			if(dwUsb2 & 0x200)						// Bit 9 of dwUsb[2]
				dwFontSig[1] |= FSINHALA > 32;		//  is Sinhala

			if(dwUsb2 & 0x400)						// Bit 10 of dwUsb[2]
				dwFontSig[1] |= FMYANMAR > 32;		//  is Myanmar

			dwFontSig[1] |= (dwUsb2 & 0xFF800) << 6;// Bits 11-19 of dwUsb[2]
		}
		if((qwFontSig & FCOMPLEX_SCRIPT) && !(qwFontSig & FHILATIN1)
		   && (pusp = GetUniscribe()))
		{
			// Signature says no Latin-1 support

			// Search for the 'a' and '0' glyph in the font to
			// determine if the font supports ASCII or European
			// Digit. This is necessary to overcome the font having
			// an incomplete font signature.
			if(ScriptGetCMap(hdc, &sc, L"a", 1, 0, &wGlyph) == S_OK)
				qwFontSig |= FASCIIUPR;

			if(ScriptGetCMap(hdc, &sc, L"0", 1, 0, &wGlyph) == S_OK)
				qwFontSig |= FBELOWX40;

			if(!IsBiDiCharSet(uCharSet) &&
				(qwFontSig & FASCII) == FASCII)
				fNonBiDiAscii = TRUE;		// Non-BiDi ASCII font

			ScriptFreeCache(&sc);
		}

		if (qwFontSig & FHILATIN1)
			qwFontSig |= FASCII;		// FLATIN1 has 3 bits

		// HACK for symbol font. We assign FSYMBOL for Symbol font signature.
		// REVIEW: should we just use csi.fs.fsCsb[0] bit 31 for symbol bit?
		if (uCharSet == SYMBOL_CHARSET && !qwFontSig || fsCsb0 & 0x80000000)
			qwFontSig = FSYMBOL;
	}
	else								// No font signature info
		qwFontSig = FontSigFromCharRep(CharRepFromCharSet(uCharSet));

#else
	qwFontSig = FLATIN1;					// Default Latin1
#endif // NOCOMPLEXSCRIPTS

	return qwFontSig;
}

/*
 *	GetFontSignatureFromFace(iFont, pqwFontSig)
 *
 *	@func
 *		Giving font signature matching the index of given facename.
 *	    This signature may not match the one in Cccs since this is the
 *		signature of the font of given facename. The Cccs one is
 *		per GDI realization.
 *
 *	@rdesc
 *		- font signature if pqwFontSig is NULL.
 *		- If pqwFontSig != NULL. It's a boolean.
 *			ZERO means returned signature is not sensible by following reasons
 *			 1. Bad facename (junk like "!@#$" or name that doesnt exist in the system)
 *			 2. Given face doesnt support even one valid ANSI codepage (symbol fonts,
 *				e.g., Marlett)
 */
QWORD GetFontSignatureFromFace(
	int 	iFont,
	QWORD *	pqwFontSig)
{
	Assert((unsigned)iFont < (unsigned)g_cFontInfo);

	FONTINFO_FLAGS	ff;
	QWORD			qwFontSig = g_pFontInfo[iFont].qwFontSig;
	ff.wFlags = g_pFontInfo[iFont].ff.wFlags;

	if(!ff.fCached)
	{
		int		i = 0;
		HDC	  	hdc = GetDC(NULL);
		LOGFONT	lf;
		WCHAR*	pwchTag = lf.lfFaceName;

		ZeroMemory(&lf, sizeof(LOGFONT));
	
		wcscpy(lf.lfFaceName, GetFontName(iFont));

		// Exclude Win95's tag name e.g. "Arial(Greek)"
		while (pwchTag[i] && pwchTag[i] != '(')
			i++;
		if(pwchTag[i] && i > 0)
		{
			while (i > 0 && pwchTag[i-1] == 0x20)
				i--;
			pwchTag[i] = 0;
		}

		lf.lfCharSet = DEFAULT_CHARSET;
	
		// Obtain a charset supported by given facename
		// to force GDI gives facename priority over charset.
		W32->GetFacePriCharSet(hdc, &lf);	
	
		HFONT hfont = CreateFontIndirect(&lf);
		if(hfont)
		{
			HFONT hfontOld = SelectFont(hdc, hfont);
			WCHAR szNewFaceName[LF_FACESIZE];
	
			GetTextFace(hdc, LF_FACESIZE, szNewFaceName);
	
			if(!wcsicmp(szNewFaceName, lf.lfFaceName) ||	// Got it
				((GetCharFlags(szNewFaceName, 2) & FFE) &&	// or Get back FE font name for English name
				 (GetCharFlags(lf.lfFaceName, 2) & FASCII)))//	because NT5 supports dual font names.
			{
				BOOL fNonBiDiAscii = FALSE;
				qwFontSig = GetFontSignatureFromDC(hdc, fNonBiDiAscii);
				if(fNonBiDiAscii)
					ff.fNonBiDiAscii = TRUE;
			}
			else
				ff.fBadFaceName = TRUE;

			TEXTMETRIC tm;

			GetTextMetrics(hdc, &tm);
			ff.fTrueType = tm.tmPitchAndFamily & TMPF_TRUETYPE ? 1 : 0;
			ff.fBitmap = tm.tmPitchAndFamily & (TMPF_TRUETYPE | TMPF_VECTOR | TMPF_DEVICE) ? 0 : 1;

			if(!ff.fBadFaceName && qwFontSig & FTHAI)
			{
				// Some heuristic test on Thai fonts.
				// Most Thai fonts will fall to this category currently except for
				// Tahoma and Microsoft Sans Serif.
				ff.fThaiDTP = tm.tmDescent && tm.tmAscent/tm.tmDescent < 3;
			}
			SelectObject(hdc, hfontOld);
			SideAssert(DeleteObject(hfont));
		}
		ReleaseDC(NULL, hdc);
	
		// Cache code pages supported by this font
		ff.fCached = TRUE;
		g_pFontInfo[iFont].qwFontSig |= qwFontSig;
		g_pFontInfo[iFont].ff.wFlags = ff.wFlags;
	}

	if (!pqwFontSig)
		return qwFontSig;

	*pqwFontSig = qwFontSig;

	// 22-29 are reserved for alternate ANSI/OEM, as of now we use 21, 22 for Devanagari and Tamil
	return qwFontSig && !ff.fBadFaceName;
}

/*
 *	FreeFontNames()
 *
 *	@func
 *		Free fontnames given by g_pFontInfo[i].szFontName allocated by
 *		GetFontNameIndex() as well as g_pFontInfo itself.
 */
void FreeFontNames()
{
	for(LONG i = cfontsDflt; i < g_cFontInfo; i++)
		FreePv((LPVOID)g_pFontInfo[i].szFontName);
	FreePv(g_pFontInfo);
	g_pFontInfo = NULL;
}

SHORT	g_iFontJapanese;
SHORT	g_iFontHangul;
SHORT	g_iFontBig5;
SHORT	g_iFontGB2312;

/*
 *	InitFontCache()
 *	
 *	@func
 *		Initializes font cache.
 *
 *	@devnote
 *		This is exists so reinit.cpp doesn't have to know all about the
 *		font cache.
 */
void InitFontCache()
{
	g_fc = new CFontCache;
	g_fc->Init();
}

/*
 *	FreeFontCache()
 *	
 *	@mfunc
 *		Frees font cache.
 *
 *	@devnote
 *		This is exists so reinit.cpp doesn't have to know all about the
 *		font cache.
 */
void FreeFontCache()
{
	for (int i = 0; i < g_cFontInfo; i++)
		delete g_pFontInfo[i]._pffm;

	delete g_fc;
	g_fc = NULL;
	FreeFontNames();
}

/*
 *	CFontCache & fc()
 *	
 *	@func
 *		initialize the global g_fc.
 *	@comm
 *		current #defined to store 16 logical fonts and
 *		respective character widths.
 */
CFontCache & fc()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "fc");
    return *g_fc;
}

FONTINFO_FLAGS CFontCache::GetInfoFlags(int ifont)
{
	if (!g_pFontInfo[ifont].ff.fCached)
		GetFontSignatureFromFace(ifont);

	return g_pFontInfo[ifont].ff;
}

CFontFamilyMgr::~CFontFamilyMgr()
{
	for (int i = 0; i < _rgf.Count(); i++)
	{
		CFontFamilyMember *pf = _rgf.Elem(i);
		pf->Free();
	}
}

CFontFamilyMember* CFontFamilyMgr::GetFontFamilyMember(LONG weight, BOOL fItalic)
{
	for (int i = 0; i < _rgf.Count(); i++)
	{
		CFontFamilyMember *pf = _rgf.Elem(i);
		if (pf->_weight == weight && pf->_fItalic == fItalic)
			return pf;
	}

	CFontFamilyMember f(weight, fItalic);
	CFontFamilyMember *pf = _rgf.Add(1, 0);
	*pf = f;
	return pf;
}

CKernCache * CFontCache::GetKernCache(LONG iFont, LONG weight, BOOL fItalic)
{
	if (!g_fc->GetInfoFlags(iFont).fTrueType)
		return 0;
	CFontFamilyMgr *pffm = GetFontFamilyMgr(iFont);
	CFontFamilyMember *pf = pffm->GetFontFamilyMember(weight, fItalic);
	return pf->GetKernCache();
}

CFontFamilyMgr* CFontCache::GetFontFamilyMgr(LONG iFont)
{
	if (!g_pFontInfo[iFont]._pffm)
		g_pFontInfo[iFont]._pffm = new CFontFamilyMgr();

	return g_pFontInfo[iFont]._pffm;
}


// ===================================  CFontCache  ====================================
/*
 *	CFontCache::Init()
 *	
 *	@mfunc
 *		Initializes font cache.
 *
 *	@devnote
 *		This is not a constructor because something bad seems to happen
 *		if we try to construct a global object.
 */
void CFontCache::Init()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::CFontCache");

	_dwAgeNext = 0;
}

/*
 *	CFontCache::MakeHashKey(pCF)
 *	
 *	@mfunc
 *		Build a hash key for quick searches for a CCcs matching
 *		the pCF.
 *		Format:
 *		iFont : 14
 *		Bold/Italic : 2
 *      Height : 16
 *
 */
CCSHASHKEY CFontCache::MakeHashKey(
	const CCharFormat *pCF)
{
	CCSHASHKEY ccshashkey;
	ccshashkey = pCF->_iFont | ((pCF->_dwEffects & 3) << 14);
	ccshashkey |= pCF->_yHeight << 16;
	return ccshashkey;
}

/*
 *	CFontCache::GetCcs(pCF, dvpInch, dwFlags, hdc)
 *	
 *	@mfunc
 *		Search the font cache for a matching logical font and return it.
 *		If a match is not found in the cache,  create one.
 *
 *	@rdesc
 *		A logical font matching the given CHARFORMAT info.
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs* CFontCache::GetCcs(
	CCharFormat *pCF,		//@parm Logical font (routine is allowed to change it)
	const LONG	dvpInch,	//@parm Y pixels per inch
	DWORD		dwFlags,	//@parm flags
	HDC			hdc)		//@parm HDC font is to be created for
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::GetCcs");
									//  display font
	const CCcs * const	pccsMost = &_rgccs[FONTCACHESIZE - 1];
	CCcs *				pccs;
    CCSHASHKEY			ccshashkey;
	int					iccsHash;

	if (dwFlags & FGCCSUSETRUETYPE)
	{
		//On Win '9x Thai/Vietnamese, you cannot force truetype fonts! Therefore,
		//we will force Tahoma if the font doesn't support the right charset.
		if (W32->OnWin9x())
		{
			UINT acp = GetACP();
			if (acp == 1258 || acp == 874)
			{
				QWORD qwFontSig = GetFontSignatureFromFace(pCF->_iFont);
				if (pCF->_iCharRep == THAI_INDEX && (qwFontSig & FTHAI) == 0 ||
					pCF->_iCharRep == VIET_INDEX && (qwFontSig & FVIETNAMESE) == 0 ||
					!g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
				{
					pCF->_iFont = GetFontNameIndex(szTahoma);
				}
			}
		}
		else if (!g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
			dwFlags |= FGCCSUSETRUETYPE;
	}

	if (hdc == NULL)
		hdc = W32->GetScreenDC();

	// Change _yHeight in the case of sub/superscript
	if(pCF->_dwEffects & (CFE_SUPERSCRIPT | CFE_SUBSCRIPT))
		 pCF->_yHeight = 2 * pCF->_yHeight / 3;

	//Convert CCharFormat into logical units (round)
	pCF->_yHeight = (pCF->_yHeight * dvpInch + LY_PER_INCH / 2) / LY_PER_INCH;
	if (pCF->_yHeight == 0)
		pCF->_yHeight = 1;

	if ((dwFlags & FGCCSUSEATFONT) && !IsFECharRep(pCF->_iCharRep))
	{
		QWORD qwFontSig = GetFontSignatureFromFace(pCF->_iFont);

		if (!(qwFontSig & FFE))				// No At font for non-FE charset and
			dwFlags &= ~FGCCSUSEATFONT;		//	font signature doesen't support FE
	}

	ccshashkey = MakeHashKey(pCF);

	// Check our hash before going sequential.
	iccsHash = ccshashkey % CCSHASHSEARCHSIZE;
	if(ccshashkey == quickHashSearch[iccsHash].ccshashkey)
	{
		pccs = quickHashSearch[iccsHash].pccs;
		if(pccs && pccs->_fValid)
		{
	        if(pccs->Compare(pCF, hdc, dwFlags))
                goto matched;
		}
	}
	else	//Setup this hash hint for next time
		quickHashSearch[iccsHash].ccshashkey = ccshashkey;


	// Sequentially search ccs for same character format
	for(pccs = &_rgccs[0]; pccs <= pccsMost; pccs++)
	{
		if(pccs->_ccshashkey == ccshashkey && pccs->_fValid)
		{
	        if(!pccs->Compare(pCF, hdc, dwFlags))
                continue;

			quickHashSearch[iccsHash].pccs = pccs;

		matched:
			//$ FUTURE: make this work even with wrap around of dwAgeNext
			// Mark as most recently used if it isn't already in use.
			if(pccs->_dwAge != _dwAgeNext - 1)
				pccs->_dwAge = _dwAgeNext++;
			pccs->_cRefs++;		// bump up ref. count
			return pccs;
		}
	}

	// We did not find a match: init a new font cache.
	pccs = GrabInitNewCcs(pCF, hdc, dwFlags);
	quickHashSearch[iccsHash].pccs = pccs;
	pccs->_ccshashkey = ccshashkey;
	return pccs;
}

/*
 *	CFontCache::GrabInitNewCcs(pCF, hdc, dwFlags)
 *	
 *	@mfunc
 *		Create a logical font and store it in our cache.
 *
 *	@rdesc
 *		New CCcs created
 */
CCcs* CFontCache::GrabInitNewCcs(
	const CCharFormat * const pCF,	//@parm Description of desired logical font
	HDC			hdc,
	DWORD		dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::GrabInitNewCcs");

	DWORD				dwAgeOldest = 0xffffffff;
	CCcs *				pccs;
	const CCcs * const	pccsMost = &_rgccs[FONTCACHESIZE - 1];
	CCcs *				pccsOldest = NULL;

	// Look for unused entry and oldest in use entry
	for(pccs = &_rgccs[0]; pccs <= pccsMost && pccs->_fValid; pccs++)
		if(pccs->_cRefs == 0 && pccs->_dwAge < dwAgeOldest)
		{
			dwAgeOldest = pccs->_dwAge;
			pccsOldest = pccs;
		}

	if(pccs > pccsMost)		// Didn't find an unused entry, use oldest entry
	{
		pccs = pccsOldest;
		if(!pccs)
		{
			AssertSz(FALSE, "CFontCache::GrabInitNewCcs oldest entry is NULL");
			return NULL;
		}
	}

	// Initialize new CCcs
	pccs->_hdc = hdc;
	pccs->_fFECharSet = IsFECharRep(pCF->_iCharRep);
	pccs->_fUseAtFont = (dwFlags & FGCCSUSEATFONT) != 0;
	pccs->_tflow = dwFlags & 0x3;
	if(!pccs->Init(pCF))
		return NULL;

	pccs->_cRefs++;
	return pccs;
}

// =============================  CCcs  class  ===================================================
/*
 *	BOOL CCcs::Init(pCF)
 *	
 *	@mfunc
 *		Init one font cache object. The global font cache stores
 *		individual CCcs objects.
 */
BOOL CCcs::Init (
	const CCharFormat * const pCF)	//@parm description of desired logical font
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Init");

	if(_fValid)
		Free();				// recycle already in-use fonts.

	if(MakeFont(pCF))
	{
		_iFont = pCF->_iFont;
		_dwAge = g_fc->_dwAgeNext++;
		_fValid = TRUE;			// successfully created a new font cache.
	}
	return _fValid;
}

/*
 *	void CCcs::Free()
 *	
 *	@mfunc
 *		Free any dynamic memory allocated by an individual font's cache.
 */
void CCcs::Free()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Free");

	Assert(_fValid);

	_widths.Free();

	if(_hfont)
	{
		DestroyFont();
		if (_fCustomTextOut)
			g_pcto->NotifyDestroyFont(_hfont);
	}

#ifndef NOCOMPLEXSCRIPTS
	if (_sc && g_pusp)
		ScriptFreeCache(&_sc);
#endif

	_fValid = FALSE;
	_cRefs = 0;
}

/*
 *	CCcs::BestCharRep(iCharRep, iCharRepDefault, fFontMatching)
 *
 *	@mfunc
 *		This function returns the best charset that the currently selected font
 *		is capable of rendering. If the currently selected font cannot support
 *		the requested charset, then the function returns bCharSetDefault, which
 *		is generally taken from the charformat.
 *		
 *	@rdesc
 *		The closest charset to bCharSet that can be rendered by the current
 *		font.
 *
 *	@devnote
 *		Currently this function is only used with plain text, however I don't
 *		believe there is any special reason it couldn't be used to improve
 *		rendering of rich text as well.
 */
BYTE CCcs::BestCharRep(
	BYTE iCharRep, 
	BYTE iCharRepDefault,
	int  fFontMatching)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::BestCharSet");

	// Does desired charset match currently selected charset or is it
	// supported by the currently selected font?
	if((iCharRep != CharRepFromCharSet(_bCharSet) || !iCharRep) &&
		(fFontMatching == MATCH_CURRENT_CHARSET || !(_qwFontSig & FontSigFromCharRep(iCharRep))))
	{
		// If desired charset is not selected and we can't switch to it,
		// switch to fallback charset (probably from backing store).
		return iCharRepDefault;
	}

	// We already match desired charset, or it is supported by the font.
	// Either way, we can just return the requested charset.
	return iCharRep;
}


/* 	
 *	CCcs::FillWidth (ch, &dup)
 *
 *	@mfunc
 *		Fill in width for given character. Sometimes we don't
 *		call the OS for the certain characters because fonts have bugs.
 *
 *	@rdesc
 *		TRUE if OK, FALSE if failed
 */
BOOL CCcs::FillWidth(
	WCHAR ch, 	//@parm WCHAR character we need a width for.
	LONG &dup)	//@parm the width of the character
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::FillWidth");
	AssertSz(_hfont, "CCcs::Fill - CCcs has no font");
	dup = 0;
	WCHAR chWidth = ch;

	HFONT hfontOld = SelectFont(_hdc, _hfont);

	BOOL fLookaside = _widths.FLookasideCharacter(ch);

	if (fLookaside)
		chWidth = 0x4E00;
	else switch(ch)
	{
	case NBHYPHEN:
	case SOFTHYPHEN:
		chWidth = '-';
		break;

	case NBSPACE:
		chWidth = ' ';
		break;

	case EMSPACE:
		chWidth = EMDASH;
		break;

	case ENSPACE:
		chWidth = ENDASH;
		break;
	}

	W32->REGetCharWidth(_hdc, chWidth, (INT*) &dup, _wCodePage, _fCustomTextOut);

	dup -= _xOverhangAdjust;
	if (dup <= 0)
		dup = max(_xAveCharWidth, 1);

	if (fLookaside)
		_widths._dupCJK = dup;
	else
	{
		CacheEntry *pWidthData = _widths.GetEntry(ch);		
		pWidthData->ch = ch;
		pWidthData->width = dup;
	}

	SelectFont(_hdc, hfontOld);
	return TRUE;
}

/* 	
 *	BOOL CCcs::MakeFont(pCF)
 *
 *	@mfunc
 *		Wrapper, setup for CreateFontIndirect() to create the font to be
 *		selected into the HDC.
 *
 *	@devnote The pCF here is in logical units
 *
 *	@rdesc
 *		TRUE if OK, FALSE if allocation failure
 */
BOOL CCcs::MakeFont(
	const CCharFormat * const pCF)	//@parm description of desired logical font
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::MakeFont");
	LONG	iFont = pCF->_iFont;
	LOGFONT	lf;
	ZeroMemory(&lf, sizeof(lf));

	_bCMDefault = pCF->_dwEffects & CFE_RUNISDBCS ? CVT_LOWBYTE : CVT_NONE;

	_yHeightRequest = pCF->_yHeight;
	_bCharSetRequest = CharSetFromCharRep(pCF->_iCharRep);

	_fCustomTextOut = (pCF->_dwEffects & CFE_CUSTOMTEXTOUT) ? TRUE : FALSE;

	lf.lfHeight = -_yHeightRequest;

	if(pCF->_wWeight)
		_weight = pCF->_wWeight;
	else
		_weight	= (pCF->_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

	lf.lfWeight	 = _weight;
	lf.lfItalic	 = _fItalic = (pCF->_dwEffects & CFE_ITALIC) != 0;
	lf.lfCharSet = _bCMDefault == CVT_LOWBYTE ? ANSI_CHARSET : CharSetFromCharRep(pCF->_iCharRep);
	if (lf.lfCharSet == PC437_CHARSET)
		lf.lfCharSet = DEFAULT_CHARSET;

	lf.lfOutPrecision = OUT_DEFAULT_PRECIS;

	if (_tflow)
		lf.lfOrientation = lf.lfEscapement = (4 - _tflow) * 900;

#ifndef UNDER_CE
	if (_fForceTrueType || _tflow && g_fc->GetInfoFlags(GetFontNameIndex(lf.lfFaceName)).fBitmap)
	{
		lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
		if (!W32->OnWin9x() && g_fc->GetInfoFlags(iFont).fTrueType)
			lf.lfOutPrecision = OUT_SCREEN_OUTLINE_PRECIS;
	}
#endif

	lf.lfClipPrecision	= CLIP_DFA_OVERRIDE;
	lf.lfPitchAndFamily = _bPitchAndFamily = pCF->_bPitchAndFamily;
	lf.lfQuality		= _bQuality		   = pCF->_bQuality;

#ifdef UNDER_CE
	// DEBUGGGGGG for EBOOK!!  Presumably this should be a registry setting
	// that overrules DEFAULT_QUALITY (0) the way ANTIALIASED_QUALITY, etc., do
#ifndef CLEARTYPE_QUALITY
#define CLEARTYPE_QUALITY	5
#endif
	lf.lfQuality = CLEARTYPE_QUALITY;
#endif

	// If family is virtual BiDi family (FF_BIDI), replace by FF_ROMAN
	if((lf.lfPitchAndFamily & 0xF0) == (FF_BIDI << 4))
		lf.lfPitchAndFamily = (FF_ROMAN << 4) | (lf.lfPitchAndFamily & 0xF);

	// If the run is DBCS, that means the font's codepage is not available in
	// this system.  Use the English ANSI codepage instead so we will display
	// ANSI characters correctly.  NOTE: _wCodePage is only used for Win95.
	_wCodePage = CodePageFromCharRep(CharRepFromCharSet(lf.lfCharSet));

	wcscpy(lf.lfFaceName, GetFontName(iFont));

	if (_fUseAtFont && lf.lfFaceName[0] != L'@')
	{
		wcscpy(&(lf.lfFaceName[1]), GetFontName(iFont));
		lf.lfFaceName[0] = L'@';
	}
	// In BiDi system, always create ANSI bitmap font with system charset
	BYTE 	bCharSetSys = W32->GetSysCharSet();

	if (IsBiDiCharSet(bCharSetSys) && lf.lfCharSet == ANSI_CHARSET &&
		fc().GetInfoFlags(iFont).fBitmap &&
		!fc().GetInfoFlags(iFont).fBadFaceName)
		lf.lfCharSet = bCharSetSys;

	// Reader! A bundle of spagghetti code lies ahead of you!
	// But go on boldly, for these spagghetti are seasoned with
	// lots of comments, and ... good luck to you...

	HFONT	hfontOriginalCharset = NULL;
	BYTE	bCharSetOriginal = lf.lfCharSet;
	WCHAR	szNewFaceName[LF_FACESIZE];

	if(pCF->_dwEffects & (CFE_BOLD | CFE_ITALIC))
		iFont = -1;							// Don't use cached font info unless
											//  normal font
	GetFontWithMetrics(&lf, szNewFaceName);

	if(0 != wcsicmp(szNewFaceName, lf.lfFaceName))					
	{
		BOOL fCorrectFont = FALSE;
		iFont = -1;							// pCF->_iFont wasn't used

		if(lf.lfCharSet == SYMBOL_CHARSET)					
		{
			// #1. if the face changed, and the specified charset was SYMBOL,
			//     but the face name exists and suports ANSI, we give preference
			//     to the face name

			lf.lfCharSet = ANSI_CHARSET;

			hfontOriginalCharset = _hfont;
			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
				// That's right, ANSI is the asnwer
				fCorrectFont = TRUE;
			else
				// No, fall back by default; the charset we got was right
				lf.lfCharSet = bCharSetOriginal;
		}
		else if(lf.lfCharSet == DEFAULT_CHARSET && _bCharSet == DEFAULT_CHARSET)
		{
			// #2. If we got the "default" font back, we don't know what it means
			// (could be anything) so we veryfy that this guy's not SYMBOL
			// (symbol is never default, but the OS could be lying to us!!!)
			// we would like to veryfy more like whether it actually gave us
			// Japanese instead of ANSI and labeled it "default"...
			// but SYMBOL is the least we can do

			lf.lfCharSet = SYMBOL_CHARSET;
			wcscpy(lf.lfFaceName, szNewFaceName);

			hfontOriginalCharset = _hfont;
			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
				// That's right, it IS symbol!
				// 'correct' the font to the 'true' one,
				//  and we'll get fMappedToSymbol
				fCorrectFont = TRUE;
				
			// Always restore the charset name, we didn't want to
			// question the original choice of charset here
			lf.lfCharSet = bCharSetOriginal;
		}
		else if(lf.lfCharSet == ARABIC_CHARSET || lf.lfCharSet == HEBREW_CHARSET)
		{
			DestroyFont();
			wcscpy(lf.lfFaceName, szNewFaceName);
			GetFontWithMetrics(&lf, szNewFaceName);
			fCorrectFont = TRUE;
		}
		else if(_bConvertMode != CVT_LOWBYTE && IsFECharSet(lf.lfCharSet)
			&& !OnWinNTFE() && !W32->OnWin9xFE())
		{
			const WCHAR *pch = NULL;
			if(_bCharSet != lf.lfCharSet && W32->OnWin9x())
			{
				// On Win95 when rendering to PS driver, we'll get something
				// other than what we asked. So try a known font we got from GDI
				switch (lf.lfCharSet)
				{
					case CHINESEBIG5_CHARSET:
						pch = GetFontName(g_iFontBig5);
						break;

					case SHIFTJIS_CHARSET:
						pch = GetFontName(g_iFontJapanese);
						break;

					case HANGEUL_CHARSET:
						pch = GetFontName(g_iFontHangul);
						break;

					case GB2312_CHARSET:
						pch = GetFontName(g_iFontGB2312);
						break;
				}
			}
			else							// FE Font (from Lang pack)
				pch = szNewFaceName;		//  on a nonFEsystem

			if(pch)
				wcscpy(lf.lfFaceName, pch);
			hfontOriginalCharset = _hfont;		

			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
			{
				// That's right, it IS the FE font we want!
				// 'correct' the font to the 'true' one.
				fCorrectFont = TRUE;
				if(W32->OnWin9x())
				{
					// Save up the GDI font names for later printing use
					switch(lf.lfCharSet)
					{
						case CHINESEBIG5_CHARSET:
							g_iFontBig5 = GetFontNameIndex(lf.lfFaceName);
							break;

						case SHIFTJIS_CHARSET:
							g_iFontJapanese = GetFontNameIndex(lf.lfFaceName);
							break;

						case HANGEUL_CHARSET:
							g_iFontHangul = GetFontNameIndex(lf.lfFaceName);
							break;

						case GB2312_CHARSET:
							g_iFontGB2312 = GetFontNameIndex(lf.lfFaceName);
							break;
					}
				}
			}
		}

		if(hfontOriginalCharset)
		{
			// Either keep old font or new one		
			if(fCorrectFont)
			{
				SideAssert(DeleteObject(hfontOriginalCharset));
			}
			else
			{
				// Fall back to original font
				DestroyFont();
				_hfont = hfontOriginalCharset;
				GetMetrics();
			}
			hfontOriginalCharset = NULL;
		}
	}

RetryCreateFont:
	{
		// Could be that we just plain simply get mapped to symbol.
		// Avoid it
		BOOL fMappedToSymbol =	(_bCharSet == SYMBOL_CHARSET &&
								 lf.lfCharSet != SYMBOL_CHARSET);

		BOOL fChangedCharset = (_bCharSet != lf.lfCharSet &&
								lf.lfCharSet != DEFAULT_CHARSET);

		if(fChangedCharset || fMappedToSymbol)
		{
			// Here, the system did not preserve the font language or mapped
			// our non-symbol font onto a symbol font, which will look awful
			// when displayed.  Giving us a symbol font when we asked for a
			// non-symbol font (default can never be symbol) is very bizarre
			// and means that either the font name is not known or the system
			// has gone complete nuts. The charset language takes priority
			// over the font name.  Hence, I would argue that nothing can be
			// done to save the situation at this point, and we have to
			// delete the font name and retry.

			if (fChangedCharset && lf.lfCharSet == THAI_CHARSET && _bCharSet == ANSI_CHARSET)
			{
				// We have charset substitution entries in Thai platforms that
				// will substitute all the core fonts with THAI_CHARSET to
				// ANSI_CHARSET. This is because we dont have Thai in such fonts.
				// Here we'll internally substitute the core font to Thai default
				// font so it matches its underlying THAI_CHARSET request (wchao).

				SHORT	iDefFont;
				BYTE	yDefHeight;
				BYTE	bDefPaf;

				W32->GetPreferredFontInfo(THAI_INDEX, TRUE, iDefFont, (BYTE&)yDefHeight, bDefPaf);

				const WCHAR* szThaiDefault = GetFontName(iDefFont);

				if (szThaiDefault)
				{
					DestroyFont();
					wcscpy(lf.lfFaceName, szThaiDefault);
					GetFontWithMetrics(&lf, szNewFaceName);
					goto GetOutOfHere;
				}
			}

			if(!wcsicmp(lf.lfFaceName, szFontOfChoice))
			{
				// We've been here already; no font with an appropriate
				// charset is on the system. Try getting the ANSI one for
				// the original font name. Next time around, we'll null
				// out the name as well!!
				if (lf.lfCharSet == ANSI_CHARSET)
				{
					TRACEINFOSZ("Asking for ANSI ARIAL and not getting it?!");

					// Those Win95 guys have definitely outbugged me
					goto GetOutOfHere;
				}

				DestroyFont();
				wcscpy(lf.lfFaceName, GetFontName(pCF->_iFont));
				lf.lfCharSet = ANSI_CHARSET;
			}
			else
			{
				DestroyFont();
				wcscpy(lf.lfFaceName, szFontOfChoice);
			}
			GetFontWithMetrics(&lf, szNewFaceName);
			goto RetryCreateFont;
		}
    }

GetOutOfHere:
	if (hfontOriginalCharset)
		SideAssert(DeleteObject(hfontOriginalCharset));

	// If we're really really stuck, get system font and hope for the best
	if(!_hfont)
	{
		iFont = IFONT_SYSTEM;
		_hfont = W32->GetSystemFont();
	}

	// Cache essential FONTSIGNATURE and GetFontLanguageInfo() information
	Assert(_hfont);
	if(iFont >= 0)							// Use cached value
		_qwFontSig = GetFontSignatureFromFace(iFont, NULL);

	if(_hfont && (iFont < 0 || _fCustomTextOut))
	{
		BOOL  fNonBiDiAscii;
		HFONT hfontOld = SelectFont(_hdc, _hfont);

		if (_fCustomTextOut)
			g_pcto->NotifyCreateFont(_hdc);

		if(iFont < 0)
			_qwFontSig = GetFontSignatureFromDC(_hdc, fNonBiDiAscii);

		SelectFont(_hdc, hfontOld);
	}

	return TRUE;
}

/*
 *	HFONT CCcs::GetFontWithMetrics (plf, szNewFaceName)
 *	
 *	@mfunc
 *		Get metrics used by the measurer and renderer and the new face name.
 *
 *	@rdesc
 *		HFONT if successful
 */
HFONT CCcs::GetFontWithMetrics (
	LOGFONT *plf,
	WCHAR *	 szNewFaceName)
{
	_hfont = CreateFontIndirect(plf);
    if(_hfont)
		GetMetrics(szNewFaceName);

	return (_hfont);
}

/*
 *	CCcs::GetOffset(pCF, dvpInch, pyOffset, pyAdjust);
 *	
 *	@mfunc
 *		Return the offset information for
 *
 *	@comm
 *		Return the offset value (used in line height calculations)
 *		and the amount to raise	or lower the text because of superscript
 *		or subscript considerations.
 */
void CCcs::GetOffset(
	const CCharFormat * const pCF, 
	LONG	dvpInch,
	LONG *	pyOffset, 
	LONG *	pyAdjust)
{
	*pyOffset = 0;
	*pyAdjust = 0;

	if (pCF->_yOffset)
		*pyOffset = MulDiv(pCF->_yOffset, dvpInch, LY_PER_INCH);

	if (pCF->_dwEffects & CFE_SUPERSCRIPT)
		*pyAdjust = _yHeight * 2 / 5;

	else if (pCF->_dwEffects & CFE_SUBSCRIPT)
		*pyAdjust = -_yDescent * 3 / 5;
}

/*
 *	void CCcs::GetFontOverhang(pdupOverhang, pdupUnderhang)
 *	
 *	@mfunc
 *		Synthesize font overhang/underhang information.
 *		Only applies to italic fonts.
 */
void CCcs::GetFontOverhang(
	LONG *pdupOverhang, 
	LONG *pdupUnderhang)
{
	if(_fItalic)
	{
		*pdupOverhang =  (_yHeight - _yDescent + 1) / 4;
		*pdupUnderhang =  (_yDescent + 1) / 4;
	}
	else
	{
		*pdupOverhang = 0;
		*pdupUnderhang = 0;
	}
}

/*
 *	BOOL CCcs::GetMetrics(szNewFaceName)
 *	
 *	@mfunc
 *		Get metrics used by the measurer and renderer.
 *
 *	@rdesc
 *		TRUE if successful
 *
 *	@comm
 *		These are in logical coordinates which are dependent
 *		on the mapping mode and font selected into the hdc.
 */
BOOL CCcs::GetMetrics(
	WCHAR *szNewFaceName)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::GetMetrics");
	AssertSz(_hfont, "No font has been created.");

	if (szNewFaceName)
		*szNewFaceName = 0;

	HFONT hfontOld = SelectFont(_hdc, _hfont);
    if(!hfontOld)
    {
        DestroyFont();
        return FALSE;
    }

	if (szNewFaceName)
		GetTextFace(_hdc, LF_FACESIZE, szNewFaceName);

	TEXTMETRIC tm;
	if(!GetTextMetrics(_hdc, &tm))
	{
		SelectFont(_hdc, hfontOld);
    	DestroyFont();
		return FALSE;
	}

	// The metrics, in logical units, dependent on the map mode and font.
	_yHeight		= (SHORT) tm.tmHeight;
	_yDescent		= (SHORT) tm.tmDescent;
	_xAveCharWidth	= (SHORT) tm.tmAveCharWidth;
	_xOverhangAdjust= (SHORT) tm.tmOverhang;

	// If fixed pitch, the tm bit is clear
	_fFixPitchFont = !(TMPF_FIXED_PITCH & tm.tmPitchAndFamily);

	_bCharSet = tm.tmCharSet;
	_fFECharSet = IsFECharSet(_bCharSet);

	// Use convert-mode proposed by CF, for which we are creating the font and
	// then tweak as necessary below.
	_bConvertMode = _bCMDefault;

	// If SYMBOL_CHARSET is used, use the A APIs with the low bytes of the
	// characters in the run
	if(_bCharSet == SYMBOL_CHARSET)
		_bConvertMode = CVT_LOWBYTE;

	else if (_bConvertMode == CVT_NONE)
		_bConvertMode = W32->DetermineConvertMode(_hdc, tm.tmCharSet);

	W32->CalcUnderlineInfo(_hdc, this, &tm);

	SelectFont(_hdc, hfontOld);
	return TRUE;
}

/* 	
 *	CCcs::DestroyFont()
 *
 *	@mfunc
 *		Destroy font handle for this CCcs
 */
void CCcs::DestroyFont()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::DestroyFont");

	// Clear out any old font
	if(_hfont)
	{
		SideAssert(DeleteObject(_hfont));
		_hfont = 0;
	}
}

/*
 *	CCcs::Compare (pCF,	hdc, dwFlags)
 *
 *	@mfunc
 *		Compares this font cache with the font properties of a
 *      given CHARFORMAT

 *	@devnote The pCF size here is in logical units
 *
 *	@rdesc
 *		FALSE iff did not match exactly.
 */
BOOL CCcs::Compare (
	const CCharFormat * const pCF,	//@parm Description of desired font
	HDC		hdc,
	DWORD	dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Compare");

	BYTE bCharSet = CharSetFromCharRep(pCF->_iCharRep);
	BOOL result =
		_iFont			== pCF->_iFont &&
        _weight			== pCF->_wWeight &&
	    _fItalic		== ((pCF->_dwEffects & CFE_ITALIC) != 0) &&
		_hdc			== hdc &&
		_yHeightRequest	== pCF->_yHeight &&
		(_bCharSetRequest == bCharSet || _bCharSet == bCharSet
		//	|| _qwFontSig & FontSigFromCharRep(pCF->_iCharRep)// FUTURE:
		) &&	//  ok except for codepage conversions (metafiles and Win9x)
		_fCustomTextOut == ((pCF->_dwEffects & CFE_CUSTOMTEXTOUT) != 0) &&
		_fForceTrueType == ((dwFlags & FGCCSUSETRUETYPE) != 0) &&
		_fUseAtFont		== ((dwFlags & FGCCSUSEATFONT) != 0) &&
		_tflow			== (dwFlags & 0x3) &&
        _bPitchAndFamily == pCF->_bPitchAndFamily &&
		(!(pCF->_dwEffects & CFE_RUNISDBCS) || _bConvertMode == CVT_LOWBYTE);

	return result;
}

// =========================  WidthCache by jonmat  =========================
/*
 *	CWidthCache::CheckWidth(ch, &dup)
 *	
 *	@mfunc
 *		Check to see if we have a width for a WCHAR character.
 *
 *	@comm
 *		Used prior to calling FillWidth(). Since FillWidth
 *		may require selecting the map mode and font in the HDC,
 *		checking here first saves time.
 *
 *	@comm
 *		Statistics are maintained to determine when to
 *		expand the cache. The determination is made after a constant
 *		number of calls in order to make calculations faster.
 *
 *	@rdesc
 *		returns TRUE if we have the width of the given WCHAR.
 */
BOOL CWidthCache::CheckWidth (
	const WCHAR ch,		//@parm char, can be Unicode, to check width for
	LONG &		dup)	//@parm Width of character
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CheckWidth");
	BOOL	fExist;

	// 30,000 FE characters all have the same width
	if (FLookasideCharacter(ch))
	{
		dup = _dupCJK;
		return dup != 0;
	}

	const	CacheEntry * pWidthData = GetEntry ( ch );

	fExist = (ch == pWidthData->ch		// Have we fetched the width?
				&& pWidthData->width);	//  only because we may have ch == 0.

	dup = fExist ? pWidthData->width : 0;

	if(!_fMaxPerformance)				//  if we have not grown to the max...
	{
		_accesses++;
		if(!fExist)						// Only interesting on collision.
		{
			if(0 == pWidthData->width)	// Test width not ch, 0 is valid ch.
			{
				_cacheUsed++;			// Used another entry.
				AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
			}
			else
				_collisions++;			// We had a collision.

			if(_accesses >= PERFCHECKEPOCH)
				CheckPerformance();		// After some history, tune cache.
		}
	}
#ifdef DEBUG							// Continue to monitor performance
	else
	{
		_accesses++;
		if(!fExist)						// Only interesting on collision.
		{
			if(0 == pWidthData->width)	// Test width not ch, 0 is valid ch.
			{
				_cacheUsed++;			// Used another entry.
				AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
			}
			else
				_collisions++;			// We had a collision.
		}

		if(_accesses > PERFCHECKEPOCH)
		{
			_accesses = 0;
			_collisions = 0;
		}
	}
#endif

	return fExist;
}

/*
 *	CWidthCache::CheckPerformance()
 *	
 *	@mfunc
 *		check performance and increase cache size if deemed necessary.
 *
 */
void CWidthCache::CheckPerformance()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CheckPerformance");

	if(_fMaxPerformance)				// Exit if already grown to our max.
		return;

	// Grow the cache when cacheSize > 0 && 75% utilized or approx 8%
	// collision rate
	if (_cacheSize > DEFAULTCACHESIZE && (_cacheSize >> 1) + (_cacheSize >> 2) < _cacheUsed ||
		_collisions > 0 && _accesses / _collisions <= 12)
	{
		GrowCache( &_pWidthCache, &_cacheSize, &_cacheUsed );
	}
	_collisions	= 0;					// This prevents wraps but makes
	_accesses	= 0;					//  calc a local rate, not global.
										
	if(_cacheSize >= maxCacheSize)		// Note if we've max'ed out
		_fMaxPerformance = TRUE;

	AssertSz( _cacheSize <= maxCacheSize, "max must be 2^n-1");
	AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
}

/*
 *	CWidthCache::GrowCache(ppWidthCache, pCacheSize, pCacheUsed)
 *	
 *	@mfunc
 *		Exponentially expand the size of the cache.
 *
 *	@comm
 *		The cache size must be of the form 2^n as we use a
 *		logical & to get the hash MOD by storing 2^n-1 as
 *		the size and using this as the modulo.
 *
 *	@rdesc
 *		Returns TRUE if we were able to allocate the new cache.
 *		All in params are also out params.
 *		
 */
BOOL CWidthCache::GrowCache(
	CacheEntry **ppWidthCache,	//@parm cache
	INT *		pCacheSize,		//@parm cache's respective size.
	INT *		pCacheUsed)		//@parm cache's respective utilization.
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::GrowCache");

	CacheEntry		*pNewWidthCache, *pOldWidthCache, *pWidthData;
	INT 			j, newCacheSize, newCacheUsed;
	WCHAR			ch;
	
	j = *pCacheSize;						// Allocate cache of 2^n.
	newCacheSize = max ( INITIALCACHESIZE, (j << 1) + 1);
	pNewWidthCache = (CacheEntry *)
			PvAlloc( sizeof(CacheEntry) * (newCacheSize + 1 ), GMEM_ZEROINIT);

	if(pNewWidthCache)
	{
		newCacheUsed = 0;
		*pCacheSize = newCacheSize;			// Update out params.
		pOldWidthCache = *ppWidthCache;
		*ppWidthCache = pNewWidthCache;
		for (; j >= 0; j--)					// Move old cache info to new.
		{
			ch = pOldWidthCache[j].ch;
			if ( ch )
			{
				pWidthData			= &pNewWidthCache [ch & newCacheSize];
				if ( 0 == pWidthData->ch )
					newCacheUsed++;			// Used another entry.
				pWidthData->ch		= ch;
				pWidthData->width	= pOldWidthCache[j].width;
			}
		}
		*pCacheUsed = newCacheUsed;			// Update out param.
											// Free old cache.
		if (pOldWidthCache < &_defaultWidthCache[0] ||
			pOldWidthCache >= &_defaultWidthCache[DEFAULTCACHESIZE+1])
		{
			FreePv(pOldWidthCache);
		}
	}
	return NULL != pNewWidthCache;
}


/*
 *	CWidthCache::Free()
 *	
 *	@mfunc
 *		Free any dynamic memory allocated by the width cache and prepare
 *		it to be recycled.
 */
void CWidthCache::Free()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::Free");

	_fMaxPerformance = FALSE;
	_dupCJK = 0;
	_cacheSize		= DEFAULTCACHESIZE;
	_cacheUsed		= 0;
	_collisions		= 0;
	_accesses		= 0;
	if(_pWidthCache != &_defaultWidthCache[0])
	{
		FreePv(_pWidthCache);
		_pWidthCache = &_defaultWidthCache[0];
	}	
	ZeroMemory(_pWidthCache, sizeof(CacheEntry)*(DEFAULTCACHESIZE + 1));
}

/*
 *	CWidthCache::CWidthCache()
 *	
 *	@mfunc
 *		Point the caches to the defaults.
 */
CWidthCache::CWidthCache()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CWidthCache");

	_pWidthCache = &_defaultWidthCache[0];
}

/*
 *	CWidthCache::~CWidthCache()
 *	
 *	@mfunc
 *		Free any allocated caches.
 */
CWidthCache::~CWidthCache()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::~CWidthCache");

	if (_pWidthCache != &_defaultWidthCache[0])
		FreePv(_pWidthCache);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\frunptr.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	FRUNPTR.C -- FormatRunPtr methods |
 *
 *		common code to handle character and paragraph format runs
 *	
 *	Original Authors: <nl>
 *		Original RichEdit 1.0 code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	History:
 *		6/25/95		alexgo	convert to use Auto-Doc and simplified backing
 *		store model
 *
 *	@devnote
 *		BOR and EOR mean Beginning Of Run and End Of Run, respectively
 *
 *	Copyright (c) 1995-1999, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_rtext.h"
#include "_font.h"

ASSERTDATA

//
//	Invariant stuff
//
#define DEBUG_CLASSNAME	CFormatRunPtr

#include "_invar.h"

#ifdef DEBUG
/*
 *	CFormatRunPtr::Invariant
 *
 *	@mfunc	Invariant for format run pointers
 *
 *	@rdesc	BOOL
 */
BOOL CFormatRunPtr::Invariant() const
{
	if(IsValid())
	{
		CFormatRun *prun = GetRun(0);
		if(prun && _iRun)
		{
			Assert(prun->_cch > 0);
		}
	}
	else
	{
		Assert(_ich == 0);
	}
	return CRunPtrBase::Invariant();
}
#endif

/*
 *	CFormatRunPtr::InitRuns(ich, cch, iFormat, ppfrs)
 *
 *	@mfunc
 *		Setup this format run ptr for rich-text operation, namely,
 *		allocate CArray<lt>CFormatRun<gt> if not allocated, assign it to this
 *		run ptr's _pRuns, add initial run if no runs are present, and store
 *		initial cch and ich
 *	
 *	@rdesc
 *		TRUE if succeeds
 */
BOOL CFormatRunPtr::InitRuns(
	LONG ich,				//@parm # chars in initial run
	LONG cch,				//@parm char offset in initial run
	CFormatRuns **ppfrs)	//@parm ptr to CFormatRuns ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::InitRuns");

	_TEST_INVARIANT_

	AssertSz( ppfrs,
		"FRP::InitRuns: illegal ptr to runs");
	AssertSz( !IsValid(),
		"FRP::InitRuns: ptr already valid");

	if(!*ppfrs)									// Allocate format runs
	{
		_pRuns = (CRunArray *) new CFormatRuns();
		if(!_pRuns)
			goto NoRAM;
		*ppfrs = (CFormatRuns *)_pRuns;
	}
	else										// Format runs already alloc'd
		_pRuns = (CRunArray *)*ppfrs;			// Cache ptr to runs

	if(!Count())								// No runs yet, so add one
	{
		CFormatRun *pRun= Add(1, NULL);
		if(!pRun)
			goto NoRAM;

#ifdef DEBUG
		PvSet(*(void**)_pRuns);
#endif
		_ich			= ich;

		ZeroMemory(pRun, sizeof(*pRun));
		pRun->_cch		= cch;					// Define its _cch
		pRun->_iFormat 	= -1;					//  and _iFormat
	}
	else
		BindToCp(ich);							// Format runs are in place

	return TRUE;

NoRAM:
	TRACEERRSZSC("CFormatRunPtr::InitRuns: Out Of RAM", E_OUTOFMEMORY);
	return FALSE;
}


/*
 *	CFormatRunPtr::Delete(cch, pf, cchMove)
 *	
 *	@mfunc
 *		Delete/modify runs starting at this run ptr up to cch chars. <nl>
 *		There are 7 possibilities: <nl>
 *		1.	cch comes out of this run with count left over, i.e.,
 *			cch <lt>= (*this)->_cch - _ich && (*this)->_cch > cch
 *			(simple: no runs deleted/merged, just subtract cch) <nl>
 *		2.	cch comes out of this run and empties run and doc
 *			(simple: no runs left to delete/merge) <nl>
 *		3.	cch comes out of this run and empties run, which is last
 *			(need to delete run, no merge possibility) <nl>
 *		4.	cch comes out of this run and empties run, which is first
 *			(need to delete run, no merge possibility) <nl>
 *		5.	cch exceeds count available in this run and this run is last
 *			(simple: treat as 3.)  <nl>
 *		6.	cch comes out of this run and empties run with runs before
 *			and after (need to delete run; merge possibility) <nl>
 *		7.	cch comes partly out of this run and partly out of later run(s)
 *			(may need to delete and merge) <nl>
 *
 *	@comm
 *		PARAFORMATs have two special cases that use the cchMove argument set
 *		up in CRchTxtPtr::ReplaceRange().
 */
void CFormatRunPtr::Delete(
	LONG		  cch,		//@parm # chars to modify format runs for
	IFormatCache *pf,		//@parm IFormatCache ptr for ReleaseFormat
	LONG		  cchMove)	//@parm cch to move between runs (always 0 for CF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::Delete");

	_TEST_INVARIANT_

	// We should not have any boundary cases for empty or NULL pointers.
	// (i.e. if there's no text, then nobody should be calling delete).

	Assert(IsValid());

	LONG			cchEnd = 0;				// Probably unnecessary: see below
	LONG			cRun = 1;
	BOOL			fLast = (_iRun == Count() - 1);
	LONG			ifmtEnd, ifmtStart;
	CFormatRun *	pRun = Elem(_iRun);
	CFormatRun *	pRunRp;
	LONG			cchChunk = pRun->_cch - _ich;
	CFormatRunPtr	rp(*this);				// Clone this run ptr
    CBiDiLevel      levelStart = {0,0};
    CBiDiLevel      levelEnd = {0,0};

	rp.AdjustBackward();					// If at BOR, move to prev EOR
	ifmtStart = rp.GetRun(0)->_iFormat;		//  to get start format
    levelStart = rp.GetRun(0)->_level;      // and level
	rp = *this;								// In case RpAdjustCp() backed up

// Process deletes confined to this run first, since their logic tends to
// clutter up other cases

	AssertSz(cch >= 0, "FRP::Delete: cch < 0");

	if(fLast)								// Handle oversized cch on last
		cch = min(cch, cchChunk); 			//  run here

	if(cch <= cchChunk)						// cch comes out of this run
	{
		pRun->_cch -= cch;
		Assert(pRun->_cch >= 0);
		if(cchMove)							// If nonzero here, we are
		{									//  deleting EOP at end of run
			rp.AdjustForward();				// Adjust rp to beginning of
			goto move;						//  next run and go move cchMove
		}									//  chars back into this run
		if(pRun->_cch)						// Something left in run: done
			return;
											// Note: _ich = 0
		if(!_iRun || fLast)					// This run is either first
		{									//  or last
			AdjustBackward();				// If last, go to prev EOR
			if(_ich)						// This run is empty so delete
				cRun++;						// Compensate for cRun-- coming up
			ifmtStart = -2;					// No runs eligible for merging
		}									//  so use unmatchable ifmtStart
		rp.NextRun();						// Set up to get next _iFormat
	}		
	else
	{
		rp.Move(cch);						// Move clone to end of delete
		pRunRp = rp.GetRun(0);
		cRun = rp._iRun - _iRun				// If at EOR, then need to add
			 + (rp._ich == pRunRp->_cch);	//  one more run to delete
		pRun->_cch = _ich;					// Shorten this run to _ich chars
		pRunRp->_cch -= rp._ich;			// Shorten last run by rp._ich
		rp._ich = 0;

		Assert(pRunRp->_cch >= 0);
		AssertSz(cRun > 0, "FRP: bogus runptr");

		if(!_iRun)		  					// First run?
			ifmtStart = -2;					// Then we cannot merge runs so
	}										//  set to unmergable format

	ifmtEnd = -3;							// Default invalid format at end
	if(rp.IsValid())
	{
		// FUTURE (murrays): probably rp is always valid here now and
		// pRun->_cch is nonzero
		pRun = rp.GetRun(0);
		if (pRun->_cch)                     // run not empty
		{
			ifmtEnd = pRun->_iFormat;		// Remember end format and count
            levelEnd = pRun->_level;
			cchEnd  = pRun->_cch;			//  in case of merge
		}
		else if(rp._iRun != rp.Count() - 1)	// run not last
		{
			pRun = rp.GetRun(1);
			ifmtEnd = pRun->_iFormat;		// Remember end format and count
            levelEnd = pRun->_level;
			cchEnd  = pRun->_cch;			//  in case of merge
		}
	}

	rp = *this;								// Default to delete this run
	if(_ich)								// There are chars in this run
	{
		if(cchMove + _ich == 0)				// Need to combine all chars of
		{									//  this run with run after del,
			pf->AddRef(ifmtEnd);			//  so setup merge below using
			ifmtStart = ifmtEnd;			//  ifmtEnd. This run then takes
			pf->Release(GetRun(0)->_iFormat);
			GetRun(0)->_iFormat = ifmtEnd;	//  place of run after del.
            GetRun(0)->_level = levelEnd;
			cchMove = 0;					// cchMove all accounted for
		}
		rp.NextRun();						// Don't delete this run; start
		cRun--;								//  with next one
	}

	AdjustBackward();						// If !_ich, go to prev EOR

    if(ifmtEnd >=0 &&                       // Same formats: merge runs
       ifmtEnd == ifmtStart &&
       levelStart == levelEnd)
	{
		GetRun(0)->_cch += cchEnd;			// Add last-run cch to this one's
		Assert(GetRun(0)->_cch >= 0);
		cRun++;								// Setup to eat last run
	}

	if(cRun > 0)							// There are run(s) to delete
	{
		rp.Remove(cRun, pf);
		if(!Count())						// If no more runs, keep this rp
			_ich = _iRun = 0;				//  valid by pointing at cp = 0
	}

move:
	if(cchMove)								// Need to move some cch between
	{										//  this run and next (See
		GetRun(0)->_cch += cchMove;			//  CRchTxtPtr::ReplaceRange())
		rp.GetRun(0)->_cch -= cchMove;

		Assert(GetRun(0)->_cch >= 0);
		Assert(rp.GetRun(0)->_cch >= 0);
		Assert(_iRun < rp._iRun);

		if(!rp.GetRun(0)->_cch)				// If all chars moved out of rp's
			rp.Remove(1, pf);				//  run, delete it

		if(cchMove < 0)						// Moved -cchMove chars from this
		{									//  run to next
			if(!GetRun(0)->_cch)
				Remove(1, pf);
			else
				_iRun++;					// Keep this run ptr in sync with

			_ich = -cchMove;				//  cp (can't use NextRun() due
		}									//  to Invariants)
	}
	AdjustForward();						// Don't leave ptr at EOR unless
}											//  there are no more runs

/*
 *	CFormatRunPtr::InsertFormat(cch, ifmt, pf)
 *	
 *	@mfunc
 *		Insert cch chars with format ifmt into format runs starting at
 *		this run ptr	
 *
 *	@rdesc
 *		count of characters added
 *
 *	@devnote	
 *		It is the caller's responsibility to ensure that we are in the
 *		"normal" or "empty" state.  A format run pointer doesn't know about
 *		CTxtStory, so it can't create the run array without outside help.
 */
LONG CFormatRunPtr::InsertFormat(
	LONG cch,				//@parm # chars to insert
	LONG ifmt,				//@parm format to use
	IFormatCache *pf)		//@parm pointer to IFormatCache to AddRefFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::InsertFormat");

	LONG		cRun;
	CFormatRun *pRun;
	CFormatRun *pRunPrev;
	LONG		cchRun;						// Current-run length,
	LONG		ich;						//  offset, and
	LONG		iFormat; 					//  format

	_TEST_INVARIANT_

	Assert(_pRuns);
	if(!IsValid())
	{		
		// Empty run case (occurs when inserting after all text is deleted)
		pRun = Add(1, NULL);
		goto StoreNewRunData;				// (located at end of function)
	}

	// Go to previous run if at a boundary case
	AdjustBackward();
	pRun	= Elem(_iRun);					// Try other cases
	cchRun 	= pRun->_cch;
	iFormat = pRun->_iFormat;
	ich 	= _ich;							

	// Same run case.  Note that there is an additional boundary case; if we
	// are the _end_ of one run, then the next run may have the necessary
	// format.
	if(ifmt == iFormat)						// IP already has correct fmt
	{
		pRun->_cch	+= cch;
		_ich		+= cch;					// Inc offset to keep in sync
		return cch;
	}
	if(_ich == pRun->_cch && _iRun < _pRuns->Count() - 1)
	{
		AdjustForward();
		pRun = Elem(_iRun);

		Assert(pRun);

		if(pRun->_iFormat == ifmt)
		{
			pRun->_cch += cch;
			_ich += cch;
			return cch;
		}
		AdjustBackward();
	}

	// Prior run case (needed when formatting change occurs on line break
	//		and caret is at beginning of new line)
	if(!ich && _iRun > 0 )					// IP at start of run
	{
		pRunPrev = GetPtr(pRun, -1);
		if( ifmt == pRunPrev->_iFormat)		// Prev run has same format:
		{									//  add count to prev run and
			pRunPrev->_cch += cch;
			return cch;
		}
	}

	// Create new run[s] cases.  There is a special case for a format
	// run of zero length: just re-use it.
	if(!pRun->_cch)
	{
		// This assert has been toned down to ignore a plain text control
		// being forced into IME Rich Composition.
		AssertSz( /* FALSE */ pRun->_iFormat == -1 && Count() == 1,
			"CFormatRunPtr::InsertFormat: 0-length run");
		pf->Release(pRun->_iFormat);
	}
	else									// Need to create 1 or 2 new
	{										//  runs for insertion
		cRun = 1;							// Default 1 new run
		if(ich && ich < cchRun)				// Not at beginning or end of
			cRun++;							//  run, so need two new runs

		// The following insert call adds one or two runs at the current
		// position. If the new run is inserted at the beginning or end
		// of the current run, the latter needs no change; however, if
		// the new run splits the current run in two, both pieces have
		// to be updated (cRun == 2 case).

		pRun = Insert(cRun);				// Insert cRun run(s)
		if(!pRun)							// Out of RAM. Can't insert
		{									//  new format, but can keep
			_ich += cch;					//  run ptr and format runs
			GetRun(0)->_cch += cch;			//  valid.  Note: doesn't
			return cch;						//  signal any error; no access
		}									//  to _ped->_fErrSpace

		if(ich)								// Not at beginning of run,
		{
			pRunPrev = pRun;				// Previous run is current run
			IncPtr(pRun);					// New run is next run
			VALIDATE_PTR(pRun);
			pRun->_cch = cch;				// Keep NextRun() invariant happy
			NextRun();						// Point this runptr at it too
			if(cRun == 2)					// Are splitting current run
			{								// _iFormat's are already set
				AssertSz(pRunPrev->_iFormat == iFormat,
					"CFormatRunPtr::InsertFormat: bad format inserted");
				pRunPrev->_cch = ich;		// Divide up original cch
				GetPtr(pRun, 1)->_cch		//  accordingly
					= cchRun - ich;
				pf->AddRef(iFormat);		// Addref iFormat for extra run
			}
		}
	}

StoreNewRunData:
	pf->AddRef(ifmt);						// Addref ifmt
	ZeroMemory(pRun, sizeof(*pRun));
	pRun->_iFormat	= ifmt;					// Store insert format and count
	pRun->_cch		= cch;					//  of new run
	_ich			= cch;					// cp goes at end of insertion

	return cch;
}

/*
 *	CFormatRunPtr::MergeRuns(iRun, pf)
 *	
 *	@mfunc
 *		Merge adjacent runs that have the same format between this run
 *		<md CFormatRunPtr::_iRun> and that for <p iRun>		
 *
 *	@comm
 *		Changes this run ptr
 */
void CFormatRunPtr::MergeRuns(
	LONG iRun, 				//@parm last run to check (can preceed or follow
							// <md CFormatRunPtr::_iRun>)
	IFormatCache *pf)		//@parm pointer to IFormatCache to ReleaseFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::MergeRuns");

	LONG	cch;
	LONG	cRuns		= iRun - _iRun;
	LONG	iDirection	= 1;				// Default going forward
	CFormatRun *pRun;

	_TEST_INVARIANT_

	if(cRuns < 0)
	{
		cRuns = -cRuns;
		iDirection = -1;
	}
	if(!IsValid())							// Allow starting run to be
	{										//  invalid
		Assert(FALSE);						// I think this is old...
		ChgRun(iDirection);					
	}

	while(cRuns--)
	{
        if(!GetRun(0)->_cch && !_iRun && _iRun < Count() - 1)
        {
            if(iDirection > 0)
                PrevRun();
            Remove(1, pf);
            continue;
        }

		pRun = GetRun(0);					// Save the current run

		if(!ChgRun(iDirection))				// Go to next (or prev) run
			return;							// No more runs to check

		if(pRun->SameFormat(GetRun(0)))
		{									// Like formatted runs
			if(iDirection > 0)				// Point at the first of the
				PrevRun();					//  two runs
			cch = GetRun(0)->_cch;			// Save its count
			Remove(1, pf);					// Remove it
			GetRun(0)->_cch += cch;			// Add its count to the other's,
		}									//  i.e., they're merged
	}
}

/*
 *	CFormatRunPtr::Remove(cRun, flag, pf)
 *	
 *	@mfunc
 *		Remove cRun runs starting at _iRun
 */
void CFormatRunPtr::Remove(
	LONG		  cRun,
	IFormatCache *pf)
{
	CFormatRun *pRun = GetRun(0);			// Point at run(s) to delete

	for(LONG j = 0; j < cRun; j++, IncPtr(pRun))
		pf->Release(pRun->_iFormat);		// Decrement run reference count

	CRunPtr<CFormatRun>::Remove(cRun);
}

/*
 *	CFormatRunPtr::SetFormat(ifmt, cch, pf, pLevel)
 *	
 *	@mfunc
 *		Set format for up to cch chars of this run to ifmt, splitting run
 *		as needed, and returning the character count actually processed
 *
 *	@rdesc
 *		character count of run chunk processed, CP_INFINITE on failure
 *		this points at next run
 *
 *	Comments:
 *		Changes this run ptr.  cch must be >= 0.
 *
 *		Note 1) for the first run in a series, _ich may not = 0, and 2) cch
 *		may be <lt>, =, or <gt> the count remaining in the run. The algorithm
 *		doesn't split runs when the format doesn't change.
 */
LONG CFormatRunPtr::SetFormat(
	LONG			ifmt, 	//@parm format index to use
	LONG			cch, 	//@parm character count of remaining format range
	IFormatCache *	pf,		//@parm pointer to IFormatCache to
	CBiDiLevel*		pLevel) //@parm pointer to BiDi level structure
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::SetFormat");
							//		AddRefFormat/ReleaseFormat
	LONG			cchChunk;
	LONG			iFormat;
	CFormatRun *	pRun;
	CFormatRun *	pChgRun;	// run that was reformatted
    CBiDiLevel      level;

	_TEST_INVARIANT_

	if(!IsValid())
		return 0;

	pRun 		= GetRun(0);				// pRun points at current run in
	cchChunk 	= pRun->_cch - _ich;		//  this function
	iFormat 	= pRun->_iFormat;
    level       = pRun->_level;
	pChgRun		= pRun;

	AssertSz(cch, "Have to have characters to format!");
	AssertSz(pRun->_cch, "uh-oh, empty format run detected");

    if(ifmt != iFormat || (pLevel && level != *pLevel)) // New and current formats differ
	{
		AssertSz(cchChunk, "Caller did not call AdjustForward");

		if(_ich)							// Not at either end of run: need
		{									//  to split into two runs of
			if(!(pRun = Insert(1)))			//  counts _ich and _pRun->_cch
			{								//  - _ich, respectively
				return CP_INFINITE;			// Out of RAM: do nothing; just
			}								//  keep current format
			pRun->_cch		= _ich;
			pRun->_iFormat	= iFormat;		// New run has same format
            pRun->_level    = level;        // and same level
			pf->AddRef(iFormat);			// Increment format ref count
			NextRun();						// Go to second (original) run
			IncPtr(pRun);					// Point pRun at current run
			pRun->_cch = cchChunk;			// Note: IncPtr is a bit more
			pChgRun = pRun;
		}									//  efficient than GetRun, but
											//  trickier to code right
		if(cch < cchChunk)					// cch doesn't cover whole run:
		{									//  need to split into two runs
			if(!(pRun = Insert(1)))
			{
				// Out of RAM, so formatting's wrong, oh well.  We actually
				// "processed" all of the characters, so return that (though
				// the tail end formatting isn't split out right)
				return cch;
			}
			pRun->_cch = cch;				// New run gets the cch
			pRun->_iFormat = ifmt;			//  and the new format
			pChgRun = pRun;
			IncPtr(pRun);					// Point pRun at current run
			pRun->_cch = cchChunk - cch;	// Set leftover count
		}
		else								// cch as big or bigger than
		{									//  current run
			pf->Release(iFormat);			// Free run's current format
			pRun->_iFormat = ifmt;			// Change it to new format		
			pChgRun = pRun;
		}									// May get merged later
		pf->AddRef(ifmt);					// Increment new format ref count
	}
	else if(!cchChunk)
	{
		pRun->_cch += cch;					// Add cch to end of current run
		cchChunk = cch;						// Report that all cch are done
		IncPtr(pRun);
		pRun->_cch -= cch;					// Remove count from next run
		if(!pRun->_cch)						// Next run is now empty, so 
		{									//  remove it
			_iRun++;
			Remove(1, pf);			
			_iRun--;						// Backup to start run
		}
	}

	// Record embedding level to changed run
	if (pLevel)
		pChgRun->_level = *pLevel;

	cch = min(cch, cchChunk);
	Move(cch);
	AdjustForward();
	return cch;
}

/*
 *	CFormatRunPtr::GetFormat()
 *
 *	@mfunc
 *		return format index at current run pointer position
 *
 *	@rdesc
 *		current format index
 */
short CFormatRunPtr::GetFormat() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::GetFormat");
	_TEST_INVARIANT_

	return IsValid() ? GetRun(0)->_iFormat : -1;
}


/*
 *	CFormatRunPtr::SplitFormat(IFormatCache*)
 *
 *	@mfunc
 *		Split a format run
 *
 *	@rdesc
 *		If succeeded the run pointer moves to the next splitted run
 */
void CFormatRunPtr::SplitFormat(IFormatCache* pf)
{
	if (!_ich || _ich == GetRun(0)->_cch)
		return;

	CFormatRun*		pRun = GetRun(0);
	LONG			iFormat = pRun->_iFormat;
	LONG			cch = pRun->_cch - _ich;
	CBiDiLevel		level = pRun->_level;

	if (pRun = Insert(1))
	{
		pRun->_cch = _ich;
		pRun->_iFormat = iFormat;
		pRun->_level = level;
		pf->AddRef(iFormat);
		NextRun();
		IncPtr(pRun);
		pRun->_cch = cch;
	}
}

/*
 *	CFormatRunPtr::SetLevel(level)
 *
 *	@mfunc
 *		Set run's embedding level
 */
void CFormatRunPtr::SetLevel (CBiDiLevel& level)
{
	if (!IsValid())
	{
		Assert(FALSE);
		return;
	}

	CFormatRun*	pRun = GetRun(0);

	if (pRun)
		pRun->_level = level;
}

BYTE CFormatRunPtr::GetLevel (CBiDiLevel* pLevel)
{
	CFormatRun*	pRun;


	if (!IsValid() || !(pRun = GetRun(0)))
	{
		Assert(FALSE);

		if (pLevel)
		{
			pLevel->_value = 0;
			pLevel->_fStart = FALSE;
		}
		return 0;
	}

	if (pLevel)
		*pLevel = pRun->_level;

	return pRun->_level._value;
}

/*
 *	CFormatRunPtr::AdjustFormatting(cch, pf)
 *	
 *	@mfunc
 *		Use the same format index for the cch chars at this run ptr
 *		as that immediately preceeding it (if on run edge).
 *
 *	@devnote
 *		This runptr ends up pointing at what was the preceeding run,
 *		since the current run has been moved into the preceeding run.
 *
 *		FUTURE: might be better to take the cch equal to chars in
 *		the following run.
 */	
void CFormatRunPtr::AdjustFormatting(
	LONG		  cch,		//@parm Count of chars to extend formatting
	IFormatCache *pf)		//@parm Format cache ptr for AddRef/Release
{
	if(!IsValid())
		return;							// Nothing to merge

	CFormatRunPtr rp(*this);
	CBiDiLevel	  level;
										// Move this run ptr to end of
	AdjustBackward();					//  preceeding run (if at run edge)
	rp.AdjustForward();					//  (merge may delete run at entry)
	if(_iRun != rp._iRun)				// On a format edge: copy previous
	{									//  format index over
		GetLevel(&level);
		rp.SetFormat(GetFormat(), cch, pf, &level);	// Format cch chars at this
		rp.MergeRuns(_iRun, pf);			//  runptr
	}
}


///////////////////////////// CCFRunPtr ///////////////////////////////

CCFRunPtr::CCFRunPtr(const CRchTxtPtr &rtp)
		: CFormatRunPtr(rtp._rpCF)
{
	_ped = rtp.GetPed();
}

CCFRunPtr::CCFRunPtr(const CFormatRunPtr &rp, CTxtEdit *ped)
		: CFormatRunPtr(rp)
{
	_ped = ped;
}

/*
 *	CCFRunPtr::IsMask(dwMask, MaskOp)
 *	
 *	@mfunc
 *		return TRUE according to the mask operation MaskOp operating on
 *		_dwEffects.
 *
 *	@rdesc
 *		TRUE if bits in CCharFormat::dwEffects correspond to those in dwMask
 */
BOOL CCFRunPtr::IsMask(
	DWORD	dwMask,		//@parm Bit mask to use on dwEffects
	MASKOP	MaskOp)		//@parm Logic operation for bits
{
	DWORD dwEffects = _ped->GetCharFormat(GetFormat())->_dwEffects;

	if(MaskOp == MO_EXACT)				// Bit masks must be identical
		return dwEffects == dwMask;

	dwEffects &= dwMask;
	if(MaskOp == MO_OR)					// TRUE if one or more effect bits
		return dwEffects != 0;			//  identified by mask are on

	if(MaskOp == MO_AND)				// TRUE if all effect bits
		return dwEffects == dwMask;		//  identified by mask are on

	AssertSz(FALSE, "CCFRunPtr::IsMask: illegal mask operation");
	return FALSE;
}

/*
 *	CCFRunPtr::IsInHidden()
 *	
 *	@mfunc
 *		return TRUE if CCharFormat for this run ptr has CFE_HIDDEN bit set
 *
 *	@rdesc
 *		TRUE if CCharFormat for this run ptr has CFE_HIDDEN bit set
 */
BOOL CCFRunPtr::IsInHidden()
{	
	if (!IsValid())
		return FALSE;		// No format run, not hidden

	AdjustForward();
	BOOL fHidden = IsHidden();
	if(_ich)
		return fHidden;

	AdjustBackward();
	return fHidden && IsHidden();
}

/*
 *	CCFRunPtr::FindUnhidden()
 *	
 *	@mfunc
 *		Find nearest expanded CF going forward. If none, find nearest going
 *		backward.  If none, go to start of document
 *	
 *	@rdesc
 *		cch to nearest expanded CF as explained in function description
 *
 *	@devnote
 *		changes this run ptr
 */
LONG CCFRunPtr::FindUnhidden()
{
	LONG cch = FindUnhiddenForward();

	if(IsHidden())
		cch = FindUnhiddenBackward();

	return cch;
}

/*
 *	CCFRunPtr::FindUnhiddenForward()
 *	
 *	@mfunc
 *		Find nearest expanded CF going forward.  If none, go to EOD
 *	
 *	@rdesc
 *		cch to nearest expanded CF going forward
 *
 *	@devnote
 *		changes this run ptr
 */
LONG CCFRunPtr::FindUnhiddenForward()
{
	LONG cch = 0;

	AdjustForward();
	while(IsHidden())
	{
		cch += GetCchLeft();
		if(!NextRun())
			break;
	}
	return cch;
}

/*
 *	CCFRunPtr::MatchFormatSignature
 *	
 *	@mfunc
 *		Match the current format's font signature with the script (index to codepage).
 *		It takes care single-codepage fonts which implicitly supports ASCII range.
 *
 *	@rdesc
 *		return how font matched
 */

inline int CCFRunPtr::MatchFormatSignature (
	const CCharFormat*	pCF,
	int					iCharRep,
	int					iMatchCurrent,
	QWORD *				pqwFontSig)
{
	QWORD qwFontSig = 0;

	if (GetFontSignatureFromFace(pCF->_iFont, &qwFontSig) != 0)
	{
		if (pqwFontSig)
			*pqwFontSig = qwFontSig;

		if (iMatchCurrent & MATCH_ASCII && fc().GetInfoFlags(pCF->_iFont).fNonBiDiAscii)
			return MATCH_ASCII;

		if (FontSigFromCharRep(iCharRep) & ~FASCII & qwFontSig)
			return MATCH_FONT_SIG;
	}
	return 0;
}

/*
 *	CCFRunPtr::GetPreferredFontInfo(iCharRep, &iCharRepRet, &iFont, &yHeight, &bPitchAndFamily,
 *									iFormat, iMatchCurrent, piFormatOut )
 *	
 *	@mfunc
 *		Find the preferred font for the given code page around the range.
 *
 *	@rdesc
 *		boolean true if suitable font found, false otherwise.
 */
bool CCFRunPtr::GetPreferredFontInfo(
	BYTE	iCharRep,
	BYTE &	iCharRepRet,
	SHORT&	iFont,
	SHORT&	yHeight,				// return in twips
	BYTE&	bPitchAndFamily,
	int		iFormat,
	int		iMatchCurrent,
	int		*piFormatOut)
{
	int				   i;
	bool			   fr = false;
	static int const   MAX_FONTSEARCH = 256;
	const CCharFormat *pCF;
	const CCharFormat *pCFCurrent;
	const CCharFormat *pCFPrevious = NULL;
	int				   iMatch = 0;			// how signature match?
	QWORD			   qwFontSigCurrent = 0;
	SHORT			   yNewHeight = 0;
	bool			   fUseUIFont = _ped->fUseUIFont() || _ped->Get10Mode();

	Assert(!(iMatchCurrent & MATCH_ASCII) || iCharRep == ANSI_INDEX);

	if(_ped->fUseUIFont())
		pCFCurrent = _ped->GetCharFormat(-1);	// Plain text or UI font specified
	else
		pCFCurrent = _ped->GetCharFormat(iFormat != -1 ? iFormat : GetFormat());

	if (iMatchCurrent == GET_HEIGHT_ONLY)	// Just do the font autosizing.
	{
		fr = true;
		pCF = NULL;
		goto DO_SIZE;
	}

	if ((iMatchCurrent & MATCH_FONT_SIG) &&
		(iMatch = MatchFormatSignature(pCFCurrent, iCharRep, iMatchCurrent, &qwFontSigCurrent)) != 0)
	{
		pCF = pCFCurrent;					// Setup to use it
	}
	else
	{
		int iFormatOut;

		// Try searching backwards
		if (IsValid())						// If doc has CF runs
			AdjustBackward();
		i = MAX_FONTSEARCH;					// Don't be searching for years
		iFormatOut = GetFormat();
		pCF = _ped->GetCharFormat(iFormatOut);
		while (i--)
		{
			if(iCharRep == pCF->_iCharRep)	// Equal charset ids?
			{
				pCFPrevious = pCF;
				break;
			}
			if (!PrevRun())					// Done searching?
				break;
			iFormatOut = GetFormat();
			pCF = _ped->GetCharFormat(iFormatOut);
		}
		pCF = pCFPrevious;
		if (piFormatOut && pCF)
		{
			*piFormatOut = iFormatOut;
			return true;					// Done since we only ask for the format.
		}
	}

	// Try match charset if requested
	if(!pCF && iMatchCurrent == MATCH_CURRENT_CHARSET)
	{
		CCcs* pccs = _ped->GetCcs(pCFCurrent, W32->GetYPerInchScreenDC());
		if (pccs)
		{
			if(pccs->BestCharRep(iCharRep, DEFAULT_INDEX, MATCH_CURRENT_CHARSET) != DEFAULT_INDEX)
				pCF = pCFCurrent;			// Current font can do it
			pccs->Release();
		}
	}

	// Try default document format
	if (!pCF)
	{
		pCF = _ped->GetCharFormat(-1);
		if(iCharRep != pCF->_iCharRep)	// Diff charset ids?
			pCF = NULL;
	}

DO_SIZE:
	yHeight = pCFCurrent->_yHeight;		// Assume current height

	if (!pCF)
	{
		// Default to table if no match.
		fr = W32->GetPreferredFontInfo(
			iCharRep, fUseUIFont, iFont, (BYTE&)yNewHeight, bPitchAndFamily );

		if (!_ped->_fAutoFontSizeAdjust && iCharRep == THAI_INDEX)
			// Kick in font size adjusting in first bind to Thai.
			_ped->_fAutoFontSizeAdjust = TRUE;
	}

	if (pCF)
	{
		// Found previous or current font
		iFont = pCF->_iFont;
		bPitchAndFamily = pCF->_bPitchAndFamily;

		if (pCF == pCFCurrent && (iMatchCurrent & MATCH_FONT_SIG) &&
			(IsFECharRep(pCF->_iCharRep) && W32->IsFECodePageFont(qwFontSigCurrent) ||
			 iMatch == MATCH_ASCII && iCharRep == ANSI_INDEX))
		{
			// The current font matches the requested signature.
			// If it's a East Asia or ASCII font, we leave the charset intact.
			iCharRepRet = pCF->_iCharRep;
			return true;
		}
	}

	if (_ped->_fAutoFontSizeAdjust && iFont != pCFCurrent->_iFont)
	{
		if (IsValid())
		{
			// If the last run format is available. We will scale the size relative to it.
			AdjustBackward();
			if (GetIch() > 0)
			{
				pCFCurrent = _ped->GetCharFormat(GetFormat());
				yHeight = pCFCurrent->_yHeight;
			}
			AdjustForward();
		}

		if (iFont != pCFCurrent->_iFont)
		{
			// Scale the height relative to the preceding format
			if (pCF)
				yNewHeight = GetFontLegitimateSize(iFont, fUseUIFont, iCharRep);
	
			if (yNewHeight)
			{
				// Get legitimate size of current font
				SHORT yDefHeight = GetFontLegitimateSize(pCFCurrent->_iFont,
										fUseUIFont, pCFCurrent->_iCharRep);
	
				// Calculate the new height relative to the current height
				if (yDefHeight)
				{
					if (fUseUIFont)
					{
						// For UIFont, we only convert from one preferred size to another preferred size.
						if (pCFCurrent->_yHeight / TWIPS_PER_POINT == yDefHeight)
							yHeight = yNewHeight * TWIPS_PER_POINT;
					}
					else
						yHeight = (SHORT)MulDiv(pCFCurrent->_yHeight, yNewHeight, yDefHeight);
				}
			}
		}
	}

	if (!yHeight)
		yHeight = (SHORT)MulDiv(pCFCurrent->_yHeight, yNewHeight, 10);

	return pCF || fr;
}

/*
 *	CCFRunPtr::FindUnhiddenBackward()
 *	
 *	@mfunc
 *		Find nearest expanded CF going backward.  If none, go to BOD
 *	
 *	@rdesc
 *		cch to nearest expanded CF going backward
 *
 *	@devnote
 *		changes this run ptr
 */
LONG CCFRunPtr::FindUnhiddenBackward()
{
	LONG cch = 0;

	AdjustBackward();
	while(IsHidden())
	{
		cch -= GetIch();
		if(!_iRun)
			break;
		_ich = 0;
		AdjustBackward();
	}
	return cch;
}

///////////////////////////// CPFRunPtr ///////////////////////////////

CPFRunPtr::CPFRunPtr(const CRchTxtPtr &rtp)
		: CFormatRunPtr(rtp._rpPF)
{
	_ped = rtp.GetPed();
}

/*
 *	CPFRunPtr::FindHeading(cch, lHeading)
 *	
 *	@mfunc
 *		Find heading with number lHeading (e.g., = 1 for Heading 1) or above
 *		in a range starting at this PFrun pointer.  If successful, this run
 *		ptr points at the matching run; else it remains unchanged.
 *	
 *	@rdesc
 *		cch to matching heading or tomBackward if not found
 *
 *	@devnote
 *		changes this run ptr
 */
LONG CPFRunPtr::FindHeading(
	LONG	cch,		//@parm Max cch to move
	LONG&	lHeading)	//@parm Lowest lHeading to match
{
	LONG	cchSave	 = cch;
	LONG	ichSave  = _ich;
	LONG	iRunSave = _iRun;
	LONG	OutlineLevel;

	Assert((unsigned)lHeading <= NHSTYLES);

	if(!IsValid())
		return tomBackward;

	while(TRUE)
	{
		OutlineLevel = GetOutlineLevel();

		if (!(OutlineLevel & 1) &&
			(!lHeading || (lHeading - 1)*2 >= OutlineLevel))
		{
			lHeading = OutlineLevel/2 + 1;	// Return heading # found
			return cchSave - cch;			// Return how far away it was
		}

		if(cch >= 0)
		{
			cch -= GetCchLeft();
			if(cch <= 0 || !NextRun())
				break;
		}			
		else
		{
			cch += GetIch();
			if(cch > 0 || !_iRun)
				break;
			AdjustBackward();
		}
	}

	_ich  = ichSave;
	_iRun = iRunSave;
	return tomBackward;						// Didn't find desired heading
}

/*
 *	CPFRunPtr::FindRowEnd(TableLevel)
 *	
 *	@mfunc
 *		Advance this ptr just past table-row terminator that matches
 *		the passed-in table level
 *	
 *	@rdesc
 *		TRUE if matching table row end is found
 *
 *	@devnote
 *		changes this run ptr only if TableLevel is found within cch chars
 */
BOOL CPFRunPtr::FindRowEnd(
	LONG	TableLevel)	//@parm Table level to match
{
	LONG	ichSave  = _ich;
	LONG	iRunSave = _iRun;

	Assert(IsValid());

	do
	{
		if(IsTableRowDelimiter() && GetPF()->_bTableLevel == (BYTE)TableLevel)
		{
			NextRun();					// Bypass delimiter
			return TRUE;
		}
	} while(NextRun());

	_ich  = ichSave;					// Restore run ptr indices
	_iRun = iRunSave;
	return FALSE;						// Didn't find desired heading
}

/*
 *	CPFRunPtr::IsCollapsed()
 *	
 *	@mfunc
 *		return TRUE if CParaFormat for this run ptr has PFE_COLLAPSED bit set
 *
 *	@rdesc
 *		TRUE if CParaFormat for this run ptr has PFE_COLLAPSED bit set
 */
BOOL CPFRunPtr::IsCollapsed()
{
	return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_COLLAPSED) != 0;
}

/*
 *	CPFRunPtr::IsTableRowDelimiter()
 *	
 *	@mfunc
 *		return TRUE if CParaFormat for this run ptr has PFE_TABLEROWDELIMITER bit set
 *
 *	@rdesc
 *		TRUE if CParaFormat for this run ptr has PFE_TABLEROWDELIMITER bit set
 */
BOOL CPFRunPtr::IsTableRowDelimiter()
{
	return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_TABLEROWDELIMITER) != 0;
}

/*
 *	CPFRunPtr::InTable()
 *	
 *	@mfunc
 *		return TRUE if CParaFormat for this run ptr has PFE_TABLE bit set
 *
 *	@rdesc
 *		TRUE if CParaFormat for this run ptr has PFE_TABLE bit set
 */
BOOL CPFRunPtr::InTable()
{
	return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_TABLE) != 0;
}

/*
 *	CPFRunPtr::FindExpanded()
 *	
 *	@mfunc
 *		Find nearest expanded PF going forward. If none, find nearest going
 *		backward.  If none, go to start of document
 *	
 *	@rdesc
 *		cch to nearest expanded PF as explained in function description
 *
 *	@devnote
 *		Moves this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpanded()
{
	LONG cch, cchRun;

	for(cch = 0; IsCollapsed(); cch += cchRun)	// Try to find expanded PF
	{											//  run going forward
		cchRun = GetCchLeft();
		if(!NextRun())							// Aren't any
		{
			Move(-cch);							// Go back to starting point
			return FindExpandedBackward();		// Try to find expanded PF
		}										//  run going backward
	}
	return cch;
}

/*
 *	CPFRunPtr::FindExpandedForward()
 *	
 *	@mfunc
 *		Find nearest expanded PF going forward.  If none, go to EOD
 *	
 *	@rdesc
 *		cch to nearest expanded PF going forward
 *
 *	@devnote
 *		advances this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpandedForward()
{
	LONG cch = 0;

	while(IsCollapsed())
	{
		LONG cchLeft = GetCchLeft();
		_ich += cchLeft;						// Update _ich in case
		cch  += cchLeft;						//  if(!NextRun()) breaks
		if(!NextRun())
			break;
	}
	return cch;
}

/*
 *	CPFRunPtr::FindExpandedBackward()
 *	
 *	@mfunc
 *		Find nearest expanded PF going backward.  If none, go to BOD
 *	
 *	@rdesc
 *		cch to nearest expanded PF going backward
 *
 *	@devnote
 *		Moves this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpandedBackward()
{
	LONG cch = 0;

	while(IsCollapsed())
	{
		cch -= GetIch();
		_ich = 0;
		if(!_iRun)
			break;
		AdjustBackward();
	}
	return cch;
}

/*
 *	CPFRunPtr::GetOutlineLevel()
 *	
 *	@mfunc
 *		Find outline level this rp is pointing at
 *	
 *	@rdesc
 *		Outline level this rp is pointing at
 */
LONG CPFRunPtr::GetOutlineLevel()
{
	const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
	LONG OutlineLevel = pPF->_bOutlineLevel;

	AssertSz(IsHeadingStyle(pPF->_sStyle) ^ (OutlineLevel & 1),
		"CPFRunPtr::GetOutlineLevel: sStyle/bOutlineLevel mismatch");

	return OutlineLevel;
}

/*
 *	CPFRunPtr::GetStyle()
 *	
 *	@mfunc
 *		Find style this rp is pointing at
 *	
 *	@rdesc
 *		Style this rp is pointing at
 */
LONG CPFRunPtr::GetStyle()
{
	const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
	LONG Style = pPF->_sStyle;

	AssertSz(IsHeadingStyle(Style) ^ (pPF->_bOutlineLevel & 1),
		"CPFRunPtr::GetStyle: sStyle/bOutlineLevel mismatch");

	return Style;
}

/*
 *	CPFRunPtr::ResolveRowStartPF()
 *	
 *	@mfunc
 *		Resolve table row start PF corresponding to the current table row
 *		end.  Assumes that all table rows contained in the current row are
 *		resolved, which should be the case for nested tables in RTF.
 *	
 *	@rdesc
 *		TRUE iff success
 */
BOOL CPFRunPtr::ResolveRowStartPF()
{
	AdjustBackward();
	LONG iFormat = GetFormat();
	Assert(IsTableRowDelimiter());

	const CParaFormat *pPF = NULL;

	while(PrevRun())
	{
		pPF = _ped->GetParaFormat(GetFormat());
		if((pPF->_wEffects & PFE_TABLEROWDELIMITER) && pPF->_iTabs == -1)
			break;
	}
	Assert(IsTableRowDelimiter());
	Assert(pPF->_iTabs == -1);

	CFormatRun*	pRun = GetRun(0);
	IParaFormatCache *pf = GetParaFormatCache();

	pf->Release(pRun->_iFormat);
	pf->AddRef(iFormat);
	pRun->_iFormat = iFormat;
	return TRUE;
}

/*
 *	CPFRunPtr::GetMinTableLevel(cch)
 *	
 *	@mfunc
 *		Get the lowest table level in the range of cch chars from this
 *		run ptr.  This is the lesser of the level ending at the range
 *		cpMost and that starting at cpMin.  Leave this run ptr at cpMin.
 *	
 *	@rdesc
 *		Lowest table level in the cch chars from this run ptr
 */
LONG CPFRunPtr::GetMinTableLevel(
	LONG cch)		//@parm cch to check for table level
{
	if(cch > 0)
		AdjustBackward();

	const CParaFormat *pPF = GetPF();
	LONG Level = pPF->_bTableLevel;		// Default: level at active end

	if(cch)
	{
		Move(-cch);						// Go find table level at other
		pPF = GetPF();					//  end of range
		if(pPF->_bTableLevel < Level)
			Level = pPF->_bTableLevel;
		if(cch < 0)						// Range active end at cpMin
			Move(cch);					// Start at cpMin
	}
	AssertSz(Level >= 0, "CPFRunPtr::GetMinTableLevel: invalid table level");
	return Level;
}

/*
 *	CPFRunPtr::GetTableLevel()
 *	
 *	@mfunc
 *		Get table level this run ptr is at
 *
 *	@rdesc
 *		Table level this run ptr is at
 */
LONG CPFRunPtr::GetTableLevel()
{
	const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
	AssertSz(!(pPF->_wEffects & PFE_TABLE) || pPF->_bTableLevel > 0,
		"CPFRunPtr::GetTableLevel: invalid table level");
	return pPF->_bTableLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\hyph.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	HYPH.CPP -- Hyphenation class |
 *
 *	A table which holds the non-standard hyphenation cases. We store
 *	these entries in the table because we cache the results of hyphenation
 *	in our CLine structure, storing the actual WCHAR and khyph would cost
 *	4 bytes. With this mechanism we can use 5 bits.
 *
 *
 *	Several elements are reserved:
 *	0 - No hyphenation
 *	1 - Normal hyphenation
 *	2 - Delete before
 *
 *	All other ones contain a khyph and a WCHAR.
 *	If performance is an issue, this table could be sorted and binary
 *	searched. We assume this table typically has few entries in use.
 *	
 *	Owner:<nl>
 *		Keith Curtis:	Created
 * 
 *	Copyright (c) 1995-1999, Microsoft Corporation. All rights reserved.
 */
#include <_common.h>
#include <_array.h>
#include <_hyph.h>

const int chyphReserved = 3;

extern CHyphCache *g_phc;

void FreeHyphCache(void)
{
	delete g_phc;
}

/*
 *	CHyphCache::Add (khyph, chHyph)
 *
 *	@mfunc
 *		Adds a new special hyphenation entry to the cache
 *
 *	@rdesc
 *		ihyph to be used
 */
int CHyphCache::Add(UINT khyph, WCHAR chHyph)
{
	HYPHENTRY he;
	he.khyph = khyph;
	he.chHyph = chHyph;

	HYPHENTRY *phe;
	if (phe = CArray<HYPHENTRY>::Add(1, NULL))
	{
		*phe = he;
		return Count() + chyphReserved - 1;
	}
	return 1; //If we run out of memory, just do normal hyphenation
}

/*
 *	CHyphCache::Find(khyph, chHyph)
 *
 *	@mfunc
 *		Finds a special hyphenation entry in the cache.
 *		If it doesn't exist, then it will add it.
 *
 *	@rdesc
 *		index into table if successful, FALSE if failed
 */
int CHyphCache::Find(UINT khyph, WCHAR chHyph)
{
	HYPHENTRY *phe = Elem(0);

	//Special cases
	if (khyph <= khyphNormal)
		return khyph;
	if (khyph == khyphDeleteBefore)
		return 2;

	for (int ihyph = 0; ihyph < Count(); ihyph++, phe++)
	{
		if (chHyph == phe->chHyph && phe->khyph == khyph)
			return ihyph + chyphReserved;
	}

	//Not found, so add 
	return Add(khyph, chHyph);
}

/*
 *	CHyphCache::GetAt(iHyph, khyph, chHyph)
 *
 *	@mfunc
 *		Given an ihyph as stored in the CLine array, fill in
 *		the khyph and the chHyph
 *
 *	@rdesc
 *		void
 */
void CHyphCache::GetAt(int ihyph, UINT & khyph, WCHAR & chHyph)
{
	Assert(ihyph - chyphReserved < Count());

	//Special cases
	if (ihyph <= 2)
	{
		chHyph = 0;
		if (ihyph <= khyphNormal)
			khyph = ihyph;
		if (ihyph == 2)
			khyph = khyphDeleteBefore;
		return;
	}

	ihyph -= chyphReserved;
	HYPHENTRY *phe = Elem(ihyph);
	khyph = phe->khyph;
	chHyph = phe->chHyph;
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\host.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	HOST.C	-- Text Host for CreateWindow() Rich Edit Control |
 *		Implements CTxtWinHost message and ITextHost interfaces
 *		
 *	Original Author: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		8/1/95   ricksa  Documented and brought to new ITextHost definition
 *		10/28/95 murrays cleaned up and moved default char/paraformat cache
 *						 cache code into text services
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"

#ifndef NOWINDOWHOSTS

ASSERTDATA

CTxtWinHost *g_phostdel = NULL;

#define EN_CLIPFORMAT			0x0712
#define ENM_CLIPFORMAT			0x00000080

void DeleteDanglingHosts()
{
	CLock lock;
	CTxtWinHost *phostdel = g_phostdel;
	while(phostdel)
	{
		CTxtWinHost *phost = phostdel;
		phostdel = phostdel->_pnextdel;
		CTxtWinHost::OnNCDestroy(phost);
	}
	g_phostdel = NULL;
}


#ifndef NOANSIWINDOWS

//////////////////////////// System Window Procs ////////////////////////////
LRESULT CreateAnsiWindow(
	HWND hwnd, 
	UINT msg, 
	CREATESTRUCTA *pcsa,
	BOOL fIs10)
{
	AssertSz((WM_CREATE == msg) || (WM_NCCREATE == msg), 
		"CreateAnsiWindow called with invalid message!");

	CTxtWinHost *phost = (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed);

	// The only thing we need to convert are the strings,
	// so just do a structure copy and replace the strings. 
	CREATESTRUCTW csw = *(CREATESTRUCTW *)pcsa;
	CStrInW strinwName(pcsa->lpszName, GetKeyboardCodePage());
	CStrInW strinwClass(pcsa->lpszClass, CP_ACP);

	csw.lpszName = (WCHAR *)strinwName;
	csw.lpszClass = (WCHAR *)strinwClass;

	if (!phost)
	{
		// No host yet so create it
		phost = CTxtWinHost::OnNCCreate(hwnd, &csw, TRUE, fIs10);
	}

	if (WM_NCCREATE == msg)
	{
		return phost != NULL;
	}

	if (NULL == phost)
	{
		// For WM_CREATE -1 indicates failure
		return -1;
	}

	// Do the stuff specific to create
	return phost->OnCreate(&csw);
}

extern "C" LRESULT CALLBACK RichEdit10ANSIWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEdit10ANSIWndProc", msg);

	if ((WM_CREATE == msg) || (WM_NCCREATE == msg))
	{
		return CreateAnsiWindow(hwnd, msg, (CREATESTRUCTA *) lparam, TRUE);
	}

    // ignore WM_DESTROY and wait for WM_NCDESTROY
	if (WM_DESTROY == msg)
	{
#ifndef NOWINDOWHOSTS
		CLock lock;
		CTxtWinHost *phost = (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed);
		phost->_pnextdel = g_phostdel;
		g_phostdel = phost;
#endif		
		return 0;
	}


	if (WM_NCDESTROY == msg)
	    msg = WM_DESTROY;

	return W32->ANSIWndProc( hwnd, msg, wparam, lparam, TRUE);
}

LRESULT CALLBACK RichEditANSIWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditANSIWndProc", msg);

	if ((WM_CREATE == msg) || (WM_NCCREATE == msg))
	{
		return CreateAnsiWindow(hwnd, msg, (CREATESTRUCTA *) lparam, FALSE);
	}

	return W32->ANSIWndProc( hwnd, msg, wparam, lparam, FALSE);

}

#else	// NOANSIWINDOWS

extern "C" LRESULT CALLBACK RichEdit10ANSIWndProc(
	HWND ,
	UINT ,
	WPARAM ,
	LPARAM)
{
	return 0;
}

LRESULT CALLBACK RichEditANSIWndProc(
	HWND ,
	UINT ,
	WPARAM ,
	LPARAM)
{
	return 0;
}

#endif	// NOANSIWINDOWS


/*
 *	RichEditWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services.
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CALLBACK RichEditWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditWndProc");

	LRESULT lres = 0;
	HRESULT hr;
	SETTEXTEX st;

	CTxtWinHost *phost = hwnd ? (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed) : NULL;

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	switch(msg)
	{
#ifdef WM_NCCREATE
	case WM_NCCREATE:
		return CTxtWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam, FALSE, FALSE) != NULL;
#endif

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WinCE)
		if (!phost)
		{
			phost = CTxtWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam, FALSE, FALSE);
		}

		break;

	case WM_DESTROY:
		if(phost)
		{
#ifndef NOWINDOWHOSTS
			CLock lock;
			CTxtWinHost *phostdel = g_phostdel;
			if (phostdel == phost)
				g_phostdel = phost->_pnextdel;
			else
			{
				while (phostdel)
				{
					if (phostdel->_pnextdel == phost)
					{
						phostdel->_pnextdel = phost->_pnextdel;
						break;
					}
					phostdel = phostdel->_pnextdel;
				}
			}
#endif
			CTxtWinHost::OnNCDestroy(phost);
		}
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// In certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	// Handle mouse/keyboard/scroll message-filter notifications
	if(phost->_fKeyMaskSet || phost->_fMouseMaskSet || phost->_fScrollMaskSet)
	{
		// We may need to fire a MSGFILTER notification.  In the tests
		// below, we check to see if mouse, keyboard, or scroll events
		// are hit and enabled for notifications.  If so, we fire the
		// msgfilter notification.  The list of events was generated
		// from	RichEdit 1.0 sources. The code gets all keyboard and
		// mouse actions, whereas the RichEdit 1.0 code only got
		// WM_KEYDOWN, WM_KEYUP, WM_CHAR, WM_SYSKEYDOWN, WM_SYSKEYUP,
		// WM_MOUSEACTIVATE, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE,
		// WM_RBUTTONDBLCLK, WM_RBUTTONDOWN, WM_RBUTTONUP. Note that the
		// following code doesn't send a notification for AltGr characters
		// (LeftCtrl+RightAlt+vkey), since some hosts misinterpret these
		// characters as hot keys.
		if (phost->_fKeyMaskSet && IN_RANGE(WM_KEYFIRST, msg, WM_KEYLAST) &&
				(msg != WM_KEYDOWN ||
				 (GetKeyboardFlags() & (ALT | CTRL)) != (LCTRL | RALT)) || // AltGr
			phost->_fMouseMaskSet && (msg == WM_MOUSEACTIVATE ||
							IN_RANGE(WM_MOUSEFIRST, msg, WM_MOUSELAST)) ||
			phost->_fScrollMaskSet && IN_RANGE(WM_HSCROLL, msg, WM_VSCROLL))
		{
			MSGFILTER msgfltr;

			ZeroMemory(&msgfltr.nmhdr, sizeof(NMHDR));
			msgfltr.msg = msg;
			msgfltr.wParam = wparam;
			msgfltr.lParam = lparam;

			// The MSDN document on MSGFILTER is wrong, if the
			// send message returns 0 (NOERROR via TxNotify in this
			// case), it means process the event.  Otherwise, return.
			//
			// The documentation states the reverse.
			//
			if(phost->TxNotify(EN_MSGFILTER, &msgfltr) == NOERROR)
			{
				// Since client is allowed to modify the contents of
				// msgfltr, we must use the returned values.
				msg	   = msgfltr.msg;
				wparam = msgfltr.wParam;
				lparam = msgfltr.lParam;
			}
			else
			{
				lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
				goto Exit;
			}
		}
	}

	switch(msg)
	{
    case EM_SETEVENTMASK:
		phost->_fKeyMaskSet = !!(lparam & ENM_KEYEVENTS);
		phost->_fMouseMaskSet = !!(lparam & ENM_MOUSEEVENTS);
		phost->_fScrollMaskSet = !!(lparam & ENM_SCROLLEVENTS);
		goto serv;

	case EM_SETSEL:

		// When we are in a dialog box that is empty, EM_SETSEL will not select
		// the final always existing EOP if the control is rich.
		if (phost->_fUseSpecialSetSel &&
			((CTxtEdit *)phost->_pserv)->GetAdjustedTextLength() == 0 &&
			wparam != -1)
		{
			lparam = 0;
			wparam = 0;
		}
		goto serv;

	case WM_CREATE:
		{
			//bug fix #5386
			//need to convert ANSI -> UNICODE for Win9x systems which didn't go through
			//the ANSI wndProc
#ifndef NOANSIWINDOWS
			if (W32->OnWin9x() && !phost->_fANSIwindow)
			{
				CREATESTRUCT cs = *(CREATESTRUCT*)lparam;
				CStrInW strinwName(((CREATESTRUCTA*)lparam)->lpszName, GetKeyboardCodePage());
				CStrInW strinwClass(((CREATESTRUCTA*)lparam)->lpszClass, CP_ACP);

				cs.lpszName = (WCHAR*)strinwName;
				cs.lpszClass = (WCHAR*)strinwClass;
				
				lres = phost->OnCreate(&cs);
			}
			else
#endif
				lres = phost->OnCreate((CREATESTRUCT*)lparam);			
		}
		break;
	
	case WM_KEYDOWN:		
		lres = phost->OnKeyDown((WORD) wparam, (DWORD) lparam);
		if(lres)							// Didn't process code:
			goto serv;						//  give it to text services
		
		break;		   

	case WM_GETTEXT:
#ifndef NOANSIWINDOWS
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
#endif
		goto serv;

	case WM_COPYDATA:
		PCOPYDATASTRUCT pcds;
		pcds = (PCOPYDATASTRUCT) lparam;
		if (HIWORD(pcds->dwData) == 1200 &&		// Unicode code page
			LOWORD(pcds->dwData) == WM_SETTEXT)	// Only message we know about
		{
			st.flags = ST_CHECKPROTECTION;
			st.codepage = 1200;
			msg = EM_SETTEXTEX;
			wparam = (WPARAM) &st;
			lparam = (LPARAM) pcds->lpData;
			goto serv;
		}
		else
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_GETTEXTLENGTH:
#ifndef NOANSIWINDOWS
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
#endif
		goto serv;

	case WM_CHAR:
		if(GetKeyboardFlags() & ALTNUMPAD)	// Handle Alt+0ddd in CTxtEdit
			goto serv;						//  so that other hosts also work
#ifndef NOANSIWINDOWS
		else if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci, 
				((CTxtEdit *)phost->_pserv)->Get10Mode() );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
#endif

		lres = phost->OnChar((WORD) wparam, (DWORD) lparam);
		if(lres)							// Didn't process code:
			goto serv;						//  give it to text services
		break;

	case WM_ENABLE:
		if(!wparam ^ phost->_fDisabled)
		{
			// Stated of window changed so invalidate it so it will
			// get redrawn.
			phost->TxInvalidateRect(NULL, TRUE);
			phost->SetScrollBarsForWmEnable(wparam);
		}
		phost->_fDisabled = !wparam;				// Set disabled flag
		lres = 0;							// Return value for message
											// Fall thru to WM_SYSCOLORCHANGE?
	case WM_SYSCOLORCHANGE:
		phost->OnSysColorChange();
		goto serv;							// Notify text services that
											//  system colors have changed
	case WM_GETDLGCODE:
		lres = phost->OnGetDlgCode(wparam, lparam);
		break;

	case EM_GETOPTIONS:
		lres = phost->OnGetOptions();
		break;

	case EM_GETPASSWORDCHAR:
		lres = phost->_chPassword;
		break;

	case EM_GETRECT:
		phost->OnGetRect((LPRECT)lparam);
		break;

	case EM_HIDESELECTION:
		if(lparam)
		{
			DWORD dwPropertyBits = 0;

			phost->_dwStyle |= ES_NOHIDESEL;
			if(wparam)
			{
				phost->_dwStyle &= ~ES_NOHIDESEL;
				dwPropertyBits = TXTBIT_HIDESELECTION;
			}

			// Notify text services of change in status.
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_HIDESELECTION, 
				dwPropertyBits);
		}
		goto serv;

	case EM_SETBKGNDCOLOR:
		lres = (LRESULT) phost->_crBackground;
		phost->_fNotSysBkgnd = !wparam;
		phost->_crBackground = (COLORREF) lparam;

		if(wparam)
			phost->_crBackground = GetSysColor(COLOR_WINDOW);

		if(lres != (LRESULT) phost->_crBackground)
		{
			// Notify text services that color has changed
			LRESULT	lres1 = 0;
			phost->_pserv->TxSendMessage(WM_SYSCOLORCHANGE, 0, 0, &lres1);
			phost->TxInvalidateRect(NULL, TRUE);
		}
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_STYLECHANGED:
		//
		// For now, we only interested in GWL_EXSTYLE Transparent mode changed.
		// This is to fix Bug 753 since Window95 is not passing us
		// the WS_EX_TRANSPARENT.
		// 
		lres = 1;
		if(GWL_EXSTYLE == wparam)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lparam;
			if(phost->IsTransparentMode() != (BOOL)(lpss->styleNew & WS_EX_TRANSPARENT))
			{
				phost->_dwExStyle = lpss->styleNew;
				((CTxtEdit *)phost->_pserv)->OnTxBackStyleChange(TRUE);

				// Return 0 to indicate we have handled this message
				lres = 0;
			}
		}
		break;

	case EM_SHOWSCROLLBAR:
		{
			Assert(wparam == SB_VERT || wparam == SB_HORZ);
			DWORD dwBit = wparam == SB_VERT ? WS_VSCROLL : WS_HSCROLL;

			phost->_dwStyle |= dwBit;
			if(!lparam)
				phost->_dwStyle &= ~dwBit;

			phost->TxShowScrollBar((int) wparam, lparam);
			if (lparam)
			    phost->TxSetScrollRange((int) wparam, 0, 0, TRUE);
		}
		break;

	case EM_SETOPTIONS:
		phost->OnSetOptions((WORD) wparam, (DWORD) lparam);
		lres = (phost->_dwStyle & ECO_STYLES);
		if(phost->_fEnableAutoWordSel)
			lres |= ECO_AUTOWORDSELECTION;
		break;

	case EM_SETPASSWORDCHAR:
		if(phost->_chPassword != (TCHAR)wparam)
		{
			phost->_chPassword = (TCHAR)wparam;
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_USEPASSWORD,
				phost->_chPassword ? TXTBIT_USEPASSWORD : 0);
		}
		break;

	case EM_SETREADONLY:
		phost->OnSetReadOnly(BOOL(wparam));
		lres = 1;
		break;

	case EM_SETRECTNP:
	case EM_SETRECT:
		phost->OnSetRect((LPRECT)lparam, wparam == 1, msg == EM_SETRECT);
		break;
		
	case WM_SIZE:
		phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		lres = phost->OnSize(hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));
		break;

	case WM_WINDOWPOSCHANGING:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		// richedit 1.0 didn't cause InvalidateRect which OnSunkenWindowPosChanging will do
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && !((CTxtEdit *)phost->_pserv)->Get10Mode())
			phost->OnSunkenWindowPosChanging(hwnd, (WINDOWPOS *) lparam);
		break;

	case WM_SETCURSOR:
		//			Only set cursor when over us rather than a child; this
		//			helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
			{
				POINT pt;
				GetCursorPos(&pt);
				::ScreenToClient(hwnd, &pt);
				phost->_pserv->OnTxSetCursor(
					DVASPECT_CONTENT,	
					-1,
					NULL,
					NULL,
					NULL,
					NULL,
					NULL,			// Client rect - no redraw 
					pt.x, 
					pt.y);
				lres = TRUE;
			}
		}
		break;

	case WM_SHOWWINDOW:
		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_PRINTCLIENT:
	case WM_PAINT:
		{
			PAINTSTRUCT ps;
			HPALETTE hpalOld = NULL;
			HDC		hdc;
			RECT rcClient;

			//RAID 6964: WM_PRINTCLIENT should not call BeginPaint. If a HDC is passed
			//down in the wparam, use it instead of calling BeginPaint.
			if (!wparam || ((CTxtEdit *)phost->_pserv)->Get10Mode())
				hdc = BeginPaint(hwnd, &ps);
			else
				hdc = (HDC) wparam;

			// Set up the palette for drawing our data
			if(phost->_hpal)
			{
				hpalOld = SelectPalette(hdc, phost->_hpal, TRUE);
				RealizePalette(hdc);
			}

			// Since we are using the CS_PARENTDC style, make sure
			// the clip region is limited to our client window.
			GetClientRect(hwnd, &rcClient);
			SaveDC(hdc);
			IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);

			phost->_pserv->TxDraw(
				DVASPECT_CONTENT,  		// Draw Aspect
				-1,						// Lindex
				NULL,					// Info for drawing optimazation
				NULL,					// target device information
				hdc,					// Draw device HDC
				NULL, 				   	// Target device HDC
				(const RECTL *) &rcClient,// Bounding client rectangle
				NULL,	                // Clipping rectangle for metafiles
				&ps.rcPaint,			// Update rectangle
				NULL, 	   				// Call back function
				NULL,					// Call back parameter
				TXTVIEW_ACTIVE);		// What view - the active one!

			// Restore palette if there is one
#ifndef NOPALETTE
			if(hpalOld)
				SelectPalette(hdc, hpalOld, TRUE);
#endif
			RestoreDC(hdc, -1);
			if (!wparam || ((CTxtEdit *)phost->_pserv)->Get10Mode())
				EndPaint(hwnd, &ps);
		}
		break;

	case EM_SETMARGINS:
		phost->OnSetMargins(wparam, LOWORD(lparam), HIWORD(lparam));
		break;

	case EM_SETPALETTE:
		// Application is setting a palette for us to use.
		phost->_hpal = (HPALETTE) wparam;

		// Invalidate the window & repaint to reflect the new palette.
		InvalidateRect(hwnd, NULL, TRUE);
		break;

	default:
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		if(hr == S_FALSE)
		{			
			// Message was not processed by text services so send it
			// to the default window proc.
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}
	}

Exit:
	phost->Release();
	return lres;
}
												 
static BOOL GetIconic(
	HWND hwnd) 
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetIconic");

	while(hwnd)
	{
		if(IsIconic(hwnd))
			return TRUE;
		hwnd = GetParent(hwnd);
	}
	return FALSE;
}

//////////////// CTxtWinHost Creation/Initialization/Destruction ///////////////////////

/*
 *	CTxtWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
CTxtWinHost *CTxtWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs,
	BOOL fIsAnsi,
	BOOL fIs10Mode)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnNCCreate");

#if defined DEBUG && !defined(NOFULLDEBUG) 
	GdiSetBatchLimit(1);
#endif

	CTxtWinHost *phost = new CTxtWinHost();

	if(!phost)
		return 0;

	CREATESTRUCT cs = *pcs;		// prefer C++ compiler not to modify constant

#ifndef NOCOMPLEXSCRIPTS
	BOOL		 fMirrorWnd = !!(cs.dwExStyle & WS_EX_LAYOUTRTL);	// Inherit parent window's mirroring

	if (fMirrorWnd)
	{
		// Force RTL reading
		cs.style |= ES_RIGHT;
		cs.dwExStyle |= WS_EX_RTLREADING;
	}
#endif

#ifndef NOANSIWINDOWS
	//bug fix #5386
	// Window wasn't created with the Richedit20A window class
	// and we are under Win9x, need to convert string to UNICODE
	CStrInW strinwName(((LPSTR)pcs->lpszName), GetKeyboardCodePage());
	CStrInW strinwClass(((LPSTR)pcs->lpszClass), CP_ACP);
	if (!fIsAnsi && W32->OnWin9x())
	{
		cs.lpszName = (WCHAR *)strinwName;
		cs.lpszClass = (WCHAR *)strinwClass;
	}
#endif

	// Stores phost in associated window data
	if(!phost->Init(hwnd, (const CREATESTRUCT*)&cs, fIsAnsi, fIs10Mode))
	{
		phost->Shutdown();
		delete phost;
		phost = NULL;
	}

#ifndef NOCOMPLEXSCRIPTS
	if (phost && fMirrorWnd)
	{
		// Disable mirroring layout to avoid mirrored mapping mode
		SetWindowLong(hwnd, GWL_STYLE, cs.style | ES_RIGHT);
		SetWindowLong(hwnd, GWL_EXSTYLE, (cs.dwExStyle & ~WS_EX_LAYOUTRTL) | WS_EX_LEFTSCROLLBAR);
	}
#endif

	return phost;
}

/*
 *	CTxtWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_CREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLong())
 */
void CTxtWinHost::OnNCDestroy(
	CTxtWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnNCDestroy");

	phost->Shutdown();
	phost->Release();
}

/*
 *	CTxtWinHost::CTxtWinHost()
 *
 *	@mfunc
 *		constructor
 */
CTxtWinHost::CTxtWinHost() 
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::CTxtWinHost");

#ifndef NOACCESSIBILITY
    _pTypeInfo = NULL;
#endif

	_fRegisteredForDrop = FALSE;
	_crefs = 1;	
	if(!_fNotSysBkgnd)
		_crBackground = GetSysColor(COLOR_WINDOW);
}

/*
 *	CTxtWinHost::~CTxtWinHost()
 *
 *	@mfunc
 *		destructor
 */
CTxtWinHost::~CTxtWinHost()
{
	AssertSz(_pserv == NULL, 
		"CTxtWinHost::~CTxtWinHost - shutdown not called till destructor");

	if(_pserv)
		Shutdown();
}

/*
 *	CTxtWinHost::Shutdown()
 *
 *	@mfunc	Shut down this object, but doesn't delete memory
 */
void CTxtWinHost::Shutdown()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Shutdown");
	ITextServices *pserv;
	
	HostRevokeDragDrop();					// Revoke our drop target
	
	if(_pserv)
	{
		// Guarantee that no recursive callbacks can happen during shutdown.
		pserv = _pserv;
		_pserv = NULL;

		pserv->OnTxInPlaceDeactivate();
		pserv->Release();

		// Host release was not the final release so notify
		// text services that they need to keep their reference
		// to the host valid.
		if (!_fTextServiceFree)
		{
			((CTxtEdit *)pserv)->SetReleaseHost();

		}
	}

#if 0
	ImmTerminate();						// Terminate only useful on Mac.
#endif

	if(_hwnd)
		SetWindowLongPtr(_hwnd, ibPed, 0);
}

/*
 *	CTxtWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CTxtWinHost
 */
BOOL CTxtWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs,	//@parm Corresponding CREATESTRUCT
	BOOL fIsAnsi,				//@parm is ansi window
	BOOL fIs10Mode)				//@parm is 1.0 mode window
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Init");

	AssertSz(!fIs10Mode || (fIsAnsi && fIs10Mode), 
		"CTxtWinHost::Init input flags are out of sync!");

	if(!pcs->lpszClass)
		return FALSE;

	// Set pointer back to CTxtWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;

	// Here we want to keep track of the "RichEdit20A"window class
	// The RICHEDIT window class is handled by a wrapper dll.
	// If the class name is "RICHEDIT", then we need to turn on the
	// RichEdit 1.0 compatibility bit.  IsAnsiWindowClass tests that class as well.
	_fANSIwindow = fIsAnsi;

 	// Edit controls created without a window are multiline by default
	// so that paragraph formats can be
	_dwStyle = ES_MULTILINE;
	_fHidden = TRUE;
	
	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		if (!fIs10Mode)
		{
			// Only set this for 2.0 windows
			// According to the edit control documentation WS_HSCROLL implies that
			// ES_AUTOSCROLL is set and WS_VSCROLL implies that ES_AUTOVSCROLL is
			// set. Here, we make this so.
			if(_dwStyle & WS_HSCROLL)
				_dwStyle |= ES_AUTOHSCROLL;

			// handle default disabled
			if(_dwStyle & WS_DISABLED)
				_fDisabled = TRUE;
		}
		else
		{
		if (GetBkMode(GetDC(hwnd)) == TRANSPARENT)
			_dwExStyle |= WS_EX_TRANSPARENT;
		else
			_dwExStyle &= ~WS_EX_TRANSPARENT;
		}

		if(_dwStyle & WS_VSCROLL)
			_dwStyle |= ES_AUTOVSCROLL;

		_fBorder = !!(_dwStyle & WS_BORDER);

		if((_dwStyle & ES_SUNKEN) || (_dwExStyle & WS_EX_CLIENTEDGE))
			_fBorder = TRUE;

		// handle default passwords
		if(_dwStyle & ES_PASSWORD)
			_chPassword = TEXT('*');

		// On Win95 ES_SUNKEN and WS_BORDER get mapped to WS_EX_CLIENTEDGE
		if(_fBorder && W32->_dwMajorVersion >= VERS4)
        {
			_dwExStyle |= WS_EX_CLIENTEDGE;
			SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
        }

#ifndef NORIGHTTOLEFT
		// Process some flags for mirrored control
		if (_dwExStyle & WS_EX_LAYOUTRTL)
		{
			// Swap whatever RTL params we have
			_dwStyle = (_dwStyle & ~ES_RIGHT) | (_dwStyle & ES_RIGHT ^ ES_RIGHT);
			_dwExStyle = (_dwExStyle & ~WS_EX_RTLREADING) | (_dwExStyle & WS_EX_RTLREADING ^ WS_EX_RTLREADING);
			_dwExStyle = (_dwExStyle & ~WS_EX_LEFTSCROLLBAR) |
						 (_dwStyle & ES_RIGHT ? WS_EX_LEFTSCROLLBAR : 0);
	
			// Disable mirroring layout to avoid GDI mirroring mapping mode
			_dwExStyle &= ~WS_EX_LAYOUTRTL;
	
			SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
			SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
		}
#endif		
	}

	// Create Text Services component
	// Watch out for sys param and sys font initialization!!  see below.
	if(FAILED(CreateTextServices()))
		return FALSE;

	_xInset = (char)W32->GetCxBorder();
	_yInset = (char)W32->GetCyBorder();

	if (!_fBorder)
	{
		_xInset += _xInset;
		_yInset += _yInset;
	}

	// At this point the border flag is set and so is the pixels per inch
	// so we can initalize the inset.
	// This must be done after CreatingTextServices so sys params are valid
	SetDefaultInset();

	// Set alignment and paragraph direction
	PARAFORMAT PF2;
	
	PF2.dwMask = 0;

#ifndef NOCOMPLEXSCRIPTS
	BOOL fRCAlign = _dwStyle & (ES_RIGHT | ES_CENTER) || _dwExStyle & WS_EX_RIGHT;
	if(fRCAlign)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = (WORD)(_dwStyle & ES_CENTER ? PFA_CENTER : PFA_RIGHT);	// right or center-aligned
	}

	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}
#endif

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}

	if (fIs10Mode)
	{
		 ((CTxtEdit *)_pserv)->Set10Mode();
		 // Remove the WS_VSCROLL and WS_HSCROLL initially
        if (_hwnd && !(_dwStyle & ES_DISABLENOSCROLL))
        {
            SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
    		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);
            DWORD dwStyle = _dwStyle & ~(WS_VSCROLL | WS_HSCROLL);
            SetWindowLong(_hwnd, GWL_STYLE, dwStyle);

            // bug fix:
            // On some systems, ie Digital PII-266, we don't get a WM_PAINT message
            // when we change the window style.  So force a WM_PAINT into the message queue
            TxInvalidateRect(NULL, TRUE);
        }
    }

	// Set window text
	if(pcs && pcs->lpszName)
	{
		if(FAILED(_pserv->TxSetText((TCHAR *)pcs->lpszName)))
		{
			SafeReleaseAndNULL((IUnknown **)&_pserv);
			return FALSE;
		}
	}

	if(_dwStyle & ES_LOWERCASE)
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_LOWERCASE,
							  SES_LOWERCASE | SES_UPPERCASE, NULL);

#if 0
	if(!ImmInitialize())			// Mac Only
	{
		#if defined(DEBUG)
		OutputDebugString(TEXT("Could not register Imm ImmInitializeForMac.\r\n"));
		#endif	// DEBUG
	}
#endif

	return TRUE;
}

HRESULT CTxtWinHost::CreateTextServices()
{
	IUnknown *pUnk;
	HRESULT	  hr = ::CreateTextServices(NULL, this, &pUnk);

	if(hr != NOERROR)
		return hr;

	// Get text services interface
	hr = pUnk->QueryInterface(IID_ITextServices, (void **)&_pserv);

	// Regardless of whether the previous call succeeded or failed, we are
	// done with the private interface.
	pUnk->Release();

#ifndef NOCOMPLEXSCRIPTS
	if(hr == NOERROR)
	{
		((CTxtEdit *)_pserv)->_fInOurHost = TRUE;
		// FE extended styles might set the fFE bit 
		if(_dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR))
			_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_BIDI, SES_BIDI, NULL);
	}
#endif

	return hr;
}

/*
 *	CTxtWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CTxtWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;
	
	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;

	DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
	
	// Hide all scrollbars to start
	if(_hwnd && !(dwStyle & ES_DISABLENOSCROLL) && !((CTxtEdit *)_pserv)->Get10Mode())
	{
		SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);

		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);
		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
	}

	if(!(dwStyle & (ES_READONLY | ES_NOOLEDRAGDROP)))
	{
		// This isn't a read only window or a no drop window,
		// so we need a drop target.
		HostRegisterDragDrop();
	}

	_usIMEMode = 0;	
	if(dwStyle & ES_NOIME)
	{
		_usIMEMode = ES_NOIME;
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	
	}
	else if(dwStyle & ES_SELFIME)
		_usIMEMode = ES_SELFIME;

	return 0;
}


/////////////////////////////////  IUnknown ////////////////////////////////

HRESULT CTxtWinHost::QueryInterface(REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");
  
  	if(IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown *)(ITextHost2*)this;

	else if(IsEqualIID(riid, IID_ITextHost) )
		*ppv = (ITextHost *)(CTxtWinHost*)this;

	else if(IsEqualIID(riid, IID_ITextHost2) )
		*ppv = (ITextHost2 *)(CTxtWinHost*)this;

	else
		*ppv = NULL;

	if(*ppv)
	{
		AddRef();
		return NOERROR;
	}
	return E_NOINTERFACE;
}

ULONG CTxtWinHost::AddRef(void)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::AddRef");

	return ++_crefs;
}

ULONG CTxtWinHost::Release(void)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Release");

	--_crefs;

	if(!_crefs)
	{
#ifndef NOACCESSIBILITY
        if(_pTypeInfo)
        {
            _pTypeInfo->Release();
            _pTypeInfo = NULL;
        }           
#endif
		delete this;
		return 0;
	}
	return _crefs;
}


//////////////////////////////// Activation ////////////////////////////////

//////////////////////////////// Properties ////////////////////////////////


TXTEFFECT CTxtWinHost::TxGetEffects() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxGetEffects");

	if((_dwStyle & ES_SUNKEN) || (_dwExStyle & WS_EX_CLIENTEDGE))
		return TXTEFFECT_SUNKEN;

	return TXTEFFECT_NONE;
}

///////////////////////////////  Keyboard Messages  //////////////////////////////////

/*
 *	CTxtWinHost::OnKeyDown (vkey, dwFlags)
 *
 *	@mfunc
 *		Handle WM_KEYDOWN messages that need to send a message to the parent
 *		window (may happen when control is in a dialog box)
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CTxtWinHost::OnKeyDown(
	WORD	vkey,			//@parm WM_KEYDOWN wparam (virtual key code)
	DWORD	dwFlags)		//@parm WM_KEYDOWN flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnKeyDown");

	if(!_fInDialogBox) 					// Not in a dialog box
		return 1;						// Signal key-down msg not processed

	DWORD dwKeyFlags = GetKeyboardFlags();

	switch(vkey)
	{
	case VK_ESCAPE:
		PostMessage(_hwndParent, WM_CLOSE, 0, 0);
		return 0;
	
	case VK_RETURN:
		if(!(dwKeyFlags & CTRL) && !(_dwStyle & ES_WANTRETURN))
		{
			// Send to default button
			HWND	hwndT;
			LRESULT id = SendMessage(_hwndParent, DM_GETDEFID, 0, 0);

			if(LOWORD(id) && (hwndT = GetDlgItem(_hwndParent, LOWORD(id))))
			{
				SendMessage(_hwndParent, WM_NEXTDLGCTL, (WPARAM) hwndT, (LPARAM) 1);
				if(GetFocus() != _hwnd)
					PostMessage(hwndT, WM_KEYDOWN, (WPARAM) VK_RETURN, 0);
			}
			return 0;
		}
		break;

	case VK_TAB:
		if(!(dwKeyFlags & CTRL))
		{
			SendMessage(_hwndParent, WM_NEXTDLGCTL, 
								!!(dwKeyFlags & SHIFT), 0);
			return 0;
		}
		break;
	}

	return 1;
}

/*
 *	CTxtWinHost::OnChar (vkey, dwFlags)
 *
 *	@mfunc
 *		Eat some WM_CHAR messages for a control in a dialog box
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CTxtWinHost::OnChar(
	WORD	vkey,			//@parm WM_CHAR wparam (translated key code)
	DWORD	dwFlags)		//@parm WM_CHAR flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnChar");

	if(!_fInDialogBox || (GetKeyboardFlags() & CTRL)) 
		return 1;
	
	switch(vkey)
	{
	case 'J' - 0x40:					// Ctrl-Return generates Ctrl-J (LF):
	case VK_RETURN:						//  treat it as an ordinary return
		// We need to filter-out cases where we don't want to insert <cr> in
		// 1.0 mode here since the info isn't available within the ped
		if (((CTxtEdit*)_pserv)->Get10Mode())
		{
			if (_fInDialogBox && dwFlags != MK_CONTROL && !(_dwStyle & ES_WANTRETURN))
				return 0;
				
			if (!(_dwStyle & ES_MULTILINE))
			{
				//richedit beeps in this case
				((CTxtEdit*)_pserv)->Beep();
				return 0;
			}
		}
		else if (!(_dwStyle & ES_WANTRETURN))
			return 0;					// Signal char processed (eaten)		
		break;

	case VK_TAB:
		return 0;
	}
	
	return 1;							// Signal char not processed
}


/////////////////////////////////  View rectangle //////////////////////////////////////

void CTxtWinHost::OnGetRect(
	LPRECT prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetRect");

	RECT rcInset;
	LONG lSelBarWidth = 0;

	if(_fEmSetRectCalled)
	{
		// Get the selection bar width and add it back to the view inset so
		// we return the rectangle that the application set.
		TxGetSelectionBarWidth(&lSelBarWidth);
	}

	// Get view inset (in HIMETRIC)
	TxGetViewInset(&rcInset);

	// Get client rect in pixels
	TxGetClientRect(prc);

	// Modify the client rect by the inset converted to pixels
	prc->left	+= W32->HimetricToDevice(rcInset.left + lSelBarWidth, W32->GetXPerInchScreenDC());
	prc->top	+= W32->HimetricToDevice(rcInset.top, W32->GetYPerInchScreenDC());
	prc->right	-= W32->HimetricToDevice(rcInset.right, W32->GetXPerInchScreenDC());
	prc->bottom -= W32->HimetricToDevice(rcInset.bottom, W32->GetYPerInchScreenDC());
}

void CTxtWinHost::OnSetRect(
	LPRECT prc,				//@parm Desired formatting RECT
	BOOL fNewBehavior,		//@parm If TRUE, prc is inset RECT directly
	BOOL fRedraw)			//@parm If TRUE, redraw after setting RECT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetRect");

	RECT rcClient;
	LONG lSelBarWidth;
	
	// Assuming this is not set to the default, turn on special EM_SETRECT 
	// processing. The important part of this is that we subtract the selection 
	// bar from the view inset because the EM_SETRECT rectangle does not 
	// include the selection bar.
	_fEmSetRectCalled = TRUE;

	if(!prc)
	{
		// We are back to the default so turn off special EM_SETRECT procesing.
		_fEmSetRectCalled = FALSE;
		SetDefaultInset();
	}
	else	
	{
		// For screen display, the following intersects new view RECT
		// with adjusted client area RECT
		TxGetClientRect(&rcClient);

		// Adjust client rect. Factors in space for borders
		if(_fBorder)
		{																					  
			rcClient.top		+= _yInset;
			rcClient.bottom 	-= _yInset - 1;
			rcClient.left		+= _xInset;
			rcClient.right		-= _xInset;
		}
	
		if(!fNewBehavior)
		{
			// Intersect new view rectangle with adjusted client area rectangle
			if(!IntersectRect(&_rcViewInset, &rcClient, prc))
				_rcViewInset = rcClient;
		}
		else
			_rcViewInset = *prc;

		// Get selection bar width 
		TxGetSelectionBarWidth(&lSelBarWidth);

		// Compute inset in pixels and convert to HIMETRIC.
		_rcViewInset.left = W32->DeviceToHimetric(_rcViewInset.left - rcClient.left, W32->GetXPerInchScreenDC()) - lSelBarWidth;
		_rcViewInset.top = W32->DeviceToHimetric(_rcViewInset.top - rcClient.top, W32->GetYPerInchScreenDC());
		_rcViewInset.right = W32->DeviceToHimetric(rcClient.right - _rcViewInset.right, W32->GetXPerInchScreenDC());
		_rcViewInset.bottom = W32->DeviceToHimetric(rcClient.bottom - _rcViewInset.bottom, W32->GetYPerInchScreenDC());
	}
	if(fRedraw)
	{
		_pserv->OnTxPropertyBitsChange(TXTBIT_VIEWINSETCHANGE, 
			TXTBIT_VIEWINSETCHANGE);
	}
}


///////////////////////////////  System notifications  //////////////////////////////////

void CTxtWinHost::OnSysColorChange()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSysColorChange");

	if(!_fNotSysBkgnd)
		_crBackground = GetSysColor(COLOR_WINDOW);
	TxInvalidateRect(NULL, TRUE);
}

/*
 *	CTxtWinHost::OnGetDlgCode (wparam, lparam)
 *
 *	@mfunc
 *		Handle some WM_GETDLGCODE messages
 *
 *	#rdesc
 *		LRESULT = dialog code
 */
LRESULT CTxtWinHost::OnGetDlgCode(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetDlgCode");

	LRESULT lres = DLGC_WANTCHARS | DLGC_WANTARROWS | DLGC_WANTTAB;

	if(_dwStyle & ES_MULTILINE)
		lres |= DLGC_WANTALLKEYS;

	if(!(_dwStyle & ES_SAVESEL))
		lres |= DLGC_HASSETSEL;

	// HACK: If we get one of these messages then we turn on the special
	// EM_SETSEL behavior. The problem is that _fInDialogBox gets turned
	// on after the EM_SETSEL has occurred.
	_fUseSpecialSetSel = TRUE;

	/*
	** -------------------------------------------- JEFFBOG HACK ----
	** Only set Dialog Box Flag if GETDLGCODE message is generated by
	** IsDialogMessage -- if so, the lParam will be a pointer to the
	** message structure passed to IsDialogMessage; otherwise, lParam
	** will be NULL.  Reason for the HACK alert:  the wParam & lParam
	** for GETDLGCODE is still not clearly defined and may end up
	** changing in a way that would throw this off
	** -------------------------------------------- JEFFBOG HACK ----
	 */
	if(lparam)
		_fInDialogBox = TRUE;

	/*
	** If this is a WM_SYSCHAR message generated by the UNDO keystroke
	** we want this message so we can EAT IT in remain.c, case WM_SYSCHAR:
	 */
	if (lparam &&
		(((LPMSG)lparam)->message == WM_SYSCHAR)  &&
		(((LPMSG)lparam)->lParam & SYS_ALTERNATE) &&	
		wparam == VK_BACK)
	{
		lres |= DLGC_WANTMESSAGE;
	}

	return lres;
}


/////////////////////////////////  Other messages  //////////////////////////////////////

LRESULT CTxtWinHost::OnGetOptions() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetOptions");

	LRESULT lres = (_dwStyle & ECO_STYLES);

	if(_fEnableAutoWordSel)
		lres |= ECO_AUTOWORDSELECTION;
	
	return lres;
}

void CTxtWinHost::OnSetOptions(
	WORD  wOp,
	DWORD eco)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetOptions");

	DWORD		dwChangeMask = 0;
	DWORD		dwProp = 0;
	DWORD		dwStyle;
	DWORD		dwStyleNew = _dwStyle;
	const BOOL	fAutoWordSel = !!(eco & ECO_AUTOWORDSELECTION);		
	BOOL		bNeedToTurnOffIME = FALSE;

	// We keep track of the bits changed and then if any have changed we
	// query for all of our property bits and then send them. This simplifies
	// the code because we don't have to set all the bits specially. If the
	// code is changed to make the properties more in line with the new 
	// model, we want to look at this code again.

	// Single line controls can't have a selection bar or do vertical writing
	if(!(_dwStyle & ES_MULTILINE))
		eco &= ~ECO_SELECTIONBAR;

	Assert((DWORD)fAutoWordSel <= 1);			// Make sure that BOOL is 1/0
	dwStyle = (eco & ECO_STYLES);

	switch(wOp)
	{
	case ECOOP_SET:
		dwStyleNew			= (dwStyleNew & ~ECO_STYLES) | dwStyle;
		_fEnableAutoWordSel = fAutoWordSel;
		break;

	case ECOOP_OR:
		dwStyleNew |= dwStyle;					// Setting a :1 flag = TRUE
		if(fAutoWordSel)						//  or FALSE is 1 instruction
			_fEnableAutoWordSel = TRUE;			// Setting it to a BOOL
		break;									//  averages 9 instructions!

	case ECOOP_AND:
		dwStyleNew &= (dwStyle | ~ECO_STYLES);
		if(!fAutoWordSel)
			_fEnableAutoWordSel = FALSE;
		break;

	case ECOOP_XOR:
		dwStyleNew ^= dwStyle;
		if(fAutoWordSel)
			_fEnableAutoWordSel ^= 1;
		break;
	}

	if(_fEnableAutoWordSel != (unsigned)fAutoWordSel)
		dwChangeMask |= TXTBIT_AUTOWORDSEL; 

	if(dwStyleNew != _dwStyle)
	{
		DWORD dwChange = dwStyleNew ^ _dwStyle;

		AssertSz(!(dwChange & ~ECO_STYLES), "non-eco style changed");
		if(!(dwStyleNew & ES_MULTILINE))
			dwStyleNew &= ~ES_VERTICAL;

		_dwStyle = dwStyleNew;
		SetWindowLong(_hwnd, GWL_STYLE, dwStyleNew & ~ES_VERTICAL);

		if(dwChange & ES_NOHIDESEL)	
			dwChangeMask |= TXTBIT_HIDESELECTION;

		// These two local variables to use to keep track of
		// previous setting of ES_READONLY
		BOOL bReadOnly = (_dwStyle & ES_READONLY);

		if(dwChange & ES_READONLY)
		{
			dwChangeMask |= TXTBIT_READONLY;

			// Change drop target state as appropriate.
			if(dwStyleNew & ES_READONLY)
				HostRevokeDragDrop();

			else
				HostRegisterDragDrop();
			
			bReadOnly = (dwStyleNew & ES_READONLY);
		}

		if(dwChange & ES_VERTICAL)
			dwChangeMask |= TXTBIT_VERTICAL;

		if(dwChange & ES_NOIME)
		{
			_usIMEMode = (dwStyleNew & ES_NOIME) ? ES_NOIME : 0;
			bNeedToTurnOffIME = (_usIMEMode ==ES_NOIME);
		}
		else if(dwChange & ES_SELFIME)
			_usIMEMode = (dwStyleNew & ES_SELFIME) ? ES_SELFIME : 0;
		
		// No action required for ES_WANTRETURN nor for ES_SAVESEL
		// Do this last
		if(dwChange & ES_SELECTIONBAR)
			dwChangeMask |= TXTBIT_SELBARCHANGE;
	}

	if (dwChangeMask)
	{
		TxGetPropertyBits(dwChangeMask, &dwProp);
		_pserv->OnTxPropertyBitsChange(dwChangeMask, dwProp);
	}

	if (bNeedToTurnOffIME)
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	
}

void CTxtWinHost::OnSetReadOnly(
	BOOL fReadOnly)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetReadOnly");

	DWORD dwT = GetWindowLong(_hwnd, GWL_STYLE);
	DWORD dwUpdatedBits = 0;

	if(fReadOnly)
	{
		dwT |= ES_READONLY;
		_dwStyle |= ES_READONLY;

		// Turn off Drag Drop 
		HostRevokeDragDrop();
		dwUpdatedBits |= TXTBIT_READONLY;
	}
	else
	{
		dwT		 &= ~ES_READONLY;
		_dwStyle &= ~ES_READONLY;

		// Turn drag drop back on
		HostRegisterDragDrop();	
	}

	_pserv->OnTxPropertyBitsChange(TXTBIT_READONLY, dwUpdatedBits);

	SetWindowLong(_hwnd, GWL_STYLE, dwT);
}


////////////////////////////////////  Helpers  /////////////////////////////////////////

void CTxtWinHost::SetDefaultInset()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::SetDefaultInset");

	// Generate default view rect from client rect
	if(_fBorder)
	{
		// Factors in space for borders
  		_rcViewInset.top	= W32->DeviceToHimetric(_yInset, W32->GetYPerInchScreenDC());
   		_rcViewInset.bottom	= W32->DeviceToHimetric(_yInset - 1, W32->GetYPerInchScreenDC());
   		_rcViewInset.left	= W32->DeviceToHimetric(_xInset, W32->GetXPerInchScreenDC());
   		_rcViewInset.right	= W32->DeviceToHimetric(_xInset, W32->GetXPerInchScreenDC());
	}
	else
	{
		// Default the top and bottom inset to 0 and the left and right
		// to the size of the border.
		_rcViewInset.top = 0;
		_rcViewInset.bottom = 0;
		_rcViewInset.left = W32->DeviceToHimetric(W32->GetCxBorder(), W32->GetXPerInchScreenDC());
		_rcViewInset.right = W32->DeviceToHimetric(W32->GetCxBorder(), W32->GetXPerInchScreenDC());
	}
}


/////////////////////////////////  East Asia Support  //////////////////////////////////////

HIMC CTxtWinHost::TxImmGetContext()
{
#ifndef NOFEPROCESSING
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxImmGetContext");

	HIMC himc;

	Assert(_hwnd);
	himc = ImmGetContext(_hwnd, FALSE);
	return himc;
#else
    return NULL;
#endif
}

void CTxtWinHost::TxImmReleaseContext(
	HIMC himc)
{
#ifndef NOFEPROCESSING
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxImmReleaseContext");

	Assert(_hwnd);
	ImmReleaseContext(_hwnd, himc, FALSE);
#endif
}


void CTxtWinHost::HostRevokeDragDrop()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::HostRevokeDragDrop");

	if(_fRegisteredForDrop)
	{
		// Note that if the revoke fails we want to know about this in debug
		// builds so we can fix any problems. In retail, we can't really do 
		// so we just ignore it.
#if !defined(NOFULLDEBUG) && defined(DEBUG)
		HRESULT hr = 
#endif // DEBUG

			RevokeDragDrop(_hwnd);

#if !defined(NOFULLDEBUG) && defined(DEBUG)
		TESTANDTRACEHR(hr);
#endif // DEBUG

		_fRegisteredForDrop = FALSE;
	}
}

void CTxtWinHost::HostRegisterDragDrop()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::RegisterDragDrop");

	IDropTarget *pdt = NULL;

	if(!_fRegisteredForDrop && _pserv->TxGetDropTarget(&pdt) == NOERROR)
	{
		// The most likely reason for RegisterDragDrop to fail is some kind of
		// bug in our program.

		HRESULT hr = RegisterDragDrop(_hwnd, pdt);

		if(hr == NOERROR)
			_fRegisteredForDrop = TRUE;

		if (pdt)
			pdt->Release();
	}
}


#define cmultBorder 1

void CTxtWinHost::OnSunkenWindowPosChanging(
	HWND hwnd,
	WINDOWPOS *pwndpos)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSunkenWindowPosChanging");

	if(IsWindowVisible(hwnd))
	{
		RECT rc;
		HWND hwndParent;

		GetWindowRect(hwnd, &rc);
		InflateRect(&rc, W32->GetCxBorder() * cmultBorder, W32->GetCyBorder() * cmultBorder);
		hwndParent = GetParent(hwnd);
		MapWindowPoints(HWND_DESKTOP, hwndParent, (POINT *) &rc, 2);
		InvalidateRect(hwndParent, &rc, TRUE);
	}
}

LRESULT CTxtWinHost::OnSize(
	HWND hwnd,
	WORD fwSizeType,
	int  nWidth,
	int  nHeight)
{	 
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSize");

	BOOL fIconic = GetIconic(hwnd);
	DWORD dw = TXTBIT_CLIENTRECTCHANGE;
	if(_sWidth != nWidth && !fIconic && !_fIconic)
	{
		_sWidth = (short)nWidth;				// Be sure to update _sWidth
		dw = TXTBIT_EXTENTCHANGE;
	}

	if(!_fVisible)
	{
		if(!fIconic)
			_fResized = TRUE;
	}
	else if(!fIconic)
	{
		// We use this property because this will force a recalc.
		// We don't actually recalc on a client rect change because
		// most of the time it is pointless. We force one here because
		// some applications use size changes to calculate the optimal 
		// size of the window.
		_pserv->OnTxPropertyBitsChange(dw, dw);

		if(_fIconic)
		{
			TRACEINFOSZ("Restoring from iconic");
			InvalidateRect(hwnd, NULL, TRUE);
		}
	}
	_fIconic = fIconic;						// Update _fIconic
	return 0;
}

HRESULT CTxtWinHost::OnTxVisibleChange(
	BOOL fVisible)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnTxVisibleChange");

	_fVisible = fVisible;

	if(!_fVisible && _fResized)
	{
		RECT rc;
		// Control was resized while hidden, need to really resize now
		TxGetClientRect(&rc);
		_fResized = FALSE;
		_pserv->OnTxPropertyBitsChange(TXTBIT_CLIENTRECTCHANGE, 
				TXTBIT_CLIENTRECTCHANGE);
	}
	return S_OK;
}


//////////////////////////// ITextHost Interface  ////////////////////////////

// @doc EXTERNAL 
/* 
 *	CTxtWinHost::TxGetDC()
 *
 *	@mfunc
 *		Abstracts GetDC so Text Services does not need a window handle.
 *
 *	@rdesc
 *		A DC or NULL in the event of an error.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
HDC CTxtWinHost::TxGetDC()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetDC");

	Assert(_hwnd);
	return ::GetDC(_hwnd);
}

/* 
 *	CTxtWinHost::TxReleaseDC (hdc)
 *
 *	@mfunc
 *		Release DC gotten by TxGetDC. 
 *
 *	@rdesc	
 *		1 - HDC was released. <nl>
 *		0 - HDC was not released. <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
int CTxtWinHost::TxReleaseDC(
	HDC hdc)				//@parm	DC to release
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxReleaseDC");

	Assert(_hwnd);
	return ::ReleaseDC (_hwnd, hdc);
}

/* 
 *	CTxtWinHost::TxShowScrollBar (fnBar, fShow)
 *
 *	@mfunc
 *		Shows or Hides scroll bar in Text Host window 
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxShowScrollBar(
	INT  fnBar, 		//@parm	Specifies scroll bar(s) to be shown or hidden
	BOOL fShow)			//@parm	Specifies whether scroll bar is shown or hidden
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxShowScrollBar");

	Assert(_hwnd);
	LONG nMax;

	if(fnBar == SB_HORZ) 
		_pserv->TxGetHScroll(NULL, &nMax, NULL, NULL, NULL);
	else
		_pserv->TxGetVScroll(NULL, &nMax, NULL, NULL, NULL);

	return W32->ShowScrollBar(_hwnd, fnBar, fShow, nMax);
}

/* 
 *	CTxtWinHost::TxEnableScrollBar (fuSBFlags, fuArrowflags)
 *
 *	@mfunc
 *		Enables or disables one or both scroll bar arrows 
 *		in Text Host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return 
 *		value is TRUE. If the arrows are already in the requested state or an 
 *		error occurs, the return value is FALSE. 
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.	
 */
BOOL CTxtWinHost::TxEnableScrollBar (
	INT fuSBFlags, 		//@parm Specifies scroll bar type	
	INT fuArrowflags)	//@parm	Specifies whether and which scroll bar arrows
						//		are enabled or disabled
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxEnableScrollBar");

	Assert(_hwnd);
	return W32->EnableScrollBar(_hwnd, fuSBFlags, fuArrowflags);
}

/* 
 *	CTxtWinHost::TxSetScrollRange (fnBar, nMinPos, nMaxPos, fRedraw)
 *
 *	@mfunc
 *		Sets the minimum and maximum position values for the specified 
 *		scroll bar in the text host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return value
 *		is TRUE. If the arrows are already in the requested state or an error
 *		occurs, the return value is FALSE. 
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetScrollRange(
	INT	 fnBar, 		//@parm	Scroll bar flag
	LONG nMinPos, 		//@parm	Minimum scrolling position
	INT  nMaxPos, 		//@parm	Maximum scrolling position
	BOOL fRedraw)		//@parm	Specifies whether scroll bar should be redrawn
{						//		to reflect change
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetScrollRange");

	Assert(_hwnd);

	if(NULL == _pserv)
	{
		// We are initializing so do this instead of callback
		return ::SetScrollRange(_hwnd, fnBar, nMinPos, nMaxPos, fRedraw);
	}
	SetScrollInfo(fnBar, fRedraw);
	return TRUE;  
}

/* 
 *	CTxtWinHost::TxSetScrollPos (fnBar, nPos, fRedraw)
 *
 *	@mfunc
 *		Tells Text host to set the position of the scroll box (thumb) in the 
 *		specified scroll bar and, if requested, redraws the scroll bar to
 *		reflect the new position of the scroll box.
 *
 *	@rdesc
 *		TRUE on success; FALSE otherwise.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetScrollPos (
	INT		fnBar, 		//@parm	Scroll bar flag
	INT		nPos, 		//@parm	New position in scroll box
	BOOL	fRedraw)	//@parm	Redraw flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetScrollPos");

	Assert(_hwnd);

	if(NULL == _pserv)
	{
		// We are initializing so do this instead of callback
		return ::SetScrollPos(_hwnd, fnBar, nPos, fRedraw);
	}
	SetScrollInfo(fnBar, fRedraw);
	return TRUE;  
}

/* 
 *	CTxtWinHost::TxInvalidateRect (prc, fMode)
 *
 *	@mfunc
 *		Adds a rectangle to the Text Host window's update region
 *
 *	@comm
 *		This function may be called while inactive; however the host
 *		implementation is free to invalidate an area greater than
 *		the requested rect.
 *
 *	Note: In transparent mode, we need to pass TRUE to InvalidateRect.
 *	However, in all other cases, it is best to pass FALSE, because we always
 *	repaint the backgrounds of our displays.
 */
void CTxtWinHost::TxInvalidateRect(
	LPCRECT	prc, 		//@parm	Address of rectangle coordinates
	BOOL	fMode)		//@parm	Erase background flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxInvalidateRect");

	Assert(_hwnd);

	if(!_fVisible)
	{
		// There doesn't seem to be a deterministic way to determine whether
		// our window is visible or not via message notifications. Therefore,
		// we check this each time in case it might have changed.
		_fVisible = IsWindowVisible(_hwnd);

		if(_fVisible)
			OnTxVisibleChange(TRUE);
	}

	// Don't bother with invalidating rect if we aren't visible
	if(_fVisible)
	{
		if(IsTransparentMode())
		{
			RECT	rcParent;
			HWND	hParent = ::GetParent(_hwnd);
		
			Assert(hParent);

	 		// For transparent mode, we need to invalidate the parent
			// so it will paint the background.
			if(prc)
				rcParent = *prc;
			else
				TxGetClientRect(&rcParent);	

			::MapWindowPoints(_hwnd, hParent, (LPPOINT)&rcParent, 2);
			::InvalidateRect(hParent, &rcParent, TRUE);
//			::HideCaret(_hwnd);
		}
		::InvalidateRect(_hwnd, prc, FALSE);
	}
}

/* 
 *	CTxtWinHost::TxViewChange (fUpdate)
 *
 *	@mfunc
 *		Notify Text Host that update region should be repainted. 
 *	
 *	@comm
 *		It is the responsibility of the text services to call 
 *		TxViewChanged every time it decides that it's visual representation 
 *		has changed, regardless of whether the control is active or 
 *		not. If the control is active, the text services has the additional
 *		responsibility of making sure the controls window is updated.
 *		It can do this in a number of ways: 1) get a DC for the control's 
 *		window and start blasting pixels (TxGetDC and TxReleaseDC), 2) 
 *		invalidate the control's window (TxInvalidate), or 3) scroll 
 *		the control's window (TxScrollWindowEx).
 *
 *		Text services can choose to call TxViewChange after it has
 *		performed any operations to update the active view and pass a
 *		true along with the call.  By passing true, the text host
 *		calls UpdateWindow to make sure any unpainted areas of the
 *		active control are repainted.
 */
void CTxtWinHost::TxViewChange(
	BOOL fUpdate)		//@parm TRUE = call update window
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxViewChange");

	Assert(_hwnd);

	// Don't bother with paint since we aren't visible
	if(_fVisible)
	{
		// For updates requests that are FALSE, we will let the next WM_PAINT 
		// message pick up the draw.
		if(fUpdate)
		{
			if(IsTransparentMode())
			{
				HWND	hParent = GetParent (_hwnd);
				Assert(hParent);

	 			// For transparent mode, we need to update the parent first
				// before we can update ourself.  Otherwise, what we painted will
				// be erased by the parent's background later.
				::UpdateWindow (hParent);
			}
			::UpdateWindow (_hwnd);
		}
	}
}

/* 
 *	CTxtWinHost::TxCreateCaret (hbmp, xWidth, yHeight)
 *
 *	@mfunc
 *		Create new shape for Text Host's caret
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxCreateCaret(
	HBITMAP hbmp, 		//@parm Handle of bitmap for caret shape	
	INT xWidth, 		//@parm	Caret width
	INT yHeight)		//@parm	Caret height
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxCreateCaret");

	Assert(_hwnd);
	return ::CreateCaret (_hwnd, hbmp, xWidth, yHeight);
}

/* 
 *	CTxtWinHost::TxShowCaret (fShow)
 *
 *	@mfunc
 *		Make caret visible/invisible at caret position in Text Host window. 
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxShowCaret(
	BOOL fShow)			//@parm Flag whether caret is visible
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxShowCaret");

	return fShow ? ::ShowCaret(_hwnd)  :  ::HideCaret(_hwnd);
}

/* 
 *	CTxtWinHost::TxSetCaretPos (x, y)
 *
 *	@mfunc
 *		Move caret position to specified coordinates in Text Host window. 
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetCaretPos(
	INT x, 				//@parm	Horizontal position (in client coordinates)
	INT y)				//@parm	Vertical position (in client coordinates)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCaretPos");

	return ::SetCaretPos(x, y);
}

/* 
 *	CTxtWinHost::TxSetTimer (idTimer, uTimeout)
 *
 *	@mfunc
 *		Request Text Host to creates a timer with specified time out.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 */
BOOL CTxtWinHost::TxSetTimer(
	UINT idTimer, 		//@parm Timer identifier	
	UINT uTimeout)		//@parm	Timeout in msec
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetTimer");

	Assert(_hwnd);	
	return ::SetTimer(_hwnd, idTimer, uTimeout, NULL);
}

/* 
 *	CTxtWinHost::TxKillTimer (idTimer)
 *
 *	@mfunc
 *		Destroy specified timer
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method may be called at any time irrespective of active versus
 *		inactive state.
 */
void CTxtWinHost::TxKillTimer(
	UINT idTimer)		//@parm	id of timer
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxKillTimer");

	Assert(_hwnd);			
	::KillTimer(_hwnd, idTimer);
}

/* 
 *	CTxtWinHost::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *									lprcUpdate, fuScroll)
 *	@mfunc
 *		Request Text Host to scroll the content of the specified client area
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtWinHost::TxScrollWindowEx (
	INT		dx, 			//@parm	Amount of horizontal scrolling
	INT		dy, 			//@parm	Amount of vertical scrolling
	LPCRECT lprcScroll, 	//@parm	Scroll rectangle
	LPCRECT lprcClip,		//@parm	Clip rectangle
	HRGN	hrgnUpdate, 	//@parm	Handle of update region
	LPRECT	lprcUpdate,		//@parm	Update rectangle
	UINT	fuScroll)		//@parm	Scrolling flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxScrollWindowEx");

	Assert(_hwnd);
	::ScrollWindowEx(_hwnd, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate, fuScroll);
}

/* 
 *	CTxtWinHost::TxSetCapture (fCapture)
 *
 *	@mfunc
 *		Set mouse capture in Text Host's window.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may do nothing.
 */
void CTxtWinHost::TxSetCapture(
	BOOL fCapture)		//@parm	Whether to get or release capture
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCapture");

	Assert(_hwnd);
	if (fCapture)
		::SetCapture(_hwnd);
	else
		::ReleaseCapture();
}

/* 
 *	CTxtWinHost::TxSetFocus ()
 *
 *	@mfunc
 *		Set focus in text host window.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtWinHost::TxSetFocus()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetFocus");

	Assert(_hwnd);
	::SetFocus(_hwnd);
}

/* 
 *	CTxtWinHost::TxSetCursor (hcur, fText)
 *
 *	@mfunc
 *		Establish a new cursor shape in the Text Host's window.
 *
 *	@comm
 *		This method may be called at any time, irrespective of 
 *		active vs. inactive state.
 *
 *		ITextHost::TxSetCursor should be called back by the Text Services 
 *		to actually set the mouse cursor. If the fText parameter is TRUE, 
 *		Text Services is trying to set the "text" cursor (cursor over text 
 *		that is not selected, currently an IBEAM). In that case, the host 
 *		can set it to whatever the control MousePointer property is. This is 
 *		required by VB compatibility since, via the MousePointer property, 
 *		the VB programmer has control over the shape of the mouse cursor, 
 *		whenever it would normally be set to an IBEAM.
 */
void CTxtWinHost::TxSetCursor(
	HCURSOR hcur,		//@parm	Handle to cursor
	BOOL	fText)		//@parm Indicates caller wants to set text cursor
						//		(IBeam) if true.
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCursor");

	::SetCursor(hcur);
}

/* 
 *	CTxtWinHost::TxScreenToClient (lppt)
 *
 *	@mfunc
 *		Convert screen coordinates to Text Host window coordinates.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 */
BOOL CTxtWinHost::TxScreenToClient(
	LPPOINT lppt)		//@parm	Coordinates for point
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxScreenToClient");

	Assert(_hwnd);
	return ::ScreenToClient(_hwnd, lppt);	
}

/* 
 *	CTxtWinHost::TxClientToScreen (lppt)
 *
 *	@mfunc
 *		Convert Text Host coordinates to screen coordinates 
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This call is valid at any time, although it is allowed to
 *		fail.  In general, if text services has coordinates it needs
 *		to translate from client coordinates (e.g. for TOM's 
 *		PointFromRange method) the text services will actually be 
 *		visible.
 *
 *		However, if no conversion is possible, then the method will fail.
 */
BOOL CTxtWinHost::TxClientToScreen(
	LPPOINT lppt)		//@parm	Client coordinates to convert.
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxClientToScreen");

	Assert(_hwnd);
	return ::ClientToScreen(_hwnd, lppt);
}

/* 
 *	CTxtWinHost::TxActivate (plOldState)
 *
 *	@mfunc
 *		Notify Text Host that control is active
 *
 *	@rdesc	
 *		S_OK 	- call succeeded. <nl>
 *		E_FAIL	- activation is not possible at this time
 *
 *	@comm
 *		It is legal for the host to refuse an activation request;
 *		the control may be minimized and thus invisible, for instance.
 *
 *		The caller should be able to gracefully handle failure to activate.
 *
 *		Calling this method more than once does not cumulate; only
 *		once TxDeactivate call is necessary to deactive.
 *
 *		This function returns an opaque handle in <p plOldState>. The caller
 *		(Text Services) should hang onto this handle and return it in a
 *		subsequent call to TxDeactivate.
 */
HRESULT CTxtWinHost::TxActivate(
	LONG *plOldState)	//@parm Where to put previous activation state
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxActivate");

	return S_OK;
}

/* 
 *	CTxtWinHost::TxDeactivate (lNewState)
 *
 *	@mfunc
 *		Notify Text Host that control is now inactive
 *
 *	@rdesc	
 *		S_OK - call succeeded. <nl>
 *		E_FAIL				   <nl>
 *
 *	@comm
 *		Calling this method more than once does not cumulate
 */
HRESULT CTxtWinHost::TxDeactivate(
	LONG lNewState)		//@parm	New state (typically value returned by
						//		TxActivate
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxDeactivate");

	return S_OK;
}
	
/* 
 *	CTxtWinHost::TxGetClientRect (prc)
 *
 *	@mfunc
 *		Retrieve client coordinates of Text Host's client area.
 *
 *	@rdesc
 *		HRESULT = (success) ? S_OK : E_FAIL
 */
HRESULT CTxtWinHost::TxGetClientRect(
	LPRECT prc)		//@parm	Where to put client coordinates
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetClientRect");

	Assert(_hwnd && prc);
	return ::GetClientRect(_hwnd, prc) ? S_OK : E_FAIL;
}

/* 
 *	CTxtWinHost::TxGetViewInset	(prc)
 *
 *	@mfunc
 *		Get inset for Text Host window.  Inset is the "white space"
 *		around text.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		The Inset rectangle is not strictly a rectangle.  The top, bottom,
 *		left, and right fields of the rect structure indicate how far in
 *		each direction drawing should be inset. Inset sizes are in client
 *		coordinates.
 */
HRESULT CTxtWinHost::TxGetViewInset(
	LPRECT prc)			//@parm Where to put inset rectangle	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetViewInset");

	Assert(prc);

	*prc = _rcViewInset;
	return NOERROR;	
}

/* 
 *	CTxtWinHost::TxGetCharFormat (ppCF)
 *
 *	@mfunc
 *		Get Text Host's default character format
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL (not needed in simple Windows host, since text
 *		services provides desired default)
 *
 *	@comm
 *		The callee retains ownwership of the charformat returned.  However,
 *		the pointer returned must remain valid until the callee notifies
 *		Text Services via OnTxPropertyBitsChange that the default character
 *		format has changed.
 */
HRESULT CTxtWinHost::TxGetCharFormat(
	const CHARFORMAT **ppCF) 		//@parm	Where to put ptr to default
									//		character format
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetCharFormat");

	return E_NOTIMPL;
}

/* 
 *	CTxtWinHost::TxGetParaFormat (ppPF)
 *
 *	@mfunc
 *		Get Text Host default paragraph format
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL (not needed in simple Windows host, since text
 *		services provides desired default)
 *
 *	@comm
 *		The host object (callee) retains ownership of the PARAFORMAT returned.
 *		However, the pointer returned must remain valid until the host notifies
 *		Text Services (the caller) via OnTxPropertyBitsChange that the default
 *		paragraph format has changed.
 */
HRESULT CTxtWinHost::TxGetParaFormat(
	const PARAFORMAT **ppPF) 	//@parm Where to put ptr to default
								//		paragraph format
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetParaFormat");

	return E_NOTIMPL;
}

/* 
 *	CTxtWinHost::TxGetSysColor (nIndex)
 *
 *	@mfunc
 *		Get specified color identifer from Text Host.
 *
 *	@rdesc
 *		Color identifier
 *
 *	@comm
 *		Note that the color returned may be *different* than the
 *		color that would be returned from a call to GetSysColor.
 *		This allows hosts to override default system behavior.
 *
 *		Needless to say, hosts should be very careful about overriding
 *		normal system behavior as it could result in inconsistent UI
 *		(particularly with respect to Accessibility	options).
 */
COLORREF CTxtWinHost::TxGetSysColor(
	int nIndex)			//@parm Color to get, same parameter as
						//		GetSysColor Win32 API
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetSysColor");

	if (!_fDisabled ||
		nIndex != COLOR_WINDOW && nIndex != COLOR_WINDOWTEXT)
	{
		// This window is not disabled or the color is not interesting
		// in the disabled case.
		return (nIndex == COLOR_WINDOW && _fNotSysBkgnd)
			? _crBackground : GetSysColor(nIndex);
	}

	// Disabled case
	if (COLOR_WINDOWTEXT == nIndex)
	{
		// Color of text for disabled window
		return GetSysColor(COLOR_GRAYTEXT);
	}

	// Background color for disabled window
	return GetSysColor(COLOR_3DFACE);
	
}

/* 
 *	CTxtWinHost::TxGetBackStyle	(pstyle)
 *
 *	@mfunc
 *		Get Text Host background style.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@xref	<e TXTBACKSTYLE>
 */
HRESULT CTxtWinHost::TxGetBackStyle(
	TXTBACKSTYLE *pstyle)  //@parm Where to put background style
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetBackStyle");

	*pstyle = (_dwExStyle & WS_EX_TRANSPARENT)
			? TXTBACK_TRANSPARENT : TXTBACK_OPAQUE;
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxGetMaxLength	(pLength)
 *
 *	@mfunc
 *		Get Text Host's maximum allowed length.
 *
 *	@rdesc
 *		HRESULT = S_OK	
 *
 *	@comm
 *		This method parallels the EM_LIMITTEXT message.
 *		If INFINITE (0xFFFFFFFF) is returned, then text services
 *		will use as much memory as needed to store any given text.
 *
 *		If the limit returned is less than the number of characters
 *		currently in the text engine, no data is lost.  Instead,
 *		no edits will be allowed to the text *other* than deletion
 *		until the text is reduced to below the limit.
 */
HRESULT CTxtWinHost::TxGetMaxLength(
	DWORD *pLength) 	//@parm Maximum allowed length, in number of 
						//		characters
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetMaxLength");
	AssertSz(FALSE, "CTxtWinHost::TxGetMaxLength why is this being called?");
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxGetScrollBars (pdwScrollBar)
 *
 *	@mfunc
 *		Get Text Host's scroll bars supported.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@comm
 *		<p pdwScrollBar> is filled with a boolean combination of the 
 *		window styles related to scroll bars.  Specifically, these are:
 *
 *			WS_VSCROLL	<nl>
 *			WS_HSCROLL	<nl>
 *			ES_AUTOVSCROLL	<nl>
 *			ES_AUTOHSCROLL	<nl>
 *			ES_DISABLENOSCROLL	<nl>
 */
HRESULT CTxtWinHost::TxGetScrollBars(
	DWORD *pdwScrollBar) 	//@parm Where to put scrollbar information
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetScrollBars");

	*pdwScrollBar =  _dwStyle & (WS_VSCROLL | WS_HSCROLL | ES_AUTOVSCROLL | 
						ES_AUTOHSCROLL | ES_DISABLENOSCROLL);
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxGetPasswordChar (pch)
 *
 *	@mfunc
 *		Get Text Host's password character.
 *
 *	@rdesc
 *		HRESULT = (password character not enabled) ? S_FALSE : S_OK
 *
 *	@comm
 *		The password char will only be shown if the TXTBIT_USEPASSWORD bit
 *		is enabled in TextServices.  If the password character changes,
 *		re-enable the TXTBIT_USEPASSWORD bit via 
 *		ITextServices::OnTxPropertyBitsChange.
 */
HRESULT CTxtWinHost::TxGetPasswordChar(
	TCHAR *pch)		//@parm Where to put password character
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetPasswordChar");

	*pch = _chPassword;
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxGetAcceleratorPos (pcp)
 *
 *	@mfunc
 *		Get special character to use for underlining accelerator character.
 *
 *	@rdesc
 *		Via <p pcp>, returns character position at which underlining 
 *		should occur.  -1 indicates that no character should be underlined. 
 *		Return value is an HRESULT (usually S_OK).
 *
 *	@comm
 *		Accelerators allow keyboard shortcuts to various UI elements (like
 *		buttons.  Typically, the shortcut character is underlined.
 *
 *		This function tells Text Services which character is the accelerator
 *		and thus should be underlined.  Note that Text Services will *not*
 *		process accelerators; that is the responsiblity of the host.
 *
 *		This method will typically only be called if the TXTBIT_SHOWACCELERATOR
 *		bit is set in text services.  
 *
 *		Note that *any* change to the text in text services will result in the
 *		invalidation of the accelerator underlining.  In this case, it is the 
 *		host's responsibility to recompute the appropriate character position 
 *		and inform text services that a new accelerator is available.
 */
HRESULT CTxtWinHost::TxGetAcceleratorPos(
	LONG *pcp) 		//@parm Out parm to receive cp of character to underline
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetAcceleratorPos");

	*pcp = -1;
	return S_OK;
} 										   

/* 
 *	CTxtWinHost::OnTxCharFormatChange
 *
 *	@mfunc
 *		Set default character format for the Text Host.
 *
 *	@rdesc
 *		S_OK - call succeeded.	<nl>
 *		E_INVALIDARG			<nl>
 *		E_FAIL					<nl>
 */
HRESULT CTxtWinHost::OnTxCharFormatChange(
	const CHARFORMAT *pcf) //@parm New default character format	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::OnTxCharFormatChange");

	return S_OK;
}

/* 
 *	CTxtWinHost::OnTxParaFormatChange
 *
 *	@mfunc
 *		Set default paragraph format for the Text Host.
 *
 *	@rdesc
 *		S_OK - call succeeded.	<nl>
 *		E_INVALIDARG			<nl>
 *		E_FAIL					<nl>
 */
HRESULT CTxtWinHost::OnTxParaFormatChange(
	const PARAFORMAT *ppf) //@parm New default paragraph format	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::OnTxParaFormatChange");

	return S_OK;
}

/* 
 *	CTxtWinHost::TxGetPropertyBits (dwMask, dwBits)
 *
 *	@mfunc
 *		Get the bit property settings for Text Host.
 *
 *	@rdesc
 *		S_OK
 *
 *	@comm
 *		This call is valid at any time, for any combination of
 *		requested property bits.  <p dwMask> may be used by the
 *		caller to request specific properties.	
 */
HRESULT CTxtWinHost::TxGetPropertyBits(
	DWORD dwMask,		//@parm	Mask of bit properties to get
	DWORD *pdwBits)		//@parm Where to put bit values
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetPropertyBits");

// FUTURE: Obvious optimization is to save bits in host the same way that
// they are returned and just return them instead of this mess.

	// Note: this RichEdit host never sets TXTBIT_SHOWACCELERATOR or
	// TXTBIT_SAVESELECTION. They are currently only used by Forms^3 host.
	// This host is always rich text.

	DWORD dwProperties = TXTBIT_RICHTEXT | TXTBIT_ALLOWBEEP;

#ifdef DEBUG
	// make sure that TS doesn't think it's plain text mode when
	// we return TXTBIT_RICHTEXT
	if((dwMask & TXTBIT_RICHTEXT) && _pserv)
	{
		DWORD mode;
		mode = _pserv->TxSendMessage(EM_GETTEXTMODE, 0, 0, NULL);
		Assert(mode == TM_RICHTEXT);
	}
#endif // DEBUG

	if(_dwStyle & ES_MULTILINE)
		dwProperties |= TXTBIT_MULTILINE;

	if(_dwStyle & ES_READONLY)
		dwProperties |= TXTBIT_READONLY;

	if(_dwStyle & ES_PASSWORD)
		dwProperties |= TXTBIT_USEPASSWORD;

	if(!(_dwStyle & ES_NOHIDESEL))
		dwProperties |= TXTBIT_HIDESELECTION;

	if(_fEnableAutoWordSel)
		dwProperties |= TXTBIT_AUTOWORDSEL;

	if(!(_dwStyle & ES_AUTOHSCROLL))
		dwProperties |= TXTBIT_WORDWRAP;

	if(_dwStyle & ES_VERTICAL)
		dwProperties |= TXTBIT_VERTICAL;

	if(_dwStyle & ES_NOOLEDRAGDROP) 
		dwProperties |= TXTBIT_DISABLEDRAG;

	*pdwBits = dwProperties & dwMask; 
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  Direct events are sent immediately as
 *		they need some processing: EN_PROTECTED is a canonical
 *		example.  Delayed events are sent after all processing
 *		has occurred; the control is thus in a "stable" state.
 *		EN_CHANGE, EN_ERRSPACE, EN_SELCHANGED are examples
 *		of delayed notifications.
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		The notification events are the same as the notification
 *		messages sent to the parent window of a richedit window.
 *		The firing of events may be controlled with a mask set via
 *		the EM_SETEVENTMASK message.
 *
 *		In general, is legal to make any calls to text services while
 *		processing this method; however, implementors are cautioned
 *		to avoid excessive recursion. 
 *
 *		Here is the complete list of notifications that may be
 *		sent and a brief description of each:
 *
 *		<p EN_CHANGE>		Sent when some data in the edit control
 *		changes (such as text or formatting).  Controlled by the
 *		ENM_CHANGE event mask.  This notification is sent _after_
 *		any screen updates have been requested. 
 *
 *		<p EN_CORRECTTEXT>	PenWin only; currently unused.
 *
 *		<p EN_DROPFILES>	If the client registered the edit
 *		control via DragAcceptFiles, this event will be sent when
 *		a WM_DROPFILES or DragEnter(CF_HDROP) message is received.
 *		If S_FALSE is returned, the drop will be ignored, otherwise,
 *		the drop will be processed.  The ENM_DROPFILES mask
 *		controls this event notification.
 *
 *		<p EN_ERRSPACE>		Sent when the edit control cannot
 *		allocate enough memory.  No additional data is sent and
 *		there is no mask for this event.
 *
 *		<p EN_HSCROLL>		Sent when the user clicks on an edit
 *		control's horizontal scroll bar, but before the screen
 *		is updated.  No additional data is sent.  The ENM_SCROLL
 *		mask controls this event.
 *
 *		<p EN_IMECHANGE>	unused
 *
 *		<p EN_KILLFOCUS>	Sent when the edit control looses focus.
 *		No additional data is sent and there is no mask.
 *
 *		<p EN_MAXTEXT>	Sent when the current text insertion
 *		has exceeded the specified number of characters for the
 *		edit control.  The text insertion has been truncated.  
 *		There is no mask for this event.
 *
 *		<p EN_MSGFILTER>	NB!!! THIS MESSAGE IS NOT SENT TO
 *		TxNotify, but is included here for completeness.  With
 *		ITextServices::TxSendMessage, client have complete
 *		flexibility in filtering all window messages.
 *	
 *		Sent on a keyboard or mouse event
 *		in the control.  A MSGFILTER data structure is sent, 
 *		containing the msg, wparam and lparam.  If S_FALSE is
 *		returned from this notification, the msg is processed by
 *		TextServices, otherwise, the message is ignored.  Note
 *		that in this case, the callee has the opportunity to modify
 *		the msg, wparam, and lparam before TextServices continues
 *		processing.  The ENM_KEYEVENTS and ENM_MOUSEEVENTS masks
 *		control this event for the respective event types.
 *
 *		<p EN_OLEOPFAILED> 	Sent when an OLE call fails.  The
 *		ENOLEOPFAILED struct is passed with the index of the object
 *		and the error code.  Mask value is nothing.
 *		
 *		<p EN_PROTECTED>	Sent when the user is taking an
 *		action that would change a protected range of text.  An
 *		ENPROTECTED data structure is sent, indicating the range
 *		of text affected and the window message (if any) affecting
 *		the change.  If S_FALSE is returned, the edit will fail.
 *		The ENM_PROTECTED mask controls this event.
 *
 *		<p EN_REQUESTRESIZE>	Sent when a control's contents are
 *		either smaller or larger than the control's window size.
 *		The client is responsible for resizing the control.  A
 *		REQRESIZE structure is sent, indicating the new size of
 *		the control.  NB!  Only the size is indicated in this
 *		structure; it is the host's responsibility to do any 
 *		translation necessary to generate a new client rectangle.
 *		The ENM_REQUESTRESIZE mask controls this event.
 *
 *		<p EN_SAVECLIPBOARD> Sent when an edit control is being
 *		destroyed, the callee should indicate whether or not 
 *		OleFlushClipboard should be called.  Data indicating the
 *		number of characters and objects to be flushed is sent
 *		in the ENSAVECLIPBOARD data structure.
 *		Mask value is nothing.
 *
 *		<p EN_SELCHANGE>	Sent when the current selection has
 *		changed.  A SELCHANGE data structure is also sent, which
 *		indicates the new selection range at the type of data
 *		the selection is currently over.  Controlled via the
 *		ENM_SELCHANGE mask.
 *
 *		<p EN_SETFOCUS>	Sent when the edit control receives the
 *		keyboard focus.  No extra data is sent; there is no mask.
 *
 *		<p EN_STOPNOUNDO>	Sent when an action occurs for which
 *		the control cannot allocate enough memory to maintain the
 *		undo state.  If S_FALSE is returned, the action will be
 *		stopped; otherwise, the action will continue.
 *
 *		<p EN_UPDATE>	Sent before an edit control requests a
 *		redraw of altered data or text.  No additional data is
 *		sent.  This event is controlled via the ENM_UPDATE mask.
 *
 *		<p EN_VSCROLL>	Sent when the user clicks an edit control's
 *		vertical scrollbar bar before the screen is updated.
 *		Controlled via the ENM_SCROLL mask; no extra data is sent.
 *
 *		<p EN_LINK>		Sent when a mouse event (or WM_SETCURSOR) happens
 *		over a range of text that has the EN_LINK mask bit set.
 *		An ENLINK data structure will be sent with relevant info.
 */
HRESULT CTxtWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxNotify");

	HRESULT		hr = NOERROR;
	LONG		nId;
	NMHDR *		phdr;
	REQRESIZE *	preq;
	RECT		rcOld;

	// We assume here that TextServices has already masked out notifications,
	// so if we get one here, it should be sent
	if(_hwndParent)
	{
		nId = GetWindowLong(_hwnd, GWL_ID);
		// First, handle WM_NOTIFY style notifications
		switch(iNotify)
		{
		case EN_REQUESTRESIZE:
			// Need to map new size into correct rectangle
			Assert(pv);
			GetWindowRect(_hwnd, &rcOld);
			MapWindowPoints(HWND_DESKTOP, _hwndParent, (POINT *) &rcOld, 2);
			
			preq = (REQRESIZE *)pv;
			preq->rc.top	= rcOld.top;
			preq->rc.left	= rcOld.left;
			preq->rc.right	+= rcOld.left;
			preq->rc.bottom += rcOld.top;

			// FALL-THROUGH!!
					
		case EN_DROPFILES:
		case EN_MSGFILTER:
		case EN_OLEOPFAILED:
		case EN_PROTECTED:
		case EN_SAVECLIPBOARD:
		case EN_SELCHANGE:
		case EN_STOPNOUNDO:
		case EN_LINK:
		case EN_OBJECTPOSITIONS:
		case EN_DRAGDROPDONE:
		case EN_LOWFIRTF:
		case EN_CLIPFORMAT:
	
			if(pv)						// Fill out NMHDR portion of pv
			{
				phdr = (NMHDR *)pv;
  				phdr->hwndFrom = _hwnd;
				phdr->idFrom = nId;
				phdr->code = iNotify;
			}

			if(SendMessage(_hwndParent, WM_NOTIFY, (WPARAM) nId, (LPARAM) pv))
				hr = S_FALSE;
			break;

		default:
			SendMessage(_hwndParent, WM_COMMAND, 
					GET_WM_COMMAND_MPS(nId, _hwnd, iNotify));
		}
	}

	return hr;
}

/*
 *	CTxtWinHost::TxGetExtent (lpExtent)
 *
 *	@mfunc
 *		Return native size of the control in HIMETRIC
 *
 *	@rdesc
 *		S_OK	<nl>
 *		some failure code <nl>
 *
 *	@comm
 *		This method is used by Text Services to implement zooming.
 *		Text Services would derive the zoom factor from the ratio between 
 *		the himetric and device pixel extent of the client rectangle.
 *	
 *		[vertical zoom factor] = [pixel height of the client rect] * 2540
 *		/ [himetric vertical extent] * [pixel per vertical inch (from DC)]
 *	
 *		If the vertical and horizontal zoom factors are not the same, Text 
 *		Services could ignore the horizontal zoom factor and assume it is 
 *		the same as the vertical one.
 */
HRESULT CTxtWinHost::TxGetExtent(
	LPSIZEL lpExtent) 	//@parm  Extent in himetric
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetExtent");

	AssertSz(lpExtent, "CTxtWinHost::TxGetExtent Invalid lpExtent");

	// We could implement the TxGetExtent in the following way. However, the
	// call to this in ITextServices is implemented in such a way that it 
	// does something sensible in the face of an error in this call. That 
	// something sensible is that it sets the extent equal to the current
	// client rectangle which is what the following does in a rather convoluted
	// manner. Therefore, we dump the following and just return an error.


#if 0
	// The window's host extent is always the same as the client
	// rectangle.
	RECT rc;
	HRESULT hr = TxGetClientRect(&rc);

	// Get our client rectangle
	if(SUCCEEDED(hr))
	{
		// Calculate the length & convert to himetric
		lpExtent->cx = DXtoHimetricX(rc.right - rc.left, W32->GetXPerInchScreenDC());
		lpExtent->cy = DYtoHimetricY(rc.bottom - rc.top, W32->GetYPerInchScreenDC());
	}

	return hr;
#endif // 0

	return E_NOTIMPL;
}

 HRESULT CTxtWinHost::TxEBookLoadImage( LPWSTR lpszName, LPARAM * pID, SIZE * psize, DWORD *pdwFlags)  
{
    return E_NOTIMPL;
}

HRESULT CTxtWinHost::TxEBookImageDraw(LPARAM ID, HDC hdc, POINT *topLeft, RECT  *prcRenderint,
                                BOOL fSelected)
{
    return E_NOTIMPL;
}

HRESULT CTxtWinHost::TxGetHorzExtent(LONG *plHorzExtent)
{
    return E_NOTIMPL;
}

/*
 *	CTxtWinHost::TxGetSelectionBarWidth (lSelBarWidth)
 *
 *	@mfunc
 *		Returns size of selection bar in HIMETRIC
 *
 *	@rdesc
 *		S_OK	<nl>
 */
HRESULT	CTxtWinHost::TxGetSelectionBarWidth (
	LONG *lSelBarWidth)		//@parm  Where to return selection bar width 
							// in HIMETRIC
{
	*lSelBarWidth = (_dwStyle & ES_SELECTIONBAR) ? W32->GetDxSelBar() : 0;
	return S_OK;
}

//
//	ITextHost2 methods
//

/*
 *	CTxtWinHost::TxIsDoubleClickPending
 *
 *	@mfunc	Look into the message queue for this hwnd and see if a
 *			double click is pending.  This enables TextServices to 
 *			effeciently transition between two inplace active objects.
 *
 *	@rdesc	BOOL
 */
BOOL CTxtWinHost::TxIsDoubleClickPending()
{
	MSG msg;

	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, 
			"CTxtWinHost::TxIsDoubleClickPending");

	if(PeekMessage(&msg, _hwnd, WM_LBUTTONDBLCLK, WM_LBUTTONDBLCLK,
			PM_NOREMOVE | PM_NOYIELD))
	{
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtWinHost::TxGetWindow
 *
 *	@mfunc	Fetches the window associated with this control (or
 *			set of controls potentially).  Useful for answering 
 *			IOleWindow::GetWindow.
 *
 *	@rdesc	HRESULT
 */
HRESULT CTxtWinHost::TxGetWindow(HWND *phwnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::GetWindow");
	
	*phwnd = _hwnd;
	return NOERROR;
}	


/*
 *	CTxtWinHost::SetForegroundWindow
 *
 *	@mfunc	Sets window to foreground window & gives the focus
 *
 *	@rdesc	NOERROR - succeeded
 *			E_FAIL - failed.
 */
HRESULT CTxtWinHost::TxSetForegroundWindow()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, 
		"CTxtWinHost::SetForegroundWindow");

	if(!SetForegroundWindow(_hwnd))
		SetFocus(_hwnd);

	return NOERROR;
}	


/*
 *	CTxtWinHost::TxGetPalette
 *
 *	@mfunc	Returns application specific palette if there is one
 *
 *	@rdesc	~NULL - there was one
 *			NULL - use default palette
 */
HPALETTE CTxtWinHost::TxGetPalette()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, 
		"CTxtWinHost::TxGetPalette");

	return _hpal;
}	


/*
 *	CTxtWinHost::TxGetFEFlags
 *
 *	@mfunc	return FE settings
 *
 *	@rdesc	NOERROR - succeeded
 *			E_FAIL - failed.
 */
HRESULT CTxtWinHost::TxGetFEFlags(LONG *pFEFlags)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, 
		"CTxtWinHost::TxGetFEFlags");

	if (!pFEFlags)
		return E_INVALIDARG;
	*pFEFlags = 0;

	if (_usIMEMode == ES_NOIME)
		*pFEFlags |= ES_NOIME;
	if (_usIMEMode == ES_SELFIME)
		*pFEFlags |= ES_SELFIME;

	return NOERROR;
}


// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);


/*
 *	CTxtWinHost::OnSetMargins
 *
 *	@mfunc	Handle EM_SETMARGINS message
 *
 *	@rdesc	None.
 */
void CTxtWinHost::OnSetMargins(
	DWORD fwMargin,		//@parm Type of requested operation
	DWORD xLeft,		//@parm Where to put left margin
	DWORD xRight)		//@parm Where to put right margin
{
	LONG xLeftMargin = -1;
	LONG xRightMargin = -1;
	HDC hdc;

	if(EC_USEFONTINFO == fwMargin)
	{
		// Get the DC since it is needed for the call
		hdc = GetDC(_hwnd);

		// Multiline behaves differently than single line
		if (_dwStyle & ES_MULTILINE)
		{
			// Multiline - over/underhange controls margin
			GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), NULL, 
				&xLeftMargin, &xRightMargin);
		}
		else
		{
			// Single line edit controls set the margins to 
			// the average character width on both left and
			// right.
			GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), &xLeftMargin, NULL, NULL);

			xRightMargin = xLeftMargin;
		}
		ReleaseDC(_hwnd, hdc);
	}
	else
	{
		// The request is for setting exact pixels.
		if(EC_LEFTMARGIN & fwMargin)
			xLeftMargin = xLeft;

		if(EC_RIGHTMARGIN & fwMargin)
			xRightMargin = xRight;
	}

	// Set left margin if so requested
	if (xLeftMargin != -1)
		_rcViewInset.left =	W32->DeviceToHimetric(xLeftMargin, W32->GetXPerInchScreenDC());

	// Set right margin if so requested
	if (xRightMargin != -1)
		_rcViewInset.right = W32->DeviceToHimetric(xRightMargin, W32->GetXPerInchScreenDC());

	if (xLeftMargin != -1 || xRightMargin != -1)
		_pserv->OnTxPropertyBitsChange(TXTBIT_VIEWINSETCHANGE, TXTBIT_VIEWINSETCHANGE);
}

/*
 *	CTxtWinHost::SetScrollInfo
 *
 *	@mfunc	Set scrolling information for the scroll bar.
 */
void CTxtWinHost::SetScrollInfo(
	INT fnBar,			//@parm	Specifies scroll bar to be updated
	BOOL fRedraw)		//@parm whether redraw is necessary
{
	// Set up the basic structure for the call
	SCROLLINFO si;
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_ALL;

	AssertSz(_pserv != NULL, 
		"CTxtWinHost::SetScrollInfo called with NULL _pserv");

	// Call back to the control to get the parameters
	if(fnBar == SB_HORZ)
	{
		_pserv->TxGetHScroll((LONG *) &si.nMin, (LONG *) &si.nMax, 
			(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
	}
	else
	{
		_pserv->TxGetVScroll((LONG *) &si.nMin, 
			(LONG *) &si.nMax, (LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
	}

	// Do the call
	::SetScrollInfo(_hwnd, fnBar, &si, fRedraw);
}

/*
 *	CTxtWinHost::SetScrollBarsForWmEnable
 *
 *	@mfunc	Enable/Disable scroll bars
 *
 *	@rdesc	None.
 */
void CTxtWinHost::SetScrollBarsForWmEnable(
	BOOL fEnable)		//@parm Whether scrollbars s/b enabled or disabled.
{
	if(!_pserv)						// If no edit object,
		return;						//  no scrollbars

	BOOL fHoriz = FALSE;
	BOOL fVert = FALSE;
	UINT wArrows = fEnable ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH;

	_pserv->TxGetHScroll(NULL, NULL, NULL, NULL, &fHoriz);
	_pserv->TxGetVScroll(NULL, NULL, NULL, NULL, &fVert);

	if(fHoriz)						// There is a horizontal scroll bar
		W32->EnableScrollBar(_hwnd, SB_HORZ, wArrows);

	if(fVert)						// There is a vertical scroll bar
		W32->EnableScrollBar(_hwnd, SB_VERT, wArrows);
}

/*
 *	CTxtWinHost::SetScrollBarsForWmEnable
 *
 *	@mfunc	Notification that Text Services is released.
 *
 *	@rdesc	None.
 */
void CTxtWinHost::TxFreeTextServicesNotification()
{
	_fTextServiceFree = TRUE;
}

/*
 *	CTxtWinHost::TxGetEditStyle
 *
 *	@mfunc	Get Edit Style flags
 *
 *	@rdesc	NOERROR is data available.
 */
HRESULT CTxtWinHost::TxGetEditStyle(
	DWORD dwItem, 
	DWORD *pdwData)
{
	if (!pdwData)
		return E_INVALIDARG;
	
	*pdwData = 0;

	if (dwItem & TXES_ISDIALOG && _fInDialogBox)
		*pdwData |= TXES_ISDIALOG;

	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetWindowStyles
 *
 *	@mfunc	Return window style bits
 *
 *	@rdesc	NOERROR is data available.
 */
HRESULT CTxtWinHost::TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle)
{
	if (!pdwStyle || !pdwExStyle)
		return E_INVALIDARG;

	*pdwStyle = _dwStyle;
	*pdwExStyle = _dwExStyle;

	return NOERROR;
}

#endif // NOWINDOWHOSTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\hwxink.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#define iverbInkRecog 351
#define iverbInkAlternates 352

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/


#ifndef __HWXInk_h__
#define __HWXInk_h__

#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITfRange_FWD_DEFINED__
#define __ITfRange_FWD_DEFINED__
typedef interface ITfRange ITfRange;
#endif 	/* __ITfRange_FWD_DEFINED__ */

#ifndef __IInk_FWD_DEFINED__
#define __IInk_FWD_DEFINED__
typedef interface IInk IInk;
#endif 	/* __IInk_FWD_DEFINED__ */


#ifndef __ILineInfo_FWD_DEFINED__
#define __ILineInfo_FWD_DEFINED__
typedef interface ILineInfo ILineInfo;
#endif 	/* __ILineInfo_FWD_DEFINED__ */

#ifndef __IThorFnConversion_FWD_DEFINED__
#define __IThorFnConversion_FWD_DEFINED__
typedef interface IThorFnConversion IThorFnConversion;
#endif 	/* __IThorFnConversion_FWD_DEFINED__ */

#ifndef __Ink_FWD_DEFINED__
#define __Ink_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ink Ink;
#else
typedef struct Ink Ink;
#endif /* __cplusplus */

#endif 	/* __Ink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_HWXInk_0000 */
/* [local] */ 

typedef struct  tagINKMETRIC
    {
    UINT iHeight;
    UINT iFontAscent;
    UINT iFontDescent;
    UINT iWeight;
    BOOL fFontHDC;
    DWORD dwAmbientProps;
    COLORREF color;
    BOOL fItalic;
    UINT nItalicPitch;
    DWORD dwReserved;
    }	INKMETRIC;

typedef struct  tagSTROKEHEADER
    {
    UINT cByteCount;
    UINT cByteOffset;
    DWORD dwFlags;
    RECT rectBounds;
    }	STROKEHEADER;

typedef struct  tagSTROKE
    {
    UINT cPoints;
    BOOL fUpStroke;
    POINT __RPC_FAR *pPoints;
    UINT __RPC_FAR *pPressure;
    UINT __RPC_FAR *pTime;
    UINT __RPC_FAR *pAngle;
    }	STROKE;

typedef struct  tagSTROKELIST
    {
    UINT cStrokes;
    STROKE __RPC_FAR *pStrokes;
    }	STROKELIST;


enum __MIDL___MIDL_itf_HWXInk_0000_0001
    {	LOSSY	= 0x1,
	LOSSLESS	= 0x2,
	XYPOINTS	= 0x4,
	PRESSURE	= 0x8,
	TIME	= 0x10,
	ANGLE	= 0x20
    };


extern RPC_IF_HANDLE __MIDL_itf_HWXInk_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HWXInk_0000_v0_0_s_ifspec;

#ifndef __IInk_INTERFACE_DEFINED__
#define __IInk_INTERFACE_DEFINED__

/* interface IInk */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IInk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03F8E511-43A1-11D3-8BB6-0080C7D6BAD5")
    IInk : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInk __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInk __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInk __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInk __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInk __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IInkVtbl;

    interface IInk
    {
        CONST_VTBL struct IInkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInk_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInk_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInk_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInk_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInk_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInk_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInk_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInk_INTERFACE_DEFINED__ */


#ifndef __ILineInfo_INTERFACE_DEFINED__
#define __ILineInfo_INTERFACE_DEFINED__

/* interface ILineInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILineInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C1C5AD5-F22F-4DE4-B453-A2CC482E7C33")
    ILineInfo : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFormat( 
            INKMETRIC __RPC_FAR *pim) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFormat( 
            INKMETRIC __RPC_FAR *pim) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInkExtent( 
            INKMETRIC __RPC_FAR *pim,
            UINT __RPC_FAR *pnWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TopCandidates( 
            UINT nCandidateNum,
            BSTR __RPC_FAR *pbstrRecogWord,
            UINT __RPC_FAR *pcchRecogWord,
            LONG fAllowRecog,
            LONG fForceRecog) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recognize( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStroke( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStroke( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPoints( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke,
            BOOL fUpStroke,
            UINT nFrameHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILineInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILineInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILineInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILineInfo __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormat )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInkExtent )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim,
            UINT __RPC_FAR *pnWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TopCandidates )( 
            ILineInfo __RPC_FAR * This,
            UINT nCandidateNum,
            BSTR __RPC_FAR *pbstrRecogWord,
            UINT __RPC_FAR *pcchRecogWord,
            LONG fAllowRecog,
            LONG fForceRecog);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Recognize )( 
            ILineInfo __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStroke )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStroke )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPoints )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke,
            BOOL fUpStroke,
            UINT nFrameHeight);
        
        END_INTERFACE
    } ILineInfoVtbl;

    interface ILineInfo
    {
        CONST_VTBL struct ILineInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILineInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILineInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILineInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILineInfo_SetFormat(This,pim)	\
    (This)->lpVtbl -> SetFormat(This,pim)

#define ILineInfo_GetFormat(This,pim)	\
    (This)->lpVtbl -> GetFormat(This,pim)

#define ILineInfo_GetInkExtent(This,pim,pnWidth)	\
    (This)->lpVtbl -> GetInkExtent(This,pim,pnWidth)

#define ILineInfo_TopCandidates(This,nCandidateNum,pbstrRecogWord,pcchRecogWord,fAllowRecog,fForceRecog)	\
    (This)->lpVtbl -> TopCandidates(This,nCandidateNum,pbstrRecogWord,pcchRecogWord,fAllowRecog,fForceRecog)

#define ILineInfo_Recognize(This)	\
    (This)->lpVtbl -> Recognize(This)

#define ILineInfo_SetStroke(This,iStroke,pStroke)	\
    (This)->lpVtbl -> SetStroke(This,iStroke,pStroke)

#define ILineInfo_GetStroke(This,iStroke,pStroke)	\
    (This)->lpVtbl -> GetStroke(This,iStroke,pStroke)

#define ILineInfo_AddPoints(This,iStroke,pStroke,fUpStroke,nFrameHeight)	\
    (This)->lpVtbl -> AddPoints(This,iStroke,pStroke,fUpStroke,nFrameHeight)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_SetFormat_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim);


void __RPC_STUB ILineInfo_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetFormat_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim);


void __RPC_STUB ILineInfo_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetInkExtent_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim,
    UINT __RPC_FAR *pnWidth);


void __RPC_STUB ILineInfo_GetInkExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_TopCandidates_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT nCandidateNum,
    BSTR __RPC_FAR *pbstrRecogWord,
    UINT __RPC_FAR *pcchRecogWord,
    LONG fAllowRecog,
    LONG fForceRecog);


void __RPC_STUB ILineInfo_TopCandidates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_Recognize_Proxy( 
    ILineInfo __RPC_FAR * This);


void __RPC_STUB ILineInfo_Recognize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_SetStroke_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke);


void __RPC_STUB ILineInfo_SetStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetStroke_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke);


void __RPC_STUB ILineInfo_GetStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_AddPoints_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke,
    BOOL fUpStroke,
    UINT nFrameHeight);


void __RPC_STUB ILineInfo_AddPoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILineInfo_INTERFACE_DEFINED__ */

#ifndef __IThorFnConversion_INTERFACE_DEFINED__
#define __IThorFnConversion_INTERFACE_DEFINED__

/* interface IThorFnConversion */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IThorFnConversion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62130000-ED22-4015-B038-A04CD0866E69")
    IThorFnConversion : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange __RPC_FAR *pRange,
            /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
            /* [out] */ BOOL __RPC_FAR *pfConvertable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Convert( 
            /* [in] */ ITfRange __RPC_FAR *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThorFnConversionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IThorFnConversion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IThorFnConversion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayName )( 
            IThorFnConversion __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryRange )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ ITfRange __RPC_FAR *pRange,
            /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
            /* [out] */ BOOL __RPC_FAR *pfConvertable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Convert )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ ITfRange __RPC_FAR *pRange);
        
        END_INTERFACE
    } IThorFnConversionVtbl;

    interface IThorFnConversion
    {
        CONST_VTBL struct IThorFnConversionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThorFnConversion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IThorFnConversion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IThorFnConversion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IThorFnConversion_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define IThorFnConversion_QueryRange(This,pRange,ppNewRange,pfConvertable)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfConvertable)

#define IThorFnConversion_Convert(This,pRange)	\
    (This)->lpVtbl -> Convert(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IThorFnConversion_QueryRange_Proxy( 
    IThorFnConversion __RPC_FAR * This,
    /* [in] */ ITfRange __RPC_FAR *pRange,
    /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
    /* [out] */ BOOL __RPC_FAR *pfConvertable);


void __RPC_STUB IThorFnConversion_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThorFnConversion_Convert_Proxy( 
    IThorFnConversion __RPC_FAR * This,
    /* [in] */ ITfRange __RPC_FAR *pRange);


void __RPC_STUB IThorFnConversion_Convert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IThorFnConversion_INTERFACE_DEFINED__ */

#ifndef __HWXINKLib_LIBRARY_DEFINED__
#define __HWXINKLib_LIBRARY_DEFINED__

/* library HWXINKLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HWXINKLib;

EXTERN_C const CLSID CLSID_Ink;

#ifdef __cplusplus

class DECLSPEC_UUID("13DE4A42-8D21-4C8E-BF9C-8F69CB068FCA")
Ink;
#endif
#endif /* __HWXINKLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\iaccess.cpp ===
/*
 *	IACCESS.CPP 
 *
 *  Purpose:
 *      Implemenation of IAccessibility for listbox and combobox
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/04/99 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-2001 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_host.h"
#include "_cbhost.h"

#ifndef NOACCESSIBILITY

extern "C" LRESULT CALLBACK RichListBoxWndProc(HWND, UINT, WPARAM, LPARAM);

#define InitPv(pv)              *pv = NULL
#define InitPlong(plong)        *plong = 0
#define InitPvar(pvar)           pvar->vt = VT_EMPTY
#define ValidateFlags(flags, valid)         (!((flags) & ~(valid)))
#define InitAccLocation(px, py, pcx, pcy)   {InitPlong(px); InitPlong(py); InitPlong(pcx); InitPlong(pcy);}

#ifdef _WIN64
#define HwndFromHWNDID(lId)         (HWND)((DWORD_PTR)(lId) & ~0x80000000)
#else
#define HwndFromHWNDID(lId)         (HWND)((lId) & ~0x80000000)
#endif // _WIN64

// this is for ClickOnTheRect
typedef struct tagMOUSEINFO
{
    int MouseThresh1;
    int MouseThresh2;
    int MouseSpeed;
}
MOUSEINFO, FAR* LPMOUSEINFO;

#define IsHWNDID(lId)               ((lId) & 0x80000000)

//////////////////////// Accessibility Utility Functions ///////////////////////////

namespace MSAA
{

// --------------------------------------------------------------------------
//
//  InitTypeInfo()
//
//  This initializes our type info when we need it for IDispatch junk.
//
// --------------------------------------------------------------------------
HRESULT InitTypeInfo(ITypeInfo** ppiTypeInfo)
{
    Assert(ppiTypeInfo);

    if (*ppiTypeInfo)
        return S_OK;

    // Try getting the typelib from the registry
    ITypeLib    *piTypeLib;    
    HRESULT hr = LoadRegTypeLib(LIBID_Accessibility, 1, 0, 0, &piTypeLib);

    if (FAILED(hr))
        hr = LoadTypeLib(OLESTR("OLEACC.DLL"), &piTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = piTypeLib->GetTypeInfoOfGuid(IID_IAccessible, ppiTypeInfo);
        piTypeLib->Release();

        if (!SUCCEEDED(hr))
            *ppiTypeInfo = NULL;
    }
    return(hr);
}


// --------------------------------------------------------------------------
//
//  ValidateChild()
//
// --------------------------------------------------------------------------
BOOL ValidateChild(VARIANT *pvar, int ctChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "ValidateChild");
    
    // Missing parameter, a la VBA
TryAgain:
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            W32->VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

        case VT_I4:
            if ((pvar->lVal < 0) || (pvar->lVal > ctChild))
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  ValidateSelFlags()
//
//  Validates selection flags.
// this makes sure the only bits set are in the valid range and that you don't
// have any invalid combinations.
// Invalid combinations are
// ADDSELECTION and REMOVESELECTION
// ADDSELECTION and TAKESELECTION
// REMOVESELECTION and TAKESELECTION
// EXTENDSELECTION and TAKESELECTION
//
// --------------------------------------------------------------------------
BOOL ValidateSelFlags(long flags)
{
    if (!ValidateFlags((flags), SELFLAG_VALID))
        return (FALSE);

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_REMOVESELECTION))
        return FALSE;

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_REMOVESELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_EXTENDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    return TRUE;
}

// --------------------------------------------------------------------------
//
//  GetStringResource(UINT id, WCHAR* psz, int nSize)
//
//  Gets the string resource for a given id and puts it in the passed buffer
//
// --------------------------------------------------------------------------
HRESULT GetStringResource(UINT id, BSTR* pbstr)
{
    
    WCHAR sz[MAX_PATH] = L"\0";

    if (!pbstr)
        return S_FALSE;

/*     
    // UNDONE:
    //  Need a workaround for this localization issue

    if (Win9x())
    {
        if (!LoadStringA(hinstResDll, id, sz, MAX_PATH))
            return(E_OUTOFMEMORY);

        // On Win9x we get ansi so convert it
        int cchUText = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)sz, -1, NULL, 0) + 1;
        *pbstr = SysAllocStringLen(NULL, cchUText);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)psz, -1, *pbstr, cchUText);
    }
    else
    {
        if (!LoadStringW(hinstResDll, id, sz, MAX_PATH))
            return(E_OUTOFMEMORY);    
        *pbstr = SysAllocString(sz);
    }
*/

#define STR_DOUBLE_CLICK            1
#define STR_DROPDOWN_HIDE           2
#define STR_DROPDOWN_SHOW           3
#define STR_ALT                     4
#define STR_COMBOBOX_LIST_SHORTCUT  5

    switch (id)
    {
        case STR_DOUBLE_CLICK:
            //"Double Click"
            wcscpy(sz, L"Double Click");
            break;
            
        case STR_DROPDOWN_HIDE:
            //"Hide"
            wcscpy(sz, L"Hide");
            break;
            
        case STR_DROPDOWN_SHOW:
            //"Show"
            wcscpy(sz, L"Show");
            break;

        case STR_ALT:
            //"Alt+"
            wcscpy(sz, L"Alt+");
            break;
            
        case STR_COMBOBOX_LIST_SHORTCUT:
            //"Alt+Down Arrow"
            wcscpy(sz, L"Alt+Down Arrow");
            break;

        default:
            AssertSz(FALSE, "id not found!!");
    }

    *pbstr = SysAllocString(sz);
    if (!*pbstr)
        return(E_OUTOFMEMORY);
        
    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  HWND GetAncestor(HWND hwnd, UINT gaFlags)
//
//  This gets the ancestor window where
//      GA_PARENT   gets the "real" parent window
//      GA_ROOT     gets the "real" top level parent window (not inc. owner)r
//
//      * The _real_ parent.  This does NOT include the owner, unlike
//          GetParent().  Stops at a top level window unless we start with
//          the desktop.  In which case, we return the desktop.
//      * The _real_ root, caused by walking up the chain getting the
//          ancestor.
//
//  NOTE:
//      User32.exe provides a undocumented function similar to this but
//  it doesn't exist in NT4.  Also, GA_ROOT works differently on Win98 so
//  I copied this over from msaa
// --------------------------------------------------------------------------
HWND GetAncestor(HWND hwnd, UINT gaFlags)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetAncestor");
    
    HWND hwndDesktop = GetDesktopWindow();
    if (hwnd == hwndDesktop || !::IsWindow(hwnd))
        return(NULL);
        
    DWORD dwStyle = GetWindowLong (hwnd, GWL_STYLE);

    HWND	hwndParent;
    switch (gaFlags)
    {
        case GA_PARENT:
            if (dwStyle & WS_CHILD)
                hwndParent = GetParent(hwnd);
            else
                hwndParent = GetWindow(hwnd, GW_OWNER);
    		hwnd = hwndParent;
            break;
            
        case GA_ROOT:
            if (dwStyle & WS_CHILD)
                hwndParent = GetParent(hwnd);
            else
                hwndParent = GetWindow(hwnd, GW_OWNER);
            while (hwndParent != hwndDesktop && hwndParent != NULL)
            {
                hwnd = hwndParent;
                dwStyle = GetWindowLong(hwnd, GWL_STYLE);
                if (dwStyle & WS_CHILD)
                    hwndParent = GetParent(hwnd);
                else
                    hwndParent = GetWindow(hwnd, GW_OWNER);
            }
            break;

        default:
            AssertSz(FALSE, "Invalid flag");
    }    
    return(hwnd);
}


// --------------------------------------------------------------------------
//
//  GetTextString(HWND hwnd, BSTR* bstr)
//
//  Parameters: hwnd of the window to get the text from
//
// --------------------------------------------------------------------------
HRESULT GetTextString(HWND hwnd, BSTR* pbstr)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetTextString");
    
    WCHAR   sz[MAX_PATH + 1];
    WCHAR   *psz = sz;

    int cchText = SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);

    // allocate memory from heap if stack buffer is insufficient
    if (cchText >= MAX_PATH)
        psz = new WCHAR[cchText + 1];

    if (!psz)
        return E_OUTOFMEMORY;

    // retrieve text
    HRESULT hres = S_OK;
    SendMessage(hwnd, WM_GETTEXT, cchText + 1, (LPARAM)psz);

    if (!*psz)
        *pbstr = NULL;
    else
    {
        *pbstr = SysAllocString(psz);
        if (!*pbstr)
            hres = E_OUTOFMEMORY;
    }
    
    // free memory if memory was allocated from heap
    if (psz != sz)
        delete [] psz;

    return hres;
}


// --------------------------------------------------------------------------
//
//  HRESULT GetLabelString(HWND hwnd, BSTR* pbstr)
//
//  This walks backwards among peer windows to find a static field.  It stops
//  if it gets to the front or hits a group/tabstop, just like the dialog 
//  manager does.
//
//  RETURN:
//   HRESULT ? S_OK on success : S_FALSE or COM error on failure
// --------------------------------------------------------------------------
HRESULT GetLabelString(HWND hwnd, BSTR* pbstr)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetLabelString");
    
    HWND hwndLabel = hwnd;
    while (hwndLabel = ::GetWindow(hwndLabel, GW_HWNDPREV))
    {
        LONG lStyle = GetWindowLong(hwndLabel, GWL_STYLE);

        // Skip if invisible
        if (!(lStyle & WS_VISIBLE))
            continue;

        // Is this a static dude?
        LRESULT lResult = SendMessage(hwndLabel, WM_GETDLGCODE, 0, 0L);
        if (lResult & DLGC_STATIC)
        {
            // Great, we've found our label.
            return GetTextString(hwndLabel, pbstr);
        }

        // Is this a tabstop or group?  If so, bail out now.
        if (lStyle & (WS_GROUP | WS_TABSTOP))
            break;
    }

    return S_FALSE;
}


// --------------------------------------------------------------------------
//
//  HRESULT StripMnemonic(BSTR bstrSrc, WCHAR** pchAmp, BOOL bStopOnAmp)
//
//  This removes the mnemonic prefix.  However, if we see '&&', we keep
//  one '&'.
//
// --------------------------------------------------------------------------
HRESULT StripMnemonic(BSTR bstrSrc, WCHAR** pchAmp, BOOL bStopOnAmp)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "StripMnemonic");

    const WCHAR amp = L'&';

    if (pchAmp)
        *pchAmp = NULL;

    WCHAR *psz = (WCHAR*)bstrSrc;
    while (*psz)
    {
        if (*psz == amp)
        {
            if (*(psz + 1) != amp)
            {
                if (pchAmp)
                    *pchAmp = psz;
                break;
            }
        }
        psz++;
    }

    // Start moving all the character up 1 position
    if (!bStopOnAmp)
        while (*psz)
		{
            *psz = *(psz+1);
			psz++;
		}

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  HRESULT GetWindowName(HWND hwnd, BSTR* pbstrName)
//
// --------------------------------------------------------------------------
HRESULT GetWindowName(HWND hwnd, BSTR* pbstrName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetWindowName");
        
    // If use a label, do that instead
    if (S_OK != GetLabelString(hwnd, pbstrName) || !*pbstrName)
        return S_FALSE;

    // Strip out the mnemonic.
    return StripMnemonic(*pbstrName, NULL, FALSE);
}


// --------------------------------------------------------------------------
//
//  HRESULT GetWindowShortcut(HWND hwnd, BSTR* pbstrShortcut)
//
// --------------------------------------------------------------------------
HRESULT GetWindowShortcut(HWND hwnd, BSTR* pbstrShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetWindowShortcut");
    
    if (S_OK != GetLabelString(hwnd, pbstrShortcut) || !*pbstrShortcut)
        return S_FALSE;

    WCHAR *pch;
    StripMnemonic(*pbstrShortcut, &pch, TRUE);

    // Is there a mnemonic?
    if (pch)
    {   
        // Get a localized "Alt+" string
        BSTR pbstrAlt = NULL;
        HRESULT hr = GetStringResource(STR_ALT, &pbstrAlt);
        if (hr != S_OK || !pbstrAlt)
            return hr;
            
        // Make a string of the form "Alt+ch".
        WCHAR   szKey[MAX_PATH];
        wcsncpy (szKey, pbstrAlt, MAX_PATH);
        WCHAR   *pchTemp = szKey + wcslen(szKey);

        // Copy shortcut character
        *pchTemp = *pch;
        *(++pchTemp) = L'\0';

        // Release allocated string allocate space for new string
        SysFreeString(pbstrAlt);
        *pbstrShortcut = SysAllocString(pchTemp);
        return (*pbstrShortcut ? S_OK : E_OUTOFMEMORY);
    }

    return(S_FALSE);
}

// --------------------------------------------------------------------------
//
//  GetWindowObject()
//
//  Gets an immediate child object.
//
// --------------------------------------------------------------------------
HRESULT GetWindowObject(HWND hwndChild, VARIANT * pvar)
{
    pvar->vt = VT_EMPTY;
    IDispatch * pdispChild = NULL;
    HRESULT hr = W32->AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch,
        (void **)&pdispChild);

    if (!SUCCEEDED(hr))
        return(hr);
    if (!pdispChild)
        return(E_FAIL);

    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdispChild;

    return(S_OK);
}

} //namespace


//////////////////////// ListBox CListBoxSelection Methods ///////////////////////////

// --------------------------------------------------------------------------
//
//  CListBoxSelection::CListBoxSelection()
//
//  We AddRef() once plistFrom so that it won't go away out from us.  When
//  we are destroyed, we will Release() it.
//
// --------------------------------------------------------------------------
CListBoxSelection::CListBoxSelection(
	int iChildCur,
	int cSelected,
	LPINT lpSelection,
	BOOL fClone)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::CListBoxSelection");
    
    _idChildCur = iChildCur;

    _cRef = 1;
	_cSel = cSelected;
	_piSel = lpSelection;

	if (fClone)
	{
		_piSel = new int[cSelected];
		if (!_piSel)
			_cSel = 0;
		else
			memcpy(_piSel, lpSelection, cSelected*sizeof(int));
	}
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::~CListBoxSelection()
//
// --------------------------------------------------------------------------
CListBoxSelection::~CListBoxSelection()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::~CListBoxSelection");

	// Free item memory
	if (_piSel)
		delete [] _piSel;
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::QueryInterface()
//
//  We only respond to IUnknown and IEnumVARIANT!  It is the responsibility
//  of the caller to loop through the items using IEnumVARIANT interfaces,
//  and get the child IDs to then pass to the parent object (or call 
//  directly if VT_DISPATCH--not in this case they aren't though).
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::QueryInterface(REFIID riid, void** ppunk)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::QueryInterface");
    
    *ppunk = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IEnumVARIANT))
    {
        *ppunk = this;
    }
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN) *ppunk)->AddRef();
    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::AddRef(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::AddRef");
    
    return(++_cRef);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::Release(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Release");
    
    if ((--_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return(_cRef);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Next()
//
//  This returns a VT_I4 which is the child ID for the parent listbox that
//  returned this object for the selection collection.  The caller turns
//  around and passes this variant to the listbox object to get acc info
//  about it.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Next(ULONG celt, VARIANT* rgvar, ULONG *pceltFetched)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Next");
    
    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    // reset temporary variable to beginning
    VARIANT *pvar = rgvar;
    long cFetched = 0;
    long iCur = _idChildCur;

    // Loop through our items
    while ((cFetched < (long)celt) && (iCur < _cSel))
    {
        VariantInit(pvar);
        pvar->vt = VT_I4;
        pvar->lVal = _piSel[iCur] + 1;

        cFetched++;
        iCur++;
        pvar++;
    }

    // Initialize the variant after the last valid one just
    // in case the client is looping based on invalid variants
    if ((ULONG)cFetched < celt)
        VariantInit(pvar);

    // Advance the current position
    _idChildCur = iCur;

    // Fill in the number fetched
    if (pceltFetched)
        *pceltFetched = cFetched;

    // Return S_FALSE if we grabbed fewer items than requested
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Skip()
//
// -------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Skip(ULONG celt)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Skip");
    
    _idChildCur += celt;
    if (_idChildCur > _cSel)
        _idChildCur = _cSel;

    // We return S_FALSE if at the end.
    return((_idChildCur >= _cSel) ? S_FALSE : S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Reset(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Reset");
    
    _idChildCur = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Clone(IEnumVARIANT **ppenum)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Clone");
    
    InitPv(ppenum);
    CListBoxSelection * plistselnew = new CListBoxSelection(_idChildCur, _cSel, _piSel, TRUE);
    if (!plistselnew)
        return(E_OUTOFMEMORY);

    HRESULT hr = plistselnew->QueryInterface(IID_IEnumVARIANT, (void**)ppenum);
	plistselnew->Release();		// Release the AddRef being done in new CListBoxSelection
	return hr;
}

//////////////////////// ListBox IAccessible Methods //////////////////////////////
/*
 *	CLstBxWinHost::InitTypeInfo()
 *
 *	@mfunc
 *		Retrieves type library
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
HRESULT CLstBxWinHost::InitTypeInfo()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InitTypeInfo");

	if (_fShutDown)
		return CO_E_RELEASED;

    return MSAA::InitTypeInfo(&_pTypeInfo);
}


/*
 *	CLstBxWinHost::get_accName(VARIANT varChild, BSTR *pbstrName)
 *
 *	@mfunc
 *		SELF ? label of control : item text 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accName(VARIANT varChild, BSTR *pbstrName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accName");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPv(pbstrName);

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        if (_fLstType == kCombo)
            return  _pcbHost->get_accName(varChild, pbstrName);
        else
            return(MSAA::GetWindowName(_hwnd, pbstrName));
    }
    else
    {
        // Get the item text.
        LRESULT lres = RichListBoxWndProc(_hwnd, LB_GETTEXTLEN, varChild.lVal-1, 0);

        // First Check for error
        if (lres == LB_ERR)
            return S_FALSE;
       
        if (lres > 0)
        {
            // allocate some buffer
            *pbstrName = SysAllocStringLen(NULL, lres + 1);
            if (!*pbstrName)
                return E_OUTOFMEMORY;
                
            RichListBoxWndProc(_hwnd, LB_GETTEXT, varChild.lVal-1, (LPARAM)*pbstrName);
        }
    }
    return(S_OK);
}


/*
 *	CLstBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
 *
 *	@mfunc
 *		Retrieves the object's Role property. 
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accRole");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarRole);

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return S_OK;
}


/*
 *	CLstBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
 *
 *	@mfunc
 *		Retrieves the current state of the object or child item.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accState");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    InitPvar(pvarState);
    if (varChild.lVal == CHILDID_SELF)
    {
        pvarState->vt = VT_I4;
        pvarState->lVal = 0;

        if (!IsWindowVisible(_hwnd))
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

        if (!IsWindowEnabled(_hwnd))
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (_fFocus)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;

        if (::GetForegroundWindow() == MSAA::GetAncestor(_hwnd, GA_ROOT))
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        return S_OK;
    }


    --varChild.lVal;

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    // Is this item selected?
    if (IsSelected(varChild.lVal))
        pvarState->lVal |= STATE_SYSTEM_SELECTED;

    // Does it have the focus?  Remember that we decremented the lVal so it
    // is zero-based like listbox indeces.
    if (_fFocus)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (varChild.lVal == GetCursor())
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;            
    }

    // Is the listbox read-only?
    long lStyle = GetWindowLong(_hwnd, GWL_STYLE);

    if (lStyle & LBS_NOSEL)
        pvarState->lVal |= STATE_SYSTEM_READONLY;
    else
    {
        pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

        // Is the listbox multiple and/or extended sel?  NOTE:  We have
        // no way to implement accSelect() EXTENDSELECTION so don't.
        if (lStyle & LBS_MULTIPLESEL)
            pvarState->lVal |= STATE_SYSTEM_MULTISELECTABLE;
    }

    // Is the item in view?
    //
	// SMD 09/16/97 Offscreen things are things never on the screen,
	// and that doesn't apply to this. Changed from OFFSCREEN to
	// INVISIBLE.
	RECT    rcItem;
    if (!RichListBoxWndProc(_hwnd, LB_GETITEMRECT, varChild.lVal, (LPARAM)&rcItem))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return S_OK;
}

/*
 *	CLstBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
 *
 *	@mfunc
 *		Retrieves an object's KeyboardShortcut property.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accKeyboardShortcut");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if ((varChild.lVal == 0) && _fLstType != kCombo)
    {
        InitPv(pszShortcut);
        return(MSAA::GetWindowShortcut(_hwnd, pszShortcut));
    }
    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::get_accFocus(VARIANT *pvarChild)
 *
 *	@mfunc
 *		Retrieves the child object that currently has the keyboard focus.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accFocus(VARIANT *pvarChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accFocus");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarChild);

    // Are we the focus?
    if (_fFocus)
    {
        pvarChild->vt = VT_I4;
        if (GetCursor() >= 0)
            pvarChild->lVal = GetCursor() + 1;
        else
            pvarChild->lVal = 0;
        return S_OK;
    }
    else
        return S_FALSE;
}


/*
 *	CLstBxWinHost::get_accSelection(VARIANT *pvarSelection)
 *
 *	@mfunc
 *		Retrieves the selected children of this object. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accSelection(VARIANT *pvarSelection)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accSelection");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarSelection);

    int cSel = RichListBoxWndProc(_hwnd, LB_GETSELCOUNT, 0, 0);
    
    if (cSel <= 1)
    {
        // cSelected is -1, 0, or 1.  
        //      -1 means this is a single sel listbox.  
        //      0 or 1 means this is multisel
        if (GetCursor() < 0)
            return S_FALSE;
            
        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = GetCursor() + 1;
        return(S_OK);
    }

    // Allocate memory for the list of item IDs
    int * plbs = new int[cSel];
    if (!plbs)
        return(E_OUTOFMEMORY);
    
    // Multiple items; must make a collection
    // Get the list of selected item IDs
    int j = 0;
    for (long i = 0; i < GetCount(); i++)
    {
		if (IsSelected(i) == TRUE)
		    plbs[j++] = i;
	}

	// Note: we don't need to free plbs since it will be kept inside plbsel.
    CListBoxSelection *plbsel = new CListBoxSelection(0, cSel, plbs, FALSE);

    // check if memory allocation failed
    if (!plbsel)
	{
		delete [] plbs;
        return(E_OUTOFMEMORY);
	}
        
    pvarSelection->vt = VT_UNKNOWN;
	HRESULT hr = plbsel->QueryInterface(IID_IUnknown, (void**)&(pvarSelection->punkVal));
	plbsel->Release();		// Release the AddRef being done in new CListBoxSelection
	return hr;
}


/*
 *	CLstBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
 *
 *	@mfunc
 *		Retrieves a string containing a localized sentence that describes the object's default action. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accDefaultAction");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPv(pszDefAction);

    // Validate.
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return (MSAA::GetStringResource(STR_DOUBLE_CLICK, pszDefAction));

    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
 *
 *	@mfunc
 *		Retrieves the object's current screen location (if the object was placed on 
 *  the screen) and optionally, the child element. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accLocation");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    // Validate params
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    RECT    rc;
    if (!varChild.lVal)
        GetClientRect(_hwnd, &rc);
    else if (!RichListBoxWndProc(_hwnd, LB_GETITEMRECT, varChild.lVal-1, (LPARAM)&rc))
        return S_OK;

    // Convert coordinates to screen coordinates
    *pcxWidth = rc.right - rc.left;
    *pcyHeight = rc.bottom - rc.top;    
    
    ClientToScreen(_hwnd, (LPPOINT)&rc);
    *pxLeft = rc.left;
    *pyTop = rc.top;

    return S_OK;
}

/*
 *	CLstBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
 *
 *	@mfunc
 *		Retrieves the child object at a given point on the screen. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accHitTest");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarHit);

    // Is the point in our client area?
    POINT   pt = {xLeft, yTop};
    ScreenToClient(_hwnd, &pt);

    RECT    rc;
    GetClientRect(_hwnd, &rc);

    if (!PtInRect(&rc, pt))
        return(S_FALSE);

    // What item is here?
    long l = GetItemFromPoint(&pt);
    pvarHit->vt = VT_I4;
    pvarHit->lVal = (l >= 0) ? l + 1 : 0;
    
    return(S_OK);
}


/*
 *	CLstBxWinHost::accDoDefaultAction(VARIANT varChild)
 *
 *	@mfunc
 *		Performs the object's default action. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accDoDefaultAction(VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accDoDefaultAction");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal)
    {        
        // this will check if WindowFromPoint at the click point is the same
	    // as m_hwnd, and if not, it won't click. Cool!
	    
        RECT	rcLoc;
	    HRESULT hr = accLocation(&rcLoc.left, &rcLoc.top, &rcLoc.right, &rcLoc.bottom, varChild);
	    if (!SUCCEEDED (hr))
		    return (hr);

        // Find Center of rect
        POINT ptClick;
    	ptClick.x = rcLoc.left + (rcLoc.right/2);
    	ptClick.y = rcLoc.top + (rcLoc.bottom/2);

    	// check if hwnd at point is same as hwnd to check
    	if (WindowFromPoint(ptClick) != _hwnd)
    		return DISP_E_MEMBERNOTFOUND;

        W32->BlockInput(TRUE);
        
        // Get current cursor pos.
        POINT ptCursor;
        DWORD dwMouseDown, dwMouseUp;
        GetCursorPos(&ptCursor);
    	if (GetSystemMetrics(SM_SWAPBUTTON))
    	{
    		dwMouseDown = MOUSEEVENTF_RIGHTDOWN;
    		dwMouseUp = MOUSEEVENTF_RIGHTUP;
    	}
    	else
    	{
    		dwMouseDown = MOUSEEVENTF_LEFTDOWN;
    		dwMouseUp = MOUSEEVENTF_LEFTUP;
    	}

        // Get delta to move to center of rectangle from current
        // cursor location.
        ptCursor.x = ptClick.x - ptCursor.x;
        ptCursor.y = ptClick.y - ptCursor.y;

        // NOTE:  For relative moves, USER actually multiplies the
        // coords by any acceleration.  But accounting for it is too
        // hard and wrap around stuff is weird.  So, temporarily turn
        // acceleration off; then turn it back on after playback.

        // Save mouse acceleration info
        MOUSEINFO	miSave, miNew;
        if (!SystemParametersInfo(SPI_GETMOUSE, 0, &miSave, 0))
        {
            W32->BlockInput(FALSE);
            return (DISP_E_MEMBERNOTFOUND);
        }

        if (miSave.MouseSpeed)
        {
            miNew.MouseThresh1 = 0;
            miNew.MouseThresh2 = 0;
            miNew.MouseSpeed = 0;

            if (!SystemParametersInfo(SPI_SETMOUSE, 0, &miNew, 0))
            {
                W32->BlockInput(FALSE);
                return (DISP_E_MEMBERNOTFOUND);
            }
        }

        // Get # of buttons
        int nButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);

        // mouse move to center of start button
        INPUT		rgInput[6];
        rgInput[0].type = INPUT_MOUSE;
        rgInput[0].mi.dwFlags = MOUSEEVENTF_MOVE;
        rgInput[0].mi.dwExtraInfo = 0;
        rgInput[0].mi.dx = ptCursor.x;
        rgInput[0].mi.dy = ptCursor.y;
        rgInput[0].mi.mouseData = nButtons;
		rgInput[0].mi.time = 0;

        int i = 1;

        // MSAA's order of double click is 
        // WM_LBUTTONDOWN
        // WM_LBUTTONUP
        // WM_LBUTTONDOWN
        // WM_LBUTTONUP
        while (i <= 4)
        {
            if (i % 2)
                rgInput[i].mi.dwFlags = dwMouseDown;
            else
                rgInput[i].mi.dwFlags = dwMouseUp;
                
            rgInput[i].type = INPUT_MOUSE;
            rgInput[i].mi.dwExtraInfo = 0;
            rgInput[i].mi.dx = 0;
            rgInput[i].mi.dy = 0;
            rgInput[i].mi.mouseData = nButtons;
			rgInput[i].mi.time = 0;
            i++;
        }
        
    	// move mouse back to starting location
        rgInput[i].type = INPUT_MOUSE;
        rgInput[i].mi.dwFlags = MOUSEEVENTF_MOVE;
        rgInput[i].mi.dwExtraInfo = 0;
        rgInput[i].mi.dx = -ptCursor.x;
        rgInput[i].mi.dy = -ptCursor.y;
        rgInput[i].mi.mouseData = nButtons;
		rgInput[i].mi.time = 0;
        i++;
        if (!W32->SendInput(i, rgInput, sizeof(INPUT)))
            MessageBeep(0);

        // Restore Mouse Acceleration
        if (miSave.MouseSpeed)
            SystemParametersInfo(SPI_SETMOUSE, 0, &miSave, 0);

        W32->BlockInput (FALSE);
	    return (S_OK);
    }
    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::accSelect(long selFlags, VARIANT varChild)
 *
 *	@mfunc
 *		Modifies the selection or moves the keyboard focus according to the specified flags.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accSelect(long selFlags, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accSelect");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()) || !MSAA::ValidateSelFlags(selFlags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(S_FALSE);

    varChild.lVal--;

    long lStyle = GetWindowLong(_hwnd, GWL_STYLE);
    if (lStyle & LBS_NOSEL)
        return DISP_E_MEMBERNOTFOUND;

    if (!IsSingleSelection())
    {
        // get the focused item here in case we change it. 
        int nFocusedItem = GetCursor();

	    if (selFlags & SELFLAG_TAKEFOCUS) 
        {
            if (!_fFocus)
                return(S_FALSE);

            RichListBoxWndProc (_hwnd, LB_SETCARETINDEX, varChild.lVal, 0);
        }

        // reset and select requested item
	    if (selFlags & SELFLAG_TAKESELECTION)
	    {
	        // deselect the whole range of items
            RichListBoxWndProc(_hwnd, LB_SETSEL, FALSE, -1);
            // Select this one
            RichListBoxWndProc(_hwnd, LB_SETSEL, TRUE, varChild.lVal);
        }

        if (selFlags & SELFLAG_EXTENDSELECTION)
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                RichListBoxWndProc (_hwnd, LB_SELITEMRANGE, (selFlags & SELFLAG_ADDSELECTION), 
                             MAKELPARAM(nFocusedItem, varChild.lVal));
            else
            {
                BOOL bSelected = RichListBoxWndProc (_hwnd, LB_GETSEL, nFocusedItem, 0);
                RichListBoxWndProc (_hwnd, LB_SELITEMRANGE, bSelected, MAKELPARAM(nFocusedItem,varChild.lVal));
            }
        }
        else // not extending, check add/remove
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                RichListBoxWndProc(_hwnd, LB_SETSEL, (selFlags & SELFLAG_ADDSELECTION), varChild.lVal);
        }
        // set focus to where it was before if SELFLAG_TAKEFOCUS not set
        if ((selFlags & SELFLAG_TAKEFOCUS) == 0)
            RichListBoxWndProc (_hwnd, LB_SETCARETINDEX, nFocusedItem, 0);
    }
    else // listbox is single select
    {
        if (selFlags & (SELFLAG_ADDSELECTION | SELFLAG_REMOVESELECTION | SELFLAG_EXTENDSELECTION))
            return (E_INVALIDARG);

        // single select listboxes do not allow you to set the
        // focus independently of the selection, so we send a 
        // LB_SETCURSEL for both TAKESELECTION and TAKEFOCUS
	    if ((selFlags & SELFLAG_TAKESELECTION) || (selFlags & SELFLAG_TAKEFOCUS))
            RichListBoxWndProc(_hwnd, LB_SETCURSEL, varChild.lVal, 0);
    } // end if listbox is single select
	
    return(S_OK);
}


/*
 *	CLstBxWinHost::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
 *
 *	@mfunc
 *		Retrieves the next or previous sibling or child object in a specified direction.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accNavigate");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarEnd);

    // Validate parameters
    if (!MSAA::ValidateChild(&varStart, GetCount()))
        return(E_INVALIDARG);

    // Is this something for the client (or combobox) to handle?
    long lEnd = 0;
    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        lEnd = GetCount() ? 1 : 0;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
        lEnd = GetCount();
    else if (varStart.lVal == CHILDID_SELF)
    {   
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        IAccessible* poleacc = NULL;
        HRESULT hr = W32->AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW, IID_IAccessible, (void**)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);

        // Ask it to navigate
        VARIANT varStart;
        VariantInit(&varStart);
        varStart.vt = VT_I4;
        varStart.lVal = OBJID_CLIENT;

        hr = poleacc->accNavigate(dwNavDir, varStart, pvarEnd);

        // Release our parent
        poleacc->Release();
        return(hr);
    }
    else
    {
        //long lT = varStart.lVal - 1;
        switch (dwNavDir)
        {
            // We're a single column list box only so ignore
            // these flags
            //case NAVDIR_RIGHT:
            //case NAVDIR_LEFT:
            //    break;

            case NAVDIR_PREVIOUS:
            case NAVDIR_UP:
                // Are we in the top-most row?
                lEnd = varStart.lVal - 1;
                break;

            case NAVDIR_NEXT:
            case NAVDIR_DOWN:
                lEnd = varStart.lVal + 1;
                if (lEnd > GetCount())
                    lEnd = 0;
                break;
        }
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
    }

    return(lEnd ? S_OK : S_FALSE);
}


/*
 *	CLstBxWinHost::get_accParent(IDispatch **ppdispParent)
 *
 *	@mfunc
 *		Retrieves the IDispatch interface of the current object's parent. 
 *  Return S_FALSE and set the variable at ppdispParent to NULL. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accParent(IDispatch **ppdispParent)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accParent");

	if (_fShutDown)
		return CO_E_RELEASED;

    AssertSz(ppdispParent != NULL, "null pointer");
    if (ppdispParent == NULL)
        return S_FALSE;
        
    InitPv(ppdispParent);
    HWND hwnd;
    if (_fLstType != kCombo)
    {
        hwnd = MSAA::GetAncestor(_hwnd, GA_PARENT);
        AssertSz(hwnd, "Invalid Hwnd");
        if (!hwnd)
            return S_FALSE;
    }
    else
    {
        if (_pcbHost)
        {
            hwnd = _pcbHost->_hwnd;
            Assert(hwnd);
        }
        else
            return S_FALSE;
        
    }

    HRESULT hr = W32->AccessibleObjectFromWindow(hwnd, (DWORD)OBJID_CLIENT, IID_IDispatch,
                                          (void **)ppdispParent);

#ifdef DEBUG
    if (FAILED(hr))
        Assert(FALSE);
#endif
    return hr;
}


/*
 *	CLstBxWinHost::get_accChildCount(long *pcCount)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accChildCount(long *pcCount)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accChildCount");

	if (_fShutDown)
		return CO_E_RELEASED;

    *pcCount = GetCount();
    return(S_OK);
}

/*
 *	CCmbBxWinHost::InitTypeInfo()
 *
 *	@mfunc
 *		Retrieves type library
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
HRESULT CCmbBxWinHost::InitTypeInfo()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::InitTypeInfo");

	if (_fShutDown)
		return CO_E_RELEASED;

    return MSAA::InitTypeInfo(&_pTypeInfo);
}

/*
 *	CCmbBxWinHost::get_accName(VARIANT varChild, BSTR *pszName)
 *
 *	@mfunc
 *		Retrieves the Name property for this object. 
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accName(VARIANT varChild, BSTR *pszName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accName");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    // The name of the combobox, the edit inside of it, and the dropdown
    // are all the same.  The name of the button is Drop down/Pop up
    InitPv(pszName);
    if (varChild.lVal != INDEX_COMBOBOX_BUTTON)
        return(MSAA::GetWindowName(_hwnd, pszName));
    else
    {
        if (IsWindowVisible(_hwndList))
            return (MSAA::GetStringResource(STR_DROPDOWN_HIDE, pszName));
        else
            return(MSAA::GetStringResource(STR_DROPDOWN_SHOW, pszName));
    }
}

/*
 *	CCmbBxWinHost::get_accValue(VARIANT varChild, BSTR *pszValue)
 *
 *	@mfunc
 *		Retrieves the object's Value property.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accValue(VARIANT varChild, BSTR *pszValue)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accValue");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
        case INDEX_COMBOBOX_ITEM:
            InitPv(pszValue);
            LRESULT lres;
            _pserv->TxSendMessage(WM_GETTEXTLENGTH, 0, 0, &lres);

            // If windows text length is 0 then MSAA searches
            // for the label associated with the control
            if (lres <= 0)
                return MSAA::GetLabelString(_hwnd, pszValue);
                
            GETTEXTEX gt;
            memset(&gt, 0, sizeof(GETTEXTEX));
            gt.cb = (lres + 1) * sizeof(WCHAR);
            gt.codepage = 1200;
            gt.flags = GT_DEFAULT;

            *pszValue = SysAllocStringLen(NULL, lres + 1);
            if (!*pszValue)
                return E_OUTOFMEMORY;
                
            _pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)*pszValue, &lres);
            return S_OK;
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
 *
 *	@mfunc
 *		Retrieves the object's Role property.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accRole");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate--this does NOT accept a child ID.
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            pvarRole->lVal = ROLE_SYSTEM_COMBOBOX;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (_cbType == kDropDown)
                pvarRole->lVal = ROLE_SYSTEM_TEXT;
            else
                pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;
            break;

        case INDEX_COMBOBOX_BUTTON:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_COMBOBOX_LIST:
            pvarRole->lVal = ROLE_SYSTEM_LIST;
            break;

        default:
            AssertSz(FALSE, "Invalid ChildID for child of combo box" );
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
 *
 *	@mfunc
 *		Retrieves the current state of the object or child item.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accState");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate--this does NOT accept a child ID.
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    VARIANT var;
    HRESULT hr;
    IAccessible* poleacc;
    InitPvar(pvarState);
    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    HWND hwndActive = GetForegroundWindow();
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX_BUTTON:
            if (_fMousedown)
                pvarState->lVal |= STATE_SYSTEM_PRESSED;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (_cbType == kDropDownList)
            {              
                if (hwndActive == MSAA::GetAncestor(_hwnd, GA_ROOT))
                    pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
                if (_fFocus)
                    pvarState->lVal |= STATE_SYSTEM_FOCUSED;
                break;
            }
            
            // FALL THROUGH CASE
            
        case INDEX_COMBOBOX:
            if (!(_dwStyle & WS_VISIBLE))
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

            if (_dwStyle & WS_DISABLED)
                pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

            if (_fFocus)
                pvarState->lVal |= STATE_SYSTEM_FOCUSED;

            if (hwndActive == MSAA::GetAncestor(_hwnd, GA_ROOT))
                pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
            break;            

        case INDEX_COMBOBOX_LIST:
            {

                // First we incorporate the state of the window in general
                //
                VariantInit(&var);
                if (FAILED(hr = MSAA::GetWindowObject(_hwndList, &var)))
                    return(hr);

                Assert(var.vt == VT_DISPATCH);

                // Get the child acc object
                poleacc = NULL;
                hr = var.pdispVal->QueryInterface(IID_IAccessible,
                    (void**)&poleacc);
                var.pdispVal->Release();

                if (FAILED(hr))
                {
                    Assert(FALSE);
                    return(hr);
                }

                // Ask the child its state
                VariantInit(&var);
                hr = poleacc->get_accState(var, pvarState);
                poleacc->Release();
                if (FAILED(hr))
                {
                    Assert(FALSE);
                    return(hr);
                }

                // The listbox is always going to be floating
                //
                pvarState->lVal |= STATE_SYSTEM_FLOATING;

                if (_plbHost->_fDisabled)
                    pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;
                else
                    pvarState->lVal &= ~STATE_SYSTEM_UNAVAILABLE;

                if (_fListVisible)
                    pvarState->lVal &= ~STATE_SYSTEM_INVISIBLE;
                else
                    pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
                    
                break;
            }
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
 *
 *	@mfunc
 *		Retrieves an object's KeyboardShortcut property.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accKeyboardShortcut");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Shortcut for combo is label's hotkey.
    // Shortcut for dropdown (if button) is Alt+F4.
    // CWO, 12/5/96, Alt+F4? F4, by itself brings down the combo box,
    //                       but we add "Alt" to the string.  Bad!  Now use 
    //                       down arrow and add Alt to it via HrMakeShortcut()
    //                       As documented in the UI style guide.
    //
    // As always, shortcuts only apply if the container has "focus".  In other
    // words, the hotkey for the combo does nothing if the parent dialog
    // isn't active.  And the hotkey for the dropdown does nothing if the
    // combobox/edit isn't focused.
  

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    InitPv(pszShortcut);
    if (varChild.lVal == INDEX_COMBOBOX)
    {
        return(MSAA::GetWindowShortcut(_hwnd, pszShortcut));
    }
    else if (varChild.lVal == INDEX_COMBOBOX_BUTTON)
    {
        return(MSAA::GetStringResource(STR_COMBOBOX_LIST_SHORTCUT, pszShortcut));
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accFocus(VARIANT *pvarFocus)
 *
 *	@mfunc
 *		Retrieves the child object that currently has the keyboard focus.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accFocus(VARIANT *pvarFocus)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accFocus");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarFocus);
    // Is the current focus a child of us?
    if (_fFocus)
    {
        pvarFocus->vt = VT_I4;
        pvarFocus->lVal = 0;
    }
    else 
    {
        // NOTE:
        //  We differ here in we don't get the foreground thread's focus window.  Instead,
        //  we just get the current threads focus window
        HWND hwnd = GetFocus();
        if (IsChild(_hwnd, hwnd))            
            return(MSAA::GetWindowObject(hwnd, pvarFocus));
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
 *
 *	@mfunc
 *		Retrieves a string containing a localized sentence that describes the object's
 *  default action.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accDefaultAction");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    if ((varChild.lVal != INDEX_COMBOBOX_BUTTON)/* || _fHasButton*/)
        return DISP_E_MEMBERNOTFOUND;

    // Default action of button is to press it.  If pressed already, pressing
    // it will pop dropdown back up.  If not pressed, pressing it will pop
    // dropdown down.
    InitPv(pszDefaultAction);

    if (IsWindowVisible(_hwndList))
        return(MSAA::GetStringResource(STR_DROPDOWN_HIDE, pszDefaultAction));
    else
        return(MSAA::GetStringResource(STR_DROPDOWN_SHOW, pszDefaultAction));
}


/*
 *	CCmbBxWinHost::accSelect(long flagsSel, VARIANT varChild)
 *	@mfunc
 *		Modifies the selection or moves the keyboard focus according to the specified 
 *  flags.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accSelect(long flagsSel, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accSelect");

	if (_fShutDown)
		return CO_E_RELEASED;

    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX) || !MSAA::ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
 *	@mfunc
 *		Retrieves the object's current screen location (if the object was placed on 
 *   the screen) and optionally, the child element.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accLocation");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    RECT rc;
    HWND hwnd = _hwnd;
    switch (varChild.lVal)
    {        
        case INDEX_COMBOBOX_BUTTON:
            //if (!m_fHasButton)
            //    return(S_FALSE);
            rc = _rcButton;
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;
            ClientToScreen(_hwnd, (LPPOINT)&rc);
            break;

        case INDEX_COMBOBOX_ITEM:
            //  Need to verify this is the currently selected item.
            //  if no item is selected then pass the rect of the first item in the list
            _plbHost->LbGetItemRect((_plbHost->GetCursor() < 0) ? 0 : _plbHost->GetCursor(), &rc);
            
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;   
            ClientToScreen(_hwndList, (LPPOINT)&rc);
            break;

        case INDEX_COMBOBOX_LIST:
            hwnd = _hwndList;
            // fall through!!!
            
        case 0: //default window
            GetWindowRect(hwnd, &rc);
            // copy over dimensions            
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;
            break;

        default:
            AssertSz(FALSE, "Invalid ChildID for child of combo box" );
            return (S_OK);
    }
    
    *pxLeft = rc.left;
    *pyTop = rc.top;
    return(S_OK);
}


/*
 *	CCmbBxWinHost::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
 *
 *	@mfunc
 *		Retrieves the next or previous sibling or child object in a specified 
 *  direction.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accNavigate");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarEnd);

    // Validate parameters
    if (!MSAA::ValidateChild(&varStart, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    long lEnd = 0;
    if (dwNav == NAVDIR_FIRSTCHILD)
    {
        lEnd =  INDEX_COMBOBOX_ITEM;
        goto GetTheChild;
    }
    else if (dwNav == NAVDIR_LASTCHILD)
    {
        dwNav = NAVDIR_PREVIOUS;
        varStart.lVal = CCHILDREN_COMBOBOX + 1;
    }
    else if (!varStart.lVal)
    {
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        IAccessible* poleacc = NULL;
        HRESULT hr = W32->AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW, IID_IAccessible, (void**)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);

        // Ask it to navigate
        VARIANT varStart;
        VariantInit(&varStart);
        varStart.vt = VT_I4;
        varStart.lVal = OBJID_CLIENT;

        hr = poleacc->accNavigate(dwNav, varStart, pvarEnd);

        // Release our parent
        poleacc->Release();
        return(hr);
    }

    // Map HWNDID to normal ID.  We work with both (it is easier).
    if (IsHWNDID(varStart.lVal))
    {
        HWND hWndTemp = HwndFromHWNDID(varStart.lVal);

        if (hWndTemp == _hwnd)
            varStart.lVal = INDEX_COMBOBOX_ITEM;
        else if (hWndTemp == _hwndList)
            varStart.lVal = INDEX_COMBOBOX_LIST;
        else
            // Don't know what the heck this is
            return(S_FALSE);
    }

    switch (dwNav)
    {
        case NAVDIR_UP:
            if (varStart.lVal == INDEX_COMBOBOX_LIST)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_DOWN:
            if ((varStart.lVal != INDEX_COMBOBOX_LIST) && _fListVisible)
                lEnd = INDEX_COMBOBOX_LIST;
            break;

        case NAVDIR_LEFT:
            if (varStart.lVal == INDEX_COMBOBOX_BUTTON)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_RIGHT:
            if ((varStart.lVal == INDEX_COMBOBOX_ITEM)/* && !(cbi.stateButton & STATE_SYSTEM_INVISIBLE)*/)
               lEnd = INDEX_COMBOBOX_BUTTON;
            break;

        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            if ((lEnd == INDEX_COMBOBOX_LIST) && !_fListVisible)
                --lEnd;
            break;

        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > CCHILDREN_COMBOBOX || ((lEnd == INDEX_COMBOBOX_LIST) && !_fListVisible))
                lEnd = 0;
            break;
    }

GetTheChild:
    if (lEnd)
    {
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        if ((lEnd == INDEX_COMBOBOX_ITEM)/* && cbi.hwndItem*/)
            return(MSAA::GetWindowObject(_hwnd, pvarEnd));
        else if ((lEnd == INDEX_COMBOBOX_LIST)/* && cbi.hwndList*/)
            return(MSAA::GetWindowObject(_hwndList, pvarEnd));

        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }

    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarEnd)
 *
 *	@mfunc
 *		Retrieves the child object at a given point on the screen.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accHitTest");
    
    POINT   pt;
    RECT    rc;

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarEnd);

    pt.x = xLeft;
    pt.y = yTop;

    // Check list first, in case it is a dropdown.
    GetWindowRect(_hwndList, &rc);
    if (_fListVisible && PtInRect(&rc, pt))
        return(MSAA::GetWindowObject(_hwndList, pvarEnd));
    else
    {
        ScreenToClient(_hwnd, &pt);
        GetClientRect(_hwnd, &rc);        

        if (PtInRect(&_rcButton, pt))
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = INDEX_COMBOBOX_BUTTON;
        }
        else
        {
            if (!PtInRect(&rc, pt))
                return(S_FALSE);
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = 0;
        }
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::accDoDefaultAction(VARIANT varChild)
 *
 *	@mfunc
 *		Performs the object's default action.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accDoDefaultAction(VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accDoDefaultAction");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    if ((varChild.lVal == INDEX_COMBOBOX_BUTTON)/* && m_fHasButton*/)
    {
        if (_fListVisible)
            PostMessage(_hwnd, WM_KEYDOWN, VK_RETURN, 0);
        else
            PostMessage(_hwnd, CB_SHOWDROPDOWN, TRUE, 0);

        return(S_OK);
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accSelection(VARIANT *pvarChildren)
 *
 *	@mfunc
 *		Retrieves the selected children of this object.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accSelection(VARIANT *pvarChildren)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accSelection");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarChildren);
    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::get_accParent(IDispatch **ppdispParent)
 *
 *	@mfunc
 *		Retrieves the IDispatch interface of the current object's parent. 
 *  Return S_FALSE and set the variable at ppdispParent to NULL. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accParent(IDispatch **ppdispParent)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accParent");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPv(ppdispParent);

    if (_hwnd)
    {
        HWND hwnd = MSAA::GetAncestor(_hwnd, GA_PARENT);
        if (hwnd)
            return W32->AccessibleObjectFromWindow(hwnd, OBJID_WINDOW,
                    IID_IDispatch, (void **)ppdispParent);
    }
    
    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::get_accChildCount(long *pcountChildren)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accChildCount(long *pcountChildren)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accChildCount");

	if (_fShutDown)
		return CO_E_RELEASED;

    if (pcountChildren)
        *pcountChildren = CCHILDREN_COMBOBOX;
    return S_OK;
}


/*
 *	CCmbBxWinHost::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accChild");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    InitPv(ppdispChild);
    HWND hwndChild = NULL;
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            return E_INVALIDARG;

        //case INDEX_COMBOBOX_ITEM:
        //   hwndChild = _hwnd;
        //   break;

        case INDEX_COMBOBOX_LIST:
            hwndChild = _hwndList;
            break;
    }

    if (!hwndChild)
        return(S_FALSE);
    else
        return(W32->AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch, (void**)ppdispChild));
}


//////////////////////// CTxtWinHost IDispatch Methods ///////////////////////////
// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetTypeInfoCount()
//
//  This hands off to our typelib for IAccessible().  Note that
//  we only implement one type of object for now.  BOGUS!  What about IText?
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetTypeInfoCount(UINT * pctInfo)
{
    HRESULT hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        InitPv(pctInfo);
        *pctInfo = 1;
    }
    return(hr);
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetTypeInfo()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetTypeInfo(UINT itInfo, LCID lcid,
    ITypeInfo ** ppITypeInfo)
{
    HRESULT hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        if (ppITypeInfo == NULL)
            return(E_POINTER);

        InitPv(ppITypeInfo);

        if (itInfo != 0)
            return(TYPE_E_ELEMENTNOTFOUND);
        _pTypeInfo->AddRef();
        *ppITypeInfo = _pTypeInfo;
    }
    return(hr);
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetIDsOfNames()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetIDsOfNames(REFIID riid,
    OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgDispID)
{
    HRESULT hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID));
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::Invoke()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::Invoke(DISPID dispID, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS * pDispParams,
    VARIANT* pvarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
    HRESULT hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(_pTypeInfo->Invoke((IAccessible *)this, dispID, wFlags,
        pDispParams, pvarResult, pExcepInfo, puArgErr));
}



#endif // NOACCESSIBILITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\makefile.inc ===
$(O)\w32sys.obj : w32sys.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\w32sys.cpp
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\ime.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module ime.cpp -- support for Win95 IME API |
 *	
 *		Most everything to do with FE composition string editing passes
 *		through here.
 *	
 *	Authors: <nl>
 *		Jon Matousek <nl>
 *		Hon Wah Chan <nl>
 *		Justin Voskuhl <nl>
 * 
 *	History: <nl>
 *		10/18/1995		jonmat	Cleaned up level 2 code and converted it into
 *								a class hierarchy supporting level 3.
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */				
#include "_common.h"
#ifndef NOFEPROCESSING
#include "msctf.h"
#include "textserv.h"
#include "_cmsgflt.h"				 
#include "_ime.h"
#include "imeapp.h"

#define HAVE_COMPOSITION_STRING() ( 0 != (lparam & (GCS_COMPSTR | GCS_COMPATTR)))
#define CLEANUP_COMPOSITION_STRING() ( 0 == lparam )
#define HAVE_RESULT_STRING() ( 0 != (lparam & GCS_RESULTSTR))

ASSERTDATA


/*
 *	HRESULT StartCompositionGlue (CTextMsgFilter &TextMsgFilter)
 *	
 *	@func
 *		Initiates an IME composition string edit.
 *	@comm
 *		Called from the message loop to handle WM_IME_STARTCOMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *
 *	@devnote
 *		We decide if we are going to do a level 2 or level 3 IME
 *		composition string edit. Currently, the only reason to 
 *		create a level 2 IME is if the IME has a special UI, or it is
 *		a "near caret" IME, such as the ones found in PRC and Taiwan.
 *		Near caret simply means that a very small window opens up
 *		near the caret, but not on or at the caret.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT StartCompositionGlue (
	CTextMsgFilter &TextMsgFilter)				// @parm containing message filter.

{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "StartCompositionGlue");

	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->IsTerminated()
		&& !TextMsgFilter._ime->_compMessageRefCount && !(TextMsgFilter._fHangulToHanja))
	{
		delete TextMsgFilter._ime;
		TextMsgFilter._ime = NULL;
	}

	if(!TextMsgFilter.IsIMEComposition())
	{
		if(TextMsgFilter._pTextSel->CanEdit(NULL) == NOERROR &&
			!TextMsgFilter.NoIMEProcess())
		{
			// Hold notification if needed
			if (!(TextMsgFilter._fIMEAlwaysNotify))
				TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);	
	
			// If a special UI, or IME is "near caret", then drop into lev. 2 mode.
			DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
			
			// use Unicode if not running under Win95
			TextMsgFilter._fUnicodeIME =
				(imeProperties & IME_PROP_UNICODE) && !W32->OnWin95();

			if ((imeProperties & IME_PROP_SPECIAL_UI) ||
				!(imeProperties & IME_PROP_AT_CARET))
			{
				TextMsgFilter._ime = new CIme_Lev2(TextMsgFilter);		// level 2 IME.
			}
			else
				TextMsgFilter._ime = new CIme_Lev3(TextMsgFilter);		// level 3 IME->TrueInline.
		}
		else													// Protect or read-only or NOFEPROCESSING:
			TextMsgFilter._ime = new CIme_Protected;			// Ignore all ime input
	}
	else
	{
		// Ignore further StartCompositionMsg.
		// Hanin 5.1 CHT symbol could cause multiple StartCompoisitonMsg.
		return S_OK;								
	}

	if(TextMsgFilter.IsIMEComposition())					
	{
		long		lSelFlags;
		HRESULT		hResult;
		
		hResult = TextMsgFilter._pTextSel->GetFlags(&lSelFlags);
		if (hResult == NOERROR)
		{
			TextMsgFilter._fOvertypeMode = !!(lSelFlags & tomSelOvertype);		
			if (TextMsgFilter._fOvertypeMode)
				TextMsgFilter._pTextSel->SetFlags(lSelFlags & ~tomSelOvertype);	// Turn off overtype mode
		}
		
		TextMsgFilter._pTextDoc->IMEInProgress(tomTrue);				// Inform client IME compostion in progress

		return TextMsgFilter._ime->StartComposition(TextMsgFilter);		// Make the method call.
	}
	else
		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

	
	return S_FALSE;
}

/*
 *	HRESULT CompositionStringGlue (const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *	
 *	@func
 *		Handle all intermediary and final composition strings.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_COMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *		We may be called independently of a WM_IME_STARTCOMPOSITION
 *		message, in which case we return S_FALSE to allow the
 *		DefWindowProc to return WM_IME_CHAR messages.
 *
 *	@devnote
 *		Side Effect: the _ime object may be deleted if composition
 *		string processing is finished.
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CompositionStringGlue (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CompositionStringGlue");

	HRESULT hr = S_FALSE;

	if(TextMsgFilter.IsIMEComposition())						// A priori fHaveIMMProcs.
	{
		TextMsgFilter._ime->_compMessageRefCount++;			// For proper deletion.
													// Make the method call.
		hr = TextMsgFilter._ime->CompositionString(lparam, TextMsgFilter);

		TextMsgFilter._ime->_compMessageRefCount--;			// For proper deletion.
		Assert (TextMsgFilter._ime->_compMessageRefCount >= 0);

		CheckDestroyIME (TextMsgFilter);						// Finished processing?
	}
	else // Even when not in composition mode, we may receive a result string.
	{
	
		DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
		long		lSelFlags;
		HRESULT		hResult;
		long		cpMin, cpMax;

		hResult = TextMsgFilter._pTextSel->GetFlags(&lSelFlags);
		if (hResult == NOERROR)
		{
			TextMsgFilter._fOvertypeMode = !!(lSelFlags & tomSelOvertype);		
			if (TextMsgFilter._fOvertypeMode)
				TextMsgFilter._pTextSel->SetFlags(lSelFlags & ~tomSelOvertype);	// Turn off overtype mode
		}

		// Use Unicode if not running under Win95
		TextMsgFilter._fUnicodeIME =
			(imeProperties & IME_PROP_UNICODE) && !W32->OnWin95();
		
		TextMsgFilter._pTextSel->GetStart(&cpMin);
		TextMsgFilter._pTextSel->GetEnd(&cpMax);
		
		if (cpMin != cpMax)			
			TextMsgFilter._pTextSel->SetText(NULL);							// Delete current selection

		CIme::CheckKeyboardFontMatching (cpMin, &TextMsgFilter, NULL);

		TextMsgFilter._pTextDoc->IMEInProgress(tomTrue);					// Inform client IME compostion in progress
		hr = CIme::CheckInsertResultString(lparam, TextMsgFilter);

		if(TextMsgFilter._fOvertypeMode)
			TextMsgFilter._pTextSel->SetFlags(lSelFlags | tomSelOvertype);	// Turn on overtype mode

		TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);					// Inform client IME compostion is done
	}

	return hr;
}

/*
 *	HRESULT EndCompositionGlue (CTextMsgFilter &TextMsgFilter, BOOL fForceDelete)
 *
 *	@func
 *		Composition string processing is about to end.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_ENDCOMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *
 *	@devnote
 *		The only time we have to handle WM_IME_ENDCOMPOSITION is when the
 *		user changes input method during typing.  For such case, we will get
 *		a WM_IME_ENDCOMPOSITION message without getting a WM_IME_COMPOSITION
 *		message with GCS_RESULTSTR later.  So, we will call CompositionStringGlue
 *		with GCS_RESULTSTR to let CompositionString to get rid of the string. 
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT EndCompositionGlue (
	CTextMsgFilter &TextMsgFilter,				// @parm the containing message filter.
	BOOL fForceDelete)							// @parm forec to terminate
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "EndCompositionGlue");

	if(TextMsgFilter.IsIMEComposition())
	{
		// ignore the EndComposition message if necessary.  We may 
		// get this from 3rd party IME - EGBRIGDE after we have received
		// both result and composition strings.  
		if ( !(TextMsgFilter._ime->_fIgnoreEndComposition) )
		{
			// Set this flag. If we are still in composition mode, then
			// let the CompositionStringGlue() to destroy the ime object.
			TextMsgFilter._ime->_fDestroy = TRUE;

			if (!fForceDelete)				
				CompositionStringGlue(GCS_COMPSTR , TextMsgFilter);	// Remove any remaining composition string.

			// Finished with IME, destroy it.
			CheckDestroyIME(TextMsgFilter);

			// Turn on undo
			TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

			// Inform client IME compostion is done
			TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);				
		}
		else
		{
			// reset this so we will handle next EndComp msg
			TextMsgFilter._ime->_fIgnoreEndComposition = FALSE;
		}

		if(!TextMsgFilter.IsIMEComposition() && TextMsgFilter._fOvertypeMode)
		{
			long		lSelFlags;
			HRESULT		hResult;
			ITextSelection	*pLocalTextSel = TextMsgFilter._pTextSel;
			BOOL		fRelease = FALSE;

			if (!pLocalTextSel)
			{
				// Get the selection
				TextMsgFilter._pTextDoc->GetSelectionEx(&pLocalTextSel);
				fRelease = TRUE;
			}

			if (pLocalTextSel)
			{
				hResult = pLocalTextSel->GetFlags(&lSelFlags);
				if (hResult == NOERROR)
					pLocalTextSel->SetFlags(lSelFlags | tomSelOvertype);	// Turn on overtype mode

				if (fRelease)
					pLocalTextSel->Release();
			}
		}
	}
	return S_FALSE;
}

/*
 *	HIMC LocalGetImmContext ( CTextMsgFilter &TextMsgFilter )
 *
 *	@func
 *		Get Imm Context from host 
 *
 */
HIMC LocalGetImmContext(
	CTextMsgFilter &TextMsgFilter)
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "LocalGetImmContext");
	
	HIMC		hIMC = NULL;							// Host's IME context.
	HRESULT		hResult;

	hResult = TextMsgFilter._pTextDoc->GetImmContext((long *)&hIMC);

	if (hResult != NOERROR)
		hIMC = ImmGetContext(TextMsgFilter._hwnd, TextMsgFilter._fUsingAIMM);		// Get host's IME context.

	return hIMC;	
}

/*
 *	void LocalReleaseImmContext ( CTextMsgFilter &TextMsgFilter, HIMC hIMC )
 *
 *	@func
 *		call host to Release Imm Context
 *
 */
void LocalReleaseImmContext(
	CTextMsgFilter &TextMsgFilter, 
	HIMC hIMC )
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "LocalReleaseImmContext");

	HRESULT		hResult;

	hResult = TextMsgFilter._pTextDoc->ReleaseImmContext((long)hIMC);

	if (hResult != NOERROR)
		ImmReleaseContext(TextMsgFilter._hwnd, hIMC, TextMsgFilter._fUsingAIMM);
}

/*
 *	long IMEShareToTomUL ( UINT ulID )
 *
 *	@func
 *		Convert IMEShare underline to Tom underline.
 *
 *	@rdesc
 *		Tom underline value
 */
long IMEShareToTomUL ( 
	UINT ulID )
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEShareToTomUL");

	long lTomUnderline;

	switch (ulID)
	{
		case IMESTY_UL_NONE:
			lTomUnderline = tomNone;
			break;

		case IMESTY_UL_DOTTED:
			lTomUnderline = tomDotted;
			break;

		case IMESTY_UL_THICK:
		case IMESTY_UL_THICKLOWER:
			lTomUnderline = tomThick;
			break;

		case IMESTY_UL_DITHLOWER:
		case IMESTY_UL_THICKDITHLOWER:
			lTomUnderline = tomWave;
			break;

		// case IMESTY_UL_SINGLE:
		// case IMESTY_UL_LOWER:
		default:
			lTomUnderline = tomSingle;
			break;
	}

	return lTomUnderline;
}

/*
 *	void IMEMessage (CTextMsgFilter &TextMsgFilter , UINT uMsg, BOOL bPostMessage)
 *
 *	@func
 *		Either post or send message to IME 
 *
 */
BOOL IMEMessage(
	CTextMsgFilter &TextMsgFilter,
	UINT uMsg,
	WPARAM	wParam,
	LPARAM	lParam,
	BOOL bPostMessage)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMessage");
	
	HIMC	hIMC;									// Host's IME context.
	HWND	hwndIME;
	BOOL	fRetCode = FALSE;
	HWND	hHostWnd = TextMsgFilter._hwnd;
	long	hWnd;

	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;
		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.

	if(hIMC)
	{
		hwndIME = ImmGetDefaultIMEWnd(hHostWnd, TextMsgFilter._fUsingAIMM);
		LocalReleaseImmContext(TextMsgFilter, hIMC);

		// check if we want to send or post message
		if (hwndIME)
		{
			if (bPostMessage)
				fRetCode = PostMessage(hwndIME, uMsg, wParam, lParam);
			else
				fRetCode = SendMessage(hwndIME, uMsg, wParam, lParam);
		}
	}

	return fRetCode;
}


/*
 *	void CheckDestroyIME (CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		Check for IME and see detroy if it needs it..
 *
 */
void CheckDestroyIME (
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CheckDestroyIME");
	
	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->_fDestroy)
	{
		if(0 == TextMsgFilter._ime->_compMessageRefCount)
		{
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)	
			{
				TextMsgFilter._pTextDoc->SetCaretType(tomNormalCaret);		// Reset Block caret mode	
				TextMsgFilter._fHangulToHanja = FALSE;					// Reset korean conversion mode
			}

		 	delete TextMsgFilter._ime;									// All done with object.
			TextMsgFilter._ime = NULL;

			TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);		// Turn on Notification
		}
	}
}

/*
 *	void PostIMECharGlue (CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		Called after processing a single WM_IME_CHAR in order to
 *		update the position of the IME's composition window. This
 *		is glue code to call the CIME virtual equivalent.
 */
void PostIMECharGlue (
	CTextMsgFilter &TextMsgFilter)				// @parm containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "PostIMECharGlue");

	if(TextMsgFilter.IsIMEComposition())
		TextMsgFilter._ime->PostIMEChar(TextMsgFilter);
}

/*
 *	BOOL	IMEMouseCheck(CTextMsgFilter &TextMsgFilter, UINT *pmsg, 
 *				WPARAM *pwparam, LPARAM *plparam, LRESULT *plres)
 *
 *	@func
 *		Called when receiving a mouse event.  Need to pass this event
 *		to MSIME98 for composition handling
 *
 */
HRESULT IMEMouseCheck(
	CTextMsgFilter &TextMsgFilter,	// @parm MsgFilter
	UINT *pmsg,						// @parm the message 
	WPARAM *pwparam,				// @parm WParam
	LPARAM *plparam,				// @parm LParam
	LRESULT *plres)					// @parm Lresult			
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMouseCheck");

	BOOL fRetCode = FALSE;
	if(TextMsgFilter.IsIMEComposition())
	{
		BOOL	fTerminateIME;
		fRetCode = TextMsgFilter._ime->IMEMouseOperation(TextMsgFilter, *pmsg, *pwparam, fTerminateIME);

		if ( fTerminateIME && WM_MOUSEMOVE != *pmsg )
			TextMsgFilter._ime->TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_NORMAL);
	}

	return fRetCode ? S_OK : S_FALSE;
}

/*
 *	HRESULT IMENotifyGlue (const WPARAM wparam, const LPARAM lparam,
 *				CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		IME is going to change some state.
 *
 *	@comm
 *		Currently we are interested in knowing when the candidate
 *		window is about to be opened.
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT IMENotifyGlue (
	const WPARAM wparam,		// @parm associated with message.
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMENotifyGlue");

	if (TextMsgFilter._fRE10Mode &&
		(wparam == IMN_SETCONVERSIONMODE ||
		wparam == IMN_SETSENTENCEMODE ||
		wparam == IMN_SETOPENSTATUS))
	{
		TextMsgFilter._pTextDoc->Notify(EN_IMECHANGE);			
	}
	else if(TextMsgFilter.IsIMEComposition())						// A priori fHaveIMMProcs.
		return TextMsgFilter._ime->IMENotify(wparam, lparam, TextMsgFilter, FALSE);// Make the method call
	
	return S_FALSE;
}

/*
 *	void IMECompositionFull (&TextMsgFilter)
 *
 *	@func
 *		Current IME Composition window is full.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_COMPOSITIONFULL.
 *		This message applied to Level 2 only.  We will use the default 
 *		IME Composition window.
 */
void IMECompositionFull (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMECompositionFull");

	if(TextMsgFilter.IsIMEComposition())
	{
		HIMC 				hIMC	= LocalGetImmContext(TextMsgFilter);
		COMPOSITIONFORM		cf;

		if(hIMC)
		{																									 
			// No room for text input in the current level 2 IME window, 
			// fall back to use the default IME window for input.
			cf.dwStyle = CFS_DEFAULT;
			ImmSetCompositionWindow(hIMC, &cf, TextMsgFilter._fUsingAIMM);	// Set composition window.
			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
 	}
}

/*
 *	LRESULT OnGetIMECompositionMode (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Returns whether or not IME composition is being handled by RE,
 *		and if so, what level of processing.
 *		
 *	@rdesc
 *		One of ICM_NOTOPEN, ICM_LEVEL2_5, ICM_LEVEL2_SUI, ICM_LEVEL2, ICM_LEVEL3.
 */
LRESULT OnGetIMECompositionMode (
	CTextMsgFilter &TextMsgFilter)	  	// @parm containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "OnGetIMECompositionMode");

	if(TextMsgFilter.IsIMEComposition())
		return TextMsgFilter._ime->GetIMECompositionMode(TextMsgFilter);

	return ICM_NOTOPEN;
}

/*
 *	LRESULT TestPoint (&pt1, &pt2, &ptTest, lTestOption, lTextFlow)
 *
 *	@mfunc
 *		Returns which side the ptTest is relative to the line (pt1, pt2) based on the lTextFlow.
 *
 *	@rdesc
 *		Sides detected
 */
LONG TestPoint( 
	POINT &pt1, 
	POINT &pt2, 
	POINT &ptTest, 
	LONG lTestOption, 
	LONG lTextFlow)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "TestPoint");

	LONG lSidesDetect = 0;

	switch (lTextFlow)
	{
		case tomTextFlowES:

			if (lTestOption & TEST_LEFT)
				lSidesDetect |= (ptTest.x < pt1.x) ? TEST_LEFT : 0;

			if (lTestOption & TEST_RIGHT)
				lSidesDetect |= (ptTest.x > pt1.x) ? TEST_RIGHT : 0;

			if (lTestOption & TEST_TOP)
				lSidesDetect |= (ptTest.y < pt1.y) ? TEST_TOP : 0;

			if (lTestOption & TEST_BOTTOM)
				lSidesDetect |= (ptTest.y > pt2.y) ? TEST_BOTTOM : 0;

			break;

		case tomTextFlowSW:

			if (lTestOption & TEST_LEFT)
				lSidesDetect |= (ptTest.y < pt1.y) ? TEST_LEFT : 0;

			if (lTestOption & TEST_RIGHT)
				lSidesDetect |= (ptTest.y > pt1.y) ? TEST_RIGHT : 0;

			if (lTestOption & TEST_TOP)
				lSidesDetect |= (ptTest.x > pt1.x) ? TEST_TOP : 0;

			if (lTestOption & TEST_BOTTOM)
				lSidesDetect |= (ptTest.x < pt2.x) ? TEST_BOTTOM : 0;

			break;

		case tomTextFlowWN:

			if (lTestOption & TEST_LEFT)
				lSidesDetect |= (ptTest.x > pt1.x) ? TEST_LEFT : 0;

			if (lTestOption & TEST_RIGHT)
				lSidesDetect |= (ptTest.x < pt1.x) ? TEST_RIGHT : 0;

			if (lTestOption & TEST_TOP)
				lSidesDetect |= (ptTest.y > pt1.y) ? TEST_TOP : 0;

			if (lTestOption & TEST_BOTTOM)
				lSidesDetect |= (ptTest.y < pt2.y) ? TEST_BOTTOM : 0;

			break;

		case tomTextFlowNE:

			if (lTestOption & TEST_LEFT)
				lSidesDetect |= (ptTest.y > pt1.y) ? TEST_LEFT : 0;

			if (lTestOption & TEST_RIGHT)
				lSidesDetect |= (ptTest.y < pt1.y) ? TEST_RIGHT : 0;

			if (lTestOption & TEST_TOP)
				lSidesDetect |= (ptTest.x < pt1.x) ? TEST_TOP : 0;

			if (lTestOption & TEST_BOTTOM)
				lSidesDetect |= (ptTest.x > pt2.x) ? TEST_BOTTOM : 0;

			break;
	}
	return lSidesDetect;
}

/*
 *	void CIme::CheckKeyboardFontMatching (long cp, CTextMsgFilter &TextMsgFilter, ITextFont	*pTextFont)
 *	
 *	@mfunc
 *		Setup current font to matches the keyboard Codepage.
 *
 *	@comm
 *		Called from CIme_Lev2::CIme_Lev2 and CompositionStringGlue
 *
 *	@devnote
 *		We need to switch to a preferred font for the keyboard during IME input.
 *		Otherwise, we will display garbage.
 *		
 */
void CIme::CheckKeyboardFontMatching (
	long cp,
	CTextMsgFilter *pTextMsgFilter, 
	ITextFont	*pTextFont)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::CheckKeyboardFontMatching");

	long	lPitchAndFamily;
	HRESULT	hResult;
	BSTR	bstr = NULL;
	long	lValue;
	long	lNewFontSize=0;
	float	nFontSize;
	ITextFont *pLocalFont = NULL;

	if (!pTextMsgFilter)
		return;

	if (!pTextFont)
	{	
		// No font supplied, get current font from selection
		hResult = pTextMsgFilter->_pTextSel->GetFont(&pLocalFont);			
		
		if (hResult != S_OK || !pLocalFont)		// Can't get font, forget it
			return;			

		pTextFont = pLocalFont;
	}

	// Check if current font matches the keyboard
	lValue = tomCharset;
	hResult = pTextFont->GetLanguageID(&lValue);
	BYTE bCharSet = (BYTE)lValue;
	BYTE bCharSetKB = GetCharSet(pTextMsgFilter->_uKeyBoardCodePage);

	if (hResult == S_OK && bCharSet == bCharSetKB)
		goto Exit;								// Current font is fine

	hResult = pTextFont->GetSize(&nFontSize);

	if (hResult != S_OK)
		goto Exit;

	hResult = pTextMsgFilter->_pTextDoc->GetPreferredFont(cp, 
		pTextMsgFilter->_uKeyBoardCodePage, tomMatchFontCharset, 
		CodePageFromCharRep(CharRepFromCharSet(bCharSet)), (long)nFontSize,
		&bstr, &lPitchAndFamily, &lNewFontSize);

	if (hResult == S_OK)
	{	
		pTextFont->Reset(tomApplyLater);		

		if (bstr)
			pTextFont->SetName(bstr);

		// Set the font charset and Pitch&Family by overloading the SetLanguageID i/f			
		lValue = tomCharset + ((BYTE)lPitchAndFamily << 8) + bCharSetKB;
		pTextFont->SetLanguageID(lValue);				
		
		if (lNewFontSize)
			pTextFont->SetSize((float)lNewFontSize);

		pTextFont->Reset(tomApplyNow);
	}

Exit:
	if (pLocalFont)
			pLocalFont->Release();
	
	if (bstr)
		SysFreeString(bstr);
}

/*
 *	INT CIme::GetCompositionStringInfo(HIMC hIMC, DWORD dwIndex,
 *			  WCHAR *szCompStr, INT cchMax, BYTE *attrib, INT cbAttrib
 *			  LONG cchAttrib, UINT kbCodePage, BOOL bUnicodeIME)
 *
 *	@mfunc
 *		For WM_IME_COMPOSITION string processing to get the requested
 *		composition string, by type, and convert it to Unicode.
 *
 *	@devnote
 *		We must use ImmGetCompositionStringA because W is not supported
 *		on Win95.
 *		
 *	@rdesc
 *		INT-cch of the Unicode composition string.
 *		Out param in szCompStr.
 */
INT CIme::GetCompositionStringInfo(
	HIMC hIMC,			// @parm IME context provided by host.
	DWORD dwIndex,		// @parm The type of composition string.
	WCHAR *szCompStr,	// @parm Out param, unicode result string.
	INT cchMax,			// @parm The cch for the Out param.
	BYTE *attrib,		// @parm Out param, If attribute info is needed.
	INT cbMax,			// @parm The cb of the attribute info.
	LONG *cpCursor,		// @parm Out param, returns the CP of cusor.
	LONG *cchAttrib,	// @parm how many attributes returned.
	UINT kbCodePage,	// @parm codepage
	BOOL bUnicodeIME,	// @parm Unciode IME
	BOOL bUsingAimm)	// @parm Using Aimm
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::GetCompositionStringInfo");

	BYTE	compStr[256], attribInfo[256];
	INT		i, j, iMax, cchCompStr=0, cbAttrib, cursor;
	INT		cchAnsiCompStr=0;

	Assert(hIMC && szCompStr);

	if(cpCursor)									// Init cursor out param.
		*cpCursor = -1;
	if(cchAttrib)
		*cchAttrib = 0;
													// Get composition string.
	if (bUnicodeIME)
		cchCompStr = ImmGetCompositionStringW(hIMC, dwIndex, szCompStr, cchMax, bUsingAimm )/sizeof(WCHAR);
	else
		cchAnsiCompStr = ImmGetCompositionStringA(hIMC, dwIndex, compStr, 255, bUsingAimm);

	if(cchAnsiCompStr > 0 || cchCompStr > 0)		// If valid data.
	{
		if (!bUnicodeIME)
		{
			Assert(cchAnsiCompStr >> 1 < cchMax - 1);		// Convert to Unicode.
			cchCompStr = UnicodeFromMbcs(szCompStr, cchMax,
					(CHAR *) compStr, cchAnsiCompStr, kbCodePage);
		}

		if(attrib || cpCursor)						// Need cursor or attribs?
		{
			if (bUnicodeIME)
			{										// Get Unicode Cursor cp.
				cursor = ImmGetCompositionStringW(hIMC, GCS_CURSORPOS, NULL, 0, bUsingAimm);
													// Get Unicode attributes.
				cbAttrib = ImmGetCompositionStringW(hIMC, GCS_COMPATTR,
								attribInfo, 255, bUsingAimm);

				iMax = max(cursor, cbAttrib);
				iMax = min(iMax, cchCompStr);
			}
			else
			{										// Get DBCS Cursor cp.
				cursor = ImmGetCompositionStringA(hIMC, GCS_CURSORPOS, NULL, 0, bUsingAimm);
													// Get DBCS attributes.
				cbAttrib = ImmGetCompositionStringA(hIMC, GCS_COMPATTR,
								attribInfo, 255, bUsingAimm);

				iMax = max(cursor, cbAttrib);
				iMax = min(iMax, cchAnsiCompStr);
			}

			if(NULL == attrib)
				cbMax = cbAttrib;

			for(i = 0, j = 0; i <= iMax && j < cbMax; i++, j++)
			{
				if(cursor == i)
					cursor = j;

				if(!bUnicodeIME && GetTrailBytesCount(compStr[i], kbCodePage))
					i++;

				if(attrib && i < cbAttrib)
					*attrib++ = attribInfo[i];
			}
													// attrib cch==unicode cch
			Assert(0 >= cbAttrib || j-1 == cchCompStr);

			if(cursor >= 0 && cpCursor)				// If client needs cursor
				*cpCursor = cursor;					//  or cchAttrib.
			if(cbAttrib >= 0 && cchAttrib)
				*cchAttrib = j-1;
		}
	}
	else
	{
		if(cpCursor)
			*cpCursor = 0;
		cchCompStr = 0;
	}
	return cchCompStr;
}

/*
 *	void CIme::SetCompositionFont (CTextMsgFilter &TextMsgFilter, ITextFont *pTextFont)
 *
 *	@mfunc
 *		Important for level 2 IME so that the composition window
 *		has the correct font. The lfw to lfa copy is due to the fact that
 *		Win95 does not support the W)ide call.
 *		It is also important for both level 2 and level 3 IME so that
 *		the candidate list window has the proper. font.
 */
void CIme::SetCompositionFont (
	CTextMsgFilter &TextMsgFilter,		// @parm the containing message filter.
	ITextFont *pTextFont) 		 		// @parm ITextFont for setting lfa.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::SetCompositionFont");
	
	HIMC 		hIMC;
	LOGFONTA	lfa;

	if (pTextFont)
	{
		hIMC = LocalGetImmContext(TextMsgFilter);
		if (hIMC)
		{
			// Build the LOGFONT based on pTextFont
			float	FontSize;
			long	lValue;
			BSTR	bstr;
			long	lTextFlow;

			memset (&lfa, 0, sizeof(lfa));

			if (pTextFont->GetSize(&FontSize) == NOERROR)			
				lfa.lfHeight = (LONG) FontSize;			
			
			if (pTextFont->GetBold(&lValue) == NOERROR && lValue == tomTrue)
				lfa.lfWeight = FW_BOLD;

			if (pTextFont->GetItalic(&lValue) == NOERROR && lValue == tomTrue)
				lfa.lfItalic = TRUE;

			lfa.lfCharSet = (BYTE)GetCharSet(TextMsgFilter._uKeyBoardCodePage);

			lValue = tomCharset;
			if (pTextFont->GetLanguageID(&lValue) == NOERROR && 
				lfa.lfCharSet == (BYTE)lValue)
				lfa.lfPitchAndFamily = (BYTE)(lValue >> 8);

			if (pTextFont->GetName(&bstr) == NOERROR)
			{
				if ((TextMsgFilter._lFEFlags & tomUseAtFont) && bstr[0] != L'@')
				{
					lfa.lfFaceName[0] = '@';
					MbcsFromUnicode(&(lfa.lfFaceName[1]), sizeof(lfa.lfFaceName)-1, bstr,
						-1, CP_ACP, UN_NOOBJECTS);
				}
				else				
					MbcsFromUnicode(lfa.lfFaceName, sizeof(lfa.lfFaceName), bstr,
						-1, CP_ACP, UN_NOOBJECTS);	

				SysFreeString(bstr);
			}

			lTextFlow = TextMsgFilter._lFEFlags & tomTextFlowMask;
			if (lTextFlow)
			{
				DWORD imeUIProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_UI, TextMsgFilter._fUsingAIMM);

				if (imeUIProperties & (UI_CAP_2700 | UI_CAP_ROT90 | UI_CAP_ROTANY))
				{
					if (lTextFlow == tomTextFlowSW)
						lfa.lfOrientation = lfa.lfEscapement = 2700;
					else if (lTextFlow == tomTextFlowNE)
						lfa.lfOrientation = lfa.lfEscapement = 900;
				}
			}

			ImmSetCompositionFontA( hIMC, &lfa, TextMsgFilter._fUsingAIMM );

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.		
		}
	}
}

/*
 *	void CIme::SetCompositionForm (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Important for level 2 IME so that the composition window
 *		is positioned correctly. 
 *
 *	@comm
 *		We go through a lot of work to get the correct height. This requires
 *		getting information from the font cache and the selection.
 */
void CIme::SetCompositionForm (
	CTextMsgFilter &TextMsgFilter)	   	// @parm the containing text edit.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::SetCompositionForm");

	HIMC 				hIMC;
	COMPOSITIONFORM		cf;

	if(IME_LEVEL_2 == GetIMELevel())
	{
		hIMC = LocalGetImmContext(TextMsgFilter);					// Get IME context.
		
		if(hIMC)
		{				
			// get the location of cpMin
			cf.ptCurrentPos.x = cf.ptCurrentPos.y = 0;
			TextMsgFilter._pTextSel->GetPoint( tomStart+tomClientCoord+TA_BOTTOM+TA_LEFT,
				&(cf.ptCurrentPos.x), &(cf.ptCurrentPos.y) );			
			
			// Set-up bounding rect. for the IME (lev 2) composition window, causing
			// composition text to be wrapped within it.
			cf.dwStyle = CFS_RECT;
			TextMsgFilter._pTextDoc->GetClientRect(tomIncludeInset+tomClientCoord,
				&(cf.rcArea.left), &(cf.rcArea.top),
				&(cf.rcArea.right), &(cf.rcArea.bottom));		 

			// Make sure the starting point is not
			// outside the rcArea.  This happens when
			// there is no text on the current line and the user 
			// has selected a large font size.
			if(cf.ptCurrentPos.y < cf.rcArea.top)
				cf.ptCurrentPos.y = cf.rcArea.top;
			else if(cf.ptCurrentPos.y > cf.rcArea.bottom)
				cf.ptCurrentPos.y = cf.rcArea.bottom; 

			if(cf.ptCurrentPos.x < cf.rcArea.left)
				cf.ptCurrentPos.x = cf.rcArea.left;
			else if(cf.ptCurrentPos.x > cf.rcArea.right)
				cf.ptCurrentPos.x = cf.rcArea.right;

			ImmSetCompositionWindow(hIMC, &cf, TextMsgFilter._fUsingAIMM);	// Set composition window.

			LocalReleaseImmContext(TextMsgFilter, hIMC);				// Done with IME context.
		}
	}
}



/*
 *
 *	CIme::TerminateIMEComposition (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	Terminate the IME Composition mode using CPS_COMPLETE
 *	@comm	The IME will generate WM_IME_COMPOSITION with the result string
 * 
 */
void CIme::TerminateIMEComposition(
	CTextMsgFilter &TextMsgFilter, 			// @parm the containing message filter.
	TerminateMode mode)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::TerminateIMEComposition");
	DWORD dwTerminateMethod;

	HIMC hIMC = LocalGetImmContext(TextMsgFilter);

	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->IsTerminated())
	{
		// Turn if off now
		EndCompositionGlue(TextMsgFilter, TRUE);
		return;
	}

	_fIMETerminated = TRUE;

	if (mode == TERMINATE_FORCECANCEL)
		TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);		// Inform client IME compostion is done

	dwTerminateMethod = CPS_COMPLETE;
	if (IME_LEVEL_2 == GetIMELevel()  ||	// force cancel for near-caret IME
		mode == TERMINATE_FORCECANCEL ||	// caller wants force cancel
		TextMsgFilter._fIMECancelComplete)				// Client wants force cancel
	{
		dwTerminateMethod = CPS_CANCEL;
	}
	
	// force the IME to terminate the current session
	if(hIMC)
	{
		BOOL fRetCode;

		fRetCode = ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, 
			dwTerminateMethod, 0, TextMsgFilter._fUsingAIMM);
		
		if(!fRetCode && !TextMsgFilter._fIMECancelComplete)
		{
			// CPS_COMPLETE fail, try CPS_CANCEL.  This happen with some ime which do not support
			// CPS_COMPLETE option (e.g. ABC IME version 4 with Win95 simplified Chinese)
			fRetCode = ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, 0, TextMsgFilter._fUsingAIMM);

		}

		LocalReleaseImmContext(TextMsgFilter, hIMC);
	}
	else
	{
		// for some reason, we didn't have a context, yet we thought we were still in IME
		// compostition mode.  Just force a shutdown here.
		EndCompositionGlue(TextMsgFilter, TRUE);
	}
}


/*
 *	CIme_Lev2::CIme_Lev2()
 *
 *	@mfunc
 *		CIme_Lev2 Constructor/Destructor.
 *
 *	@comm
 *		Needed to make sure _iFormatSave was handled properly.
 *
 */
CIme_Lev2::CIme_Lev2(	
	CTextMsgFilter &TextMsgFilter)		// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::CIme_Lev2");

	long		cpMin, cpMax, cpLoc;
	HRESULT		hResult;
	ITextFont	*pCurrentFont = NULL;

	_pTextFont = NULL;
	_cIgnoreIMECharMsg = 0;

	// setup base Font format for later use during composition
	hResult	= TextMsgFilter._pTextSel->GetStart(&cpMin);
	cpLoc = cpMin;	

	if (TextMsgFilter._fHangulToHanja)
		cpMax = cpMin + 1;				// Select the Hangul character
	else
		hResult	= TextMsgFilter._pTextSel->GetEnd(&cpMax);

	_fSkipFirstOvertype = FALSE;
	if (cpMax != cpMin)
	{
		// selection case, get format for at cpMin
		ITextRange *pTextRange;
		HRESULT		hResult;
				
		hResult = TextMsgFilter._pTextDoc->Range(cpMin, cpMin+1, &pTextRange);
		Assert (pTextRange != NULL);
		
		if (hResult == NOERROR && pTextRange)
		{
			pTextRange->GetFont(&pCurrentFont);
			Assert(pCurrentFont != NULL);		
			pTextRange->Release();
			cpLoc = cpMin+1;
		}	

		if (!TextMsgFilter._fHangulToHanja)
			_fSkipFirstOvertype = TRUE;			// For Korean Overtype support
	}
	
	if (!pCurrentFont)
		TextMsgFilter._pTextSel->GetFont(&pCurrentFont);

	Assert(pCurrentFont != NULL);

	pCurrentFont->GetDuplicate(&_pTextFont);		// duplicate the base format for later use
	pCurrentFont->Release();
	Assert(_pTextFont != NULL);
		
	// setup font to match current keyboard
	CIme::CheckKeyboardFontMatching (cpLoc, &TextMsgFilter, _pTextFont);

	_fIgnoreEndComposition = FALSE;
	
	_fIMETerminated = FALSE;
}

CIme_Lev2::~CIme_Lev2()
{
	if ( _pTextFont )
		_pTextFont->Release();
}

/*
 *	HRESULT CIme_Lev2::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin IME Level 2 composition string processing.		
 *
 *	@comm
 *		Set the font, and location of the composition window which includes
 *		a bounding rect and the start position of the cursor. Also, reset
 *		the candidate window to allow the IME to set its position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev2::StartComposition(
	CTextMsgFilter &TextMsgFilter)		// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::StartComposition");

	_imeLevel = IME_LEVEL_2;

	SetCompositionFont(TextMsgFilter, _pTextFont);	// Set font, & comp window.
	SetCompositionForm(TextMsgFilter);

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *	HRESULT CIme_Lev2::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 2 WM_IME_COMPOSITION messages.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing.  
 *		
 *		Side effect: 
 *			The Host needs to mask out the lparam before calling DefWindowProc to
 *			prevent unnessary WM_IME_CHAR messages.
 */
HRESULT CIme_Lev2::CompositionString (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::CompositionString");

	_cIgnoreIMECharMsg = 0;
	if(HAVE_RESULT_STRING())
	{
		_fGotFinalString = TRUE;

		if (_pTextFont)
		{
			// setup the font before insert final string
			ITextFont *pFETextFont=NULL;

			_pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			TextMsgFilter._pTextSel->SetFont(pFETextFont);
			pFETextFont->Release();
		}

		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

		CheckInsertResultString(lparam, TextMsgFilter, &_cIgnoreIMECharMsg);
		SetCompositionForm(TextMsgFilter);			// Move Composition window.
		
	}

	// Always return S_FALSE so the DefWindowProc will handle the rest.
	// Host has to mask out the ResultString bit to avoid WM_IME_CHAR coming in.
	return S_FALSE;																	
}

/*
 *	HRESULT CIme::CheckInsertResultString (const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		handle inserting of GCS_RESULTSTR text, the final composed text.
 *
 *	@comm
 *		When the final composition string arrives we grab it and set it into the text.
 *
 *	@devnote
 *		A GCS_RESULTSTR message can arrive and the IME will *still* be in
 *		composition string mode. This occurs because the IME's internal
 *		buffers overflowed and it needs to convert the beginning of the buffer
 *		to clear out some room.	When this happens we need to insert the
 *		converted text as normal, but remain in composition processing mode.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme::CheckInsertResultString (
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	short	*pcch,					// @parm number of character read
	int		*pcbOutBuff,			// @parm byte size of the output buffer
	WCHAR	*pOutBuff)				// @parm buffer to receive the text
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::CheckInsertResultString");

	HRESULT			hr = S_FALSE;
	HIMC 			hIMC;
	INT				cch;
	WCHAR			szCompStr[256];

	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING())	// If result string..
	{
		hIMC = LocalGetImmContext(TextMsgFilter);				// Get host's IME context.

		cch = 0;
		if(hIMC)												// Get result string.
		{
			cch = GetCompositionStringInfo(hIMC, pOutBuff ? GCS_RESULTREADSTR : GCS_RESULTSTR, 
							szCompStr,
							sizeof(szCompStr)/sizeof(szCompStr[0]),
							NULL, 0, NULL, NULL, TextMsgFilter._uKeyBoardCodePage, 
							TextMsgFilter._fUnicodeIME, TextMsgFilter._fUsingAIMM);

			if (pcch)
				*pcch = (short)cch;

			cch = min (cch, 255);
			szCompStr[cch] = L'\0';
			LocalReleaseImmContext(TextMsgFilter, hIMC);		// Done with IME context.
		}

		// Don't need to replace range when there isn't any text. Otherwise, the character format is
		// reset to previous run.
		if(cch)
		{
			if (pOutBuff)
			{
				if (*pcbOutBuff > (int) ((cch + 1) * sizeof(WCHAR)))
					*pcbOutBuff = (cch + 1) * sizeof(WCHAR);

				memcpy(pOutBuff, szCompStr, *pcbOutBuff);
			}
			else
			{
				BSTR bstr = SysAllocString(szCompStr);
				if (!bstr)
					return E_OUTOFMEMORY;

				TextMsgFilter._pTextSel->TypeText(bstr);
				SysFreeString(bstr);
			}
		}
		else if (pOutBuff)
			*pcbOutBuff = 0;

		hr = S_OK;												// Don't want WM_IME_CHARs.
		
	}

	return hr;
}

/*
 *	HRESULT CIme_Lev2::IMENotify(const WPARAM wparam, const LPARAM lparam,
 *					CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 2 WM_IME_NOTIFY messages.
 *
 *	@comm
 *		Currently we are only interested in knowing when to reset
 *		the candidate window's position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev2::IMENotify(
	const WPARAM wparam,			// @parm associated with message.
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	BOOL fIgnore)					// @parm Level3 Chinese Composition window only
{
 	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::IMENotify");

	if(IMN_OPENCANDIDATE == wparam)
	{
		Assert (0 != lparam);

		HIMC			hIMC;							// Host's IME context.

		INT				index;							// Candidate window index.
		CANDIDATEFORM	cdCandForm;

		hIMC = LocalGetImmContext(TextMsgFilter);				// Get host's IME context.

		if(hIMC)
		{
													// Convert bitID to INDEX.
			for (index = 0; index < 32; index++)	//  because *stupid* API.
			{
				if((1 << index) & lparam)
					break;
			}
			Assert (((1 << index) & lparam) == lparam);	// Only 1 set?
			Assert (index < 32);						
													// Reset to CFS_DEFAULT
			if(ImmGetCandidateWindow(hIMC, index, &cdCandForm, TextMsgFilter._fUsingAIMM)
					&& CFS_DEFAULT != cdCandForm.dwStyle)
			{
				cdCandForm.dwStyle = CFS_DEFAULT;
				ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
	}	

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *	void CIme_Lev2::PostIMEChar (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Called after processing a single WM_IME_CHAR in order to
 *		update the position of the IME's composition window.		
 *
 */
void CIme_Lev2::PostIMEChar (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
 	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::PostIMEChar");

	SetCompositionForm(TextMsgFilter);						// Move Composition window.
}

/*
 *
 *	CIme_Lev2::IMEMouseOperation (CTextMsgFilter &TextMsgFilter, UINT msg, BOOL	&fTerminateIME)
 *
 *	@mfunc	Level 2 IME does not handle the mouse events, we need to check if
 *		we should terminate IME.
 *
 *	@rdesc
 *		BOOL-FALSE since Level 2 IME does not handle the mouse events
 *		fTermineateIME-TRUE if we want to terminateIME
 *
 */
BOOL CIme_Lev2::IMEMouseOperation(
	CTextMsgFilter	&TextMsgFilter, 		// @parm the containing message filter.
	UINT			msg,					// @parm message id
	WPARAM			wParam,					// @parm wparam
	BOOL			&fTerminateIME)			// @parm need to terminate IME					
	
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::IMEMouseOperation");

	// Level 2 IME, check if we need to terminate IME
	fTerminateIME = FALSE;
	switch(msg)
	{
		case WM_LBUTTONDOWN:
 		case WM_LBUTTONDBLCLK:
 		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
 		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
			fTerminateIME = TRUE;
	}
	return FALSE;
}

/*
 *
 *	CIme_Lev2::GetIMECompositionMode (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	Return the current IME composition mode when we haven't received any final string
 *
 *	@rdesc
 *			IME Level
 * 
 */
LRESULT  CIme_Lev2::GetIMECompositionMode(
	CTextMsgFilter &TextMsgFilter)			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::GetIMECompositionMode");

	LRESULT lres = ICM_NOTOPEN;

	if (!_fGotFinalString)
	{
		DWORD imeProperties;

		imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
		if(imeProperties & IME_PROP_AT_CARET)
			lres = ICM_LEVEL2_5;				// level 2.5.
		else if	(imeProperties & IME_PROP_SPECIAL_UI)
			lres = ICM_LEVEL2_SUI;				// special UI.
		else
			lres = ICM_LEVEL2;					// stock level 2.
	}

	return lres;
}

/*
 *	CIme_Lev3::CIme_Lev3()
 *
 *	@mfunc
 *		CIme_Lev3 Constructor/Destructor.
 *
 */
CIme_Lev3::CIme_Lev3(	
	CTextMsgFilter &TextMsgFilter) : CIme_Lev2 ( TextMsgFilter )
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::CIme_Lev3");

	_sIMESuportMouse = 0;		// initial to 0 so we will check mouse operation if need
	_wParamBefore = 0;
	_fUpdateWindow = FALSE;
}

/*
 *	HRESULT CIme_Lev3::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin IME Level 3 composition string processing.		
 *
 *	@comm
 *		For rudimentary processing, remember the start and
 *		length of the selection. Set the font in case the
 *		candidate window actually uses this information.
 *
 *	@rdesc
 *		This is a rudimentary solution for remembering were
 *		the composition is in the text. There needs to be work
 *		to replace this with a composition "range".
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::StartComposition(
	CTextMsgFilter &TextMsgFilter)			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::StartComposition");
	long	cpMin;
	TextMsgFilter._pTextSel->GetStart(&cpMin);

	_ichStart = cpMin;
	_cchCompStr		= 0;
	_imeLevel		= IME_LEVEL_3;

	SetCompositionFont (TextMsgFilter, _pTextFont);	

	// Delete current selection
	TextMsgFilter._pTextSel->SetText(NULL);
	
	// turn off undo
	TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

	if (_pTextFont)
	{
		_pTextFont->GetForeColor(&_crTextColor);
		_pTextFont->GetBackColor(&_crBkColor);
	}

	// Setup IMEShare Lid if necessary
	if (!TextMsgFilter._fRE10Mode && 
		TextMsgFilter._uKeyBoardCodePage != CP_KOREAN &&
		W32->HaveIMEShare())
	{
		CIMEShare *pIMEShare;
		if (W32->getIMEShareObject(&pIMEShare))
		{
			LID hKL = (LID)GetKeyboardLayout(0x0FFFFFFFF);
			if (pIMEShare->LidGetLid() != hKL)
				pIMEShare->LidSetLid(hKL);
		}
	}

	return S_OK;									// No DefWindowProc
}													//  processing.

/*
 *	HRESULT CIme_Lev3::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 3 WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		Display all of the intermediary composition text as well as the final
 *		reading.
 *
 *	@devnote
 *		This is a rudimentary solution for replacing text in the backing store.
 *		Work is left to do with the undo list, underlining, and hiliting with
 *		colors and the selection.	
 *		
 *	@devnote
 *		A GCS_RESULTSTR message can arrive and the IME will *still* be in
 *		composition string mode. This occurs because the IME's internal
 *		buffers overflowed and it needs to convert the beginning of the buffer
 *		to clear out some room.	When this happens we need to insert the
 *		converted text as normal, but remain in composition processing mode.
 *
 *		Another reason, GCS_RESULTSTR can occur while in composition mode
 *		for Korean because there is only 1 correct choice and no additional 
 *		user intervention is necessary, meaning that the converted string can
 *		be sent as the result before composition mode is finished.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::CompositionString(
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::CompositionString");
	
	long	cpMin;
	
	_fIgnoreEndComposition = FALSE;

	if (_fUpdateWindow)
	{
		TextMsgFilter._pTextDoc->UpdateWindow();
		_fUpdateWindow = FALSE;
	}

 	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING())	// Any final readings?
	{
		long	lCount;

		if (!_fHandlingFinalString)
		{
			_fHandlingFinalString = TRUE;

			if (HAVE_RESULT_STRING())
				_fGotFinalString = TRUE;

			if (!CLEANUP_COMPOSITION_STRING())
				TextMsgFilter._pTextDoc->Freeze(&lCount);				// Turn off display


			if (_cchCompStr)
			{
				ITextRange *pTextRange = NULL;

				// Create a range to delete composition text
				TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart + _cchCompStr, &pTextRange);
				Assert (pTextRange != NULL);

				// delete composition text
				pTextRange->SetText(NULL);
				pTextRange->Release();
				_cchCompStr	= 0;							//  be in composition mode.
			};

			// setup the font before insert final string
			ITextFont *pFETextFont;

			_pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			TextMsgFilter._pTextSel->SetFont(pFETextFont);
			pFETextFont->Release();

			// turn on undo
			TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

			// Turn on Notification again
			TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

			// get final string
			CheckInsertResultString(lparam, TextMsgFilter);

			if (!CLEANUP_COMPOSITION_STRING())
				TextMsgFilter._pTextDoc->Unfreeze(&lCount);				// Turn on display

			// Reset as we may still in Composition
			TextMsgFilter._pTextSel->GetStart(&cpMin);
			_ichStart = cpMin;

			// turn off undo for Korean IME since we will get Composition string message
			// again without getting EndComposition
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
				TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

			_fHandlingFinalString = FALSE;
		}
	}

	if(HAVE_COMPOSITION_STRING())						// In composition mode?
	{
		HIMC	hIMC;
		INT		cchOld = _cchCompStr;
		LONG	cpCursor = 0, cchAttrib = 0;
		LONG	i, j;				// For applying attrib effects.
		WCHAR	szCompStr[256];
		BYTE	startAttrib, attrib[256];
		BSTR	bstr = NULL;
		ITextRange *pTextRange = NULL;
		long	cpMax;
		long	lCount;

		_cchCompStr = 0;

		if (!_fDestroy)
		{
			hIMC = LocalGetImmContext(TextMsgFilter);			// Get host's IME context.

			if(hIMC)								// Get composition string.
			{
				_cchCompStr = GetCompositionStringInfo(hIMC, GCS_COMPSTR, 
						szCompStr, sizeof(szCompStr)/sizeof(szCompStr[0]),
						attrib, sizeof(attrib)/sizeof(attrib[0]), 
						&cpCursor, &cchAttrib, TextMsgFilter._uKeyBoardCodePage, TextMsgFilter._fUnicodeIME, TextMsgFilter._fUsingAIMM);
				_cchCompStr = min (_cchCompStr, 255);
				szCompStr[_cchCompStr] = L'\0';

				LocalReleaseImmContext(TextMsgFilter, hIMC);		// Done with IME context.
			}
		}

		// any new composition string?
		if(_cchCompStr)
		{
			long	cchExced = 0;
			if (TextMsgFilter._pTextDoc->CheckTextLimit(_cchCompStr-cchOld, &cchExced) == NOERROR &&
				cchExced > 0)
			{
				// We reach text limit, beep...
				TextMsgFilter._pTextDoc->SysBeep();

				if (_cchCompStr > cchExced)
					_cchCompStr -= cchExced;
				else
					_cchCompStr = 0;

				szCompStr[_cchCompStr] = L'\0';

				if (!_cchCompStr && TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)				
					TextMsgFilter._pTextDoc->SetCaretType(tomNormalCaret);		// Turn off Block caret mode
			}

			bstr = SysAllocString(szCompStr);

			if (!bstr)
				return E_OUTOFMEMORY;

			if (HAVE_RESULT_STRING())
			{
				// ignore next end composition
				_fIgnoreEndComposition = TRUE;

				// turn off undo
				TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

				// Get the new format that may have changed by apps (e.g. Outlook)
				_pTextFont->Release();

				ITextFont	*pCurrentFont = NULL;
				TextMsgFilter._pTextSel->GetFont(&pCurrentFont);

				Assert(pCurrentFont != NULL);

				pCurrentFont->GetDuplicate(&_pTextFont);		// duplicate the base format for later use
				pCurrentFont->Release();
				Assert(_pTextFont != NULL);
				CIme::CheckKeyboardFontMatching (_ichStart, &TextMsgFilter, _pTextFont);
			}			
		}

		if (cchOld || _cchCompStr)
		{
			bool	fFreezeDisplay = false;

			// Hold notification if needed
			if (!(TextMsgFilter._fIMEAlwaysNotify) && !HAVE_RESULT_STRING())
				TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);

			// We only support overtype mode in Korean IME
			if (!cchOld && TextMsgFilter._uKeyBoardCodePage == CP_KOREAN && 
				TextMsgFilter._fOvertypeMode && !_fSkipFirstOvertype)
			{				
				long		cCurrentChar;	
				HRESULT		hResult;

				// Create a range using the next character
				hResult	= TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+1, &pTextRange);
				Assert (pTextRange != NULL);

				// Check if it is par character. If so, we don't want to 
				// delete it.
				hResult	= pTextRange->GetChar(&cCurrentChar);
				if (hResult == NOERROR)
				{
					if (cCurrentChar != (long)'\r' && cCurrentChar != (long)'\n')
					{			
						TextMsgFilter._pTextDoc->Undo(tomResume, NULL);		// Turn on undo
						pTextRange->SetText(NULL);							// Delete the character
						TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);	// Turn off undo
					}
					else
					{
						// Unselect the par character
						hResult	= pTextRange->SetRange(_ichStart, _ichStart);
					}
				}
			}	
			else
			{
				// Create a range using the preivous composition text and delete the text
				TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+cchOld, &pTextRange);
				Assert (pTextRange != NULL);
				if (cchOld)
				{
					if (cpCursor >= 0)
					{
						TextMsgFilter._pTextDoc->Freeze(&lCount);	// Turn off display
						fFreezeDisplay = true;
					}
					pTextRange->SetText(NULL);
				}
			}
			
			_fSkipFirstOvertype = FALSE;
			
			if (cpCursor >= 0 && !fFreezeDisplay)
				TextMsgFilter._pTextDoc->Freeze(&lCount);			// Turn off display
			
			// Make sure the composition string is formatted with the base font
			ITextFont *pFETextFont;
			HRESULT		hResult;

			hResult = _pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			if (!(hResult != NOERROR || pFETextFont == NULL))
			{
				if (TextMsgFilter._fHangulToHanja && !_cchCompStr)
					// Hangul to Hanja mode, setup font for selection to 
					// handle the Hanja character the come in after the end composition
					// message
					TextMsgFilter._pTextSel->SetFont(pFETextFont);
				else
					pTextRange->SetFont(pFETextFont);				
			}

			pTextRange->SetText(bstr);								// Replace with the new text			
			if (pFETextFont)
				pFETextFont->Release();

			// update how many composition characters have been added
			pTextRange->GetEnd(&cpMax); 
			_cchCompStr = cpMax - _ichStart;
			
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
			{
				// no formatting for Korean
				POINT		ptBottomPos;

				if (cpCursor == 0)
					TextMsgFilter._pTextDoc->Unfreeze(&lCount);			// Turn on display
			
				if (pTextRange->GetPoint( tomEnd+TA_BOTTOM+TA_RIGHT,
					&(ptBottomPos.x), &(ptBottomPos.y) ) != NOERROR)
					pTextRange->ScrollIntoView(tomEnd);
				
				// Setup Block caret mode only when there is One char and the caret pos is 0.
				TextMsgFilter._pTextDoc->SetCaretType((_cchCompStr == 1 && !cpCursor) ? tomKoreanBlockCaret : tomNormalCaret);
				
			}
			else if (_cchCompStr && _cchCompStr <= cchAttrib)
			{				
				for ( i = 0; i < _cchCompStr; )			// Parse the attributes...
				{										//  to apply styles.					
					ITextFont *pFETextFont;
					HRESULT		hResult;

					hResult = _pTextFont->GetDuplicate(&pFETextFont);
					Assert(pFETextFont != NULL);

					if (hResult != NOERROR || pFETextFont == NULL)
						break;
					
					// Rsest the clone font so we will only apply effects returned
					// from SetCompositionStyle
					pFETextFont->Reset(tomUndefined);

					startAttrib = attrib[i];			// Get attrib's run length.
					for ( j = i+1; j < _cchCompStr; j++ )
					{
						if ( startAttrib != attrib[j] )	// Same run until diff.
							break; 
					}

					SetCompositionStyle(TextMsgFilter, startAttrib, pFETextFont);

					// Apply FE clause's style
					pTextRange->SetRange(_ichStart+i, _ichStart+j);
					pTextRange->SetFont(pFETextFont);
					pFETextFont->Release();

					i = j;
				}
			}

			pTextRange->Release();
		}
		else if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
			TextMsgFilter._pTextDoc->Update(tomTrue);		// Force an Update

		// setup caret pos
		if ( !(TextMsgFilter._uKeyBoardCodePage == CP_KOREAN) || cpCursor > 0)
		{
			if ( cpCursor >= 0 )
			{
				HRESULT hResult;
				int		cpLocal = min(cpCursor, _cchCompStr) + _ichStart;

				hResult	= TextMsgFilter._pTextDoc->Range(cpLocal, cpLocal, &pTextRange);
				Assert (pTextRange != NULL);
				
				if (hResult == NO_ERROR)
				{
					pTextRange->Select();
					pTextRange->Release();
				}
				TextMsgFilter._pTextDoc->Unfreeze(&lCount);			// Turn on display
			}
		}

		if (bstr)	
			SysFreeString(bstr);
		
		// setup composition window for Chinese in-caret IME
		if (!_fDestroy && (TextMsgFilter._uKeyBoardCodePage == CP_CHINESE_TRAD || 
			TextMsgFilter._uKeyBoardCodePage == CP_CHINESE_SIM))
			IMENotify ( IMN_OPENCANDIDATE, 0x01, TextMsgFilter, TRUE );

	}

	return S_OK;									// No DefWindowProc
}													//  processing.

/*
 *	void CIme_Lev3::SetCompositionStyle (CTextMsgFilter &TextMsgFilter, CCharFormat &CF)
 *
 *	@mfunc
 *		Set up a composition clause's character formmatting.
 *
 *	@comm
 *		If we loaded Office's IMEShare.dll, then we ask it what the formatting
 *		should be, otherwise we use our own, hardwired default formatting.
 *
 *	@devnote
 *		Note the use of pointers to functions when dealing with IMEShare funcs.
 *		This is because we dynamically load the IMEShare.dll.
 *
 */
void CIme_Lev3::SetCompositionStyle (
	CTextMsgFilter &TextMsgFilter,
	UINT attribute,
	ITextFont *pTextFont)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::SetCompositionStyle");

	UINT			ulID = 0;
	COLORREF		crText = UINTIMEBOGUS;
	COLORREF		crBackground = UINTIMEBOGUS;
	BOOL			fBold = FALSE;
	BOOL			fItalic = FALSE;
	BOOL			fStrikeThru = FALSE;
	long			lUnderlineStyle = tomNone;

	if (TextMsgFilter._fRE10Mode)
	{
		COMPCOLOR* pcrComp = TextMsgFilter.GetIMECompAttributes();
		
		if (!pcrComp)
			goto defaultStyle;

		if (attribute > ATTR_TARGET_NOTCONVERTED)
			attribute = ATTR_CONVERTED;

		// IME input for 1.0 mode, need to use IME Color
		fBold = (pcrComp[attribute].dwEffects & CFE_BOLD);		
		fItalic = (pcrComp[attribute].dwEffects & CFE_ITALIC);
		fStrikeThru = (pcrComp[attribute].dwEffects & CFE_STRIKEOUT);

		if (pcrComp[attribute].dwEffects & CFE_UNDERLINE)
			lUnderlineStyle = tomSingle;

		crText = pcrComp[attribute].crText;			
		crBackground = pcrComp[attribute].crBackground;
	}
	else if (W32->HaveIMEShare())
	{
		CIMEShare *pIMEShare;
		if (W32->getIMEShareObject(&pIMEShare))
		{
			if (TextMsgFilter._fUsingAIMM)
			{
				HIMC	hIMC = LocalGetImmContext(TextMsgFilter);	// Get host's IME context.

				if (hIMC)
				{
					attribute = W32->GetDisplayGUID (hIMC, attribute);
					LocalReleaseImmContext(TextMsgFilter, hIMC);	// Done with IME context.
				}
			}

			// IMEShare 98 interface
			fBold = pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFBold);			
			fItalic = pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFItalic);

			if (pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFUl))
			{
				ulID = pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareUKul);
				if(UINTIMEBOGUS != ulID)
				{
					long		lUnderlineCrIdx = 0;
					COLORREF	crUl;

					// get color for underline					
					crUl = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubUl);					
					if(UINTIMEBOGUS != crUl)
					{
						// NOTE:- attribute is 0 based and index for EffectColor is 1 based,
						HRESULT hResult = TextMsgFilter._pTextDoc->SetEffectColor(attribute+1, crUl);
						
						// setup the high nibble for color index
						if (hResult == NOERROR)
							lUnderlineCrIdx = (attribute+1) << 8;
					}

					lUnderlineStyle = IMEShareToTomUL(ulID) + lUnderlineCrIdx;
				}
			}

			crText = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubText);		
			crBackground = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubBack);
		}
		else
		{
			// IMEShare 96 interface
			const IMESTYLE	*pIMEStyle = PIMEStyleFromAttr(attribute);
			if (NULL == pIMEStyle)
				goto defaultStyle;		

			fBold = FBoldIMEStyle(pIMEStyle);
			fItalic = FItalicIMEStyle(pIMEStyle);

			if (FUlIMEStyle(pIMEStyle))
			{			
				ulID = IdUlIMEStyle (pIMEStyle);
				if(UINTIMEBOGUS != ulID)
					lUnderlineStyle = IMEShareToTomUL(ulID);
			}

			crText = RGBFromIMEColorStyle(PColorStyleTextFromIMEStyle(pIMEStyle));						
			crBackground = RGBFromIMEColorStyle(PColorStyleBackFromIMEStyle(pIMEStyle));
		}
	}
	else // default styles when no IMEShare.dll exist.
	{
defaultStyle:
		switch(attribute)
		{										// Apply underline style.
			case ATTR_INPUT:
			case ATTR_CONVERTED:
				pTextFont->SetUnderline(tomDotted);
				break;

			case ATTR_TARGET_NOTCONVERTED:
				pTextFont->SetUnderline(tomSingle);
				break;

			case ATTR_TARGET_CONVERTED:			// Target *is* selection.			
			{
				pTextFont->SetForeColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
				pTextFont->SetBackColor(::GetSysColor(COLOR_HIGHLIGHT));
			}
			break;
		}
		return;			// Done
	}

	//  Now setup all the attribute
	pTextFont->Reset(tomApplyLater);

	if (fBold)
		pTextFont->SetBold(tomTrue);
	else if (TextMsgFilter._fRE10Mode)
		pTextFont->SetBold(tomFalse);

	if (fItalic)
		pTextFont->SetItalic(tomTrue);
	else if (TextMsgFilter._fRE10Mode)
		pTextFont->SetItalic(tomFalse);

	if (fStrikeThru)
		pTextFont->SetStrikeThrough(tomTrue);
	else if (TextMsgFilter._fRE10Mode)
		pTextFont->SetStrikeThrough(tomFalse);

	pTextFont->SetUnderline(lUnderlineStyle);

	// ignore case where text color is same as background color
	if (crText != crBackground)
	{
		if(UINTIMEBOGUS != crText)
			pTextFont->SetForeColor(crText);
		
		if(UINTIMEBOGUS != crBackground)
			pTextFont->SetBackColor(crBackground);		
	}

	pTextFont->Reset(tomApplyNow);
}
/*
 *	COLORREF CIme_Lev3::GetIMEShareColor (CIMEShare *pIMEShare, DWORD dwAttribute, DWORD dwProperty)
 *
 *	@mfunc
 *		Get the IME share color for the given dwAttribute and property
 *
 *
 *	@rdesc
 *		COLORREF of the color
 *
 */
COLORREF CIme_Lev3::GetIMEShareColor(
	CIMEShare *pIMEShare,
	DWORD dwAttribute,
	DWORD dwProperty)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::GetIMEShareColor");

	if (pIMEShare->DwGetIMEStyle(dwAttribute,IdstyIMEShareFSpecCol | dwProperty))
	{
		if (pIMEShare->DwGetIMEStyle(dwAttribute,IdstyIMEShareFSpecColText | dwProperty))
			return (COLORREF) _crTextColor;
		else
			return (COLORREF) _crBkColor;
	}
	else
		return (COLORREF) (pIMEShare->DwGetIMEStyle(dwAttribute, 
				IdstyIMEShareRGBCol | dwProperty));
}

/*
 *	HRESULT CIme_Lev3::IMENotify(const WPARAM wparam, const LPARAM lparam,
 *					CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 3 WM_IME_NOTIFY messages.
 *
 *	@comm
 *		Currently we are only interested in knowing when to update
 *		the n window's position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::IMENotify(
	const WPARAM wparam,			// @parm associated with message.
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	BOOL fCCompWindow)				// @parm Level3 Chinese Composition window
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMENotify");

	if(IMN_OPENCANDIDATE == wparam || IMN_CLOSECANDIDATE == wparam )
	{
		Assert (0 != lparam);

		INT				index;							// Candidate window index.
		CANDIDATEFORM	cdCandForm;
		POINT			ptCaret;
		HIMC			hIMC = LocalGetImmContext(TextMsgFilter);	// Get host's IME context.

		if(hIMC)
		{
			for (index = 0; index < 32; index++)	// Convert bitID to INDEX
			{										//  because *stupid* API
				if((1 << index) & lparam)
					break;
			}
			Assert(((1 << index) & lparam) == lparam);	// Only 1 set?
			Assert(index < 32);

			if(IMN_OPENCANDIDATE == wparam && !(TextMsgFilter._uKeyBoardCodePage == CP_KOREAN))	// Set candidate to caret.
			{
				HRESULT	hResult;
				POINT	ptCurrentBottomPos;
				long	lTextFlow;
				long	lTomType = tomStart+tomClientCoord+TA_BOTTOM+TA_LEFT;
		
				TextMsgFilter._pTextDoc->GetFEFlags(&(TextMsgFilter._lFEFlags));
				lTextFlow = TextMsgFilter._lFEFlags & tomTextFlowMask;

				if (lTextFlow == tomTextFlowWN)
					lTomType = tomStart+tomClientCoord+TA_TOP+TA_LEFT;

				GetCaretPos(&ptCaret);			// Start at caret.

				ptCaret.x = max(0, ptCaret.x);
				ptCaret.y = max(0, ptCaret.y);
					
				cdCandForm.dwStyle = CFS_CANDIDATEPOS;
				
				if ( !fCCompWindow )			// Not positioning the Chinese composition
				{								//	Window.
					hResult = TextMsgFilter._pTextSel->GetPoint( lTomType,
							&(ptCurrentBottomPos.x), &(ptCurrentBottomPos.y) );

					if (hResult != NOERROR)
					{
						RECT	rcArea;

						// GetPoint fails, use application rect in screen coordinates
						hResult = TextMsgFilter._pTextDoc->GetClientRect(tomIncludeInset+tomClientCoord,
									&(rcArea.left), &(rcArea.top),
									&(rcArea.right), &(rcArea.bottom));
						ptCurrentBottomPos.x = ptCaret.x;
						ptCurrentBottomPos.y = rcArea.bottom;
					}

					if (hResult == NOERROR)
					{
						if (TextMsgFilter._uKeyBoardCodePage == CP_JAPAN)
						{
							// Change style to CFS_EXCLUDE, this is to
							// prevent the candidate window from covering
							// the current selection.
							cdCandForm.dwStyle = CFS_EXCLUDE;
							cdCandForm.rcArea.left = ptCaret.x;					

							// FUTURE: for verticle text, need to adjust
							// the rcArea to include the character width.
							cdCandForm.rcArea.right = (lTextFlow == tomTextFlowNE) ? ptCurrentBottomPos.x :
								cdCandForm.rcArea.left + 2;
							cdCandForm.rcArea.top = ptCaret.y;
							ptCaret.y = ptCurrentBottomPos.y + 4;
							cdCandForm.rcArea.bottom = ptCaret.y;
						}
						else
							ptCaret.y = ptCurrentBottomPos.y + 4;
					}
				}

				// Most IMEs will have only 1, #0, candidate window. However, some IMEs
				//  may want to have a window organized alphabetically, by stroke, and
				//  by radical.
				cdCandForm.dwIndex = index;				
				cdCandForm.ptCurrentPos = ptCaret;
				ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
			}
			else									// Reset back to CFS_DEFAULT.
			{
				if(ImmGetCandidateWindow(hIMC, index, &cdCandForm, TextMsgFilter._fUsingAIMM)
						&& CFS_DEFAULT != cdCandForm.dwStyle)
				{
					cdCandForm.dwStyle = CFS_DEFAULT;
					ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
				}				
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.

			if (TextMsgFilter._fHangulToHanja == TRUE  &&
				IMN_CLOSECANDIDATE == wparam &&					 
				W32->OnWinNT4() && OnWinNTFE() && !TextMsgFilter._fUsingAIMM)
			{
				// By pass NT4.0 Kor Bug where we didn't get EndComposition message
				// when user toggle the VK_HANJA key to terminate the reconversion.
				TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_NORMAL);
			}

			if (IMN_CLOSECANDIDATE == wparam && CP_JAPAN == TextMsgFilter._uKeyBoardCodePage)
				_fUpdateWindow = TRUE;			
		}
	}	

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *
 *	CIme_Lev3::IMEMouseOperation (CTextMsgFilter &TextMsgFilter, UINT msg, BOOL	&fTerminateIME)
 *
 *	@mfunc	if current IME support Mouse operation, need to pass
 *		mouse events to IME for processing
 *
 *	@rdesc
 *		BOOL-TRUE if IME handled the mouse events
 *		fTermineateIME-TRUE if we want to terminateIME
 *
 */
BOOL CIme_Lev3::IMEMouseOperation(
	CTextMsgFilter	&TextMsgFilter, 		// @parm the containing message filter.
	UINT			msg,					// @parm message id
	WPARAM			wParam,					// @parm wparam
	BOOL			&fTerminateIME)			// @parm need to terminate IME						
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMEMouseOperation");

	if (IMESupportMouse(TextMsgFilter))
		return TextMsgFilter.MouseOperation(msg, _ichStart, _cchCompStr, wParam, &_wParamBefore, &fTerminateIME, _hwndIME);

	fTerminateIME = TRUE;
	return FALSE;
}

/*
 *
 *	CIme_Lev3::IMESupportMouse (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	check if current IME supports Mouse events.  This should be
 *			a feature for IME Level 3.
 * 
 *	@comm	_sIMESupportMouse is a flag with the following values:
 *				== 0	if we haven't checked IME mouse support
 *				== -1	if we have checked and IME doesn't support mouse events
 *				== 1	if we have checked and IME supports mouse events and we have
 *						retrieved the IME hWnd
 */
BOOL CIme_Lev3::IMESupportMouse(
	CTextMsgFilter &TextMsgFilter) 			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMESupportMouse");
	HIMC	hIMC;									// Host's IME context.
	HWND	hHostWnd;
	long	hWnd;

	if (!MSIMEMouseMsg || _sIMESuportMouse == -1)
		return FALSE;								// No mouse operation support

	if (_sIMESuportMouse == 1)
		return TRUE;								// IME supports mouse operation

	hHostWnd = TextMsgFilter._hwnd;
	
	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;
		
		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	// Check if this IME supports mouse operation
	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.

	_sIMESuportMouse = -1;							// Init. to no support
	if(hIMC)
	{
		_hwndIME = ImmGetDefaultIMEWnd(hHostWnd, TextMsgFilter._fUsingAIMM);
		LocalReleaseImmContext(TextMsgFilter, hIMC);

		// SendMessage returns TRUE if IME supports mouse operation
		if (_hwndIME && SendMessage(_hwndIME, MSIMEMouseMsg, (WPARAM)IMEMOUSE_VERSION, hIMC) )
			_sIMESuportMouse = 1;
	}

	return (_sIMESuportMouse == 1);
}

/*
 *
 *	CIme_Lev3::GetIMECompositionMode (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	Return the current IME composition mode when we have composition characters
 *			or when we haven't received any final string
 * 
 */
LRESULT  CIme_Lev3::GetIMECompositionMode(
	CTextMsgFilter &TextMsgFilter)			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::GetIMECompositionMode");

	if (_cchCompStr || !_fGotFinalString)
		return ICM_LEVEL3;

	if (!_fDestroy)
	{
		HIMC	hIMC = LocalGetImmContext(TextMsgFilter);	// Get host's IME context.
		int		cchCompStr = 0;

		if(hIMC)											// Check if there is composition string.
		{
			if (TextMsgFilter._fUnicodeIME)
				cchCompStr = ImmGetCompositionStringW(hIMC, GCS_COMPSTR, NULL, 0, TextMsgFilter._fUsingAIMM);
			else
				cchCompStr = ImmGetCompositionStringA(hIMC, GCS_COMPSTR, NULL, 0, TextMsgFilter._fUsingAIMM);

			LocalReleaseImmContext(TextMsgFilter, hIMC);
		}

		if (cchCompStr)
			return ICM_LEVEL3;
	}
	return ICM_NOTOPEN;
}

/*
 *	BOOL IMEHangeulToHanja (&TextMsgFilter)
 *	
 *	@func
 *		Initiates an IME composition string edit to convert Korean Hanguel to Hanja.
 *	@comm
 *		Called from the message loop to handle VK_KANJI_KEY.
 *
 *	@devnote
 *		We decide if we need to do a conversion by checking:
 *		- the Fonot is a Korean font,
 *		- the character is a valid SBC or DBC,
 *		- ImmEscape accepts the character and bring up a candidate window
 *
 *	@rdesc
 *		BOOL - FALSE for no conversion. TRUE if OK.
 */
BOOL IMEHangeulToHanja (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEHangeulToHanja");

	if(!TextMsgFilter.IsIMEComposition())
	{
		if(TextMsgFilter._pTextSel->CanEdit(NULL) == NOERROR)
		{
			WCHAR		szCurrentChar;
			long		cCurrentChar;	
			HRESULT		hResult;
			HKL			hKL = GetKeyboardLayout(0x0FFFFFFFF);
			HIMC		hIMC;	

			if (!hKL)
				goto Exit;
			
			hIMC = LocalGetImmContext(TextMsgFilter);
			if (!hIMC)
				goto Exit;

			// Collapse to cpMin
			hResult	= TextMsgFilter._pTextSel->Collapse(tomTrue);

			// get the current character
			hResult	= TextMsgFilter._pTextSel->GetChar(&cCurrentChar);

			if (hResult != NOERROR)
				goto Exit;

			szCurrentChar = (WCHAR)cCurrentChar;
			
			// Check if the IME has a conversion for this Hangeul character.					
			if (ImmEscape(hKL, hIMC, IME_ESC_HANJA_MODE, (LPVOID)&szCurrentChar, TextMsgFilter._fUsingAIMM) != FALSE)
			{
				ITextRange *pTextRange;
				POINT		ptMiddlePos;
				LONG		cpCurrent;

				hResult = TextMsgFilter._pTextSel->GetStart(&cpCurrent);
				if (hResult == S_OK)
				{
					hResult = TextMsgFilter._pTextDoc->Range(cpCurrent, cpCurrent+1, &pTextRange);
					if (hResult == S_OK && pTextRange)
					{
						// Check if the character is in view
						if (pTextRange->GetPoint( tomEnd+TA_BASELINE+TA_LEFT,
							&(ptMiddlePos.x), &(ptMiddlePos.y) ) != NOERROR)
							pTextRange->ScrollIntoView(tomEnd);
						pTextRange->Release();
					}
				}

				TextMsgFilter._fHangulToHanja = TRUE;

				TextMsgFilter._ime = new CIme_HangeulToHanja(TextMsgFilter);

				if(TextMsgFilter.IsIMEComposition())
				{
					// start IME composition for the conversion
					LocalReleaseImmContext(TextMsgFilter, hIMC);
					return TextMsgFilter._ime->StartComposition(TextMsgFilter);
				}
				else
					TextMsgFilter._fHangulToHanja = FALSE;				
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);
		}
	}

Exit:
	return S_FALSE;
}

/*
 *	CIme_HangeulToHanja::CIme_HangeulToHanja()
 *
 *	@mfunc
 *		CIme_HangeulToHanja Constructor.
 *
 *
 */
 CIme_HangeulToHanja::CIme_HangeulToHanja(CTextMsgFilter &TextMsgFilter)	:
	CIme_Lev3(TextMsgFilter)
{
}

/*
 *	HRESULT CIme_HangeulToHanja::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin CIme_HangeulToHanja composition string processing.		
 *
 *	@comm
 *		Call Level3::StartComposition.  Then setup the Korean block
 *		caret for the Hanguel character.
 *
 *	@rdesc
 *		Need to adjust _ichStart and _cchCompStr to make the Hanguel character
 *		"become" a composition character.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_HangeulToHanja::StartComposition(
	CTextMsgFilter &TextMsgFilter )				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_HangeulToHanja::StartComposition");
	HRESULT				hr;

	hr = CIme_Lev3::StartComposition(TextMsgFilter);
	
	// initialize to 1 so Composition string will get rid of the selected Hangeul
	_cchCompStr		= 1;

	// turn on undo
	TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

	// Setup Block caret mode
	TextMsgFilter._pTextDoc->SetCaretType(tomKoreanBlockCaret);

	return hr;
}

/*
 *	HRESULT CIme_HangeulToHanja::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle CIme_HangeulToHanja WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		call CIme_Lev3::CompositionString to get rid of the selected Hanguel character,
 *		then setup the format for the next Composition message.
 *
 *	@devnote
 *		When the next Composition message comes in and that we are no longer in IME,
 *		the new character will use the format as set here.
 */
HRESULT CIme_HangeulToHanja::CompositionString(
	const LPARAM lparam,		// @parm associated with message
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_HangeulToHanja::CompositionString");

	CIme_Lev3::CompositionString(lparam, TextMsgFilter);

	return S_OK;
}
/*
 *	HRESULT CIme_Protected::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle CIme_Protected WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		Just throw away the result string since we are
 *	in read-only or protected mode
 *
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 *
 */
HRESULT CIme_Protected::CompositionString (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Protected::CompositionString");

	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING()) // If result string..
	{
		LONG	cch = 0;
		HIMC	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.
		WCHAR	szCompStr[256];

		if(hIMC)									// Get result string.
		{
			cch = GetCompositionStringInfo(hIMC, GCS_RESULTSTR, 
							szCompStr, sizeof(szCompStr)/sizeof(szCompStr[0]),
							NULL, 0, NULL, NULL, TextMsgFilter._uKeyBoardCodePage, FALSE, TextMsgFilter._fUsingAIMM);

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
		return NOERROR;								// Don't want WM_IME_CHARs.
	}

	// Terminate composition to force a end composition message
	TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_FORCECANCEL);
	return S_FALSE;
}

#endif // NOFEPROCESSING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\kern.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	KERN.CPP -- CCKernCache class |
 *
 *	Class which implements a kerning pair cache. Note that these widths
 *	are stored in the font's design units (2048 pixel high font)
 *	This allows us to share the same kerning pair information for all
 *	sizes of a font.
 *	
 *	The kerning cache assumes you know in advance how many entries
 *	you will put into the cache. It does not support the expensive
 *	operations of growing and re-hashing all the data.
 *
 *	Owner:<nl>
 *		Keith Curtis: Stolen from Quill '98, simplified and improved upon.
 * 
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include <_common.h>
#include <_kern.h>

const int dvpDesign = 2048;

/*
 *	CKernCache::FetchDup(chFirst, chSecond, dvpFont)
 *
 *	@mfunc
 *	Looks up the characters in the table and returns their pair
 *	adjustment if found.
 *
 *	We will scale the value from the font's design units.
 *	
 *	This routine is very important for performance.
 *	Many optimizations (double hashing, early returns if the data 
 *	didn't match but a collision wasn't found) actually slowed things down!
 *
 *	Note this is very similar to the below function but having
 *	separate functions makes pagination 7% faster.
 */
LONG CKernCache::FetchDup(WCHAR chFirst, WCHAR chSecond, LONG dvpFont)
{
	KERNHASHKEY kernhashkey = MakeHashKey(chFirst, chSecond);
	int ikpe = Hash(kernhashkey);

	KPE *pkpe = _pmpkpe.Elem(ikpe);

	for(;;)
	{
		if (pkpe->chFirst == chFirst && pkpe->chSecond == chSecond)
			return MulDiv(pkpe->du, dvpFont, dvpDesign);

		if (pkpe->chFirst == 0)			//Empty slot, so no pair
			return 0;

		ikpe++;
		pkpe++;
		if (ikpe == _pmpkpe.Count())	//Loop around if necessary
		{
			ikpe = 0;
			pkpe = _pmpkpe.Elem(0);
		}
	}
}

/*
 *	CKernCache::Add(chFirst, chSecond, du)
 *
 *	@mfunc
 *	Finds a free spot to put the kerning pair information.
 *	This function cannot fail because the array has been preallocated.
 *
 */
void CKernCache::Add(WCHAR chFirst, WCHAR chSecond, LONG du)
{
	KERNHASHKEY kernhashkey = MakeHashKey(chFirst, chSecond);
	int ikpe = Hash(kernhashkey);

	KPE *pkpe = _pmpkpe.Elem(ikpe);

	for(;;)
	{
		if (pkpe->chFirst == 0)
		{
			pkpe->chFirst = chFirst;
			pkpe->chSecond = chSecond;
			pkpe->du = du;
			return;
		}

		ikpe++;
		pkpe++;
		if (ikpe == _pmpkpe.Count())
		{
			ikpe = 0;
			pkpe = _pmpkpe.Elem(0);
		}
	}
}

/*
 *	CKernCache::FInit(hfont)
 *
 *	@mfunc
 *	If the kern cache is uninitialized, Init it. If there are no
 *	kerning pairs (or it failed) return FALSE.
 *
 *	@rdesc
 *	Return TRUE if you can fetch kerning pairs for this cache
 *
 */
BOOL CKernCache::FInit(HFONT hfont)
{
	if (_kcis == Unitialized)
		Init(hfont);

	return _kcis == Initialized;
}

/*
 *	CKernCache::Init(hfont)
 *
 *	@mfunc
 *	Fetches the kerning pairs from the OS in design units and hashes them
 *	all into a table. Updates _ckis with result
 *	
 */
void CKernCache::Init(HFONT hfont)
{
	KERNINGPAIR *pkp = 0;
	int prime, ikp;
	HFONT hfontOld = 0;
	HFONT hfontIdeal = 0;
	int ckpe = 0;

	HDC hdc = W32->GetScreenDC();

	LOGFONT lfIdeal;
	W32->GetObject(hfont, sizeof(LOGFONT), &lfIdeal);

	//FUTURE (keithcu) Support kerning of Greek, Cyrillic, etc.
	lfIdeal.lfHeight = -dvpDesign;
	lfIdeal.lfCharSet = ANSI_CHARSET;
	hfontIdeal = CreateFontIndirect(&lfIdeal);
	if (!hfontIdeal)
		goto LNone;

	hfontOld = SelectFont(hdc, hfontIdeal);
	Assert(hfontOld);

	ckpe = GetKerningPairs(hdc, 0, 0);
	if (ckpe == 0)
		goto LNone;

	prime = FindPrimeLessThan(ckpe * 5 / 2);
	if (prime == 0)
		goto LNone;

	pkp = new KERNINGPAIR[ckpe];
	if (!pkp)
		goto LNone;

	GetKerningPairs(hdc, ckpe, pkp);

	_pmpkpe.Add(prime, 0);

	PvSet(*(void**) &_pmpkpe);
	
	for (ikp = 0; ikp < ckpe; ikp++)
		Add(pkp[ikp].wFirst, pkp[ikp].wSecond, pkp[ikp].iKernAmount);

	_kcis = Initialized;
	goto LDone;

LNone:
	_kcis = NoKerningPairs;

LDone:
	delete []pkp;
	if (hfontOld)
		SelectObject(hdc, hfontOld);
	DeleteObject(hfontIdeal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\layout.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	LAYOUT.CPP -- CLayout class |
 *
 *	Recursive structure which contains an array of lines.
 *	
 *	Owner:<nl>
 *		Murray Sargent: Initial table implementation
 *		Keith Curtis:	Factored into a separate class for
 *						performance, simplicity
 * 
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

//FUTURE: (KeithCu) More stuff should be put into here, e.g., RecalcLines, 
//The CDisplayML should just be a class that knows about Device descriptors, 
//pagination and scrolling, etc., i.e., things that are the same for all
//layouts and things that apply only to the outermost layout. This code knows
//how to manage and update recursive arrays of lines.

#include "_common.h"
#include "_dispml.h"
#include "_select.h"
#include "_measure.h"
#include "_render.h"

void CLayout::DeleteSubLayouts(
	LONG ili,
	LONG cLine)
{
	CLine *pli = Elem(ili);

	if(cLine < 0)
		cLine = Count();

	LONG cLineMax = Count() - ili;
	cLine = min(cLine, cLineMax);

	AssertSz(ili >= 0 && cLine >= 0, "DeleteSubLayouts: illegal line count");

	// Delete sublayouts 
	for(; cLine--; pli++)
		delete pli->GetPlo();
}

/*
 *	CLayout::VposFromLine(pdp, ili)
 *
 *	@mfunc
 *		Computes top of line position
 *
 *	@rdesc
 *		top position of given line (relative to the first line)
 */
LONG CLayout::VposFromLine(
	CDisplayML *pdp,		//@parm Parent display 
	LONG		ili) 		//@parm Line we're interested in
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLayout::VposFromLine");
	LONG cli = 0, vPos = 0;
	CLine *pli = 0;

	if (IsNestedLayout())
	{
		Assert(!IsTableRow());					// _iPFCell layouts are horizontal
		Assert(ili < Count());
		cli = ili;
		pli = Elem(0);
		vPos = 0;
	}
	else
	{
		if(!pdp->WaitForRecalcIli(ili))			// out of range, use last valid line
		{
			ili = Count() - 1;
			ili = (ili > 0) ? ili : 0;
		}
		cli	= ili - pdp->_iliFirstVisible;
		pli = Elem(pdp->_iliFirstVisible);
		vPos = pdp->_vpScroll + pdp->_dvpFirstVisible;
	}

	while(cli > 0)
	{
		vPos += pli->GetHeight();
		cli--;
		pli++;
	}
	while(cli < 0)
	{	
		pli--;
		vPos -= pli->GetHeight();
		cli++;
	}

	AssertSz(vPos >= 0, "VposFromLine height less than 0");
	return vPos;
}

/*
 *	CLayout::LineFromVPos(pdp, vPos, pdvpLine, pcpFirst)
 *
 *	@mfunc
 *		Computes line at given y position. Returns top of line vPos
 *		cp at start of line cp, and line index.
 *
 *	@rdesc
 *		index of line found
 */
LONG CLayout::LineFromVpos(
	CDisplayML *pdp,	//@parm Parent display
	LONG vPos,			//@parm Vpos to look for (relative to first line)
	LONG *pdvpLine,		//@parm Returns vPos at top of line /r first line (can be NULL)
	LONG *pcpFirst)		//@parm Returns cp at start of line (can be NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLayout::LineFromVpos");
	LONG cpLi;
	LONG dy;
	LONG ili = 0;
	LONG yLi;
	CLine *pli;

	if(IsNestedLayout())
		goto BindFrom0;

	yLi = pdp->_vpScroll;

	if(!pdp->WaitForRecalc(-1, pdp->_vpScroll))
	{
		yLi = 0;
		cpLi = 0;
		goto done;
	}

	cpLi = pdp->_cpFirstVisible;
	ili = pdp->_iliFirstVisible;
	if(!pdp->IsInPageView())
		yLi += pdp->_dvpFirstVisible;
	dy = vPos - yLi;
	
	if(dy < 0 && -dy <= pdp->_vpScroll)
	{
		// Closer to first visible line than to first line:
		// go backwards from first visible line.
		while(vPos < yLi && ili > 0)
		{
			pli = Elem(--ili);
			yLi -= pli->GetHeight();
			cpLi -= pli->_cch;
		}
	}
	else
	{
		if(dy < 0)
		{
			// Closer to first line than to first visible line:
			// so start at first line.
BindFrom0:
			cpLi = _cpMin;
			yLi = 0;
			ili = 0;
		}
		pli = Elem(ili);
		while(vPos > yLi && ili < Count()-1)
		{
			yLi += pli->GetHeight();
			cpLi += pli->_cch;
			ili++;
			pli++;
		}
		if(vPos < yLi && ili > 0)
		{
			ili--;
			pli--;
			yLi -= pli->GetHeight();
			cpLi -= pli->_cch;
		}
	}

done:
	if(pdvpLine)
		*pdvpLine = yLi;

	if(pcpFirst)
		*pcpFirst = cpLi;

	return ili;
}

/*
 *	CLayout::FindTopCell(&cch, pli, &ili, dul, &dy, pdvp, pliMain,iliMain, pcLine)
 *
 *	@mfunc
 *		Find cch and height change back to current position in 
 *		top cell corresponding to the current vertically merged cell.
 *		Enter with cch = cch from current cell back to start of row.
 *
 *	@rdesc
 *		target line in top cell
 */
CLine * CLayout::FindTopCell(
	LONG &		cch,		//@parm In/out parm for cch back to top
	CLine	*	pli,		//@parm Table-row line
	LONG &		ili,		//@parm Corresponding line index & return ili
	LONG		dul,		//@parm Current cell x offset
	LONG &		dy,			//@parm In/Out parm for y offset in top cell
	LONG *		pdvp,		//@parm TopCellHeight - heights of inbetween rows
	CLine *		pliMain,	//@parm Line preceding first line accessible by pli
	LONG		iliMain,	//@parm Line index corresponding to pliMain
	LONG *		pcLine)		//@parm Count() of possible CLayout for returned pli
{
	LONG		cCell;
	LONG		iCell;
	CLayout	*	plo;
	const CELLPARMS *prgCellParms;
	const CParaFormat *pPF;

#ifdef DEBUG
	BYTE bTableLevel = pli->GetPlo()->GetPFCells()->_bTableLevel;
#endif

	if(pcLine)
		*pcLine = 0;					// Default no lines in case of error

	// Need to use uCell to identify cell rather than iCell, since
	// horizontal merge can change iCell from row to row
	do									// Backup row by row
	{
		if(ili > 0)
		{
			pli--;						// Go to previous row
			ili--;
		}
		else if(pliMain)
		{
			pli = pliMain;
			ili = iliMain;
			pliMain = NULL;				// Switch to pliMain only once!
			
		}
		else
		{
			AssertSz(FALSE, "CLayout::FindTopCell: no accessible top cell");
			return NULL;
		}
		plo = pli->GetPlo();			// Get its cell display
		if(!plo || !plo->IsTableRow())	// Illegal structure or not table row
		{
			AssertSz(FALSE, "CLayout::FindTopCell: no accessible top cell");
			return NULL;
		}
		pPF = plo->GetPFCells();
		AssertSz(pPF->_bTableLevel == bTableLevel,
			"CLayout::FindTopCell: no accessible top cell");
		prgCellParms = pPF->GetCellParms();
		cCell = plo->Count();
		iCell = prgCellParms->ICellFromUCell(dul, cCell);
		dy  += pli->GetHeight();	// Add row height
		cch += pli->_cch;			// Add in cch for whole row
	}
	while(!IsTopCell(prgCellParms[iCell].uCell));

	cch -= 2;						// Sub cch for StartRow delim
	
	pli = plo->Elem(0);				// Point at 1st cell in row
	for(ili = 0; ili < iCell; ili++)// Sub cch's for cells
		cch -= (pli++)->_cch;		//  preceding iCellth cell

	if(pdvp)						// Return top-cell height - heights of
		*pdvp = pli->GetHeight() - dy;//  cells in between

	LONG cLine = 0;
	LONG dvpBrdrTop = plo->_dvpBrdrTop;
	ili = 0;
	dy -= dvpBrdrTop;
	plo = pli->GetPlo();
	if(plo)							// Top cell is multiline
	{
		cLine = plo->Count();
		pli	  = plo->Elem(0);		// Advance pli to line in plo
		if(pli->IsNestedLayout())
			dy += dvpBrdrTop;
		while(ili < cLine && dy >= pli->GetHeight())	//  nearest to input position
		{
			dy -= pli->GetHeight();
			ili++;
			if(ili == cLine)		// Done: leave pli pointing at last line
				break;
			cch -= pli->_cch;
			pli++;
		}
	}

	if(pcLine)
		*pcLine = cLine;
	return pli;
}

/*
 *	CLayout::FindTopRow(pli, ili, pliMain, iliMain, pPF)
 *
 *	@mfunc
 *		Find CLine for top row in a table
 *
 *	@rdesc
 *		CLine for top row in table
 */
CLine * CLayout::FindTopRow(
	CLine	*	pli,		//@parm Entry table-row line
	LONG 		ili,		//@parm Corresponding line index
	CLine *		pliMain,	//@parm Line preceding first line accessible by pli
	LONG		iliMain,	//@parm Line index corresponding to pliMain
	const CParaFormat *pPF)	//@parm CParaFormat for entry plo
{
	BYTE	 bAlignment  = pPF->_bAlignment;	// Target row must have same
	BYTE	 bTableLevel = pPF->_bTableLevel;	//  alignment and level
	CLine *	 pliLast;
	CLayout *plo;
	do									// Backup row by row
	{
		pliLast = pli;					// Last line pointing at row in table
		if(ili > 0)
		{
			pli--;						// Go to previous line
			ili--;
		}
		else if(pliMain)				// More lines to go back to
		{
			pli = pliMain;
			ili = iliMain;
			pliMain = NULL;				// Switch to pliMain only once!
		}
		else
			break;

		plo = pli->GetPlo();			// Get its cell display
		if(!plo || !plo->IsTableRow())
			break;
		pPF = plo->GetPFCells();
	}
	while(pPF->_bAlignment == bAlignment && pPF->_bTableLevel == bTableLevel);

	return pliLast;
}

/*
 *	CLayout::GetCFCells()
 *
 *	@mfunc
 *		Return CCharFormat for the table row described by this CLayout
 *
 *	@rdesc
 *		Table row CCharFormat
 */
const CCharFormat* CLayout::GetCFCells()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CLayout::GetCFCells");

	Assert(_iCFCells >= 0);
	
	const CCharFormat *pCF;
	
	if(FAILED(GetCharFormatCache()->Deref(_iCFCells, &pCF)))
	{
		AssertSz(FALSE, "CLayout::GetCFCells: couldn't deref _iCFCells");
		pCF = NULL;
	}
	return pCF;
}

/*
 *	CLayout::GetPFCells()
 *
 *	@mfunc
 *		Return CParaFormat for the table row described by this CLayout
 *
 *	@rdesc
 *		Table row CParaFormat
 */
const CParaFormat* CLayout::GetPFCells() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CLayout::GetPFCells");

	Assert(_iPFCells >= 0);
	
	const CParaFormat *pPF;
	
	if(FAILED(GetParaFormatCache()->Deref(_iPFCells, &pPF)))
	{
		AssertSz(FALSE, "CLayout::GetPF: couldn't deref _iPFCells");
		pPF = NULL;
	}
	return pPF;
}

/*
 *	CLayout::GetLORowAbove(pli, ili, pliMain, iliMain)
 *
 *	@mfunc
 *		Return CLayout for the table row described by the line above pli.
 *		If not a table row, return NULL.
 *
 *	@rdesc
 *		Table row CLayout for row above pli's
 */
const CLayout* CLayout::GetLORowAbove(
	CLine *	pli,		//@parm Entry table-row line
	LONG	ili,		//@parm Corresponding line index
	CLine *	pliMain,	//@parm Line preceding first line accessible by pli
	LONG	iliMain)	//@parm Line index corresponding to pliMain
{
	if(!ili && pliMain && iliMain)			// More lines to go back to
	{
		pli = pliMain;
		ili = iliMain;
	}
	if(ili)
	{
		CLayout *plo = (pli - 1)->GetPlo();	// Get cell display for row above
		if(plo && plo->IsTableRow())
			return plo;
	}
	return NULL;							// No line above 
}

/*
 *	CLayout::CpFromPoint(&me, pt, prcClient, prtp, prp, fAllowEOL, phit,
 *							pdispdim, pcpActual, pliParent, iliParent)
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CLayout::CpFromPoint(
	CMeasurer	&me,		//@parm Measurer
	POINTUV		pt,			//@parm Point to compute cp at (client coords)
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const prtp,//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual,	//@parm Out cp that pt is above
	CLine *		pliParent,	//@parm Parent pli for table row displays
	LONG		iliParent)	//@parm Parent ili corresponding to pli
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLayout::CpFromPoint");

	LONG	cch = 0;
	LONG	cp = 0;
	HITTEST	hit = HT_Nothing;
	LONG	ili;
	CLine *	pli;
	CLayout *plo = NULL;
    RECTUV	rcView;
	int		v = pt.v;						// Save input y coordinate
	LONG	yLine = 0;
	CDisplayML *pdp = (CDisplayML*) me.GetPdp();

	if (IsNestedLayout())
		rcView = *prcClient;
	else
	{
		pdp->GetViewRect(rcView, prcClient);
		pt.v += pdp->GetVpScroll();
		if(pt.u >= 0)						// If x coordinate is within view,
			pt.u += pdp->GetUpScroll();		//  adjust by scroll value
	}

	if(phit)
		*phit = HT_Nothing;					// Default in case early return

	// Get line under hit
	if(IsTableRow())						// This display is a table row
	{										// Shrink to cell text boundaries 
		pli = Elem(0);						// Point at starting cell CLine

		// Move over to start of cells
		const CParaFormat *pPFCells = GetPFCells();
		LONG		dul = 0;
		LONG		dulRTLRow = pPFCells->GetRTLRowLength();
		LONG		dup = 0;
		BOOL		fCellLow;
		LONG		h  = me.LUtoDU(pPFCells->_dxOffset);
		const CELLPARMS *prgCellParms = pPFCells->GetCellParms();
		LONG		u;						// Tracks start of text in cell
		LONG		u0 = pli->_upStart;
		LONG		uCell = 0;

		pt.v -= _dvpBrdrTop;				// Subtract off border top
		cp = _cpMin;
		if(dulRTLRow)
			u0 += me.LUtoDU(dulRTLRow);
		ili = 0;

		while(1)
		{
			u = u0 + dup + h;				// Indent in current cell
			cch = cp - _cpMin;
			uCell = prgCellParms[ili].uCell;
			fCellLow = IsLowCell(uCell);
			dul += GetCellWidth(uCell);
			me.SetDulLayout(GetCellWidth(uCell) - 2*pPFCells->_dxOffset);
			dup = me.LUtoDU(dul);
			if(!dulRTLRow && pt.u < u0 + dup ||// pt.u is inside current cell
			    dulRTLRow && pt.u > u0 - dup)
			{
				LONG ili0 = iliParent;
				if(fCellLow)				// Cell merged vertically
				{							//  with the one above it
					LONG   dy = pt.v;
					CLine *pli0 = FindTopCell(cch, pliParent, ili0, dul, dy,
											  NULL, NULL, 0, NULL);
					if(pli0)
					{						// Found top cell
						cch += 2;			// Include cch of row-start delim
						pli = pli0;			// Use its pli and backup
						ili = ili0;
						cp -= cch;			// Backup to start of pli
						pt.v += dy;
					}
				}
				if(!dulRTLRow && pt.u < u)
				{							// In cell gap, so select cell							
					hit = HT_LeftOfText;
					cch = 0;				// Setup for start of row
					goto finish;				
				}
				break;
			}
			cp += pli->_cch;				// Add in cell's cch
			ili++;
			if(ili == Count())
			{
				hit = HT_RightOfText;
				goto finish;				
			}
			pli++;
		}
		LONG dupCell = me.LUtoDU(GetCellWidth(uCell));
		if(dulRTLRow)
			pt.u -= me.LUtoDU(dulRTLRow - dul) + h;
		else
			pt.u -= dup - dupCell + h;
		rcView.right = dupCell - 2*h;
		pt.v -= GetVertAlignShift(uCell, pli->GetHeight());
	}
	else									// This display isn't a table row
	{
		// Adjust coordinates relative to view origin
		rcView.right -= rcView.left;
		pt.u -= rcView.left;
		pt.v -= rcView.top;
		ili = LineFromVpos(pdp, pt.v, &yLine, &cp);
		if(ili < 0)
			return -1;
		pli = Elem(ili);
		if(yLine + pli->GetHeight() < pt.v)
			hit = HT_BelowText;				// Return hit below text
	}
	rcView.left = 0;
	rcView.top = 0;

	AssertSz(pli || !ili, "CLayout::CpFromPoint invalid line pointer");

	if(pli)									// Line exists, even it it's
	{										//  above or below current screen
		HITTEST hit0;
		if(v < rcView.top)					// Note if hit occurs above or
			hit = HT_AboveScreen;			//  below text
		if(v > rcView.bottom && !IsNestedLayout())
			hit = HT_BelowText;

		plo = pli->GetPlo();
	    pt.v -= yLine;

		if(plo)								// Child layout
		{
			pt.u -= pli->_upStart;
			plo->_cpMin = cp;				// Update child's _cpMin
			if(plo->IsTableRow())			// Table row
			{
				plo->_cpMin += 2;			// Bypass TR start delimiter

				if(pt.u < 0)
				{
					plo = NULL;
					hit = HT_LeftOfText;	// Return hit left of text
					Assert(cch >= 0);		//  (should be row)
					goto finish;
				}
			}
			cp = plo->CpFromPoint(me, pt, &rcView, prtp, prp, fAllowEOL,
								  &hit0, pdispdim, pcpActual, pli, ili);
			if(cp == -1)
				return -1;
			cch = cp - _cpMin;
		}
		else								// Leaf line
		{
			me.SetLayout(this);
			me.SetCp(cp);

			// Support khyphChangeAfter
			me.SetIhyphPrev(ili > 0 ? (pli - 1)->_ihyph : 0);

			// Get character in line
			cch = pli->CchFromUp(me, pt, pdispdim, &hit0, pcpActual);

			// Don't allow click at EOL to select EOL marker and take into
			// account single line edits as well
			if(cch == pli->_cch && pli->_cchEOP && (!fAllowEOL || me.GetPrevChar() == CELL))
			{
				// Adjust position on line by amount backed up. OK for
				// me._rpCF and me._rpPF to get out of sync with me._rpTX,
				// since they're not needed for me.GetCp().
				cch += me._rpTX.BackupCRLF();
			}
			cp = me.GetCp();
		}
		if(hit != HT_BelowText && hit != HT_AboveScreen || hit0 == HT_RightOfText)
			hit = hit0;
	}

finish:
	if(!plo)								// Store info from leaf line
	{
		if(prtp)
			prtp->SetCp(cp);
		if(prp)
		{
			Assert(cch >= 0);
			prp->Set(ili, cch, this);
		}
	}
	if (phit)
		*phit = hit;

	return cp;
}

/*
 *	CLayout::PointFromTp(&me, rtp, prcClient, fAtEnd, pt, prp, taMode, pdispdim)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CLayout::PointFromTp(
	CMeasurer	&me,		//@parm Measurer
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of prev line for ambiguous cp
	POINTUV &	pt,			//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	LONG	 cp = rtp.GetCp();
	LONG	 dy = 0;
	RECTUV	 rcView;
	CDisplayML *pdp = (CDisplayML*) me.GetPdp();
	CLinePtr rp(pdp);

    if(!pdp->WaitForRecalc(cp, -1))
		return -1;

    if(!IsNestedLayout())				// Main display
	{
		if(!rp.SetCp(cp, fAtEnd))
			return -1;

		pdp->GetViewRect(rcView, prcClient);
		pt.u = rcView.left - pdp->_upScroll;
		pt.v = rcView.top  - pdp->_vpScroll;
	}
	else								// Subdisplay
	{
		rp.Init(*this);

		rp.BindToCp(cp - _cpMin);
		if(fAtEnd && !IsTableRow())		// Ambiguous-cp caret position
			rp.AdjustBackward();		//  belongs at prev EOL

		rcView = *prcClient;
		pt.u = rcView.left;
		pt.v = rcView.top;
	}

	AssertSz(pdp->_ped->_fInPlaceActive || prcClient, "Invalid client rect");
	
	LONG ili = rp.GetLineIndex();
	CLine *pli = NULL;
	CLayout *plo = NULL;
	LONG xEnd = -1;						// pt.u to use at end of table row

	if(IsTableRow())					// This layout is a table row
	{									// Shrink to cell text boundaries
		const CParaFormat *pPFCells = GetPFCells();
		const CELLPARMS *  prgCellParms = pPFCells->GetCellParms();
		LONG dul = 0;
		LONG dulRTLRow = pPFCells->GetRTLRowLength();
		LONG h = me.LUtoDU(pPFCells->_dxOffset);
		LONG i;

		cp = _cpMin;
		pli = Elem(0);

		for(i = 0; i < ili; i++, pli++)
		{
			dul += GetCellWidth(prgCellParms[i].uCell);
			cp += pli->_cch;
		}
		LONG uCell = prgCellParms[ili].uCell;
		me.SetDulLayout(GetCellWidth(uCell) - 2 * pPFCells->_dxOffset);

		if(dulRTLRow)
		{
			if(dul < dulRTLRow)
			{
				uCell = prgCellParms[ili + 1].uCell;
				dul += GetCellWidth(prgCellParms[i].uCell);
			}
			dul = dulRTLRow - dul;
		}
		rcView.left  = pt.u + me.LUtoDU(dul) + h;
		rcView.right = pt.u + me.LUtoDU(dul + GetCellWidth(uCell)) - h;
		pt.u = rcView.left;
		if(!GetCellWidth(uCell))
		{
			pt.v += _dvp;
			goto done;
		}
		if(ili + 1 == Count() && rp->_cch == rp.GetIch())
		{
			xEnd = rcView.right + h + 1;
			if(dulRTLRow)
				xEnd = rcView.left - h - 1;
		}
		pt.v += GetVertAlignShift(uCell, pli->GetHeight());
		if(!(taMode & TA_CELLTOP))
			pt.v += _dvpBrdrTop;
	}
	else								// This layout isn't a table row
	{
		pt.v += VposFromLine(pdp, ili);
		cp -= rp.GetIch();
	}

	pli = Elem(ili);
	plo = pli->GetPlo();

	if(plo)								// Line has child display
	{									// Define child rcView and delegate
		RECTUV rc;						//  to child
		pt.u	 += pli->_upStart;
		rc.left	  = pt.u;
		rc.right  = pt.u + rcView.right - rcView.left;
		rc.top	  = pt.v;
		rc.bottom = pt.v + pli->GetHeight();
		plo->_cpMin = cp;				// Update child display's _cpMin
		if(plo->IsTableRow())
			plo->_cpMin += 2;			// Bypass table row start code	

		if(plo->PointFromTp(me, rtp, &rc, fAtEnd, pt, prp, taMode, pdispdim) == -1)
			return -1;
	}
	else								// Line is a leaf line
	{
		me.SetLayout(this);
		me.Move(-rp.GetIch());			// Backup to start of line		
		me.NewLine(*rp);				// Measure from there to where we are

		//Support khyphChangeAfter
		me.SetIhyphPrev(ili > 0 ? (pli - 1)->_ihyph : 0);

		LONG xCalc = rp->UpFromCch(me, rp.GetIch(), taMode, pdispdim, &dy);

		if(pt.u + xCalc <= rcView.right || !pdp->GetWordWrap() || pdp->GetTargetDev())
		{
			// Width is in view or there is no wordwrap so just
			// add the length to the point.
			pt.u += xCalc;
		}
		else
			pt.u = rcView.right; //Hit-test went too far, limit it.

		pt.v += dy;
	}
	if(xEnd != -1)
		pt.u = xEnd;				// Return x coord at end of table row

done:
	if(prp && !plo)
		*prp = rp;						// Return innermost rp
	return rp;							// Return outermost iRun
}

/*
 *	CLayout::Measure(&me, pli, ili, uiFlags, pliTarget, iliMain, pliMain, pdvpExtra)
 *
 *	@mfunc
 *		Computes line break (based on target device) and fills
 *		in *pli with resulting metrics on rendering device
 *
 *	@rdesc 
 *		TRUE if OK
 */
BOOL CLayout::Measure (
	CMeasurer&	me,			//@parm Measurer pointing at text to measure 
	CLine	*	pli,		//@parm Line to store result in
	LONG		ili,		//@parm Line index corresponding to pli
	UINT		uiFlags,	//@parm Flags
	CLine *		pliTarget,	//@parm Returns target-device line metrics (optional)
	LONG		iliMain,	//@parm Line index corresponding to pliMain
	CLine *		pliMain,	//@parm Line preceding 1st line in pli layout (optional)
	LONG *		pdvpExtra)	//@parm Returns extra line height for vmrged cells (opt)
//REVIEW (keithcu) pliTarget is busted in the recursive case.
{
	CTxtEdit *	ped = me.GetPed();
	LONG		cchText = ped->GetTextLength();
	LONG		cpSave = me.GetCp();
	CLine *		pliNew;
	const CDisplayML * pdp = (const CDisplayML *)me.GetPdp();
	const CParaFormat *pPF = me.GetPF();

	// Measure one line, which is either a table row or a line in a paragraph
	if(pPF->IsTableRowDelimiter())
	{
		// Measure table row, which is modeled as a CLayout with one
		// CLine per cell. In the backing store, table rows start with
		// the two chars STARTFIELD CR and end with ENDFIELD CR. Cells
		// are delimited by CELL.
		LONG		cpStart = me.GetCp();
		LONG		dul = 0;
		LONG		dxCell = 0;
		LONG		dvp = 0;
		LONG		dvpMax = 0;
		CLayout *	plo = new CLayout();
		const CLayout *	 ploAbove = GetLORowAbove(pli, ili, pliMain, iliMain);
		const CELLPARMS *prgCellParms = pPF->GetCellParms();

		if(!plo)
			return FALSE;

		plo->_iCFCells = me.Get_iCF();
		plo->_iPFCells = me.Get_iPF();
		pli->SetPlo(plo);

		AssertSz(pPF->_bTabCount && me.GetChar() == STARTFIELD, "Invalid table-row header");
		me.Move(2);
		AssertSz(me.GetPrevChar() == CR, "Invalid table-row header");

		plo->_cpMin = me.GetCp();
		
		// Save current values
		LONG	 dulLayoutOld = me.GetDulLayout();
		LONG	 dvlBrdrTop	  = 0;
		LONG	 dvlBrdrBot	  = 0;
		const CLayout *ploOld = me.GetLayout();
		CArray <COleObject*> rgpobjWrapOld;
		me._rgpobjWrap.TransferTo(rgpobjWrapOld);

		// Create CLines for each cell and measure them
		for(LONG iCell = 0; iCell < pPF->_bTabCount; iCell++)
		{
			me.SetNumber(0);
			LONG uCell = prgCellParms[iCell].uCell;
			dxCell = GetCellWidth(uCell);
			dul += dxCell;

			// Add a line for the next cell
			pliNew = plo->Add(1, NULL);
			if(!pliNew)
				return FALSE;

			LONG dvl = prgCellParms[iCell].GetBrdrWidthTop();
			dvlBrdrTop = max(dvlBrdrTop, dvl);
			dvl = prgCellParms[iCell].GetBrdrWidthBottom();
			dvlBrdrBot = max(dvlBrdrBot, dvl);

			if(!ploAbove)
				uCell &= ~fLowCell;			// Can't be a low cell if no row above
			AssertSz(!IsLowCell(uCell) || me.GetChar() == NOTACHAR,
				"CLayout::Measure: invalid low cell");
			me.SetLayout(plo);
			me.SetDulLayout(dxCell - 2*pPF->_dxOffset);
			plo->Measure(me, pliNew, iCell, uiFlags | MEASURE_FIRSTINPARA, pliTarget, iliMain, pliMain);

			if(IsLowCell(uCell))		
			{							 
				// If a low cell in set of vertically merged cells, check
				// if corresponding cell on next row is also merged
				CPFRunPtr rp(me);
				rp.FindRowEnd(pPF->_bTableLevel);

				const CParaFormat *pPF1 = rp.GetPF();
				BOOL  fBottomCell = !pPF1->IsTableRowDelimiter();

				if(!fBottomCell)
				{
					const CELLPARMS *prgCellParms1 = pPF1->GetCellParms();
					LONG iCell1 = prgCellParms1->ICellFromUCell(dul, pPF1->_bTabCount);

					if(iCell1 >= 0 && !IsLowCell(prgCellParms1[iCell1].uCell))
						fBottomCell = TRUE;
				}
				if(fBottomCell)
				{
					// Need to include top cell in current row height
					// calculation
					LONG cch = me.GetCp() - cpStart;
					LONG dy1 = 0;
					LONG iliT = ili;
					LONG dvpCell = 0;
					
					if(!FindTopCell(cch, pli, iliT, dul, dy1, &dvpCell, pliMain, iliMain, NULL))
						uCell &= ~fLowCell;	// Not a valid low cell
					else if(dvpCell > 0)
						dvp = max(dvp, dvpCell);
				}								
			}
			if(!IsVertMergedCell(uCell) && dxCell || !dvp && iCell == pPF->_bTabCount - 1)
				dvp = max(pliNew->GetHeight(), dvp);
			dvpMax = max(dvpMax, pliNew->GetHeight());
		}

		//Restore original values
		me.SetDulLayout(dulLayoutOld);
		me.SetLayout(ploOld);
		me.SetIhyphPrev(0);
		me._rgpobjWrap.Clear(AF_DELETEMEM);
		
		rgpobjWrapOld.TransferTo(me._rgpobjWrap);

#ifdef DEBUG
		// Bypass table-row terminator
		if(me.GetChar() != ENDFIELD)
			me._rpTX.MoveGapToEndOfBlock();
		AssertSz(me.GetPrevChar() == CELL && pPF->_bTabCount == plo->Count(),
			"Incorrect table cell count");
		AssertSz(me.GetChar() == ENDFIELD,
			"CLayout::Measure: invalid table-row terminator");
		me._rpPF.AdjustForward();
		const CParaFormat *pPFme = me.GetPF();
		AssertSz(pPFme->IsTableRowDelimiter(),
			"CLayout::Measure: invalid table-row terminator");
#endif

		me.UpdatePF();						// me._pPF points at TRD PF
		me.Move(2);							// Bypass table row terminator
		AssertSz(me.GetPrevChar() == CR,
			"CLayout::Measure: invalid table-row terminator");
		if(me.IsHidden())
		{
			CCFRunPtr rp(me);
			me.Move(rp.FindUnhiddenForward());
		}

		if(me.GetChar() == CELL)			// Bypass possible CELL delimeter
		{									//  at end of table row (happens
			Assert(pPF->_bTableLevel > 1);	//  when table row is last line
			CTxtSelection *psel = ped->GetSelNC();	//  of cell
			if(!psel || psel->GetCch() ||	// Don't bypass CELL if selection
			   psel->GetCp() !=me.GetCp() ||//  is an IP at this position,
			   !psel->GetShowCellLine())	//  i.e., display a blank line
			{
				me.Move(1);
				pli->_fIncludeCell = TRUE;
			}
		}

		plo->_dvpBrdrBot = me.GetPBorderWidth(dvlBrdrBot);
		plo->_dvpBrdrTop = me.GetPBorderWidth(dvlBrdrTop);
		if(ploAbove)
			plo->_dvpBrdrTop = max(plo->_dvpBrdrTop, ploAbove->_dvpBrdrBot);
		dvp += plo->_dvpBrdrTop;			  // Add top border width
		if(!me.GetPF()->IsTableRowDelimiter())// End of table: add in 
			dvp += plo->_dvpBrdrBot;		  //  bottom border width

		// Define CLine parameters for table row
		if(pPF->_dyLineSpacing)
		{
			LONG dvpLine = me.LUtoDU(pPF->_dyLineSpacing);
			if(dvpLine < 0)					// Negative row height means use
				dvp = -dvpLine;				//  the magnitude exactly
			else
				dvp = max(dvp, dvpLine);	// Positive row height means
		}									//  "at least"
		plo->_dvp = dvp;
		dvpMax = max(dvpMax, dvp);
		if(pdvpExtra)
			*pdvpExtra = dvpMax - dvp;

		// Fill in CLine structure for row
		pli->_cch = me.GetCp() - cpSave;
		pli->_fFirstInPara = pli->_fHasEOP = TRUE;
		pli->_dup = me.LUtoDU(dul);
		me._li._fFirstInPara = TRUE;
		pli->_upStart  = me.MeasureLeftIndent();
		me.MeasureRightIndent();			// Define me._upEnd
		pli->_cObjectWrapLeft  = me._li._cObjectWrapLeft;
		pli->_cObjectWrapRight = me._li._cObjectWrapRight;
		USHORT dvpLine = plo->_dvp;
		USHORT dvpDescent = 0;
		me.UpdateWrapState(dvpLine, dvpDescent);
		pli->_fFirstWrapLeft  = me._li._fFirstWrapLeft;
		pli->_fFirstWrapRight = me._li._fFirstWrapRight;

		if(!pdp->IsInOutlineView() && IN_RANGE(PFA_RIGHT, pPF->_bAlignment, PFA_CENTER))
		{
			// Normal view with center or flush-right para. Move right accordingly
			// If not top row of like-aligned rows, use indent of top row
			CLine *pliFirst = FindTopRow(pli, ili, pliMain, iliMain, pPF);
			if(pli != pliFirst)
				pli->_upStart = pliFirst->_upStart;

			else
			{
				LONG uShift = me.LUtoDU(dulLayoutOld - dul);  
				uShift = max(uShift, 0);		// Don't allow alignment to go < 0
												// Can happen with a target device
				if(pPF->_bAlignment == PFA_CENTER)
					uShift /= 2;
				pli->_upStart = uShift;
			}
		}
		me.SetNumber(0);					// Update me._wNumber in case next
	}										//  para is numbered
	else if(!pli->Measure(me, uiFlags, pliTarget))	// Not a table row
		return FALSE;						// Measure failed

	if(pli->_fFirstInPara && pPF->_wEffects & PFE_PAGEBREAKBEFORE)
		pli->_fPageBreakBefore = TRUE;

	me.SetIhyphPrev(pli->_ihyph);

	if(!IsTableRow() || me.GetPrevChar() == CELL)// Not a table row display or	
		return TRUE; 							//  cell text fits on 1 line

	// Multiline table cell: allocate its CLayout
	CLayout *plo = new CLayout();
	if(!plo)
		return FALSE;						// Not enuf RAM

	plo->_cpMin = cpSave;
	pliNew = plo->Add(1, NULL);
	if(!pliNew)
	{
		ped->GetCallMgr()->SetOutOfMemory();
		TRACEWARNSZ("Out of memory Recalc'ing lines");
		return FALSE;
	}
	*pliNew = *pli;							// Copy first line of cell layout
	pli->SetPlo(plo);						// Turn line into a layout line

	// Calculate remaining lines in cell.
	// Eventually would be nice to share this code with RecalcLines()
	BOOL fFirstInPara;
	LONG dvp = pliNew->GetHeight();
	LONG iliNew = 0;

	while(me.GetCp() < cchText)
	{
		fFirstInPara = pliNew->_fHasEOP;
		pliNew = plo->Add(1, NULL);
		iliNew++;

		if(!pliNew)
		{
			ped->GetCallMgr()->SetOutOfMemory();
			TRACEWARNSZ("Out of memory Recalc'ing lines");
			return FALSE;
		}
		// New table row can start after EOP, i.e., allow recursion here
		uiFlags = MEASURE_BREAKATWORD | (fFirstInPara ? MEASURE_FIRSTINPARA : 0);
		if(!plo->Measure(me, pliNew, iliNew, uiFlags, pliTarget))
		{
			Assert(FALSE);
			return FALSE;
		}
		dvp += pliNew->GetHeight();
		if(me.GetPrevChar() == CELL)
			break;							// Done with current cell
	}
	pli->_upStart = 0;
	plo->_dvp = dvp;
	pli->_cch = me.GetCp() - cpSave;

	return TRUE;
}

/*
 *	CLayout::Render(&re, pli, prcView, fLastLine, ili, cLine)
 *
 *	@mfunc
 *		Render visible part of the line *pli
 *
 *	@rdesc
 *		TRUE iff successful
 *
 *	@devnote
 *		re is moved past line (to beginning of next line).
 *		FUTURE: the RenderLine functions return success/failure.
 *		Could do something on failure, e.g., be specific and fire
 *		appropriate notifications like out of memory or character
 *		not in font.  Note that CLayout::_cpMin isn't used in
 *		rendering, so we don't have to update it the way we do in
 *		the query functions.
 */
BOOL CLayout::Render(
	CRenderer &	  re,		//@parm Renderer to use
	CLine *		  pli,		//@parm Line to render
	const RECTUV *prcView,	//@parm View rect to use
	BOOL		  fLastLine,//@parm TRUE iff last line of control
	LONG		  ili,		//@parm Line index of pli
	LONG		  cLine)	//@parm # lines in pli's CLayout
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLayout::Render");

	CLayout *plo = pli->GetPlo();
	if(!plo)
		return pli->Render(re, fLastLine);	// Render leaf line

	LONG	cLine1 = plo->Count();			// Count of lines in sublayout
	LONG	ili1;							// Index of first line in sublayout
	CLine *	pli1 = plo->Elem(0);			// Ptr to first line in sublayout
	POINTUV	pt;

	if(plo->IsTableRow())					// Line's nested display is a table row
	{
		// Render table row, which is modeled as a CLayout with one
		// CLine per cell. In the backing store, table rows start with
		// the two chars STARTFIELD CR and end with ENDFIELD CR. Cells
		// are terminated by CELL.
		const CLayout *		ploAbove = GetLORowAbove(pli, ili);
		const CParaFormat *	pPF = plo->GetPFCells();
		const CELLPARMS *	prgCellParms = pPF->GetCellParms();
		LONG	cpStart = re.GetCp();
		LONG	dul = 0;
		BOOL	fSetErase = FALSE;
		LONG	hl = pPF->_dxOffset;		// Logical half gap
		LONG	h  = re.LUtoDU(hl);			// Device  half gap
		RECTUV	rcView;
		LONG	u = prcView->left + pli->_upStart - re._pdp->GetUpScroll();

		// Bypass table-row start
		AssertSz(pPF->_bTabCount && re.GetChar() == STARTFIELD,	"Invalid table-row header");
		AssertSz(pPF == re.GetPF(), "Invalid table-row pPF");
		re.Move(2);
		AssertSz(re.GetPrevChar() == CR, "Invalid table-row header");

		// Save current state
		LONG	crBackOld	  = re.GetDefaultBackColor();
		LONG	crTextOld	  = re.GetDefaultTextColor();
		LONG	dulLayoutOld  = re.GetDulLayout();
		LONG	dulRTLRow	  = pPF->GetRTLRowLength();
		LONG	dvpBrdrTop	  = plo->_dvpBrdrTop;
		CLine *	pli0;
		POINTUV	ptOld		  = re.GetCurPoint();
		RECTUV	rcRender;
		RECTUV	rcRenderOld	  = re.GetRcRender();
		RECTUV	rcViewOld	  = re.GetRcView();
		const CLayout *ploOld = re.GetLayout();

		rcView.left		= u + h;				// Default for LTR row
		rcView.right	= rcView.left;			// Suppress compiler warning
		rcView.top		= ptOld.v;
		rcRender.top	= rcView.top;
		rcView.bottom	= rcView.top + pli->GetHeight();
		rcRender.bottom	= rcView.bottom;

		if(dulRTLRow)
			rcView.right = u + re.LUtoDU(dulRTLRow);

		// Render each cell
		for(ili1 = 0; ili1 < cLine1; ili1++, pli1++)
		{
			LONG dvp = 0;					// Additional cell height if
			LONG uCell = prgCellParms[ili1].uCell;

			dul += GetCellWidth(uCell);
			re.SetLayout(pli1->GetPlo());
			re.SetDulLayout(GetCellWidth(uCell) - 2*hl);

			// Reduce roundoff by converting dul instead of multiple uCell
			if(dulRTLRow)					// Right-To-Left row
				rcView.left	 = u + h + re.LUtoDU(dulRTLRow - dul);	// Convert horizontal coords
			else
				rcView.right = u + re.LUtoDU(dul);

			rcRender.left  = rcView.left - h;	   
			rcRender.right = rcView.right;

			//Set state
			re.StartRender(rcView, rcRender);
			pt.u = rcView.left;
			pt.v = rcView.top + plo->GetVertAlignShift(uCell, pli1->GetHeight());
			if(!IsLowCell(uCell))
				pt.v += dvpBrdrTop;
			re.SetRcViewTop(pt.v);			// Clear to top of cell 
			re.SetCurPoint(pt);
			if(IsTopCell(uCell))
			{
				// Calculate bottom of set of vertically merged cells
				LONG	 ili0;
				LONG	 iCell;
				CLayout *plo0;
				const CELLPARMS *prgCellParms0;

				for(ili0 = ili + 1, pli0 = pli + 1; ili0 < cLine; ili0++, pli0++)
				{
					plo0 = pli0->GetPlo();
					if(!plo0 || !plo0->IsTableRow())
						break;
					prgCellParms0 = plo0->GetPFCells()->GetCellParms();
					iCell = prgCellParms0->ICellFromUCell(dul, plo0->Count());
					if(iCell < 0 || !IsLowCell(prgCellParms0[iCell].uCell))
						break;
					dvp += pli0->GetHeight();	// Add row height
				}
				if(dvp)
				{
					rcView.bottom += dvp;
					rcRender.bottom += dvp;
					re.SetRcBottoms(rcView.bottom, rcRender.bottom);
				}
			}
			COLORREF crf = crTextOld;
			LONG icrf = prgCellParms[ili1].GetColorIndexForegound();
			LONG icrb = prgCellParms[ili1].GetColorIndexBackgound();
			if(icrf | icrb)						// If any nonzero bits,
			{									//  calc special color
				BYTE	 bS = prgCellParms[ili1].bShading;
				COLORREF crb = re.GetShadedColorFromIndices(icrf, icrb, bS, pPF);
				fSetErase = re.EraseRect(&rcRender, crb);
				if(IsTooSimilar(crf, crb))
					crf = re.GetShadedColorFromIndices(icrb, icrf, bS, pPF);
			}
			else
				re.SetDefaultBackColor(crBackOld);
			re.SetDefaultTextColor(crf);

			if(!ploAbove)
				uCell &= ~fLowCell;				// Can't be low cell if no row above
			if(IsLowCell(uCell))				// Cell merged vertically with
			{									//  the one above it
				LONG cch = re.GetCp() -cpStart;	// Use cLine0, ili0, pli0 to
				LONG cLine0;					//  refer to text in set
				LONG cpNext = re.GetCp()	 	//  of vert merged cells
							+ (re.GetChar() == NOTACHAR ? 2 : 1);
				LONG dy = 0;
				LONG ili0 = ili;

				// Get target line to display
				pli0 = FindTopCell(cch, pli, ili0, dul, dy, NULL, NULL, 0, &cLine0);
				if(!pli0)
					uCell &= ~fLowCell;			// Whoops, no cell above
				else
				{
					pt.v -= dy;
					re.SetCurPoint(pt);
					re.Move(-cch);
					for(; ili0 < cLine0; ili0++, pli0++)
					{
						//Support khyphChangeAfter
						re.SetIhyphPrev(ili0 > 0 ? (pli0 - 1)->_ihyph : 0);

						if(!Render(re, pli0, &rcView, ili0 == cLine0 - 1, ili0, cLine0))
							return FALSE;
					}
					re.SetCp(cpNext);			 // Bypass [NOTACHAR] CELL
				}
			}
			if(!IsLowCell(uCell))				// Solo cell or top cell of
			{									//  vertically merged set
				if(!Render(re, pli1, &rcView, !pli1->GetPlo(), ili1, cLine1))
					return FALSE;
				if(dvp)							// Rendered set of vmerged cells
				{
					rcView.bottom -= dvp;		// Restore rcView/rcRender bottoms
					rcRender.bottom -= dvp;
					re.SetRcBottoms(rcView.bottom, rcRender.bottom);
				}
			}
			if(fSetErase)
				re.SetErase(TRUE);				// Restore CRenderer::_fErase
			re.SetRcViewTop(rcView.top);		// Restore re._rcView.top in case changed
			if(dulRTLRow)						// Restore rcView.right
				rcView.right = rcView.left - h;
			else
				rcView.left = rcView.right + h;
		}

		//Restore previous state
		re.SetLayout(ploOld);
		re.SetDulLayout(dulLayoutOld);
		re.SetDefaultBackColor(crBackOld);
		re.SetDefaultTextColor(crTextOld);
		re.StartRender(rcViewOld, rcRenderOld);
		re.SetCurPoint(ptOld);

		// Bypass table-row terminator
		AssertSz(re.GetPrevChar() == CELL && pPF->_bTabCount == plo->Count(),
			"CLayout::Render:: incorrect table cell count");
		AssertSz(re.GetChar() == ENDFIELD, "CLayout::Render: invalid table-row terminator");

		re.Move(2);							// Bypass table row terminator
		AssertSz(re.GetPrevChar() == CR, "invalid table-row terminator");

		BOOL fDrawBottomLine = !re._rpTX.IsAtTRD(STARTFIELD);
		LONG dvp = re.DrawTableBorders(pPF, u, plo->_dvp,
									   fDrawBottomLine | fLastLine*2, dul,
									   ploAbove ? ploAbove->GetPFCells() : NULL);
		if(re.IsHidden())
		{
			CCFRunPtr rp(re);
			re.Move(rp.FindUnhiddenForward());
		}
		if(re.GetChar() == CELL && pli->_fIncludeCell)
		{
			Assert(pPF->_bTableLevel > 1);
			re.Move(1);						// Bypass CELL at end of cell 
		}									//  containing a table
		ptOld.v += pli->GetHeight() + dvp;	// Advance to next line	position
		re.SetCurPoint(ptOld);
		if(fLastLine)
			re.EraseToBottom();
		return TRUE;
	}

	RECTUV	rcRender  = re.GetRcRender();
	LONG	dvpBottom = min(prcView->bottom, rcRender.bottom);
	LONG	dvpTop	  = max(prcView->top, rcRender.top);
	LONG	v0;
	dvpTop = max(dvpTop, 0);

	// Line's nested layout is a regular layout galley, i.e., not a table row
	for(ili1 = 0; ili1 < cLine1; ili1++, pli1++)
	{
		pt = re.GetCurPoint();
		v0 = pt.v + pli1->GetHeight();
		fLastLine = ili1 == cLine1 - 1 || v0 >= dvpBottom;

		//Support khyphChangeAfter
		re.SetIhyphPrev(ili1 > 0 ? (pli1 - 1)->_ihyph : 0);

		if(v0 < dvpTop)
		{
			pt.v = v0;						// Advance to next line	position
			re.SetCurPoint(pt);
			re.Move(pli1->_cch);
		}
		else if(pt.v >= dvpBottom)
			re.Move(pli1->_cch);			// Get to end of nested display

		else if(!Render(re, pli1, prcView, fLastLine, ili1, cLine1))
			return FALSE;
	}

	return TRUE;
 }

/*
 *	CLayout::GetVertAlignShift(uCell, dypText)
 *
 *	@mfunc
 *		Render visible part of the line *pli
 *
 *	@rdesc
 *		Vertical shift for cell text
 *
 *	@devnote
 *		Calculating this shift for vertically merged cells is tricky because
 *		dypCell = sum of the cell heights of all cells in the vertically
 *		merged set. In particular, if the table is not nested, one needs to
 *		wait for recalc of all rows in the set. dypText is relatively easy
 *		since it's the height of the top cell in the set.
 */
LONG CLayout::GetVertAlignShift(
	LONG	uCell,		//@parm uCell to use
	LONG	dypText)	//@parm Text height in cell
{
	LONG dyp = 0;
	if(IsVertMergedCell(uCell))
	{
	}
	else if(GetCellVertAlign(uCell))
	{
		dyp = _dvp - _dvpBrdrTop - _dvpBrdrBot - dypText;
		if(dyp > 0 && IsCellVertAlignCenter(uCell))
			dyp /= 2;
	}
	return dyp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\lbhost.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LBHOST.CPP -- Text Host for CreateWindow() Rich Edit 
 *		List Box Control | 
 *		Implements CLstBxWinHost message
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		12/15/97 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

#ifndef NOLISTCOMBOBOXES

#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"
#include "_cbhost.h"

ASSERTDATA

// REListbox scroll notification
#define LBN_PRESCROLL			0x04000
#define LBN_POSTSCROLL			0x08000

// special define to set VSCROLL topindex to index directly
#define SB_SETINDEX 0x0fff0

#ifdef DEBUG
const UINT db_rgLBUnsupportedStyle[] = {
	LBS_MULTICOLUMN,
	LBS_NODATA,			
	LBS_NOREDRAW,
	LBS_NOSEL,
	0
};

const UINT db_rgLBUnsupportedMsg[] = {
	LB_GETLOCALE,
	LB_SETLOCALE,
//	LB_INITSTORAGE,
	LB_ITEMFROMPOINT,
	LB_SETANCHORINDEX,
	LB_SETCOLUMNWIDTH,
	LB_ADDFILE,
	LB_DIR,
	EM_GETLIMITTEXT,
	EM_POSFROMCHAR,
	EM_CHARFROMPOS,
	EM_SCROLLCARET,
	EM_CANPASTE,
	EM_DISPLAYBAND,
	EM_EXGETSEL,
	EM_EXLIMITTEXT,
	EM_EXLINEFROMCHAR,
	EM_EXSETSEL,
	EM_FINDTEXT,
	EM_FORMATRANGE,
	EM_GETEVENTMASK,
	EM_GETOLEINTERFACE,
	EM_GETPARAFORMAT,
	EM_GETSELTEXT, 
	EM_HIDESELECTION,
	EM_PASTESPECIAL,
	EM_REQUESTRESIZE,
	EM_SELECTIONTYPE,
	EM_SETBKGNDCOLOR,
	EM_SETEVENTMASK,
	EM_SETOLECALLBACK,
	EM_SETTARGETDEVICE,
	EM_STREAMIN,
	EM_STREAMOUT,
	EM_GETTEXTRANGE,
	EM_FINDWORDBREAK,
	EM_SETOPTIONS,
	EM_GETOPTIONS,
	EM_FINDTEXTEX,
#ifdef _WIN32
	EM_GETWORDBREAKPROCEX,
	EM_SETWORDBREAKPROCEX,
#endif

	/* Richedit v2.0 messages */
	EM_SETUNDOLIMIT,
	EM_REDO,
	EM_CANREDO,
	EM_GETUNDONAME,
	EM_GETREDONAME,
	EM_STOPGROUPTYPING,
	EM_SETTEXTMODE,
	EM_GETTEXTMODE,
	EM_AUTOURLDETECT,
	EM_GETAUTOURLDETECT,
	EM_SHOWSCROLLBAR,	
	/* East Asia specific messages */
	EM_SETPUNCTUATION,
	EM_GETPUNCTUATION,
	EM_SETWORDWRAPMODE,
	EM_GETWORDWRAPMODE,
	EM_SETIMECOLOR,
	EM_GETIMECOLOR,
	EM_CONVPOSITION,
	EM_SETLANGOPTIONS,
	EM_GETLANGOPTIONS,
	EM_GETIMECOMPMODE,
	EM_FINDTEXTW,
	EM_FINDTEXTEXW,

	/* RE3.0 FE messages */
	EM_RECONVERSION,
	EM_SETIMEMODEBIAS,
	EM_GETIMEMODEBIAS,
	/* Extended edit style specific messages */
	0
};

// Checks if the style is in the passed in array
BOOL LBCheckStyle(UINT msg, const UINT* rg)
{
	for (int i = 0; rg[i]; i++)
		if (rg[i] & msg)
		{
			char Buffer[128];
			sprintf(Buffer, "Unsupported style recieved 0x0%lx", rg[i]);
			AssertSz(FALSE, Buffer);
			return TRUE;
		}
	return FALSE;
}

// Checks if the msg is in the passed in array
BOOL LBCheckMessage(UINT msg, const UINT* rg)
{
	for (int i = 0; rg[i]; i++)
		if (rg[i] == msg)
		{
			char Buffer[128];
			sprintf(Buffer, "Unsupported message recieved 0x0%lx", msg);
			AssertSz(FALSE, Buffer);
			return TRUE;
		}
	return FALSE;
}

#define CHECKSTYLE(msg) LBCheckStyle(msg, db_rgLBUnsupportedStyle)
#define CHECKMESSAGE(msg) LBCheckMessage(msg, db_rgLBUnsupportedMsg)
#else
#define CHECKSTYLE(msg)	
#define CHECKMESSAGE(msg)
#endif

// internal listbox messages
#define LB_KEYDOWN WM_USER+1

// UNDONE:
//	Should this go into _w32sys.h??
#ifndef CSTR_LESS_THAN
// 
//  Compare String Return Values. 
// 
#define CSTR_LESS_THAN            1           // string 1 less than string 2 
#define CSTR_EQUAL                2           // string 1 equal to string 2 
#define CSTR_GREATER_THAN         3           // string 1 greater than string 
#endif


// UNDONE : LOCALIZATION
// these vary by country/region!  For US they are VK_OEM_2 VK_OEM_5.
//       Change lboxctl2.c MapVirtualKey to character - and fix the spelling?
#define VERKEY_SLASH     0xBF   /* Vertual key for '/' character */
#define VERKEY_BACKSLASH 0xDC   /* Vertual key for '\' character */

// Used for Listbox notifications
#define LBNOTIFY_CANCEL 	1
#define LBNOTIFY_SELCHANGE 	2
#define LBNOTIFY_DBLCLK		4

// Used for LBSetSelection
#define LBSEL_SELECT	1
#define LBSEL_NEWANCHOR	2
#define LBSEL_NEWCURSOR	4
#define LBSEL_RESET		8
#define LBSEL_HIGHLIGHTONLY 16

#define LBSEL_DEFAULT (LBSEL_SELECT | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR | LBSEL_RESET)

// Used for keyboard and mouse messages
#define LBKEY_NONE 0
#define LBKEY_SHIFT	1
#define LBKEY_CONTROL 2
#define LBKEY_SHIFTCONTROL 3

extern const TCHAR szCR[];

// Size of allocated string
#define LBSEARCH_MAXSIZE 256

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);

// helper function for compare string.  This function checks for null strings
// because CStrIn doesn't like initializing string with zero length
int CompareStringWrapper( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cch1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cch2 			// size, in bytes or characters, of second string  
)
{
	// check if one of the 2 strings is 0-length if so then
	// no need to proceed the one with the 0-length is the less
	if (!cch1 || !cch2)
	{
		if (cch1 < cch2)
			return CSTR_LESS_THAN;
		else if (cch1 > cch2)
			return CSTR_GREATER_THAN;
		return CSTR_EQUAL;
	}
	return CompareString(Locale, dwCmpFlags, lpString1, cch1, lpString2, cch2);	
}

template<class CLbData> CLbData
CDynamicArray<CLbData>::_sDummy = {0, 0};

//////////////////////////// System Window Procs ////////////////////////////
/*
 *	RichListBoxWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services.
 *
 *	@rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
extern "C" LRESULT CALLBACK RichListBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichListBoxWndProc", msg);

	LRESULT	lres = 0;
	HRESULT hr;
	CLstBxWinHost *phost = (CLstBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
	BOOL	fRecalcHeight = FALSE;

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CLstBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam);

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WINCE)
		if (!phost)
		{
			(void) CLstBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam);
			phost = (CLstBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
		}
		break;

	case WM_DESTROY:
		if(phost)
			CLstBxWinHost::OnNCDestroy(phost);
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// in certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	CHECKMESSAGE(msg);

	long nTemp = 0;
	switch(msg)
	{
	///////////////////////Painting. Messages///////////////////////////////
	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		phost->OnSysColorChange();
		break;

	case WM_PRINTCLIENT:
	case WM_PAINT:
		{
			PAINTSTRUCT ps;
			RECT rc;
 			HPALETTE hpalOld = NULL;
			HDC		hdc;
			RECT rcClient;
			BOOL fErase = TRUE;

			//RAID 6964: WM_PRINTCLIENT should not call BeginPaint. If a HDC is passed
			//down in the wparam, use it instead of calling BeginPaint.
			if (!wparam)
			{
				hdc = BeginPaint(hwnd, &ps);
				fErase = ps.fErase;
			}
			else
				hdc = (HDC) wparam;
			
			// Since we are using the CS_PARENTDC style, make sure
			// the clip region is limited to our client window.
			GetClientRect(hwnd, &rcClient);

			// Set up the palette for drawing our data
			if(phost->_hpal)
			{
				hpalOld = SelectPalette(hdc, phost->_hpal, TRUE);
				RealizePalette(hdc);
			}

			SaveDC(hdc);
			IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
				rcClient.bottom);
				
			if (!phost->_fOwnerDraw)
			{
				phost->_pserv->TxDraw(
					DVASPECT_CONTENT,  		// Draw Aspect
					-1,						// Lindex
					NULL,					// Info for drawing optimazation
					NULL,					// target device information
					hdc,					// Draw device HDC
					NULL, 				   	// Target device HDC
					(const RECTL *) &rcClient,// Bounding client rectangle
					NULL, 					// Clipping rectangle for metafiles
					&ps.rcPaint,			// Update rectangle
					NULL, 	   				// Call back function
					NULL,					// Call back parameter
					TXTVIEW_ACTIVE);		// What view - the active one!
			}
			else if (phost->LbEnableDraw())
			{
				// Owner draw
				int nViewsize = phost->GetViewSize();
				int nCount = phost->GetCount();
				int nTopidx = phost->GetTopIndex();
				
				if (!phost->_fOwnerDrawVar)
				{
					// notify each visible item and then the one which has the focus
					int nBottom = min(nCount, nTopidx + nViewsize);
					if (nBottom >= nCount || !phost->IsItemViewable(nBottom))
						nBottom--;
					for (int i = nTopidx; i <= nBottom; i++) 
					{
						// get Rect of region and see if it intersects
			    		phost->LbGetItemRect(i, &rc);
			    		if (IntersectRect(&rc, &rc, &ps.rcPaint))
			    		{
							//first erase the background and notify parent to draw
							if (fErase)
								FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
			    			phost->LbDrawItemNotify(hdc, i, ODA_DRAWENTIRE, phost->IsSelected(i) ? ODS_SELECTED : 0);
			    		}
					}

					// Now draw onto the area where drawing may not have been done or erased
					if (fErase)
					{
						int nDiff = nCount - nTopidx;
						if (nDiff < nViewsize || 
							(phost->_fNoIntegralHeight && nDiff == nViewsize))
						{
							rc = rcClient;
							if (nDiff < 0)
								nDiff *= -1;  // lets be positive

							rc.top = nDiff * phost->GetItemHeight();
							if (IntersectRect(&rc, &rc, &ps.rcPaint))
								FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
						}
					}
				}
				else
				{
					// Owner draw with variable height case
					rc = rcClient;
					rc.left = 0;
					rc.bottom = rc.top;

					for (int i = nTopidx; i < nCount && rc.bottom < rcClient.bottom; i++)
					{
						RECT rcIntersect;
						rc.top = rc.bottom;
						rc.bottom = rc.top + phost->_rgData[i]._uHeight;
						if (IntersectRect(&rcIntersect, &rc, &ps.rcPaint))
			    		{
							//first erase the background and notify parent to draw
							if (fErase)
								FillRect(hdc, &rcIntersect, (HBRUSH)(COLOR_WINDOW + 1));
			    			phost->LbDrawItemNotify(hdc, i, ODA_DRAWENTIRE, phost->IsSelected(i) ? ODS_SELECTED : 0);
			    		}
					}

					if (fErase)
					{
						// Now draw onto the area where drawing may not have been done or erased
						if (rc.bottom < rcClient.bottom)
						{
							rc.top = rc.bottom;
							rc.bottom = rcClient.bottom;
							if (IntersectRect(&rc, &rc, &ps.rcPaint))
								FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
						}
					}
				}
			}

			// Restore palette if there is one
#ifndef NOPALETTE
			if(hpalOld)
				SelectPalette(hdc, hpalOld, TRUE);
#endif
			RestoreDC(hdc, -1);

			// NOTE: Bug #5431
			// This bug could be fixed by replacing the hDC to NULL
			// The hdc can be clipped from BeginPaint API.  So just pass in NULL
			// when drawing focus rect
			phost->SetCursor(hdc, phost->GetCursor(), FALSE);			
			if (!wparam)
				EndPaint(hwnd, &ps);
		}
		break;

	/////////////////////////Mouse Messages/////////////////////////////////
	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
		break;

	case WM_LBUTTONDBLCLK:
		phost->_fDblClick = 1;
		/* Fall through case */
	case WM_LBUTTONDOWN:
		if (!phost->_fFocus)
			SetFocus(hwnd);
		phost->OnLButtonDown(wparam, lparam);
		break;
		
	case WM_MOUSEMOVE:
		if (!phost->GetCapture())
			break;
		phost->OnMouseMove(wparam, lparam);
		break;
		
	case WM_LBUTTONUP:	
		if (!phost->GetCapture())
			break;
		phost->OnLButtonUp(wparam, lparam, LBN_SELCHANGE);
		break;

	case WM_MOUSEWHEEL:
		if (wparam & (MK_SHIFT | MK_CONTROL))
			goto defwndproc;

		lres = phost->OnMouseWheel(wparam, lparam);
		break;

	///////////////////////KeyBoard Messages////////////////////////////////
	case WM_KEYDOWN:
		phost->OnKeyDown(LOWORD(wparam), lparam, 0);
		break;

	case WM_CHAR:
		if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				// UNDONE:
				// Need to see what we should do in WM_IME_CHAR
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
		
		phost->OnChar(LOWORD(wparam), lparam);
		break;
		
	case WM_TIMER:
		if (phost->OnTimer(wparam, lparam))
			goto serv;
		break;

	case LBCB_TRACKING:
		phost->OnCBTracking(wparam, lparam);
		break;

	//UNDONE:
	//	Messages should be ordered from most often called --> least often called
	//		
	case LB_GETITEMRECT:
		Assert(lparam);
		lres = -1;
		if (((wparam < (unsigned)phost->GetCount()) && 
			phost->IsItemViewable((long)wparam)) || wparam == (unsigned int)-1 ||
			wparam == 0 && phost->GetCount() == 0)
			lres = phost->LbGetItemRect(wparam, (RECT*)lparam);
		break;
	
	///////////////////////ListBox Messages/////////////////////////////////
	case LB_GETITEMDATA:
		if ((unsigned)phost->GetCount() <= wparam) 
			lres = LB_ERR;
		else
			lres = phost->GetData(wparam);
		break;
		
	case LB_SETITEMDATA:
		lres = LB_ERR;
		if ((int)wparam >= -1 && (int)wparam < phost->GetCount())
		{
			// if index is -1 this means all the dataItems are set
			// to the value
			lres = 1;
			if (wparam == -1)
				phost->LbSetItemData(0, phost->GetCount() - 1, lparam);
			else
				phost->LbSetItemData(wparam, wparam, lparam);
		}
		break;
	
	case LB_GETSELCOUNT:
		if (lparam != NULL || wparam != 0)
		{
			lres = LB_ERR;
			break;
		}
		// FALL through case
		
	case LB_GETSELITEMS:
		// retrieves all the selected items in the list
		lres = LB_ERR;
		if (!phost->IsSingleSelection())
		{
			int j = 0;
			for (int i = 0; i < phost->GetCount(); i++)
			{
				if (phost->IsSelected(i))
				{
					if (lparam)
					{
						if (j < (int)wparam)						
							((int*)lparam)[j] = i;
						else
							break;		// exced the buffer size
					}
					j++;
				}
			}
			lres = j;
		}
		break;
		
	case LB_GETSEL:
		// return the select state of the passed in index
		lres = LB_ERR;
		if ((int)wparam >= 0 && (int)wparam < phost->GetCount())
			lres = phost->IsSelected((long)wparam);		
		break;
		
	case LB_GETCURSEL:
		// Get the current selection
		lres = phost->LbGetCurSel();
		break;
		
	case LB_GETTEXTLEN:
		// Retieves the text at the requested index
		lres = LB_ERR;
		if (wparam < (unsigned)phost->GetCount())
			lres = phost->GetString(wparam, (PWCHAR)NULL);
		break;

	case LB_GETTEXT:			
		// Retieves the text at the requested index
		lres = LB_ERR;
		if ((int)lparam != NULL && (int)wparam >= 0 && (int)wparam < phost->GetCount())
			lres = phost->GetString(wparam, (PWCHAR)lparam);
		break;
		
	case LB_RESETCONTENT:
		// Reset the contents
		lres = phost->LbDeleteString(0, phost->GetCount() - 1);
		break;
		
	case LB_DELETESTRING:
		// Delete requested item
		lres = phost->LbDeleteString(wparam, wparam);
		break;
		
	case LB_ADDSTRING:
		lres = phost->LbInsertString((phost->_fSort) ? -2 : -1, (LPCTSTR)lparam);
		break;
		
	case LB_INSERTSTRING:
		lres = LB_ERR;
		if (wparam <= (unsigned long)phost->GetCount() || (signed int)wparam == -1 || wparam == 0)
			lres = phost->LbInsertString(wparam, (LPCTSTR)lparam);
		break;		

	case LB_GETCOUNT:
		// retrieve the count
		lres = phost->GetCount();
		break;
		
	case LB_GETTOPINDEX:
		// Just return the top index
		lres = phost->GetTopIndex();
		break;

	case LB_GETCARETINDEX:
		lres = phost->GetCursor();
		break;

	case LB_GETANCHORINDEX:
		lres = phost->GetAnchor();
		break;
		
	case LB_FINDSTRINGEXACT:
		// For NT compatibility
		wparam++;
		
		// Find and select the item matching the string text
		if ((int)wparam >= phost->GetCount() || (int)wparam < 0)
			wparam = 0;

		lres = phost->LbFindString(wparam, (LPCTSTR)lparam, TRUE);
		if (0 <= lres)
			break;
				
		lres = LB_ERR;
		break;
		
	case LB_FINDSTRING:	
		// For NT compatibility
		wparam++;
		
		// Find and select the item matching the string text
		if (wparam >= (unsigned)phost->GetCount())
			wparam = 0;

		lres = phost->LbFindString(wparam, (LPCTSTR)lparam, FALSE);
		if (0 > lres)
			lres = LB_ERR;
		break;
	
	case LB_SELECTSTRING:
		if (phost->IsSingleSelection())
		{			
			// For NT compatibility
			wparam++;
			
			// Find and select the item matching the string text
			if ((int)wparam >= phost->GetCount() || (int)wparam < 0)
				wparam = 0;

			lres = phost->LbFindString(wparam, (LPCTSTR)lparam, FALSE);
			if (0 <= lres)
			{
				// bug fix #5260 - need to move to selected item first
				// Unselect last item and select new one
				Assert(lres >= 0 && lres < phost->GetCount());
				if (phost->LbShowIndex(lres, FALSE) && phost->LbSetSelection(lres, lres, LBSEL_DEFAULT, lres, lres))
				{
#ifndef NOACCESSIBILITY
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);

					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
					break;
				}
			}			
		}
		// If failed then let it fall through to the LB_ERR
		lres = LB_ERR;
		break;
		
	case LB_SETSEL:
		// We only update the GetAnchor() and _nCursor if we are selecting an item
		if (!phost->IsSingleSelection())
		{
			// We need to return zero to mimic system listbox
			if (!phost->GetCount())
				break;

			//bug fix #4265
			int nStart = lparam;
			int nEnd = lparam;
			int nAnCur = lparam;
			if (lparam == (unsigned long)-1)
			{
				nAnCur = phost->GetCursor();
				nStart = 0;
				nEnd = phost->GetCount() - 1;
			}
			if (phost->LbSetSelection(nStart, nEnd, (BOOL)wparam ? 
				LBSEL_SELECT | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR : 0, nAnCur, nAnCur))		
			{
				if (wparam && lparam != ((unsigned long)-1) && nAnCur >= 0 && nAnCur < phost->GetCount()
					&& !phost->IsItemViewable(nAnCur))			// Is selected item in view?
					phost->LbShowIndex(nAnCur, FALSE);			//	scroll to the selected item

#ifndef NOACCESSIBILITY
				if (lparam == (unsigned long)-1)
				{
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
				}
				else if (wparam)
				{
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
				}
				else
				{
					phost->_nAccessibleIdx = lparam + 1;
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
				}
				phost->_fNotifyWinEvt = TRUE;
				phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
				break;
			}
		}

		// We only get here if error occurs or list box is a singel sel Listbox
		lres = LB_ERR;
		break;

	case LB_SELITEMRANGEEX:
		// For this message we need to munge the messages a little bit so it
		// conforms with LB_SETITEMRANGE
		if ((int)lparam > (int)wparam)
		{
			nTemp = MAKELONG(wparam, lparam);
			wparam = 1;
			lparam = nTemp;
		}
		else
		{
			nTemp = MAKELONG(lparam, wparam);
			wparam = 0;
			lparam = nTemp;			
		}	
		/* Fall through case */

	case LB_SELITEMRANGE:				
		// We have to make sure the range is valid
		if (LOWORD(lparam) >= phost->GetCount())
		{
			if (HIWORD(lparam) >= phost->GetCount())
				//nothing to do so exit without error
				break;
			lparam = MAKELONG(HIWORD(lparam), phost->GetCount() - 1);
		}
		else if (HIWORD(lparam) > LOWORD(lparam))
		{
			// NT swaps the start and end value if start > end
			lparam = MAKELONG(LOWORD(lparam), HIWORD(lparam) < phost->GetCount() ? 
				HIWORD(lparam) : phost->GetCount()-1);
		}

		// Item range messages do not effect the GetAnchor() nor the _nCursor
		if (!phost->IsSingleSelection() && phost->LbSetSelection(HIWORD(lparam), 
				LOWORD(lparam), (wparam) ? LBSEL_SELECT : 0, 0, 0))
		{
#ifndef NOACCESSIBILITY
			phost->_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
			phost->_fNotifyWinEvt = TRUE;
			phost->TxNotify(phost->_dwWinEvent, NULL);
#endif		
			break;
		}

		// We only get here if error occurs or list box is a singel sel Listbox
		lres = LB_ERR;
		break;

	case LB_SETCURSEL:
		// Only single selection list box can call this!!
		if (phost->IsSingleSelection())
		{
			// -1 should return LB_ERR and turn off any selection

			// special flag indicating no items should be selected
			if (wparam == (unsigned)-1)
			{	
				// turn-off any selections
				int nCurrentCursor = phost->GetCursor();
				phost->LbSetSelection(phost->GetCursor(), phost->GetCursor(), LBSEL_RESET, 0, 0);
				phost->SetCursor(NULL, -1, phost->_fFocus);
#ifndef NOACCESSIBILITY
				if (nCurrentCursor != -1)
				{
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_nAccessibleIdx = nCurrentCursor + 1;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
					phost->_nAccessibleIdx = nCurrentCursor + 1;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
				}
#endif
			}
			else if (wparam < (unsigned)(phost->GetCount()))
			{
				if ((int)wparam == phost->GetCursor() && phost->IsSelected((int)wparam) && 
				    phost->IsItemViewable((signed)wparam) ||
					phost->LbShowIndex(wparam, FALSE) /* bug fix #5260 - need to move to selected item first */
					&& phost->LbSetSelection(wparam, wparam, LBSEL_DEFAULT, wparam, wparam))
				{
					lres = (unsigned)wparam;
#ifndef NOACCESSIBILITY
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
					break;
				}
			}
		}
		// If failed then let it fall through to the LB_ERR
		lres = LB_ERR;
		break;

	case LB_SETTOPINDEX:
		// Set the top index
		if ((!phost->GetCount() && !wparam) || phost->LbSetTopIndex(wparam) >= 0)
			break;

		// We get here if something went wrong
		lres = LB_ERR;
		break;

	case LB_SETITEMHEIGHT:
		if (!phost->LbSetItemHeight(wparam, lparam))
			lres = LB_ERR;
		break;	

	case LB_GETITEMHEIGHT:
		lres = LB_ERR;
		if ((unsigned)phost->GetCount() > wparam || wparam == 0 || wparam == (unsigned)-1)
		{
			if (phost->_fOwnerDrawVar)
			{
				if ((unsigned)phost->GetCount() > wparam)
					lres = phost->_rgData[wparam]._uHeight;
			}
			else
				lres = phost->GetItemHeight();
		}
		break;

	case LB_SETCARETINDEX:
        if (((phost->GetCursor() == -1) || (!phost->IsSingleSelection()) &&
                    (phost->GetCount() > (INT)wparam)))
        {
            /*
             * Set's the Cursor to the wParam
             * if lParam, then don't scroll if partially visible
             * else scroll into view if not fully visible
             */
            if (!phost->IsItemViewable(wparam) || lparam)
            {
                phost->LbShowIndex(wparam, FALSE);
                phost->SetCursor(NULL, wparam, TRUE);
            }
            lres = 0;            
        } 
        else        
            return LB_ERR;            
        break;

	case EM_SETTEXTEX:
		lres = LB_ERR;
		if (lparam)
			lres = phost->LbBatchInsert((WCHAR*)lparam);	
		break;

	////////////////////////Windows Messages////////////////////////////////
	case WM_VSCROLL:
		phost->OnVScroll(wparam, lparam);
		break;

	case WM_CAPTURECHANGED:
		lres = phost->OnCaptureChanged(wparam, lparam);
		if (!lres)
			break;
		goto serv;

	case WM_KILLFOCUS:
		lres = 1;
		phost->_fFocus = 0;
		phost->SetCursor(NULL, phost->GetCursor(), TRUE);	// force the removal of focus rect
		phost->InitSearch();
		phost->InitWheelDelta();
		if (phost->_fLstType == CLstBxWinHost::kCombo)
			phost->OnCBTracking(LBCBM_END, 0);	//this will internally release the mouse capture
		phost->TxNotify(LBN_KILLFOCUS, NULL);
		break;

	case WM_SETFOCUS:
		lres = 1;
		phost->_fFocus = 1;
		phost->SetCursor(NULL, (phost->GetCursor() < 0) ? -2 : phost->GetCursor(), 
			FALSE);  // force the displaying of the focus rect
		phost->TxNotify(LBN_SETFOCUS, NULL);

#ifndef NOACCESSIBILITY
		if (!phost->_fDisabled && phost->GetCursor() != -1)
		{
			phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
			phost->_fNotifyWinEvt = TRUE;
			phost->TxNotify(phost->_dwWinEvent, NULL);
		}
#endif
		break;

	case WM_SETREDRAW:
		lres = phost->OnSetRedraw(wparam);
		break;

	case WM_HSCROLL:
		phost->OnHScroll(wparam, lparam);
		break;

	case WM_SETCURSOR:
		// Only set cursor when over us rather than a child; this
		// helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
				lres = phost->OnSetCursor();
		}
		break;

	case WM_CREATE:
		lres = phost->OnCreate((CREATESTRUCT*)lparam);
		break;

    case WM_GETDLGCODE:	
		phost->_fInDialogBox = TRUE;
		lres |= DLGC_WANTARROWS | DLGC_WANTCHARS;
        break;

	////////////////////////System setting messages/////////////////////
	case WM_SETTINGCHANGE:
		phost->OnSettingChange(wparam, lparam);
		// Fall thru

	case WM_SYSCOLORCHANGE:
		phost->OnSysColorChange();
		//	Need to update the edit controls colors!!!!
		goto serv;							// Notify text services that
											//  system colors have changed

	case EM_SETPALETTE:
		// Application is setting a palette for us to use.
		phost->_hpal = (HPALETTE) wparam;

		// Invalidate the window & repaint to reflect the new palette.
		InvalidateRect(hwnd, NULL, FALSE);
		break;

	/////////////////////////Misc. Messages/////////////////////////////////
	case WM_ENABLE:
		if(!wparam ^ phost->_fDisabled)
		{
			// Stated of window changed so invalidate it so it will
			// get redrawn.
			InvalidateRect(phost->_hwnd, NULL, FALSE);
			phost->SetScrollBarsForWmEnable(wparam);
		}
		phost->_fDisabled = !wparam;				// Set disabled flag
		InvalidateRect(hwnd, NULL, FALSE);
		lres = 0;
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		goto defwndproc;
		break;

	case WM_STYLECHANGED:
		// FUTURE:
		//	We should support style changes after the control has been created
		//  to be more compatible with the system controls
		//
		// For now, we only interested in GWL_EXSTYLE Transparent mode changed.
		// This is to fix Bug 753 since Window95 is not passing us
		// the WS_EX_TRANSPARENT.
		// 
		lres = 1;
		if(GWL_EXSTYLE == wparam)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lparam;
			if(phost->IsTransparentMode() != (BOOL)(lpss->styleNew & WS_EX_TRANSPARENT))
			{
				phost->_dwExStyle = lpss->styleNew;
				((CTxtEdit *)phost->_pserv)->OnTxBackStyleChange(TRUE);

				// Return 0 to indicate we have handled this message
				lres = 0;
			}
		}
		break;

	case WM_SIZE:
		// Check if we have to recalculate the height of the listbox
		// Note if window is resized we will receive another WM_SIZE message
		// upon which the RecalcHeight will fail and we will proceed
		// normally
		if (phost->RecalcHeight(LOWORD(lparam), HIWORD(lparam)))
			break;
		phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		lres = phost->OnSize(hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));
		break;

	case WM_WINDOWPOSCHANGING:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN || phost->IsCustomLook())
			phost->OnSunkenWindowPosChanging(hwnd, (WINDOWPOS *) lparam);
		break;

	case WM_SHOWWINDOW:
		if ((phost->GetViewSize() == 0 || phost->_fLstType == CLstBxWinHost::kCombo) && wparam == 1)
		{
			// we need to do this because if we are part of a combo box
			// we won't get the size message because listbox may not be visible at time of sizing
			RECT rc;
			GetClientRect(hwnd, &rc);
			phost->_fVisible = 1;
			phost->RecalcHeight(rc.right, rc.bottom);
			
			//Since we may not get the WM_SIZE message for combo boxes we need to
			// do this in WM_SHOWWINDOW: bug fix #4080
			if (phost->_fLstType == CLstBxWinHost::kCombo)
			{
				phost->_pserv->TxSendMessage(WM_SIZE, SIZE_RESTORED, MAKELONG(rc.right, rc.bottom), NULL);
				phost->OnSize(hwnd, SIZE_RESTORED, rc.right, rc.bottom);
			}
		}

		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case LB_SETTABSTOPS:
		msg = EM_SETTABSTOPS;
		goto serv;

	case WM_ERASEBKGND:
		// We will erase the background in WM_PAINT.  For owner LB, we want
		// to check PAINTSTRUCT fErase flag before we erase the background.
		// Thus, if client (ie PPT) sub-class us and have handled the WM_ERASEBKGND,
		// we don't want to erase the background.
		lres = phost->_fOwnerDraw ? 0 : 1;
		break;

	case EM_SETPARAFORMAT:
		fRecalcHeight = TRUE;
		wparam = SPF_SETDEFAULT;
		goto serv;
		
	case EM_SETCHARFORMAT:
		fRecalcHeight = TRUE;
		wparam = SCF_ALL;	//wparam for this message should always be SCF_ALL
		goto serv;

	case EM_SETEDITSTYLE:
		lres = phost->OnSetEditStyle(wparam, lparam);
		break;

	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;

	case LB_GETHORIZONTALEXTENT:
		lres = phost->GetHorzExtent();
		break;

	case LB_SETHORIZONTALEXTENT:
		if (phost->_fHorzScroll)
		{
			LONG lHorzExtentLocal = (LONG)wparam;
			if (lHorzExtentLocal < 0)
				lHorzExtentLocal = 0;

			if (phost->GetHorzExtent() != lHorzExtentLocal)
			{
				phost->SetHorzExtent(lHorzExtentLocal);
				fRecalcHeight = TRUE;
			}
		}
		break;

	case WM_SETFONT:
		if (wparam)
			fRecalcHeight = TRUE;
		goto serv;

	case WM_SETTEXT:
		// We don't handle WM_SETTEXT, pass onto defWindowPorc to set
		// the title if this came from SetWindowText()
		Tracef(TRCSEVWARN, "Unexpected WM_SETTEXT for REListbox");
		goto defwndproc;

#ifndef NOACCESSIBILITY
	case WM_GETOBJECT:	
		IUnknown* punk;
		phost->QueryInterface(IID_IUnknown, (void**)&punk);
		Assert(punk);
		lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
		AssertSz(!FAILED((HRESULT)lres), "WM_GETOBJECT message FAILED\n");
		punk->Release();
		break;
#endif		

	default:
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		if(hr == S_FALSE)
		{			
defwndproc:
			// Message was not processed by text services so send it
			// to the default window proc.
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}
	}

	// Special border processing. The inset changes based on the size of the
	// defautl character set. So if we got a message that changes the default
	// character set, we need to update the inset.
	if (fRecalcHeight)
	{
		// need to recalculate the height of each item
		phost->ResizeInset();

		// need to resize the window to update internal window variables
		RECT rc;
		GetClientRect(phost->_hwnd, &rc);
		phost->RecalcHeight(rc.right, rc.bottom);

		if (WM_SETFONT == msg)
			phost->ResetItemColor();
	}
Exit:
	phost->Release();
	return lres;
}


//////////////// CTxtWinHost Creation/Initialization/Destruction ///////////////////////
#ifndef NOACCESSIBILITY
/*
 *	CLstBxWinHost::QueryInterface (REFIID, void)
 *
 *	@mfunc
 *		QI for IID_IAccessible
 *		
 */
HRESULT CLstBxWinHost::QueryInterface(
	REFIID riid,
	void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");

  	if(riid == IID_IAccessible)
		*ppv = (IAccessible*)this;
    else if (riid == IID_IDispatch)
		*ppv = (IDispatch*)(IAccessible*)this;
    else if (IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown*)(IAccessible*)this;
    else
        return CTxtWinHost::QueryInterface(riid, ppv);

	AddRef();
	return NOERROR;
}
#endif

/*
 *	CLstBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
LRESULT CLstBxWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnNCCreate");

#if defined DEBUG && !defined(NOPALETTE) 
	GdiSetBatchLimit(1);
#endif

	CLstBxWinHost *phost = new CLstBxWinHost();
	Assert(phost);
	if(!phost)
		return 0;

	if(!phost->Init(hwnd, pcs))					// Stores phost in associated
	{											//  window data
		Assert(FALSE);
		phost->Shutdown();
		delete phost;
		return FALSE;
	}
	return TRUE;
}

/*
 *	CLstBxWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_CREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLong())
 */
void CLstBxWinHost::OnNCDestroy(
	CLstBxWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnNCDestroy");

	CNotifyMgr *pnm = ((CTxtEdit*)(phost->_pserv))->GetNotifyMgr();

	if(pnm)
		pnm->Remove((ITxNotify *)phost);

	phost->_fShutDown = 1;
	// We need to send WM_DELETEITEM messages for owner draw list boxes
	if (phost->_fOwnerDraw && phost->_nCount)
	{
		phost->LbDeleteItemNotify(0, phost->_nCount - 1);		
	}
	if (phost->_pwszSearch)
		delete phost->_pwszSearch;

	// set the combobox's listbox hwnd pointer to null so combo box won't try 
	// to delete the window twice
	if (phost->_pcbHost)
	{
		phost->_pcbHost->_hwndList = NULL;
		phost->_pcbHost->Release();
	}
	
	phost->Shutdown();
	phost->Release();
}

/*
 *	CLstBxWinHost::CLstBxWinHost()
 *
 *	@mfunc
 *		constructor
 */
CLstBxWinHost::CLstBxWinHost() : CTxtWinHost(), _nCount(0), _fSingleSel(0), _nidxSearch(0), 
	_pwszSearch(NULL), _pcbHost(NULL)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::CTxtWinHost");
#ifndef NOACCESSIBILITY
	_dwWinEvent = 0;				// Win Event code (ACCESSIBILITY use)
	_nAccessibleIdx = -1;			// Index (ACCESSIBILITY use)
#endif
}

/*
 *	CLstBxWinHost::~CLstBxWinHost()
 *
 *	@mfunc
 *		destructor
 */
CLstBxWinHost::~CLstBxWinHost()
{
}

/*
 *	CLstBxWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CLstBxWinHost
 */
BOOL CLstBxWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs)	//@parm Corresponding CREATESTRUCT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Init");

	if(!pcs->lpszClass)
		return FALSE;
		
	// Set pointer back to CLstBxWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;
	_fHidden = TRUE;
	
	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		CHECKSTYLE(_dwStyle);
		
		//	Internally WinNT defines a LBS_COMBOBOX to determine
		//	if the list box is part of a combo box.  So we will use
		//	the same flag and value!!
		if (_dwStyle & LBS_COMBOBOX)
		{
			AssertSz(pcs->hMenu == (HMENU)CB_LISTBOXID && pcs->lpCreateParams,
				"invalid combo box parameters");
			if (pcs->hMenu != (HMENU)CB_LISTBOXID || !pcs->lpCreateParams)
				return -1;
				
			_pcbHost = (CCmbBxWinHost*) pcs->lpCreateParams;
			_pcbHost->AddRef();
			_fLstType = kCombo;
			_fSingleSel = 1;
		}
		else
		{
			//	NOTE:
			//	  The order in which we check the style flags immulate
			//	WinNT's order.  So please verify with NT order before
			//	reaaranging order.

			//	determine the type of list box
			//if (_dwStyle & LBS_NOSEL)			//Not implemented but may be in the future
			//	_fLstType = kNoSel;
			//else
			_fSingleSel = 0;
			if (_dwStyle & LBS_EXTENDEDSEL)
				_fLstType = kExtended;
			else if (_dwStyle & LBS_MULTIPLESEL)
				_fLstType = kMultiple;
			else
			{
				_fLstType = kSingle;
				_fSingleSel = 1;
			}
		}

		_fNotify = ((_dwStyle & LBS_NOTIFY) != 0);

		if (!(_dwStyle & LBS_HASSTRINGS))
		{
			_dwStyle |= LBS_HASSTRINGS;
			SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
		}


		_fDisableScroll = 0;
		if (_dwStyle & LBS_DISABLENOSCROLL)
		{
			_fDisableScroll = 1;

			// WARNING!!!
			// ES_DISABLENOSCROLL is equivalent to LBS_NODATA
			// Since we don'w support LBS_NODATA this should be 
			// fine.  But in the event we do want to support this 
			// in the future we will have to override the
			// TxGetScrollBars member function and return the 
			// proper window style

			// set the equivalent ES style
			_dwStyle |= ES_DISABLENOSCROLL;
		}			

		_fNoIntegralHeight = !!(_dwStyle & LBS_NOINTEGRALHEIGHT);
		_fOwnerDrawVar = 0;
		_fOwnerDraw = !!(_dwStyle & LBS_OWNERDRAWFIXED);
		if (_dwStyle & LBS_OWNERDRAWVARIABLE)
		{
			_fOwnerDraw = 1;
			_fOwnerDrawVar = 1;
			_fNoIntegralHeight = 1;		// Force no intergal height - following System LB
		}
		_fIntegralHeightOld = _fNoIntegralHeight;
		_fSort = !!(_dwStyle & LBS_SORT);

		_fHorzScroll = !!(_dwStyle & WS_HSCROLL);
				
		_fBorder = !!(_dwStyle & WS_BORDER);
		if(_dwExStyle & WS_EX_CLIENTEDGE)
			_fBorder = TRUE;

		// handle default disabled
		if(_dwStyle & WS_DISABLED)
			_fDisabled = TRUE;

		_fWantKBInput = !!(_dwStyle & LBS_WANTKEYBOARDINPUT);
		_fHasStrings = !!(_dwStyle & LBS_HASSTRINGS);
	}

	DWORD dwStyleSaved = _dwStyle;

	// get rid of all ES styles except ES_DISABLENOSCROLL
	_dwStyle &= (~(0x0FFFFL) | ES_DISABLENOSCROLL);

	// Create Text Services component
	if(FAILED(CreateTextServices()))
		return FALSE;

	_dwStyle = dwStyleSaved;
	_yInset = 0;
	_xInset = 0; //_xWidthSys / 2;

	// Shut-off the undo stack since listbox don't have undo's
	((CTxtEdit*)_pserv)->HandleSetUndoLimit(0);

	// Set alignment
	PARAFORMAT PF2;	
	PF2.dwMask = 0;

	if(_dwExStyle & WS_EX_RIGHT)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = PFA_RIGHT;	// right or center-aligned
	}
	
	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}

	// Tell textservices to select the entire background & disable ime for listbox
	_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EXTENDBACKCOLOR | SES_NOIME, SES_EXTENDBACKCOLOR | SES_NOIME, NULL);

	// Tell textservices to turn-on auto font sizing
	_pserv->TxSendMessage(EM_SETLANGOPTIONS, 0, IMF_AUTOFONT | IMF_AUTOFONTSIZEADJUST | IMF_UIFONTS, NULL);

	// NOTE: 
	// It is important we call this after
	// ITextServices is created because this function relies on certain
	// variable initialization to be performed on the creation by ITextServices
	// At this point the border flag is set and so is the pixels per inch
	// so we can initalize the inset.  
	_rcViewInset.left = 0;
	_rcViewInset.bottom = 0;
	_rcViewInset.right = 0;
	_rcViewInset.top = 0;
	
	_fSetRedraw = 1;

	return TRUE;
}

/*
 *	CLstBxWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CLstBxWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;

	DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
	
	// init variables
	UpdateSysColors();
	_idCtrl = (UINT)(DWORD_PTR)pcs->hMenu;
	_fKeyMaskSet = 0;
	_fMouseMaskSet = 0;
	_fScrollMaskSet = 0;
	_nAnchor = _nCursor = -1;
	_nOldCursor = -1;
	_fMouseDown = 0;
	_nTopIdx = 0;
	_cpLastGetRange = 0;
	_nIdxLastGetRange = 0;
	_fSearching = 0;
	_nyFont = _nyItem = 1;
	_fNoResize = 1;
	_stvidx = -1;
	_lHorzExtent = 0;
	InitWheelDelta();

	// Hide all scrollbars to start unless the disable scroll flag
	// is set
	if(_hwnd && !_fDisableScroll)
	{
		SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);

		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);
		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
	}
	
	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;	

	// Initially the font height is the item height	
	ResizeInset();
	Assert(_yInset == 0); // _yInset should be zero since listbox's doesn't have yinsets

	//We never want to display the selection or caret so tell textservice this
	_pserv->TxSendMessage(EM_HIDESELECTION, TRUE, FALSE, NULL);

	//Set the indents to 2 pixels like system listboxes	
	SetListIndent(2);
		
	_fNoResize = 0;
	_usIMEMode = ES_NOIME;

	CNotifyMgr *pnm = ((CTxtEdit*)_pserv)->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);

	return 0;
}

/*
 *	CLstBxWinHost::SetListIndent(int)
 *
 *	@mfunc
 *		Sets the left indent of a paragraph to the equivalent point value of nLeft, nLeft is
 *	given in device-coordinate pixels.
 *
 *	@rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::SetListIndent(
	int nLeft)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetListIndent");

	LRESULT lres;
	PARAFORMAT2 pf2;

	// tranlate the nLeft pixel value to point value
	long npt = MulDiv(nLeft, 1440, W32->GetXPerInchScreenDC());

	//format message struct
	pf2.cbSize = sizeof(PARAFORMAT2);
	pf2.dwMask = PFM_STARTINDENT;
	pf2.dxStartIndent = npt;

	// indent first line
	_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf2, &lres);

	return lres;
}

///////////////////////////////  Helper Functions  ////////////////////////////////// 
/*
 *	CLstBxWinHost::FindString(long, LPCTSTR, BOOL)
 *
 *	@mfunc
 *		This function checks a given index matches the search string
 *
 *	@rdesc
 *		BOOL = Match ? TRUE : FALSE
 */
BOOL CLstBxWinHost::FindString(
	long idx, 
	LPCTSTR szSearch, 
	BOOL bExact)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::FindString");

	Assert(_nCount);	

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;
	int cch = wcslen(szSearch);
	
	if ( (cch + 3 /* 2 paragraphs and a NULL*/) > 1024)
		psz = new WCHAR[cch + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	// format the string the way we need it
	wcscpy(psz, szSearch);
	if (bExact)
		wcscat(psz, szCR);		
	BOOL bMatch = FALSE;	
	ITextRange *pRange = NULL;
	BSTR bstrQuery = SysAllocString(psz);
	if (!bstrQuery)
		goto CleanExit;

	if (psz != sz)
		delete [] psz;
	
	// Set starting position for the search
	long cp, cp2;
	if (!GetRange(idx, idx, &pRange))
	{
		SysFreeString(bstrQuery);
		return FALSE;
	}
	
	CHECKNOERROR(pRange->GetStart(&cp));
	CHECKNOERROR(pRange->FindTextStart(bstrQuery, 0, FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC, NULL));
	CHECKNOERROR(pRange->GetStart(&cp2));
	bMatch = (cp == cp2);

CleanExit:
	if (bstrQuery)
		SysFreeString(bstrQuery);
	if (pRange)
		pRange->Release();
	return bMatch;	
}

/*
 *	CLstBxWinHost::MouseMoveHelper(int, BOOL)
 *
 *	@mfunc
 *		Helper function for the OnMouseMove function.  Performs
 *		the correct type of selection given an index to select
 *
 *	@rdesc
 *		void
 */
void CLstBxWinHost::MouseMoveHelper(
	int idx,
	BOOL bSelect)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::MouseMoveHelper");

	int ff = LBSEL_RESET | LBSEL_NEWCURSOR;
	if (bSelect)
		ff |= LBSEL_SELECT;
		
	switch (_fLstType)
	{
	case kSingle:
	case kCombo:
	case kExtended:										// perform the extended selection		
		if (LbSetSelection(_fLstType == kExtended ? _nAnchor : idx, idx, ff, idx, 0))
		{
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);

			if (_fLstType == kCombo)
			{
				_dwWinEvent = bSelect ? EVENT_OBJECT_SELECTION : EVENT_OBJECT_SELECTIONREMOVE;
				_fNotifyWinEvt = TRUE;
				TxNotify(_dwWinEvent, NULL);
			}
#endif
		}

		break;			

	case kMultiple:
		// Just change the cursor position
		SetCursor(NULL, idx, TRUE);
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_FOCUS;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
		break;	
	}
}
	
/*
 *	CLstBxWinHost::ResizeInset
 *
 *	@mfunc	Recalculates rectangle for a font change.
 *
 *	@rdesc	None.
 */
void CLstBxWinHost::ResizeInset()
{
	// Create a DC
	HDC hdc = GetDC(_hwnd);
	// Get the inset information
	LONG xAveCharWidth = 0;
	LONG yCharHeight = GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
		W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);

	ReleaseDC(_hwnd, hdc);

	// update our internal font and item height information with the new font
	if (_nyItem == _nyFont)
	{
		// We need to set the new font height before calling set item height
		// so set item height will set exact height rather than space after
		// for the default paragraph
		_nyFont = yCharHeight;
		SetItemsHeight(yCharHeight, TRUE);
	}
	else		
		_nyFont = yCharHeight;
}


/*
 *	CLstBxWinHost::RecalcHeight(int, int)
 *
 *	@mfunc
 *		Resized the height so no partial text will be displayed
 *
 *	@rdesc
 *		BOOL = window has been resized ? TRUE : FALSE
 */
BOOL CLstBxWinHost::RecalcHeight(
	int nWidth, 
	int nHeight)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::RecalcHeight");

	// NOTE: We should also exit if nWidth == 0 but PPT does some
	// sizing tests which we cause it to fail because before we
	// just exited when nWidth was 0. (bug fix #4196)
	// Check if any resizing should be done in the first place
	if (_fNoResize || !nHeight || IsIconic(_hwnd))
		return FALSE;
  	
	// get # of viewable items
	Assert(_yInset == 0);
	_nViewSize = max(1, (nHeight / max(_nyItem, 1)));
	
   	// Calculate the viewport
   	_rcViewport.left = 0;//(_fBorder) ? _xInset : 0;
   	_rcViewport.bottom = nHeight;
	_rcViewport.right = nWidth;
   	_rcViewport.top	= 0;
   	
	// bug fix don't do anything if the height is smaller then our font height
	if (nHeight <= _nyItem)
		return FALSE;

	if (_nyItem && (nHeight % _nyItem) && !_fNoIntegralHeight)
	{   	
		// we need to get the window rect before we can call SetWindowPos because
		// we have to include the scrollbar if the scrollbar is visible
		RECT rc;
		::GetWindowRect(_hwnd, &rc);

		// instead of worrying about the dimensions of the client edge and stuff we
		// figure-out the difference between the window size and the client size and add
		// that to the end of calculating the new height
		int nDiff = max(rc.bottom - rc.top - nHeight, 0);

		nHeight = (_nViewSize * _nyItem) + nDiff;
	
		// Resize the window
		SetWindowPos(_hwnd, HWND_TOP, 0, 0, rc.right - rc.left, nHeight,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSENDCHANGING);
		return TRUE;
	}
	else
	{
	    // bug fix #6011
	    // we need to force the display to update the width since it doesn't do it on
	    // WM_SIZE
	    _sWidth = nWidth;
	    _pserv->OnTxPropertyBitsChange(TXTBIT_EXTENTCHANGE, TXTBIT_EXTENTCHANGE);

        // We may need to adjust the top index if suddenly the viewsize becomes larger
        // and causes empty space to be displayed at the bottom
		int idx = GetTopIndex();
		if (!_fOwnerDrawVar)
		{
			if ((GetCount() - max(0, idx)) < _nViewSize)
				idx = GetCount() - _nViewSize;
		}
		else
		{
			// Get top index for the last page
			int iLastPageTopIdx = PageVarHeight(_nCount, FALSE);
			if (iLastPageTopIdx < idx)
				idx = iLastPageTopIdx;
		}
		//bug fix #4374
		// We need to make sure our internal state is in sync so update the top index
		// based on the new _nViewSize
		SetTopViewableItem(max(0, idx));
	}
	return FALSE;
}

/*
 *	CLstBxWinHost::ResetItemColor( )
 *
 *	@mfunc
 *		reset all the item colors when needed
 *
 */
void CLstBxWinHost::ResetItemColor()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::ResetItemColor");

	int nStart = 0;
	int nEnd = 0;

	// Don't do anything if there LB is empty or 
	// it is an owner draw LB
	if (_nCount <= 0 || _fOwnerDraw)
		return;

	BOOL bSelection = _rgData.Get(0)._fSelected;

	for (int i = 1; i < _nCount; i++)
	{
		if (_rgData.Get(i)._fSelected != (unsigned)bSelection)
		{
			// Update the colors only for selections
			if (bSelection)
				SetColors(_crSelFore, _crSelBack, nStart, nStart + nEnd);

			// Update our cache to reflect the value of our current index
			bSelection = _rgData.Get(i)._fSelected;
			nStart = i;
			nEnd = 0;
		}
		else
			nEnd++;
	}

	// there was some left over so change the color for these
	if (bSelection)
		SetColors(_crSelFore, _crSelBack, nStart, nStart + nEnd);
}

/*
 *	CLstBxWinHost::SortInsertList(WCHAR* pszDst, WCHAR* pszSrc)
 *
 *	@mfunc
 *		inserts a list of strings rather than one at a time with addstring
 *
 *	@rdesc
 *		int = amount of strings inserted;
 */
int CLstBxWinHost::SortInsertList(
	WCHAR* pszDst,
	WCHAR* pszSrc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SortInsertList");
 
	Assert(pszSrc != NULL);
	Assert(pszDst != NULL);
	const int ARRAY_DEFAULT = 256;

	//calculate the amount of strings to be inserted
	CHARSORTINFO rg[ARRAY_DEFAULT];
	int nMax = ARRAY_DEFAULT;
	int nLen = wcslen(pszSrc);
	CHARSORTINFO* prg = rg;
	memset(rg, 0, sizeof(rg));

	//insert first item in list to head or array
	prg[0].str = pszSrc;
	int i = 1;

	// go through store strings into array and replace <CR> with NULL
	WCHAR* psz = nLen + pszSrc - 1;	//start at end of list

	int nSz = 0;
	while (psz >= pszSrc)
	{		
		if (*psz == *szCR)
		{
	 		// Check if we need to allocate memory since we hit the maximum amount
	 		// allowed in array
	 		if (i == nMax)
	 		{
	 			int nSize = nMax + ARRAY_DEFAULT;
	 			CHARSORTINFO* prgTemp = new CHARSORTINFO[nSize];

	 			// Check if memory allocation failed
	 			Assert(prgTemp);
	 			if (!prgTemp)
	 			{
	 				if (prg != rg)
	 					delete [] prg;

	 				TxNotify((unsigned long)LBN_ERRSPACE, NULL);
	 				return LB_ERR;
	 			}

				// copy memory from 1 array to the next
				memcpy(prgTemp, prg, sizeof(CHARSORTINFO) * nMax);

	 			// delete any previously allocated memory
	 			if (prg != rg)
	 				delete [] prg;

				// set pointers and max to new values
	 			prg = prgTemp;
	 			nMax = nSize;
	 		}

	 		// record position of string into array
			prg[i].str = psz + 1;
			prg[i].sz = nSz;
			i++;
			nSz = 0;
		}
		else
			nSz++;

		psz--;		
	}
	prg[0].sz = nSz;	// update the size of first index since we didn't do it before

	i--; // set i to last valid index

	//now sort the array of items
	QSort(prg, 0, i);

	//create string list with the newly sorted list
	WCHAR* pszOut = pszDst;
	for (int j = 0; j <= i; j++)
	{
		memcpy(pszOut, (prg + j)->str, (prg + j)->sz * sizeof(WCHAR));
		pszOut = pszOut + (prg + j)->sz;
		*pszOut++ = L'\r';
	}
	*(--pszOut) = L'\0';

	// delete any previously allocated memory
	if (prg != rg)
		delete [] prg;

	return ++i;
} 


/*
 *	CLstBxWinHost::QSort(CHARSORTINFO rg[], int nStart, int nEnd)
 *
 *	@mfunc
 *		recursively quick sorts a given list of strings
 *
 *	@rdesc
 *		int = SHOULD ALWAYS RETURN TRUE;
 */
int CLstBxWinHost::QSort(
	CHARSORTINFO rg[],
	int nStart,
	int nEnd)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::QSort");
	
	// it's important these values are what they are since we use < and >
	Assert(CSTR_LESS_THAN == 1);
	Assert(CSTR_EQUAL == 2);
	Assert(CSTR_GREATER_THAN == 3);

	if (nStart >= nEnd)
		return TRUE;

	// for statisical efficiency lets use the item in the middle of the array for 
	// the sentinal	
	int mid = (nStart + nEnd) / 2;
	CHARSORTINFO tmp = rg[mid];
	rg[mid] = rg[nEnd];
	rg[nEnd] = tmp;


	int x = nStart;
	int y = nEnd - 1;

	WCHAR* psz = rg[nEnd].str;
	int nSz = rg[nEnd].sz;	
	for(;;)
	{	
		while ((x < nEnd) && CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, rg[x].str, rg[x].sz, 
			   psz, nSz) == CSTR_LESS_THAN)
			   x++;

		while ((y > x) && CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, rg[y].str, rg[y].sz, 
			   psz, nSz) == CSTR_GREATER_THAN)
			   y--;

		// swap elements
		if (x >= y)
			break;

		//if we got here then we need to swap the indexes
		tmp = rg[x];
		rg[x] = rg[y];
		rg[y] = tmp;

		// move to next index
		x++;
		y--;
	}
	tmp = rg[x];
	rg[x] = rg[nEnd];
	rg[nEnd] = tmp;

	QSort(rg, nStart, x - 1);
	QSort(rg, x + 1, nEnd);

	return TRUE;
}

/*
 *	CLstBxWinHost::CompareIndex(LPCTSTR, int)
 *
 *	@mfunc
 *		Recursive function which returns the insertion index of a sorted list
 *
 *	@rdesc
 *		int = position to insert string
 */
int CLstBxWinHost::CompareIndex(
	LPCTSTR szInsert, 
	int nIndex)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::CompareIndex");
	Assert(0 <= nIndex && nIndex < _nCount);
	
	// Get the string at a given index
	// compare the string verses the index
	ITextRange* pRange;
	if (!GetRange(nIndex, nIndex, &pRange))
		return -1;

	// Exclude the paragraph character at the end
	if (NOERROR != pRange->MoveEnd(tomCharacter, -1, NULL))
	{
		pRange->Release();
		return -1;
	}

	// we need to get the locale for the comparison
	// we will just use the locale of the string we want to compare with
	ITextFont* pFont;
	if (NOERROR != pRange->GetFont(&pFont))
	{
		pRange->Release();
		return -1;
	}

	BSTR bstr;
	int nRet;
	CHECKNOERROR(pRange->GetText(&bstr));
	
	if (!bstr)
		nRet = CSTR_GREATER_THAN;
	else if (!szInsert || !*szInsert)
	    nRet = CSTR_LESS_THAN;
	else
	{
		nRet = CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, szInsert, wcslen(szInsert), 
								bstr, wcslen(bstr));
 		SysFreeString(bstr);
	}
 	pFont->Release();
 	pRange->Release();
 	return nRet;

CleanExit:
 	Assert(FALSE);
 	pFont->Release();
 	pRange->Release();
 	return -1;
}

/*
 *	CLstBxWinHost::GetSortedPosition(LPCTSTR, int, int)
 *
 *	@mfunc
 *		Recursive function which returns the insertion index of a sorted list
 *
 *	@rdesc
 *		int = position to insert string
 */
int CLstBxWinHost::GetSortedPosition(
	LPCTSTR szInsert,
	int nStart,
	int nEnd)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetSortedPosition");

	Assert(nStart <= nEnd);
	
	// Start at the middle of the list
	int nBisect = (nStart + nEnd) / 2;
	int fResult = CompareIndex(szInsert, nBisect);
	if (fResult == CSTR_LESS_THAN)
	{
		if (nStart == nBisect)
			return nBisect;
		else
			return GetSortedPosition(szInsert, nStart, nBisect - 1); // [nStart, nBisect)
	}
	else if (fResult == CSTR_GREATER_THAN)
	{
		if (nEnd == nBisect)
			return nBisect + 1;
		else
			return GetSortedPosition(szInsert, nBisect + 1, nEnd);   // (nBisect, nStart]
	}
	else /*fResult == 0 (found match)*/
		return nBisect;
}

/*
 *	CLstBxWinHost::SetScrollInfo
 *
 *	@mfunc	Set scrolling information for the scroll bar.
 */
void CLstBxWinHost::SetScrollInfo(
	INT fnBar,			//@parm	Specifies scroll bar to be updated
	BOOL fRedraw)		//@parm whether redraw is necessary
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetScrollInfo");

	Assert(_pserv);

	// Set up the basic structure for the call
	SCROLLINFO si;
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_ALL;

	// Call back to the control to get the parameters	
	if(fnBar == SB_VERT)
	{
		// Bug Fix #4913
		// if the scrollbar is disabled and count is less than the view size
		// then there is nothing to do so just exit out
		BOOL fGreaterThanView;

		if (_fOwnerDrawVar)
			SumVarHeight(0, GetCount(), &fGreaterThanView);
		else
			fGreaterThanView = (GetCount() > _nViewSize);

		if (!fGreaterThanView)
		{
			if (_fDisableScroll)
			{
				// Since listboxes changes height according to its content textservice
				// might of turned-on the scrollbar during an insert string.  Make sure
				// the scrollbar is disabled
				TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
			}
			else
				TxShowScrollBar(SB_VERT, FALSE);
			return;
		}
		else
			TxEnableScrollBar(SB_VERT, _fDisabled ? ESB_DISABLE_BOTH : ESB_ENABLE_BOTH);

		RECT rc;
		TxGetClientRect(&rc);
		
		// For owner draw cases we have to set the scroll positioning
		// ourselves		
		if (_fOwnerDraw)
		{
			Assert(GetCount() >= 0);

			si.nMin = 0;
			if (!_fOwnerDrawVar)
			{
				// We don't do anything here if 
				// item height is smaller than font height 
				if (_nyItem < _nyFont)
				{
					if (!_fDisableScroll)
						TxShowScrollBar(SB_VERT, FALSE);
					return;
				}
				si.nMax = _nyItem * GetCount();
				si.nPos = _nyItem * max(GetTopIndex(), 0);
			}
			else
			{
				int iTopIdx = max(GetTopIndex(), 0);

				si.nPos = SumVarHeight(0, iTopIdx);
				si.nMax = SumVarHeight(iTopIdx, GetCount()) + si.nPos;
			}
		}
		else
			_pserv->TxGetVScroll((LONG *) &si.nMin, (LONG *) &si.nMax, 
				(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
		
		// need to take care of cases where items are partially exposed
		if (si.nMax)
		{			
			si.nPage = rc.bottom;	//our scrollbar range is based on pixels so just use the 
									//height of the window for the page size
			if (!_fOwnerDrawVar)
				si.nMax += (rc.bottom % _nyItem);

			// We need to decrement the max by one so maximum scroll pos will match
			// what the listbox should be the maximum value
			si.nMax--;
		}
	}
	else
		_pserv->TxGetHScroll((LONG *) &si.nMin, (LONG *) &si.nMax, 
			(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);

	// Do the call
	::SetScrollInfo(_hwnd, fnBar, &si, fRedraw);
}

/* 
 *	CLstBxWinHost::TxGetScrollBars (pdwScrollBar)
 *
 *	@mfunc
 *		Get Text Host's scroll bars supported.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@comm
 *		<p pdwScrollBar> is filled with a boolean combination of the 
 *		window styles related to scroll bars.  Specifically, these are:
 *
 *			WS_VSCROLL	<nl>
 *			WS_HSCROLL	<nl>
 *			ES_AUTOVSCROLL	<nl>
 *			ES_AUTOHSCROLL	<nl>
 *			ES_DISABLENOSCROLL	<nl>
 */
HRESULT CLstBxWinHost::TxGetScrollBars(
	DWORD *pdwScrollBar) 	//@parm Where to put scrollbar information
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxGetScrollBars");

	*pdwScrollBar =  _dwStyle & (WS_VSCROLL | WS_HSCROLL | ((_fDisableScroll) ?  ES_DISABLENOSCROLL : 0));
	return NOERROR;
}

/* 
 *	CLstBxWinHost::TxGetHorzExtent (plHorzExtent)
 *
 *	@mfunc
 *		Get Text Host's horizontal extent
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 */
HRESULT CLstBxWinHost::TxGetHorzExtent (
	LONG *plHorzExtent)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxGetHorzExtent");
	*plHorzExtent = _lHorzExtent;
	return S_OK;
}

/*
 *	CLstBxWinHost::TxGetEffects()
 *
 *	@mfunc
 *		Indicates if a sunken window effect should be drawn
 *
 *	@rdesc
 *		HRESULT = (_fBorder) ? TXTEFFECT_SUNKEN : TXTEFFECT_NONE
 */
TXTEFFECT CLstBxWinHost::TxGetEffects() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::TxGetEffects");

	return (_fBorder) ? TXTEFFECT_SUNKEN : TXTEFFECT_NONE;
}

/* 
 *	CLstBxWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  All listbox notifications are post-action
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		The notification events are the same as the notification
 *		messages sent to the parent window of a listbox window.
 *
 *		<LBN_DBLCLK> user double-clicks an item in teh list box
 *
 *		<LBN_ERRSPCAE> The list box cannot allocate enough memory to 
 *		fulfill a request
 *
 *		<LBN_KILLFOCUS> The list box loses the keyboard focus
 *
 *		<LBN_CANCEL> The user cancels te selection of an item in the list
 *		box
 *
 *		<LBN_SELCHANGE> The selection in a list box is about to change
 *
 *		<LBN_SETFOCUS> The list box receives the keyboard focus
 *
 */
HRESULT CLstBxWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxNotify");

	HRESULT	hr = NOERROR;
	
	// Filter-out all the messages except Listbox notification messages

	// If _fNotifyWinEvt is true, we only need to do NotifyWinEvent
	if (_fNotify && !_fNotifyWinEvt)		// Notify parent?
	{
		Assert(_hwndParent);
		switch (iNotify)
		{		
			case LBN_DBLCLK:
			case LBN_ERRSPACE:
			case LBN_KILLFOCUS:
			case LBN_SELCANCEL:
			case LBN_SELCHANGE:
			case LBN_SETFOCUS:
			case LBN_PRESCROLL:
			case LBN_POSTSCROLL:
				hr = SendMessage(_hwndParent, WM_COMMAND, 
							GET_WM_COMMAND_MPS(_idCtrl, _hwnd, iNotify));						
		}
	}

	_fNotifyWinEvt = 0;

#ifndef NOACCESSIBILITY
	DWORD	dwLocalWinEvent = _dwWinEvent;
	int		nLocalIdx = _nAccessibleIdx;
	_dwWinEvent = 0;
	if (nLocalIdx == -1)
		nLocalIdx = _nCursor+1;
	_nAccessibleIdx = -1;
	if (iNotify == LBN_SELCHANGE || dwLocalWinEvent)
		W32->NotifyWinEvent(dwLocalWinEvent ? dwLocalWinEvent : EVENT_OBJECT_SELECTION, _hwnd, _idCtrl, nLocalIdx);

#endif
	return hr;
}


/*
 *	CLstBxWinHost::TxGetPropertyBits(DWORD, DWORD *)
 *
 *	@mfunc
 *		returns the proper style.  This is a way to fool the edit 
 *		control to behave the way we want it to
 *
 *	@rdesc
 *		HRESULT = always NOERROR
 */
HRESULT CLstBxWinHost::TxGetPropertyBits(
	DWORD dwMask, 
	DWORD *pdwBits)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::TxGetPropertyBits");

	// Note: the rich edit host will never set TXTBIT_SHOWACCELERATOR or
	// TXTBIT_SAVESELECTION. Those are currently only used by forms^3 host.

	// This host is always rich text.
	*pdwBits = (TXTBIT_RICHTEXT | TXTBIT_MULTILINE | TXTBIT_HIDESELECTION | 
				TXTBIT_DISABLEDRAG | TXTBIT_USECURRENTBKG) & dwMask;

	return NOERROR;
}

/* 
 *	CLstBxWinHost::TxShowScrollBar (nBar, fShow)
 *
 *	@mfunc
 *		Shows or Hides scroll bar in Text Host window 
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CLstBxWinHost::TxShowScrollBar(
	INT  nBar,			//@parm	Specifies scroll bar(s) to be shown or hidden
	BOOL fShow)			//@parm	Specifies whether scroll bar is shown or hidden
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxShowScrollBar");

	Assert(fShow == TRUE || fShow == FALSE);

	if (SB_VERT == nBar)
	{
		// There maybe cases where the item height is smaller than the font size
		// which means the notifications from ITextServices is wrong because
		// it uses the wrong line height.  We will use the following case
		// 1a) if _nyItem >= _nyFont OR
		// 1b) if window style is LBS_DISABLESCROLL OR
		// 1c) We are showing the scrollbar w/ current count greater than viewsize OR
		// 1d) We are hiding the scrollbar w/ current count <= viewsize


		if (_fDisableScroll || !_fOwnerDrawVar && (_nyItem >= _nyFont || fShow == (GetCount() > _nViewSize)))
			return CTxtWinHost::TxShowScrollBar(nBar, fShow);

		if (_fOwnerDrawVar)
		{
			BOOL fGreaterThanView;

			SumVarHeight(0, GetCount(), &fGreaterThanView);

			if (fShow == fGreaterThanView)
				return CTxtWinHost::TxShowScrollBar(nBar, fShow);
		}
	}
	else
	{
		if (fShow)											// When showing Horz scrollbar,
			_fNoIntegralHeight = TRUE;						//	turn on _fNoIntegralHeight.
		else
			_fNoIntegralHeight = _fIntegralHeightOld;		// Reset to previous setting

		return CTxtWinHost::TxShowScrollBar(nBar, fShow);
	}

	return FALSE;
}

/* 
 *	CLstBxWinHost::TxEnableScrollBar (fuSBFlags, fuArrowflags)
 *
 *	@mfunc
 *		Enables or disables one or both scroll bar arrows 
 *		in Text Host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return 
 *		value is TRUE. If the arrows are already in the requested state or an 
 *		error occurs, the return value is FALSE. 
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.	
 */
BOOL CLstBxWinHost::TxEnableScrollBar (
	INT fuSBFlags, 		//@parm Specifies scroll bar type	
	INT fuArrowflags)	//@parm	Specifies whether and which scroll bar arrows
						//		are enabled or disabled
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxEnableScrollBar");

	// There may be cases where the item height is smaller than the font size
	// which means the notifications from ITextServices is wrong.  We have to perform
	// some manual checking for owner draw listboxes. The following cases will be valid
	// 1. If the listbox is NOT owner draw
	// 2. If the message is to disable the control
	// 3. If the count is greater than the viewsize
	if (!_fOwnerDraw || ESB_ENABLE_BOTH != fuArrowflags)
		return CTxtWinHost::TxEnableScrollBar(fuSBFlags, fuArrowflags);

	BOOL fGreaterThanView = GetCount() > _nViewSize;

	if (_fOwnerDrawVar)
		SumVarHeight(0, GetCount(), &fGreaterThanView);

	if (fGreaterThanView)
		return CTxtWinHost::TxEnableScrollBar(fuSBFlags, fuArrowflags);

	return FALSE;
}


/*
 *	CLstBxWinHost::SetItemsHeight(int, BOOL)
 *
 *	@mfunc
 *		Sets the items height for all items
 *
 *	@rdesc
 *		int = number of paragraphs whose fontsize has been changed
 */
int CLstBxWinHost::SetItemsHeight(
	int nHeight,
	BOOL bUseExact)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetItemsHeight");

	if (_fOwnerDrawVar)
		return 1;

	// Calculate the new size in points
	long nptNew = MulDiv(nHeight, 1440, W32->GetYPerInchScreenDC());
	long nptMin = MulDiv(_nyFont, 1440, W32->GetYPerInchScreenDC());

	// NOTE:
	// This diverges from what the system list box does but there isn't a way
	// to set the height of a item to smaller than what the richedit will allow and
	// is not ownerdraw.  If it is owner draw make sure our height is not zero
	if (((nptNew < nptMin && !_fOwnerDraw) || nHeight <= 0) && !bUseExact)
		nptNew = nptMin;

	// Start setting the new height
	Freeze();
	long nPt;
	PARAFORMAT2 pf2;
	pf2.cbSize = sizeof(PARAFORMAT2);

	if (bUseExact)
	{
		pf2.dwMask = PFM_LINESPACING;
		pf2.bLineSpacingRule = 4;
		pf2.dyLineSpacing = nPt = nptNew;
	}
	else
	{		
		pf2.dwMask = PFM_SPACEAFTER;
		pf2.dySpaceAfter = max(nptNew - nptMin, 0);
		nPt = pf2.dySpaceAfter + nptMin;
	}

	// Set the default paragraph format
	LRESULT lr;
	_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (WPARAM)&pf2, &lr);

	// set the item height
	if (lr)
		_nyItem = (_fOwnerDraw && nHeight > 0) ? nHeight : 
					MulDiv(nPt, W32->GetYPerInchScreenDC(), 1440);

	Unfreeze();
	return lr;
}

/*
 *	CLstBxWinHost::UpdateSysColors()
 *
 *	@mfunc
 *		update the system colors in the event they changed or for initialization
 *		purposes
 *
 *	@rdesc
 *		<none>
 */
void CLstBxWinHost::UpdateSysColors()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::UpdateSysColors");

	// Update the system colors
	_crDefBack = ::GetSysColor(COLOR_WINDOW);
	_crSelBack = ::GetSysColor(COLOR_HIGHLIGHT);
	_crDefFore = ::GetSysColor(COLOR_WINDOWTEXT);
	_crSelFore = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
}

/*
 *	CLstBxWinHost::SetCursor(HDC, int, BOOL)
 *
 *	@mfunc
 *		Sets the cursor position, if it's valid and draws the focus rectangle if
 *		the control has focus.  The BOOL is used to determine if the previous
 *		cursor drawing needs to be removed
 *
 *	@rdesc
 *		<none>
 */
void CLstBxWinHost::SetCursor(
	HDC hdc,
	int idx,
	BOOL bErase)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetCursor");

	Assert(idx >= -2 && idx < _nCount);

	// Get the hdc if it wasn't passed in
	BOOL bReleaseDC = (hdc == NULL);
	if (bReleaseDC)
 		hdc = TxGetDC();
	Assert(hdc);

	RECT rc;
	// don't draw outside the client rect draw the rectangle
	TxGetClientRect(&rc);
	IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

	// Check if we have to remove the previous position
	if ((idx != _nCursor && _fFocus && idx >= -1) || bErase)
	{
		if (LbEnableDraw())
		{
 			if (_fOwnerDraw)
 				LbDrawItemNotify(hdc, _nCursor, ODA_FOCUS, (IsSelected(max(_nCursor, 0)) ? ODS_SELECTED : 0));
 			else if (IsItemViewable(max(0, _nCursor)))
			{
	 			LbGetItemRect(max(_nCursor, 0), &rc);
	 			::DrawFocusRect(hdc, &rc);
			}
		}
	}

	// special flag meaning to set the cursor to the top index
	// if there are items in the listbox
	if (idx == -2)
	{
		if (GetCount())
		{
			idx = max(_nCursor, 0);
			if (!IsItemViewable(idx))
				idx = GetTopIndex();
		}
		else
			idx = -1;
	}

	_nCursor = idx;

	// Only draw the focus rect if the cursor item is
	// visible in the list box
	if (_fFocus && LbEnableDraw())
	{
		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, max(0, _nCursor), ODA_FOCUS, ODS_FOCUS | (IsSelected(max(0, _nCursor)) ? ODS_SELECTED : 0));
 		else if (IsItemViewable(max(0, idx)))
		{
			// Now draw the rectangle
	 		LbGetItemRect(max(0,_nCursor), &rc);
	 		::DrawFocusRect(hdc, &rc);
		}
	}

	if (bReleaseDC)
 		TxReleaseDC(hdc);
}

/*
 *	CLstBxWinHost::InitSearch()
 *
 *	@mfunc
 *		Sets the array to its initial state
 *
 *	@rdesc
 *		<none>
 */
void CLstBxWinHost::InitSearch()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InitSearch");

	_fSearching = 0;
	_nidxSearch = 0;
	if (_pwszSearch)
 		*_pwszSearch = 0;
}
 
/*
 *	CLstBxWinHost::PointInRect(const POINT*)
 *
 *	@mfunc
 *		Determines if the given point is inside the listbox windows rect
 *		The point parameter should be in client coordinates.
 *
 *	@rdesc
 *		BOOL = inside listbox window rectangle ? TRUE : FALSE
 */
BOOL CLstBxWinHost::PointInRect(
	const POINT * ppt)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::PointInRect");
	Assert(ppt);

	RECT rc;
	::GetClientRect(_hwnd, &rc);
	return PtInRect(&rc, *ppt);
}

/*
 *	CLstBxWinHost::GetItemFromPoint(POINT*)
 *
 *	@mfunc
 *		Retrieves the nearest viewable item from a passed in point.
 *		The point should be in client coordinates.
 *
 *	@rdesc
 *		int = item which is closest to the given in point, -1 if there 
 *			  are no items in the list box
 */
int CLstBxWinHost::GetItemFromPoint(
	const POINT * ppt)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetItemFromPoint");

	// perform error checking first
	if (_nCount == 0)
		return -1;

	int y = (signed short)ppt->y;

	// make sure y is in a valid range
	if (y < _rcViewport.top)
 		y = 0;
	else if (y > _rcViewport.bottom)
 		y = _rcViewport.bottom - 1;

	//need to factor in the possibility an item may not fit entirely into the window view

	int idx;

	if (_fOwnerDrawVar)
	{
		int iHeightCurrent = 0;
		int iHeight;

		for (idx = GetTopIndex(); idx < _nCount; idx++)
		{
			iHeight = iHeightCurrent + _rgData[idx]._uHeight;
			if (iHeightCurrent <= y && y <= iHeight)
				break;		// Found it

			iHeightCurrent = iHeight;
		}
	}
	else
	{
		Assert(_nyItem);
		idx = GetTopIndex() + (int)(max(0,(y - 1)) / max(1,_nyItem));
	}

	Assert(IsItemViewable(idx));
	return (idx < _nCount ? idx : _nCount - 1);
}
 
/*
 *	CLstBxWinHost::ResetContent()
 *
 *	@mfunc
 *		Deselects all the items in the list box
 *
 *	@rdesc
 *		BOOL = If everything went fine ? TRUE : FALSE
 */
BOOL CLstBxWinHost::ResetContent()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::ResetContent");

	Assert(_fOwnerDraw == 0);

	// lets try to be smart about reseting the colors by only select a range
	// from the first selection found to the last selection found

	int nStart = _nCount - 1;
	int nEnd = -1;
	for (int i = 0; i < _nCount; i++)
	{
		if (_rgData[i]._fSelected)
		{
			_rgData[i]._fSelected = 0;

			if (nStart > i)
				nStart = i;
			if (nEnd < i)
				nEnd = i;
		}
	}

	Assert(nStart <= nEnd || ((nStart == _nCount - 1) && (nEnd == -1)));
	if (nStart > nEnd)
		return TRUE;

	return (_nCount > 0) ? SetColors((unsigned)tomAutoColor, (unsigned)tomAutoColor, nStart, nEnd) : FALSE;
}
 
/*
 *	CLstBxWinHost::GetString(long, PWCHAR)
 *
 *	@mfunc
 *		Retrieve the string at the requested index.  PWSTR can be null
 *		if only the text length is requires
 *
 *	@rdesc
 *		long = successful ? length of string : -1
 */
long CLstBxWinHost::GetString(
	long nIdx, 
	PWCHAR szOut)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetString");

	Assert(0 <= nIdx && nIdx < _nCount);
	if (nIdx < 0 || _nCount <= nIdx)
 		return -1;

	long l = -1;
	long lStart;
	long lEnd;
	ITextRange* pRange;
	BSTR bstr;
	if (!GetRange(nIdx, nIdx, &pRange))
 		return -1;
 		
	// Need to move one character to the left to unselect the paragraph marker.
	Assert(pRange);
	CHECKNOERROR(pRange->MoveEnd(tomCharacter, -1, &lEnd));
	CHECKNOERROR(pRange->GetStart(&lStart));
	CHECKNOERROR(pRange->GetEnd(&lEnd));

	// Get the string
	if (szOut)
	{
		if (_dwStyle & LBS_HASSTRINGS)
		{
			CHECKNOERROR(pRange->GetText(&bstr));
			if (bstr)
			{
				wcscpy(szOut, bstr);
				SysFreeString(bstr);
			}
			else
				wcscpy(szOut, L"");	// we got an empty string!
		}
		else
			(*(LPARAM *)szOut) = GetData(nIdx);
	}
	l = lEnd - lStart;

CleanExit:
	pRange->Release();
	return l;
}
 
/*
 *	CLstBxWinHost::InsertString(long, LPCTSTR)
 *
 *	@mfunc
 *		Insert the string at the requested location.  If the
 *		requested index is larger than _nCount then the function
 *		will fail.  The string is inserted with CR appended to
 *		to the front and back of the string
 *
 *	@rdesc
 *		BOOL = successfully inserted ? TRUE : FALSE
 */
BOOL CLstBxWinHost::InsertString(
	long nIdx,
	LPCTSTR szInsert)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InsertString");

	Assert(szInsert);
	Assert(0 <= nIdx && nIdx <= _nCount);

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;

	if ( (wcslen(szInsert) + 3 /* 2 paragraphs and a NULL*/) > 1024)
		psz = new WCHAR[wcslen(szInsert) + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	*psz = NULL;
	if (nIdx == _nCount && _nCount)
		wcscpy(psz, szCR);

	// copy string and add <CR> at the end
	wcscat(psz, szInsert);

	// don't add the carriage return if the entry point is the end
	if (nIdx < _nCount)
		wcscat(psz, szCR);			

	BOOL bRet = FALSE;
	ITextRange * pRange = NULL;
	int fFocus = _fFocus;
	long idx = nIdx;
	BSTR bstr = SysAllocString(psz);
	if (!bstr)
		goto CleanExit;
	Assert(bstr);

	if (psz != sz)
		delete [] psz;

	// Set the range to the point where we want to insert the string 	

	// make sure the requested range is a valid one
	if (nIdx == _nCount)
		idx = max(idx - 1, 0);

	if (!GetRange(idx, idx, &pRange))
	{
 		SysFreeString(bstr);
 		return FALSE;
	}

	// Collapse the range to the start if insertion is in the middle or top
	// of list, collapse range to the end if we are inserting at the end of the list
	CHECKNOERROR(pRange->Collapse((idx == nIdx)));

	// Need to assume the item was successfully added because during SetText TxEnable(show)Scrollbar
	// gets called which looks at the count to determine if we should display the scroll bar
	_nCount++;

	//bug fix #5411
	// Check if we have focus, if so we need to remove the focus rect first and update the cursor positions	
	_fFocus = 0;
	SetCursor(NULL, (idx > GetCursor() || GetCursor() < 0) ? GetCursor() : GetCursor() + 1, fFocus);
	_fFocus = fFocus;


	//For fix height cases where the item height is less than the font we need to manually
	//enable the scrollbar if we need the scrollbar and the scrollbar is disabled.
	BOOL fSetupScrollBar;
	fSetupScrollBar = FALSE;
	if (!_fOwnerDrawVar && _nCount - 1 == _nViewSize &&
		((_nyItem < _nyFont && _fDisableScroll) || _fOwnerDraw))
	{
		fSetupScrollBar = TRUE;
		TxEnableScrollBar(SB_VERT, _fDisabled ? ESB_DISABLE_BOTH : ESB_ENABLE_BOTH);
	}

#ifdef _DEBUG
	if (bstr && wcslen(bstr))
		Assert(FALSE);
#endif

	if (NOERROR != (pRange->SetText(bstr)))
	{
		// NOTE: SetText could return S_FALSE which means it has added some characters but not all.
		// We do want to clean up the text in such case.
		pRange->SetText(NULL);		// Cleanup text that may have been added.
		_nCount--;
		
		//Unsuccessful in adding the string so disable the scrollbar if we enabled it
		if (fSetupScrollBar)
			TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
			
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		goto CleanExit;
	} 

	//We need to update the top index after a string is inserted
	if (idx < GetTopIndex())
		_nTopIdx++;
		
	bRet = TRUE;

CleanExit:
	if (bstr)
 		SysFreeString(bstr);
	if (pRange)
 		pRange->Release();
	return bRet;
}

/*
 *	BOOL CLstBxWinHost::RemoveString(long, long)
 *
 *	@mfunc
 *		Prevents TOM from drawing
 *
 *	@rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::RemoveString(
	long nStart,
	long nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::RemoveString");

	Assert(nStart <= nEnd);
	Assert(nStart < _nCount && nEnd < _nCount);

	// Remove item from richedit
	Freeze();
	ITextRange* pRange;
	if (!GetRange(nStart, nEnd, &pRange))
	{
		Unfreeze();
		return FALSE;
	}
	long l;
	
	// Since we can't erase the last paragraph marker we will erase
	// the paragraph marker before the item if it's not the first item
	HRESULT hr;
	if (nStart != 0)
	{
		hr = pRange->MoveStart(tomCharacter, -1, &l);
		Assert(hr == NOERROR);
		hr = pRange->MoveEnd(tomCharacter, -1, &l);
		Assert(hr == NOERROR);
	}

	if (NOERROR != pRange->Delete(tomCharacter, 0, &l) && _nCount > 1)
	{
		Unfreeze();
		pRange->Release();
		return FALSE;
	}
	pRange->Release();
	int nOldCt = _nCount;
	_nCount -= (nEnd - nStart) + 1;

	// Because we delete the paragraph preceeding the item
	// rather than following the item we need to update 
	// the paragraph which followed the item. bug fix #4074	
	long nFmtPara = max(nStart -1, 0);
	if (!_fOwnerDraw && (IsSelected(nEnd) != IsSelected(nFmtPara) || _nCount == 0))
	{		
		DWORD dwFore = (unsigned)tomAutoColor;
		DWORD dwBack = (unsigned)tomAutoColor;		
		if (IsSelected(nFmtPara) && _nCount)
		{
			dwFore = _crSelFore;
			dwBack = _crSelBack;		
		}
		SetColors(dwFore, dwBack, nFmtPara, nFmtPara);
	}

	// update our internal listbox records	
	int j = nEnd + 1;
	for(int i = nStart; j < nOldCt; i++, j++)
	{
		_rgData[i]._fSelected = _rgData.Get(j)._fSelected;
		_rgData[i]._lparamData = _rgData.Get(j)._lparamData;
		_rgData[i]._uHeight = _rgData.Get(j)._uHeight;
	}

	//bug fix #5397 
	//we need to reset the internal array containing information
	//about previous items
	while (--j >= _nCount)
	{
		_rgData[j]._fSelected = 0;
		_rgData[j]._lparamData = 0;
		_rgData[i]._uHeight = 0;
	}
		
	if (_nCount > 0)
	{
		// update the cursor			
		if (nStart <= _nCursor)
			_nCursor--;
		_nCursor = min(_nCursor, _nCount - 1);

		if (_fLstType == kExtended)
		{
			if (_nCursor < 0)
			{
				_nOldCursor = min(_nAnchor, _nCount - 1);
				_nAnchor = -1;
			}
			else if (_nAnchor >= 0)
			{
				if (nStart <= _nAnchor && _nAnchor <= nEnd)
				{
					// Store the old anchor for future use
					_nOldCursor = min(_nAnchor, _nCount - 1);
					_nAnchor = -1;
				}
			}
		}

		if (_fOwnerDraw)
		{
			RECT rcStart;
			RECT rcEnd;
			LbGetItemRect(nStart, &rcStart);
			LbGetItemRect(nEnd, &rcEnd);
			rcStart.bottom = rcEnd.bottom;
			if (IntersectRect(&rcStart, &rcStart, &_rcViewport))
			{
				// the list will get bumped up so we need to redraw
				// everything from the top to the bottom
				rcStart.bottom = _rcViewport.bottom;
				::InvalidateRect(_hwnd, &rcStart, FALSE);
			}
		}
	}
	else
	{
		SetTopViewableItem(0);
		_nAnchor = -1;
		_nCursor = -1;
	}

	//For fix height cases where the item height is less than the font we need to manually
	//enable the scrollbar if we need the scrollbar and the scrollbar is disabled.
	if (!_fOwnerDrawVar)
	{
		if ((_nyItem < _nyFont) && (_fDisableScroll) && 
			(_nCount <= _nViewSize) && (nOldCt > _nViewSize))
			TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
	}

	LbDeleteItemNotify(nStart, nEnd);
	Assert(GetTopIndex() >= 0);
	if (_nCount)
		LbShowIndex(min(GetTopIndex(), _nCount - 1), FALSE);
	Unfreeze();
	return TRUE;
}
 
/*
 *	CLstBxWinHost::Freeze()
 *
 *	@mfunc
 *		Prevents TOM from drawing
 *
 *	@rdesc
 *		freeze count
 */
long CLstBxWinHost::Freeze()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Freeze");
	long l;
	((CTxtEdit*)_pserv)->Freeze(&l);

	return l;
}

/*
 *	inline CLstBxWinHost::FreezeCount()
 *
 *	@mfunc
 *		Returns the current freeze count
 *
 *	@rdesc
 *		<none>
 */
short CLstBxWinHost::FreezeCount() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetFreezeCount");
	return ((CTxtEdit*)_pserv)->GetFreezeCount();
}

/*
 *	CLstBxWinHost::Unfreeze(long *)
 *
 *	@mfunc
 *		Allows TOM to update itself
 *
 *	@rdesc
 *		freeze count
 */
long CLstBxWinHost::Unfreeze()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Unfreeze");
	long l;
	((CTxtEdit*)_pserv)->Unfreeze(&l);

    // HACK ALERT!
    // When ITextRange::ScrollIntoView starts caching the scroll position
    // in cases where the display is frozen the following code can be removed
    
    // We could have failed in ITextRange::ScrollIntoView
    // Check if we did and try calling it again
	if (!l && _stvidx >= 0)
	{
	    ScrollToView(_stvidx);
	    _stvidx = -1;
	}

	return l;
}

/*
 *	CLstBxWinHost::ScrollToView(long)
 *
 *	@mfunc
 *		Sets the given index to be at the top of 
 *		the viewable window space
 *
 *	@rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::ScrollToView(
	long nTop)
{
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetTopViewableItem");

	//Get the range which contains the item desired
	BOOL bVal = FALSE;
	ITextRange* pRange = NULL;
	
	if (!GetRange(nTop, nTop, &pRange))
	    return bVal;
    Assert(pRange);	 

    CHECKNOERROR(pRange->Collapse(1));
	CHECKNOERROR(pRange->ScrollIntoView(tomStart + /* TA_STARTOFLINE */ 32768));
	bVal = TRUE;

CleanExit:
	pRange->Release();

    // HACK ALERT!
    // When ITextRange::ScrollIntoView starts caching the scroll position
    // in cases where the display is frozen the following code can be removed
    
	//if we failed record the index we failed to scroll to	
	if (!bVal && FreezeCount())
	    _stvidx = nTop;
	return bVal;	
}

/*
 *	CLstBxWinHost::SetTopViewableItem(long)
 *
 *	@mfunc
 *		Sets the given index to be at the top of 
 *		the viewable window space
 *
 *	@rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::SetTopViewableItem(
	long nTop)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetTopViewableItem");

	// if we don't have any items in the list box then just set the topindex to 
	// zero
	if (_nCount == 0)
	{
		Assert(nTop == 0);
		_nTopIdx = 0;
		return TRUE;
	}

	// don't do anything if the requested top index is greater
	// then the amount of items in the list box
	Assert(nTop < _nCount);
	if (nTop >= _nCount)
 		return FALSE;

	// Don't do this if it's ownerdraw
	if (!_fOwnerDraw)
	{
		// Since we erase and draw the focus rect here
		// cache the focus rect info and don't bother with the
		// focus rect stuff until later
		int fFocus = _fFocus;
		_fFocus = 0;
		if (fFocus && IsItemViewable(GetCursor()))
			SetCursor(NULL, GetCursor(), TRUE);
		
		//Get the range which contains the item desired
		long nOldIdx = _nTopIdx;
		_nTopIdx = nTop;
		if (!ScrollToView(nTop))
		{
			// HACK ALERT!
			// When ITextRange::ScrollIntoView starts caching the scroll position
			// in cases where the display is frozen the following code can be removed            
			if (_stvidx >= 0)
				return TRUE;

			// Something went wrong and we weren't able to display the index requested
			// reset top index
			_nTopIdx = nOldIdx;		
		}

		// Note:
		//	If the cursor was not viewable then we don't attempt
		// to display the focus rect because we never erased it 
		_fFocus = fFocus;
		if (_fFocus & IsItemViewable(GetCursor()))
		{
			// Now we need to redraw the focus rect which we erased
			SetCursor(NULL, GetCursor(), FALSE);
		}
	}
	else
	{				
		int dy = (_nTopIdx - nTop) * _nyItem;

		if (_fOwnerDrawVar)
		{
			if (_nTopIdx > nTop)
				dy = SumVarHeight(nTop, _nTopIdx);
			else
				dy = -SumVarHeight(_nTopIdx, nTop);
		}

		RECT rc;
		TxGetClientRect(&rc);
		_nTopIdx = nTop;
		_fSetScroll = 0;
		if (_fSetRedraw)
		{
			if (((CTxtEdit *)_pserv)->_fLBScrollNotify)
				TxNotify(LBN_PRESCROLL, NULL);

			TxScrollWindowEx(0, dy, NULL, &rc, NULL, NULL, 
					SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN);
			if (((CTxtEdit *)_pserv)->_fLBScrollNotify)
				TxNotify(LBN_POSTSCROLL, NULL);

			if (_dwStyle & WS_VSCROLL)
				SetScrollInfo(SB_VERT, TRUE); // we update the scrollbar manually if we are in ownerdraw mode
			UpdateWindow(_hwnd);
		}
		else
			_fSetScroll = 1;
	}
		
	return TRUE;
}
 
/*
 *	CLstBxWinHost::GetRange(long, long, ITextRange**)
 *
 *	@mfunc
 *		Sets the range given the top and bottom index
 *		by storing the range into ITextRange
 *
 *	@rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::GetRange(
	long nTop,
	long nBottom,
	ITextRange** ppRange)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetRange");

	// do some error checking
	if (nTop < 0 || nTop > _nCount || nBottom < 0 || nBottom > _nCount)
		return FALSE;

	Assert(ppRange);
	if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, ppRange))
	{
		Assert(FALSE);
		return FALSE;
	}
	Assert(*ppRange);

	if (_nIdxLastGetRange && nTop >= _nIdxLastGetRange)
	{
		long Count;
		CHECKNOERROR((*ppRange)->SetRange(_cpLastGetRange, _cpLastGetRange));
		if (nTop > _nIdxLastGetRange)
			CHECKNOERROR((*ppRange)->Move(tomParagraph, nTop - _nIdxLastGetRange, &Count));
		CHECKNOERROR((*ppRange)->MoveEnd(tomParagraph, 1, &Count));
	}
	else
	{
		CHECKNOERROR((*ppRange)->SetIndex(tomParagraph, nTop + 1, 1));
	}

	if (nBottom > nTop)
	{
		long l;
		CHECKNOERROR((*ppRange)->MoveEnd(tomParagraph, nBottom - nTop, &l));
	}

	if (nTop)
	{
		_nIdxLastGetRange = nTop;
		CHECKNOERROR((*ppRange)->GetStart(&_cpLastGetRange));
	}

	return TRUE;
CleanExit:
	Assert(FALSE);
	(*ppRange)->Release();
	*ppRange = NULL;
	_nIdxLastGetRange = 0;
	_cpLastGetRange = 0;
	return FALSE;
}

/*
 *	CLstBxWinHost::SetColors(DWORD, DWORD, long, long)
 *
 *	@mfunc
 *		Sets the background color for the givin range of paragraphs.  This
 *		only operates in terms of paragraphs.
 *
 *	@rdesc
 *		BOOL = if function succeeded in changing different color
 */
BOOL CLstBxWinHost::SetColors(
	DWORD dwFgColor,
	DWORD dwBgColor,
	long nParaStart,
	long nParaEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetColors");

	Assert(_fOwnerDraw == 0);
	
	//Get the range of the index
	ITextRange* pRange;
	if (!GetRange(nParaStart, nParaEnd, &pRange))
		return FALSE;

	BOOL bRet = FALSE;	
	ITextFont* pFont;

	// Set the background and forground color
	if (NOERROR != pRange->GetFont(&pFont))
	{
		pRange->Release();
		return FALSE;
	}	

	Assert(pFont);
	CHECKNOERROR(pFont->SetBackColor(dwBgColor));
	CHECKNOERROR(pFont->SetForeColor(dwFgColor));

	bRet = TRUE;
CleanExit:
	// Release pointers
	pFont->Release();
	pRange->Release();
	return bRet;

}

/////////////////////////////  Message Map Functions  ////////////////////////////////
/*
 *	void CLstBxWinHost::OnSetCursor()
 *
 *	@mfunc
 *		Handles the WM_SETCURSOR message.
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnSetCursor()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSetCursor");

	// Just make sure the cursor is an arrow if it's over us
	TxSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
	return 1;
}

/*
 *	void CLstBxWinHost::OnSetRedraw(WAPRAM)
 *
 *	@mfunc
 *		Handles the WM_SETREDRAW message.
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnSetRedraw(
	WPARAM wparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSetRedraw");

	long lCount = 0;
	BOOL fSetRedraw = (wparam == TRUE);

	if (fSetRedraw != (BOOL)_fSetRedraw)
	{
		_fSetRedraw = fSetRedraw;

		if (fSetRedraw)
			lCount = Unfreeze();	// Turn on display
		else
			lCount = Freeze();		// Turn off display
	}

	if (fSetRedraw && lCount == 0)
	{
		if (_fSetScroll)
		{
			_fSetScroll = 0;
			if (_dwStyle & WS_VSCROLL)
				SetScrollInfo(SB_VERT, TRUE);
		}
		OnSunkenWindowPosChanging(_hwnd, NULL);		// Erase frame/scrollbars as well
	}

	return 1;
}

/*
 *	void CLstBxWinHost::OnSysColorChange()
 *
 *	@mfunc
 *		Handles the WM_SYSCOLORCHANGE message.
 *
 */
void CLstBxWinHost::OnSysColorChange()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSysColorChange");

	if (!_fOwnerDraw)
	{
		// set the new colors
 		COLORREF crDefBack = _crDefBack;
 		COLORREF crDefFore = _crDefFore;
 		COLORREF crSelBack = _crSelBack;
 		COLORREF crSelFore = _crSelFore;
 		
 		// update colors
 		UpdateSysColors();

		// optimization check; don't do anything if there are no elements
		if (_nCount <= 0)
			return;

		// Only update the list box if colors changed
		if (crDefBack != _crDefBack || crDefFore != _crDefFore ||
	 		crSelBack != _crSelBack || crSelFore != _crSelFore)
		{
	 		//Bug fix #4847
	 		// notify parent first
 			CTxtWinHost::OnSysColorChange();
 			
			ResetItemColor();
		}
	}
}

/*
 *	CLstBxWinHost::OnSettingChange()
 *
 *	@mfunc
 *		forwards the WM_SETTINGCHANGE message to RECombobox
 *
 */
void CLstBxWinHost::OnSettingChange(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSettingChange");

	if (_pcbHost)
		SendMessage(_hwndParent, WM_SETTINGCHANGE, wparam, lparam); // Forward this message to cb host
}

/*
 *	LRESULT CLstBxWinHost::OnChar(WORD, DWORD)
 *
 *	@mfunc
 *		Handles the WM_CHAR message.
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnChar(
	WORD vKey,
	DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnChar");

	// don't do anything if list box is empty or in the middle of
	// a mouse down
	if (_fMouseDown || _nCount == 0)
 		return 0;

	BOOL fControl = (GetKeyState(VK_CONTROL) < 0);

	int nSel = -1;
	int nRes;

	if (_fWantKBInput && _fOwnerDraw && !_fHasStrings)
	{
		nRes = SendMessage(_hwndParent, WM_CHARTOITEM, MAKELONG(vKey, _nCursor), (LPARAM)_hwnd);

		if (nRes < 0)
			return 1;

		goto SELECT_SEL;
	}

	switch (vKey)
	{
	case VK_ESCAPE:
 		InitSearch();
 		return 0;
 		
	case VK_BACK:
 		if (_pwszSearch && _nidxSearch)
 		{
 			if (_nidxSearch > 0)
 				_nidxSearch--;
 			_pwszSearch[_nidxSearch] = NULL;
 			break;	// we break out of case because we still want to perform the search
 		}
 		return 0;		

	case VK_SPACE:
 		if (_fLstType == kMultiple)
 			return 0;
 		/* Fall through case */
 		
	default:
 		// convert CTRL+char to char
 		if (fControl && vKey < 0x20)
 			vKey += 0x40;

		// don't go beyond the search array size
 		if (_nidxSearch >= LBSEARCH_MAXSIZE)
 		{
 			((CTxtEdit*)_pserv)->Beep();
 			return 0;
 		}

		// allocate string if not already allocated
		if (_pwszSearch == NULL)
			_pwszSearch = new WCHAR[LBSEARCH_MAXSIZE];

		// error checking
		if (_pwszSearch == NULL)
		{
			((CTxtEdit*)_pserv)->Beep();
			Assert(FALSE && "Unable to allocate search string");
			return 0;
		}		

		// put the input character into string array
 		_pwszSearch[_nidxSearch++] = (WCHAR)vKey;
 		_pwszSearch[_nidxSearch] = NULL;
	}

	if (_fSort)
	{		
		nSel = (_fSearching) ? _nCursor + 1 : 0;

		// Start the search for a string
 		TxSetTimer(ID_LB_SEARCH, ID_LB_SEARCH_DEFAULT);
		_fSearching = 1;
	}
	else
	{
		_nidxSearch = 0;
		nSel = _nCursor + 1;
	}

	// Make sure our index isn't more than the items we have
	if (nSel >= _nCount)
		nSel = 0;

	nRes = LbFindString(nSel, _pwszSearch, FALSE);
	if (nRes < 0)
	{
		if (_pwszSearch)
		{
			if (_nidxSearch > 0)
				_nidxSearch--;
			if (_nidxSearch == 1 && _pwszSearch[0] == _pwszSearch[1])
			{
				_pwszSearch[1] = NULL;
				nRes = LbFindString(nSel, _pwszSearch, FALSE);
			}
		}
	}

SELECT_SEL:
	// If a matching string is found then select it
	if (nRes >= 0)
		OnKeyDown(nRes, 0, 1);

	//	If Hi-Ansi need to send a wm_syskeyup message to ITextServices to 
	// stabalize the state
	if (0x80 <= vKey && vKey <= 0xFF && !HIWORD(GetKeyState(VK_MENU)))
	{
		LRESULT lres;
		_pserv->TxSendMessage(WM_SYSKEYUP, VK_MENU, 0xC0000000, &lres);
	}	

	return 0;
}

 
/*
 *	LRESULT CLstBxWinHost::OnKeyDown(WPARAM, LPARAM, INT)
 *
 *	@mfunc
 *		Handles the WM_KEYDOWN message.  The BOOL ff is used as a flag for calls
 *	made internally and not responsive to the WM_KEYDOWN message.  Since this
 *	function is used for other things, ie helper to dealing with the WM_CHAR message.
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnKeyDown(
	WPARAM vKey,
	LPARAM lparam,
	int ff)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnKeyDown");

	// Ignore keyboard input if we are in the middle of a mouse down deal or
	// if there are no items in the listbox. Note that we let F4's go
	// through for combo boxes so that the use can pop up and down empty
	// combo boxes.
	if (_fMouseDown || (_nCount == 0 && vKey != VK_F4))
 		return 1;

	// Check if the shift key is down for Extended listbox style only
	int ffShift = 0;
	if (_fLstType == kExtended)
 		ffShift = HIWORD(GetKeyState(VK_SHIFT));

	// Special case!
	// Check if this function is called as a helper
	int nSel = (ff) ? vKey : -1;

	TxKillTimer(ID_LB_CAPTURE);

	if (_fWantKBInput && ff == 0)	// Need to notify the parent the key was pressed
		nSel = SendMessage(_hwndParent, WM_VKEYTOITEM, MAKELONG(vKey, _nCursor), (LPARAM)_hwnd);

	// if the parent returns -2 then we don't do anything and immediately exit out
	// if the parent returns >=0 then we just jump to that index
	// else we just continue with the default procedure.	
	if (nSel == -2)
		return 1;
	else if (nSel >= 0) 
		goto SKIP_DEFAULT;

	if (nSel < 0)
	{
 		// Need to set the selection so find the new selection
 		// based on the virtual key pressed
 		switch (vKey)
 		{
 		// UNDONE: Later, not language independent!!!
 		// Need to find-out how NT5.0 determines the slash issue??
 		
 		case VERKEY_BACKSLASH:
 			// Deselect everything if we are in extended mode
 			if (HIWORD(GetKeyState(VK_CONTROL)) && _fLstType == kExtended)
 			{
 				// NOTE:
 				//	Winnt loses the anchor and performing a shift+<vkey> 
 				//  doesn't select any items.  Instead, it just moves the
 				//  cursor w/o selecting the current cursor
 				_nAnchor = -1;
 				LbSetSelection(_nCursor, _nCursor, LBSEL_RESET | LBSEL_SELECT, 0, 0); 
 				TxNotify(LBN_SELCHANGE, NULL);
 			} 			
 			return 1;

 		case VK_DIVIDE:
 		case VERKEY_SLASH:
 			// Select everything if we are in extended mode
 			if (HIWORD(GetKeyState(VK_CONTROL)) && _fLstType == kExtended)
 			{
 				// NOTE:
 				//  Winnt behaves as we expect.  In other words the anchor
 				//  isn't changed and neither is the cursor
 				LbSetSelection(0, _nCount - 1, LBSEL_SELECT, 0, 0);
 				TxNotify(LBN_SELCHANGE, NULL);
 			}
 			return 1;
 		
 		case VK_SPACE:
 			// just get out if there is nothing to select
 			if (_nCursor < 0 && !GetCount())
 				return 1;
 			// Just select current item
 			nSel = _nCursor;
 			break;
 			
 		case VK_PRIOR:
 			// move the cursor up enough so the current item which the cursor
 			// is pointing to is at the bottom and the new cursor position is at the top
			if (_fOwnerDrawVar)
				nSel = PageVarHeight(_nCursor, FALSE);
			else
 				nSel = _nCursor - _nViewSize + 1;
 			if (nSel < 0)
 				nSel = 0;
 			break;
 			
 		case VK_NEXT:
 			// move the cursor down enough so the current item which the cursor
 			// is point is at the top and the new cursor position is at the bottom
			if (_fOwnerDrawVar)
				nSel = PageVarHeight(_nCursor, TRUE);
			else
 				nSel = _nCursor + _nViewSize - 1;

 			if (nSel >= _nCount)
 				nSel = _nCount - 1;
 			break; 			

 		case VK_HOME:
 			// move to the top of the list
 			nSel = 0;
 			break;
 			
 		case VK_END:
 			// move to the bottom of the list
 			nSel = _nCount - 1;
 			break;

 		case VK_LEFT:
 		case VK_UP:
 			nSel = (_nCursor > 0) ? _nCursor - 1 : 0;
 			break;

 		case VK_RIGHT:
 		case VK_DOWN:
 			nSel = (_nCursor < _nCount - 1) ? _nCursor + 1 : _nCount - 1;
 			break;

 		case VK_RETURN:
 		case VK_F4:
 		case VK_ESCAPE:
 			if (_fLstType == kCombo)
 			{
	 			Assert(_pcbHost);
	 			int nCursor = (vKey == VK_RETURN) ? GetCursor() : _nOldCursor;
	 			_pcbHost->SetSelectionInfo(vKey == VK_RETURN, nCursor);
	 			LbSetSelection(nCursor, nCursor, LBSEL_RESET | 
	 				((nCursor == -1) ? 0 : LBSEL_NEWCURSOR | LBSEL_SELECT), nCursor, nCursor);
				OnCBTracking(LBCBM_END, 0); // we need to do this because we may have some extra messages
											// in our message queue which can change the selections
	 			SendMessage(_hwndParent, LBCB_TRACKING, 0, 0);
	 		}
 			// NOTE:
 			//	We differ from Winnt here in that we expect the
 			// combobox window handler to do all the positioning and 
 			// showing of the list box.  So when we get this message
 			// and we are part of a combobox we should notify the 
 			// combobox and in turn the combobox should immediately close us.
 			//return 1;

 		//case VK_F8: // not suppported 

 		// We need to return this to pserv to process these keys
		/*
		case VK_MENU:
 		case VK_CONTROL:
 		case VK_SHIFT:
 			return 1;
 		*/
 		
 		default:
 			return 1; 		
 		}
	}

	// There can be cases where nSel = -1; _nCursor = -1 && _nViewSize = 1
	// make sure the selection index is valid
	if (nSel < 0)
 		nSel = 0;

SKIP_DEFAULT:
	// Should the cursor be set at the top or bottom of the list box??
	BOOL bTop = (_nCursor > nSel) ? TRUE : FALSE;
	Freeze();
	if (_fLstType == kMultiple)
	{
		if (vKey == VK_SPACE)
		{
			BOOL fSel = IsSelected(nSel);
			if (LbSetSelection(nSel, nSel, LBSEL_NEWCURSOR | (IsSelected(nSel) ? 0 : LBSEL_SELECT), nSel, 0))
			{
				_nAnchor = nSel;
#ifndef NOACCESSIBILITY
				_dwWinEvent = EVENT_OBJECT_FOCUS;
				_fNotifyWinEvt = TRUE;
				TxNotify(_dwWinEvent, NULL);
				if (fSel)
					_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
#endif
			}
		}
		else
		{
			SetCursor(NULL, nSel, TRUE);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
#endif
		}
	}
	else
	{
		if (ffShift && _fLstType == kExtended)
		{	 		
	 		// Set the anchor if it already isn't set
	 		_nOldCursor = -1;
			if (_nAnchor < 0)
				_nAnchor = nSel;

			LbSetSelection(_nAnchor, nSel, LBSEL_RESET | LBSEL_SELECT | LBSEL_NEWCURSOR, nSel, 0);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
			_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
#endif
		}
		else
		{
	 		// if the selected item is already selected then
	 		// just exit out
	 		if (_nCursor == nSel && IsSelected(_nCursor))
	 		{
	 			Unfreeze();
	 			return 1;
	 		}

	 		LbSetSelection(nSel, nSel, LBSEL_DEFAULT, nSel, nSel);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
#endif
		}
	}
	// LbShowIndex eventually calls ScrollToView which fails if display is frozen
	Unfreeze();

	// Make sure the selection is visible
	LbShowIndex(nSel, bTop);

	// key presses qualify as ok selections so we have to update the old cursor position		
	TxNotify(LBN_SELCHANGE, NULL);

	_nOldCursor = _nCursor;
	return 1;
}
 
/*
 *	LRESULT CLstBxWinHost::OnTimer(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_TIMER message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnTimer(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnTimer");

	// Check which timer we have
	switch (wparam)
	{
	case ID_LB_CAPTURE:
		// for mouse movements let mousemove handler deal with it
		if (_fCapture)
		{
			POINT pt;
			::GetCursorPos(&pt);
			// Must convert to client coordinates to mimic the mousemove call
			TxScreenToClient(&pt);
			OnMouseMove(0, MAKELONG(pt.x, pt.y));
		}
		break;

	case ID_LB_SEARCH:
		// for type search.  If we get here means > 2 seconds elapsed before last
		// character was typed in so reset type search and kill the timer
		InitSearch();
		TxKillTimer(ID_LB_SEARCH);
		break;

	default:
		return 1;	
	}
	return 0;
}
 
/*
 *	LRESULT CLstBxWinHost::OnVScroll(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_VSCROLL message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnVScroll(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnVScroll");

	if (_fOwnerDrawVar)
	{
		BOOL fGreaterThanView;
		SumVarHeight(0, _nCount, &fGreaterThanView);
		if (!fGreaterThanView)		// If less than current view size
			return 0;				//	nothing to scroll
	}
	else if (_nCount <= _nViewSize)
		return 0;

	int nCmd = LOWORD(wparam);
	int nIdx = 0;
	switch (nCmd)
	{
	case SB_TOP:
		nIdx = 0;
		break;
		
	case SB_BOTTOM:
		if (_fOwnerDrawVar)
			nIdx = PageVarHeight(_nCount, FALSE) + 1;
		else
			nIdx = _nCount - _nViewSize;

		if (nIdx < 0)
			nIdx = 0;

		if (nIdx >= _nCount)
			nIdx = _nCount - 1;
		break;

	case SB_LINEDOWN:
		nIdx = GetTopIndex() + 1;
		break;		
		
	case SB_LINEUP:
		nIdx = GetTopIndex() - 1;
		if (nIdx < 0)
			nIdx = 0;
		break;
		
	case SB_PAGEDOWN:
		if (_fOwnerDrawVar)
			nIdx = PageVarHeight(GetTopIndex(), TRUE);
		else
		{
			nIdx = GetTopIndex() + _nViewSize;

			if (nIdx > (_nCount - _nViewSize))
				nIdx = _nCount - _nViewSize;
		}
		break;
		
	case SB_PAGEUP:
		if (_fOwnerDrawVar)
			nIdx = PageVarHeight(GetTopIndex(), FALSE);
		else
			nIdx = GetTopIndex() - _nViewSize;

		if (nIdx < 0)
			nIdx = 0;
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		// NOTE:
		//	if the list box is expected to hold more that 0xffff items
		//  then we need to modify this code to call GetScrollInfo.		
		if (_fOwnerDrawVar)
			nIdx = GetIdxFromHeight(HIWORD(wparam));
		else
			nIdx =  HIWORD(wparam) / _nyItem;
		break;

	case SB_SETINDEX:
		// Internal case for setting the index directly.
		nIdx = HIWORD(wparam);
		break;

		// Don't need to do anything for this case
	case SB_ENDSCROLL:
		return 0;	
	}
		
	LbSetTopIndex(nIdx);
	return 0;
}
 
/*
 *	LRESULT CLstBxWinHost::OnHScroll(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_HSCROLL message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnHScroll(
	WPARAM wparam,
	LPARAM lparam)
{
	BOOL	fRedrawCursor = FALSE;
	BOOL	fFocus = _fFocus;
	LRESULT lres = 0;
	int		nCmd = LOWORD(wparam);

	if (nCmd == SB_LINEDOWN || nCmd == SB_PAGEDOWN)
	{
		LONG lMax, lPos, lPage;
		_pserv->TxGetHScroll(NULL, &lMax, &lPos, &lPage, NULL);
		if (lPos + lPage >= lMax)
			return 0;

	}
	else if (nCmd == SB_ENDSCROLL)
		return 0;		// Do nothing for this case

	if (!_fOwnerDraw && fFocus && IsItemViewable(GetCursor()))
	{
		fRedrawCursor = TRUE;
		_fFocus = 0;
		SetCursor(NULL, GetCursor(), TRUE);	// force the removal of focus rect
	}

	_pserv->TxSendMessage(WM_HSCROLL, wparam, lparam, &lres);

	if (fRedrawCursor)
	{
		_fFocus = fFocus;
		SetCursor(NULL, GetCursor(), FALSE);		// Redraw the focus rect which we erased
	}
	return lres;
}

/*
 *	LRESULT CLstBxWinHost::OnCaptureChanged(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_CAPTURECHANGED message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnCaptureChanged(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCaptureChanged");

	if (_fCapture)
	{
		POINT pt;
		::GetCursorPos(&pt);
		::ScreenToClient(_hwnd, &pt);

		// prevent us from trying to release capture since we don't have
		// it anyways by set flag and killing timer
		_fCapture = 0;
		TxKillTimer(ID_LB_CAPTURE);		
		OnLButtonUp(0, MAKELONG(pt.y, pt.x), LBN_SELCANCEL);
	}
	return 0;
}

//FUTURE:
// Do we need to support ReadModeHelper? 

/*
 *	LRESULT CLstBxWinHost::OnMouseWheel(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_MOUSEWHEEL message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnMouseWheel(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnMouseWheel");

	// we don't to any zooms or anything of the sort
	if ((wparam & MK_CONTROL) == MK_CONTROL)
		return 1;

	// Check if the scroll is ok w/ the listbox requirements
	LRESULT lReturn = 1;
	short delta = (short)(HIWORD(wparam));
	_cWheelDelta -= delta;
	if ((abs(_cWheelDelta) >= WHEEL_DELTA) && (_dwStyle & WS_VSCROLL )) 
	{
		BOOL fGreaterThanView = _nCount > _nViewSize;

		if (_fOwnerDrawVar)
			SumVarHeight(0, _nCount, &fGreaterThanView);

		if (!fGreaterThanView)	// Smaller than current view size
			return lReturn;		//	no need to scroll

		// shut-off timer for right now
		TxKillTimer(ID_LB_CAPTURE);

		Assert(delta != 0);
        
		int nlines = W32->GetRollerLineScrollCount();
		if (nlines == -1)
		{
			OnVScroll(MAKELONG((delta < 0) ? SB_PAGEUP : SB_PAGEDOWN, 0), 0);
		}
		else
		{
			int nIdx;

			//Calculate the number of lines to scroll
			nlines *= _cWheelDelta/WHEEL_DELTA;

			if (!_fOwnerDrawVar)
			{
				//Perform some bounds checking
				nlines = min(_nViewSize - 1, nlines);
				nIdx = max(0, nlines + GetTopIndex());
				nIdx = min(nIdx, _nCount - _nViewSize);
			}
			else
			{
				int	idxNextPage = PageVarHeight(GetTopIndex(), TRUE);

				if (nlines > idxNextPage - GetTopIndex())
					nIdx = idxNextPage;
				else
					nIdx = max(0, nlines + GetTopIndex());
			}

			if (nIdx != GetTopIndex()) 
				OnVScroll(MAKELONG(SB_SETINDEX, nIdx), 0);
		}		

		_cWheelDelta %= WHEEL_DELTA;
	}
	return lReturn;
}

/*
 *	LRESULT CLstBxWinHost::OnLButtonUp(WPARAM, LPARAM, int)
 *
 *	@mfunc
 *		Handles the WM_LBUTTONUP and WM_CAPTURECHANGED message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnLButtonUp(
	WPARAM wparam,
	LPARAM lparam,
	int ff)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnLButtonUp");

	// if mouse wasn't down then exit out
	if (!_fMouseDown)
		return 0;
	_fMouseDown = 0;

	POINT pt;
	POINTSTOPOINT(pt, lparam);
	if (_fLstType == kCombo)
	{
 		Assert(_fCapture);
 		// Check if user clicked outside the list box
 		// if so this signifies the user cancelled and we
 		// should send a message to the parentwindow
		if (!PointInRect(&pt))
 		{	
			//User didn't click in listbox so reselect old item
			LbSetSelection(_nOldCursor, _nOldCursor, LBSEL_DEFAULT, _nOldCursor, _nOldCursor);
			ff = 0;
 		}
 		else
			ff = LBN_SELCHANGE;	//item changed so notify parent
 		
 		_pcbHost->SetSelectionInfo(ff == LBN_SELCHANGE, GetCursor());
		OnCBTracking(LBCBM_END, 0);
		::PostMessage(_hwndParent, LBCB_TRACKING, LBCBM_END, 0);
	}
	else
	{
 		// Kill any initializations done by mouse down... 
		_fMouseDown = 0;
		_nOldCursor = -1;
	}

	if (_fCapture)
	{
 		TxKillTimer(ID_LB_CAPTURE);
		_fCapture = 0;
 		TxSetCapture(FALSE); 	
	}

	if (ff)
	{
#ifndef NOACCESSIBILITY
		if (ff == LBN_SELCHANGE)
		{
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
			if (!IsSelected(_nCursor))
			{
				_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
			}
		}
#endif
		// Send notification if a notification exists
		TxNotify(ff, NULL);
	}

	return 1;
}

/*
 *	LRESULT CLstBxWinHost::OnMouseMove(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_MOUSEMOVE message and possibly the
 *		WM_TIMER message for tracking mouse movements
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnMouseMove(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnMouseMove");

	// bug fix #4998
	// Check if previous mouse position is the same as current, if it is
	// then this is probably a bogus message from PPT.
	POINT pt;
	POINTSTOPOINT(pt, lparam);
	if (_nPrevMousePos == lparam && PtInRect(&_rcViewport, pt))
 		return 0;
	_nPrevMousePos = lparam;

	// This routine will only start the autoscrolling of the listbox
	// The autoscrolling is done using a timer where the and the elapsed
	// time is determined by how far the mouse is from the top and bottom
	// of the listbox.  The farther from the listbox the faster the timer
	// will be.  This function relies on the timer to scroll and select
	// items.
	// We get here if mouse cursor is in the list box.
	int idx = GetItemFromPoint(&pt);

	// We only do the following if mouse is down.
	if (_fMouseDown)
	{
		int y = (short)pt.y;
		if (y < 0 || y > _rcViewport.bottom - 1)
		{
			// calculate the new timer settings
			int dist = y < 0 ? -y : (y - _rcViewport.bottom + 1);
			int nTimer = ID_LB_CAPTURE_DEFAULT - (int)((WORD)dist << 4);
				
			// Scroll up or down depending on the mouse pos relative
			// to the list box
			idx = (y <= 0) ? max(0, idx - 1) : min(_nCount - 1, idx + 1);
			if (idx >= 0 && idx < _nCount)
			{	
				// The ordering of this is VERY important to prevent screen
				// flashing...
				if (idx != _nCursor)
					MouseMoveHelper(idx, (_fLstType == kCombo) ? FALSE : TRUE);
				OnVScroll(MAKELONG((y < 0) ? SB_LINEUP : SB_LINEDOWN, 0), 0);
			}
			// reset timer
			TxSetTimer(ID_LB_CAPTURE, (5 > nTimer) ? 5 : nTimer);
			return 0;
		}
		// Don't select if we are part of a combo box and mouse is outside client area
		else if (_fLstType == kCombo && (pt.x < 0 || pt.x > _rcViewport.right - 1))
			return 0;
	}
	else if (!PointInRect(&pt))
		return 0;

	if (idx != _nCursor || (_fLstType == kCombo && idx >= 0 && !IsSelected(idx)))
	{			
		// Prevent flashing by not redrawing if index
		// didn't change
		Assert(idx >= 0);
		MouseMoveHelper(idx, TRUE);
	}
	return 0;
}
 
/*
 *	LRESULT CLstBxWinHost::OnLButtonDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_LBUTTONDOWN message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnLButtonDown(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnLButtonDown");
	
	POINT pt;
	POINTSTOPOINT(pt, lparam);

	if (_fCapture)
	{
		// Need to check if the listbox is part of a combobox, if so
		// then we need to notify the parent class.
		if (_fLstType == kCombo)
		{
			// Need to perform the following
			// - check if click is within client area of combo box if not then
			//		behave as if user cancelled
			if (!PointInRect(&pt))
			{
				// reset our double click flag because we could be double clicking on the scrollbar
				_fDblClick = 0;
				
				// check if the scroll bar was clicked
				// mouse message won't get posted unless we release it 
				// for a short while
				TxClientToScreen(&pt);				
				LRESULT lHit = SendMessage(_hwnd, WM_NCHITTEST, 0, MAKELONG(pt.x, pt.y));
				// check if user clicked on the scrollbar
				if (HTVSCROLL == lHit || HTHSCROLL == lHit)
				{
					if (_fCapture)
					{
						_fCapture = 0;
						TxSetCapture(FALSE);
					}

					SendMessage(_hwnd, WM_NCLBUTTONDOWN, lHit, MAKELONG(pt.x, pt.y));

					TxSetCapture(TRUE);
					_fCapture = 1;
				}
				else if (HTGROWBOX != lHit)
				{
					// if user didn't click the scrollbar then notify parent and stop
					// tracking else just get out
					Assert(_pcbHost);
					_pcbHost->SetSelectionInfo(FALSE, _nOldCursor);
					LbSetSelection(_nOldCursor, _nOldCursor, LBSEL_RESET | 
						((_nOldCursor == -1) ? 0 : LBSEL_NEWCURSOR | LBSEL_SELECT), 
						_nOldCursor, _nOldCursor);
					OnCBTracking(LBCBM_END, 0);
					SendMessage(_hwndParent, LBCB_TRACKING, 0, 0);
				}				
				return 0;
			}
		}
	}	
	
	int idx = GetItemFromPoint(&pt);
	if (idx <= -1)
	{
		_fDblClick = 0;
		return 0;
	}

	_fMouseDown = 1;

	// if the message was a double click message than don't need to go
	// any further just fake a mouseup message to get back to a normal
	// state	
	if (_fDblClick)
	{
		_fDblClick = 0;
		OnLButtonUp(wparam, lparam, LBN_DBLCLK);
		return 0;
	}
		
	// Set the timer in case the user scrolls outside the listbox
	if (!_fCapture)
	{
		TxSetCapture(TRUE);
		_fCapture = 1;
		TxSetTimer(ID_LB_CAPTURE, ID_LB_CAPTURE_DEFAULT);	
	}

	int ffVirtKey = LBKEY_NONE;
	if (_fLstType == kExtended)
	{
		if (HIWORD(GetKeyState(VK_SHIFT)))
			ffVirtKey |= LBKEY_SHIFT;
		if (HIWORD(GetKeyState(VK_CONTROL)))
			ffVirtKey |= LBKEY_CONTROL;
	}

	int ff = 0;
	int i = 0;
	int nStart = idx;
	int nEnd = idx;
	int nAnchor = _nAnchor;
	switch (ffVirtKey)
	{	
	case LBKEY_NONE:
		// This case accounts for listbox styles with kSingle, kMultiple, and 
		// kExtended w/ no keys pressed
		if (_fLstType == kMultiple)
		{
			ff = (IsSelected(idx) ? 0 : LBSEL_SELECT) | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR;			
		}
		else
		{
			// keep a copy of the old cursor position around for combo cancells			
			ff = LBSEL_DEFAULT;
		}
		nAnchor = idx;
		break;
		
	case LBKEY_SHIFT:		
		// Now select all the items between the anchor and the current selection
		// The problem is LbSetSelection expects the first index to be less then
		// or equal to the second index so we have to manage the Anchor and index
		// ourselves..				
		ff = LBSEL_SELECT | LBSEL_RESET | LBSEL_NEWCURSOR;
		i = !(IsSelected(_nAnchor));
		if (_nAnchor == -1)
		{
			ff |= LBSEL_NEWANCHOR;
			nAnchor = idx;
		}
		else if (_nAnchor > idx)
		{
			nEnd = _nAnchor - i;			
		}
		else if (_nAnchor < idx)
		{
			nEnd = _nAnchor + i;
		}
		else if (i) // _nAnchor == idx && idx IS selected
		{
			ff = LBSEL_RESET;
			nStart = 0;
			nEnd = 0;
		}
		break;
		
	case LBKEY_CONTROL:
		// Toggle the selected item and set the new anchor and cursor
		// positions
		ff = LBSEL_NEWCURSOR | LBSEL_NEWANCHOR | (IsSelected(idx) ? 0 : LBSEL_SELECT);
		nAnchor = idx;
		break;
		
	case LBKEY_SHIFTCONTROL:
		// De-select any items between the cursor and the anchor (excluding the anchor)
		// and select or de-select the new items between the anchor and the cursor

		// Set the anchor if it already isn't set
		if (_nAnchor == -1)
			_nAnchor = (_nOldCursor >= 0) ? _nOldCursor : idx;
			
		// Just deselect all items between the cursor and the anchor
		if (_nCursor != _nAnchor)
		{
			// remove selection from old cursor position to the current anchor position
			LbSetSelection(_nCursor, (_nCursor > _nAnchor) ? _nAnchor + 1 : _nAnchor - 1, 0, 0, 0);
		}

		// Check if we used a temporary anchor if so then set the anchor to
		// idx because we don't want the temporary anchor to be the actual anchor
		if (_nOldCursor >= 0)
		{
			_nOldCursor = -1;
			_nAnchor = idx;
		}

		// Set the state of all items between the new Cursor (idx) and 
		// the anchor to the state of the anchor
		ff = LBSEL_NEWCURSOR | (IsSelected(_nAnchor) ? LBSEL_SELECT : 0);
		nEnd = _nAnchor;
		break;
	default:
		Assert(FALSE && "Should not be here!!");		
	}

	if (LbSetSelection(nStart, nEnd, ff, idx, nAnchor))
	{
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_FOCUS;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
	}

	return 0;
}

///////////////////////////  ComboBox Helper Functions  ////////////////////////////// 
/*
 * void CLstBxWinHost::OnCBTracking(WPARAM, LPARAM)
 *
 * @mfunc
 * 	This should be only called by the combo box.  This is a general message used
 *  to determine the state the listbox should be in
 *
 * @rdesc
 *	void
 */
void CLstBxWinHost::OnCBTracking(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCBTracking");

	Assert(_pcbHost);
	Assert(_hwndParent);

	switch (wparam)
	{
	// lparam = Set focus to listbox
	case LBCBM_PREPARE:
		Assert(IsWindowVisible(_hwnd));
		_fMouseDown = FALSE;		
		if (lparam & LBCBM_PREPARE_SAVECURSOR)
			_nOldCursor = GetCursor();
		if (lparam & LBCBM_PREPARE_SETFOCUS)
		{
			_fFocus = 1;
			TxSetFocus();
		}
		InitWheelDelta();
		break;

	// lparam = mouse is down
	case LBCBM_START:
		Assert(IsWindowVisible(_hwnd));
		_fMouseDown = !!lparam;
		TxSetCapture(TRUE);
		_fCapture = 1;
		break;		

	// lparam = Keep capture
	case LBCBM_END:
		TxKillTimer(ID_LB_CAPTURE);
		_fFocus = 0;
		if (_fCapture)
		{			
			_fCapture = FALSE;
			TxSetCapture(FALSE);
		}
		break;
	default:
		AssertSz(FALSE, "ALERT: Custom message being used by someone else");
	}	

}


///////////////////////////////  ListBox Functions  ////////////////////////////////// 
/*
 * void CLstBxWinHost::LbDeleteItemNotify(int, int)
 *
 * @mfunc
 * Sends message to the parent an item has been deleted.  This function should be
 *	called whenever the LB_DELETESTRING message is recieved or if the listbox is
 *	being destroyed and the listbox is owner draw
 *
 * @rdesc
 *	void
 */
void CLstBxWinHost::LbDeleteItemNotify(
	int nStart,
	int nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDeleteItemNotify");
	
	// Initialize structure
	DELETEITEMSTRUCT ds;

	ds.CtlType = ODT_LISTBOX;
	ds.CtlID = _idCtrl;
	ds.hwndItem = _hwnd;
	
	for(int i = nStart; i <= nEnd; i++)
	{		
		// We do this just in case the user decides to change
		// the structure
		ds.itemData = GetData(i);
		ds.itemID = i;
		SendMessage(_hwndParent, WM_DELETEITEM, _idCtrl, (LPARAM)&ds);
	}
}


/*
 * void CLstBxWinHost::LbDrawItemNotify(HDC, int, UINT, UINT)
 *
 * @mfunc
 * This fills the draw item struct with some constant data for the given
 * item.  The caller will only have to modify a small part of this data
 * for specific needs.
 *
 * @rdesc
 *	void
 */
void CLstBxWinHost::LbDrawItemNotify(
	HDC hdc,
	int nIdx,
	UINT itemAction,
	UINT itemState)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDrawItemNotify");
	
	// Only send the message if the item is viewable and no freeze is on
	if (!IsItemViewable(nIdx) || !LbEnableDraw())
		return;
		
    //Fill the DRAWITEMSTRUCT with the unchanging constants
	DRAWITEMSTRUCT dis;
    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = _idCtrl;

    // Use -1 if an invalid item number is being used.  This is so that the app
    // can detect if it should draw the caret (which indicates the lb has the
    // focus) in an empty listbox
    dis.itemID = (UINT)(nIdx < _nCount ? nIdx : -1);
    dis.itemAction = itemAction;
    dis.hwndItem = _hwnd;
    dis.hDC = hdc;
    dis.itemState = itemState |
            (UINT)(_fDisabled ? ODS_DISABLED : 0);

    // Set the app supplied data
    if (_nCount == 0) 
    {
        // If no items, just use 0 for data.  This is so that we
        // can display a caret when there are no items in the listbox.
        dis.itemData = 0L;
    } 
    else 
    {
    	Assert(nIdx < _nCount);
        dis.itemData = GetData(nIdx);
    }

	LbGetItemRect(nIdx, &(dis.rcItem));

    /*
     * Set the window origin to the horizontal scroll position.  This is so that
     * text can always be drawn at 0,0 and the view region will only start at
     * the horizontal scroll offset. We pass this as wparam
     */
    SendMessage(_hwndParent, WM_DRAWITEM, _idCtrl, (LPARAM)&dis);
}

/*
 *	LRESULT CLstBxWinHost::OnSetEditStyle(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Check if we need to do custom look for ListBox
 *
 *	@rdesc
 *		return value same as EM_GETEDITSTYLE
 */
LRESULT CLstBxWinHost::OnSetEditStyle(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSetEditStyle");
	LRESULT	lres;
	BOOL	fCustomLookBefore = ((CTxtEdit *) _pserv)->_fCustomLook;
	BOOL	fCustomLook;
	HRESULT	hr;

	hr = _pserv->TxSendMessage(EM_SETEDITSTYLE, wparam, lparam, &lres);
	fCustomLook = ((CTxtEdit *) _pserv)->_fCustomLook;

	if (fCustomLook != fCustomLookBefore)
	{
		DWORD	dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
		DWORD	dwExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);

		if (fCustomLook)
		{
			dwStyle |= WS_BORDER;
			dwExStyle &= ~WS_EX_CLIENTEDGE;
		}
		else
		{
			dwStyle &= ~WS_BORDER;
			dwExStyle |= WS_EX_CLIENTEDGE;
		}

		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
		SetWindowLong(_hwnd, GWL_EXSTYLE, dwExStyle);
		OnSunkenWindowPosChanging(_hwnd, NULL);
	}
	return lres;
}


/*
 *	LONG CLstBxWinHost::IsCustomLook()
 *
 *	@mfunc
 *		return custom look setting for ListBox
 *
 *	@rdesc
 *		return custom look setting for ListBox
 */
BOOL CLstBxWinHost::IsCustomLook()
{
	return	((CTxtEdit *) _pserv)->_fCustomLook;
}

/*
 *	BOOL CLstBxWinHost::LbSetItemHeight(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Sets the height of the items within the given range [0, _nCount -1]
 *
 *	@rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbSetItemHeight(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetItemHeight");

	int		nHeight = (int)lparam;
	BOOL	retCode = FALSE;

	// Set the height of the items if there are between [1,255] : bug fix #4783
	if (nHeight < 256 && nHeight > 0)
	{
		if (_fOwnerDrawVar)
		{
			if ((unsigned)GetCount() > wparam)
				retCode = SetVarItemHeight(wparam, nHeight);
		}
		else if (SetItemsHeight(nHeight, FALSE))
		{
			//bug fix #4214
			//need to recalculate how many items are viewable, IN ITS ENTIRETY, 
			//using the current window size
			RECT rc;
			TxGetClientRect(&rc);
			_nViewSize = max(rc.bottom / max(_nyItem, 1), 1);
			retCode = TRUE;
		}

		if (retCode)
		{
			_fSetScroll = 0;
			if (_fSetRedraw)
			{
				if (_dwStyle & WS_VSCROLL)
					SetScrollInfo(SB_VERT, TRUE);
			}
			else
				_fSetScroll = 1;
		}
	}
	return retCode;
}

/*
 *	BOOL CLstBxWinHost::LbGetItemRect(int, RECT*)
 *
 *	@mfunc
 *		Returns the rectangle coordinates of a requested index
 *		The coordinates will be in client coordinates
 *
 *	@rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbGetItemRect(
	int idx,
	RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbGetItemRect");

	Assert(prc);
	Assert(idx >= -1);

#ifdef _DEBUG
	if (_nCount > 0)
		Assert(idx < _nCount);
	else
		Assert(idx == _nCount);
#endif //_DEBUG

	if (idx == -1)
		idx = 0;

	TxGetClientRect(prc);

	prc->left = 0; 
	if (_fOwnerDrawVar)
	{
		LONG lTop = _rcViewport.top;

		if (idx > _nCount)
			idx = _nCount - 1;
		else if (idx < 0)
			idx = 0;

		if (idx >= GetTopIndex())
		{
			for (int i = GetTopIndex(); i < idx; i++)
				lTop += _rgData[i]._uHeight;
		}
		else
		{
			for (int i = idx; i < GetTopIndex(); i++)
				lTop -= _rgData[i]._uHeight;
		}
		prc->top = lTop;
		prc->bottom = lTop + _rgData[idx]._uHeight;
	}
	else
	{
		prc->top = (idx - GetTopIndex()) * _nyItem + _rcViewport.top;
		prc->bottom = prc->top + _nyItem;
	}

	return TRUE;
}

	
/*
 *	BOOL CLstBxWinHost::LbSetItemData(long, long, LPARAM)
 *
 *	@mfunc
 *		Given a range [nStart,nEnd] the data for these items
 *		will be set to nValue
 *	@rdesc
 *		void
 */
void CLstBxWinHost::LbSetItemData(
	long	nStart,
	long	nEnd,
	LPARAM	nValue)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetItemData");
	
	Assert(nStart >= 0 && nStart < _nCount);
	Assert(nEnd >= 0 && nEnd < _nCount);
	Assert(nStart <= nEnd);
	
	int nMin = min(nEnd + 1, _nCount);
	for (int i = nStart; i < nMin; i++)
		_rgData[i]._lparamData = nValue;
}

/*
 *	long CLstBxWinHost::LbDeleteString(long, long)
 *
 *	@mfunc
 *		Delete the string at the requested range.
 *	@rdesc
 *		long = # of items in the list box.  If failed -1
 */
long CLstBxWinHost::LbDeleteString(
	long nStart,
	long nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDeleteString");

	if ((nStart > nEnd) || (nStart < 0) || (nEnd >= _nCount))
		return -1;

	if (!RemoveString(nStart, nEnd))
		return -1;

	// set the top index to fill the window
	LbSetTopIndex(max(nStart -1, 0));

#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_DESTROY;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
		
	return _nCount;
}
 
/*
 *	CLstBxWinHost::LbInsertString(long, LPCTSTR)
 *
 *	@mfunc
 *		Insert the string at the requested index.  If long >= 0 then the
 *	string insertion is at the requested index. If long == -2 insertion
 *	is at the position which the string would be alphabetically in order.
 *	If long == -1 then string is added to the bottom of the list
 *
 *	@rdesc
 *		long = If inserted, the index (paragraph) which the string
 *			was inserted.  If not inserted returns -1;
 */
long CLstBxWinHost::LbInsertString(
	long nIdx,
	LPCTSTR szText)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbInsertString");

	Assert(nIdx >= -2);
	Assert(szText);
	
	if (nIdx == -2)
	{
		if (_nCount > 0)
			nIdx = GetSortedPosition(szText, 0, _nCount - 1);
		else
			nIdx = 0; //nothing inside listbox
	}
	else if (nIdx == -1)
		nIdx = GetCount();	// Insert string to the bottom of list if -1

	if (InsertString(nIdx, szText))
	{
		// If the index was previously selected unselect the newly 
		// added item
		for (int i = _nCount - 1; i > nIdx; i--)
		{
			_rgData[i]._fSelected = _rgData.Get(i - 1)._fSelected;

			// bug fix #4916
			_rgData[i]._lparamData = _rgData.Get(i - 1)._lparamData;

			_rgData[i]._uHeight = _rgData.Get(i - 1)._uHeight;
		}
		_rgData[nIdx]._fSelected = 0;
		_rgData[nIdx]._uHeight = 0;
		_rgData[nIdx]._lparamData = 0;		// Need to Initialize data back to zero

		if (!_fOwnerDraw)
		{
			// if we inserted at the middle or top then check 1 index down to see if the item
			// was selected, if we inserted at the bottom then check 1 index up to see if the item
			// was selected.  If the item was selected we need to change the colors to default
			// because we inherit the color properties from the range which we inserted into
			if (_nCount > 1)
			{
				if (((nIdx < _nCount - 1) && _rgData.Get(nIdx + 1)._fSelected) ||
					(nIdx == (_nCount - 1) && _rgData.Get(nIdx - 1)._fSelected))
					SetColors((unsigned)tomAutoColor, (unsigned)tomAutoColor, nIdx, nIdx);
			}
		}
		else
		{
			if (_fOwnerDrawVar)
			{
				// Get item height for OwnerDrawFix listbox
				MEASUREITEMSTRUCT	measureItem;

				measureItem.CtlType = ODT_LISTBOX;
				measureItem.CtlID = _idCtrl;
				measureItem.itemHeight = _nyFont;
				measureItem.itemWidth = 0;
				measureItem.itemData = (ULONG_PTR)szText;
				measureItem.itemID = nIdx;

				SendMessage(_hwndParent, WM_MEASUREITEM, _idCtrl, (LPARAM)&measureItem);

				LbSetItemHeight(nIdx, measureItem.itemHeight);
			}

			// Force redraw of items if owner draw and new item is viewable
			if (IsItemViewable(nIdx))
			{
				RECT rc;
				LbGetItemRect(nIdx, &rc);
				rc.bottom = _rcViewport.bottom;
				InvalidateRect(_hwnd, &rc, FALSE);
			}
		}
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_CREATE;
		_fNotifyWinEvt = TRUE;
		_nAccessibleIdx = nIdx + 1;
		TxNotify(_dwWinEvent, NULL);
#endif
		return nIdx;
	}
	else
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return -1;
	}
}
 
/*
 *	CLstBxWinHost::LbFindString(long, LPCTSTR, BOOL)
 *
 *	@mfunc
 *		Searches the story for a given string.  The
 *		starting position will be determined by the index nStart.
 *		This routine expects the units to be in tomParagraph.
 *		If bExact is TRUE then the paragraph must match the BSTR.
 *
 *	@rdesc
 *		long = If found, the index (paragraph) which the string
 *			was found in.  If not found returns -1;
 */
long CLstBxWinHost::LbFindString(
	long nStart,
	LPCTSTR szSearch,
	BOOL bExact)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbFindString");

	Assert(szSearch);
	Assert(nStart <= _nCount);

	int nSize = wcslen(szSearch);
	// If string is empty and not finding exact match then just return -1 like
	// the system control.  We don't have to worry about the exact match case
	// because it will work properly
	if (nStart >= _nCount || (nSize == 0 && !bExact))
		return -1;

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;

	if ((nSize + 3) > 1024)
		psz = new WCHAR[nSize + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	// format the string the way we need it
	wcscpy(psz, szCR);
	wcscat(psz, szSearch);
	if (bExact)
		wcscat(psz, szCR);		
	long lRet = -1;
	long l, cp;
	ITextRange *pRange = NULL;
	BSTR bstrQuery = SysAllocString(psz);
	if(!bstrQuery)
		goto CleanExit;
	if (psz != sz)
		delete [] psz;

	// Set starting position for the search
	if (!GetRange(nStart, _nCount - 1, &pRange))
	{
		SysFreeString(bstrQuery);
		return lRet;
	}

	CHECKNOERROR(pRange->GetStart(&cp));
	if (cp > 0)
	{
		// We need to use the paragraph marker from the previous
		// paragraph when searching for a string
		CHECKNOERROR(pRange->SetStart(--cp));	
	}
	else
	{
		// Special case:
		// Check if the first item matchs
		if (FindString(0, szSearch, bExact))
		{
			lRet = 0;
			goto CleanExit;
		}
	}

	if (NOERROR != pRange->FindTextStart(bstrQuery, 0, FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC, &l))
	{
		// Didn't find the string...
		if (nStart > 0)
		{
			if (!FindString(0, szSearch, bExact))
			{
				// Start the search from top of list to the point where
				// we last started the search			
				CHECKNOERROR(pRange->SetRange(0, ++cp));
				CHECKNOERROR(pRange->FindTextStart(bstrQuery, 0, 0, &l));
			}
			else
			{
				// First item was a match
				lRet = 0;
				goto CleanExit;
			}
		}
		else
			goto CleanExit;
	}

	// If we got down here then we have a match.
	// Get the index and convert to listbox index
	CHECKNOERROR(pRange->MoveStart(tomCharacter, 1, &l));
	CHECKNOERROR(pRange->GetIndex(tomParagraph, &lRet));
	lRet--;	// index is 1 based so we need to changed it to zero based

CleanExit:
	if (lRet != -1 && nSize == 1 && *szSearch == CR && _fOwnerDraw)
	{
		// Special case
		if (GetString(lRet, sz) != 1 || sz[0] != *szSearch)
			lRet = -1;
	}

	if (bstrQuery)
		SysFreeString(bstrQuery);
	if (pRange)
		pRange->Release();
	return lRet;
}
 
/*
 *	CLstBxWinHost::LbShowIndex(int, BOOL)
 *
 *	@mfunc
 *		Makes sure the requested index is within the viewable space.
 *		In cases where the item is not in the viewable space bTop is
 *		used to determine the requested item should be at the top
 *		of the list else list box will scrolled enough to display the
 *		item.
 *		NOTE:
 *			There can be situations where bTop will fail.  These 
 *		situations occurr of the top index requested prevents the list
 *		box from being completely filled with items.  For more info
 *		read the comments for LBSetTopIndex.
 *
 *	@rdesc
 *		BOOL = Successfully displays the item ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbShowIndex(
	long nIdx,
	BOOL bTop)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbShowIndex");

	// Make sure the requested item is within valid bounds
	if (!(nIdx >= 0 && nIdx < _nCount))
		return FALSE;

	if (_fOwnerDrawVar)
	{
		if (nIdx >= GetTopIndex())
		{
			BOOL fGreaterThanView;

			SumVarHeight(GetTopIndex(), nIdx+1, &fGreaterThanView);
			if (!fGreaterThanView)
				return TRUE;		// Already visible
		}
		if (!bTop)
			nIdx = PageVarHeight(nIdx, FALSE);
	}
	else
	{
		int delta = nIdx - GetTopIndex();

		// If item is already visible then just return TRUE
		if (0 <= delta && delta < _nViewSize)
			return TRUE;

		if ((delta) >= _nViewSize && !bTop && _nViewSize)
			nIdx = nIdx - _nViewSize + 1;
	}

	return (LbSetTopIndex(nIdx) < 0) ? FALSE : TRUE;
}

/*
 *	CLstBxWinHost::LbSetTopIndex(long)
 *
 *	@mfunc
 *		Tries to make the requested item the top index in the list box.
 *		If making the requested item the top index prevents the list box
 *		from using the viewable region to its fullest then and alternative
 *		top index will be used which will display the requested index
 *		but NOT as the top index.  This ensures conformancy with the system
 *		list box and makes full use of the dislayable region.
 *
 *	@rdesc
 *		long = returns the new top index if successful.  If failed returns -1
 */
long CLstBxWinHost::LbSetTopIndex(
	long nIdx)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetTopIndex");
		
	// Make sure the requested item is within valid bounds
	if (nIdx < 0 || nIdx >= _nCount)
 		return -1;
		
	// Always try to display a full list of items in the list box
	// This may mean we have to adjust the requested top index if
	// the requested top index will leave blanks at the end of the
	// viewable space
	if (_fOwnerDrawVar)
	{
		// Get top index for the last page
		int iLastPageTopIdx = PageVarHeight(_nCount, FALSE);
		if (iLastPageTopIdx < nIdx)
			nIdx = iLastPageTopIdx;
	}
	else if (_nCount - _nViewSize < nIdx)
		nIdx = max(0, _nCount - _nViewSize);

	// Just check to make sure we not already at the top 
	if (GetTopIndex() == nIdx)
		return nIdx;

	if (!SetTopViewableItem(nIdx))
		nIdx = -1;

	return nIdx;
}

/*
 *	CLstBxWinHost::LbBatchInsert(WCHAR* psz)
 *
 *	@mfunc
 *		Inserts the given list of items into listbox.  The listbox is reset prior to adding
 *	the items into the listbox
 *
 *	@rdesc
 *		int = # of items in the listbox if successful else LB_ERR
 */
int CLstBxWinHost::LbBatchInsert(
	WCHAR* psz)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbBatchInsert");

	// make sure we get some sort of string
	if (!psz)
		return LB_ERR;
		
	WCHAR* pszOut = psz;
	LRESULT nRet = LB_ERR;
	BSTR bstr = NULL;
	ITextRange* pRange = NULL;
	int nCount = 0;
	
	if (_fSort)
	{
		pszOut = new WCHAR[wcslen(psz) + 1];
		Assert(pszOut);

		if (!pszOut)
		{
			TxNotify((unsigned long)LBN_ERRSPACE, NULL);
			return LB_ERR;
		}

		nCount = SortInsertList(pszOut, psz);
		if (nCount == LB_ERR)
			goto CleanExit;
	}
	else
	{
		//bug fix #5130 we need to know how much we are going to insert
		//prior to inserting because we may be getting showscrollbar message
		//during insertion
		WCHAR* pszTemp = psz;
		while(*pszTemp)
		{
			if (*pszTemp == L'\r')
				nCount++;
			pszTemp++;
		}
		nCount++;
	}

	//clear listbox and insert new list into listbox
	LbDeleteString(0, GetCount() - 1);

	bstr = SysAllocString(pszOut);
	if(!bstr)
		goto CleanExit;
	
	// Insert string into list	
	CHECKNOERROR(((CTxtEdit*)_pserv)->Range(0, 0, &pRange));

	//bug fix #5130
	// preset our _nCount for scrollbar purposes
	_nCount = nCount;	
	CHECKNOERROR(pRange->SetText(bstr));

    nRet = nCount;

CleanExit:
	if (pszOut != psz)
		delete [] pszOut;

	if (bstr)
		SysFreeString(bstr);

	if (pRange)
		pRange->Release();
	return nRet;
}

/*
 *	CLstBxWinHost::LbSetSelection(long, long, int, long, long)
 *
 *	@mfunc
 *		Given the range of nStart to nEnd set the selection state of each item
 *		This function will also update the anchor and cursor position
 *		if requested.
 *
 *	@rdesc
 *		BOOL = If everything went fine ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbSetSelection(
	long nStart,
	long nEnd,
	int ffFlags,
	long nCursor,
	long nAnchor)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetSelection");

	if (!_fOwnerDraw)
	{
		Freeze();
	
		// de-select all items
		if ((ffFlags & LBSEL_RESET))
		{
			if (!ResetContent())
			{
				Unfreeze();
				return FALSE;
			}

			// Reset, check if anything else needs to be done
			// else just exit out
			if (ffFlags == LBSEL_RESET)
			{
				Unfreeze();
				return TRUE;
			}
		}
	}
	
	// NOTE:
	//	This should be one big critical section because we rely on certain
	// member variables not changing during the process of this function

	// Check if we are changing the selection and if we have focus
	// if we do then we first need to xor out the focus rect from
	// old cursor
	RECT rc;
	HDC hdc;
	hdc = TxGetDC();
	Assert(hdc);
	// don't draw outside the client rect draw the rectangle
	TxGetClientRect(&rc);
	IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

	if ((ffFlags & LBSEL_NEWCURSOR) && _fFocus && LbEnableDraw())
	{
 		// If owner draw notify parentwindow
 		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, max(_nCursor, 0), ODA_FOCUS, IsSelected(_nCursor) ? ODS_SELECTED : 0);				
 		else
 		{
 			LbGetItemRect(_nCursor, &rc);
 			::DrawFocusRect(hdc, &rc);
 		}
	}
		
	//	check if all item should be selected
	if (nStart == -1 && nEnd == 0)
	{
		nStart = 0;
		nEnd = _nCount - 1;
	}
	else if (nStart > nEnd)	
	{
		// reshuffle so nStart is <= nEnd;
		long temp = nEnd;
		nEnd = nStart;
		nStart = temp;
	}

	// Check for invalid values
	if (nStart < -1 || nEnd >= _nCount)
	{
		if (!_fOwnerDraw)
			Unfreeze();

		// mimic system listbox behaviour
		if (nEnd >= _nCount)
			return FALSE;
		else
			return TRUE;
	}

	// Prepare the state we want to be in
	unsigned int bState;	
	DWORD dwFore;
	DWORD dwBack;
	if (ffFlags & LBSEL_SELECT)
	{
		bState = ODS_SELECTED;	//NOTE ODS_SELECTED must equal 1
		dwFore = _crSelFore;
		dwBack = _crSelBack;

		if (_fSingleSel)
			nEnd = nStart;
	}
	else 
	{
		bState = 0;
		dwFore = (unsigned)tomAutoColor;
		dwBack = (unsigned)tomAutoColor;
	}

	// A little optimization check
	// Checks to see if the state is really being changed if not then don't bother
	// calling SetColor, works only when nStart == nEnd;
	// The list box will not change the background color if nSame is true
	int nSame = (nStart == nEnd && nStart != -1) ? (_rgData.Get(nStart)._fSelected == bState) : FALSE;

	BOOL bRet = TRUE;
	if (_fOwnerDraw)
	{
		if (ffFlags & LBSEL_RESET || !bState)
		{
			// There are cases where we don't necessarily reset all the items
			// in the list but rather the range which was given.  The following
			// takes care of this case
			int ff = ffFlags & LBSEL_RESET;
			int i = (ff) ? 0 : nStart;
			int nStop = (ff) ? _nCount : nEnd + 1;
		 	for (; i < nStop; i++)
		 	{
		 		// Don't unselect an item which is going to be
		 		// selected in the next for loop
		 		if (!bState || (i < nStart || i > nEnd) &&
		 			(_rgData.Get(i)._fSelected != 0))
		 		{
		 			// Only send a unselect message if the item
		 			// is viewable
		 			_rgData[i]._fSelected = 0;
			 		if (IsItemViewable(i))
			 			LbDrawItemNotify(hdc, i, ODA_SELECT, 0);			 		
			 	}
		 	}
		}

		if (bState)
		{
			// We need to loop through and notify the parent
			// The item has been deselected or selected
			for (int i = max(0, nStart); i <= nEnd; i++)
			{		
				if (_rgData.Get(i)._fSelected != 1)
				{
					_rgData[i]._fSelected = 1;
					if (IsItemViewable(i))
						LbDrawItemNotify(hdc, i, ODA_SELECT, ODS_SELECTED);					
				}
			}
		}
		
	}
	else if (!nSame)
	{
		// Update our internal records	
		for (int i = max(0, nStart); i <= nEnd; i++)
			_rgData[i]._fSelected = bState;	
		bRet = SetColors(dwFore, dwBack, nStart, nEnd);
	}

    // Update the cursor and anchor positions
	if (ffFlags & LBSEL_NEWANCHOR)
		_nAnchor = nAnchor;

	// Update the cursor position
	if (ffFlags & LBSEL_NEWCURSOR)
		_nCursor = nCursor;

	// Draw the focus rect
	if (_fFocus && LbEnableDraw())
	{
		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, _nCursor, ODA_FOCUS, ODS_FOCUS | 
 				(IsSelected(_nCursor) ? ODS_SELECTED : 0));	
 		else
 		{
			LbGetItemRect(_nCursor, &rc);
	 		::DrawFocusRect(hdc, &rc);
	 	} 		
	}

	TxReleaseDC(hdc);
		
	// This will automatically update the window
	if (!_fOwnerDraw)
	{
		Unfreeze();
		// We need to do this because we are making so many changes
		// ITextServices might get confused
		ScrollToView(GetTopIndex());		
	}
	
	return bRet;
}

/*
 *	BOOL CLstBxWinHost::IsItemViewable(int)
 *
 *	@mfunc
 *		Helper to check if the idx is in current view
 *
 *	@rdesc
 *		TRUE if it is viewable
 */
BOOL CLstBxWinHost::IsItemViewable(
	long idx)
{
	if (idx < GetTopIndex())
		return FALSE;

	if (!_fOwnerDrawVar)
		return ((idx - GetTopIndex()) * _nyItem < _rcViewport.bottom);

	BOOL fGreateThanView;

	SumVarHeight(GetTopIndex(), idx, &fGreateThanView);

	return !fGreateThanView;
}

/*
 *	CLstBxWinHost::SumVarHeight(int, int, BOOL*)
 *
 *	@mfunc
 *		Helper to sum the height from iStart to iEnd for a variable item
 *		height listbox.  If pfGreaterThanView is not NULL, then set it to TRUE
 *		once the total height is bigger than current view size.
 *
 *	@rdesc
 *		int = hights from iStart to iEnd
 */
int CLstBxWinHost::SumVarHeight(
	int		iStart,
	int		iEnd,
	BOOL	*pfGreaterThanView)
{
	RECT	rc = {0};
	int		uHeightSum = 0;

	Assert(_fOwnerDrawVar);

	if (pfGreaterThanView)
	{
		*pfGreaterThanView = FALSE;
		TxGetClientRect(&rc);
	}

	if (GetCount() <= 0)
		return 0;

	if (iStart < 0)
		iStart = 0;

	if (iEnd >= GetCount())
		iEnd = GetCount();

	Assert(iEnd >= iStart);

	for (int nIdx = iStart; nIdx < iEnd; nIdx++)
	{
		uHeightSum += _rgData[nIdx]._uHeight;
		if (pfGreaterThanView && uHeightSum > rc.bottom)
		{
			*pfGreaterThanView = TRUE;
			break;
		}
	}

	return uHeightSum;
}

/*
 * int CLstBxWinHost::PageVarHeight(int, BOOL)
 *
 *	@mfunc
 *		For variable height ownerdraw listboxes, calaculates the new iTop we must
 *		move to when paging (page up/down) through variable height listboxes.
 *
 *	@rdesc
 *		int = new iTop
 */
int CLstBxWinHost::PageVarHeight(
	int	startItem,
	BOOL fPageForwardDirection)
{
	int     i;
	int iHeight;
	RECT    rc;

	Assert(_fOwnerDrawVar);

	if (GetCount() <= 1)
		return 0;

	TxGetClientRect(&rc);
	iHeight = rc.bottom;
	i = startItem;

	if (fPageForwardDirection)
	{
		while ((iHeight >= 0) && (i < GetCount()))
			iHeight -= _rgData[i++]._uHeight;

		return ((iHeight >= 0) ? GetCount() - 1 : max(i - 2, startItem + 1));
	} 
	else 
	{
		while ((iHeight >= 0) && (i >= 0))
			iHeight -= _rgData[i--]._uHeight;

		return ((iHeight >= 0) ? 0 : min(i + 2, startItem - 1));
	}
}

/*
 * BOOL CLstBxWinHost::SetVarItemHeight(int, int)
 *
 *	@mfunc
 *		For variable height ownerdraw listboxes, setup the para height.
 *
 *	@rdesc
 *		TRUE if setup new height
 */
BOOL CLstBxWinHost::SetVarItemHeight(
	int	idx,
	int iHeight)
{
	BOOL retCode = FALSE;
	ITextPara *pPara = NULL;
	ITextRange *pRange = NULL;

	Assert(_fOwnerDrawVar);

	// Calculate the new size in points
	long lptNew = MulDiv(iHeight, 1440, W32->GetYPerInchScreenDC());

	if (GetRange(idx, idx, &pRange))
	{
		CHECKNOERROR(pRange->GetPara(&pPara));
		CHECKNOERROR(pPara->SetLineSpacing(tomLineSpaceExactly, (float)lptNew));

		_rgData[idx]._uHeight = iHeight;
		retCode = TRUE;
	}

CleanExit:
	if (pPara)
		pPara->Release();

	if (pRange)
		pRange->Release();

	return retCode;
}

/*
 * int CLstBxWinHost::GetIdxFromHeight(int)
 *
 *	@mfunc
 *		Find the idx for the given iHeight from idx 0.
 *
 *	@rdesc
 *		idx
 */
int CLstBxWinHost::GetIdxFromHeight(
	int iHeight)
{
	int	idx;
	int	iHeightSum = 0;

	Assert(_fOwnerDrawVar);

	for(idx=0; idx < _nCount; idx++)
	{
		if (iHeight < iHeightSum + (int)_rgData[idx]._uHeight)
		{
			if (iHeight != iHeightSum)
				idx++;		// partial item, get the next idx
			break;
		}
		iHeightSum += _rgData[idx]._uHeight;
	}

	idx = min(idx, _nCount-1);

	return idx;
}

/*
 *	LRESULT CLstBxWinHost::LbGetCurSel()
 *
 *	@mfunc
 *		For Single-selection LB, returns the idnex of current selected item.
 *		For multiple-selection LB, returns the index of the item that has the
 *		focus rect.
 *
 *	@rdesc
 *		current select idx
 */
LRESULT CLstBxWinHost::LbGetCurSel()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbGetCurSel");

	LRESULT lres;

	if (!IsSingleSelection() ||		// multiple-selection LB or
		IsSelected(_nCursor))		//	_nCursor is selected
		lres = _nCursor;
	else
	{
		lres = LB_ERR;
		// Check which item is selected in single-selection LB
		for (int idx=0; idx < _nCount; idx++)
		{
			if (_rgData[idx]._fSelected)
			{
				lres = idx;
				break;
			}
		}
	}
	return lres;
}

//
//	ITxNotify
//

/*
 *	CLstBxWinHost::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc	called after a change has been made to the backing store.
 */
void CLstBxWinHost::OnPostReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	_cpLastGetRange = 0;
	_nIdxLastGetRange = 0;
}

#endif // NOLISTCOMBOBOXES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\magellan.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module magellan.cpp -- Handle magellan mouse. |
 *	
 *	Magellan mouse can roll scroll and mButtonDown drag scroll.
 *
 *	History: <nl>
 *		Jon Matousek - 1996
 *		4/1/2000 KeithCu - Cleanup, coding convention, support for textflows
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */								 

#include "_common.h"

#if !defined(NOMAGELLAN)

#include "_edit.h"
#include "_disp.h"
#include "_magelln.h"

ASSERTDATA

const SHORT scrollCursors[] = 
{												// Cursor for various
	0,											//  directions.
	IDC_SCROLLNORTH,
	IDC_SCROLLSOUTH,
	IDC_SCROLLEAST,
	IDC_SCROLLNE,
	IDC_SCROLLSE,
	IDC_SCROLLWEST,
	IDC_SCROLLNW,
	IDC_SCROLLSW
};

const SHORT mDownBMPs[] =
{												// mButtonDown origin BMPs.
	0,
	IDB_1DVSCROL,
	IDB_1DHSCROL,
	IDB_2DSCROL
};

const SHORT noScrollCursors[] =
{
	0,
	IDC_NOSCROLLV,
	IDC_NOSCROLLH,
	IDC_NOSCROLLVH
};

//Convert the compass from logical to visual
const BYTE mapCursorTflowSW[] =
{
	0, 3, 6, 2, 5, 8, 1, 4, 7
};

const BYTE mapCursorTflowWN[] = 
{
	0, 2, 1, 6, 8, 7, 3, 5, 4
};

const BYTE mapCursorTflowNE[] = 
{
	0, 6, 3, 1, 7, 4, 2, 8, 5
};



BOOL CMagellan::ContinueMButtonScroll(CTxtEdit *ped, INT x, INT y)
{
	POINTUV ptuv;
	POINT ptxy = {x,y};

	ped->_pdp->PointuvFromPoint(ptuv, ptxy);

	return (_ptStart.u == ptuv.u && _ptStart.v == ptuv.v);
}

/*
 *	CMagellan::MagellanStartMButtonScroll
 *
 *	@mfunc
 *		Called when we get an mButtonDown message. Initiates tracking
 *		of the mouse which in turn will scroll at various speeds based
 *		on how far the user moves the mouse from the mDownPt.
 *
 *	@rdesc
 *		TRUE if the caller should capture the mouse.
 *
 */
BOOL CMagellan::MagellanStartMButtonScroll(CTxtEdit &ed, POINT ptxy)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanStartMButtonScroll");

	RECTUV	rc;
	BOOL	fCapture = FALSE;
	CDisplay *pdp = ed._pdp;
	POINTUV	pt;

	pdp->PointuvFromPoint(pt, ptxy);

	pdp->GetViewRect(rc);						// skip scroll bars, etc.
	if (PtInRect(&rc, pt) && !_fMButtonScroll)
	{
		fCapture				= TRUE;
		_ID_currMDownBMP		= 0;
		_fMButtonScroll			= TRUE;			// Now tracking...
		_ptStart				= pt;
		_fLastScrollWasRoll		= FALSE;		// Differentiate type.

		CheckInstallMagellanTrackTimer(ed);		// Fire up timer...
	}

	return fCapture;
}

/*
 *	CMagellan::MagellanEndMButtonScroll
 *
 *	@mfunc
 *		Finished tracking mButtonDown magellan scroll, finish up state.
 *
 */
VOID CMagellan::MagellanEndMButtonScroll(CTxtEdit &ed)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanEndMButtonScroll");

	CDisplay *pdp = ed._pdp;

	_fMButtonScroll = FALSE;
	CheckRemoveMagellanUpdaterTimer(ed);			// Remove timer...

	pdp->FinishSmoothVScroll();						// So smooth scroll stops.
	InvertMagellanDownBMP(pdp, FALSE, NULL);		// Turn it off.

	if (_MagellanMDownBMP)							// Release bitmap.
	{
		DeleteObject(_MagellanMDownBMP);
		_MagellanMDownBMP = NULL;
		_ID_currMDownBMP = 0;
	}
}

/*
 *	CMagellan::MagellanRollScroll
 *
 *	@mfunc
 *		Handle the Magellan WM_MOUSEROLLER message. This routine has global, internal
 *		state that allows the number of lines scrolled to increase if the user continues
 *		to roll the wheel in rapid succession.
 *
 */
VOID CMagellan::MagellanRollScroll (CDisplay *pdp, int direction, WORD cLines, 
			int speedNum, int speedDenom, BOOL fAdditive)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanRollScroll");

	static DWORD	lastFastRollTime;
	static int		lastDirection;
	static INT		cFastRolls;
	DWORD			tickCount = GetTickCount();

	if (!_fMButtonScroll)
	{
														// start/continue fast
		if (tickCount - lastFastRollTime <	FAST_ROLL_SCROLL_TRANSITION_TICKS			
			|| ((lastDirection ^ (direction < 0 ? -1 : 1)) == 0	// or, same sign
					&& _fLastScrollWasRoll				// and in slow.
					&& pdp->IsSmoothVScolling()))
		{
			cFastRolls++;
			if (cFastRolls > FASTER_ROLL2_COUNT)		// make faster.
				cLines <<= 1;
			else if (cFastRolls > FASTER_ROLL1_COUNT)	// make fast
				cLines += 1;
			speedNum = cLines;							// Cancel smooth
														// effect.
			lastFastRollTime = tickCount;
		}
		else
			cFastRolls = 0;

		pdp->SmoothVScroll(direction, cLines, speedNum, speedDenom, TRUE);

		_fLastScrollWasRoll = TRUE;
		lastDirection = (direction < 0) ? -1 : 1;
	}
}

/*
 *	CMagellan::CheckInstallMagellanTrackTimer
 *
 *	@mfunc
 *		Install a timing task that will allow TrackUpdateMagellanMButtonDown
 *		To be periodically called.
 *
 *	@devnote
 *		The CTxtEdit class handles all WM_TIMER dispatches, so there's glue there
 *		to call our magellan routine.
 *
 */
VOID CMagellan::CheckInstallMagellanTrackTimer (CTxtEdit &ed)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::CheckInstallMagellanTrackTimer");

	ed.TxSetTimer(RETID_MAGELLANTRACK, cmsecScrollInterval);
}

/*
 *	CMagellan::CheckRemoveMagellanUpdaterTimer
 *
 *	@mfunc
 *		Remove the timing task that dispatches to TrackUpdateMagellanMButtonDown.
 *
 */
VOID CMagellan::CheckRemoveMagellanUpdaterTimer (CTxtEdit &ed)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::CheckRemoveMagellanUpdaterTimer");

	ed.TxKillTimer(RETID_MAGELLANTRACK);
}

/*
 *	CMagellan::TrackUpdateMagellanMButtonDown
 *
 *	@mfunc
 *		After mButtonDown capture, a periodic WM_TIMER calls this from OnTxTimer(). The cursor
 *		is tracked to determine direction, speed, and in dead zone (not moving).
 *		Movement is dispacted to CDisplay. The cursor is set to the appropriate
 *		direction cusor, and the mButtonDown point BMP is drawn.
 */
VOID CMagellan::TrackUpdateMagellanMButtonDown (CTxtEdit &ed, POINT ptxy)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::TrackUpdateMagellanMButtonDown");

	RECTUV	deadZone;
	POINTUV	pt;

	LONG	inflate;

	SHORT	IDC_mScrollCursor = 0, IDC_mDeadScrollCursor = 0;

	BOOL	fDoUScroll = FALSE, fDoVScroll = FALSE;

	CDisplay *pdp = ed._pdp;
	pdp->PointuvFromPoint(pt, ptxy);

	Assert (_fMButtonScroll);

	deadZone.top = deadZone.bottom = _ptStart.v;
	deadZone.left = deadZone.right = _ptStart.u;
	inflate = pdp->LYtoDY(DEAD_ZONE_TWIPS);
	InflateRect(&deadZone, inflate, inflate);

	//
	//	Calculate direction to scroll and what cusor to display. 
	//
	//	By numbering a compass like the following, we can easily calc the index into
	//	the scrollCursors array to get the proper cursor:
	//
	//							North = 1
	//					NW = 7				NE = 4
	//				West = 6					East = 3
	//					SW = 8				SE = 5
	//							South = 2
	//
	if (pdp->IsVScrollEnabled())					// Can scroll vertically?
	{
		IDC_mDeadScrollCursor = 1;
		if (pt.v < deadZone.top || pt.v > deadZone.bottom)
		{
			fDoVScroll = TRUE;
			IDC_mScrollCursor = (pt.v < _ptStart.v) ? 1 : 2;
		}
	}

	// FUTURE (alexgo): allow magellan scrolling when no scrollbar?
	if(pdp->IsUScrollEnabled() && ed.TxGetScrollBars() & WS_HSCROLL)	// Can scroll horizontally?
	{
		IDC_mDeadScrollCursor |= 2;
		if (pt.u < deadZone.left || pt.u > deadZone.right)
		{
			fDoUScroll = TRUE;
			IDC_mScrollCursor += (pt.u < _ptStart.u) ? 6 : 3;
		}
	}

	//Convert cursors from logical to visual
	switch(pdp->GetTflow())
	{
	case tflowSW:
		IDC_mScrollCursor = mapCursorTflowSW[IDC_mScrollCursor];
		break;
	case tflowWN:
		IDC_mScrollCursor = mapCursorTflowWN[IDC_mScrollCursor];
		break;
	case tflowNE:
		IDC_mScrollCursor = mapCursorTflowNE[IDC_mScrollCursor];
		break;
	}

	if (IsUVerticalTflow(pdp->GetTflow()))
	{
		if (IDC_mDeadScrollCursor == 2)
			IDC_mDeadScrollCursor = 1;
		else if (IDC_mDeadScrollCursor == 1)
			IDC_mDeadScrollCursor = 2;
	}
		

	//Review (keithcu) A little goofy...
	IDC_mScrollCursor = scrollCursors[IDC_mScrollCursor];

	if (mDownBMPs[IDC_mDeadScrollCursor] != _ID_currMDownBMP)
	{
		if (_MagellanMDownBMP)						// Undraw old BMP.
		{
			InvertMagellanDownBMP(pdp, FALSE, NULL);
			DeleteObject (_MagellanMDownBMP);
			_MagellanMDownBMP = NULL;
		}
													// Draw new BMP.
		_ID_currMDownBMP = mDownBMPs[IDC_mDeadScrollCursor];
		_MagellanMDownBMP = LoadBitmap (hinstRE, MAKEINTRESOURCE (_ID_currMDownBMP));
		InvertMagellanDownBMP(pdp, TRUE, NULL);
	}

													// Moved out of dead zone?
	if (fDoVScroll || fDoUScroll)					//  time to scroll...
	{				
		RECTUV rcClient;
		POINTUV ptCenter, ptAuto;
		ed.TxGetClientRect(&rcClient);				// Get our client rect.
		LONG dupClient = rcClient.right - rcClient.left;
		LONG dvpClient = rcClient.bottom - rcClient.top;

		ptCenter.u = rcClient.left + (dupClient >> 1);
		ptCenter.v = rcClient.top + (dvpClient >> 1);

		LONG uInset = (dupClient >> 1) - 2;			// Get inset to center

													// Map origin to rcClient.
		LONG dup = pt.u - _ptStart.u;
		LONG dvp = pt.v - _ptStart.v;

		ptAuto.u = ptCenter.u + dup;
		ptAuto.v = ptCenter.v + dvp;

		// This formula is a bit magical, but here goes.  What
		// we want is the sub-linear part of an exponential function.
		// In other words, smallish distances should produce pixel
		// by pixel scrolling.
		//
		// So the formula we use is (x^2) / dvpClient, where x is dvpClient scaled
		// to be in units of dvpClient (i.e. 5yDiff/2).   The final 10* 
		// multiplier is to shift all the values leftward so we can
		// do this in integer arithmetic.
		LONG num = MulDiv(10 * 25 * dvp, dvp, dvpClient * 4);

		if(!num)
			num = 1;

		if (fDoVScroll)
			pdp->SmoothVScroll(_ptStart.v - pt.v, 0, num, 10 * dvpClient, FALSE);
												
		if (fDoUScroll)								// u direction scrolling?
		{										
			ptAuto.v = ptCenter.v;					// Prevent v dir scrolling.
													// Do u dir scroll.
			pdp->AutoScroll(ptAuto, uInset, 0);
		}

		// notify through the messagefilter that we scrolled
		if ((ed._dwEventMask & ENM_SCROLLEVENTS) && (fDoUScroll || fDoVScroll))
		{
			MSGFILTER msgfltr;
			ZeroMemory(&msgfltr, sizeof(MSGFILTER));

			if (fDoUScroll)
			{
				msgfltr.msg = WM_HSCROLL;
				msgfltr.wParam = (dup > 0 ? SB_LINERIGHT : SB_LINELEFT);
				ed._phost->TxNotify(EN_MSGFILTER, &msgfltr);			

			}
			if (fDoVScroll)
			{
				msgfltr.msg = WM_VSCROLL;
				msgfltr.wParam = (dvp > 0 ? SB_LINEDOWN : SB_LINEUP);
				ed._phost->TxNotify(EN_MSGFILTER, &msgfltr);			
			}

		}
	}
	else									// No scroll in dead zone.
	{												
		IDC_mScrollCursor = noScrollCursors[IDC_mDeadScrollCursor];
		pdp->FinishSmoothVScroll();			// Finish up last line.
	}

	ed._phost->TxSetCursor(IDC_mScrollCursor ? 
		LoadCursor(hinstRE, MAKEINTRESOURCE(IDC_mScrollCursor)) : ed._hcurArrow, FALSE);
}



/*
 *	BOOL CMagellan::InvertMagellanDownBMP
 *
 *	@mfunc
 *		Magellan mouse UI requires that the mouse down point draw
 *		and maintain a bitmap in order to help the user control scroll speed.
 *
 *	@devnote
 *		This routine is designed to be nested. It also handles WM_PAINT updates
 *		when the repaintDC is passed in. Because there is no support for multiple
 *		cursors in the operating system, all WM_PAINT and ScrollWindow redraws
 *		must temporarily turn off the BMP and then redraw it. This gives the
 *		BMAP a flicker.
 *
 *	@rdesc
 *		TRUE if the bitmap was previously drawn.
 */
BOOL CMagellan::InvertMagellanDownBMP(CDisplay *pdp, BOOL fTurnOn, HDC repaintDC)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::InvertMagellanDownBMP");

	BOOL	fOldState = _fMagellanBitMapOn;

	Assert (pdp);

	if (fOldState != fTurnOn)
	{
		if (_MagellanMDownBMP)
		{
			BITMAP	bm;
			HDC		hdcMem, screenDC;
			POINT	ptSize, ptOrg;

			screenDC = (repaintDC != NULL) ? repaintDC : pdp->GetDC();
			if (screenDC)
			{
				hdcMem = CreateCompatibleDC(screenDC);
				if (hdcMem)
				{
					SelectObject(hdcMem, _MagellanMDownBMP);

					if (W32->GetObject(_MagellanMDownBMP, sizeof(BITMAP), &bm))
					{
						ptSize.x = bm.bmWidth;
						ptSize.y = bm.bmHeight;
						DPtoLP(screenDC, &ptSize, 1);
						ptOrg.x = 0;
						ptOrg.y = 0;
						DPtoLP(hdcMem, &ptOrg, 1);

						POINT ptBitmap;
						pdp->PointFromPointuv(ptBitmap, _ptStart);
						BitBlt(screenDC,
							ptBitmap.x - (ptSize.x >> 1) - 1,
							ptBitmap.y - (ptSize.y >> 1) + 1,
							ptSize.x, ptSize.y,
							hdcMem, ptOrg.x, ptOrg.y, 0x00990066 /* NOTXOR */);
							
						_fMagellanBitMapOn = !fOldState;
					}
					DeleteDC(hdcMem);
				}
				if (repaintDC == NULL) 
					pdp->ReleaseDC(screenDC);
			}
		}
	}

	return fOldState;
}

////////////////////////// 	CMagellanBMPStateWrap class.

/*
 *	CMagellanBMPStateWrap:: CMagellanBMPStateWrap
 *
 *	@mfunc
 *		Handles the state of whether to redraw the Magellan BMP as well as
 *		repaints due to WM_PAINT.
 *
 *	@devnote
 *		This class is akin to smart pointer wrapper class idioms, in that
 *		no matter how a routine exits the correct state of whether the
 *		BMP is drawn will be maintined.
 */
CMagellanBMPStateWrap:: CMagellanBMPStateWrap(CTxtEdit &ed, HDC repaintDC)
	: _ed(ed), _repaintDC(repaintDC)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellanBMPStateWrap:: CMagellanBMPStateWrap");

	BOOL fRepaint;

	fRepaint = repaintDC != NULL && _ed.mouse._fMagellanBitMapOn != 0;
	_fMagellanState = fRepaint || _ed.mouse.InvertMagellanDownBMP(_ed._pdp, FALSE, NULL);
	_ed.mouse._fMagellanBitMapOn = FALSE;
}

CMagellanBMPStateWrap::~CMagellanBMPStateWrap()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellanBMPStateWrap::~CMagellanBMPStateWrap");

	_ed.mouse.InvertMagellanDownBMP(_ed._pdp, _fMagellanState, _repaintDC);
}

#endif // !defined(NOMAGELLAN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\ldte.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LDTE.C - RichEdit Light Data Transfer Engine |
 *
 *		This file contains data transfer code using IDataObject
 *
 *	Author: <nl>
 *		alexgo (4/25/95)
 *
 *	Revisions: <nl>
 *		murrays (7/6/95) auto-doc'd and added RTF support
 *
 *	FUTURE (AlexGo): <nl>
 *		Maybe merge this class with CTxtRange to make more efficient use of
 *		the this ptr.  All but two methods use a CTxtRange and one of these
 *		could be global.  The two are:
 *
 *		GetDropTarget( IDropTarget **ppDropTarget )
 *		GetDataObjectInfo(IDataObject *pdo, DWORD *pDOIFlags) // Can be global
 *
 *		In general, a range can spawn data objects, which need to have a clone
 *		of the range in case the range is moved around.  The contained range
 *		is used for delayed rendering.  A prenotification is sent to the data
 *		object just before the data object's data is to be changed.  The data
 *		object then renders the data in its contained range, whereupon the
 *		object becomes independent of the range and destroys the range.
 *
 *	@devnote
 *		We use the word ANSI in a general way to mean any multibyte character
 *		system as distinguished from 16-bit Unicode.  Technically, ANSI refers
 *		to a specific single-byte character system (SBCS).  We translate
 *		between "ANSI" and Unicode text using the Win32
 *		MultiByteToWideChar() and WideCharToMultiByte() APIs.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_ldte.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_edit.h"
#include "_disp.h"
#include "_select.h"
#include "_dragdrp.h"
#include "_dxfrobj.h"
#include "_rtfwrit.h"
#include "_rtfread.h"
#include "_urlsup.h"

ASSERTDATA


//Local Prototypes
DWORD CALLBACK WriteHGlobal(WRITEHGLOBAL *pwhg, LPBYTE pbBuff, LONG cb, LONG *pcb);

#define	SFF_ADJUSTENDEOP	0x80000000

#define FMITAL	(FMATHITAL >> 24)
#define FMBOLD	(FMATHBOLD >> 24)
#define FMSCRP	(FMATHSCRP >> 24)
#define FMFRAK	(FMATHFRAK >> 24)
#define FMOPEN	(FMATHOPEN >> 24)
#define FMSANS	(FMATHSANS >> 24)
#define FMMONO	(FMATHMONO >> 24)

#if FMITAL != 0x02 || FMBOLD != 0x04 || FMSCRP != 0x08 || FMFRAK != 0x10 || FMOPEN != 0x20 || FMSANS != 0x40 || FMMONO != 0x80
#error "Need to change >> 24 (and << 24) below"
#endif

//
// LOCAL METHODS
//

/*
 *	ReadHGlobal(dwCookie, pbBuff, cb, pcb)
 *
 *	@func
 *		EDITSTREAM callback for reading from an hglobal
 *
 *	@rdesc
 *		es.dwError
 */
DWORD CALLBACK ReadHGlobal(
	DWORD_PTR	dwCookie,		// @parm dwCookie
	LPBYTE	pbBuff,				// @parm Buffer to fill
	LONG	cb,					// @parm Buffer length
	LONG *	pcb)				// @parm Out parm for # bytes stored
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "ReadHGlobal");

	READHGLOBAL * const prhg = (READHGLOBAL *)dwCookie;

	cb = min(cb, prhg->cbLeft);
	CopyMemory(pbBuff, prhg->ptext, cb);
	prhg->cbLeft -= cb;
	prhg->ptext  += cb;

	if(pcb)
		*pcb = cb; 
	return NOERROR;	
}

/*
 *	WriteHGlobal(pwhg, pbBuff, cb, pcb)
 *
 *	@func
 *		EDITSTREAM callback for writing ASCII to an hglobal
 *
 *	@rdesc
 *		error (E_OUTOFMEMORY or NOERROR)
 */
DWORD CALLBACK WriteHGlobal(
	DWORD_PTR	dwCookie,		// @parm dwCookie
	LPBYTE	pbBuff,				// @parm Buffer to write from
	LONG	cb,					// @parm Buffer length
	LONG *	pcb)				// @parm Out parm for # bytes written
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "WriteHGlobal");

	WRITEHGLOBAL * const pwhg = (WRITEHGLOBAL *)dwCookie;

	HGLOBAL		hglobal = pwhg->hglobal;
	LPSTR		pstr;

	if(pwhg->cch + cb > pwhg->cb)			// Less than requested cb in
	{										//  current Alloc
		ULONG cbNewSize = GROW_BUFFER(pwhg->cb, cb);
		hglobal = GlobalReAlloc(hglobal, cbNewSize, GMEM_MOVEABLE);
		if(!hglobal)	
			return (DWORD)E_OUTOFMEMORY;
		pwhg->hglobal = hglobal;			// May be superfluous...
		pwhg->cb = cbNewSize;
	}
	pstr = (LPSTR)GlobalLock(hglobal);
	if(!pstr)
		return (DWORD)E_OUTOFMEMORY;

	CopyMemory(pstr + pwhg->cch, pbBuff, cb);
	GlobalUnlock(hglobal);
	pwhg->cch += cb;
	if(pcb)
		*pcb = cb; 
	return NOERROR;	
}


//
// PUBLIC METHODS
//

/*
 *	GetCharFlags(pch, cchPch, iCharRepDefault)
 *
 *	@func
 *		Return principle character flags corresponding to character *pch.
 *		Note that if *pch is a Unicode surrogate-pair lead word, then
 *		*(pch + 1) is used as the trail word. Note also that only math
 *		fonts return more than one flag. The values follow the Unicode
 *		Standard Version 3.0 with some extensions beyond that standard
 *		(limited plane-2 support and plane-1 math alphanumerics).
 *
 *	@rdesc
 *		Principle char flag corresponding to *pch.
 *
 *		=FUTURE= should be constructed as a 2-level lookup.
 */
QWORD GetCharFlags(
	const WCHAR *pch,			//@parm Gives char to get flag for
	LONG	cch,				//@parm cch of valid chars in pch
	BYTE	iCharRepDefault)	//@parm Default charrep in FE heuristics
{
	WCHAR ch = *pch;

	if(ch < 0x100)						// Latin1: divide into 3 bits
		return	ch > 0x7F ? FHILATIN1 : 
				ch < 0x40 ? FBELOWX40 : FASCIIUPR;

	if(ch < 0x590)
	{
		if(ch >= 0x530)
			return FARMENIAN;

		if(ch >= 0x492)
			return FOTHER;				// Extended Cyrillic

		if(ch >= 0x400)
			return FCYRILLIC;

		if(ch >= 0x370)
			return FGREEK;

		if(ch >= 0x300)					// Combining diacritical marks
			return FCOMBINING;			

		return (ch < 0x250) ? FLATIN2 : FOTHER;
	}
	// Complex scripts start at 0x590 with Hebrew (aside from combining)
	if(ch <= 0x11FF)					// Complex scripts end at 0x11FF
	{									//  (at least in July, 2000)
		if(ch < 0x900)
		{
			return (ch < 0x600 ? FHEBREW :
					ch < 0x700 ? FARABIC :
					ch < 0x750 ? FSYRIAC : 
					ch < 0x780 ? FRTL :
					ch < 0x7C0 ? FTHAANA : FRTL);
		}
		if(ch < 0xE00)					// 0x900 - 0xDFF: Indic scripts
			return FontSigFromCharRep(DEVANAGARI_INDEX + ((ch - 0x900) >> 7));

		if(ch < 0xF00)
			return ch < 0xE80 ? FTHAI : FLAO;

		if(ch < 0x1000)
			return ch < 0xFC0 ? FTIBETAN : FOTHER;

		if(ch < 0x1100)
			return ch < 0x10A0 ? FMYANMAR : FGEORGIAN;

		return FJAMO;
	}

	DWORD dwCharFlags = 0;
	if(ch < 0x3100)
	{
		if(ch >= 0x3000)
		{
			if(ch > 0x3040)
				return FKANA;
			goto CLASSIFY_CHINESE;
		}
		if(ch < 0x18AF)
		{
			Assert(ch >= 0x1200);

			if(ch <= 0x137F)
				return FETHIOPIC;

			if(IN_RANGE(0x13A0, ch, 0x16F0))
			{
				return ch < 0x1400 ? FCHEROKEE :
					   ch < 0x1680 ? FABORIGINAL :
					   ch < 0x16A0 ? FOGHAM : FRUNIC;
			}
			if(IN_RANGE(0x1780, ch, 0x18AF))
				return ch < 0x1800 ? FKHMER : FMONGOLIAN;

			return FOTHER;
		}

		if(IN_RANGE(RTLMARK, ch, 0x202E) && (ch == RTLMARK ||
			IN_RANGE(0x202A, ch, 0x202E)))
		{
			return FRTL;
		}

		if(ch == EURO || ch == 0x2122)			// Euro or TM
			return FHILATIN1;

		if(ch == 0x20AA)						// Hebrew currency sign
			return FHEBREW;

		if(W32->IsFESystem() || IsFECharRep(iCharRepDefault) || IN_RANGE(0x2460, ch, 0x24FF))
			goto CLASSIFY_CHINESE;

		if(IN_RANGE(0x200b, ch, 0x200d))		// ZWSP, ZWNJ, ZWJ
			return FUNIC_CTRL;

		if(ch == 0x2016 || ch == 0x2236)
		{
			// Some hack to make Word2000 happy
			if(VerifyFEString(CP_CHINESE_TRAD, &ch, 1, TRUE) == CP_CHINESE_TRAD)   
				return FBIG5;
			
			if(VerifyFEString(CP_CHINESE_SIM,  &ch, 1, TRUE) == CP_CHINESE_SIM)
				return FCHINESE;
		}
		if(IN_RANGE(0x2800, ch, 0x28FF))
			return FBRAILLE;

		return FOTHER;
	}
	if(ch < 0xD800)
	{		
		Assert(ch >= 0x3100);
		if(ch < 0x3400)
		{
			if(ch < 0x3130)						// Bopomofo annotation chars
			{									//  used in Chinese text
				return (W32->GetFEFontInfo() == BIG5_INDEX)
						? FBIG5 : FCHINESE;
			}
			if (ch < 0x3190 ||					// Hangul Compatibility Jamo
				IN_RANGE(0x3200, ch, 0x321F) ||	// Parenthesized Hangul
				IN_RANGE(0x3260, ch, 0x327F))	// Circled Hangul
			{
				return FHANGUL;
			}
			if(IN_RANGE(0x32D0, ch, 0x337F))	// Circled & Squared Katakana words
				return FKANA;
		}

		if(ch < 0x04DFF)
			return FOTHER;

		if(ch < 0xA000)
			goto CLASSIFY_CHINESE;

		if(ch < 0xA4D0)
			return FYI;

		if(ch < 0xAC00)
			goto CLASSIFY_CHINESE;

		return FHANGUL;
	}

	if(ch < 0xE000)
	{
		if(cch > 1 && IN_RANGE(UTF16_LEAD, ch, UTF16_TRAIL - 1))
		{
			pch++;
			if(IN_RANGE(UTF16_TRAIL, *pch, UTF16_TRAIL + 1023))
			{
				LONG lch = (*pch & 0x3FF) + ((ch & 0x3FF) << 10) + 0x10000;
				/* For testing purposes, implement math alphanumerics. Block
				 * starts with thirteen 52-char English alphabets, five 58-char
				 * Greek alphabets (2*24 + 10 variants), and ended with five
				 * 10-char digits as given by the following table (E - English,
				 * D - digit, G - Greek):
				 *
				 *  1) Math bold (EGD)			 2) Math italic (E) 
				 *  3) Math bold italic (EG)	 4) Math script (E)
				 *  5) Math script bold (E)		 6) Math fraktur (E)
				 *  7) Math fraktur bold (E)	 8) Math open-face (ED)
				 *  9) Math sans (ED)			10) Math sans bold (EGD)
				 * 11) Math sans italic (E)		12)	Math sans bold italic (EG)
				 * 13) Math monospace (ED)
				 */
				static BYTE rgFsE[] = {
					FMBOLD, FMITAL, FMBOLD + FMITAL, FMSCRP, FMSCRP + FMBOLD,
					FMFRAK, FMFRAK + FMBOLD, FMOPEN, FMSANS, FMSANS + FMBOLD,
					FMSANS + FMITAL, FMSANS + FMBOLD + FMITAL, FMMONO};

				static BYTE rgFsG[] = {
					FMBOLD, FMITAL, FMBOLD + FMITAL, FMSANS + FMBOLD,
					FMSANS + FMBOLD + FMITAL};

				static BYTE rgFsD[] = {
					FMBOLD, FMOPEN, FMSANS, FMSANS + FMBOLD, FMMONO};

				if(IN_RANGE(0x1D400, lch, 0x1D7FF))
				{
					lch -= 0x1D400;				// Sub math-alphanumerics origin
					if(lch < 13*52)				// 13 English alphabets
						return FSURROGATE + FASCIIUPR + (rgFsE[lch/52] << 24);

					lch -= 13*52;
					if(lch < 5*58)				// 5 Greek alphabets
						return FSURROGATE + FGREEK + (rgFsG[lch/58] << 24);

					lch -= 5*58 + (1024 - 5*58 - 13*52 - 5*10);
					if(lch >= 0)				// 5 digit groups
						return FSURROGATE + FBELOWX40 + (rgFsD[lch/10] << 24);
				}
				if(IN_RANGE(0x20000, lch, 0x2FFFF))	// Plane 2: Extension B
				{									//  CJK characters
					dwCharFlags = FSURROGATE;
					goto CLASSIFY_CHINESE;
				}
			}
		}
		return FSURROGATE;						// Surrogate
	}

	if(ch < 0xF900)								// Private Use Area
	{
		if(IN_RANGE(0xF020, ch, 0xF0FF))
			return FSYMBOL;

		return FOTHER;
	}

	if(ch < 0xFF00)
	{
		if(IN_RANGE(0xFE30, ch, 0xFE4F))		// CJK Vertical variants
			goto CLASSIFY_CHINESE;	

		if(IN_RANGE(0xF900, ch, 0xFAFF))		// CJK characters
			goto CLASSIFY_CHINESE;	

		return FOTHER;
	}

	if(IN_RANGE(0xFF00, ch, 0xFFEF))		
	{										
		if (ch < 0xFF60 || ch >= 0xFFE0 ||		// Fullwidth ASCII or Fullwidth symbols
			ch == 0xFF64)						// special case Half-width ideographic comma
			goto CLASSIFY_CHINESE;		
							
		return ch < 0xFFA0 ? FKANA : FHANGUL;	// Halfwidth Katakana/Hangul		
	}
	return FOTHER;


CLASSIFY_CHINESE:
	if(IN_RANGE(JPN2_INDEX, iCharRepDefault, CHT2_INDEX))
		iCharRepDefault -= JPN2_INDEX - SHIFTJIS_INDEX;

	if(IN_RANGE(SHIFTJIS_INDEX, iCharRepDefault, BIG5_INDEX))
	{
CLASS2:
		LONG dIndex = iCharRepDefault - SHIFTJIS_INDEX;
		if(!dwCharFlags)
			return (DWORD)FKANA << dIndex;

		union									// Plane 2
		{										// Endian-dependent way to
			QWORD qw;							//  avoid 64-bit left shift
			DWORD dw[2];
		};
		dw[0] = FSURROGATE;
		dw[1] = (DWORD)(FJPN2 >> 32) << dIndex;
		return qw;
	}

	iCharRepDefault = W32->GetFEFontInfo();

	if(IN_RANGE(SHIFTJIS_INDEX, iCharRepDefault, BIG5_INDEX))
		goto CLASS2;

	return FCHINESE;
}

/*
 *	CLightDTEngine::CLightDTEngine()
 *
 *	@mfunc
 *		Constructor for Light Data Transfer Engine
 */
CLightDTEngine::CLightDTEngine()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CLightDTEngine");

	_ped = NULL;
	_pdt = NULL;
	_pdo = NULL;
	_fUseLimit = FALSE;
	_fOleless = FALSE;
}

/*
 *	CLightDTEngine::~CLightDTEngine 
 *
 *	@mfunc
 *		Handles all necessary clean up for the object.
 */
CLightDTEngine::~CLightDTEngine()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::~CLightDTEngine");

	if( _pdt )
	{
		_pdt->Zombie();
		_pdt->Release();
		_pdt = NULL;
	}
	Assert(_pdo == NULL);
}

/*
 *	CLightDTEngine::Destroy()
 *
 *	@mfunc
 *		Deletes this instance
 */
void CLightDTEngine::Destroy()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::Destroy");

	delete this;
}

/*
 *	CLightDTEngine::CopyRangeToClipboard ( prg, lStreamFormat )
 *
 *	@mfunc
 *		Copy the text of the range prg to the clipboard using Win32 APIs
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::CopyRangeToClipboard(
	CTxtRange *prg,				//@parm Range to copy to clipboard
	LONG	   lStreamFormat)	//@parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CopyRangeToClipboard");

	HRESULT hresult = E_FAIL;
	IDataObject *pdo = NULL;
	IRichEditOleCallback * precall = _ped->GetRECallback();
	BOOL fSingleObject;
	CHARRANGE chrg;

	prg->GetRange(chrg.cpMin, chrg.cpMost);

	if (chrg.cpMin >= chrg.cpMost)
	{
		// We can't copy an insertion point to the clipboard so we are done.
		return NOERROR;
	}

	fSingleObject = chrg.cpMost - chrg.cpMin == 1 &&
		_ped->HasObjects() &&
		_ped->_pobjmgr->CountObjectsInRange(chrg.cpMin, chrg.cpMost);
	if(precall)
	{
		// Give the callback a chance to give us its own IDataObject
		hresult = precall->GetClipboardData(&chrg, RECO_COPY, &pdo);
	}

	// If we didn't get an IDataObject from the callback, build our own
	if(hresult != NOERROR)
	{
		// If the range is empty, don't bother creating it.  Just
		// leave the clipboard alone and return
		if( prg->GetCch() == 0 )
		{
			_ped->Beep();
			return NOERROR;
		}

		hresult = RangeToDataObject(prg, SF_TEXT | SF_RTF | lStreamFormat, &pdo);
	}

	// NB: it's important to check both hresult && pdo; it is legal for
	// our client to say "yep, I handled the copy, but there was nothing
	// to copy".
	if( hresult == NOERROR && pdo )
	{
		hresult = OleSetClipboard(pdo);
		if( hresult != NOERROR )
		{
			HWND hwnd;
			_fOleless = TRUE;
			// Ole less clipboard support
			if (_ped->TxGetWindow(&hwnd) == NOERROR &&
				::OpenClipboard(hwnd) &&
				::EmptyClipboard()
			)
			{
				::SetClipboardData(cf_RTF, NULL);

				::SetClipboardData(CF_UNICODETEXT, NULL);
				if(_ped->IsDocMoreThanLatin1Symbol())
				{
					::SetClipboardData(cf_RTFUTF8, NULL);
					::SetClipboardData(cf_RTFNCRFORNONASCII, NULL);
				}
				::SetClipboardData(CF_TEXT, NULL);

				if (fSingleObject)
					::SetClipboardData(CF_DIB, NULL);
				::CloseClipboard();
				hresult = NOERROR;				// To cause replace range to happen
			}
		}
        if(_pdo)
			_pdo->Release();
		_pdo = pdo;
	}
	return hresult;
}

/* 
 *	CLightDTEngine::CutRangeToClipboard( prg, lStreamFormat, publdr );
 *	
 *	@mfunc
 *		Cut text of the range prg to the clipboard
 *
 *	@devnote
 *		If publdr is non-NULL, antievents for the cut operation should be
 *		stuffed into this collection
 *
 *	@rdesc
 *		HRESULT from CopyRangeToClipboard()
 *
 *	@devnote
 *		First copy the text to the clipboard, then delete it from the range
 */
HRESULT CLightDTEngine::CutRangeToClipboard(
	CTxtRange *	  prg,				//@parm Range to cut to clipboard
	LONG		  lStreamFormat,	//@parm Stream format
	IUndoBuilder *publdr )			//@parm Undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CutRangeToClipboard");

	Assert(!_ped->TxGetReadOnly());

	prg->AdjustEndEOP(NONEWCHARS);				// Don't include trailing EOP
												//  in some selection cases
	HRESULT hr = CopyRangeToClipboard(prg, lStreamFormat);

	if( publdr )
	{
		publdr->SetNameID(UID_CUT);
		publdr->StopGroupTyping();
	}

	if(hr == NOERROR)							// Delete contents of range
		prg->Delete(publdr, SELRR_REMEMBERRANGE);	

	return hr;
}

/*
 *	CLightDTEngine::FlushClipboard()
 *
 *	@mfunc	flushes the clipboard (if needed).  Typically called during
 *			shutdown.
 */
void CLightDTEngine::FlushClipboard()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::FlushClipboard");
	ENSAVECLIPBOARD ens;

	if( _pdo )
	{
		if( OleIsCurrentClipboard(_pdo) == NOERROR )
		{
			CDataTransferObj *pdo = NULL;

			// check to see if we have to flush the clipboard.
			ZeroMemory(&ens, sizeof(ENSAVECLIPBOARD));

			// check to make sure the object is one of ours before accessing
			// the memory.  EVIL HACK ALERT.  'nuff said.

			if( _pdo->QueryInterface(IID_IRichEditDO, (void **)&pdo ) 
				== NOERROR && pdo  )
			{
				ens.cObjectCount = pdo->_cObjs;
				ens.cch = pdo->_cch;
				pdo->Release();
			}

			if( _ped->TxNotify(EN_SAVECLIPBOARD, &ens) == NOERROR )
				OleFlushClipboard();

			else
				OleSetClipboard(NULL);
		}
		_pdo->Release();
		_pdo = NULL;
	}
}

/*
 *	CLightDTEngine::CanPaste(pdo, cf, flags)
 *
 *	@mfunc
 *		Determines if clipboard format cf is one we can paste.
 *
 *	@rdesc
 *		BOOL - true if we can paste cf into range prg OR DF_CLIENTCONTROL
 *		if the client is going to handle this one.
 *
 *	@devnote
 *		we check the clipboard ourselves if cf is 0. Primarily, this
 *		is for backwards compatibility with Richedit1.0's EM_CANPASTE
 *		message.
 *
 */
DWORD CLightDTEngine::CanPaste(
	IDataObject *pdo,	// @parm Data object to check; if NULL use clipboard
	CLIPFORMAT cf, 		// @parm Clipboard format to query about; if 0, use
						//		 best available.
	DWORD flags)		// @parm Flags 
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CanPaste");

	IRichEditOleCallback *precall = _ped->GetRECallback();
	CLIPFORMAT	cf0 = cf;
	DWORD		cFETC = CFETC;
	HRESULT		hr = NOERROR;
	DWORD		ret = FALSE;

	if( pdo == NULL && precall )
	{
		// don't worry about errors
		OleGetClipboard(&pdo);
	}
	else if( pdo )
	{
		// So we can make just one 'Release' call below
		pdo->AddRef();
	}
	
	if( precall && pdo )
	{
		hr = precall->QueryAcceptData(pdo, &cf, flags, 0, NULL);

		if( SUCCEEDED(hr) && (hr != S_OK && hr != DATA_S_SAMEFORMATETC ) )
		{
			ret = DF_CLIENTCONTROL;
			goto Exit;
		}
		else if( FAILED(hr) && hr != E_NOTIMPL )
			goto Exit;

		else if(SUCCEEDED(hr))
		{
			// We should go on and check ourselves unless the client
			// modified the format when it shouldn't have
			if(cf0 && cf0 != cf)
				goto Exit;
		}

		// Otherwise, continue with our normal checks
	}

    if(_ped->TxGetReadOnly())		    // Can't paste if read only
		goto Exit;

	while(cFETC--)						// Does cf = format we can paste or
	{									//  is selection left up to us?
		cf0 = g_rgFETC[cFETC].cfFormat;
	    if( cf == cf0 || !cf )
		{
			// Either we hit the format requested, or no format was
			// requested.  Now see if the format matches what we can
			// handle in principle. There are three basic categories:
			//
			//		1. Rich text with OLE callback:
			//		   can handle pretty much everything.
			//		2. Rich text with no OLE callback:
			//		   can handle anything but OLE specific	formats.
			//		3. Plain text only:
			//		   can only handle plain text formats.
			if ((_ped->_fRich || (g_rgDOI[cFETC] & DOI_CANPASTEPLAIN)) &&
				(precall || !(g_rgDOI[cFETC] & DOI_CANPASTEOLE)))
			{
				// once we get this far, make sure the data format
				// is actually available.
				if( (pdo && pdo->QueryGetData(&g_rgFETC[cFETC]) == NOERROR ) ||
					(!pdo && IsClipboardFormatAvailable(cf0)) )
				{
					ret = TRUE;			// Return arbitrary non zero value.
					break;
				}
			}
		}
    }	

Exit:
	if(pdo)
		pdo->Release();

	return ret;
}

/*
 *	CLightDTEngine::RangeToDataObject (prg, lStreamFormat, ppdo)
 *
 *	@mfunc
 *		Create data object (with no OLE-formats) for the range prg
 *
 *	@rdesc
 *		HRESULT	= !ppdo ? E_INVALIDARG :
 *				  pdo ? NOERROR : E_OUTOFMEMORY
 */
HRESULT CLightDTEngine::RangeToDataObject(
	CTxtRange *		prg,			// @parm Range to get DataObject for
	LONG			lStreamFormat,	// @parm Stream format to use for loading
	IDataObject **	ppdo)			// @parm Out parm for DataObject
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::RangeToDataObject");

	if(!ppdo)
		return E_INVALIDARG;

	// Use SFF_SELECTION to indicate that this isn't used to write the whole doc.
	// Need to rethink if we add ITextDocument::Copy(), which would be used to
	// copy the whole doc.
	CDataTransferObj *pdo = CDataTransferObj::Create(_ped, prg, lStreamFormat | SFF_SELECTION);

	*ppdo = pdo;
	return pdo ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CLightDTEngine::RenderClipboardFormat(wFmt)
 *
 *	@mfunc
 *		Renders current clipboard data object in specified format. (Ole less transfer)
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::RenderClipboardFormat(
	WPARAM wFmt)
{
	HRESULT hr = S_OK;
	if (_fOleless && 
		(wFmt == cf_RTF || wFmt == CF_UNICODETEXT || wFmt == CF_DIB || wFmt == CF_TEXT))
	{
		Assert(_pdo);
		STGMEDIUM med;
		DWORD iFETC = iUnicodeFETC;

		if (wFmt == cf_RTF)
			iFETC = iRtfFETC;

		else if (wFmt == CF_DIB)
			iFETC = iDIB;

		else if (wFmt == CF_TEXT)
			iFETC = iAnsiFETC;

		med.tymed = TYMED_HGLOBAL;
		med.pUnkForRelease = NULL;
		med.hGlobal = NULL;
		hr = _pdo->GetData(&g_rgFETC[iFETC], &med);
		hr = hr || ::SetClipboardData(wFmt, med.hGlobal) == NULL;
	}
	return hr;								// Pretend we did the right thing.
}

/*
 *	CLightDTEngine::RenderAllClipboardFormats()
 *
 *	@mfunc
 *		Renders current clipboard data object (text and RTF). (Ole less transfer)
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::RenderAllClipboardFormats()
{
	HRESULT hr;
	if(_fOleless)
	{
		HWND howner = ::GetClipboardOwner();
		HWND hwnd;
		if (howner &&
			_ped->TxGetWindow(&hwnd) == NOERROR &&
			howner == hwnd &&
			::OpenClipboard(hwnd))
		{
			::EmptyClipboard();
			hr = RenderClipboardFormat(cf_RTF);
			hr = hr || RenderClipboardFormat(CF_UNICODETEXT);
			hr = hr || RenderClipboardFormat(CF_DIB);
			hr = hr || RenderClipboardFormat(CF_TEXT);
			::CloseClipboard();
			return hr;
		}
	}
	return S_OK;		// Pretend we did the right thing.
}

/*
 *	CLightDTEngine::DestroyClipboard()
 *
 *	@mfunc
 *		Destroys the clipboard data object
 *
 *	@rdesc
 *		HRESULT
 *
 */
HRESULT CLightDTEngine::DestroyClipboard()
{
	// Nothing to do.  This should work together with our Flush clipboard logic
	return S_OK;
}

/*
 *	CLightDTEngine::HGlobalToRange(dwFormatIndex, hGlobal, ptext, prg, publdr)
 *
 *	@mfunc
 *		Copies the contents of the given string (ptext) to the given range.
 *		The global memory handle may or may not point to the string depending
 *		on the format
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::HGlobalToRange(
	DWORD		dwFormatIndex,
	HGLOBAL		hGlobal,
	LPTSTR		ptext,
	CTxtRange *	prg,
	IUndoBuilder *publdr)
{
	READHGLOBAL	rhg;
	EDITSTREAM	es;	
	HCURSOR		hcur = NULL;

	// If RTF, wrap EDITSTREAM around hGlobal & delegate to LoadFromEs()
	if (dwFormatIndex == iRtfNoObjs || dwFormatIndex == iRtfFETC ||
		dwFormatIndex == iRtfUtf8 || dwFormatIndex == iRtfNCRforNonASCII)
	{
		Assert(hGlobal != NULL);
		rhg.ptext		= (LPSTR)ptext;			// Start at beginning
		rhg.cbLeft		= GlobalSize(hGlobal);	//  with full length
		es.dwCookie		= (DWORD_PTR)&rhg;		// The read "this" ptr
		es.dwError		= NOERROR;				// No errors yet
		es.pfnCallback	= ReadHGlobal;			// The read method
		// Want wait cursor to display sooner
		bool fSetCursor = rhg.cbLeft > NUMPASTECHARSWAITCURSOR;
		if (fSetCursor)
			hcur = _ped->TxSetCursor(LoadCursor(NULL, IDC_WAIT));
		LONG cchLoad = LoadFromEs(prg, SFF_SELECTION | SF_RTF, &es, TRUE, publdr);
		if (fSetCursor)
			_ped->TxSetCursor(hcur);
		return (es.dwError != NOERROR) ? es.dwError : 
			   cchLoad ? NOERROR : S_FALSE;
	}

	Assert( dwFormatIndex == iRtfAsTextFETC ||
			dwFormatIndex == iAnsiFETC ||
			dwFormatIndex == iUnicodeFETC );

	BOOL fTRDsInvolved;
	prg->CheckTableSelection(FALSE, TRUE, &fTRDsInvolved, 0);

	LONG cchEOP = 0;
	LONG cchMove = 0;
	if(fTRDsInvolved)
		cchEOP = prg->DeleteWithTRDCheck(publdr, SELRR_REMEMBERRANGE, &cchMove,
						RR_NEW_CHARS | RR_NO_LP_CHECK);

	LONG cchNew = prg->CleanseAndReplaceRange(-1, ptext, TRUE, publdr, NULL, NULL,
						RR_NEW_CHARS | RR_ITMZ_NONE | RR_NO_LP_CHECK | RR_UNHIDE);
	if(prg->GetCch() && prg->IsSel())
		return E_FAIL;						// Paste failed due to UI rules

	if (_ped->IsRich() &&
		(!_ped->Get10Mode() || cchEOP))		// If rich text & not 1.0 mode, &
	{										//  new text ends with EOP, delete
		prg->DeleteTerminatingEOP(publdr);	//  that EOP to agree with Word
	}
	prg->ItemizeReplaceRange(cchNew + cchEOP, cchMove, publdr, TRUE);// Itemize w/ UnicodeBidi
											
	return NOERROR;						
}

/* 
 *	CLightDTEngine::DIBToRange(hGlobal, prg, publdr)
 *
 *	@mfunc
 *		Inserts dib data from the clipboard into range in the control
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::DIBToRange(
	HGLOBAL			hGlobal,
	CTxtRange *		prg,	
	IUndoBuilder *	publdr)
{
	HRESULT         hresult = DV_E_FORMATETC;
	REOBJECT        reobj = { 0 };
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(hGlobal);

	reobj.clsid = CLSID_StaticDib;
	reobj.sizel.cx = _ped->_pdp->DUtoHimetricU(pbmi->bmiHeader.biWidth);
	reobj.sizel.cy = _ped->_pdp->DVtoHimetricV(pbmi->bmiHeader.biHeight);
	_ped->GetClientSite(&reobj.polesite);

	COleObject *pobj = (COleObject *)reobj.polesite;
	COleObject::ImageInfo *pimageinfo = new COleObject::ImageInfo;
	pobj->SetHdata(hGlobal);
	pimageinfo->xScale = 100;
	pimageinfo->yScale = 100;
	pimageinfo->xExtGoal = reobj.sizel.cx;
	pimageinfo->yExtGoal = reobj.sizel.cy;
	pimageinfo->cBytesPerLine = 0;
	pobj->SetImageInfo(pimageinfo);
	
	// FUTURE: Why are we not testing for NULL earlier before we assign it to pobj? v-honwch
	// Also, do we need to release interfaces inside reobj (poleobj, polesite, pstg) before exit?
	if (!reobj.polesite )
		return hresult;

	// Put object into the edit control
	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = prg->GetCp();
	reobj.dvaspect = DVASPECT_CONTENT;
	reobj.dwFlags = REO_RESIZABLE;

	// Since we are loading an object, it shouldn't be blank
	reobj.dwFlags &= ~REO_BLANK;

	prg->Set_iCF(-1);	
	hresult = _ped->GetObjectMgr()->InsertObject(prg, &reobj, NULL);

	return hresult;
}

/* 
 *	CLightDTEngine::PasteDataObjectToRange (pdo, prg, cf, rps, pubdlr, dwFlags)
 *
 *	@mfunc
 *		Inserts data from the data object pdo into the range prg. If the
 *		clipboard format cf is not NULL, that format is used; else the highest
 *		priority clipboard format is used.  In either case, any text that
 *		already existed in the range is replaced.  If pdo is NULL, the
 *		clipboard is used.
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::PasteDataObjectToRange(
	IDataObject *	pdo,		// @parm Data object to paste
	CTxtRange *		prg,		// @parm Range into which to paste
	CLIPFORMAT		cf,			// @parm ClipBoard format to paste
	REPASTESPECIAL *rps,		// @parm Special paste info
	IUndoBuilder *	publdr,		// @parm Undo builder to receive antievents
	DWORD			dwFlags)	// @parm DWORD packed flags
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::PasteDataObjectToRange");

	BOOL		f10Mode = _ped->Get10Mode();
	HGLOBAL		hGlobal = NULL;
	HRESULT		hresult = DV_E_FORMATETC;
	HGLOBAL		hUnicode = NULL;
	DWORD		i;
	STGMEDIUM	medium = {0, NULL};
	IDataObject *pdoSave = pdo;
	FORMATETC *	pfetc = g_rgFETC;
	LPTSTR		ptext = NULL;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();
	BOOL		fThawDisplay = FALSE;
	BOOL        bFormatFound = FALSE;   // flag which determines if a matching cf format
	                                    // was found in g_rgFETC (1.0 compatibility)

	if(!pdo)								// No data object: use clipboard
	{
		hresult = OleGetClipboard(&pdo);
		if(FAILED(hresult))
		{
			// Ooops.  No Ole clipboard support
			// Need to use direct clipboard access
			HWND howner = ::GetClipboardOwner();
			HWND hwnd;
			if (howner &&
				_ped->TxGetWindow(&hwnd) == NOERROR &&
				howner == hwnd)
			{
				// We are cut/pasting within the same richedit instance
				// Use our cached clipboard data object
				pdo = _pdo;
				if(!pdo)		// Some failure
				{
					_ped->Beep();
					return hresult;
				}
				pdo->AddRef();
			}
			else
			{
				// Oh Oh We need to transfer from clipboard without data object
				// Data must be coming from another window instance
				if (_ped->TxGetWindow(&hwnd) == NOERROR &&
					::OpenClipboard(hwnd)
				)
				{
					HGLOBAL		hUnicode = NULL;

					DWORD dwFmt = iRtfUtf8;				// Try for UTF8 RTF
					_ped->_pdp->Freeze();
					if(!f10Mode)
					{
						hGlobal = ::GetClipboardData(cf_RTFUTF8);
						if (hGlobal == NULL)				// Wasn't there, so
						{									//  try for RTF
							hGlobal = ::GetClipboardData(cf_RTFNCRFORNONASCII);
							dwFmt = iRtfNCRforNonASCII;
						}
					}
					if (hGlobal == NULL)				// Wasn't there, so
					{									//  try for RTF
						hGlobal = ::GetClipboardData(cf_RTF);
						dwFmt = iRtfFETC;
					}
					if (hGlobal == NULL && !f10Mode)	// Wasn't there either
					{									//  so try for plain
						hGlobal = ::GetClipboardData(CF_UNICODETEXT);
						dwFmt = iUnicodeFETC;
					}
					if (hGlobal == NULL)				// Wasn't there either
					{									//  so try for plain text
						hGlobal = ::GetClipboardData(CF_TEXT);
						dwFmt = iAnsiFETC;
					}
					if (hGlobal)
					{
						if (dwFmt == iAnsiFETC)
						{
							// Convert Ansi plain text to Unicode
							hUnicode = TextHGlobalAtoW(hGlobal);
							if (hUnicode)
								ptext = (LPTSTR)GlobalLock(hUnicode);
						}
						else
							ptext = (LPTSTR)GlobalLock(hGlobal);

						if (ptext)
							hresult = HGlobalToRange(dwFmt, hGlobal, ptext, prg, publdr);
						else
							hresult = E_OUTOFMEMORY;

						if (hUnicode)
						{
							// Free plain text buffer
							GlobalUnlock(hUnicode);
							GlobalFree(hUnicode);
						}
						else
							GlobalUnlock(hGlobal);
					}
					else								// hGlobal == NULL Try for bitmaps
					{
						hGlobal = ::GetClipboardData(CF_DIB);
						if (hGlobal)
							hresult =  DIBToRange(hGlobal, prg, publdr);
					}
					_ped->_pdp->Thaw();
					::CloseClipboard();
				}
				if (FAILED(hresult))
					_ped->Beep();
				return hresult;
			}
		}
	}

	// Paste an object uses the limit text calculation
	_fUseLimit = TRUE;

	//Call QueryAcceptData unless caller has specified otherwise
	if(!(dwFlags & PDOR_NOQUERY) && precall)
	{
		CLIPFORMAT cfReq = cf;
		HGLOBAL hmeta = NULL;

		if(rps)
			hmeta = (HGLOBAL)((rps->dwAspect == DVASPECT_ICON) ? rps->dwParam : NULL);

		// Ask callback if it likes the data object and cfReq.

		hresult = precall->QueryAcceptData(
			pdo,
			&cfReq,
			(dwFlags & PDOR_DROP) ? RECO_DROP : RECO_PASTE,
			TRUE,
			hmeta);

		if(hresult == DATA_S_SAMEFORMATETC)
		{
			// Allow callback to return DATA_S_SAMEFORMATETC if it only
			// wants cf as passed in - we don't really care because
			// any non-zero CLIPFORMAT causes us to only accept that format.
			hresult = S_OK;
		}

		if(hresult == S_OK || hresult == E_NOTIMPL)
		{
			// Callback either liked it or didn't implement the method.
			// It may have changed the format while it was at it.
			// Treat a change of cf to zero as acceptance of the original.
			// In any event, we will try to handle it.

			// If a specific CLIPFORMAT was originally requested and the
			// callback changed it, don't accept it.
			if(cfReq && cf && (cf != cfReq))
			{
				hresult = DV_E_FORMATETC;
				goto Exit;
			}

			// If a specific CLIPFORMAT was originally requested and the
			// callback either left it alone or changed it to zero,
			// make sure we use the original.  If no CLIPFORMAT was
			// originally requested, make sure we use what came back
			// from the callback.
			if(!cf)
				cf = cfReq;
		}
		else
		{
			// Some success other than S_OK && DATA_S_SAMEFORMATETC.
			// The callback has handled the paste.  OR some error
			// was returned.
			goto Exit;
		}
	}

	// Even if the RichEdit client wants CF_TEXT, if the data object
	// supports CF_UNICODETEXT, we should prefer it as long as we are
	// not in 1.0 or single-codepage modes.
	if(cf == CF_TEXT && !f10Mode && !_ped->_fSingleCodePage)
	{
		FORMATETC fetc = {CF_UNICODETEXT, NULL, 0, -1, TYMED_NULL};

		if(pdo->QueryGetData(&fetc) == S_OK)
			cf = CF_UNICODETEXT;
		else
		{
			// One more try - CDataTransferObj::QueryGetData is checking
			// the tymed format
			fetc.tymed = TYMED_HGLOBAL;
			if(pdo->QueryGetData(&fetc) == S_OK)
				cf = CF_UNICODETEXT;
		}
	}
	if(cf == CF_UNICODETEXT && _ped->_fSingleCodePage)
		cf = CF_TEXT;

	if (_ped->TxGetReadOnly())			// Should check for range protection
	{
		hresult = E_ACCESSDENIED;
		goto Exit;
	}

	// At this point we freeze the display
	fThawDisplay = TRUE;
	_ped->_pdp->Freeze();

	if( publdr )
	{
		publdr->StopGroupTyping();
		publdr->SetNameID(UID_PASTE);
	}

    for( i = 0; i < CFETC; i++, pfetc++ )
	{
		// Make sure the format is either 1.) a plain text format 
		// if we are in plain text mode or 2.) a rich text format
		// or 3.) matches the requested format.

		if( cf && cf != pfetc->cfFormat )
			continue;

		if( _ped->IsRich() || (g_rgDOI[i] & DOI_CANPASTEPLAIN) )
		{
			// Make sure format is available
			if( pdo->QueryGetData(pfetc) != NOERROR )
			    continue;
			
			if(i == iUnicodeFETC && _ped->_fSingleCodePage)
				continue;

			// If we have a format that uses an hGlobal get and lock it
			if (i == iRtfFETC  || i == iRtfAsTextFETC ||
				i == iAnsiFETC || i == iRtfNoObjs	  ||
				!f10Mode && (i == iUnicodeFETC || i == iRtfUtf8 || i == iRtfNCRforNonASCII))
			{
				if( pdo->GetData(pfetc, &medium) != NOERROR )
					continue;

                hGlobal = medium.hGlobal;
				ptext = (LPTSTR)GlobalLock(hGlobal);
				if( !ptext )
				{
					ReleaseStgMedium(&medium);

					hresult = E_OUTOFMEMORY;
					goto Exit;
				}

				// 1.0 COMPATBILITY HACK ALERT!  RichEdit 1.0 has a bit of
				// "error recovery" for parsing rtf files; if they aren't
				// valid rtf, it treats them as just plain text.
				// Unfortunately, apps like Exchange depend on this behavior,
				// i.e., they give RichEdit plain text data, but call it rich
				// text anyway.  Accordingly, we emulate 1.0 behavior here by
				// checking for an rtf signature.
				if ((i == iRtfFETC || i == iRtfNoObjs || i == iRtfUtf8) &&
					!IsRTF((char *)ptext, GlobalSize(hGlobal)))
				{
					i = iAnsiFETC;			// Not RTF, make it ANSI text
				}
			}			
			else if (f10Mode && (i == iUnicodeFETC || i == iRtfUtf8))
			{
				// This else handles the case where we want to keep searching
				// for a goood format.  i.e. Unicode in 10 Mode
				continue;
			}

			// Don't delete trail EOP in some cases
			prg->AdjustEndEOP(NONEWCHARS);
			
			// Found a format we want.
			bFormatFound = TRUE;

			switch(i)									
			{											
			case iRtfNoObjs:							
			case iRtfFETC:								
			case iRtfUtf8:								
			case iRtfNCRforNonASCII:								
				hresult = HGlobalToRange(i, hGlobal, ptext, prg, publdr);
				break;
	
			case iRtfAsTextFETC:
			case iAnsiFETC:								// ANSI plain text		
				hUnicode = TextHGlobalAtoW(hGlobal);
				ptext	 = (LPTSTR)GlobalLock(hUnicode);
				if(!ptext)
				{
					hresult = E_OUTOFMEMORY;			// Unless out of RAM,
					break;								//  fall thru to
				}										//  Unicode case
														
			case iUnicodeFETC:							// Unicode plain text
				// Ok to pass in NULL for hglobal since argument won't be used
				hresult = HGlobalToRange(i, NULL, ptext, prg, publdr);
				if(hUnicode)							// For iAnsiFETC case
				{
					GlobalUnlock(hUnicode);
					GlobalFree(hUnicode);
				}			
				break;

			case iObtDesc:	 // Object Descriptor
				continue;	 // To search for a good format.
				             // the object descriptor hints will be used
				             // when the format is found.

			case iEmbObj:	 // Embedded Object
			case iEmbSrc:	 // Embed Source
			case iLnkSrc:	 // Link Source
			case iMfPict:	 // Metafile
			case iDIB:		 // DIB
			case iBitmap:	 // Bitmap
			case iFilename:	 // Filename
				hresult = CreateOleObjFromDataObj(pdo, prg, rps, i, publdr);
				break;

			// COMPATIBILITY ISSUE (v-richa) iTxtObj is needed by Exchange and 
			// as a flag for Wordpad.  iRichEdit doesn't seem to be needed by 
			// anyone but might consider implementing as a flag.
			case iRichEdit:	 // RichEdit
			case iTxtObj:	 // Text with Objects
				break;
			default:
				// Ooops didn't find a format after all
				bFormatFound = FALSE;
				break;
			}
			_ped->_ClipboardFormat = bFormatFound ? i + 1 : 0;

			//If we used the hGlobal unlock it and free it.
			if(hGlobal)
			{
				GlobalUnlock(hGlobal);
				ReleaseStgMedium(&medium);
			}
			break;							//Break out of for loop
		}
	}

    // richedit 1.0 returned an error if an unsupported FORMATETC was
    // found.  This behaviour is expected by ccMail so it can handle the
    // format itself
	if (!bFormatFound && f10Mode)
	    hresult = DV_E_FORMATETC;

Exit:
	if (fThawDisplay)
		_ped->_pdp->Thaw();

	if(!pdoSave)							// Release data object
		pdo->Release();						//  used for clipboard

	return hresult;						
}	

/*
 *	CLightDTEngine::GetDropTarget (ppDropTarget)
 *
 *	@mfunc
 *		creates an OLE drop target
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote	The caller is responsible for AddRef'ing this object
 *				if appropriate.
 */
HRESULT CLightDTEngine::GetDropTarget(
	IDropTarget **ppDropTarget)		// @parm outparm for drop target
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::GetDropTarget");

	if(!_pdt)
	{
		_pdt = new CDropTarget(_ped);
		// the AddRef done by the constructor will be
		// undone by the destructor of this object
	}

	if(ppDropTarget)
		*ppDropTarget = _pdt;

	return _pdt ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CLightDTEngine::StartDrag (psel, publdr)
 *
 *	@mfunc
 *		starts the main drag drop loop
 *
 */	
HRESULT CLightDTEngine::StartDrag(
	CTxtSelection *psel,		// @parm Selection to drag from
	IUndoBuilder *publdr)		// @parm undo builder to receive antievents
{
#ifndef NODRAGDROP
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::StartDrag");

	LONG			cch, cch1;
	LONG			cp1, cpMin, cpMost;
	DWORD			dwEffect = 0;
	HRESULT			hr;
	IDataObject *	pdo = NULL;
	IDropSource *	pds;
	IRichEditOleCallback * precall = _ped->GetRECallback();

	// If we're doing drag drop's, we should have our own drop target
	// It's possible that _pdt will be NULL at this point--some clients
	// will delay instantiation of our drop target until a drop target
	// in the parent window decides that ours is needed.  However, since
	// we need it just to initiate drag drop, go ahead and create one
	// here.

	if( _pdt == NULL )
	{
		hr = GetDropTarget(NULL);
		if(hr != NOERROR)
			return hr;
	}

	psel->CheckTableSelection(FALSE, TRUE, NULL, 0);

	if(precall)
	{
		CHARRANGE chrg;

		// give the callback a chance to give us its own IDataObject
		psel->GetRange(chrg.cpMin, chrg.cpMost);
		hr = precall->GetClipboardData(&chrg, RECO_COPY, &pdo);
	}
	else
	{
		// we need to build our own data object.
		hr = S_FALSE;
	}

	// If we didn't get an IDataObject from the callback, build our own
	if(hr != NOERROR || pdo == NULL)
	{										// Don't include trailing EOP
		psel->AdjustEndEOP(NONEWCHARS);		//  in some selection cases
		hr = RangeToDataObject(psel, SF_TEXT | SF_RTF, &pdo);
		if(hr != NOERROR)
			return hr;
	}

	cch = psel->GetRange(cpMin, cpMost);	// NB: prg is the selection
	cp1 = psel->GetCp();					// Save active end and signed
	cch1 = psel->GetCch();					//  length for Undo antievent
	CTxtRange rg(_ped, cpMost, cch);		// Use range copy to float over
											// mods made to backing store
	// The floating range that we just created on the stack needs to
	// think that it's protected, so it won't change size.
	rg.SetDragProtection(TRUE);

	pds = new CDropSource();
	if(pds == NULL)
	{
		pdo->Release();
		return E_OUTOFMEMORY;
	}

	// Cache some info with our own drop target
	_pdt->SetDragInfo(publdr, cpMin, cpMost);


	// Set allowable effects
	dwEffect = DROPEFFECT_COPY;
	if(!_ped->TxGetReadOnly())
		dwEffect |= DROPEFFECT_MOVE;
	
	// Let the client decide what it wants.
	if(precall)
		hr = precall->GetDragDropEffect(TRUE, 0, &dwEffect);

	if(!FAILED(hr) || hr == E_NOTIMPL)
	{
		// Start drag-drop operation
		psel->AddRef();					// Stabilize Selection around DoDragDrop
		hr = DoDragDrop(pdo, pds, dwEffect, &dwEffect);
		psel->Release();
	}

	// Clear drop target
	_pdt->SetDragInfo(NULL, -1, -1);

	// Handle 'move' operations	
	if( hr == DRAGDROP_S_DROP && (dwEffect & DROPEFFECT_MOVE) )
	{
		// We're going to delete the dragged range, so turn off protection.
		rg.SetDragProtection(FALSE);
		if( publdr )
		{
			LONG cpNext, cchNext;

			if(_ped->GetCallMgr()->GetChangeEvent() )
			{
				cpNext = cchNext = -1;
			}
			else
			{
				cpNext = rg.GetCpMin();
				cchNext = 0;
			}

			HandleSelectionAEInfo(_ped, publdr, cp1, cch1, cpNext, cchNext,
								  SELAE_FORCEREPLACE);
		}
		
		// Delete the data that was moved.  The selection will float
		// to the new correct location.
		rg.Delete(publdr, SELRR_IGNORE);

		// The update that happens implicitly by the update of the range may
		// have the effect of scrolling the window. This in turn may have the
		// effect in the drag drop case of scrolling non-inverted text into
		// the place where the selection was. The logic in the selection 
		// assumes that the selection is inverted and so reinverts it to turn
		// off the selection. Of course, it is obvious what happens in the
		// case where non-inverted text is scrolled into the selection area.
		// To simplify the processing here, we just say the whole window is
		// invalid so we are guaranteed to get the right painting for the
		// selection.
		// FUTURE: (ricksa) This solution does have the disadvantage of causing
		// a flash during drag and drop. We probably want to come back and
		// investigate a better way to update the screen.
		_ped->TxInvalidate();

		// Display is updated via notification from the range

		// Update the caret
		psel->Update(TRUE);
	}
	else if( hr == DRAGDROP_S_DROP && _ped->GetCallMgr()->GetChangeEvent() &&
		(dwEffect & DROPEFFECT_COPY) && publdr)
	{
		// if we copied to ourselves, we want to restore the selection to
		// the original drag origin on undo
		HandleSelectionAEInfo(_ped, publdr, cp1, cch1, -1, -1, 
				SELAE_FORCEREPLACE);
	}

	if(SUCCEEDED(hr))
		hr = NOERROR;

	pdo->Release();
	pds->Release();

	// we do this last since we may have re-used some 'paste' code which
	// will stomp the undo name to be UID_PASTE.
	if( publdr )
		publdr->SetNameID(UID_DRAGDROP);

	if(_ped->GetEventMask() & ENM_DRAGDROPDONE)
	{
		NMHDR	hdr;
		ZeroMemory(&hdr, sizeof(NMHDR));
		_ped->TxNotify(EN_DRAGDROPDONE, &hdr);
	}

	return hr;
#else
	return 0;
#endif // NODRAGDROP
}

/*
 *	CLightDTEngine::LoadFromEs (prg, lStreamFormat, pes, fTestLimit, publdr)
 *
 *	@mfunc
 *		Load data from the stream pes into the range prg according to the
 *		format lStreamFormat
 *
 *	@rdesc
 *		LONG -- count of characters read
 */
LONG CLightDTEngine::LoadFromEs(
	CTxtRange *	 prg,			// @parm Range to load into
	LONG		 lStreamFormat,	// @parm Stream format to use for loading
	EDITSTREAM * pes,			// @parm Edit stream to load from
	BOOL		 fTestLimit,	// @parm Whether to test text limit
	IUndoBuilder *publdr)		// @parm Undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::LoadFromEs");

#ifdef DEBUG
	// FUTURE: Currently freezing the display prior to loading text
	// is simply an optimization. This may become a requirement in the
	// future. If this does become a requirement then we'll want to
	// exit with an error.
	if( !_ped->_pdp->IsFrozen() )
	{
		TRACEWARNSZ("CLightDTEngine::LoadFromEs	display not frozen");
	}
#endif // DEBUG

	LONG		cch = 0;					// Default no chars read
	IAntiEvent *pae = NULL;

	if(publdr)
		publdr->StopGroupTyping();

	// Other components, such as the display and backing store, will
	// be able to make optimizations if they know that we are streaming
	// in text or RTF data.
	prg->CheckTableSelection(FALSE, TRUE, NULL, 0);
	if(lStreamFormat & SF_RTF)				// RTF case must precede
	{										//  TEXT case (see SF_x values)
		if(!_ped->IsRich())
			return 0;

		LONG cpMin, cpMost;

		// Here we do something a bit unusual for performance reasons.
		// Instead of letting the rtf reader generate its own undo actions,
		// we take care of it ourselves.  Instead of generating actions
		// for each little operation, we simply generate a "big" antievent
		// for the whole shebang

		// There is a subtlty w.r.t. to paragraph format runs.  By inserting
		// text with para formatting, it's possible that we will modify the
		// para formatting of the _current_ paragraph.  Thus, it's necessary
		// to remember what the formatting currently is for undo.  Note that
		// it may actually not be changed; but we go ahead and generate an
		// antievent anyways.  Note that we only need to do this if cpMin is
		// the middle of a paragraph
		
		CTxtPtr tp(prg->_rpTX);
		if(prg->GetCch() > 0)
			tp.Move(-prg->GetCch());
		
		if(publdr && !tp.IsAfterEOP())
		{
			tp.FindEOP(tomBackward);
			cpMin = tp.GetCp();
			tp.FindEOP(tomForward);
			cpMost = tp.GetCp();
			
			// We must be in rich text mode, so we must be able to always
			// find a paragraph.
			Assert(cpMost > cpMin);

			if (prg->_rpPF.IsValid())
			{
				CFormatRunPtr rpPF(prg->_rpPF);
				rpPF.Move(cpMin - prg->GetCp());
					
				pae = gAEDispenser.CreateReplaceFormattingAE(_ped, cpMin, rpPF, 
							cpMost - cpMin, GetParaFormatCache(), ParaFormat);
				if(pae)
					publdr->AddAntiEvent(pae);
			}

			// Also create the charformat antievent for the current paragraph
			// to preserve BiDi level. We cannot check fBiDi here since we may be running
			// on US platform inserting a BiDi rtf.
			if (prg->_rpCF.IsValid())
			{
				CFormatRunPtr rpCF(prg->_rpCF);
				rpCF.Move(cpMin - prg->GetCp());
				
				pae = gAEDispenser.CreateReplaceFormattingAE(_ped, cpMin, rpCF, 
							cpMost - cpMin, GetCharFormatCache(), CharFormat);
				if(pae)
					publdr->AddAntiEvent(pae);
			}
		} 

		// First, clear range
		LONG cchEOP = prg->DeleteWithTRDCheck(publdr, SELRR_REMEMBERRANGE, NULL,
											  RR_NO_LP_CHECK | RR_NO_CHECK_TABLE_SEL);
		if(prg->GetCch())
			return 0;							// Deletion suppressed, so
												//  can't insert text
		cpMin = prg->GetCp();
		_ped->SetStreaming(TRUE);
		CRTFRead rtfRead(prg, pes, lStreamFormat);

		cch	= rtfRead.ReadRtf();

		if(prg->_rpTX.IsAfterEOP() && (cchEOP ||// Inserted text ends with EOP
		    prg->_rpTX.GetChar() == CELL &&		// OK to delete EOP if we
			cch && !prg->_rpTX.IsAfterTRD(0)))	//  inserted one or if before
		{										//  CELL
			if(cchEOP)
			{
				Assert(prg->_rpTX.GetChar() == CR);
				prg->AdvanceCRLF(CSC_NORMAL, TRUE);
			}
			else
				prg->BackupCRLF(CSC_NORMAL, TRUE);

			prg->ReplaceRange(0, NULL, NULL, SELRR_REMEMBERRANGE);
		}
		cpMost = prg->GetCp();
		Assert(pes->dwError != 0 || cpMost >= cpMin);

		// If nothing changed, get rid of any antievents (like the formatting
		// one) that we may have "speculatively" added
		if(publdr && !_ped->GetCallMgr()->GetChangeEvent())
			publdr->Discard();

		if(publdr && cpMost > cpMin)
		{
			// If some text was added, create an antievent for
			// it and add it in.
			AssertSz(_ped->GetCallMgr()->GetChangeEvent(),
				"Something changed, but nobody set the change flag");

			pae = gAEDispenser.CreateReplaceRangeAE(_ped, cpMin, cpMost, 0, 
						NULL, NULL, NULL);

			HandleSelectionAEInfo(_ped, publdr, -1, -1, cpMost, 0, 
						SELAE_FORCEREPLACE);
			if(pae)
				publdr->AddAntiEvent(pae);
		}
	}
	else if(lStreamFormat & SF_TEXT)
	{
		_ped->SetStreaming(TRUE);
		cch = ReadPlainText(prg, pes, fTestLimit, publdr, lStreamFormat);
	}
	_ped->SetStreaming(FALSE);

	// Before updating the selection, try the auto-URL detect.  This makes
	// two cases better: 1. a long drag drop is now faster and 2. the
	// selection _iFormat will now be udpated correctly for cases of
	// copy/paste of a URL.

	if(_ped->GetDetectURL())
		_ped->GetDetectURL()->ScanAndUpdate(publdr);

	// The caret belongs in one of two places:
	//		1. if we loaded into a selection, at the end of the new text
	//		2. otherwise, we loaded an entire document, set it to cp 0
	//
	// ReadPlainText() and ReadRtf() set prg to an insertion point
	// at the end, so if we loaded a whole document, reset it.
	CTxtSelection *psel = _ped->GetSelNC();
	if(psel)
	{
		if(!(lStreamFormat & SFF_SELECTION))
		{
			psel->Set(0,0);
			psel->Update(FALSE);
		}
		psel->Update_iFormat(-1);
	}

	if (!fTestLimit)
	{
		// If we don't limit the text then we adjust the text limit
		// if we have exceeded it.
		_ped->TxSetMaxToMaxText();
	}
	return cch;
}

/*
 *	CLightDTEngine::SaveToEs (prg, lStreamFormat, pes)
 *
 *	@mfunc
 *		save data into the given stream
 *
 *	@rdesc
 *		LONG -- count of characters written
 */
LONG CLightDTEngine::SaveToEs(
	CTxtRange *	prg,			//@parm Range to drag from
	LONG		lStreamFormat,	//@parm Stream format to use for saving
	EDITSTREAM *pes )			//@parm Edit stream to save to
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::SaveToEs");

	LONG cch = 0;								// Default no chars written

	prg->AdjustCRLF(1);
	if(lStreamFormat & SF_RTF)					// Be sure to check for SF_RTF
	{											//  before checking for SF_TEXT
		if(prg->CheckTableSelection(FALSE, TRUE, NULL, 0))
			lStreamFormat |= SFF_WRITEXTRAPAR;	// Signal to write \par for CELL
		CRTFWrite rtfWrite( prg, pes, lStreamFormat );
	
		cch = rtfWrite.WriteRtf();
	}
	else if(lStreamFormat & (SF_TEXT | SF_TEXTIZED))
		cch = WritePlainText(prg, pes, lStreamFormat);

	else
	{
		Assert(FALSE);
	}
	return cch;
}

/*
 *	CLightDTEngine::UnicodePlainTextFromRange (prg)
 *
 *	@mfunc
 *		Fetch plain text from a range and put it in an hglobal
 *
 *	@rdesc
 *		an allocated HGLOBAL.
 *
 *	@devnote
 *		FUTURE: Export bullets as does Word for plain text
 */
HGLOBAL CLightDTEngine::UnicodePlainTextFromRange(
	CTxtRange *prg)				// @parm range to get text from
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::UnicodePlainTextFromRange");

	LONG	cpMin, cpMost;
	LONG	cch = prg->GetRange(cpMin, cpMost);
	LONG	cchT = 2*(cch + 1);					// Allocate 2* in  case all CRs

	HGLOBAL	hText = GlobalAlloc(GMEM_FIXED,	cchT*sizeof(WCHAR));
	if(!hText)
		return NULL;

	WCHAR *pText = (WCHAR *)GlobalLock(hText);
	if(!pText)
		return NULL;

	if(cch)
	{
		CRchTxtPtr rtp(*prg);
		rtp.SetCp(cpMin);
		cch = rtp.GetPlainText(cchT, pText, cpMost, FALSE, TRUE);
		AssertSz(cch <= cchT,
			"CLightDTEngine::UnicodePlainTextFromRange: got too much text");
	}
	*(pText + cch) = 0;
	
	GlobalUnlock(hText);

	HGLOBAL	hTemp = GlobalReAlloc(hText, 2*(cch + 1), GMEM_MOVEABLE);

	if(!hTemp)
		GlobalFree(hText);

	return hTemp;
}

/*
 *	CLightDTEngine::AnsiPlainTextFromRange (prg)
 *
 *	@mfunc
 *		Retrieve an ANSI copy of the text in the range prg
 *
 *	@rdesc
 *		HRESULT
 */
HGLOBAL CLightDTEngine::AnsiPlainTextFromRange(
	CTxtRange *prg)				// @parm range to get text from
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::AnsiPlainTextFromRange");

	HGLOBAL hUnicode;
	HGLOBAL hAnsi;

	// FUTURE (alexgo): if we implement the option to store text as 8-bit
	// chars, then we can make this routine more efficient

	hUnicode = UnicodePlainTextFromRange(prg);
	hAnsi = TextHGlobalWtoA(hUnicode);

	GlobalFree(hUnicode);
	return hAnsi;
}

/*
 *	CLightDTEngine::RtfFromRange (prg, lStreamFormat)
 *
 *	@mfunc
 *		Fetch RTF text from a range and put it in an hglobal
 *
 *	@rdesc
 *		an allocated HGLOBAL.  
 */
HGLOBAL CLightDTEngine::RtfFromRange(
	CTxtRange *	prg,			// @parm Range to get RTF from
	LONG 		lStreamFormat)	// @parm stream format to use for loading
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::RtfFromRange");

	WRITEHGLOBAL whg;
	EDITSTREAM	 es = {(DWORD_PTR)&whg, NOERROR, WriteHGlobal};
	DWORD		 cb	= 2*abs(prg->GetCch()) + 100;	// Rough estimate
 
	whg.cb			= cb;
	whg.hglobal		= GlobalAlloc(GMEM_FIXED, cb);
	if(!whg.hglobal)
		return NULL;		
	whg.cch			= 0;					// Nothing written yet
	SaveToEs(prg, lStreamFormat & ~SF_TEXT, &es);
	if(es.dwError)
	{
		GlobalFree(whg.hglobal);
		return NULL;
	}
	
	HGLOBAL	hTemp = GlobalReAlloc(whg.hglobal, whg.cch, GMEM_MOVEABLE);
	
	if (!hTemp)		
		GlobalFree(whg.hglobal);			// Fail ReAlloc... 

	return hTemp;
}


//
// PROTECTED METHODS
//

#define READSIZE 	4096 - 2
#define WRITESIZE	2048

/*
 *	CLightDTEngine::ReadPlainText (prg, pes, publdr, lStreamFormat)
 *
 *	@mfunc
 *		Replaces contents of the range prg with the data given in the edit
 *		stream pes. Handles multibyte sequences that overlap stream buffers.
 *
 *	@rdesc
 *		Count of bytes read (to be compatible with RichEdit 1.0)
 *
 *	@devnote
 *		prg is modified; at the return of the call, it will be a degenerate
 *		range at the end of the read in text.
 *
 *		Three kinds of multibyte/char sequences can overlap stream buffers:
 *		DBCS, UTF-8, and CRLF/CRCRLF combinations. DBCS and UTF-8 streams are
 *		converted by MultiByteToWideChar(), which cannot convert a lead byte
 *		(DBCS and UTF-8) that occurs at the end of the buffer, since the
 *		corresponding trail byte(s) will be in the next buffer.  Similarly,
 *		in RichEdit 2.0 mode, we convert CRLFs to CRs and CRCRLFs to blanks,
 *		so one or two CRs at the end of the buffer require knowledge of the
 *		following char to determine if they are part of a CRLF or CRCRLF.
 *
 *		To handle these overlapped buffer cases, we move the ambiguous chars
 *		to the start of the next buffer, rather than keeping them as part of
 *		the current buffer.  At the start of the buffer, the extra char(s)
 *		needed for translation follow immediately.
 */
LONG CLightDTEngine::ReadPlainText(
	CTxtRange *	  prg, 			// @parm range to read to
	EDITSTREAM *  pes,			// @parm edit stream to read from
	BOOL		  fTestLimit,	// @parm whether limit testing is needed
	IUndoBuilder *publdr,		// @parm undo builder to receive antievents
	LONG		  lStreamFormat)// @parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::ReadPlainText");

	CTxtEdit *ped = _ped;
	LONG	  cbRead;
	LONG 	  cbReadTotal = 0;	// No bytes read yet
	LONG	  cchConv;
	LONG	  cchMove = 0;
	LONG	  cCR = 0;			// Count of CRs from preceding buffer
	LONG	  cCRPrev = 0;		// Count used while calc'ing new cCR
	LONG	  cpMin;
	BOOL	  fContinue = TRUE;	// Keep reading so long as TRUE
	BYTE *	  pb;				// Byte ptr to szBuf or wszBuf
	CCallMgr *pCallMgr = ped->GetCallMgr();
	WCHAR *	  pch;				// Ptr to wszBuf
	UINT	  uCpg = GetStreamCodePage(lStreamFormat);
	CFreezeDisplay	fd(ped->_pdp);

	// Just put a big buffer on the stack.  Thankfully, we only
	// run on 32bit OS's.  4K is a good read size for NT file caching.
	char 	szBuf[READSIZE];
	WCHAR	wszBuf[READSIZE+2];	// Allow for moving end CRs to start

	// Empty the range
	prg->DeleteWithTRDCheck(publdr, SELRR_REMEMBERRANGE, &cchMove, 0);

	cpMin = prg->GetCp();							// Save initial cp for
													//  BreakRuns() at end
	pb = (IsUnicodeCP(uCpg)) ? (BYTE *)(wszBuf + 2)	// Setup Unicode or MBCS
						: (BYTE *)szBuf;
	LONG j = 0;										// Haven't read anything,
													//  so no lead byte left
	while(fContinue)								//  from previous read
	{
		LONG jPrev = j;								// Save byte(s) left over
		LONG cbSkip = 0;							//  from previous read

		pes->dwError = (*pes->pfnCallback)(			// Read next bufferful,
				pes->dwCookie, pb + j, 				//  bypassing any lead
				READSIZE - j, &cbRead);				//  bytes

		if(pes->dwError || !cbRead && !cCR)
			break;									// Error or done

		if(!cbReadTotal && cbRead >= 3 && W32->IsUTF8BOM(pb))
		{
			uCpg = CP_UTF8;
			cbSkip = 3;								// Bypass 3 bytes
		}
		// Adjust cbRead with previous leading byte(s)
		cbRead += j;
		j = 0;										
		
		cchConv = cbRead/2;							// Default Unicode cch
		if(uCpg == CP_UBE)							// Big Endian Unicode
		{
			WORD *pch = &wszBuf[2];

			for(LONG j = 0; j < cchConv; j++)		// Convert to little endian
				*pch++ = (*pch >> 8) + (*pch << 8); 
		}
		else if(uCpg != CP_ULE && cbRead)			// Multibyte of some kind
		{
			Assert(pb == (BYTE *)szBuf && !j);		// Just in case...

			// Check if last byte is a leading byte
			if(uCpg == CP_UTF8)
			{
				// Note: Unlike UTF-8, UTF-7 can be in the middle of a long
				// sequence, so it can't be converted effectively in chunks
				// and we don't handle it
				LONG cb = cbRead - 1;
				BYTE b;
				BYTE bLeadMax = 0xDF;

				// Find UTF-8 lead byte
				while((b = (BYTE)szBuf[cb - j]) >= 0x80)
				{
					j++;
					if(b >= 0xC0)					// Break on UTF-8 lead
					{								//  byte
						if(j > 1 && (b <= bLeadMax || b >= 0xF8))
							j = 0;					// Full UTF-8 char or
						break;						//  illegal sequence
					}
					if(j > 1)
					{
						if(j == 5)					// Illegal UTF-8
						{
							j = 0;
							break;
						}
						*(char *)&bLeadMax >>= 1;
					}
				}
			}
			else 
			{
				LONG temp = cbRead - 1; 

				// GetTrailBytesCount() can return 1 for some trail bytes
				// esp. for GBX.  So, we need to keep on checking until
				// we hit a non-lead byte character.  Then, based on
				// how many bytes we went back, we can determine if the
				// last byte is really a Lead byte.
				while (temp && GetTrailBytesCount((BYTE)szBuf[temp], uCpg))
					temp--;

				if(temp && ((cbRead-1-temp) & 1))
					j = 1;
			}

			// We don't want to pass the lead byte or partial UTF-8 to
			// MultiByteToWideChar() because it will return bad char.
		    cchConv = MBTWC(uCpg, 0, szBuf + cbSkip, cbRead - j - cbSkip,
							&wszBuf[2], READSIZE, NULL);

			for(LONG i = j; i; i--)					// Copy down partial
				szBuf[j - i] = szBuf[cbRead - i];	//  multibyte sequence
		}
		cbReadTotal += cbRead - j - jPrev;

		// Cleanse (CRLFs -> CRs, etc.), limit, and insert the data. Have
		// to handle CRLFs and CRCRLFs that overlap two successive buffers.
		Assert(cCR <= 2);
		pch = &wszBuf[2 - cCR];						// Include CRs from prev

		if(!ped->_pdp->IsMultiLine())				// Single-line control
		{
			Assert(!cCR);
		}
		else
		{								
			wszBuf[0] = wszBuf[1] = CR;				// Store CRs for cchCR > 0
			cCRPrev = cCR;							// Save prev cchCR
			cCR = 0;								// Default no CR this buf

			Assert(ARRAY_SIZE(wszBuf) >= cchConv + 2);

			// Need to +2 since we are moving data into wszBuf[2]
			if(cchConv && wszBuf[cchConv + 2 - 1] == CR)
			{										// There's at least one
				cCR++;								// Set it up for next buf
				if (cchConv > 1 &&					//  in case CR of CRLF
					wszBuf[cchConv + 2 - 2] == CR)	// Got 2nd CR; might be
				{									//  first CR of CRCRLF so
					cCR++;							//  setup for next buffer
				}
			}										
			cchConv += cCRPrev - cCR;				// Add in count from prev
		}											//  next
		Assert(!prg->GetCch());						// Range is IP
		prg->CleanseAndReplaceRange(cchConv, pch, fTestLimit, publdr, pch, NULL, RR_ITMZ_NONE);

		if(pCallMgr->GetMaxText() || pCallMgr->GetOutOfMemory())
		{
			// Out of memory or reached the max size of our text control.
			// In either case, return STG_E_MEDIUMFULL (for compatibility
			// with RichEdit 1.0)
			pes->dwError = (DWORD)STG_E_MEDIUMFULL;
			break;
		}
	}
	prg->ItemizeReplaceRange(prg->GetCp() - cpMin, cchMove, publdr, TRUE);

	return cbReadTotal;
}

/*
 *	CLightDTEngine::WritePlainText (prg, pes, lStreamFormat)
 *
 *	@mfunc
 *		Writes plain text from the range into the given edit stream
 *
 *	@rdesc
 *		Count of bytes written
 */
LONG CLightDTEngine::WritePlainText(
	CTxtRange *	prg,			// @parm range to write from
	EDITSTREAM *pes,			// @parm edit stream to write to
	LONG		lStreamFormat)	// @parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::WritePlainText");

	LONG		cbConverted;		// Bytes for output stream
	LONG		cbWrite;			// Incremental byte count
	LONG		cbWriteTotal = 0;	// No chars written yet
	LONG		cpMin, cpMost;
	LONG		cch = prg->GetRange(cpMin, cpMost);
	BOOL		fTextize = lStreamFormat & SF_TEXTIZED;
	LPBYTE		pb;					// Byte ptr to szBuf or wszBuf
	COleObject *pobj;				// Ptr to embedded object
	CRchTxtPtr	rtp(*prg);			// rtp to walk prg with
	UINT		uCpg = GetStreamCodePage(lStreamFormat);

	// DBCS has up to 2 times as many chars as WCHARs. UTF-8 has 3 BYTES for
	// all codes above 0x7ff. UTF-7 has even more due to shift in/out codes.
	// We don't support UTF-7, since can't use WCTMB with UTF-7 chunks

	char		szBuf[3*WRITESIZE];	// Factor of 2 works with DBCS, 3 with UTF-8
	WCHAR		wszBuf[WRITESIZE];

	pes->dwError = NOERROR;							// No error yet

	pb = IsUnicodeCP(uCpg) ? (BYTE *)wszBuf			// Setup Unicode or MBCS
						: (BYTE *)szBuf;

	LONG cchText = _ped->GetAdjustedTextLength();
	cpMost = min(cpMost, cchText);					// Don't write final CR
	rtp.SetCp(cpMin);
	while(rtp.GetCp() < cpMost)
	{
		if (fTextize && rtp.GetChar() == WCH_EMBEDDING)
		{
			Assert(_ped->GetObjectCount());

			pobj = _ped->GetObjectMgr()->GetObjectFromCp(rtp.GetCp());
			rtp.Move(1);							// Move past object
			if(pobj)
			{
				cbWriteTotal += pobj->WriteTextInfoToEditStream(pes, uCpg);
				continue;							// If no object at cp,
			}										//  just ignore char
		}											
		cch	= rtp.GetPlainText(WRITESIZE, wszBuf, cpMost, fTextize, TRUE);
		if(!cch)
			break;									// No more to do

		cbConverted = 2*cch;						// Default Unicode byte ct
		if(uCpg == CP_UBE)							// Big Endian Unicode
		{
			WORD *pch = &wszBuf[0];

			for(LONG j = 0; j < cch; j++)			// Convert to little endian
				*pch++ = (*pch >> 8) + (*pch << 8); 
		}
		else if(uCpg != CP_ULE)						// Multibyte of some kind
		{
			cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
								UN_CONVERT_WCH_EMBEDDING);

			// FUTURE: report some kind of error if default char used,
			// i.e., data lost in conversion
		
			// Did the conversion completely fail? As a fallback, we might try 
			// the system code page, or just plain ANSI...
			if (!cbConverted)
			{
				uCpg = CodePageFromCharRep(GetLocaleCharRep());
				cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
												UN_CONVERT_WCH_EMBEDDING);
			}
			if (!cbConverted)
			{
				uCpg = CP_ACP;
				cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
												UN_CONVERT_WCH_EMBEDDING);
			}
		}

		pes->dwError = (*pes->pfnCallback)(pes->dwCookie, pb,
							cbConverted,  &cbWrite);
		if(!pes->dwError && cbConverted != cbWrite)	// Error or ran out of
			pes->dwError = (DWORD)STG_E_MEDIUMFULL;	//  target storage

		if(pes->dwError)
			break;
		cbWriteTotal += cbWrite;
	}

	AssertSz(rtp.GetCp() >= cpMost,
		"CLightDTEngine::WritePlainText: not all text written");

	return cbWriteTotal;
}

/* 
 *	CLightDTEngine::GetStreamCodePage (lStreamFormat)
 *
 *	@mfunc
 *		Returns code page given by lStreamFormat or CTxtEdit::_pDocInfo
 *
 *	@rdesc
 *		HRESULT
 */
LONG CLightDTEngine::GetStreamCodePage(
	LONG lStreamFormat)
{
	if(lStreamFormat & SF_UNICODE)
		return CP_ULE;

	if(lStreamFormat & SF_USECODEPAGE)
		return HIWORD(lStreamFormat);

	if (W32->IsFESystem())
		return GetACP();

	return CP_ACP;
}

/* 
 *	CLightDTEngine::CreateOleObjFromDataObj ( pdo, prg, rps, iformatetc, pubdlr )
 *
 *	@mfunc
 *		Creates an ole object based on the data object pdo, and
 *		pastes the object into the range prg. Any text that already
 *		existed in the range is replaced.
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::CreateOleObjFromDataObj(
	IDataObject *	pdo,		// @parm Data object from which to create
	CTxtRange *		prg,		// @parm Range in which to place
	REPASTESPECIAL *rps,		// @parm Special paste info
	INT				iformatetc,	// @parm Index in g_rgFETC 
	IUndoBuilder *	publdr)		// @parm Undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CreateOleObjFromDataObj");

	HRESULT			hr = NOERROR;
	REOBJECT		reobj;
	SIZEL			sizel;
	FORMATETC		formatetc;
	DWORD			dwDrawAspect = 0;
	HGLOBAL			hMetaPict = NULL;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();
	LPOBJECTDESCRIPTOR lpod = NULL;
	STGMEDIUM		medObjDesc;
	BOOL			fStatic = (iformatetc == iMfPict || iformatetc == iDIB ||
							   iformatetc == iBitmap);
	BOOL			fFilename = (iformatetc == iFilename);
    DUAL_FORMATETC	tmpFormatEtc;

	if(!precall)
		return E_NOINTERFACE;

	ZeroMemory(&medObjDesc, sizeof(STGMEDIUM));
	ZeroMemory(&sizel, sizeof(SIZEL));
	ZeroMemory(&reobj, sizeof(REOBJECT));

	if(fStatic)
		dwDrawAspect = DVASPECT_CONTENT;

	if(fFilename)
		dwDrawAspect = DVASPECT_ICON;

	if(rps && !dwDrawAspect)
	{
		dwDrawAspect = rps->dwAspect;
		if(rps->dwAspect == DVASPECT_ICON)
			hMetaPict = (HGLOBAL)rps->dwParam;
	}

	// If no aspect was specified, pick up the object descriptor hints
	if(!dwDrawAspect)
	{
		// Define ObjectDescriptor data
		formatetc.cfFormat = cf_OBJECTDESCRIPTOR;
		formatetc.ptd = NULL;
		formatetc.dwAspect = DVASPECT_CONTENT;
		formatetc.lindex = -1;
		formatetc.tymed = TYMED_HGLOBAL;

		if(pdo->GetData(&formatetc, &medObjDesc) == NOERROR)
		{
			HANDLE	hGlobal = medObjDesc.hGlobal;

			lpod = (LPOBJECTDESCRIPTOR)GlobalLock(hGlobal);
			if(lpod)
			{
				dwDrawAspect = lpod->dwDrawAspect;
			}
			GlobalUnlock(hGlobal);
			ReleaseStgMedium(&medObjDesc);
		}
	}

	if(!dwDrawAspect)
		dwDrawAspect = DVASPECT_CONTENT;

	if(fStatic)
	{
		reobj.clsid	= ((iformatetc == iMfPict) ?
			CLSID_StaticMetafile : CLSID_StaticDib);
	}

	// COMPATIBILITY ISSUE: Compatibility Issue from Richedit 1.0 - Raid 16456: 
	// Don't call GetData(CF_EMBEDSOURCE)
	// on 32-bit Excel. Also clsidPictPub.
	//	if(iformatetc == iformatetcEmbSrc && (ObFIsExcel(&clsid) || 
	//		IsEqualCLSID(&clsid, &clsidPictPub)))
	//	else
	//		ObGetStgFromDataObj(pdataobj, &medEmbed, iformatetc);

	// Get storage for the object from the application
	hr = precall->GetNewStorage(&reobj.pstg);
	if(hr)
	{
		TRACEERRORSZ("GetNewStorage() failed.");
		goto err;
	}

	// Create an object site for the new object
	hr = _ped->GetClientSite(&reobj.polesite);
	if(!reobj.polesite)
	{
		TRACEERRORSZ("GetClientSite() failed.");
		goto err;
	}


	ZeroMemory(&tmpFormatEtc, sizeof(DUAL_FORMATETC));
	tmpFormatEtc.ptd = NULL;
	tmpFormatEtc.dwAspect = dwDrawAspect;
	tmpFormatEtc.lindex = -1;

	//Create the object
	if(fStatic)
	{
		hr = OleCreateStaticFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}
	else if(iformatetc == iLnkSrc || (_ped->Get10Mode() && iformatetc == iFilename))
	{
		hr = OleCreateLinkFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}
	else
	{
		hr = OleCreateFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}

	if(hr)
	{
		TRACEERRORSZ("Failure creating object.");
		goto err;
	}


	//Get the clsid of the object.
	if(!fStatic)
	{
		hr = reobj.poleobj->GetUserClassID(&reobj.clsid);
		if(hr)
		{
			TRACEERRORSZ("GetUserClassID() failed.");
			goto err;
		}
	}

	//Deal with iconic aspect if specified.
	if(hMetaPict)
	{
		BOOL fUpdate;

		hr = OleStdSwitchDisplayAspect(reobj.poleobj, &dwDrawAspect,
										DVASPECT_ICON, hMetaPict, FALSE,
										FALSE, NULL, &fUpdate);
		if(hr)
		{
			TRACEERRORSZ("OleStdSwitchDisplayAspect() failed.");
			goto err;
		}

		// If we successully changed the aspect, recompute the size.
		hr = reobj.poleobj->GetExtent(dwDrawAspect, &sizel);

		if(hr)
		{
			TRACEERRORSZ("GetExtent() failed.");
			goto err;
		}
	}

	// Try to retrieve the previous saved RichEdit site flags.
	if( ObjectReadSiteFlags(&reobj) != NOERROR )
	{
		// Set default for site flags
		reobj.dwFlags = REO_RESIZABLE;
	}

	// First, clear the range
	prg->Delete(publdr, SELRR_REMEMBERRANGE);

	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = prg->GetCp();
	reobj.dvaspect = dwDrawAspect;
	reobj.sizel = sizel;

	//COMPATIBILITY ISSUE: from Richedit 1.0 - don't Set the Extent,
	//instead Get the Extent below in ObFAddObjectSite
	//hr = reobj.poleobj->SetExtent(dwDrawAspect, &sizel);

	hr = reobj.poleobj->SetClientSite(reobj.polesite);
	if(hr)
	{
		TRACEERRORSZ("SetClientSite() failed.");
		goto err;
	}

	if(hr = _ped->InsertObject(&reobj))
	{
		TRACEERRORSZ("InsertObject() failed.");
	}

err:
	if(reobj.poleobj)
		reobj.poleobj->Release();

	if(reobj.polesite)
		reobj.polesite->Release();

	if(reobj.pstg)
		reobj.pstg->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\line.cpp ===
/*
 *	LINE.CPP
 *	
 *	Purpose:
 *		CLine class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_line.h"
#include "_measure.h"
#include "_render.h"
#include "_disp.h"
#include "_dispml.h"
#include "_edit.h"

ASSERTDATA

extern BOOL g_OLSBusy;

/*
 *	CLine::Measure(&me, uiFlags, pliTarget)
 *
 *	@mfunc
 *		Computes line break (based on target device) and fills
 *		in this CLine with resulting metrics on rendering device
 *
 *	@rdesc 
 *		TRUE if OK
 *
 *	@devnote
 *		me is moved past line (to beginning of next line).  Note: CLock is
 *		needed in the main four routines (Measure, MeasureText, CchFromUp,
 *		and RenderLine), since they use the global (shared) fc().GetCcs()
 *		facility and may use the LineServices global g_plsc and g_pols.
 */
BOOL CLine::Measure(
	CMeasurer& me,			//@parm Measurer pointing at text to measure
	UINT	   uiFlags,		//@parm Flags
	CLine *	   pliTarget)	//@parm Returns target-device line metrics (optional)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLine::Measure");

	CLock	lock;
	BOOL	fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
	BOOL	fMultiLine = me.GetPdp()->IsMultiLine();
	BOOL	fRet;

	if(fMultiLine && fFirstInPara && me.GetPrevChar() == VT)
	{
		fFirstInPara = FALSE;
		uiFlags &= ~MEASURE_FIRSTINPARA;
	}

	me.NewLine(fFirstInPara);

	if(fFirstInPara)
		me._li._fFirstInPara = TRUE;

	BYTE bNumber = me._wNumber < 256	// Store current para # offset
				 ? me._wNumber : 255;
	me._li._bNumber = bNumber;
	me._fMeasure = TRUE;

	//REVIEW (keithcu) uiFlags aren't needed in LS model? Can I remove
	//from the other model, too?
#ifndef NOLINESERVICES
	COls *	   pols = me.GetPols();			// Try for LineServices object
	if(pols)
	{						// Got it: use LineServices
		fRet = pols->MeasureLine(pliTarget);
		g_OLSBusy = FALSE;
	}
	else									// LineServices not active
#endif
		fRet = me.MeasureLine(uiFlags, pliTarget);

	if(!fRet)
		return FALSE;

	*this = me._li;							// Copy over line info

	if(!fMultiLine)							// Single-line controls can't
		return TRUE;						//  have paragraph numbering

	if(IsHeadingStyle(me._pPF->_sStyle))	// Store heading number if relevant
		_nHeading = (BYTE)(-me._pPF->_sStyle - 1);

	if(me.IsInOutlineView() && me._pPF->_wEffects & PFE_COLLAPSED)	// Cache collapsed bit
		_fCollapsed = TRUE;

	_bNumber = bNumber;
	
	if(_fHasEOP)							// Check for new para number
	{
		const CParaFormat *pPF = me.GetPF();

		me._wNumber	  = (WORD)pPF->UpdateNumber(me._wNumber, me._pPF);
	}
	if(me.GetPrevChar() == FF)
		_fHasFF = TRUE;

	return TRUE;
}
	
/*
 *	CLine::Render(&re, fLastLine)
 *
 *	@mfunc
 *		Render visible part of this line
 *
 *	@rdesc
 *		TRUE iff successful
 *
 *	@devnote
 *		re is moved past line (to beginning of next line).
 *		FUTURE: the RenderLine functions return success/failure.
 *		Could do something on failure, e.g., be specific and fire
 *		appropriate notifications like out of memory.
 */
BOOL CLine::Render(
	CRenderer& re,			//@parm Renderer to use
	BOOL fLastLine)			//@parm TRUE iff last line in layout
{
	if(_fCollapsed)						// Line is collapsed in Outline view
	{
		re.Move(_cch);					// Bypass line
		return TRUE;
	}

	BOOL	fRet;
	CLock	lock;
	POINTUV	pt = re.GetCurPoint();

#ifndef NOLINESERVICES
	COls *pols = re.GetPols();			// Try for LineServices object
	if(pols)
	{
		fRet = pols->RenderLine(*this, fLastLine);
		g_OLSBusy = FALSE;
	}
	else
#endif
		fRet = re.RenderLine(*this, fLastLine);

	pt.v += GetHeight();				// Advance to next line	position
	re.SetCurPoint(pt);
	return fRet;
}

/*
 *	CLine::CchFromUp(&me, pt, pdispdim, pHit, pcpActual)
 *
 *	@mfunc
 *		Computes cch corresponding to x position in a line.
 *		Used for hit testing.
 *
 *	@rdesc 
 *		cch found up to the x coordinate x	
 *
 *	@devnote
 *		me is moved to the cp at the cch offset returned
 */
LONG CLine::CchFromUp(
	CMeasurer& me,		//@parm Measurer position at start of line
	POINTUV	 pt,		//@parm pt.u is u coord to search for
	CDispDim*pdispdim,	//@parm Returns display dimensions
	HITTEST *phit,		//@parm Returns hit type at x	
	LONG	*pcpActual) const //@parm actual CP mouse is above
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLine::CchFromUp");
	
	CLock		lock;
	const BOOL	fFirst = _fFirstInPara;
	*phit =		HT_Text;
	LONG		cpActual = me.GetCp();
	CDispDim	dispdim;
	
	me._li = *this;
	*phit = me.HitTest(pt.u);
	me._li._cch = 0;					// Default zero count

	if(*phit == HT_Text || *phit == HT_RightOfText) // To right of left margin
	{
		me.NewLine(*this);

#ifndef NOLINESERVICES
		COls *pols = me.GetPols();		// Try for LineServices object
		if(pols)						// Got it: use LineServices
		{
			pols->CchFromUp(pt, &dispdim, &cpActual);
			g_OLSBusy = FALSE;
		}
		else
#endif
			if(me.Measure(me.DUtoLU(pt.u - _upStart), _cch,
						  MEASURE_BREAKBEFOREWIDTH | MEASURE_IGNOREOFFSET 
						  | (fFirst ? MEASURE_FIRSTINPARA : 0)) >= 0)
			{
				LONG dupBefore = me._li._dup;
				cpActual = me.GetCp();
				if (me._li._cch < _cch)
				{
					LONG dup = pt.u - _upStart - dupBefore;
					dispdim.dup = me._dupAddLast;
					if(dup > dispdim.dup / 2 ||
					   dup > W32->GetDupSystemFont()/2 && me.GetChar() == WCH_EMBEDDING)
					{
						me.Move(1);
						me._li._cch++;
						me._li._dup += dispdim.dup;
					}
				}
			}

		me._rpCF.AdjustForward();
		if(cpActual < me.GetCp() || pt.u >= _upStart + _dup)
			me._rpCF.AdjustBackward();
		DWORD dwEffects = me.GetCF()->_dwEffects;
		if(dwEffects & CFE_LINK)
		{
			if(cpActual < me.GetTextLength())
				*phit = HT_Link;
		}
		else if(dwEffects & CFE_ITALIC)
			*phit = HT_Italic;
	}

	if (pdispdim)
		*pdispdim = dispdim;
	if (pcpActual)
		*pcpActual = cpActual;

	return me._li._cch;
}

/*
 *	CLine::UpFromCch(&me, cch, taMode, pdispdim, pdy)
 *
 *	@mfunc
 *		Measures cch characters starting from this text ptr, returning
 *		the width measured and setting yOffset = y offset relative to
 *		top of line and dx = halfwidth of character at me.GetCp() + cch.
 *		Used for caret placement and object location. pdx returns offset
 *		into the last char measured (at me.GetCp + cch) if taMode includes
 *		TA_CENTER (dx = half the last char width) or TA_RIGHT (dx = whole
 *		char width). pdy returns the vertical offset relative to the top
 *		of the line if taMode includes TA_BASELINE or TA_BOTTOM.
 *
 *	@rdesc 
 *		width of measured text
 *
 *	@devnote
 *		me may be moved.  
 */
LONG CLine::UpFromCch(
	CMeasurer&	me,			//@parm Measurer pointing at text to measure
	LONG		cch,		//@parm Max cch to measure
	UINT		taMode,		//@parm Text-align mode
	CDispDim *	pdispdim,	//@parm display dimensions
	LONG *		pdy) const	//@parm dy offset due to taMode
{
	CLock	lock;
	LONG	dup;
	BOOL	fPols = FALSE;
	CDispDim dispdim;
	LONG	dy = 0;

#ifndef NOLINESERVICES
	COls *pols = me.GetPols();			// Try for LineServices object
	if(pols)
	{									// Got it: use LineServices
		if(cch)							
			taMode &= ~TA_STARTOFLINE;	// Not start of line
		if(cch != _cch)
			taMode &= ~TA_ENDOFLINE;	// Not end of line

		dup = pols->MeasureText(cch, taMode, &dispdim);
		fPols = TRUE;
		g_OLSBusy = FALSE;
	}
	else
#endif
	{
		dup = me.MeasureText(cch) + _upStart;
		dispdim.dup = me._dupAddLast;
	}

	if(taMode != TA_TOP)
	{
		// Check for vertical calculation request
		if(taMode & TA_BASELINE)			// Matches TA_BOTTOM and
		{									//  TA_BASELINE
			if(!_fCollapsed)
			{
				dy = _dvpHeight;
				AssertSz(_dvpHeight != -1, "control has no height; used to use default CHARFORMAT");
				if((taMode & TA_BASELINE) == TA_BASELINE)
				{
					dy -= _dvpDescent;		// Need "== TA_BASELINE" to
					if(!_dvpDescent)		//  distinguish from TA_BOTTOM
						dy--;				// Compensate for weird fonts
				}
			}
		}
	}

	LONG dupAdd = 0;

	if((taMode & TA_CENTER) == TA_CENTER)
		dupAdd = dispdim.dup / 2;
	else if (taMode & TA_RIGHT)
		dupAdd = dispdim.dup;

	if (dispdim.lstflow == lstflowWS && (taMode & TA_LOGICAL))
		dupAdd = -dupAdd;

	dup += dupAdd;

	if (pdispdim)
		*pdispdim = dispdim;
	if (pdy)
		*pdy = dy;

	return max(dup, 0);
}
	
/*
 *	CLine::GetHeight()
 *
 *	@mfunc
 *		Get line height unless in outline mode and collasped, in
 *		which case get 0.
 *
 *	@rdesc
 *		Line height (_yHeight), unless in outline mode and collapsed,
 *		in which case 0.
 */
LONG CLine::GetHeight() const
{
	if (_fCollapsed)
		return 0;

	return IsNestedLayout() ? _plo->_dvp : _dvpHeight;
}

/*
 *	CLine::GetDescent()
 *
 *	@mfunc
 *		Return descent of line. Assumed not to be collapsed
 *
 *	@rdesc
 */
LONG CLine::GetDescent() const
{
	return IsNestedLayout() ? 0 : _dvpDescent;
}

BOOL CLine::IsEqual(CLine& li)
{
	return	_upStart == li._upStart &&
			_plo   == li._plo && //checks _yHeight, _yDescent OR _plo
			_dup == li._dup && 
			_cch == li._cch;
}


// =====================  CLinePtr: Line Run Pointer  ==========================


CLinePtr::CLinePtr(CDisplay *pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::CLinePtr");

	_pdp = pdp;
	_pLine = NULL;
	_pdp->InitLinePtr(* this);
}

void CLinePtr::Init (CLine & line)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::Init");

	_pRuns = 0;
	_pLine = &line;
	_iRun = 0;
	_ich = 0;
}

void CLinePtr::Init (CLineArray & line_arr)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::Init");

	_pRuns = (CRunArray *) & line_arr;
	_iRun = 0;
	_ich = 0;
}

void CLinePtr::Set(
	LONG iRun,
	LONG ich,
	CLineArray *pla)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpSet");

	// See if this is a multi-line ptr
    if(_pRuns)
	{
		if(pla)
		{
			CRunPtr<CLine>::SetRun(0, 0);	// Be sure current state is valid
			_pRuns = (CRunArray *)pla;		//  for new _pRuns
		}
        CRunPtr<CLine>::SetRun(iRun, ich);	// Now set to desired run & ich
	}
    else
    {
        // single line, just reinit and set _ich
        AssertSz(iRun == 0, "CLinePtr::Set() - single line and iRun != 0");
	    _pdp->InitLinePtr(* this);		//  to line 0
	    _ich = ich;
    }
}

// Move runptr by a certain number of cch/runs

BOOL CLinePtr::Move(
	LONG cch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpMove");

	// See if this is a multi-line ptr

	if(_pRuns)
		return (cch == CRunPtr<CLine>::Move(cch));

	return MoveSL(cch);
}
	
BOOL CLinePtr::operator --(int)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator --");

	return _pRuns ? PrevRun() : OperatorPostDeltaSL(-1);
}

BOOL CLinePtr::operator ++(int)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator ++");

	return _pRuns ? NextRun() : OperatorPostDeltaSL(+1);
}

/*
 *	CLinePtr::MoveSL(cch)
 *
 *	@mfunc
 *		move this line pointer forward or backward on the line
 *
 *	@rdesc
 *		TRUE iff could Move cch chars within current line
 */
BOOL CLinePtr::MoveSL(
	LONG cch)	 //@parm signed count of chars to Move by
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpMoveSL");

	Assert(!_pRuns);
	
	if(!_pLine)
		return FALSE;

	_ich += cch;

	if(_ich < 0)
	{
		_ich = 0;
		return FALSE;
	}

	if(_ich > _pLine->_cch)
	{
		_ich = _pLine->_cch;
		return FALSE;
	}

	return TRUE;
}

/*
 *	CLinePtr::OperatorPostDeltaSL(Delta)
 *
 *	@mfunc
 *		Implement line-ptr ++ and -- operators for single-line case
 *
 *	@rdesc
 *		TRUE iff this line ptr is valid
 */
BOOL CLinePtr::OperatorPostDeltaSL(
	LONG Delta)			//@parm 1 for ++ and -1 for --
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::OperatorPostDeltaSL");

	AssertSz(_iRun <= 1 && !_pRuns,
		"LP::++: inconsistent line ptr");

	if(_iRun == -Delta)						// Operation validates an
	{										//  invalid line ptr by moving
		_pdp->InitLinePtr(* this);			//  to line 0
		return TRUE;
	}
	
	_iRun = Delta;							// Operation invalidates this line
	_ich = 0;								//  ptr (if it wasn't already)

	return FALSE;
}

CLine *	CLinePtr::operator ->() const		
{
	return _pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine;
}

CLine * CLinePtr::GetLine() const
{	
    return _pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine;
}

CLine &	CLinePtr::operator *() const      
{	
    return *(_pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine);
}

CLine & CLinePtr::operator [](LONG dRun)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator []");

	if(_pRuns)
		return *(CLine *)CRunPtr<CLine>::GetRun(dRun);

	AssertSz(dRun + _iRun == 0 ,
		"LP::[]: inconsistent line ptr");

	return  *(CLine *)CRunPtr<CLine>::GetRun(_iRun);
}

BOOL CLinePtr::IsValid() const
{ 
	return !_pRuns ? _pLine != NULL : CRunPtrBase::IsValid(); 
}

/*
 *	CLinePtr::SetCp(cp, fAtEnd, lNest)
 *
 *	@mfunc	
 *		Set this line ptr to cp allowing for ambigous cp and taking advantage
 *		of _cpFirstVisible and _iliFirstVisible
 *
 *	@rdesc
 *		TRUE iff able to set to cp
 */
BOOL CLinePtr::SetCp(
	LONG cp,			//@parm Position to set this line ptr to
	BOOL fAtEnd,		//@parm If ambiguous cp: if fAtEnd = TRUE, set this
						// line ptr to end of prev line; else to line start
	LONG lNest)			//@parm Set to deep CLine in nested layouts
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpSetCp");

	_ich = 0;
	if(!_pRuns)
	{
		// This is a single line so just go straight to the single
		// line Move logic. It is important to note that the
		// first visible character is irrelevent to the cp Move
		// for single line displays.
		return MoveSL(cp);
	}

	BOOL fRet;
	LONG cpFirstVisible = _pdp->GetFirstVisibleCp();

	if(cp > cpFirstVisible / 2)
	{											// cpFirstVisible closer than 0
		_iRun = _pdp->GetFirstVisibleLine();
		fRet = Move(cp - cpFirstVisible);
	}
	else
		fRet = (cp == CRunPtr<CLine>::BindToCp(cp));// Start from 0

	if(lNest)
	{
		CLayout *plo;
		while(plo = GetLine()->GetPlo())
		{
			LONG cch = _ich;
			if(plo->IsTableRow())
			{
				if(cch <= 2 && lNest == 1)		// At start of table row:
					break;						//  leave this rp there
				cch -= 2;						// Bypass table row start code
			}
			Set(0, 0, (CLineArray *)plo);		// Goto start of layout plo
			Move(cch);							// Move to parent _ich
		}
	}

	if(fAtEnd)									// Ambiguous-cp caret position
		AdjustBackward();						//  belongs at prev EOL

	return fRet;
}

/*
 *	CLinePtr::FindParagraph(fForward)
 *
 *	@mfunc	
 *		Move this line ptr to paragraph (fForward) ? end : start,
 *		and return change in cp
 *
 *	@rdesc
 *		change in cp
 */
LONG CLinePtr::FindParagraph(
	BOOL fForward)		//@parm TRUE move to para end; else to para start
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::FindParagraph");

	LONG	cch;
	CLine *	pli = GetLine();

	if(!fForward)							// Go to para start
	{
		cch = 0;							// Default already at para start
		if (_ich != pli->_cch ||
			!(pli->_fHasEOP))				// It isn't at para start
		{
			cch = -_ich;					// Go to start of current line
			while(!(pli->_fFirstInPara) && _iRun > 0)
			{
				pli--;
				_iRun--;
				cch -= pli->_cch;			// Subtract # chars in line
			}
			_ich = 0;						// Leave *this at para start
		}
	}
	else									// Go to para end
	{
		cch = GetCchLeft();					// Go to end of current line
		if(!_pRuns)
			return cch;						// Single line

		LONG cLine	 = _pRuns->Count();
		BOOL fNested = _pRuns->Elem(0) != ((CDisplayML *)_pdp)->Elem(0);

		while((_iRun < cLine - 1 || !fNested &&
				_pdp->WaitForRecalcIli(_iRun + 1))
			  && !(pli->_fHasEOP))
		{
			pli++;							// Go to start of next line
			_iRun++;
			cch += pli->_cch;				// Add # chars in line
		}
		_ich = pli->_cch;					// Leave *this at para end
	}
	return cch;
}

/*
 *	CLinePtr::GetAdjustedLineLength()
 *
 *	@mfunc	returns length of line _without_ EOP markers
 *
 *	@rdesc	LONG; length of line
 */
LONG CLinePtr::GetAdjustedLineLength()
{
	CLine * pline = GetLine();

	return pline->_cch - pline->_cchEOP;
}

/*
 *	CLinePtr::GetCchLeft()
 *
 *	@mfunc
 *		Calculate length of text left in run starting at the current cp.
 *		Complements GetIch(), which	is length of text up to this cp. 
 *
 *	@rdesc
 *		length of text so calculated
 */
LONG CLinePtr::GetCchLeft() const
{
	return _pRuns ? CRunPtrBase::GetCchLeft() : _pLine->_cch - _ich;
}

/*
 *	CLinePtr::GetNumber()
 *
 *	@mfunc
 *		Get paragraph number 
 *
 *	@rdesc
 *		paragraph number
 */
WORD CLinePtr::GetNumber()
{
	if(!IsValid())
		return 0;

	_pLine = GetLine();
	if(!_iRun && _pLine->_bNumber > 1)
		_pLine->_bNumber = 1;

	return _pLine->_bNumber;
}

/*
 *	CLinePtr::CountPages(&cPage, cchMax, cp, cchText)
 *
 *	@mfunc
 *		Count characters up to <p cPages> pages away or <p cchMax> chars,
 *		whichever comes first. If the target page and <p cchMax> are both
 *		beyond the corresponding end of the document, count up thru the
 *		closest page.  The direction of counting is	determined by the sign
 *		of <p cPage>.  To count without being limited by <p cchMax>, set it
 *		equal to tomForward. An initial partial	page counts as a page.
 *
 *	@rdesc
 *		Return the signed cch counted and set <p cPage> equal to count of
 *		pages actually counted.  If no pages are allocated, the text is
 *		treated as a single page.  If <p cPage> = 0, -cch to the start of the
 *		current page is returned. If <p cPage> <gt> 0 and cp is at the end
 *		of the document, 0 is returned.
 *
 *	@devnote
 *		The maximum count capability is included to be able to count units in
 *		a range.
 *
 *	@todo
 *		EN_PAGECHANGE
 */
LONG CLinePtr::CountPages (
	LONG &cPage,		//@parm Count of pages to get cch for
	LONG  cchMax,		//@parm Maximum char count
	LONG  cp,			//@parm CRchTxtPtr::GetCp()
	LONG  cchText) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CLinePtr::CountPages");

	if(!_pdp->IsInPageView())
	{
		cPage = 0;
		return tomBackward;					// Signal error
	}
	Assert(IsValid());

	LONG	cch;
	LONG	j = cPage;
	CLine *pli = (CLine *)GetLine();		// Not NULL since lines exist

	if(cPage < 0)							// Try to count backward cPage pages
	{
		// TODO: eliminate cchText and cp (currently only used for validation)
		Assert(cchMax <= cp);				// Don't undershoot
		for(cch = _ich; j && cch <= cchMax; cch += pli->_cch)
		{
			if(pli->_fFirstOnPage && cch)	// !cch prevents counting current
				j++;						//  page if at start of that page
			if(cch >= cchMax)					
			{
				Assert(cch == cp);
				break;						// At beginning of doc, so done
			}

			if (!j)
				break;						// Done counting backward

			pli--;
			VALIDATE_PTR(pli);
		}
		cPage -= j;							// Discount any pages not counted
		return -cch;
	}

	Assert(cPage > 0 && cchMax <= cchText - cp);

	for(cch	= GetCchLeft(); cch < cchMax; cch += pli->_cch)
	{
		pli++;
		VALIDATE_PTR(pli);
		if(pli->_fFirstOnPage && cch)		// !cch prevents counting current
		{									//  page if at start of that page
			j--;
			if(!j)
				break;
		}
	}
	cPage -= j;								// Discount any pages not counted
	return cch;
}

/*
 *	CLinePtr::FindPage (pcpMin, pcpMost, cpMin, cch, cchText)
 *
 *	@mfunc
 *		Set *<p pcpMin>  = closest page cpMin <lt>= range cpMin, and
 *		set *<p pcpMost> = closest page cpMost <gt>= range cpMost
 *
 *	@devnote
 *		This routine plays a role analogous to CTxtRange::FindParagraph
 *		(pcpMin, pcpMost), but needs extra arguments since this line ptr does
 *		not know the range cp's.  This line ptr is located at the range active
 *		end, which is determined by the range's signed length <p cch> in
 *		conjunction with <p cpMin>.  See also the very similar function
 *		CRunPtrBase::FindRun().  The differences seem to make a separate
 *		encoding simpler.
 */
void CLinePtr::FindPage (
	LONG *pcpMin,			//@parm Out parm for bounding-page cpMin
	LONG *pcpMost,			//@parm Out parm for bounding-page cpMost
	LONG cpMin,				//@parm Range cpMin
	LONG cch,				//@parm Range signed length
	LONG cchText)			//@parm Story length
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CLinePtr::FindPage");

	Assert(_pdp->IsMultiLine() && _pdp->IsInPageView());

	LONG	cp;							
	BOOL	fMove;						// Controls Move for pcpMost
	LONG	i;
	CLine *pli;

	AdjustForward();					// Select forward line
	if(pcpMin)
	{									// If cch != 0, rp is sure to end up
		fMove = cch;					//  at cpMin, so pcpMost needs advance
		if(cch > 0)						// rp is at cpMost, so move it to
			Move(-cch);					//  cpMin
		cp = cpMin - _ich;				// Subtract off line offset in this run
		pli = (CLine *)GetLine();
		for(i = GetLineIndex(); i > 0 && !pli->_fFirstOnPage; i--)
		{
			pli--;
			cp -= pli->_cch;
		}
		*pcpMin = cp;
	}
	else
		fMove = cch < 0;				// Need to advance to get pcpMost

	if(pcpMost)
	{
		LONG cLine = ((CDisplayML *)_pdp)->Count();

		cch = abs(cch);
		if(fMove)						// Advance to cpMost = cpMin + cch,
			Move(cch);					//  i.e., range's cpMost
		cp = cpMin + cch;
		pli = (CLine *)GetLine();
		i = GetLineIndex();
		if(pcpMin && cp == *pcpMin)		// Expand IP to next page
		{
			Assert(!_ich);
			cp += pli->_cch;			// Include first line even if it starts
			pli++;						//  a new page (pli->_fFirstOnPage = 1)
			i++;						
		}
		else if (_ich)
		{								// If not at start of line, add
			cp += GetCchLeft();			//  remaining cch in run to cpMost, and
			pli++;						//  skip to next line
			i++;
		}

		while(i < cLine && !pli->_fFirstOnPage)
		{
			cp += pli->_cch;			// Add in next line's
			pli++;
			i++;
		}
		*pcpMost = cp;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\msctfp_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

/* c6debc0a-f2b2-4f17-930e-ca9faff4cd04 */
const GUID GUID_TFCAT_TIP_REFERENCE = { 
    0xc6debc0a,
    0xf2b2,
    0x4f17,
    {0x93, 0x0e, 0xca, 0x9f, 0xaf, 0xf4, 0xcd, 0x04}
  };

/* 5130a009-5540-4fcf-97eb-aad33fc0ee09 */
const GUID GUID_TFCAT_TIP_PROOFING = { 
    0x5130a009,
    0x5540,
    0x4fcf,
    {0x97, 0xeb, 0xaa, 0xd3, 0x3f, 0xc0, 0xee, 0x09}
  };

/* 7ae86bb7-262c-431e-9111-c974b6b7cac3 */
const GUID GUID_TFCAT_TIP_SMARTTAG = { 
    0x7ae86bb7,
    0x262c,
    0x431e,
    {0x91, 0x11, 0xc9, 0x74, 0xb6, 0xb7, 0xca, 0xc3}
  };

/* cc33ce20-13c6-4e88-a4b4-78f1b685c762 */
const GUID GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT = { 
    0xcc33ce20,
    0x13c6,
    0x4e88,
    {0xa4, 0xb4, 0x78, 0xf1, 0xb6, 0x85, 0xc7, 0x62}
  };

/* c0db7b30-7b78-4dac-b52a-5fd61e7b58fa */
const GUID GUID_SERVICE_TEXTSTORE = { 
    0xc0db7b30,
    0x7b78,
    0x4dac,
    {0xb5, 0x2a, 0x5f, 0xd6, 0x1e, 0x7b, 0x58, 0xfa}
  };

/* aabf7f9a-4487-4b2e-8164-e54c5fe19204 */
const GUID GUID_SERVICE_TF = { 
    0xaabf7f9a,
    0x4487,
    0x4b2e,
    {0x81, 0x64, 0xe5, 0x4c, 0x5f, 0xe1, 0x92, 0x04}
  };

/* c0eb60fe-473e-4a0c-be36-52f0bc985473 */
const GUID GUID_COMPARTMENT_ENABLESTATE = { 
    0xc0eb60fe,
    0x473e,
    0x4a0c,
    {0xbe, 0x36, 0x52, 0xf0, 0xbc, 0x98, 0x54, 0x73}
  };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\msctfp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for msctfp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msctfp_h__
#define __msctfp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfThreadMgr_P_FWD_DEFINED__
#define __ITfThreadMgr_P_FWD_DEFINED__
typedef interface ITfThreadMgr_P ITfThreadMgr_P;
#endif 	/* __ITfThreadMgr_P_FWD_DEFINED__ */


#ifndef __ITfSysHookSink_FWD_DEFINED__
#define __ITfSysHookSink_FWD_DEFINED__
typedef interface ITfSysHookSink ITfSysHookSink;
#endif 	/* __ITfSysHookSink_FWD_DEFINED__ */


#ifndef __ITfStartReconversionNotifySink_FWD_DEFINED__
#define __ITfStartReconversionNotifySink_FWD_DEFINED__
typedef interface ITfStartReconversionNotifySink ITfStartReconversionNotifySink;
#endif 	/* __ITfStartReconversionNotifySink_FWD_DEFINED__ */


#ifndef __ITfLangBarEventSink_P_FWD_DEFINED__
#define __ITfLangBarEventSink_P_FWD_DEFINED__
typedef interface ITfLangBarEventSink_P ITfLangBarEventSink_P;
#endif 	/* __ITfLangBarEventSink_P_FWD_DEFINED__ */


#ifndef __ITfLangBarMgr_P_FWD_DEFINED__
#define __ITfLangBarMgr_P_FWD_DEFINED__
typedef interface ITfLangBarMgr_P ITfLangBarMgr_P;
#endif 	/* __ITfLangBarMgr_P_FWD_DEFINED__ */


#ifndef __ITfContext_P_FWD_DEFINED__
#define __ITfContext_P_FWD_DEFINED__
typedef interface ITfContext_P ITfContext_P;
#endif 	/* __ITfContext_P_FWD_DEFINED__ */


#ifndef __ITfRangeChangeSink_FWD_DEFINED__
#define __ITfRangeChangeSink_FWD_DEFINED__
typedef interface ITfRangeChangeSink ITfRangeChangeSink;
#endif 	/* __ITfRangeChangeSink_FWD_DEFINED__ */


#ifndef __ITfFnAbort_FWD_DEFINED__
#define __ITfFnAbort_FWD_DEFINED__
typedef interface ITfFnAbort ITfFnAbort;
#endif 	/* __ITfFnAbort_FWD_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_FWD_DEFINED__
#define __ITfMouseTrackerAnchor_FWD_DEFINED__
typedef interface ITfMouseTrackerAnchor ITfMouseTrackerAnchor;
#endif 	/* __ITfMouseTrackerAnchor_FWD_DEFINED__ */


#ifndef __ITfRangeAnchor_FWD_DEFINED__
#define __ITfRangeAnchor_FWD_DEFINED__
typedef interface ITfRangeAnchor ITfRangeAnchor;
#endif 	/* __ITfRangeAnchor_FWD_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
typedef interface ITfPersistentPropertyLoaderAnchor ITfPersistentPropertyLoaderAnchor;
#endif 	/* __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__ */


#ifndef __ITextStoreAnchorServices_FWD_DEFINED__
#define __ITextStoreAnchorServices_FWD_DEFINED__
typedef interface ITextStoreAnchorServices ITextStoreAnchorServices;
#endif 	/* __ITextStoreAnchorServices_FWD_DEFINED__ */


#ifndef __ITfProperty2_FWD_DEFINED__
#define __ITfProperty2_FWD_DEFINED__
typedef interface ITfProperty2 ITfProperty2;
#endif 	/* __ITfProperty2_FWD_DEFINED__ */


#ifndef __IEnumTfCollection_FWD_DEFINED__
#define __IEnumTfCollection_FWD_DEFINED__
typedef interface IEnumTfCollection IEnumTfCollection;
#endif 	/* __IEnumTfCollection_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__
#define __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__
typedef interface ITfDisplayAttributeCollectionMgr ITfDisplayAttributeCollectionMgr;
#endif 	/* __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__
#define __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__
typedef interface ITfDisplayAttributeCollectionProvider ITfDisplayAttributeCollectionProvider;
#endif 	/* __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__ */


#ifndef __IEnumTfRenderingMarkup_FWD_DEFINED__
#define __IEnumTfRenderingMarkup_FWD_DEFINED__
typedef interface IEnumTfRenderingMarkup IEnumTfRenderingMarkup;
#endif 	/* __IEnumTfRenderingMarkup_FWD_DEFINED__ */


#ifndef __ITfContextRenderingMarkup_FWD_DEFINED__
#define __ITfContextRenderingMarkup_FWD_DEFINED__
typedef interface ITfContextRenderingMarkup ITfContextRenderingMarkup;
#endif 	/* __ITfContextRenderingMarkup_FWD_DEFINED__ */


#ifndef __ITfBackgroundThreadMgr_FWD_DEFINED__
#define __ITfBackgroundThreadMgr_FWD_DEFINED__
typedef interface ITfBackgroundThreadMgr ITfBackgroundThreadMgr;
#endif 	/* __ITfBackgroundThreadMgr_FWD_DEFINED__ */


#ifndef __ITfEnableService_FWD_DEFINED__
#define __ITfEnableService_FWD_DEFINED__
typedef interface ITfEnableService ITfEnableService;
#endif 	/* __ITfEnableService_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msctfp_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// msctfp.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// MSCTF Private Interfaces.

#ifndef MSCTFP_DEFINED
#define MSCTFP_DEFINED

#include <windows.h>

EXTERN_C const GUID GUID_TFCAT_TIP_REFERENCE;
EXTERN_C const GUID GUID_TFCAT_TIP_PROOFING;
EXTERN_C const GUID GUID_TFCAT_TIP_SMARTTAG;
EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT;
EXTERN_C const GUID GUID_SERVICE_TEXTSTORE;
EXTERN_C const GUID GUID_SERVICE_TF;

#define TF_LBU_CAPSKANAKEY               1
#define TF_LBU_NTCONSOLELANGCHANGE       2
#define TF_LBUF_CAPS        0x0001
#define TF_LBUF_KANA        0x0002
#define	TF_ES_READ_PROPERTY_WRITE	( 0x12 )



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0000_v0_0_s_ifspec;

#ifndef __ITfThreadMgr_P_INTERFACE_DEFINED__
#define __ITfThreadMgr_P_INTERFACE_DEFINED__

/* interface ITfThreadMgr_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfThreadMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f65567a7-34a1-46f4-b5dd-8804aeb06ff7")
    ITfThreadMgr_P : public ITfThreadMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssociated( 
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSysHookSink( 
            /* [in] */ ITfSysHookSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestPostponedLock( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsKeystrokeFeedEnabled( 
            /* [out] */ BOOL *pfEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfThreadMgr_P * This,
            /* [out] */ TfClientId *ptid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfThreadMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentMgr )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDocumentMgrs )( 
            ITfThreadMgr_P * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfDocumentMgr **ppdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfDocumentMgr *pdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateFocus )( 
            ITfThreadMgr_P * This,
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev);
        
        HRESULT ( STDMETHODCALLTYPE *IsThreadFocus )( 
            ITfThreadMgr_P * This,
            /* [out] */ BOOL *pfThreadFocus);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionProvider )( 
            ITfThreadMgr_P * This,
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFunctionProviders )( 
            ITfThreadMgr_P * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalCompartment )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfCompartmentMgr **ppCompMgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssociated )( 
            ITfThreadMgr_P * This,
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *SetSysHookSink )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfSysHookSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RequestPostponedLock )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *IsKeystrokeFeedEnabled )( 
            ITfThreadMgr_P * This,
            /* [out] */ BOOL *pfEnabled);
        
        END_INTERFACE
    } ITfThreadMgr_PVtbl;

    interface ITfThreadMgr_P
    {
        CONST_VTBL struct ITfThreadMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgr_P_Activate(This,ptid)	\
    (This)->lpVtbl -> Activate(This,ptid)

#define ITfThreadMgr_P_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ITfThreadMgr_P_CreateDocumentMgr(This,ppdim)	\
    (This)->lpVtbl -> CreateDocumentMgr(This,ppdim)

#define ITfThreadMgr_P_EnumDocumentMgrs(This,ppEnum)	\
    (This)->lpVtbl -> EnumDocumentMgrs(This,ppEnum)

#define ITfThreadMgr_P_GetFocus(This,ppdimFocus)	\
    (This)->lpVtbl -> GetFocus(This,ppdimFocus)

#define ITfThreadMgr_P_SetFocus(This,pdimFocus)	\
    (This)->lpVtbl -> SetFocus(This,pdimFocus)

#define ITfThreadMgr_P_AssociateFocus(This,hwnd,pdimNew,ppdimPrev)	\
    (This)->lpVtbl -> AssociateFocus(This,hwnd,pdimNew,ppdimPrev)

#define ITfThreadMgr_P_IsThreadFocus(This,pfThreadFocus)	\
    (This)->lpVtbl -> IsThreadFocus(This,pfThreadFocus)

#define ITfThreadMgr_P_GetFunctionProvider(This,clsid,ppFuncProv)	\
    (This)->lpVtbl -> GetFunctionProvider(This,clsid,ppFuncProv)

#define ITfThreadMgr_P_EnumFunctionProviders(This,ppEnum)	\
    (This)->lpVtbl -> EnumFunctionProviders(This,ppEnum)

#define ITfThreadMgr_P_GetGlobalCompartment(This,ppCompMgr)	\
    (This)->lpVtbl -> GetGlobalCompartment(This,ppCompMgr)


#define ITfThreadMgr_P_GetAssociated(This,hWnd,ppdim)	\
    (This)->lpVtbl -> GetAssociated(This,hWnd,ppdim)

#define ITfThreadMgr_P_SetSysHookSink(This,pSink)	\
    (This)->lpVtbl -> SetSysHookSink(This,pSink)

#define ITfThreadMgr_P_RequestPostponedLock(This,pic)	\
    (This)->lpVtbl -> RequestPostponedLock(This,pic)

#define ITfThreadMgr_P_IsKeystrokeFeedEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsKeystrokeFeedEnabled(This,pfEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_GetAssociated_Proxy( 
    ITfThreadMgr_P * This,
    /* [in] */ HWND hWnd,
    /* [out] */ ITfDocumentMgr **ppdim);


void __RPC_STUB ITfThreadMgr_P_GetAssociated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_SetSysHookSink_Proxy( 
    ITfThreadMgr_P * This,
    /* [in] */ ITfSysHookSink *pSink);


void __RPC_STUB ITfThreadMgr_P_SetSysHookSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_RequestPostponedLock_Proxy( 
    ITfThreadMgr_P * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfThreadMgr_P_RequestPostponedLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_IsKeystrokeFeedEnabled_Proxy( 
    ITfThreadMgr_P * This,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB ITfThreadMgr_P_IsKeystrokeFeedEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfSysHookSink_INTERFACE_DEFINED__
#define __ITfSysHookSink_INTERFACE_DEFINED__

/* interface ITfSysHookSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSysHookSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("495388DA-21A5-4852-8BB1-ED2F29DA8D60")
    ITfSysHookSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPreFocusDIM( 
            /* [in] */ HWND hWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSysKeyboardProc( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSysShellProc( 
            /* [in] */ int nCode,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSysHookSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSysHookSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSysHookSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSysHookSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnPreFocusDIM )( 
            ITfSysHookSink * This,
            /* [in] */ HWND hWnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSysKeyboardProc )( 
            ITfSysHookSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *OnSysShellProc )( 
            ITfSysHookSink * This,
            /* [in] */ int nCode,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfSysHookSinkVtbl;

    interface ITfSysHookSink
    {
        CONST_VTBL struct ITfSysHookSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSysHookSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSysHookSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSysHookSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSysHookSink_OnPreFocusDIM(This,hWnd)	\
    (This)->lpVtbl -> OnPreFocusDIM(This,hWnd)

#define ITfSysHookSink_OnSysKeyboardProc(This,wParam,lParam)	\
    (This)->lpVtbl -> OnSysKeyboardProc(This,wParam,lParam)

#define ITfSysHookSink_OnSysShellProc(This,nCode,wParam,lParam)	\
    (This)->lpVtbl -> OnSysShellProc(This,nCode,wParam,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnPreFocusDIM_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ HWND hWnd);


void __RPC_STUB ITfSysHookSink_OnPreFocusDIM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnSysKeyboardProc_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfSysHookSink_OnSysKeyboardProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnSysShellProc_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ int nCode,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfSysHookSink_OnSysShellProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSysHookSink_INTERFACE_DEFINED__ */


#ifndef __ITfStartReconversionNotifySink_INTERFACE_DEFINED__
#define __ITfStartReconversionNotifySink_INTERFACE_DEFINED__

/* interface ITfStartReconversionNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfStartReconversionNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b9cd19cb-2919-4935-8768-ef30bae9a0cc")
    ITfStartReconversionNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartReconversion( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndReconversion( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfStartReconversionNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfStartReconversionNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfStartReconversionNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfStartReconversionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartReconversion )( 
            ITfStartReconversionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndReconversion )( 
            ITfStartReconversionNotifySink * This);
        
        END_INTERFACE
    } ITfStartReconversionNotifySinkVtbl;

    interface ITfStartReconversionNotifySink
    {
        CONST_VTBL struct ITfStartReconversionNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfStartReconversionNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfStartReconversionNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfStartReconversionNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfStartReconversionNotifySink_StartReconversion(This)	\
    (This)->lpVtbl -> StartReconversion(This)

#define ITfStartReconversionNotifySink_EndReconversion(This)	\
    (This)->lpVtbl -> EndReconversion(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfStartReconversionNotifySink_StartReconversion_Proxy( 
    ITfStartReconversionNotifySink * This);


void __RPC_STUB ITfStartReconversionNotifySink_StartReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfStartReconversionNotifySink_EndReconversion_Proxy( 
    ITfStartReconversionNotifySink * This);


void __RPC_STUB ITfStartReconversionNotifySink_EndReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfStartReconversionNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarEventSink_P_INTERFACE_DEFINED__
#define __ITfLangBarEventSink_P_INTERFACE_DEFINED__

/* interface ITfLangBarEventSink_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarEventSink_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a460360-da21-4b09-a8a0-8a69e728d893")
    ITfLangBarEventSink_P : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLangBarUpdate( 
            /* [in] */ UINT uPdate,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarEventSink_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarEventSink_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarEventSink_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarEventSink_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLangBarUpdate )( 
            ITfLangBarEventSink_P * This,
            /* [in] */ UINT uPdate,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfLangBarEventSink_PVtbl;

    interface ITfLangBarEventSink_P
    {
        CONST_VTBL struct ITfLangBarEventSink_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarEventSink_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarEventSink_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarEventSink_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarEventSink_P_OnLangBarUpdate(This,uPdate,lParam)	\
    (This)->lpVtbl -> OnLangBarUpdate(This,uPdate,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_P_OnLangBarUpdate_Proxy( 
    ITfLangBarEventSink_P * This,
    /* [in] */ UINT uPdate,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfLangBarEventSink_P_OnLangBarUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarEventSink_P_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarMgr_P_INTERFACE_DEFINED__
#define __ITfLangBarMgr_P_INTERFACE_DEFINED__

/* interface ITfLangBarMgr_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d72c0fa9-add5-4af0-8706-4fa9ae3e2eff")
    ITfLangBarMgr_P : public ITfLangBarMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPrevShowFloatingStatus( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventSink )( 
            ITfLangBarMgr_P * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseEventSink )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadMarshalInterface )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadLangBarItemMgr )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfLangBarItemMgr **pplbi,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputProcessorProfiles )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfInputProcessorProfiles **ppaip,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreLastFocus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwThreadId,
            /* [in] */ BOOL fPrev);
        
        HRESULT ( STDMETHODCALLTYPE *SetModalInput )( 
            ITfLangBarMgr_P * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ShowFloating )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowFloatingStatus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrevShowFloatingStatus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } ITfLangBarMgr_PVtbl;

    interface ITfLangBarMgr_P
    {
        CONST_VTBL struct ITfLangBarMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarMgr_P_AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)	\
    (This)->lpVtbl -> AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)

#define ITfLangBarMgr_P_UnadviseEventSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseEventSink(This,dwCookie)

#define ITfLangBarMgr_P_GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)	\
    (This)->lpVtbl -> GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)

#define ITfLangBarMgr_P_GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)	\
    (This)->lpVtbl -> GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)

#define ITfLangBarMgr_P_GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)	\
    (This)->lpVtbl -> GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)

#define ITfLangBarMgr_P_RestoreLastFocus(This,pdwThreadId,fPrev)	\
    (This)->lpVtbl -> RestoreLastFocus(This,pdwThreadId,fPrev)

#define ITfLangBarMgr_P_SetModalInput(This,pSink,dwThreadId,dwFlags)	\
    (This)->lpVtbl -> SetModalInput(This,pSink,dwThreadId,dwFlags)

#define ITfLangBarMgr_P_ShowFloating(This,dwFlags)	\
    (This)->lpVtbl -> ShowFloating(This,dwFlags)

#define ITfLangBarMgr_P_GetShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetShowFloatingStatus(This,pdwFlags)


#define ITfLangBarMgr_P_GetPrevShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetPrevShowFloatingStatus(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarMgr_P_GetPrevShowFloatingStatus_Proxy( 
    ITfLangBarMgr_P * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ITfLangBarMgr_P_GetPrevShowFloatingStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfContext_P_INTERFACE_DEFINED__
#define __ITfContext_P_INTERFACE_DEFINED__

/* interface ITfContext_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContext_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2dee47c8-704d-42a0-9983-ffeed659b64d")
    ITfContext_P : public ITfContext
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapAppProperty( 
            /* [in] */ REFGUID guidAppProp,
            /* [in] */ REFGUID guidProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContext_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContext_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContext_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContext_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestEditSession )( 
            ITfContext_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfEditSession *pes,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HRESULT *phrSession);
        
        HRESULT ( STDMETHODCALLTYPE *InWriteSession )( 
            ITfContext_P * This,
            /* [in] */ TfClientId tid,
            /* [out] */ BOOL *pfWriteSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const TF_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetStart )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnd )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveView )( 
            ITfContext_P * This,
            /* [out] */ ITfContextView **ppView);
        
        HRESULT ( STDMETHODCALLTYPE *EnumViews )( 
            ITfContext_P * This,
            /* [out] */ IEnumTfContextViews **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfContext_P * This,
            /* [out] */ TF_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfReadOnlyProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *TrackProperties )( 
            ITfContext_P * This,
            /* [size_is][in] */ const GUID **prgProp,
            /* [in] */ ULONG cProp,
            /* [size_is][in] */ const GUID **prgAppProp,
            /* [in] */ ULONG cAppProp,
            /* [out] */ ITfReadOnlyProperty **ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            ITfContext_P * This,
            /* [out] */ IEnumTfProperties **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentMgr )( 
            ITfContext_P * This,
            /* [out] */ ITfDocumentMgr **ppDm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRangeBackup )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRangeBackup **ppBackup);
        
        HRESULT ( STDMETHODCALLTYPE *MapAppProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidAppProp,
            /* [in] */ REFGUID guidProp);
        
        END_INTERFACE
    } ITfContext_PVtbl;

    interface ITfContext_P
    {
        CONST_VTBL struct ITfContext_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContext_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContext_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContext_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContext_P_RequestEditSession(This,tid,pes,dwFlags,phrSession)	\
    (This)->lpVtbl -> RequestEditSession(This,tid,pes,dwFlags,phrSession)

#define ITfContext_P_InWriteSession(This,tid,pfWriteSession)	\
    (This)->lpVtbl -> InWriteSession(This,tid,pfWriteSession)

#define ITfContext_P_GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)	\
    (This)->lpVtbl -> GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)

#define ITfContext_P_SetSelection(This,ec,ulCount,pSelection)	\
    (This)->lpVtbl -> SetSelection(This,ec,ulCount,pSelection)

#define ITfContext_P_GetStart(This,ec,ppStart)	\
    (This)->lpVtbl -> GetStart(This,ec,ppStart)

#define ITfContext_P_GetEnd(This,ec,ppEnd)	\
    (This)->lpVtbl -> GetEnd(This,ec,ppEnd)

#define ITfContext_P_GetActiveView(This,ppView)	\
    (This)->lpVtbl -> GetActiveView(This,ppView)

#define ITfContext_P_EnumViews(This,ppEnum)	\
    (This)->lpVtbl -> EnumViews(This,ppEnum)

#define ITfContext_P_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITfContext_P_GetProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetProperty(This,guidProp,ppProp)

#define ITfContext_P_GetAppProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetAppProperty(This,guidProp,ppProp)

#define ITfContext_P_TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)	\
    (This)->lpVtbl -> TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)

#define ITfContext_P_EnumProperties(This,ppEnum)	\
    (This)->lpVtbl -> EnumProperties(This,ppEnum)

#define ITfContext_P_GetDocumentMgr(This,ppDm)	\
    (This)->lpVtbl -> GetDocumentMgr(This,ppDm)

#define ITfContext_P_CreateRangeBackup(This,ec,pRange,ppBackup)	\
    (This)->lpVtbl -> CreateRangeBackup(This,ec,pRange,ppBackup)


#define ITfContext_P_MapAppProperty(This,guidAppProp,guidProp)	\
    (This)->lpVtbl -> MapAppProperty(This,guidAppProp,guidProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContext_P_MapAppProperty_Proxy( 
    ITfContext_P * This,
    /* [in] */ REFGUID guidAppProp,
    /* [in] */ REFGUID guidProp);


void __RPC_STUB ITfContext_P_MapAppProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContext_P_INTERFACE_DEFINED__ */


#ifndef __ITfRangeChangeSink_INTERFACE_DEFINED__
#define __ITfRangeChangeSink_INTERFACE_DEFINED__

/* interface ITfRangeChangeSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeChangeSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1a0e6af-0d60-4800-9796-1fe8e85c0cca")
    ITfRangeChangeSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnChange( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeChangeSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeChangeSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeChangeSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeChangeSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            ITfRangeChangeSink * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfRangeChangeSinkVtbl;

    interface ITfRangeChangeSink
    {
        CONST_VTBL struct ITfRangeChangeSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeChangeSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeChangeSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeChangeSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeChangeSink_OnChange(This,pRange)	\
    (This)->lpVtbl -> OnChange(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeChangeSink_OnChange_Proxy( 
    ITfRangeChangeSink * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfRangeChangeSink_OnChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeChangeSink_INTERFACE_DEFINED__ */


#ifndef __ITfFnAbort_INTERFACE_DEFINED__
#define __ITfFnAbort_INTERFACE_DEFINED__

/* interface ITfFnAbort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnAbort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17f2317f-addb-49df-870e-66227bc51d1a")
    ITfFnAbort : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnAbortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnAbort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnAbort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnAbort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnAbort * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ITfFnAbort * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfFnAbortVtbl;

    interface ITfFnAbort
    {
        CONST_VTBL struct ITfFnAbortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnAbort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnAbort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnAbort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnAbort_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnAbort_Abort(This,pic)	\
    (This)->lpVtbl -> Abort(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnAbort_Abort_Proxy( 
    ITfFnAbort * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfFnAbort_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnAbort_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_INTERFACE_DEFINED__
#define __ITfMouseTrackerAnchor_INTERFACE_DEFINED__

/* interface ITfMouseTrackerAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTrackerAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f9f4e0f2-d600-4a4c-b144-77e201ebd1b0")
    ITfMouseTrackerAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTrackerAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTrackerAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerAnchorVtbl;

    interface ITfMouseTrackerAnchor
    {
        CONST_VTBL struct ITfMouseTrackerAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTrackerAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTrackerAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTrackerAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTrackerAnchor_AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)

#define ITfMouseTrackerAnchor_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_AdviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_UnadviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTrackerAnchor_INTERFACE_DEFINED__ */


#ifndef __ITfRangeAnchor_INTERFACE_DEFINED__
#define __ITfRangeAnchor_INTERFACE_DEFINED__

/* interface ITfRangeAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8b99712b-5815-4bcc-b9a9-53db1c8d6755")
    ITfRangeAnchor : public ITfRange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtent( 
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtent( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRangeAnchor * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtent )( 
            ITfRangeAnchor * This,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtent )( 
            ITfRangeAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd);
        
        END_INTERFACE
    } ITfRangeAnchorVtbl;

    interface ITfRangeAnchor
    {
        CONST_VTBL struct ITfRangeAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeAnchor_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRangeAnchor_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRangeAnchor_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRangeAnchor_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRangeAnchor_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRangeAnchor_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRangeAnchor_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRangeAnchor_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRangeAnchor_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRangeAnchor_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRangeAnchor_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRangeAnchor_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfRangeAnchor_GetExtent(This,ppaStart,ppaEnd)	\
    (This)->lpVtbl -> GetExtent(This,ppaStart,ppaEnd)

#define ITfRangeAnchor_SetExtent(This,paStart,paEnd)	\
    (This)->lpVtbl -> SetExtent(This,paStart,paEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeAnchor_GetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [out] */ IAnchor **ppaStart,
    /* [out] */ IAnchor **ppaEnd);


void __RPC_STUB ITfRangeAnchor_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRangeAnchor_SetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd);


void __RPC_STUB ITfRangeAnchor_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);






/* interface __MIDL_itf_msctfp_0222 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("af9f076f-4937-4285-8600-81dca5c31eb6") struct TF_PERSISTENT_PROPERTY_HEADER_ANCHOR
    {
    GUID guidType;
    IAnchor *paStart;
    IAnchor *paEnd;
    ULONG cb;
    DWORD dwPrivate;
    CLSID clsidTIP;
    } 	TF_PERSISTENT_PROPERTY_HEADER_ANCHOR;

#endif 	/* __ITfRangeAnchor_INTERFACE_DEFINED__ */

extern RPC_IF_HANDLE __MIDL_itf_msctfp_0222_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0222_v0_0_s_ifspec;

#ifndef __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__

/* interface ITfPersistentPropertyLoaderAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPersistentPropertyLoaderAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2133f790-34c2-11d3-a745-0050040ab407")
    ITfPersistentPropertyLoaderAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadProperty( 
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPersistentPropertyLoaderAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProperty )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream);
        
        END_INTERFACE
    } ITfPersistentPropertyLoaderAnchorVtbl;

    interface ITfPersistentPropertyLoaderAnchor
    {
        CONST_VTBL struct ITfPersistentPropertyLoaderAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPersistentPropertyLoaderAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPersistentPropertyLoaderAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPersistentPropertyLoaderAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPersistentPropertyLoaderAnchor_LoadProperty(This,pHdr,ppStream)	\
    (This)->lpVtbl -> LoadProperty(This,pHdr,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPersistentPropertyLoaderAnchor_LoadProperty_Proxy( 
    ITfPersistentPropertyLoaderAnchor * This,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [out] */ IStream **ppStream);


void __RPC_STUB ITfPersistentPropertyLoaderAnchor_LoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__ */


#ifndef __ITextStoreAnchorServices_INTERFACE_DEFINED__
#define __ITextStoreAnchorServices_INTERFACE_DEFINED__

/* interface ITextStoreAnchorServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreAnchorServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e9fe-2021-11d2-93e0-0060b067b86e")
    ITextStoreAnchorServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreAnchorServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreAnchorServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreAnchorServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreAnchorServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITextStoreAnchorServices * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange);
        
        END_INTERFACE
    } ITextStoreAnchorServicesVtbl;

    interface ITextStoreAnchorServices
    {
        CONST_VTBL struct ITextStoreAnchorServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreAnchorServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreAnchorServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreAnchorServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreAnchorServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITextStoreAnchorServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITextStoreAnchorServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITextStoreAnchorServices_CreateRange(This,paStart,paEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,paStart,paEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Serialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITextStoreAnchorServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Unserialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);


void __RPC_STUB ITextStoreAnchorServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_ForceLoadProperty_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITextStoreAnchorServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_CreateRange_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [out] */ ITfRangeAnchor **ppRange);


void __RPC_STUB ITextStoreAnchorServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreAnchorServices_INTERFACE_DEFINED__ */


#ifndef __ITfProperty2_INTERFACE_DEFINED__
#define __ITfProperty2_INTERFACE_DEFINED__

/* interface ITfProperty2 */
/* [unique][uuid][object] */ 

#define	TF_FNV_BACKWARD	( 0x1 )

#define	TF_FNV_NO_CONTAINED	( 0x2 )


EXTERN_C const IID IID_ITfProperty2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("db261faa-2142-486a-b5c6-d2101bc03d2e")
    ITfProperty2 : public ITfProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindNextValue( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfContained,
            /* [out] */ ITfRange **ppRangeNextValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfProperty2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfProperty2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfProperty2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfProperty2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfProperty2 * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRanges )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfProperty2 * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *FindRange )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueStore )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ const VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfContained,
            /* [out] */ ITfRange **ppRangeNextValue);
        
        END_INTERFACE
    } ITfProperty2Vtbl;

    interface ITfProperty2
    {
        CONST_VTBL struct ITfProperty2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfProperty2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfProperty2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfProperty2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfProperty2_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfProperty2_EnumRanges(This,ec,ppEnum,pTargetRange)	\
    (This)->lpVtbl -> EnumRanges(This,ec,ppEnum,pTargetRange)

#define ITfProperty2_GetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,ec,pRange,pvarValue)

#define ITfProperty2_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfProperty2_FindRange(This,ec,pRange,ppRange,aPos)	\
    (This)->lpVtbl -> FindRange(This,ec,pRange,ppRange,aPos)

#define ITfProperty2_SetValueStore(This,ec,pRange,pPropStore)	\
    (This)->lpVtbl -> SetValueStore(This,ec,pRange,pPropStore)

#define ITfProperty2_SetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,ec,pRange,pvarValue)

#define ITfProperty2_Clear(This,ec,pRange)	\
    (This)->lpVtbl -> Clear(This,ec,pRange)


#define ITfProperty2_FindNextValue(This,ec,pRangeQuery,tfAnchorQuery,dwFlags,pfContained,ppRangeNextValue)	\
    (This)->lpVtbl -> FindNextValue(This,ec,pRangeQuery,tfAnchorQuery,dwFlags,pfContained,ppRangeNextValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfProperty2_FindNextValue_Proxy( 
    ITfProperty2 * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRangeQuery,
    /* [in] */ TfAnchor tfAnchorQuery,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BOOL *pfContained,
    /* [out] */ ITfRange **ppRangeNextValue);


void __RPC_STUB ITfProperty2_FindNextValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfProperty2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0225 */
/* [local] */ 

#define	TF_DA_PRIORITY_HIGHEST	( 0 )

#define	TF_DA_PRIORITY_DEFAULT_SPELLING	( 8 )

#define	TF_DA_PRIORITY_DEFAULT_GRAMMAR	( 16 )

#define	TF_DA_PRIORITY_DEFAULT	( 24 )

#define	TF_DA_PRIORITY_LOWEST	( 31 )

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_msctfp_0225_0001
    {
    ULONG uPriority;
    GUID guidProperty;
    } 	TF_DA_PROPERTY;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0225_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0225_v0_0_s_ifspec;

#ifndef __IEnumTfCollection_INTERFACE_DEFINED__
#define __IEnumTfCollection_INTERFACE_DEFINED__

/* interface IEnumTfCollection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c760b20-ed66-4dbd-9ff1-68fc21c02922")
    IEnumTfCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfCollection **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfCollection * This,
            /* [out] */ IEnumTfCollection **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfCollection * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfCollection * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfCollectionVtbl;

    interface IEnumTfCollection
    {
        CONST_VTBL struct IEnumTfCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfCollection_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define IEnumTfCollection_Next(This,ulCount,rgCollection,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgCollection,pcFetched)

#define IEnumTfCollection_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfCollection_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfCollection_Clone_Proxy( 
    IEnumTfCollection * This,
    /* [out] */ IEnumTfCollection **ppClone);


void __RPC_STUB IEnumTfCollection_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Next_Proxy( 
    IEnumTfCollection * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfCollection_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Reset_Proxy( 
    IEnumTfCollection * This);


void __RPC_STUB IEnumTfCollection_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Skip_Proxy( 
    IEnumTfCollection * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfCollection_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfCollection_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__
#define __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeCollectionMgr */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeCollectionMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4e3d2d48-3c17-457d-84a1-f209476de897")
    ITfDisplayAttributeCollectionMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCollections( 
            /* [out] */ IEnumTfCollection **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeCollectionMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeCollectionMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeCollectionMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeCollectionMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCollections )( 
            ITfDisplayAttributeCollectionMgr * This,
            /* [out] */ IEnumTfCollection **ppEnum);
        
        END_INTERFACE
    } ITfDisplayAttributeCollectionMgrVtbl;

    interface ITfDisplayAttributeCollectionMgr
    {
        CONST_VTBL struct ITfDisplayAttributeCollectionMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttribut